"""
Generated LLM strategies for social dilemma games.

This file contains strategy classes generated by LLMs for game theory experiments.
Each strategy is a callable class that implements a specific approach to the game.

Generated with:
- Provider: Anthropic
- Model: claude-haiku-4-5
- Game: common_pool
"""

from dataclasses import dataclass
from enum import Enum
import math
import numpy as np
from numpy.typing import NDArray
import random

from emergent_llm.players import BaseStrategy
from emergent_llm.games import PublicGoodsDescription, CollectiveRiskDescription, CommonPoolDescription, CommonPoolState
from emergent_llm.common import Action, C, D, PlayerHistory, GameState




class Strategy_COLLECTIVE_1(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Maintains stock sustainability while protecting against exploitation through:
    1. Dynamic safety thresholds based on round context
    2. Defection rate monitoring with tolerance buffers
    3. State-dependent behavior (emergency, recovery, prosperous, exploited)
    4. Round-specific logic (always C in round 1, always D in last round)
    5. Adaptive learning via rolling window observation
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            if current_stock > 0:
                return Action.D
            else:
                return Action.C
        if current_stock < 2 * self.n_players:
            return Action.D
        remaining_rounds = self.n_rounds - current_round
        safety_threshold = self.capacity * (0.5 + 0.2 * remaining_rounds / self.n_rounds)
        defection_rate = self._calculate_defection_rate(history, current_round)
        tolerance_threshold = 1.0 / self.n_players + 0.15
        if defection_rate > tolerance_threshold:
            return Action.D
        if current_stock > safety_threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate observed defection rate using rolling window of up to 3 recent rounds.
        Returns ratio of defections (False) to total actions observed.
        """
        if current_round <= 0:
            return 0.0
        lookback = min(3, current_round)
        start_idx = current_round - lookback
        recent_actions = history.opponent_actions[start_idx:current_round, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        defection_count = np.sum(recent_actions == 0)
        defection_rate = defection_count / total_actions
        return float(defection_rate)

class Strategy_COLLECTIVE_2(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS) for Common Pool Resource Games.
    
    Balances individual payoff maximization with collective resource preservation.
    Uses stock-conditional cooperation: defect when stock is abundant and sustainable,
    cooperate when stock is depleted to prevent collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.total_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == self.total_rounds - 1:
            return Action.D
        critical_threshold = self.capacity / self.n
        if stock < critical_threshold:
            return Action.C
        sustainability_threshold = self.capacity * (2.0 / self.n)
        if stock > sustainability_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_3(BaseStrategy):
    """
    Adaptive Stewardship: A conditional cooperation strategy that balances
    individual payoff maximization with resource sustainability. Cooperates by
    default, maintains an emergency mode when stock is critically low, and adapts
    to observed defection rates while exploiting in the final round when conditions permit.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.critical_threshold = self.capacity * 0.3
        self.defection_tolerance = 0.4
        self.capacity_threshold_high = self.capacity * 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if current_stock < self.critical_threshold:
            return Action.C
        history_length = round_number
        total_opponent_actions = (self.n_players - 1) * history_length
        if total_opponent_actions == 0:
            observed_defection_rate = 0.0
        else:
            defections_observed = np.sum(~history.opponent_actions[:history_length, :])
            observed_defection_rate = defections_observed / total_opponent_actions
        if round_number == self.n_rounds - 1 and current_stock > self.critical_threshold:
            return Action.D
        if current_stock > self.capacity * 0.95:
            if observed_defection_rate > self.capacity_threshold_high:
                return Action.D
            return Action.C
        if observed_defection_rate > self.defection_tolerance:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_4(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual rationality with systemic sustainability by:
    - Establishing cooperative baseline (round 1)
    - Preserving critical stock levels
    - Adapting to observed cooperation rates
    - Tracking reputation over recent rounds
    - Extracting in final round
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity * 0.25
        self.cooperation_threshold = 0.5
        self.defection_tolerance = 0.35
        self.reputation_window = max(3, math.ceil(self.r / 4))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        stock = state.current_stock
        capacity = self.capacity
        if capacity > 0:
            stock_ratio = stock / capacity
        else:
            stock_ratio = 0.0
        if current_round == self.r - 1:
            return Action.D
        cooperative_rate = self._calculate_cooperative_rate(history, current_round)
        if stock_ratio < 0.25:
            return Action.C
        if cooperative_rate >= self.cooperation_threshold or cooperative_rate >= self.defection_tolerance:
            base_action = Action.C
        else:
            base_action = Action.D
        recent_defection_rate = self._calculate_recent_defection_rate(history, current_round)
        if recent_defection_rate > self.defection_tolerance and base_action == Action.C:
            if stock_ratio > 0.25:
                return Action.D
        elif recent_defection_rate < 0.15 and base_action == Action.D:
            if stock_ratio > 0.25:
                return Action.C
        unanimous_defection_rounds = self._count_unanimous_defection_rounds(history, current_round)
        if unanimous_defection_rounds >= 2:
            if current_round >= self.r - 2:
                return Action.C
            return Action.D
        if self._is_stock_saturated(history, current_round, capacity):
            if random.random() < 0.3:
                return Action.D
        if self.n <= 3 and self.r >= 20:
            adjusted_coop_threshold = 0.6
            adjusted_defection_tolerance = 0.25
            if cooperative_rate < adjusted_coop_threshold and cooperative_rate < adjusted_defection_tolerance:
                return Action.D
        if self.n >= 8 and self.r <= 5:
            if cooperative_rate < 0.5:
                return Action.D
        return base_action

    def _calculate_cooperative_rate(self, history: PlayerHistory, current_round: int) -> float:
        """Calculate proportion of opponents who cooperated in previous round."""
        if current_round == 0:
            return 0.0
        prev_round_actions = history.opponent_actions[current_round - 1, :]
        cooperators = np.sum(prev_round_actions)
        if self.n - 1 > 0:
            return float(cooperators) / float(self.n - 1)
        return 0.0

    def _calculate_recent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """Calculate defection rate over recent reputation window."""
        if current_round == 0:
            return 0.0
        window_start = max(0, current_round - self.reputation_window)
        window_length = current_round - window_start
        if window_length == 0:
            return 0.0
        recent_actions = history.opponent_actions[window_start:current_round, :]
        defections = np.sum(recent_actions == 0)
        total_observations = (self.n - 1) * window_length
        if total_observations > 0:
            return float(defections) / float(total_observations)
        return 0.0

    def _count_unanimous_defection_rounds(self, history: PlayerHistory, current_round: int) -> int:
        """Count consecutive rounds where all opponents defected."""
        if current_round == 0:
            return 0
        consecutive = 0
        for round_idx in range(current_round - 1, -1, -1):
            round_actions = history.opponent_actions[round_idx, :]
            if np.all(round_actions == 0):
                consecutive += 1
            else:
                break
        return consecutive

    def _is_stock_saturated(self, history: PlayerHistory, current_round: int, capacity: float) -> bool:
        """Check if stock >= capacity for 2+ consecutive rounds."""
        if current_round < 2:
            return False
        consecutive_high_coop = 0
        for round_idx in range(current_round - 1, max(-1, current_round - 3), -1):
            if round_idx >= 0:
                coop_count = np.sum(history.opponent_actions[round_idx, :])
                if coop_count == self.n - 1:
                    consecutive_high_coop += 1
                else:
                    break
        return consecutive_high_coop >= 2

class Strategy_COLLECTIVE_5(BaseStrategy):
    """
    Adaptive Collective Stewardship Strategy for Common Pool Resource Game.
    
    Balances sustainability, fairness, and robustness by:
    - Maintaining stock above dynamic thresholds
    - Adapting tolerance to observed defection rates
    - Always defecting in the final round
    - Withdrawing cooperation only when exploitation becomes clear
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == self.n_rounds - 1:
            return Action.D
        threshold = self.capacity * max(0.45, 1.0 - round_num / (2.0 * self.n_rounds))
        if stock < threshold:
            return Action.D
        if round_num == 0:
            defection_rate = 0.0
        else:
            defection_count = self.n_players - sum(history.opponent_actions[round_num - 1, :])
            defection_rate = defection_count / self.n_players
        tolerance = 0.25 + 0.25 * round_num / self.n_rounds
        if defection_rate <= tolerance:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_6(BaseStrategy):
    """
    Collective Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Treats the common pool as a shared ecosystem requiring active stewardship.
    Cooperates when the pool is vulnerable, defects when abundant, and adapts
    based on observed group cooperation rates. Balances individual payoff with
    collective resource preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        cooperation_rate = self._calculate_cooperation_rate(history)
        threshold_1 = 0.25 * self.capacity
        threshold_2 = 0.5 * self.capacity
        threshold_3 = 0.75 * self.capacity
        if cooperation_rate <= 0.3:
            threshold_1 -= 0.2 * self.capacity
            threshold_2 -= 0.2 * self.capacity
            threshold_3 -= 0.2 * self.capacity
        elif cooperation_rate <= 0.6:
            threshold_1 -= 0.1 * self.capacity
            threshold_2 -= 0.1 * self.capacity
            threshold_3 -= 0.1 * self.capacity
        threshold_1 = max(0.0, threshold_1)
        threshold_2 = max(threshold_1, threshold_2)
        threshold_3 = max(threshold_2, threshold_3)
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= 2:
            if current_stock > 0.5 * self.capacity:
                return Action.D
            else:
                return Action.C
        if current_stock <= threshold_1:
            return Action.C
        elif current_stock <= threshold_2:
            if threshold_2 > 0:
                cooperation_probability = current_stock / threshold_2
            else:
                cooperation_probability = 0.0
            return Action.C if random.random() < cooperation_probability else Action.D
        elif current_stock <= threshold_3:
            return Action.D
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the cooperation rate: fraction of rounds where majority cooperated.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 1.0
        n_rounds_played = len(history.opponent_actions)
        majority_cooperated_count = 0
        for round_idx in range(n_rounds_played):
            opponent_cooperators = int(np.sum(history.opponent_actions[round_idx, :]))
            if opponent_cooperators > (self.n_players - 1) / 2:
                majority_cooperated_count += 1
        cooperation_rate = majority_cooperated_count / n_rounds_played if n_rounds_played > 0 else 1.0
        return cooperation_rate

class Strategy_COLLECTIVE_7(BaseStrategy):
    """
    Adaptive Collective Stewardship Strategy (ACS)
    
    Prioritizes long-term collective welfare through stock-conditional cooperation.
    - When stock is healthy (>75%): cooperate to maintain sustainable equilibrium
    - When stock is critical (<25%): defect for survival
    - When stock is mid-range: adapt based on observed defection rates
    - Becomes stricter about defection tolerance as game approaches end
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if ratio < 0.1:
            return Action.D
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            if ratio > 0.5:
                return Action.C
            else:
                return Action.D
        if ratio > 0.75:
            return Action.C
        if ratio < 0.25:
            return Action.D
        if history is None:
            return Action.C
        previous_round_idx = current_round - 1
        opponent_actions_last_round = history.opponent_actions[previous_round_idx, :]
        defectors_count = sum(~opponent_actions_last_round)
        observed_defection_rate = defectors_count / self.n_players
        progress = current_round / self.n_rounds if self.n_rounds > 0 else 0.0
        defection_tolerance = min(0.5, 1.0 - progress)
        if observed_defection_rate <= defection_tolerance:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_8(BaseStrategy):
    """
    Adaptive Conservation with Reputation Tracking strategy for Common Pool Resource Game.
    
    Balances individual payoff maximization with system sustainability by:
    - Enforcing mandatory cooperation in critical stock conditions
    - Tracking reputation across recent rounds
    - Adapting to stock trends and opponent behavior
    - Applying end-game extraction only when sustainable
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = game_description.capacity * 0.25
        self.healthy_threshold = game_description.capacity * 0.65
        self.cooperation_threshold = 0.5
        self.window_size = 5
        self.defection_rate_threshold = 0.5
        self.cooperation_rate_threshold = 0.6
        self.stock_decline_threshold = -0.15
        self.stock_growth_threshold = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        recent_coop_rate = self._calculate_recent_cooperation_rate(history, current_round)
        stock_trend = self._calculate_stock_trend(history, current_round)
        if current_stock < self.critical_threshold:
            return Action.C
        if current_round >= self.game_description.n_rounds - 2:
            if current_stock >= self.healthy_threshold:
                return Action.D
            else:
                return Action.C
        if stock_trend < self.stock_decline_threshold:
            return Action.C
        if current_stock >= self.healthy_threshold and stock_trend > self.stock_growth_threshold:
            if recent_coop_rate >= self.cooperation_rate_threshold:
                return Action.D
            else:
                return Action.C
        if current_stock >= self.healthy_threshold:
            if recent_coop_rate >= self.cooperation_threshold:
                return Action.C
            else:
                return Action.D
        if recent_coop_rate > 0.5:
            return Action.C
        elif recent_coop_rate < 0.5:
            return Action.D
        else:
            return Action.C

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the aggregate cooperation rate of opponents over recent rounds.
        Uses rolling window of last min(5, current_round) rounds.
        """
        if current_round == 0:
            return 0.5
        window_start = max(0, current_round - self.window_size)
        recent_history = history.opponent_actions[window_start:current_round, :]
        if recent_history.size == 0:
            return 0.5
        total_cooperations = np.sum(recent_history)
        total_actions = recent_history.size
        if total_actions == 0:
            return 0.5
        return float(total_cooperations) / float(total_actions)

    def _calculate_stock_trend(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate stock trend over last 3 rounds.
        Returns (current_stock - stock_3_rounds_ago) / stock_3_rounds_ago
        """
        if current_round < 3:
            return 0.0
        stock_history = self._reconstruct_stock_history(history, current_round)
        if len(stock_history) < 2:
            return 0.0
        stock_now = stock_history[-1]
        stock_3_rounds_ago = stock_history[-4] if len(stock_history) >= 4 else stock_history[0]
        if stock_3_rounds_ago <= 0:
            return 0.0
        trend = (stock_now - stock_3_rounds_ago) / stock_3_rounds_ago
        return float(trend)

    def _reconstruct_stock_history(self, history: PlayerHistory, current_round: int) -> list:
        """
        Attempt to reconstruct stock levels from history.
        This is approximate since we don't have exact stock values, but we can infer
        from the payoff structure and action counts.
        """
        stock_estimates = []
        for round_idx in range(current_round):
            cooperators = np.sum(history.opponent_actions[round_idx, :])
            defectors = self.game_description.n_players - 1 - cooperators
            my_is_coop = history.my_actions[round_idx]
            if my_is_coop:
                cooperators += 1
            else:
                defectors += 1
            payoff = history.my_payoffs[round_idx]
            if my_is_coop and payoff > 0:
                estimated_stock = payoff * 2 * self.game_description.n_players
            elif not my_is_coop and payoff > 0:
                estimated_stock = payoff * self.game_description.n_players
            else:
                estimated_stock = 0.0
            estimated_stock = min(estimated_stock, self.game_description.capacity)
            stock_estimates.append(estimated_stock)
        return stock_estimates

class Strategy_COLLECTIVE_9(BaseStrategy):
    """
    Adaptive Commons Stewardship Strategy: Prioritizes long-term collective sustainability
    through conditional cooperation with adaptive thresholds and graduated reciprocity.
    Defends against free-riders while remaining robust to pure defection and mixed strategies.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_memory = 0
        self.memory_horizon = max(3, self.r // 4)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        safety_threshold = self.capacity * 0.3
        crisis_threshold = self.capacity * 0.15
        recovery_threshold = self.capacity * 0.9
        late_game_threshold = self.capacity * 0.7
        defection_tolerance = (self.n - 1) * 0.4
        if current_stock < crisis_threshold:
            return Action.C
        observed_defection_rate = self._calculate_defection_rate(history, current_round)
        if observed_defection_rate > defection_tolerance:
            self.defection_memory = min(self.defection_memory + 1, self.memory_horizon)
        else:
            self.defection_memory = max(self.defection_memory - 1, 0)
        if current_stock > recovery_threshold and self.defection_memory > 0:
            self.defection_memory = max(self.defection_memory - 1, 0)
        if current_round == self.r - 1:
            if current_stock >= safety_threshold:
                return Action.C
            else:
                return Action.D
        late_game_round = 3 * self.r / 4
        if current_round > late_game_round and current_stock > late_game_threshold:
            return Action.C
        if observed_defection_rate >= 1.0 and self.defection_memory >= 2:
            return Action.D
        if self.defection_memory > 0 and observed_defection_rate > defection_tolerance:
            return Action.D
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the defection rate among opponents in the previous round.
        Returns the fraction of opponents who played D (False/0) in the previous round.
        """
        if current_round == 0:
            return 0.0
        prev_round_idx = current_round - 1
        opponent_actions_prev_round = history.opponent_actions[prev_round_idx, :]
        defection_count = int(np.sum(opponent_actions_prev_round == 0))
        total_opponents = len(opponent_actions_prev_round)
        if total_opponents == 0:
            return 0.0
        return defection_count / total_opponents

class Strategy_COLLECTIVE_10(BaseStrategy):
    """
    Adaptive Collective Resource Stewardship Strategy
    
    Balances individual incentives with collective sustainability by:
    1. Assessing stock health against sustainability thresholds
    2. Detecting aggregate defection rates across all players
    3. Conditionally cooperating or defecting based on stock state and group behavior
    4. Defecting in final round (end-game logic)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.optimal_stock = self.capacity * 0.6
        self.critical_stock = self.capacity * 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        defection_rate = self._calculate_defection_rate(history)
        if current_stock < self.critical_stock:
            return Action.D
        if current_stock >= self.optimal_stock:
            if defection_rate < 0.4:
                return Action.C
            else:
                return Action.D
        if defection_rate < 0.25:
            return Action.C
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the aggregate defection rate across all players and all past rounds.
        
        Defection is encoded as False (0), Cooperation as True (1).
        Defection rate = (total defections) / (n_players × rounds_elapsed)
        """
        if history is None or history.opponent_actions.size == 0:
            return 0.0
        rounds_elapsed = history.opponent_actions.shape[0]
        my_defections = np.sum(~history.my_actions[:rounds_elapsed])
        opponent_defections = np.sum(~history.opponent_actions[:rounds_elapsed, :])
        total_defections = my_defections + opponent_defections
        total_actions = self.n_players * rounds_elapsed
        if total_actions == 0:
            return 0.0
        return total_defections / total_actions

class Strategy_COLLECTIVE_11(BaseStrategy):
    """
    Adaptive Stock-Preserving Cooperation (ASPC)
    
    A threshold-based strategy that adapts to stock health:
    - Healthy phase (≥60% capacity): COOPERATE to preserve commons
    - Stressed phase (25%-60% capacity): DEFECT to maximize extraction
    - Collapsed phase (<25% capacity): COOPERATE (defection gains trivial, preserves optionality)
    
    This strategy prioritizes sustainable collective welfare while protecting against
    exploitation when the pool degrades.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.healthy_threshold = 0.6
        self.critical_threshold = 0.25
        self.collapse_threshold = 0.05

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if capacity <= 0:
            return Action.C
        stock_health = current_stock / capacity
        if stock_health >= self.healthy_threshold:
            return Action.C
        elif stock_health >= self.critical_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_12(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual benefit with collective sustainability through adaptive responses
    to stock depletion trajectory and opponent behavior. Uses health-based thresholds,
    defection rate tracking, and forward-looking depletion trends to decide between
    cooperation and defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 0.25
        self.safe_threshold = 0.6
        self.defection_tolerance = 0.5
        self.depletion_acceleration_factor = 1.3
        self.stock_collapse_threshold = 0.2
        self.recovery_threshold = 0.5
        self.health_signal_threshold = 0.35
        self.defection_detection_threshold = 0.75
        self.patience_rounds = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if round_number == 0:
            return Action.C
        if rounds_remaining == 1:
            return Action.D
        if health_ratio < self.critical_threshold:
            return Action.C
        if rounds_remaining == 2:
            if health_ratio < 0.4:
                return Action.C
            else:
                return Action.D
        if round_number >= 2:
            recent_stocks = [current_stock]
            if round_number >= 2:
                collapse_count = 0
                for i in range(max(0, round_number - 2), round_number + 1):
                    if i < len(history.my_payoffs):
                        pass
            if health_ratio < self.stock_collapse_threshold:
                return Action.D
        recent_window_size = min(3, round_number)
        if recent_window_size > 0:
            recent_start = round_number - recent_window_size
            defection_counts = []
            for r in range(recent_start, round_number):
                defecting = np.sum(history.opponent_actions[r, :] == 0)
                defection_counts.append(defecting)
            majority_defection_rounds = sum((1 for count in defection_counts if count > self.n_players / 2))
            defection_rate = majority_defection_rounds / len(defection_counts) if defection_counts else 0.0
            if defection_rate > self.defection_tolerance:
                return Action.D
        if round_number >= 2:
            recent_my_payoffs = history.my_payoffs[max(0, round_number - 2):round_number]
            if len(recent_my_payoffs) >= 2:
                payoff_change = recent_my_payoffs[-2] - recent_my_payoffs[-1]
                if payoff_change > 0:
                    if round_number >= 3:
                        prior_payoff_change = history.my_payoffs[round_number - 3] - history.my_payoffs[round_number - 2]
                        if prior_payoff_change > 0 and payoff_change > prior_payoff_change * self.depletion_acceleration_factor:
                            return Action.D
        if round_number >= 2 and health_ratio > self.recovery_threshold:
            recent_payoffs = history.my_payoffs[max(0, round_number - 2):round_number]
            if len(recent_payoffs) >= 2:
                if recent_payoffs[-1] > recent_payoffs[-2]:
                    if round_number >= 3:
                        prior_payoff = history.my_payoffs[round_number - 3]
                        if recent_payoffs[-2] > prior_payoff:
                            return Action.C
        return Action.C

class Strategy_COLLECTIVE_13(BaseStrategy):
    """
    Adaptive Collective Strategy: "Stewardship"
    
    Balances sustainability, reciprocity, and adaptability in common pool resource management.
    - Early game (rounds 1-2): Cooperate to establish intent and gather information
    - Mid game (rounds 3 to r-1): Conditional cooperation based on observed defection rate
    - End game (final round): Defect (subgame perfect equilibrium)
    - Stock-dependent: Defect if stock falls below critical threshold
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = game_description.capacity * 0.4
        self.cooperation_threshold = 0.3
        self.defection_cascade_threshold = 0.8
        self.high_defection_threshold = 0.6
        self.stock_crisis_threshold = 0.2 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - round_number - 1
        if rounds_remaining == 0:
            return Action.D
        if round_number == 0:
            return Action.C
        if round_number <= 1:
            return Action.C
        defection_rate = self._calculate_defection_rate(history, round_number)
        if current_stock < self.stock_crisis_threshold:
            return Action.D
        if current_stock >= self.critical_threshold:
            if defection_rate > self.defection_cascade_threshold:
                return Action.D
            if defection_rate > self.high_defection_threshold:
                return Action.D
            if defection_rate > self.cooperation_threshold:
                return Action.D
            return Action.C
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the observed defection rate across all players and rounds.
        
        Uses a 3-round moving average to smooth noise in oscillating patterns.
        """
        if round_number == 0:
            return 0.0
        window_size = min(3, round_number)
        start_round = max(0, round_number - window_size)
        total_defections = 0
        total_actions = 0
        for r in range(start_round, round_number):
            defections_in_round = np.sum(~history.opponent_actions[r, :])
            total_defections += defections_in_round
            total_actions += self.n_players - 1
        if total_actions == 0:
            return 0.0
        defection_rate = total_defections / total_actions
        return defection_rate

class Strategy_COLLECTIVE_14(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS): Balances cooperation with defensive extraction
    based on stock health and historical extraction patterns. Adapts thresholds dynamically
    to punish over-extraction and reward sustainable behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.confidence_adjustment = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if current_stock < 0.05 * self.capacity:
            return Action.D
        if round_number == 0:
            return Action.C
        total_consumed = self._compute_total_consumed(history)
        avg_extraction_rate = total_consumed / (round_number * self.capacity)
        if avg_extraction_rate <= 0.6:
            base_threshold = 0.75
        elif avg_extraction_rate <= 0.8:
            base_threshold = 0.7
        else:
            base_threshold = 0.6
        if round_number >= 1:
            stock_change = self._compute_stock_trajectory(history)
            if stock_change > 0:
                self.confidence_adjustment += 0.05
            elif stock_change < 0:
                self.confidence_adjustment -= 0.1
            adjustment_factor = 1.0 - 0.02 * self.confidence_adjustment
            adjustment_factor = max(0.55, min(0.8, adjustment_factor))
            base_threshold *= adjustment_factor
        rounds_remaining = self.n_rounds - round_number
        if rounds_remaining <= 2:
            base_threshold -= 0.05
        if round_number >= 1:
            prev_stock = history.my_payoffs[round_number - 1] * self.n_players * 2
            stock_drop = prev_stock - current_stock if round_number > 0 else 0
            if stock_drop > 0.5 * self.capacity:
                base_threshold = min(base_threshold, 0.55)
        threshold_level = base_threshold * self.capacity
        if current_stock >= threshold_level:
            return Action.C
        else:
            return Action.D

    def _compute_total_consumed(self, history: PlayerHistory) -> float:
        """
        Estimate total consumption across all rounds.
        Uses the relationship: stock_change = consumption - growth
        """
        if history is None or len(history.my_payoffs) == 0:
            return 0.0
        my_total_consumption = float(np.sum(history.my_payoffs))
        total_consumed = my_total_consumption * self.n_players
        return total_consumed

    def _compute_stock_trajectory(self, history: PlayerHistory) -> float:
        """
        Determine if stock is rising or falling based on recent rounds.
        Positive = rising, negative = falling.
        """
        if history is None or len(history.my_payoffs) < 2:
            return 0.0
        recent_payoffs = history.my_payoffs[-2:]
        payoff_trend = recent_payoffs[-1] - recent_payoffs[-2]
        return payoff_trend

class Strategy_COLLECTIVE_15(BaseStrategy):
    """
    Adaptive Sustainable Harvest Strategy (ASHS)
    
    Prioritizes long-term collective sustainability over short-term individual gain.
    Cooperates when stock is healthy or recovery is feasible, defects as a last resort.
    Adapts thresholds based on observed opponent defection rates and avoids last-round
    opportunistic defection to prevent tragedy-of-the-commons collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        healthy_threshold = 0.6 * self.capacity
        recovery_threshold = 0.3 * self.capacity
        d_ratio = self._compute_defection_ratio(history)
        defection_escalation_threshold = (self.n_players - 1) / self.n_players - 0.15
        if d_ratio > defection_escalation_threshold:
            healthy_threshold = 0.7 * self.capacity
            recovery_threshold = 0.5 * self.capacity
        if stock < recovery_threshold:
            return Action.D
        estimated_remaining = stock / 2.0
        if self.capacity > 0:
            estimated_growth = 2.0 * estimated_remaining * (1.0 - estimated_remaining / self.capacity)
        else:
            estimated_growth = 0.0
        estimated_next_stock = min(estimated_remaining + estimated_growth, self.capacity)
        if estimated_next_stock < 0.2 * self.capacity:
            return Action.D
        if stock >= healthy_threshold:
            return Action.C
        elif estimated_next_stock >= stock:
            return Action.C
        else:
            return Action.D

    def _compute_defection_ratio(self, history: PlayerHistory) -> float:
        """
        Compute the ratio of observed defections by all opponents across all rounds.
        Returns a value in [0, 1].
        """
        if history.opponent_actions.size == 0:
            return 0.0
        total_opponent_actions = history.opponent_actions.size
        if total_opponent_actions == 0:
            return 0.0
        num_defections = np.sum(~history.opponent_actions)
        d_ratio = float(num_defections) / float(total_opponent_actions)
        return d_ratio

class Strategy_COLLECTIVE_16(BaseStrategy):
    """
    Adaptive Stewardship with Defensive Thresholds
    
    Balances collective welfare, robustness against defectors, and adaptation to observed behavior.
    Uses stock health as primary signal and adaptive thresholds to calibrate responses across
    three phases: initial assessment, adaptive response, and endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == 1:
            health_index = current_stock / self.capacity if self.capacity > 0 else 0.0
            if health_index >= 0.75:
                return Action.C
            else:
                return Action.D
        if round_num == self.n_rounds - 1:
            health_index = current_stock / self.capacity if self.capacity > 0 else 0.0
            if health_index > 0.4:
                return Action.C
            else:
                return Action.D
        health_index = current_stock / self.capacity if self.capacity > 0 else 0.0
        defection_rate = self._estimate_defection_rate(state, history)
        if health_index > 0.75:
            if defection_rate < 0.3:
                return Action.C
            else:
                return Action.D
        elif health_index > 0.5:
            if defection_rate < 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _estimate_defection_rate(self, state: CommonPoolState, history: PlayerHistory) -> float:
        """
        Estimate the defection rate from stock depletion patterns.
        
        Expected consumption if all cooperate: stock / 2
        Actual consumption is inferred from stock change and growth.
        """
        if state.round_number < 1 or history is None:
            return 0.0
        prev_round_idx = state.round_number - 1
        recent_opponent_actions = history.opponent_actions[prev_round_idx, :]
        num_defectors = np.sum(~recent_opponent_actions)
        defection_rate = float(num_defectors) / self.n_players if self.n_players > 0 else 0.0
        return defection_rate

class Strategy_COLLECTIVE_17(BaseStrategy):
    """
    Adaptive Collective Stewardship Strategy (ACS)
    
    Balances individual gains with collective sustainability by maintaining stock health.
    Uses dynamic thresholds and history-dependent cooperation to avoid exploitation
    while preventing resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.coop_threshold = 1.5 * (self.capacity / self.n)
        self.healthy_threshold = 2.5 * (self.capacity / self.n)
        self.stock_epsilon = 0.1
        self.final_rounds_threshold = 2
        self.high_coop_threshold = 0.65
        self.low_coop_threshold = 0.4
        self.defection_trigger = 0.5
        self.previous_stock = None
        self.recovery_phase_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            self.previous_stock = current_stock
            return Action.C
        cooperation_index = self._calculate_cooperation_index(history, current_round)
        stock_declining = self._is_stock_declining(current_stock)
        if current_stock < self.coop_threshold:
            self.previous_stock = current_stock
            self.recovery_phase_count = 0
            return Action.C
        if current_stock >= self.healthy_threshold:
            self.recovery_phase_count += 1
            if self.recovery_phase_count >= 3:
                self.recovery_phase_count = 0
            if cooperation_index >= 0.3:
                self.previous_stock = current_stock
                return Action.C
            else:
                self.previous_stock = current_stock
                return Action.C
        if current_stock >= self.coop_threshold and current_stock < self.healthy_threshold:
            self.recovery_phase_count = 0
            if stock_declining:
                recent_defection_rate = self._calculate_recent_defection_rate(history, current_round, lookback=2)
                if recent_defection_rate > self.defection_trigger:
                    self.previous_stock = current_stock
                    return Action.D
                else:
                    self.previous_stock = current_stock
                    return Action.C
            else:
                self.previous_stock = current_stock
                return Action.C
        if current_round >= self.r - self.final_rounds_threshold:
            if current_round >= 3:
                projected_stock = self._estimate_stock_trajectory(history, current_round)
                if projected_stock > self.capacity * 0.6:
                    self.previous_stock = current_stock
                    return Action.C
                else:
                    self.previous_stock = current_stock
                    return Action.D
        self.previous_stock = current_stock
        return Action.C

    def _calculate_cooperation_index(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate weighted cooperation index from opponent history.
        Weights recent rounds more heavily.
        """
        if current_round == 0:
            return 1.0
        opponent_actions = history.opponent_actions[:current_round]
        total_cooperations = np.sum(opponent_actions)
        total_actions = opponent_actions.size
        if total_actions == 0:
            return 1.0
        if current_round <= 3:
            coop_index = total_cooperations / total_actions
        else:
            recent_rounds = opponent_actions[-3:]
            recent_coop = np.sum(recent_rounds)
            recent_weight = 0.6
            earlier_rounds = opponent_actions[:-3]
            earlier_coop = np.sum(earlier_rounds)
            earlier_weight = 0.4
            recent_ratio = recent_coop / recent_rounds.size if recent_rounds.size > 0 else 0
            earlier_ratio = earlier_coop / earlier_rounds.size if earlier_rounds.size > 0 else 0
            coop_index = recent_weight * recent_ratio + earlier_weight * earlier_ratio
        return coop_index

    def _calculate_recent_defection_rate(self, history: PlayerHistory, current_round: int, lookback: int) -> float:
        """
        Calculate defection rate in recent rounds.
        Returns fraction of actions that were defections (False = defection).
        """
        if current_round <= 1:
            return 0.0
        start_idx = max(0, current_round - lookback)
        recent_actions = history.opponent_actions[start_idx:current_round]
        if recent_actions.size == 0:
            return 0.0
        defections = np.sum(~recent_actions)
        defection_rate = defections / recent_actions.size
        return defection_rate

    def _is_stock_declining(self, current_stock: float) -> bool:
        """
        Check if stock is declining compared to previous round.
        """
        if self.previous_stock is None:
            return False
        return current_stock < self.previous_stock - self.stock_epsilon

    def _estimate_stock_trajectory(self, history: PlayerHistory, current_round: int) -> float:
        """
        Estimate future stock based on observed trajectory.
        Simple linear extrapolation from last 3 rounds.
        """
        if current_round < 2:
            return self.capacity * 0.5
        recent_defection_rate = self._calculate_recent_defection_rate(history, current_round, lookback=3)
        if recent_defection_rate > 0.7:
            return self.capacity * 0.2
        elif recent_defection_rate > 0.5:
            return self.capacity * 0.4
        elif recent_defection_rate > 0.3:
            return self.capacity * 0.6
        else:
            return self.capacity * 0.8

class Strategy_COLLECTIVE_18(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual security with collective sustainability by adapting
    dynamically to stock levels and observed opponent behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 0.2 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        sustainability_index = current_stock / self.capacity if self.capacity > 0 else 0.0
        if round_number == 0:
            return Action.C
        defection_rate = self._compute_defection_rate(history)
        if current_stock < self.critical_threshold:
            if defection_rate < 0.25:
                return Action.C
            else:
                return Action.D
        if round_number == self.n_rounds - 1:
            if sustainability_index >= 0.5:
                return Action.C
            else:
                return Action.D
        if sustainability_index >= 0.7:
            return Action.C
        if sustainability_index < 0.4:
            return Action.D
        if defection_rate < 0.4:
            return Action.C
        else:
            return Action.D

    def _compute_defection_rate(self, history: PlayerHistory) -> float:
        """
        Compute the empirical defection rate from opponent actions in history.
        Defection is encoded as False (0), Cooperation as True (1).
        """
        if history is None or history.opponent_actions is None:
            return 0.0
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.0
        defections = np.sum(~history.opponent_actions)
        return float(defections) / float(total_actions)

class Strategy_COLLECTIVE_19(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): Balances individual payoff maximization with collective
    sustainability by adapting behavior based on stock health, rounds remaining, and estimated
    defector behavior. Cooperates in early phases to build stock, conditionally punishes
    free-riding in mid-game, and prioritizes extraction in end-game while respecting critical
    stock thresholds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number
        if round_number == 0:
            return Action.C
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_health < 0.15:
            if rounds_remaining > 2:
                return Action.C
            else:
                return Action.D
        phase = self._detect_phase(stock_health, rounds_remaining)
        if phase == 'EARLY_GAME':
            if self._detect_free_riding(history):
                return Action.D
            return Action.C
        elif phase == 'MID_GAME':
            return self._mid_game_decision(stock_health, history)
        elif phase == 'END_GAME':
            return self._end_game_decision(stock_health, rounds_remaining)
        return Action.C

    def _detect_phase(self, stock_health: float, rounds_remaining: int) -> str:
        """Determine the current game phase based on stock health and rounds remaining."""
        early_threshold = self.n_rounds / 3
        mid_threshold = self.n_rounds / 6
        if rounds_remaining > early_threshold and stock_health > 0.6:
            return 'EARLY_GAME'
        elif rounds_remaining <= mid_threshold or stock_health < 0.3:
            return 'END_GAME'
        else:
            return 'MID_GAME'

    def _detect_free_riding(self, history: PlayerHistory) -> bool:
        """
        Detect if free-riding (excessive defection) occurred in recent rounds.
        Returns True if we should switch to conditional defection.
        """
        if history is None or len(history.opponent_actions) == 0:
            return False
        recent_rounds = min(3, len(history.opponent_actions))
        for i in range(1, recent_rounds + 1):
            round_idx = -i
            defectors = self.n_players - np.sum(history.opponent_actions[round_idx, :])
            if defectors > self.n_players / 2:
                if len(history.my_payoffs) >= 2:
                    return True
        return False

    def _mid_game_decision(self, stock_health: float, history: PlayerHistory) -> Action:
        """Mid-game conditional defection logic."""
        if stock_health >= 0.4:
            return Action.C
        estimated_defectors = self._estimate_defectors(history)
        defector_ratio = estimated_defectors / self.n_players if self.n_players > 0 else 0.0
        if stock_health < 0.25:
            if defector_ratio >= 0.5:
                return Action.D
            else:
                return Action.C
        elif stock_health < 0.4:
            if defector_ratio > 1.0 / 3.0:
                if self._stock_dropped_recently(history):
                    return Action.D
            return Action.C
        return Action.C

    def _end_game_decision(self, stock_health: float, rounds_remaining: int) -> Action:
        """End-game selfish extraction logic."""
        if stock_health >= 0.4:
            return Action.C
        if rounds_remaining <= 2:
            return Action.D
        if rounds_remaining <= self.n_rounds / 6:
            if stock_health < 0.3:
                return Action.D
            else:
                return Action.C
        return Action.C

    def _estimate_defectors(self, history: PlayerHistory) -> float:
        """
        Estimate the number of defectors in the previous round.
        Uses observed consumption patterns to infer behavior.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        last_round_idx = -1
        cooperators = np.sum(history.opponent_actions[last_round_idx, :])
        defectors = self.n_players - cooperators
        return float(defectors)

    def _stock_dropped_recently(self, history: PlayerHistory) -> bool:
        """Check if stock dropped significantly in the last 3 rounds."""
        if history is None or len(history.my_payoffs) < 2:
            return False
        recent_rounds = min(3, len(history.my_payoffs))
        for i in range(1, recent_rounds + 1):
            round_idx = -i
            current_payoff = history.my_payoffs[round_idx]
            prev_idx = -i - 1
            if -i - 1 >= -len(history.my_payoffs):
                prev_payoff = history.my_payoffs[prev_idx]
                if prev_payoff > 0 and current_payoff < prev_payoff * 0.8:
                    return True
        return False

class Strategy_COLLECTIVE_20(BaseStrategy):
    """
    Adaptive Commons Stewardship Strategy: Dynamically balances personal sustainability,
    resource preservation, and adaptive response to opponent behavior. Tracks stock health
    and defection rates to make context-sensitive cooperation/defection decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self._was_critical_last_round = False
        self._consecutive_low_payoff_rounds = 0
        self._punishment_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        sustainability = current_stock / self.capacity if self.capacity > 0 else 0.0
        if sustainability > 0.6:
            health = 'HEALTHY'
        elif sustainability > 0.3:
            health = 'DANGER'
        else:
            health = 'CRITICAL'
        avg_defection = self._calculate_avg_defection_rate(history)
        stock_improving = self._is_stock_improving(history)
        if current_stock < 0.15 * self.capacity:
            self._consecutive_low_payoff_rounds = 0
            return Action.D
        if self._was_critical_last_round and stock_improving:
            self._was_critical_last_round = False
            return Action.C
        self._was_critical_last_round = health == 'CRITICAL'
        if self._punishment_rounds_remaining > 0:
            self._punishment_rounds_remaining -= 1
            return Action.D
        if avg_defection > 0.7:
            rounds_above_threshold = self._count_consecutive_high_defection(history)
            if rounds_above_threshold >= 3:
                self._punishment_rounds_remaining = 2
                return Action.D
        rounds_remaining = self.n_rounds - round_number
        if health == 'HEALTHY':
            if avg_defection <= 0.4 or rounds_remaining > self.n_players + 2:
                return Action.C
            else:
                return Action.D
        elif health == 'DANGER':
            if avg_defection <= 0.25 and stock_improving:
                return Action.C
            elif avg_defection > 0.5:
                return Action.D
            else:
                return Action.C
        elif avg_defection <= 0.25:
            return Action.C
        else:
            return Action.D

    def _calculate_avg_defection_rate(self, history: PlayerHistory) -> float:
        """Calculate average defection rate across all opponents."""
        if history.opponent_actions.shape[0] == 0:
            return 0.0
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.0
        defection_count = np.sum(~history.opponent_actions)
        defection_rate = defection_count / total_actions
        return float(defection_rate)

    def _is_stock_improving(self, history: PlayerHistory) -> bool:
        """Check if stock improved in the last round."""
        if history.my_payoffs.shape[0] < 2:
            return True
        recent_payoff = history.my_payoffs[-1]
        previous_payoff = history.my_payoffs[-2]
        return recent_payoff >= previous_payoff * 0.95

    def _count_consecutive_high_defection(self, history: PlayerHistory) -> int:
        """Count consecutive rounds with high defection rate."""
        if history.opponent_actions.shape[0] == 0:
            return 0
        consecutive_count = 0
        window_size = min(3, history.opponent_actions.shape[0])
        if window_size > 0:
            recent_rounds = history.opponent_actions[-window_size:, :]
            for round_actions in recent_rounds:
                defection_rate = np.sum(~round_actions) / len(round_actions)
                if defection_rate > 0.7:
                    consecutive_count += 1
                else:
                    break
        return consecutive_count

class Strategy_COLLECTIVE_21(BaseStrategy):
    """
    Adaptive Stock-Preserving Cooperation (ASPC) Strategy
    
    Prioritizes collective sustainability by cooperating when stock is healthy
    (above a dynamically calculated threshold) and defecting when stock is depleted
    or cascading defection is observed. The threshold decays quadratically over time,
    creating a sustainability gradient that enforces discipline early and permits
    extraction late.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        round_ratio = (current_round + 1) / self.n_rounds
        threshold = self.capacity * (1 - round_ratio ** 2)
        if current_round == self.n_rounds - 1:
            if current_stock > 0:
                return Action.D
            else:
                return Action.C
        if current_stock < 0.05 * self.capacity:
            return Action.D
        defection_rate_last_2 = self._calculate_recent_defection_rate(history, current_round)
        if defection_rate_last_2 > 0.5:
            if current_stock < 0.3 * self.capacity:
                return Action.D
            else:
                return Action.C
        if current_stock >= threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_recent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the defection rate among all opponents in the last 2 rounds.
        Returns a value between 0 and 1.
        """
        if current_round < 1:
            return 0.0
        rounds_to_check = min(2, current_round)
        start_round = current_round - rounds_to_check
        total_actions = 0
        total_defections = 0
        for round_idx in range(start_round, current_round):
            for opponent_idx in range(self.n_players - 1):
                action = history.opponent_actions[round_idx, opponent_idx]
                total_actions += 1
                if not action:
                    total_defections += 1
        if total_actions == 0:
            return 0.0
        return total_defections / total_actions

class Strategy_COLLECTIVE_22(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual security with long-term resource preservation by:
    - Cooperating when stock is healthy (>60% capacity)
    - Defecting when stock is critically low (<20% capacity)
    - Defaulting to defection in the danger zone (20-60% capacity)
    - Starting with cooperation in round 0 to signal intent
    
    This enables sustainable collective benefit while protecting against
    resource collapse and predatory defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.threshold_high = self.capacity * 0.6
        self.threshold_low = self.capacity * 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock = state.current_stock
        if stock > self.threshold_high:
            return Action.C
        if stock < self.threshold_low:
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_23(BaseStrategy):
    """
    Collective Pool Stewardship Strategy
    
    Treats the common pool as a shared resource requiring active stewardship.
    Optimizes for collective sustainability and long-term total payoff while
    remaining robust to defectors through adaptive thresholds and conditional
    defection based on observable behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 0.25
        self.warning_threshold = 0.5
        self.healthy_threshold = 0.75
        self.defection_threshold = math.ceil(self.n_players / 3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        shr = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        if state.round_number == self.n_rounds - 1:
            total_defections = self._count_total_defections(history)
            if shr > self.healthy_threshold and total_defections < math.ceil(self.n_players / 3):
                return Action.C
            else:
                return Action.D
        if shr < self.critical_threshold:
            return Action.C
        estimated_defectors = self._estimate_defectors(history, state.round_number)
        if shr < self.warning_threshold:
            if estimated_defectors >= self.defection_threshold:
                return Action.D
            else:
                return Action.C
        elif estimated_defectors >= self.defection_threshold:
            defection_rate = self._calculate_defection_rate(history, state.round_number)
            if random.random() < defection_rate / 2:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

    def _count_total_defections(self, history: PlayerHistory) -> int:
        """Count total defections across all rounds and players."""
        if history is None or len(history.opponent_actions) == 0:
            return 0
        total_defections = np.sum(~history.opponent_actions)
        return int(total_defections)

    def _estimate_defectors(self, history: PlayerHistory, current_round: int) -> int:
        """
        Estimate number of defectors based on recent history.
        Uses a sliding window of the last min(5, current_round) rounds.
        """
        if history is None or current_round == 0:
            return 0
        window_size = min(5, current_round)
        start_idx = max(0, current_round - window_size)
        recent_actions = history.opponent_actions[start_idx:current_round, :]
        if recent_actions.size == 0:
            return 0
        defection_count = np.sum(~recent_actions)
        total_observations = recent_actions.size
        if total_observations == 0:
            return 0
        defection_rate = defection_count / total_observations
        estimated_defectors = math.ceil(self.n_players * defection_rate)
        return estimated_defectors

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the recent defection rate from the last min(5, current_round) rounds.
        """
        if history is None or current_round == 0:
            return 0.0
        window_size = min(5, current_round)
        start_idx = max(0, current_round - window_size)
        recent_actions = history.opponent_actions[start_idx:current_round, :]
        if recent_actions.size == 0:
            return 0.0
        defection_count = np.sum(~recent_actions)
        total_observations = recent_actions.size
        if total_observations == 0:
            return 0.0
        return float(defection_count) / float(total_observations)

class Strategy_COLLECTIVE_24(BaseStrategy):
    """
    Collective Pool Stewardship Strategy (CPSS)
    
    Balances individual security with collective sustainability through adaptive threshold-based
    cooperation. Uses stock health ratio and dynamic thresholds that adjust based on rounds remaining,
    with punishment mechanisms and critical threshold overrides to prevent mutual destruction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_debt = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if health_ratio < 0.3:
            return Action.C
        if current_stock <= 0:
            return Action.C
        rounds_remaining = self.n_rounds - current_round
        base_threshold = 0.5 + 0.3 * rounds_remaining / self.n_rounds
        threshold = base_threshold
        if current_round > 0:
            last_round_defection_count = self._infer_defection_from_history(history, current_round - 1)
            defection_ratio = last_round_defection_count / self.n_players if self.n_players > 0 else 0.0
            if defection_ratio > (self.n_players - 1) / self.n_players:
                self.punishment_debt = 2
                threshold -= 0.15
            elif self.punishment_debt > 0:
                threshold -= 0.1
                self.punishment_debt -= 1
        if health_ratio >= threshold:
            return Action.C
        else:
            return Action.D

    def _infer_defection_from_history(self, history: PlayerHistory, round_idx: int) -> int:
        """
        Infer the number of defectors in a given round by analyzing stock decline.
        
        In a round with stock S:
        - Each cooperator consumes S/(2n)
        - Each defector consumes S/n
        
        If k players defected and (n-k) cooperated:
        Total consumption = k * S/n + (n-k) * S/(2n) = S/n * (k + (n-k)/2) = S/n * (k/2 + n/2)
        
        However, we observe stock before and after growth. We use a heuristic:
        Count opponent defections (True = 1, False = 0) and sum them.
        """
        if round_idx < 0 or round_idx >= len(history.opponent_actions):
            return 0
        defection_count = int(np.sum(~history.opponent_actions[round_idx, :]))
        return defection_count

class Strategy_COLLECTIVE_25(BaseStrategy):
    """
    Adaptive Sustainable Harvest Strategy (ASHS) for Common Pool Resource Game.
    
    Balances sustainability, opportunistic exploitation, and robustness by:
    - Cooperating when stock is healthy (above 70% capacity)
    - Defecting opportunistically in intermediate zones when others defect
    - Forcing cooperation at critical stock levels (below 25% capacity)
    - Always defecting in the final round (except at critical levels)
    - Adapting thresholds based on observed defection rates in recent rounds
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.C
        if stock < self.capacity * 0.2:
            return Action.C
        if current_round == self.n_rounds - 1:
            if stock < self.capacity * 0.2:
                return Action.C
            return Action.D
        recent_rounds = min(3, current_round)
        defection_rate = self._calculate_defection_rate(history, recent_rounds)
        threshold_upper = self.capacity * 0.7
        threshold_critical = self.capacity * 0.25
        adjusted_upper = threshold_upper * (1.0 - 0.15 * defection_rate)
        adjusted_upper = min(adjusted_upper, self.capacity * 0.85)
        adjusted_critical = threshold_critical * (1.0 + 0.2 * defection_rate)
        adjusted_critical = max(adjusted_critical, self.capacity * 0.15)
        if stock > adjusted_upper:
            return Action.C
        elif stock <= adjusted_critical:
            return Action.C
        elif defection_rate > 0.25:
            return Action.D
        else:
            return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, recent_rounds: int) -> float:
        """
        Calculate the defection rate from the last N rounds.
        Defection is encoded as False (0), Cooperation as True (1).
        """
        if recent_rounds <= 0 or history is None:
            return 0.0
        start_idx = max(0, len(history.opponent_actions) - recent_rounds)
        recent_actions = history.opponent_actions[start_idx:, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        defections = np.sum(recent_actions == False)
        defection_rate = float(defections) / float(total_actions)
        return defection_rate

class Strategy_COLLECTIVE_26(BaseStrategy):
    """
    Adaptive Stewardship Strategy: Stock-Responsive Conditional Cooperation
    
    Balances individual payoff maximization with collective resource preservation.
    Adapts to stock levels and observed depletion patterns while remaining robust
    to exploitation. Cooperates when commons health is sustainable, defects when
    cooperation becomes futile or in endgame scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            return Action.C
        if rounds_remaining <= 1:
            return Action.D
        if current_stock <= 2 * self.n_players:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        depletion_rate = self._calculate_depletion_rate(history, current_stock)
        sustainable_depletion = self.capacity / (2 * self.n_players)
        defection_rate = self._estimate_defection_rate(history, current_round)
        if stock_ratio >= 0.75:
            return Action.C
        if stock_ratio >= 0.5:
            if depletion_rate <= sustainable_depletion * 1.2:
                if defection_rate >= (self.n_players - 1) / self.n_players:
                    return Action.D
                return Action.C
            else:
                return Action.D
        if stock_ratio >= 0.25:
            if defection_rate <= 0.25:
                return Action.C
            elif defection_rate >= 0.5:
                return Action.D
            elif depletion_rate <= sustainable_depletion * 1.0:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _calculate_depletion_rate(self, history: PlayerHistory, current_stock: float) -> float:
        """
        Calculate average stock loss per round over recent history.
        Returns the mean depletion over the most recent 3 rounds (or fewer if unavailable).
        """
        if history is None or len(history.my_payoffs) == 0:
            return 0.0
        stock_history = self._reconstruct_stock_history(history)
        if len(stock_history) < 2:
            return 0.0
        recent_window = min(3, len(stock_history) - 1)
        depletion_values = []
        for i in range(len(stock_history) - recent_window, len(stock_history)):
            if i >= 0 and i < len(stock_history) - 1:
                loss = stock_history[i] - stock_history[i + 1]
                if loss > 0:
                    depletion_values.append(loss)
        if len(depletion_values) == 0:
            return 0.0
        return float(np.mean(depletion_values))

    def _reconstruct_stock_history(self, history: PlayerHistory) -> list:
        """
        Reconstruct approximate stock levels from payoff data.
        Uses payoff patterns to infer consumption and stock dynamics.
        """
        stock_levels = [self.capacity]
        for round_idx in range(len(history.my_payoffs)):
            my_payoff = history.my_payoffs[round_idx]
            my_action = history.my_actions[round_idx]
            if my_payoff > 0:
                if my_action:
                    inferred_stock = my_payoff * 2 * self.n_players
                else:
                    inferred_stock = my_payoff * self.n_players
                stock_levels.append(inferred_stock)
            else:
                stock_levels.append(0.0)
        return stock_levels

    def _estimate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Estimate the rate of defection among opponents.
        Based on observed actions and depletion patterns.
        """
        if history is None or current_round == 0:
            return 0.0
        recent_rounds = min(3, current_round)
        if recent_rounds == 0:
            return 0.0
        recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
        cooperators_per_round = np.sum(recent_opponent_actions, axis=1)
        avg_cooperators = float(np.mean(cooperators_per_round))
        defection_rate = 1.0 - avg_cooperators / self.n_players
        return max(0.0, min(1.0, defection_rate))

class Strategy_COLLECTIVE_27(BaseStrategy):
    """
    Adaptive Stewardship with Contingent Defection.
    
    Balances collective long-term resource sustainability with self-protection against exploitation.
    Uses stock-dependent cooperation with history-weighted defection detection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players
        self.threshold_high = self.capacity * 0.75
        self.threshold_low = self.capacity * 0.4
        self.threshold_critical = self.capacity * 0.2
        self.defection_window = 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        if current_stock < self.threshold_critical:
            return Action.D
        if current_stock > self.threshold_high:
            defection_rate = self._calculate_recent_defection_rate(history)
            if defection_rate < 0.4:
                return Action.C
            else:
                return Action.D
        if current_stock > self.threshold_low:
            return Action.D
        return Action.D

    def _calculate_recent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the proportion of recent rounds where the majority played defection.
        Uses a moving window of up to self.defection_window rounds.
        """
        rounds_played = history.my_actions.shape[0]
        window_size = min(self.defection_window, rounds_played)
        if window_size == 0:
            return 0.0
        recent_opponent_actions = history.opponent_actions[-window_size:, :]
        defection_count = 0
        for round_idx in range(window_size):
            cooperators_in_round = np.sum(recent_opponent_actions[round_idx, :])
            majority_defected = cooperators_in_round < (self.n_players - 1) / 2
            if majority_defected:
                defection_count += 1
        defection_rate = defection_count / window_size
        return defection_rate

class Strategy_COLLECTIVE_28(BaseStrategy):
    """
    Adaptive Threshold Harvesting with Decay Detection.
    
    Balances individual payoff maximization with collective resource preservation.
    Uses stock-level thresholds and observed cooperation rates to decide between
    cooperation and defection. Detects rapid stock decline and adapts accordingly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = self.capacity * 0.75
        self.threshold_medium = self.capacity * 0.35
        self.threshold_low = self.capacity * 0.1
        self.critical_depletion = self.capacity * 0.05

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        round_num = state.round_number
        recent_decline = self._calculate_recent_decline(history, round_num)
        if recent_decline > 0.3:
            return Action.D
        if round_num >= 1 and self._is_recovery_phase(history, current_stock):
            return Action.C
        if current_stock < self.critical_depletion:
            return Action.D
        if current_stock > self.threshold_high:
            return Action.C
        elif current_stock > self.threshold_medium:
            observed_coop_rate = self._calculate_cooperation_rate(history, round_num)
            if observed_coop_rate > 0.65:
                return Action.C if random.random() < 0.95 else Action.D
            elif observed_coop_rate > 0.4:
                return Action.C if random.random() < 0.6 else Action.D
            elif observed_coop_rate > 0.2:
                return Action.C if random.random() < 0.25 else Action.D
            else:
                return Action.D
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the observed cooperation rate of other players up to current round.
        Returns: proportion of cooperations in range [0, 1]
        """
        if round_num == 0 or self.n_players < 2:
            return 0.5
        total_cooperations = np.sum(history.opponent_actions[:round_num, :])
        total_possible = round_num * (self.n_players - 1)
        if total_possible == 0:
            return 0.5
        return float(total_cooperations) / float(total_possible)

    def _calculate_recent_decline(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the recent decline rate over the last 3 rounds.
        Returns: proportional decline per round, or 0 if insufficient history
        """
        if round_num < 3:
            return 0.0
        stock_history = self._reconstruct_stock_history(history, round_num)
        if len(stock_history) < 4:
            return 0.0
        stock_3_rounds_ago = stock_history[-4]
        current_stock = stock_history[-1]
        if stock_3_rounds_ago <= 0:
            return 0.0
        decline = (stock_3_rounds_ago - current_stock) / stock_3_rounds_ago
        return max(0.0, decline)

    def _reconstruct_stock_history(self, history: PlayerHistory, round_num: int) -> list:
        """
        Reconstruct the stock level at the start of each round.
        This is an approximation based on total payoffs distributed.
        Returns: list of stock levels [initial_stock, after_round_0, after_round_1, ...]
        """
        stock_levels = [self.capacity]
        for r in range(round_num):
            my_payoff = history.my_payoffs[r]
            opponent_payoffs = history.opponent_payoffs[r, :]
            my_action = history.my_actions[r]
            opponent_actions = history.opponent_actions[r, :]
            stock_at_round_start = stock_levels[-1]
            my_consumption = stock_at_round_start / (2 * self.n_players) if my_action else stock_at_round_start / self.n_players
            total_consumption = my_consumption
            for opponent_action in opponent_actions:
                opponent_consumption = stock_at_round_start / (2 * self.n_players) if opponent_action else stock_at_round_start / self.n_players
                total_consumption += opponent_consumption
            stock_after_consumption = max(0.0, stock_at_round_start - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            new_stock = min(stock_after_consumption + growth, self.capacity)
            stock_levels.append(new_stock)
        return stock_levels

    def _is_recovery_phase(self, history: PlayerHistory, current_stock: float) -> bool:
        """
        Detect if the stock increased by >20% in the last round.
        Returns: True if recovery detected
        """
        if history is None or len(history.my_payoffs) < 2:
            return False
        stock_history = self._reconstruct_stock_history(history, len(history.my_payoffs))
        if len(stock_history) < 2:
            return False
        prev_stock = stock_history[-2]
        if prev_stock <= 0:
            return False
        growth_rate = (current_stock - prev_stock) / prev_stock
        return growth_rate > 0.2

class Strategy_COLLECTIVE_29(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Response strategy for Common Pool Resource Game.
    
    Prioritizes long-term collective welfare by:
    1. Using stock health ratio to determine cooperation threshold
    2. Monitoring collective defection rates and adapting thresholds
    3. Special handling for first/last rounds
    4. Recovery bias when stock exceeds 80% capacity
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        capacity = self.capacity
        if capacity > 0:
            health = stock / capacity
        else:
            health = 0.0
        if health > 0.8:
            return Action.C
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            if health >= 0.3:
                return Action.C
            else:
                return Action.D
        avg_defection = 0.0
        if history is not None and round_num > 1:
            my_defections = np.sum(~history.my_actions[:round_num])
            opponent_defections = np.sum(~history.opponent_actions[:round_num, :])
            total_plays = round_num * (self.n_players + 1)
            total_defections = my_defections + opponent_defections
            if total_plays > 0:
                avg_defection = total_defections / total_plays
        threshold = 0.4
        if round_num <= 1:
            threshold = 0.5
        elif avg_defection > 0.75:
            threshold = 0.1
        elif avg_defection > 0.5:
            threshold = 0.25
        if health >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_30(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection Deterrence.
    
    Balances sustainability, fairness, and pragmatism by cooperating when the common pool
    is healthy (stock ≥ 60% capacity), defecting when depleted (stock < 15% capacity),
    and always defecting in the final round to maximize immediate extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.sustainability_threshold = 0.6 * game_description.capacity
        self.critical_threshold = 0.15 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds - 1:
            if current_stock > 0:
                return Action.D
            else:
                return Action.D
        if current_stock < self.critical_threshold:
            return Action.D
        if current_stock >= self.sustainability_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_31(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Prioritizes sustainable pool management through adaptive responses to both
    stock health and observed group defection rates. Employs conditional cooperation
    with proportional punishment, emergency defection under scarcity, and endgame
    extraction logic.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.previous_defection_rate = 0.0
        self.defection_spike_cooldown = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        capacity = self.capacity
        n_players = self.n_players
        if round_number == 0:
            return Action.C
        health_ratio = current_stock / capacity if capacity > 0 else 0.0
        if current_stock < 2 * n_players or health_ratio < 0.25:
            return Action.D
        if health_ratio < 0.5:
            threshold = (0.5 - health_ratio) / 0.25
            if random.random() < threshold:
                return Action.D
            else:
                return Action.C
        previous_round_idx = round_number - 1
        opponent_defections = sum((1 for action in history.opponent_actions[previous_round_idx, :] if not action))
        other_defection_rate = opponent_defections / (n_players - 1) if n_players > 1 else 0.0
        defection_rate_change = other_defection_rate - self.previous_defection_rate
        if defection_rate_change > 0.4 and self.defection_spike_cooldown == 0:
            self.defection_spike_cooldown = 2
        if self.defection_spike_cooldown > 0:
            self.defection_spike_cooldown -= 1
            if random.random() < 0.65:
                self.previous_defection_rate = other_defection_rate
                return Action.D
        self.previous_defection_rate = other_defection_rate
        if other_defection_rate > 0.5:
            defect_prob = min(0.8, other_defection_rate * 1.2)
            if random.random() < defect_prob:
                return Action.D
            else:
                return Action.C
        elif other_defection_rate > 0.25:
            defect_prob = 0.3 + other_defection_rate * 0.4
            if random.random() < defect_prob:
                return Action.D
            else:
                return Action.C
        else:
            rounds_remaining = self.n_rounds - round_number
            if rounds_remaining == 1:
                if health_ratio > 0.75:
                    return Action.C
                else:
                    return Action.D
            elif rounds_remaining <= 3:
                if random.random() < 0.2:
                    return Action.D
                else:
                    return Action.C
            return Action.C

class Strategy_COLLECTIVE_32(BaseStrategy):
    """
    Adaptive Stewardship with Defensive Thresholds
    
    A conditional cooperation strategy that balances collective welfare maximization
    with robustness to exploitation. Cooperates when stock is healthy and defection
    pressure is low, defects when the resource is stressed or being exploited.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if stock < 0.1 * self.capacity:
            return Action.D
        if stock >= 0.95 * self.capacity:
            return Action.D
        if round_num == self.n_rounds - 1:
            if stock >= 0.6 * self.capacity:
                return Action.D
            else:
                return Action.C
        defection_pressure = self._compute_defection_pressure(history, round_num)
        threshold = 0.5 * self.capacity
        if stock < threshold:
            if defection_pressure >= 0.5:
                return Action.D
            elif stock < 0.3 * self.capacity:
                return Action.C
            elif self._is_negative_trajectory(history, round_num):
                return Action.D
            else:
                return Action.C if defection_pressure < 0.5 else Action.D
        if stock >= 0.3 * self.capacity and stock < 0.5 * self.capacity:
            if self._is_negative_trajectory(history, round_num):
                return Action.D
        if defection_pressure >= 0.5:
            return Action.D
        return Action.C

    def _compute_defection_pressure(self, history: PlayerHistory, round_num: int) -> float:
        """
        Compute weighted average defection rate over recent rounds.
        Uses exponential decay: recent rounds weighted more heavily.
        """
        if round_num == 0:
            return 0.0
        total_weight = 0.0
        weighted_defection = 0.0
        weights = [0.5, 0.3, 0.2]
        for i, weight in enumerate(weights):
            look_back_round = round_num - 1 - i
            if look_back_round < 0:
                break
            cooperators = np.sum(history.opponent_actions[look_back_round, :])
            defectors = self.n_players - cooperators
            defection_rate = defectors / self.n_players
            weighted_defection += weight * defection_rate
            total_weight += weight
        if total_weight > 0:
            return weighted_defection / total_weight
        return 0.0

    def _is_negative_trajectory(self, history: PlayerHistory, round_num: int) -> bool:
        """
        Detect if stock is declining rapidly over last 2+ consecutive rounds.
        Returns True if trajectory indicates imminent collapse.
        """
        if round_num < 2:
            return False
        recent_payoffs = history.my_payoffs[-2:]
        if len(recent_payoffs) >= 2:
            payoff_decline = recent_payoffs[-2] - recent_payoffs[-1]
            if payoff_decline > 0.1 * (self.capacity / (2 * self.n_players)):
                return True
        return False

class Strategy_COLLECTIVE_33(BaseStrategy):
    """
    Collective Pool Stewardship Strategy (CPSS)
    
    Prioritizes sustainable collective outcomes by adapting extraction based on:
    1. Stock health ratio (current_stock / capacity)
    2. Observed cooperation rates in recent rounds
    3. Round position (first round cooperates, last round defects)
    
    Decision logic:
    - Healthy (ratio ≥ 0.6): Cooperate
    - Degraded (0.3 ≤ ratio < 0.6): Match recent cooperation rate
    - Critical (ratio < 0.3): Defect
    - Last round: Always defect
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        recent_cooperation_rate = self._calculate_recent_cooperation_rate(history, round_number)
        if health_ratio >= 0.6:
            return Action.C
        elif health_ratio >= 0.3:
            if recent_cooperation_rate >= 0.75:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the proportion of opponents who played C in the last 2 rounds.
        Returns 0.0 if no history available.
        """
        if history is None or round_number == 0:
            return 0.0
        start_round = max(0, round_number - 2)
        end_round = round_number
        if start_round >= end_round:
            return 0.0
        recent_actions = history.opponent_actions[start_round:end_round, :]
        if recent_actions.size == 0:
            return 0.0
        cooperation_count = np.sum(recent_actions)
        total_actions = recent_actions.size
        cooperation_rate = cooperation_count / total_actions if total_actions > 0 else 0.0
        return cooperation_rate

class Strategy_COLLECTIVE_34(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A sophisticated strategy for common pool resource games.
    
    Balances three objectives:
    1. Stock preservation - maintain resource regeneration capacity
    2. Exploitation detection - identify and adapt to defection
    3. Conditional reciprocity - reward cooperation, punish defection within bounds
    
    Uses majority-defection detection over a lookback window and maintains critical stock thresholds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            return Action.C
        stock_critical = self.capacity * 0.15
        if current_stock < stock_critical:
            return Action.D
        if rounds_remaining <= 2:
            if current_stock > 0:
                return Action.D
            else:
                return Action.C
        lookback_window = max(3, self.n_rounds // 4)
        defection_rate_others = self._compute_majority_defection_rate(history, current_round, lookback_window)
        stock_sustainability_threshold = self.capacity * 0.3
        defection_threshold = 0.4
        if current_stock < stock_sustainability_threshold and defection_rate_others > 0.2 and (rounds_remaining > 3):
            defection_threshold = 0.3
        if current_stock < stock_critical and rounds_remaining > 3:
            return Action.C
        if defection_rate_others > defection_threshold:
            return Action.D
        return Action.C

    def _compute_majority_defection_rate(self, history: PlayerHistory, current_round: int, lookback_window: int) -> float:
        """
        Compute the rate at which a majority of opponents defected in the lookback window.
        
        Majority defection = rounds where >= ceil(n_players / 2) opponents played D.
        Returns: proportion of lookback rounds with majority defection.
        """
        start_round = max(0, current_round - lookback_window)
        end_round = current_round
        majority_threshold = math.ceil(self.n_players / 2)
        majority_defection_count = 0
        for round_idx in range(start_round, end_round):
            opponent_actions_in_round = history.opponent_actions[round_idx, :]
            defector_count = (opponent_actions_in_round == False).sum()
            if defector_count >= majority_threshold:
                majority_defection_count += 1
        rounds_evaluated = end_round - start_round
        if rounds_evaluated == 0:
            return 0.0
        defection_rate = majority_defection_count / rounds_evaluated
        return defection_rate

class Strategy_COLLECTIVE_35(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual benefit with collective survival by:
    1. Starting with cooperation to establish norms
    2. Assessing stock health (healthy/degraded/critical)
    3. Observing opponent defection rates and responding adaptively
    4. Using mixed strategies to proportionally match opponent restraint
    5. Defecting only when justified (others defect, stock critical, or final round)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.healthy_threshold = 0.6 * self.capacity
        self.degraded_threshold = 0.2 * self.capacity
        self.threshold_low = 0.33
        self.threshold_high = 0.66

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        is_last_round = current_round == self.n_rounds - 1
        if is_last_round and current_stock > 0.5 * self.capacity:
            return Action.D
        prev_round_idx = current_round - 1
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        num_defectors_prev = np.sum(~opponent_actions_prev)
        defection_rate = num_defectors_prev / self.n_players
        if current_stock > self.healthy_threshold:
            return self._decide_healthy(defection_rate)
        elif current_stock > self.degraded_threshold:
            return self._decide_degraded(defection_rate)
        else:
            return self._decide_critical(current_round, current_stock)

    def _decide_healthy(self, defection_rate: float) -> Action:
        """
        When stock is healthy (> 60% capacity):
        - Low defection: cooperate (reciprocate restraint)
        - Moderate defection: mixed strategy proportional to restraint
        - High defection: defect (majority defected)
        """
        if defection_rate <= self.threshold_low:
            return Action.C
        elif defection_rate <= self.threshold_high:
            p_cooperate = 1.0 - defection_rate
            return Action.C if random.random() < p_cooperate else Action.D
        else:
            return Action.D

    def _decide_degraded(self, defection_rate: float) -> Action:
        """
        When stock is degraded (20-60% capacity):
        - Low defection: cooperate (few defectors + need recovery)
        - Higher defection: mixed strategy weighted toward cooperation
        """
        if defection_rate <= self.threshold_low:
            return Action.C
        else:
            p_cooperate = min(1.0, 2.0 * (1.0 - defection_rate))
            return Action.C if random.random() < p_cooperate else Action.D

    def _decide_critical(self, current_round: int, current_stock: float) -> Action:
        """
        When stock is critical (<= 20% capacity):
        - Check if sustainable consumption for remaining rounds is possible
        - If sustainable: cooperate (hard choice for long-term viability)
        - Otherwise: defect (pool is effectively lost, salvage what remains)
        """
        remaining_rounds = self.n_rounds - current_round
        sustainable_per_round = current_stock / (2 * self.n_players)
        if remaining_rounds > 0:
            projected_final_stock = current_stock - sustainable_per_round * remaining_rounds
            if projected_final_stock > self.degraded_threshold:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_36(BaseStrategy):
    """
    Adaptive Threshold Stewardship (ATS): A collectively-aligned strategy that
    prioritizes long-term stock sustainability through conditional cooperation,
    adaptive probability adjustment based on observed defection rates, and
    threshold-based decision rules that respond to resource health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.p_adaptive = 0.7
        self.threshold_cooperate = 0.6
        self.threshold_minimum = 0.25
        self.threshold_critical = 0.1
        self.threshold_full = 0.95

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if round_num == 0:
            return Action.C
        self._update_adaptive_probability(history, round_num)
        health_ratio = stock / capacity if capacity > 0 else 0.0
        if round_num <= 2:
            return Action.C
        remaining_rounds = n_rounds - round_num
        if remaining_rounds <= 2:
            if stock >= capacity * 0.5:
                return Action.C
            else:
                return Action.D
        if health_ratio < self.threshold_critical:
            return Action.D
        if health_ratio >= self.threshold_full:
            return Action.C
        if health_ratio >= self.threshold_cooperate:
            return Action.C
        elif health_ratio >= self.threshold_minimum:
            if random.random() < self.p_adaptive:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _update_adaptive_probability(self, history: PlayerHistory, round_num: int) -> None:
        """
        Update p_adaptive based on observed defection rate in the previous round.
        """
        if round_num < 1:
            return
        prev_round_idx = round_num - 1
        opponent_actions = history.opponent_actions[prev_round_idx, :]
        n_cooperators = int(np.sum(opponent_actions))
        n_defectors = self.game_description.n_players - n_cooperators
        defection_rate = n_defectors / self.game_description.n_players if self.game_description.n_players > 0 else 0.0
        if defection_rate > 0.5:
            self.p_adaptive = max(0.2, self.p_adaptive - 0.1)
        elif defection_rate < 0.2 and history.my_payoffs[prev_round_idx] > 0:
            self.p_adaptive = min(0.8, self.p_adaptive + 0.05)

class Strategy_COLLECTIVE_37(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy for common pool resource games
    that balances individual payoff maximization with resource sustainability through
    stock-conditional reciprocal decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if ratio < 0.01:
            return Action.D
        defectors_prev_round = self.n_players - int(sum(history.opponent_actions[-1, :]))
        defection_rate = defectors_prev_round / self.n_players if self.n_players > 0 else 0.0
        if defection_rate == 0.0 and current_round > 0:
            return Action.C
        if ratio < 0.1 and defection_rate > 0.75:
            return Action.D
        if ratio >= 0.9 and defection_rate < 0.25:
            return Action.C
        if defection_rate >= 0.5:
            threshold = 0.3
        elif defection_rate >= 0.25:
            threshold = 0.5
        else:
            threshold = 0.7
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= 3:
            threshold = max(threshold, 0.4)
        if current_round == self.n_rounds - 1:
            if ratio >= 0.4:
                return Action.C
            else:
                return Action.D
        if ratio >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_38(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS) for Common Pool Resource Games.
    
    Balances immediate payoff maximization with long-term resource preservation.
    Cooperates when stock is critically low or showing decline, adapts based on
    observed defection rates, and conditionally defects in terminal rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        rounds_remaining = self.n_rounds - round_num
        if round_num == 0:
            return Action.C
        critical_threshold = 1.5 * self.n
        healthy_threshold = 1.2 * self.capacity
        if stock <= critical_threshold:
            return Action.C
        recent_defection_rate = self._calculate_recent_defection_rate(history, round_num)
        if stock >= healthy_threshold and recent_defection_rate <= 0.4:
            return Action.C
        if rounds_remaining <= 2:
            if stock > 2 * self.n:
                return Action.D
            else:
                return Action.C
        if self._is_stock_declining(history, round_num):
            return Action.C
        if random.random() < 0.3:
            return Action.D
        else:
            return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate defection rate over last 3 rounds.
        Returns a value between 0 and 1 representing fraction of observed defections.
        """
        lookback = min(3, round_num)
        if lookback == 0:
            return 0.0
        start_round = round_num - lookback
        recent_opponent_actions = history.opponent_actions[start_round:round_num, :]
        defections = np.sum(~recent_opponent_actions)
        total_observations = recent_opponent_actions.size
        if total_observations == 0:
            return 0.0
        defection_rate = defections / total_observations
        return float(defection_rate)

    def _is_stock_declining(self, history: PlayerHistory, round_num: int) -> bool:
        """
        Check if stock is declining by comparing to moving average of previous 2 rounds.
        Returns True if stock is declining (current < 95% of recent average).
        """
        if round_num < 1:
            return False
        lookback = min(2, round_num)
        if round_num < 2:
            return False
        recent_payoffs = history.my_payoffs[round_num - 2:round_num]
        avg_recent = np.mean(recent_payoffs)
        current_payoff = history.my_payoffs[round_num - 1]
        if avg_recent > 0 and current_payoff < 0.95 * avg_recent:
            return True
        return False

class Strategy_COLLECTIVE_39(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy balancing individual payoff
    maximization with resource preservation through stock-level-based decision thresholds.
    
    Core logic:
    - Defect when stock is abundant (above 75% capacity)
    - Stochastically cooperate when stock is declining (25-50% capacity)
    - Cooperate when stock is critical (below 50% capacity or below 2n)
    - Always defect on the final round (backward induction)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.n_rounds - 1:
            return Action.D
        threshold_critical = 2 * self.n_players
        threshold_caution = self.capacity / 2.0
        threshold_optimal = self.capacity * 0.75
        if current_stock >= self.capacity:
            return Action.C
        if current_stock <= threshold_critical:
            return Action.C
        if current_stock <= threshold_caution:
            prob_cooperate = (current_stock - threshold_critical) / (threshold_caution - threshold_critical)
            prob_cooperate = max(0.0, min(1.0, prob_cooperate))
            if random.random() < prob_cooperate:
                return Action.C
            else:
                return Action.D
        if current_stock <= threshold_optimal:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_40(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game
    
    Combines stock health monitoring, adaptive cooperation, and defection thresholds
    to maximize long-term collective sustainability while protecting against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        if round_number == 0:
            self.previous_stock = current_stock
            return Action.C
        stock_ratio = current_stock / capacity if capacity > 0 else 0.0
        if stock_ratio < 0.1:
            self.previous_stock = current_stock
            return Action.D
        if round_number == total_rounds - 1:
            self.previous_stock = current_stock
            if stock_ratio > 0.5:
                return Action.C
            else:
                return Action.D
        if stock_ratio < 0.2:
            self.previous_stock = current_stock
            return Action.D
        recent_window_size = min(3, round_number)
        start_idx = round_number - recent_window_size
        total_c_actions = 0
        total_possible_actions = 0
        for r in range(start_idx, round_number):
            if history.my_actions[r]:
                total_c_actions += 1
            total_possible_actions += 1
            for opponent_idx in range(self.game_description.n_players - 1):
                if history.opponent_actions[r, opponent_idx]:
                    total_c_actions += 1
                total_possible_actions += 1
        cooperation_rate = total_c_actions / total_possible_actions if total_possible_actions > 0 else 0.0
        if cooperation_rate < 0.5:
            self.previous_stock = current_stock
            return Action.D
        if round_number > 0 and history.my_actions[round_number - 1]:
            if self.previous_stock is not None and self.previous_stock > 0:
                stock_decline = (self.previous_stock - current_stock) / self.previous_stock
                if stock_decline > 0.3:
                    self.previous_stock = current_stock
                    return Action.D
        if round_number <= 2:
            if stock_ratio <= 0.25:
                self.previous_stock = current_stock
                return Action.D
        self.previous_stock = current_stock
        return Action.C

class Strategy_COLLECTIVE_41(BaseStrategy):
    """
    Adaptive Collective Stewardship Strategy (ACS)
    
    Balances sustainability, reciprocity, and robustness by:
    - Cooperating in round 1 to establish cooperative norms
    - Defecting in the final round (no future to protect)
    - Reciprocating cooperation when others cooperate sufficiently
    - Cooperating when stock is critically depleted (defection is futile)
    - Cooperating when stock is healthy despite defection (strategic patience)
    - Defecting when stock is intermediate and others defect (self-protection)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.total_rounds = game_description.n_rounds
        self.critical_threshold = 0.15 * self.capacity
        self.sustainability_level = 0.6 * self.capacity
        self.cooperation_threshold = (self.n - 1) / self.n

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        rounds_remaining = self.total_rounds - current_round
        if current_round == 0:
            return Action.C
        if rounds_remaining == 1:
            return Action.D
        if stock < self.critical_threshold:
            return Action.C
        if history is not None and len(history.opponent_actions) > 0:
            last_round_actions = history.opponent_actions[-1, :]
            num_cooperators = int(np.sum(last_round_actions))
            cooperation_rate = num_cooperators / self.n
        else:
            cooperation_rate = 1.0
        if cooperation_rate >= self.cooperation_threshold:
            return Action.C
        elif stock >= self.sustainability_level and rounds_remaining > 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_42(BaseStrategy):
    """
    Adaptive Stewardship with Defensive Safeguards: A stock-health-based strategy
    that prioritizes sustainable collective outcomes while maintaining robust defenses
    against exploitation. Cooperates when the pool is healthy, adapts tolerance based
    on observed defection rates, and switches to survival mode when stock is critical.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_high = 0.75
        self.threshold_mid = 0.4
        self.tolerance_threshold = 0.4
        self.critical_stock_level = 2 * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_health_ratio = state.current_stock / self.game_description.capacity
        if state.current_stock < self.critical_stock_level:
            return Action.D
        is_last_round = state.round_number == self.game_description.n_rounds - 1
        if is_last_round:
            if stock_health_ratio > self.threshold_mid:
                return Action.C
            else:
                return Action.D
        previous_round_idx = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[previous_round_idx, :]
        defectors_prev = np.sum(~opponent_actions_prev)
        defection_rate = defectors_prev / self.game_description.n_players
        if stock_health_ratio > self.threshold_high:
            return Action.C
        elif stock_health_ratio > self.threshold_mid:
            if defection_rate <= self.tolerance_threshold:
                return Action.C
            else:
                return Action.D
        elif defection_rate > 0.6:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_43(BaseStrategy):
    """
    Adaptive Resource Stewardship (ARS) Strategy for Common Pool Resource Game.
    
    Balances individual payoff maximization with collective sustainability through
    three-mode framework based on stock health and observed defection rates.
    Modes: Growth (abundant), Stability (precarious), Crisis (depleted).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history: list[float] = []
        self.consecutive_crisis_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        self.stock_history.append(state.current_stock)
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        defection_rate_last_round = self._get_defection_rate(history, state.round_number - 1)
        if len(self.stock_history) >= 2:
            stock_drop_rate = (self.stock_history[-2] - self.stock_history[-1]) / max(self.stock_history[-2], 1e-09)
            if stock_drop_rate > 0.3:
                return Action.D
        if current_stock > 0.6 * capacity:
            mode = 'GROWTH'
        elif current_stock >= 0.3 * capacity:
            mode = 'STABILITY'
        else:
            mode = 'CRISIS'
        if mode == 'CRISIS':
            self.consecutive_crisis_rounds += 1
        else:
            self.consecutive_crisis_rounds = 0
        if self.consecutive_crisis_rounds >= 2:
            return Action.D
        if current_stock < 0.05 * capacity:
            return Action.D
        if mode == 'GROWTH':
            if defection_rate_last_round >= 0.5:
                return Action.D
            else:
                return Action.C
        elif mode == 'STABILITY':
            if defection_rate_last_round <= 0.33:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

    def _get_defection_rate(self, history: PlayerHistory, round_idx: int) -> float:
        """
        Calculate the defection rate among opponents in a given round.
        Defection = Action.D = False/0, so count False values and divide by n_players-1.
        """
        if round_idx < 0 or round_idx >= history.opponent_actions.shape[0]:
            return 0.0
        opponent_actions_in_round = history.opponent_actions[round_idx, :]
        num_defectors = np.sum(~opponent_actions_in_round)
        num_opponents = self.game_description.n_players - 1
        if num_opponents == 0:
            return 0.0
        return float(num_defectors) / float(num_opponents)

class Strategy_COLLECTIVE_44(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy that prioritizes
    long-term sustainability of the common pool resource while adapting to
    stock health, round progression, and observed defection patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if self.capacity > 0:
            stock_ratio = current_stock / self.capacity
        else:
            stock_ratio = 0.0
        if round_number == self.n_rounds - 1:
            return Action.D
        if round_number == self.n_rounds - 2:
            if stock_ratio >= 0.5:
                return Action.C
            else:
                return Action.D
        defection_rate = 0.0
        if round_number > 0 and history is not None:
            start_idx = max(0, round_number - 3)
            recent_rounds = history.opponent_actions[start_idx:round_number, :]
            if recent_rounds.size > 0:
                defection_count = np.sum(~recent_rounds)
                total_actions = recent_rounds.size
                if total_actions > 0:
                    defection_rate = defection_count / total_actions
        if stock_ratio >= 0.6:
            return Action.C
        if stock_ratio >= 0.3:
            if defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_45(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances immediate reward-seeking with long-term stock preservation through
    stock-conditional cooperation. Behavior depends on resource health:
    - Healthy stock (>60% capacity): COOPERATE
    - Degraded stock (20-60% capacity): CONDITIONAL based on opponent defection rate
    - Depleted stock (<20% capacity): DEFECT
    - Final round: DEFECT (subgame perfect)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if current_round == self.n_rounds - 1:
            return Action.D
        if health_ratio > 0.6:
            return Action.C
        if health_ratio < 0.2:
            return Action.D
        if current_round == 0:
            return Action.C
        opponent_defection_rate = self._calculate_opponent_defection_rate(history)
        if opponent_defection_rate > 0.4:
            return Action.D
        elif opponent_defection_rate <= 0.2:
            return Action.C
        else:
            cooperation_prob = (0.4 - opponent_defection_rate) / 0.2
            if random.random() < cooperation_prob:
                return Action.C
            else:
                return Action.D

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the average defection rate of all opponents across all previous rounds.
        
        Returns a value in [0, 1] where 1.0 means all opponent actions were defections,
        and 0.0 means all were cooperations.
        """
        if history is None or history.opponent_actions.size == 0:
            return 0.0
        total_opponent_actions = history.opponent_actions.size
        if total_opponent_actions == 0:
            return 0.0
        total_defections = np.sum(~history.opponent_actions)
        defection_rate = float(total_defections) / float(total_opponent_actions)
        return defection_rate

class Strategy_COLLECTIVE_46(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy for Common Pool Resource games
    that balances long-term stock preservation with punishment of defectors.
    
    The strategy assesses stock health (ABUNDANCE/SUSTAINABILITY/CRISIS modes) and adjusts
    behavior accordingly, while tracking defection history to punish exploitation and
    maintain collective welfare.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        defection_rate = self._calculate_defection_rate(history, round_number)
        if stock_ratio >= 0.75:
            mode = 'ABUNDANCE'
        elif stock_ratio >= 0.4:
            mode = 'SUSTAINABILITY'
        else:
            mode = 'CRISIS'
        any_defection_last_round = self._check_defection_last_round(history)
        if mode == 'ABUNDANCE':
            if defection_rate > 0.4:
                return Action.D
            else:
                return Action.C
        elif mode == 'SUSTAINABILITY':
            if any_defection_last_round:
                return Action.D
            elif defection_rate > 0.25:
                return Action.D if random.random() < 0.3 else Action.C
            else:
                return Action.C
        elif defection_rate <= 0.1:
            return Action.C
        elif round_number == self.n_rounds - 1:
            return Action.D if defection_rate > 0.3 else Action.C
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the proportion of rounds (so far) where any player defected.
        Defection is False (0) in opponent_actions, Cooperation is True (1).
        """
        if round_number <= 1:
            return 0.0
        rounds_elapsed = round_number
        defection_count = 0
        for round_idx in range(rounds_elapsed):
            round_actions = history.opponent_actions[round_idx, :]
            if not all(round_actions):
                defection_count += 1
        return defection_count / rounds_elapsed if rounds_elapsed > 0 else 0.0

    def _check_defection_last_round(self, history: PlayerHistory) -> bool:
        """
        Check if any opponent defected in the most recent completed round.
        True (1) = Cooperate, False (0) = Defect.
        """
        if history is None or len(history.opponent_actions) == 0:
            return False
        last_round_actions = history.opponent_actions[-1, :]
        return not all(last_round_actions)

class Strategy_COLLECTIVE_47(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Defection Detection.
    
    Balances collective welfare with individual rationality by:
    1. Cooperating in round 1 to build trust
    2. Defecting in final round (subgame perfection)
    3. Using pool health indicator to detect defection and graduate response
    4. Defecting when stock falls below critical threshold (25% of capacity)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == self.n_rounds - 1:
            return Action.D
        if round_number == 0:
            return Action.C
        if current_stock <= 1.0:
            return Action.D
        if current_stock < self.critical_threshold:
            return Action.D
        pool_health = self._calculate_pool_health(state, history)
        if pool_health >= 0.95:
            cooperation_threshold = 0.85
        elif pool_health >= 0.75:
            cooperation_threshold = 0.7
        elif pool_health >= 0.5:
            cooperation_threshold = 0.5
        else:
            cooperation_threshold = -1.0
        if pool_health >= cooperation_threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_pool_health(self, state: CommonPoolState, history: PlayerHistory) -> float:
        """
        Empirical measure of collective discipline.
        
        Compares actual stock remaining to projected stock if everyone cooperated.
        Range: [0, ∞). Values > 1 mean others consumed more than C-level.
        Values < 1 mean others are cooperating or consuming less.
        """
        current_stock = state.current_stock
        round_number = state.round_number
        previous_round_idx = round_number - 1
        my_previous_action = history.my_actions[previous_round_idx]
        opponent_previous_actions = history.opponent_actions[previous_round_idx, :]
        n_cooperators = int(my_previous_action) + np.sum(opponent_previous_actions)
        n_defectors = self.n_players - n_cooperators
        projected_remaining_if_all_coop = current_stock / 2.0
        if self.n_players <= 1:
            return 1.0
        expected_cooperation_rate = 1.0
        observed_cooperation_rate = n_cooperators / self.n_players
        pool_health = observed_cooperation_rate / max(1.0, expected_cooperation_rate)
        return pool_health

class Strategy_COLLECTIVE_48(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS) - Balances individual rationality with collective
    sustainability by protecting commons, punishing defection, rewarding cooperation,
    and adapting to stock health and observed behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        stock_health = current_stock / self.capacity
        rounds_remaining = self.n_rounds - current_round
        if current_stock <= 2 * self.n_players:
            return Action.C
        if stock_health >= 0.75:
            base_action = Action.D
        elif stock_health >= 0.5:
            base_action = Action.C
        elif stock_health >= 0.25:
            base_action = Action.C
        else:
            base_action = Action.C
        final_action = base_action
        if current_round > 0:
            lookback_rounds = min(3, current_round)
            start_idx = max(0, current_round - lookback_rounds)
            defection_count = 0
            total_observations = 0
            for round_idx in range(start_idx, current_round):
                opponent_actions = history.opponent_actions[round_idx, :]
                defection_count += np.sum(opponent_actions == False)
                total_observations += len(opponent_actions)
            if total_observations > 0:
                RDR = defection_count / total_observations
            else:
                RDR = 0.0
            if RDR >= 0.67:
                if stock_health >= 0.5:
                    final_action = Action.D
                else:
                    final_action = Action.C
            elif RDR <= 0.25:
                if stock_health >= 0.6:
                    final_action = Action.D
                else:
                    final_action = Action.C
        if rounds_remaining <= 2:
            if stock_health >= 0.5:
                final_action = Action.D
            else:
                final_action = Action.C
        if rounds_remaining == 1:
            if stock_health >= 0.4:
                final_action = Action.D
            else:
                final_action = Action.C
        if stock_health >= 0.95:
            final_action = Action.D
        return final_action

class Strategy_COLLECTIVE_49(BaseStrategy):
    """
    Adaptive Stewardship: A dynamic common pool resource strategy that balances
    individual gains with collective sustainability by adapting to stock health
    and observed cooperation rates.
    
    Core mechanism: Classify stock health (healthy/vulnerable/critical) and
    environment (cooperative/mixed/defective) to determine action via decision matrix.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_critical_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_health = state.current_stock / self.game_description.capacity
        opponent_c_count = 0
        total_opponent_actions = state.round_number * (self.game_description.n_players - 1)
        if total_opponent_actions > 0:
            opponent_c_count = int(np.sum(history.opponent_actions[:state.round_number, :]))
            cooperation_rate = opponent_c_count / total_opponent_actions if total_opponent_actions > 0 else 0.5
        else:
            cooperation_rate = 0.5
        if cooperation_rate > 0.6:
            environment = 'COOPERATIVE'
        elif cooperation_rate > 0.3:
            environment = 'MIXED'
        else:
            environment = 'DEFECTIVE'
        if stock_health > 0.7:
            health = 'HEALTHY'
        elif stock_health > 0.4:
            health = 'VULNERABLE'
        else:
            health = 'CRITICAL'
        if health == 'CRITICAL':
            self.consecutive_critical_rounds += 1
        else:
            self.consecutive_critical_rounds = 0
        if state.current_stock <= 1e-06:
            return Action.C
        if health == 'CRITICAL':
            return Action.C
        elif health == 'VULNERABLE':
            if environment == 'DEFECTIVE':
                return Action.D
            else:
                return Action.C
        elif environment == 'COOPERATIVE':
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_50(BaseStrategy):
    """
    Adaptive Stock-Preserving Cooperation (ASPC) Strategy
    
    Balances collective sustainability with individual rationality by using the common pool's
    stock level as the primary decision signal. Cooperates when stock is healthy (above 1/3 capacity),
    defects when depleted (below 1/3 capacity), with special handling for extreme depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.critical_threshold = self.capacity / 3.0
        self.extreme_threshold = self.capacity / (4.0 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        if stock < self.extreme_threshold:
            return Action.D
        if stock > self.critical_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_51(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy that maintains common pool
    sustainability while remaining robust to exploitation. Cooperates by default, defects
    only when defection is widespread or stock is robust enough to sustain it.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 0.3 * self.capacity
        self.healthy_threshold = 0.7 * self.capacity
        self.extremely_low_threshold = 0.15 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if stock < self.extremely_low_threshold:
            return Action.C
        if stock < self.critical_threshold:
            return Action.C
        defection_ratio = self._compute_defection_ratio(history, round_num)
        if defection_ratio >= (self.n - 1) / self.n:
            return Action.D
        if defection_ratio >= 0.5:
            if stock >= self.healthy_threshold:
                return Action.D
            else:
                return Action.C
        if defection_ratio < 0.5:
            return Action.C
        return Action.C

    def _compute_defection_ratio(self, history: PlayerHistory, round_num: int) -> float:
        """
        Compute the ratio of defectors in the previous round.
        Returns a value in [0, 1].
        """
        if round_num <= 0:
            return 0.0
        prev_round_idx = round_num - 1
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        num_defectors = np.sum(~opponent_actions_prev)
        defection_ratio = float(num_defectors) / self.n if self.n > 0 else 0.0
        return defection_ratio

class Strategy_COLLECTIVE_52(BaseStrategy):
    """
    Adaptive Stewardship with Gradual Enforcement: A collective strategy that balances
    individual benefit-taking with common pool sustainability. Cooperates by default,
    adapts to defection patterns with grace periods, and recognizes end-game dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < 2 * self.n_players:
            return Action.C
        if current_stock >= 0.95 * self.capacity:
            return Action.C
        if self._is_rapid_depletion(history, current_round):
            return Action.C
        if self._is_stock_increasing(history, current_round):
            return Action.C
        defection_ratio = self._get_defection_ratio(history, current_round - 1)
        if defection_ratio <= 0.33:
            return Action.C
        else:
            return Action.D

    def _get_defection_ratio(self, history: PlayerHistory, round_idx: int) -> float:
        """
        Calculate the defection ratio in a given round.
        Returns: (number of defectors) / n_players
        """
        if round_idx < 0 or round_idx >= len(history.opponent_actions):
            return 0.0
        defectors = self.n_players - int(sum(history.opponent_actions[round_idx, :]))
        return defectors / self.n_players if self.n_players > 0 else 0.0

    def _is_rapid_depletion(self, history: PlayerHistory, current_round: int) -> bool:
        """
        Check if stock has declined by more than 30% over the last 3 rounds.
        """
        if current_round < 3:
            return False
        recent_payoffs = history.my_payoffs[max(0, current_round - 3):current_round]
        if len(recent_payoffs) < 2:
            return False
        first_payoff = recent_payoffs[0]
        last_payoff = recent_payoffs[-1]
        if first_payoff <= 0:
            return False
        decline = (first_payoff - last_payoff) / first_payoff
        return decline > 0.3

    def _is_stock_increasing(self, history: PlayerHistory, current_round: int) -> bool:
        """
        Check if stock has increased for two consecutive rounds.
        Infer stock levels from payoff patterns.
        """
        if current_round < 2:
            return False
        recent_payoffs = history.my_payoffs[current_round - 2:current_round]
        if len(recent_payoffs) < 2:
            return False
        return recent_payoffs[1] > recent_payoffs[0]

class Strategy_COLLECTIVE_53(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Defection Detection.
    
    Balances individual security with collective sustainability by:
    - Monitoring stock health and responding adaptively
    - Detecting defection levels and responding proportionally
    - Protecting the commons during critical depletion
    - Allowing rational end-game defection when sustainable
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        capacity = self.capacity
        n_players = self.n_players
        n_rounds = self.n_rounds
        stock_health = current_stock / capacity if capacity > 0 else 0.0
        rounds_remaining = n_rounds - round_number - 1
        if round_number == 0:
            return Action.C
        if stock_health < 0.1:
            return Action.C
        if rounds_remaining == 0:
            if stock_health >= 0.2:
                return Action.D
            else:
                return Action.C
        if stock_health < 0.2:
            return Action.C
        defection_count = n_players - int(np.sum(history.opponent_actions[-1, :]))
        majority_threshold = math.ceil(n_players / 2)
        if defection_count >= majority_threshold:
            return Action.D
        elif defection_count >= 1:
            if stock_health < 0.5:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_54(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS) for Common Pool Resource Game.
    
    Balances immediate individual gain against long-term resource availability.
    Cooperates when sustainable, defects when others exploit systematically,
    and prioritizes preventing collapse over short-term extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.min_viable = 2 * self.n
        self.healthy_threshold = self.capacity * 0.75
        self.moderate_lower = self.min_viable
        self.moderate_upper = self.healthy_threshold
        self.exploitation_threshold_base = 1.3
        self.severe_depletion_threshold = 1.5 * self.min_viable
        self.collective_exploitation_high = 1.5
        self.collective_exploitation_low = 1.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_t = state.round_number
        if round_t == 0:
            return Action.C
        if stock <= self.min_viable:
            return Action.C
        if stock >= self.healthy_threshold:
            return Action.C
        if self.moderate_lower < stock < self.moderate_upper:
            optimal_rate = stock / (2 * self.n)
            avg_opponent_consumption = self._compute_avg_opponent_consumption(history)
            if optimal_rate > 0:
                exploitation_score = avg_opponent_consumption / optimal_rate
            else:
                exploitation_score = 0.0
            rounds_remaining = self.r - round_t
            threshold = self.exploitation_threshold_base
            if rounds_remaining <= 2:
                threshold = threshold * 1.5
            collective_defection_rate = self._compute_collective_defection_rate(history, optimal_rate)
            if collective_defection_rate > self.collective_exploitation_high:
                rounds_to_recovery = self._estimate_rounds_to_recovery(stock)
                if rounds_to_recovery > rounds_remaining:
                    return Action.D
            if exploitation_score > threshold:
                return Action.D
            else:
                return Action.C
        if round_t == self.r - 1:
            if stock > self.min_viable:
                return Action.D
            else:
                return Action.C
        if stock < self.severe_depletion_threshold:
            return Action.C
        return Action.C

    def _compute_avg_opponent_consumption(self, history: PlayerHistory) -> float:
        """
        Compute the average consumption by opponents across all past rounds.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        total_consumption = 0.0
        total_rounds = len(history.opponent_actions)
        for round_idx in range(total_rounds):
            round_stock = self._estimate_stock_at_round(history, round_idx)
            if round_stock <= 0:
                continue
            opponent_actions = history.opponent_actions[round_idx, :]
            for action in opponent_actions:
                if action:
                    consumption = round_stock / (2 * self.n)
                else:
                    consumption = round_stock / self.n
                total_consumption += consumption
        if total_rounds == 0:
            return 0.0
        return total_consumption / (total_rounds * self.n)

    def _compute_collective_defection_rate(self, history: PlayerHistory, optimal_rate: float) -> float:
        """
        Compute collective defection rate: sum of opponent consumptions / optimal sustainable total.
        """
        if history is None or len(history.opponent_actions) == 0 or optimal_rate <= 0:
            return 0.0
        total_opponent_consumption = 0.0
        total_rounds = len(history.opponent_actions)
        for round_idx in range(total_rounds):
            round_stock = self._estimate_stock_at_round(history, round_idx)
            if round_stock <= 0:
                continue
            opponent_actions = history.opponent_actions[round_idx, :]
            for action in opponent_actions:
                if action:
                    consumption = round_stock / (2 * self.n)
                else:
                    consumption = round_stock / self.n
                total_opponent_consumption += consumption
        optimal_sustainable_total = optimal_rate * self.n * total_rounds
        if optimal_sustainable_total <= 0:
            return 0.0
        return total_opponent_consumption / optimal_sustainable_total

    def _estimate_stock_at_round(self, history: PlayerHistory, round_idx: int) -> float:
        """
        Estimate the stock level at the start of a given round using history.
        """
        if round_idx == 0:
            return self.capacity
        stock = self.capacity
        for r_idx in range(round_idx):
            my_action = history.my_actions[r_idx]
            opponent_actions = history.opponent_actions[r_idx, :]
            my_consumption = stock / (2 * self.n) if my_action else stock / self.n
            total_consumption = my_consumption
            for opp_action in opponent_actions:
                opp_consumption = stock / (2 * self.n) if opp_action else stock / self.n
                total_consumption += opp_consumption
            stock_after_consumption = stock - total_consumption
            stock_after_consumption = max(0.0, stock_after_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
                stock = min(stock_after_consumption + growth, self.capacity)
            else:
                stock = 0.0
        return stock

    def _estimate_rounds_to_recovery(self, current_stock: float) -> int:
        """
        Estimate how many rounds needed to recover from current stock to healthy level.
        Uses logistic growth model under full cooperation.
        """
        if current_stock >= self.healthy_threshold:
            return 0
        stock = current_stock
        rounds = 0
        max_rounds = self.r + 10
        while stock < self.healthy_threshold and rounds < max_rounds:
            consumption = stock / (2 * self.n) * self.n
            stock_after = stock - consumption
            stock_after = max(0.0, stock_after)
            if stock_after > 0:
                growth = 2 * stock_after * (1 - stock_after / self.capacity)
                stock = min(stock_after + growth, self.capacity)
            else:
                return max_rounds
            rounds += 1
        return rounds

class Strategy_COLLECTIVE_55(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS) Strategy for Common Pool Resource Game
    
    Prioritizes long-term collective sustainability by monitoring stock health
    and regeneration rates. Uses threshold-based decision rules to maintain
    the resource at sustainable levels while being robust against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_number = state.round_number
        if stock > self.capacity * 0.75:
            return Action.C
        if stock < self.capacity * 0.25:
            return Action.C
        if round_number == 0 or history is None:
            return Action.C
        previous_round_idx = round_number - 1
        last_stock = state.current_stock
        n = self.game_description.n_players
        previous_actions = history.opponent_actions[previous_round_idx, :]
        cooperators_count = int(np.sum(previous_actions))
        defectors_count = n - cooperators_count - 1
        self_cooperated = history.my_actions[previous_round_idx]
        if self_cooperated:
            cooperators_count += 1
        else:
            defectors_count += 1
        my_payoff_prev = history.my_payoffs[previous_round_idx]
        if my_payoff_prev > 0:
            if self_cooperated:
                stock_at_prev_start = my_payoff_prev * 2 * n
            else:
                stock_at_prev_start = my_payoff_prev * n
        else:
            stock_at_prev_start = stock
        total_consumption_prev = cooperators_count * (stock_at_prev_start / (2 * n)) + defectors_count * (stock_at_prev_start / n)
        stock_after_consumption_prev = max(0, stock_at_prev_start - total_consumption_prev)
        growth = 2 * stock_after_consumption_prev * (1 - stock_after_consumption_prev / self.capacity)
        stock_after_growth_prev = min(stock_after_consumption_prev + growth, self.capacity)
        regeneration = stock_after_growth_prev - stock_at_prev_start
        if regeneration >= 0:
            return Action.C
        elif stock > self.capacity * 0.35:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_56(BaseStrategy):
    """
    Collective Resource Stewardship Strategy (CRSS)
    
    Balances immediate individual benefit with long-term collective sustainability.
    Adapts to stock levels: cooperates when healthy, conditionally cooperates when moderate,
    and defects when critical or in terminal round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_number = state.round_number
        if round_number == self.n_rounds - 1:
            return Action.D
        critical_threshold = 0.4 * self.capacity
        healthy_threshold = 0.75 * self.capacity
        if stock >= healthy_threshold:
            return Action.C
        if stock < critical_threshold:
            return Action.D
        threshold_range = 0.35 * self.capacity
        cooperation_prob = (stock - critical_threshold) / threshold_range
        if random.random() < cooperation_prob:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_57(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective-welfare strategy for common pool resource games.
    
    Prioritizes long-term ecosystem health by:
    1. Monitoring stock health relative to capacity
    2. Responding to population-level cooperation trends
    3. Enforcing implicit norms through stock-responsive behavior
    4. Gracefully degrading under resource stress
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if self.capacity <= 0:
            return Action.D
        health_ratio = current_stock / self.capacity
        if round_num == 0:
            return Action.C
        recent_coop_rate = self._calculate_recent_cooperation_rate(history, round_num)
        if round_num == self.n_rounds - 1:
            if health_ratio >= 0.7:
                return Action.C
            else:
                return Action.D
        if current_stock <= 2 * self.n_players:
            return Action.D
        if recent_coop_rate == 0.0 and health_ratio < 0.4:
            return Action.D
        if health_ratio >= 0.7:
            return Action.C
        elif health_ratio >= 0.4:
            if recent_coop_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate population-level cooperation rate from the last 3 rounds.
        Returns the proportion of rounds where >= 50% of opponents played C.
        """
        if round_num == 0:
            return 1.0
        lookback = min(3, round_num)
        start_idx = round_num - lookback
        end_idx = round_num
        recent_actions = history.opponent_actions[start_idx:end_idx, :]
        coop_rounds = 0
        for round_actions in recent_actions:
            cooperators = np.sum(round_actions)
            if cooperators >= self.n_players / 2:
                coop_rounds += 1
        return coop_rounds / lookback if lookback > 0 else 1.0

class Strategy_COLLECTIVE_58(BaseStrategy):
    """
    Adaptive Stewardship Strategy: Sustainable Threshold Defection
    
    Balances individual payoff maximization with long-term resource preservation.
    Uses stock-dependent thresholds to decide between cooperation and defection,
    with special handling for endgame, recovery, and edge cases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.safe_threshold = self.capacity * 0.4
        self.crisis_threshold = self.capacity * 0.2
        self.recovery_threshold = self.capacity * 0.3
        self.near_full_threshold = self.capacity * 0.95

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number - 1
        if round_number == self.n_rounds - 1:
            return Action.D
        if current_stock <= self.crisis_threshold:
            return Action.D
        if current_stock < self.safe_threshold and rounds_remaining <= 2:
            return Action.D
        if round_number >= 1 and history is not None:
            if current_stock <= self.recovery_threshold:
                prev_stock_before_consumption = self._estimate_previous_stock(state, history, round_number)
                if prev_stock_before_consumption is not None:
                    stock_decline_ratio = (prev_stock_before_consumption - current_stock) / max(prev_stock_before_consumption, 1.0)
                    if stock_decline_ratio > 0.5:
                        return Action.D
        if current_stock > self.safe_threshold:
            return Action.C
        else:
            return Action.D

    def _estimate_previous_stock(self, state: CommonPoolState, history: PlayerHistory, round_number: int) -> float | None:
        """
        Estimate the stock level at the start of the current round
        by working backwards from known consumption patterns.
        
        Returns None if estimation is unreliable.
        """
        if round_number == 0:
            return None
        prev_round_idx = round_number - 1
        my_action = history.my_actions[prev_round_idx]
        opponent_actions = history.opponent_actions[prev_round_idx, :]
        n_defectors = int(np.sum(~opponent_actions)) + (0 if my_action else 1)
        n_cooperators = self.n_players - n_defectors
        return None

class Strategy_COLLECTIVE_59(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS) Strategy
    
    Balances individual resource security with collective pool sustainability.
    Adapts to stock levels and opponent behavior patterns while maintaining
    a bias toward cooperation. Maximizes long-term payoffs through sustainable
    resource management rather than short-term exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if stock <= 0:
            return Action.D
        if round_num == 0:
            return Action.C
        observed_defection_rate = self._calculate_defection_rate(history, round_num)
        base_action = self._get_base_action(stock, observed_defection_rate)
        final_action = self._apply_round_adjustments(base_action, round_num, stock, observed_defection_rate)
        return final_action

    def _calculate_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """Calculate the fraction of opponents who defected in the previous round."""
        if round_num == 0:
            return 0.0
        prev_round_idx = round_num - 1
        opponent_actions = history.opponent_actions[prev_round_idx, :]
        defections = np.sum(~opponent_actions)
        defection_rate = float(defections) / self.n_players
        return defection_rate

    def _get_base_action(self, stock: float, observed_defection_rate: float) -> Action:
        """
        Primary and secondary rules: determine action based on stock level
        and opponent behavior detection.
        """
        if observed_defection_rate > 0.5:
            high_threshold = self.capacity * 0.5
            low_threshold = self.capacity * 0.33
        else:
            high_threshold = self.capacity * 0.66
            low_threshold = self.capacity * 0.33
        if stock > high_threshold:
            return Action.C
        elif stock > low_threshold:
            return Action.C if random.random() < 0.75 else Action.D
        else:
            return Action.D

    def _apply_round_adjustments(self, base_action: Action, round_num: int, stock: float, observed_defection_rate: float) -> Action:
        """
        Apply tertiary rules for round-dependent adjustments.
        """
        round_ratio = round_num / self.n_rounds
        if round_ratio < 0.33:
            if base_action == Action.C:
                return Action.C
            else:
                if random.random() < 0.1:
                    return Action.C
                return Action.D
        elif round_ratio > 0.67:
            if stock < self.capacity * 0.33:
                return base_action
            elif base_action == Action.C:
                return Action.C
            else:
                if random.random() < 0.15:
                    return Action.C
                return Action.D
        return base_action

class Strategy_COLLECTIVE_60(BaseStrategy):
    """
    Adaptive Threshold Stewardship (ATS): A collective strategy that balances
    individual benefit with resource sustainability through stock-relative
    thresholding with decay pressure.
    
    Core mechanism: Cooperate when stock health exceeds a dynamic threshold
    that increases as the game approaches its final round, prioritizing
    early-round cooperation for compounding growth benefits.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_health = state.current_stock / self.capacity
        remaining_rounds = self.n_rounds - state.round_number
        decay_pressure = remaining_rounds / self.n_rounds
        cooperation_threshold = 0.4 + 0.4 * decay_pressure
        if stock_health >= cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_61(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection.
    
    Uses threshold-based conditional cooperation to balance resource sustainability
    with individual security. Cooperates when the resource is healthy AND observed
    cooperation rates exceed phase-dependent thresholds. Adapts expectations across
    game phases (early/middle/late) and tolerates reasonable imperfection in
    cooperation while maintaining self-protection against systematic over-consumption.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        stock = state.current_stock
        k = min(3, current_round)
        cooperation_rate = self._calculate_cooperation_rate(history, k, current_round)
        threshold = self._get_cooperation_threshold(current_round)
        resource_threshold = 1.5 * self.capacity / self.n_players
        resource_healthy = stock > resource_threshold
        history_good = cooperation_rate >= threshold
        if resource_healthy and history_good:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, k: int, current_round: int) -> float:
        """
        Calculate the cooperation rate over the last k rounds.
        cooperation_rate = total_C_actions_observed / (n_players * k)
        """
        if k == 0:
            return 1.0
        start_idx = max(0, current_round - k)
        recent_opponent_actions = history.opponent_actions[start_idx:current_round, :]
        total_cooperations = np.sum(recent_opponent_actions)
        total_possible = self.n_players * k
        if total_possible == 0:
            return 1.0
        cooperation_rate = float(total_cooperations) / float(total_possible)
        return cooperation_rate

    def _get_cooperation_threshold(self, current_round: int) -> float:
        """
        Get phase-dependent cooperation threshold.
        
        Phases:
        - Early (round <= r/3): threshold = 0.60
        - Middle (r/3 < round <= 2r/3): threshold = 0.70
        - Late (round > 2r/3): threshold = 0.75
        """
        third = self.n_rounds / 3.0
        two_thirds = 2.0 * self.n_rounds / 3.0
        if current_round <= third:
            return 0.6
        elif current_round <= two_thirds:
            return 0.7
        else:
            return 0.75

class Strategy_COLLECTIVE_62(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS): Balances immediate payoff with long-term
    sustainability through dynamic stock-threshold cooperation, collapse avoidance,
    and rapid depletion response mechanisms.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        collapse_threshold = self.capacity / (4 * self.n_players)
        if stock < collapse_threshold:
            return Action.D
        stock_previous_round = None
        consumption_previous_round = None
        stock_growth = None
        if history is not None and round_num > 0:
            prev_round_idx = round_num - 1
            my_action_prev = history.my_actions[prev_round_idx]
            my_consumption_prev = stock / (2 * self.n_players) if my_action_prev else stock / self.n_players
            opponent_cooperators_prev = sum(history.opponent_actions[prev_round_idx, :])
            opponent_defectors_prev = self.n_players - 1 - opponent_cooperators_prev
            total_cooperators_prev = (1 if my_action_prev else 0) + opponent_cooperators_prev
            total_defectors_prev = opponent_defectors_prev + (0 if my_action_prev else 1)
            consumption_previous_round = total_cooperators_prev * (stock / (2 * self.n_players)) + total_defectors_prev * (stock / self.n_players)
            stock_previous_round = stock
        if round_num == self.n_rounds - 1:
            if stock > self.capacity / 2:
                return Action.C
            else:
                return Action.D
        if history is not None and round_num > 0 and (stock_previous_round is not None):
            if stock_previous_round > 0:
                depletion_rate = (stock_previous_round - stock) / stock_previous_round
                if depletion_rate > 0.8:
                    return Action.C
        rounds_remaining = self.n_rounds - round_num
        progress_ratio = rounds_remaining / self.n_rounds
        sqrt_progress = math.sqrt(progress_ratio)
        threshold = self.capacity * (1 - (1 - sqrt_progress) / 2)
        if history is not None and round_num > 0:
            if stock > self.capacity * 0.7:
                threshold = threshold * 0.9
        if stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_63(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Sanctions.
    
    Cooperates to sustain the common pool resource, defects strategically when
    resource is depleted or exploitation is detected, and applies graduated
    sanctions proportional to observed defection rates. Balances individual
    extraction with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            return Action.C
        if current_round == 1:
            return Action.C
        recent_defection_rate = self._calculate_recent_defection_rate(history, current_round)
        if rounds_remaining <= 2 and current_stock > 0:
            return Action.D
        if recent_defection_rate > 0.66:
            return Action.D
        if recent_defection_rate <= 0.33:
            return self._apply_primary_rule(current_stock, rounds_remaining)
        if random.random() < 1.0 - recent_defection_rate:
            return self._apply_primary_rule(current_stock, rounds_remaining)
        else:
            return Action.D

    def _calculate_recent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the defection rate from opponents in the last 3 rounds.
        Defection is represented as False (0) in the action arrays.
        """
        lookback_rounds = min(3, current_round)
        if lookback_rounds == 0:
            return 0.0
        recent_opponent_actions = history.opponent_actions[-lookback_rounds:, :]
        total_actions = lookback_rounds * (self.n_players - 1)
        if total_actions == 0:
            return 0.0
        defections = np.sum(recent_opponent_actions == False)
        defection_rate = float(defections) / float(total_actions)
        return defection_rate

    def _apply_primary_rule(self, stock: float, rounds_remaining: int) -> Action:
        """
        Apply primary rule: Stock-responsive cooperation.
        """
        threshold_high = 0.75 * self.capacity
        threshold_medium = 0.5 * self.capacity
        threshold_low = 0.25 * self.capacity
        if stock > threshold_high:
            return Action.C
        if stock > threshold_medium:
            if rounds_remaining > 5:
                return Action.C
            else:
                return Action.D
        if stock > threshold_low:
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_64(BaseStrategy):
    """
    Adaptive Sustainable Harvest Strategy (ASHS)
    
    Balances personal security, collective sustainability, and adaptive resilience
    by coupling behavior to stock health. Cooperates when stock is depleted or
    declining, defects when stock is abundant or growing, with special end-game logic.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        stock_health = stock / self.capacity if self.capacity > 0 else 0.0
        if round_num <= 2:
            return Action.C
        if stock < 2 * self.n:
            return Action.C
        if stock < self.capacity / 3:
            return Action.C
        if round_num > 0.8 * self.r:
            if stock_health > 0.5:
                return Action.D
            else:
                return Action.C
        trend = self._compute_stock_trend(history, window=3)
        if stock_health <= 0.3:
            return Action.C
        elif stock_health <= 0.65:
            if trend in ['DECLINING', 'STABLE']:
                return Action.C
            else:
                return Action.D
        elif stock_health <= 0.85:
            if trend == 'DECLINING':
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _compute_stock_trend(self, history: PlayerHistory, window: int=3) -> str:
        """
        Compute stock trend from recent history.
        
        Returns: 'GROWING', 'DECLINING', or 'STABLE'
        """
        num_rounds = len(history.my_actions)
        if num_rounds < window:
            return 'STABLE'
        stocks = self._reconstruct_stocks(history)
        if len(stocks) < window:
            return 'STABLE'
        recent_stocks = stocks[-window:]
        first_stock = recent_stocks[0]
        last_stock = recent_stocks[-1]
        if last_stock > first_stock:
            return 'GROWING'
        elif last_stock < first_stock - 0.05 * self.capacity:
            return 'DECLINING'
        else:
            return 'STABLE'

    def _reconstruct_stocks(self, history: PlayerHistory) -> list:
        """
        Reconstruct stock levels at the start of each round based on history.
        """
        stocks = [self.capacity]
        current_stock = self.capacity
        for round_idx in range(len(history.my_actions)):
            cooperators = sum(history.opponent_actions[round_idx, :])
            if history.my_actions[round_idx]:
                cooperators += 1
            defectors = self.n - cooperators
            my_consumption = current_stock / (2 * self.n) if history.my_actions[round_idx] else current_stock / self.n
            total_opponent_consumption = 0.0
            for opp_idx in range(self.n - 1):
                if history.opponent_actions[round_idx, opp_idx]:
                    total_opponent_consumption += current_stock / (2 * self.n)
                else:
                    total_opponent_consumption += current_stock / self.n
            total_consumption = my_consumption + total_opponent_consumption
            stock_after_consumption = max(0.0, current_stock - total_consumption)
            growth = 2.0 * stock_after_consumption * (1.0 - stock_after_consumption / self.capacity)
            new_stock = min(stock_after_consumption + growth, self.capacity)
            current_stock = new_stock
            stocks.append(current_stock)
        return stocks

class Strategy_COLLECTIVE_65(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy for common pool resource games.
    
    Balances self-interest with resource preservation by:
    1. Protecting the common good as a prerequisite for sustained benefit
    2. Punishing over-extraction through conditional defection
    3. Rewarding restraint by maintaining cooperation
    4. Scaling responses to resource state urgency
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            return Action.C
        defection_rate = self._infer_defection_rate(history, current_round)
        stock_recovering = self._is_stock_recovering(history, current_round)
        consecutive_low_stock = self._count_consecutive_low_stock(history, current_round)
        if rounds_remaining == 1:
            if stock_health >= 0.5 or defection_rate < 0.2:
                return Action.C
            else:
                return Action.D
        if stock_recovering:
            return Action.C
        if stock_health >= 0.7:
            return Action.C
        if stock_health >= 0.4:
            if defection_rate >= 0.5:
                return Action.D
            else:
                return Action.C
        if stock_health >= 0.2:
            if defection_rate > 0.3:
                return Action.D
            else:
                return Action.C
        if consecutive_low_stock >= 2:
            return Action.D
        return Action.D

    def _infer_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Infer the defection rate of opponents from stock trajectory.
        
        Defection means consuming stock/n per player.
        Cooperation means consuming stock/(2n) per player.
        
        By examining consumption patterns inferred from stock changes,
        estimate the proportion of opponents defecting.
        """
        if current_round == 0:
            return 0.0
        lookback_rounds = min(3, current_round)
        start_idx = max(0, current_round - lookback_rounds)
        opponent_actions = history.opponent_actions[start_idx:current_round]
        if opponent_actions.size == 0:
            return 0.0
        defections = np.sum(~opponent_actions.astype(bool))
        total_actions = opponent_actions.size
        if total_actions == 0:
            return 0.0
        defection_rate = defections / total_actions
        return defection_rate

    def _is_stock_recovering(self, history: PlayerHistory, current_round: int) -> bool:
        """
        Check if stock shows a growth trend over the last 2+ rounds.
        """
        if current_round < 2:
            return False
        if current_round >= 2:
            recent_opponent_actions = history.opponent_actions[current_round - 2:current_round]
            if recent_opponent_actions.size > 0:
                defections = np.sum(~recent_opponent_actions.astype(bool))
                total = recent_opponent_actions.size
                recent_defection_rate = defections / total if total > 0 else 0.0
                if recent_defection_rate < 0.2:
                    return True
        return False

    def _count_consecutive_low_stock(self, history: PlayerHistory, current_round: int) -> int:
        """
        Count consecutive rounds where stock was likely low (high defection rate).
        Stock is inferred to be low when defection rates are high.
        """
        if current_round < 2:
            return 0
        consecutive = 0
        for i in range(current_round - 1, -1, -1):
            round_actions = history.opponent_actions[i:i + 1]
            if round_actions.size > 0:
                defections = np.sum(~round_actions.astype(bool))
                total = round_actions.size
                round_defection_rate = defections / total if total > 0 else 0.0
                if round_defection_rate > 0.4:
                    consecutive += 1
                else:
                    break
            else:
                break
        return consecutive

class Strategy_COLLECTIVE_66(BaseStrategy):
    """
    Adaptive Stock-Preserving Reciprocity (ASPR) strategy for Common Pool Resource games.
    
    Prioritizes long-term collective welfare by maintaining stock sustainability while
    opportunistically punishing defection. Uses stock health as primary decision criterion,
    with conditional reciprocity based on observed defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio < 0.25:
            return Action.D
        if current_stock < 2 * self.n_players:
            return Action.D
        if self._all_cooperated_recently(history, round_number):
            return Action.C
        if stock_ratio >= 0.75:
            return Action.C
        recent_defection_rate = self._calculate_recent_defection_rate(history, round_number)
        if stock_ratio >= 0.5:
            if recent_defection_rate <= 0.2:
                return Action.C
            else:
                return Action.D
        if recent_defection_rate > 0.3:
            return Action.D
        else:
            return Action.C

    def _all_cooperated_recently(self, history: PlayerHistory, round_number: int) -> bool:
        """
        Check if all players (including self) cooperated in the last 3 rounds.
        Returns True if perfect cooperation observed, False otherwise.
        """
        look_back = min(3, round_number)
        if look_back == 0:
            return False
        for i in range(round_number - look_back, round_number):
            if i >= 0 and (not history.my_actions[i]):
                return False
        for i in range(round_number - look_back, round_number):
            if i >= 0:
                for opponent_idx in range(self.n_players - 1):
                    if not history.opponent_actions[i, opponent_idx]:
                        return False
        return True

    def _calculate_recent_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the defection rate of opponents in the last 3 rounds.
        Returns a value between 0 and 1 representing the proportion of defections.
        """
        look_back = min(3, round_number)
        if look_back == 0:
            return 0.0
        total_actions = 0
        total_defections = 0
        for i in range(round_number - look_back, round_number):
            if i >= 0:
                for opponent_idx in range(self.n_players - 1):
                    total_actions += 1
                    if not history.opponent_actions[i, opponent_idx]:
                        total_defections += 1
        if total_actions == 0:
            return 0.0
        return total_defections / total_actions

class Strategy_COLLECTIVE_67(BaseStrategy):
    """
    Adaptive Stewardship with Defensive Thresholds.
    
    Prioritizes sustainable collective outcomes while maintaining resilience against exploitation.
    Uses stock-health-based cooperation with adaptive defection rate monitoring.
    Cooperates when stock is above critical threshold, defects when endangered.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.base_threshold_ratio = 0.3
        self.defection_rate_weight = 0.15
        self.high_defection_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        n = self.game_description.n_players
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.C
        base_threshold = capacity * self.base_threshold_ratio
        adjusted_threshold = base_threshold
        if current_round > 0 and history is not None:
            previous_round_idx = current_round - 1
            cooperators_last_round = int(np.sum(history.opponent_actions[previous_round_idx, :]))
            defectors_last_round = n - cooperators_last_round
            my_action_last_round = history.my_actions[previous_round_idx]
            total_players_analyzed = n
            total_defectors = defectors_last_round
            if not my_action_last_round:
                pass
            if len(history.opponent_actions[previous_round_idx, :]) > 0:
                opponent_cooperators = int(np.sum(history.opponent_actions[previous_round_idx, :]))
                opponent_defectors = n - 1 - opponent_cooperators
                defection_rate = opponent_defectors / n if n > 0 else 0
            else:
                defection_rate = 0
            if defection_rate > self.high_defection_threshold:
                adjusted_threshold = base_threshold + defection_rate * self.defection_rate_weight * capacity
        if current_round == self.game_description.n_rounds - 1:
            if stock > adjusted_threshold:
                return Action.C
            else:
                return Action.D
        if stock > adjusted_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_68(BaseStrategy):
    """
    Adaptive Conservation with Reciprocal Enforcement strategy for Common Pool Resource games.
    
    Prioritizes long-term collective welfare through:
    1. Leading by example (cooperate first round)
    2. Stock-aware adaptation (stricter conservation as stock depletes)
    3. Graduated reciprocal responses to defection
    4. Temporal awareness (endgame dynamics)
    
    Core principle: Treat the commons as a shared patient requiring stewardship,
    not an individual extraction opportunity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.C
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio < 0.3:
            return Action.C
        last_round_idx = round_num - 1
        last_round_defections = sum((1 for action in history.opponent_actions[last_round_idx, :] if not action))
        defection_rate_last = last_round_defections / self.n_players
        if stock_ratio < 0.6:
            if defection_rate_last > 0.5:
                return Action.D
            else:
                return Action.C
        rounds_to_check = min(3, round_num)
        total_defections = 0
        total_checks = 0
        for i in range(round_num - rounds_to_check, round_num):
            if i >= 0:
                last_round_defs = sum((1 for action in history.opponent_actions[i, :] if not action))
                total_defections += last_round_defs
                total_checks += self.n_players
        recent_defection_rate = total_defections / total_checks if total_checks > 0 else 0.0
        if round_num == self.n_rounds - 1:
            if stock_ratio >= 0.6:
                return Action.C
            elif stock_ratio < 0.3:
                return Action.C
            elif defection_rate_last > 0.33:
                return Action.D
            else:
                return Action.C
        if round_num >= self.n_rounds - 2:
            if recent_defection_rate > 0.33:
                return Action.D
            else:
                return Action.C
        if recent_defection_rate > 0.25:
            if recent_defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_69(BaseStrategy):
    """
    Adaptive Stewardship with Contingent Defection
    
    A stock-aware strategy that prioritizes long-term collective welfare by:
    1. Cooperating when stock is healthy (>75% capacity)
    2. Defecting when stock is critical (<25% capacity)
    3. Using conditional logic based on recent defection rates in the moderate zone
    4. Tracking opponent behavior over a sliding window to detect persistent exploitation
    5. Allowing recovery from mutual defection when conditions improve
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if stock > 0.75 * self.capacity:
            return Action.C
        if stock < 0.25 * self.capacity:
            return Action.D
        if round_num == 0:
            return Action.C
        prev_defection_rate = self._get_previous_round_defection_rate(history)
        opponent_defection_rate = self._get_opponent_defection_rate(history, round_num)
        adjusted_defection_rate = prev_defection_rate
        if opponent_defection_rate > 0.5:
            adjusted_defection_rate = min(1.0, prev_defection_rate + 0.2)
        if round_num >= 2 and opponent_defection_rate > 0.5:
            stock_improving = stock > history.opponent_payoffs[-2, 0] if len(history.opponent_payoffs) > 1 else False
            if self._is_stock_recovering(history, round_num):
                return Action.C
        if adjusted_defection_rate <= 0.33:
            return Action.C
        else:
            return Action.D

    def _get_previous_round_defection_rate(self, history: PlayerHistory) -> float:
        """Calculate the defection rate in the previous round."""
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        prev_round_actions = history.opponent_actions[-1, :]
        defectors = np.sum(~prev_round_actions)
        defection_rate = float(defectors) / self.n_players
        return defection_rate

    def _get_opponent_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """Calculate average opponent defection rate over last 3 rounds."""
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        lookback = min(3, round_num)
        if lookback == 0:
            return 0.0
        recent_actions = history.opponent_actions[-lookback:, :]
        defectors = np.sum(~recent_actions)
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        defection_rate = float(defectors) / total_actions
        return defection_rate

    def _is_stock_recovering(self, history: PlayerHistory, round_num: int) -> bool:
        """Check if stock has been recovering in recent rounds."""
        if round_num < 2 or history is None:
            return False
        if len(history.my_payoffs) < 2:
            return False
        recent_payoffs = history.my_payoffs[-2:]
        return recent_payoffs[-1] > recent_payoffs[-2]

class Strategy_COLLECTIVE_70(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Monitors collective resource health and adapts behavior to sustain the resource
    while punishing defection. Uses stock-based decision zones (critical, degraded, healthy)
    and graduated punishment mechanisms based on recent opponent defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_punishment_reset_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        defection_rate = self._calculate_recent_defection_rate(history, round_num)
        is_critical = stock < 2 * self.n
        is_degraded = 2 * self.n <= stock < 0.75 * self.capacity
        is_healthy = stock >= 0.75 * self.capacity
        is_at_capacity = stock >= 0.95 * self.capacity
        if is_critical:
            self.defection_punishment_reset_counter = 0
            return Action.C
        if is_at_capacity:
            self.defection_punishment_reset_counter = 0
            return Action.C
        rounds_remaining = self.r - round_num
        if rounds_remaining <= 2:
            if stock > 0.5 * self.capacity:
                return Action.D
            else:
                return Action.C
        if is_healthy:
            if defection_rate > 0.4:
                self.defection_punishment_reset_counter = 0
                return Action.D
            else:
                if defection_rate <= 0.2:
                    self.defection_punishment_reset_counter += 1
                else:
                    self.defection_punishment_reset_counter = 0
                return Action.C
        if is_degraded:
            if defection_rate <= 0.2:
                self.defection_punishment_reset_counter += 1
                if self.defection_punishment_reset_counter >= 2:
                    return Action.C
            else:
                self.defection_punishment_reset_counter = 0
            if defection_rate > 0.3:
                return Action.D
            else:
                return Action.C
        return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate defection rate from last 3 rounds of opponent behavior.
        Returns fraction of opponents playing D (0.0 to 1.0).
        """
        if round_num == 0:
            return 0.0
        window_start = max(0, round_num - 3)
        window_end = round_num
        if window_start >= window_end:
            return 0.0
        total_opponent_actions = 0
        total_defections = 0
        for round_idx in range(window_start, window_end):
            actions_this_round = history.opponent_actions[round_idx, :]
            cooperations = np.sum(actions_this_round)
            defections = len(actions_this_round) - cooperations
            total_opponent_actions += len(actions_this_round)
            total_defections += defections
        if total_opponent_actions == 0:
            return 0.0
        defection_rate = total_defections / total_opponent_actions
        return defection_rate

class Strategy_COLLECTIVE_71(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS) for Common Pool Resource Game.
    
    Balances individual benefit extraction with collective sustainability by:
    - Cooperating when pool is healthy (≥75% capacity)
    - Adapting cooperation probability based on opponent behavior when stressed (40-75%)
    - Forcing cooperation when critical (<40% or <1.5×2n stock)
    - Detecting defection spirals and extracting value only if sustainable
    - Always cooperating in final round to honor resource commitment
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.C
        critical_threshold = 2 * self.n_players * 1.5
        if current_stock < critical_threshold:
            return Action.C
        if stock_ratio >= 0.75:
            return Action.C
        if stock_ratio < 0.4:
            return Action.C
        if 0.4 <= stock_ratio < 0.75:
            opponent_coop_rate = self._calculate_opponent_cooperation_rate(history)
            cooperation_rate = 0.5 * opponent_coop_rate + 0.3
            cooperation_rate = min(cooperation_rate, 0.85)
            cooperation_rate = max(cooperation_rate, 0.15)
            if stock_ratio < 0.5:
                cooperation_rate = min(cooperation_rate + 0.2, 0.9)
            if round_number >= 3:
                recent_defection_rate = self._calculate_recent_defection_rate(history, rounds_back=3)
                if recent_defection_rate > 0.7:
                    if stock_ratio >= 0.5:
                        return Action.D
                    else:
                        return Action.C
            if 0.35 <= stock_ratio < 0.55:
                if opponent_coop_rate < 0.3:
                    cooperation_rate = 0.85
            if random.random() < cooperation_rate:
                return Action.C
            else:
                return Action.D
        return Action.C

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the cooperation rate of all opponents across all previous rounds.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.5
        total_observations = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
        if total_observations == 0:
            return 0.5
        observed_cooperations = np.sum(history.opponent_actions)
        opponent_cooperation_rate = float(observed_cooperations) / float(total_observations)
        return opponent_cooperation_rate

    def _calculate_recent_defection_rate(self, history: PlayerHistory, rounds_back: int=3) -> float:
        """
        Calculate the defection rate of opponents in the most recent rounds.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        num_rounds_available = history.opponent_actions.shape[0]
        start_idx = max(0, num_rounds_available - rounds_back)
        recent_actions = history.opponent_actions[start_idx:, :]
        if recent_actions.size == 0:
            return 0.0
        total_recent = recent_actions.size
        defections = total_recent - int(np.sum(recent_actions))
        recent_defection_rate = float(defections) / float(total_recent) if total_recent > 0 else 0.0
        return recent_defection_rate

class Strategy_COLLECTIVE_72(BaseStrategy):
    """
    Adaptive Stewardship: A collective strategy balancing sustainability, reciprocity, and robustness
    in common pool resource games. Maintains resource health through state-dependent decision rules
    and observation-based reciprocity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 1.5 * self.n
        self.safe_threshold = 1.2 * self.capacity
        self.target_stock = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if stock < self.critical_threshold:
            return Action.C
        if round_num == self.r - 1:
            if stock > self.critical_threshold:
                return Action.D
            else:
                return Action.C
        recent_window = min(5, round_num)
        recent_rounds = list(range(round_num - recent_window, round_num))
        opponent_defection_count = 0
        for t in recent_rounds:
            defections_in_round = sum((1 for action in history.opponent_actions[t, :] if not action))
            opponent_defection_count += defections_in_round
        total_opponent_observations = (self.n - 1) * recent_window
        if total_opponent_observations > 0:
            opponent_defection_rate = opponent_defection_count / total_opponent_observations
        else:
            opponent_defection_rate = 0.0
        if stock >= self.safe_threshold:
            if opponent_defection_rate > 0.5:
                if stock > 1.3 * self.n and self.r - round_num > 3:
                    return Action.C if random.random() < 0.4 else Action.D
                else:
                    return Action.D
            elif opponent_defection_rate < 0.2:
                return Action.C
            elif stock > self.target_stock:
                return Action.C
            else:
                return Action.D
        else:
            trend_window = min(3, round_num)
            if trend_window > 0:
                stock_trend = stock - history.my_payoffs[round_num - trend_window]
            else:
                stock_trend = 0.0
            if stock_trend > 0:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_73(BaseStrategy):
    """
    Adaptive Sustainability Strategy (ASS) for Common Pool Resource Game.
    
    Prioritizes collective long-term sustainability over short-term individual gains.
    Adapts decisions based on stock levels and observed defection rates:
    - Phase 1 (High Stock): DEFECT to exploit abundance
    - Phase 2 (Caution Zone): COOPERATE to preserve resource
    - Phase 3 (Crisis Zone): COOPERATE to save the commons
    - Special handling for first/last rounds and defection cascades
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainability_line = self.capacity * 0.6
        self.critical_threshold = self.capacity * 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            if current_stock > self.critical_threshold:
                return Action.D
            else:
                return Action.C
        if round_number >= 1:
            prev_round_idx = round_number - 1
            prev_defectors = sum((1 for action in history.opponent_actions[prev_round_idx, :] if not action))
            prev_defection_rate = prev_defectors / self.n_players
            if prev_defection_rate > 0.5:
                if round_number >= 2:
                    prev_prev_stock = self._estimate_stock_at_round(history, round_number - 2)
                    if current_stock < prev_prev_stock:
                        return Action.C
        if current_stock >= self.sustainability_line:
            return Action.D
        elif current_stock > self.critical_threshold:
            return Action.C
        else:
            return Action.C

    def _estimate_stock_at_round(self, history: PlayerHistory, round_idx: int) -> float:
        """
        Estimate stock level at a given round by working backward from payoffs.
        Uses the relationship: payoff = stock / (2*n) for cooperators, stock / n for defectors.
        """
        if round_idx < 0:
            return self.capacity
        my_payoff = history.my_payoffs[round_idx]
        my_action = history.my_actions[round_idx]
        if my_action:
            estimated_stock = my_payoff * 2 * self.n_players
        else:
            estimated_stock = my_payoff * self.n_players
        return max(0.0, estimated_stock)

class Strategy_COLLECTIVE_74(BaseStrategy):
    """
    Adaptive Sustainability Stewardship (ASS) Strategy
    
    Balances individual welfare with collective resource sustainability through:
    - Health-based mode switching (Opportunistic vs Conservation)
    - Conditional cooperation with forgiveness
    - Adaptive defection thresholds based on observed behavior
    - Special handling for edge cases (first round, last round, stock collapse)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.health_threshold = 0.5
        self.defection_tolerance = 0.3
        self.escalation_threshold = 0.6
        self.conservation_defection_threshold = 0.2
        self.lookback_window = 5
        self.stock_depletion_threshold = 0.7
        self.collapse_threshold = 2 * self.n_players
        self.recovery_stock_ratio = 0.6
        self.recovery_defection_tolerance = 0.15
        self.defect_for_rounds = 0
        self.last_two_rounds_increasing = False
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        self.stock_history.append(state.current_stock)
        current_round = state.round_number
        current_stock = state.current_stock
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if self.defect_for_rounds > 0:
            self.defect_for_rounds -= 1
            return Action.D
        if current_stock < self.collapse_threshold:
            return Action.C
        if current_round == self.n_rounds - 1:
            if current_stock < 0.1 * self.capacity:
                return Action.D
        observed_defection_rate = self._calculate_recent_defection_rate(history, current_round)
        if stock_ratio > self.health_threshold:
            return self._opportunistic_mode(current_round, observed_defection_rate, history)
        else:
            return self._conservation_mode(current_round, current_stock, observed_defection_rate)

    def _calculate_recent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """Calculate defection rate from opponents in recent rounds."""
        if current_round == 0:
            return 0.0
        lookback = min(self.lookback_window, current_round)
        start_round = current_round - lookback
        recent_actions = history.opponent_actions[start_round:current_round, :]
        defections = np.sum(~recent_actions)
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        return float(defections) / float(total_actions)

    def _check_recovery_momentum(self) -> bool:
        """Check if stock has been increasing for last 2 rounds."""
        if len(self.stock_history) < 3:
            return False
        last_round_stock = self.stock_history[-1]
        prev_round_stock = self.stock_history[-2]
        two_rounds_ago_stock = self.stock_history[-3]
        return last_round_stock > prev_round_stock and prev_round_stock > two_rounds_ago_stock

    def _opportunistic_mode(self, current_round: int, observed_defection_rate: float, history: PlayerHistory) -> Action:
        """
        Generous Tit-for-Tat with Forgiveness when stock is healthy.
        """
        if self._check_recovery_momentum() and len(self.stock_history) > 0 and (self.stock_history[-1] / self.capacity > self.recovery_stock_ratio):
            defection_tolerance = self.recovery_defection_tolerance
        else:
            defection_tolerance = self.defection_tolerance
        if observed_defection_rate < defection_tolerance:
            return Action.C
        elif observed_defection_rate < self.escalation_threshold:
            return Action.D
        else:
            self.defect_for_rounds = min(2, self.n_rounds - current_round - 1)
            return Action.D

    def _conservation_mode(self, current_round: int, current_stock: float, observed_defection_rate: float) -> Action:
        """
        Strict Harm Minimization when stock is depleted.
        """
        if observed_defection_rate > self.conservation_defection_threshold:
            return Action.D
        rounds_until_end = self.n_rounds - current_round
        if rounds_until_end <= 0:
            return Action.C
        stock_per_round_needed = current_stock / rounds_until_end
        sustainable_consumption = self.capacity / (2 * self.n_players)
        if stock_per_round_needed < self.stock_depletion_threshold * sustainable_consumption:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_75(BaseStrategy):
    """
    Adaptive Conservation with Graduated Defection Control.
    
    This strategy maintains the common pool by cooperating when stock is healthy,
    defensively defecting when stressed, and always defecting in the final round.
    Stock health is assessed via ratio thresholds: healthy (≥0.60), stressed (0.30-0.60),
    and critical (<0.30).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.healthy_threshold = 0.6
        self.stressed_threshold = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if self.game_description.capacity <= 0:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio >= self.healthy_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_76(BaseStrategy):
    """
    Adaptive Regeneration Conservation (ARC) Strategy
    
    A collective strategy that prioritizes sustainable stock maintenance over individual
    short-term gains. Cooperates when stock is healthy (≥50% capacity), defects when
    stock is depleted (<50% capacity) to minimize extraction and allow recovery.
    
    Core insight: Stock health is the critical shared asset. Maintaining it benefits
    all players across rounds through compound growth opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.epsilon = 1e-06

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_health_ratio = state.current_stock / self.game_description.capacity
        if stock_health_ratio >= self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_77(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Response strategy for Common Pool Resource Game.
    
    Prioritizes collective long-term welfare through three decision modes:
    1. Stewardship Mode (default): Cooperate to maintain stock health
    2. Cautionary Mode: Shift toward defection as stock depletes
    3. Recovery Mode: Return to cooperation when stock shows regeneration potential
    
    Uses resource health thresholds and graduated probabilistic response to opponent defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        resource_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        if current_round == self.n_rounds - 1:
            if current_stock > 0:
                return Action.D
            return Action.D
        defectors_last_round = sum((1 for action in history.opponent_actions[-1, :] if not action))
        defection_rate = defectors_last_round / self.n_players if self.n_players > 0 else 0.0
        if resource_health < 0.15:
            return Action.D
        if resource_health < 0.3 and defection_rate >= 0.5:
            return Action.D
        if defection_rate > 0.5:
            if random.random() < defection_rate:
                return Action.D
            return Action.C
        if defection_rate > 0.25:
            if random.random() < defection_rate * 0.5:
                return Action.D
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_78(BaseStrategy):
    """
    Adaptive Sustainability Management (ASM) Strategy.
    
    Prioritizes long-term collective welfare through sustainability-first approach,
    conditional reciprocity, and adaptive aggression based on stock health and
    opponent behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if current_stock <= 2 * self.n_players:
            return Action.D
        total_actions = current_round * (self.n_players - 1)
        if total_actions > 0:
            total_defections = np.sum(~history.opponent_actions[:current_round, :])
            global_defection_rate = total_defections / total_actions
        else:
            global_defection_rate = 0.0
        base_threshold_high = 0.75
        base_threshold_mid = 0.5
        base_threshold_low = 0.25
        if global_defection_rate > 0.66:
            base_threshold_mid = 0.65
            base_threshold_low = 0.4
        elif global_defection_rate < 0.33:
            base_threshold_high = 0.6
            base_threshold_mid = 0.4
        if current_round == self.n_rounds - 1:
            if stock_ratio >= 0.4:
                return Action.C
            else:
                return Action.D
        if current_round >= 3:
            recent_rounds = min(3, current_round)
            all_cooperated = np.all(history.opponent_actions[current_round - recent_rounds:current_round, :])
            if all_cooperated:
                return Action.C
        if current_round >= 2:
            recent_rounds = min(2, current_round)
            all_defected = np.all(~history.opponent_actions[current_round - recent_rounds:current_round, :])
            if all_defected:
                return Action.D
        if stock_ratio >= base_threshold_high:
            return Action.C
        elif stock_ratio >= base_threshold_mid:
            last_round_cooperators = np.sum(history.opponent_actions[current_round - 1, :])
            majority_threshold = (self.n_players - 1) / 2.0
            if last_round_cooperators > majority_threshold:
                return Action.C
            else:
                return Action.D
        elif stock_ratio >= base_threshold_low:
            if global_defection_rate <= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_79(BaseStrategy):
    """
    Adaptive Sustainable Harvesting (ASH) Strategy
    
    Prioritizes long-term collective welfare by maintaining stock health while
    adaptively responding to defection. Balances sustainability with opportunistic
    exploitation only when necessary or when others are free-riding.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if current_stock < self.capacity * 0.3:
            return Action.D
        if current_stock >= self.capacity * 0.7:
            return Action.C
        if current_stock < self.capacity * 0.5:
            observed_defection_rate = self._calculate_defection_rate(history, round_number)
            if observed_defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        stock_ratio = (current_stock - self.capacity * 0.5) / (self.capacity * 0.2)
        expected_defection = max(0.0, min(1.0, stock_ratio))
        observed_defection_rate = self._calculate_defection_rate(history, round_number)
        if observed_defection_rate > expected_defection:
            return Action.D
        else:
            return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the observed defection rate from the previous round.
        
        Returns a value in [0, 1] representing the proportion of players who defected.
        Handles edge case where calculation denominator could be zero.
        """
        if round_number <= 0:
            return 0.0
        last_round_idx = round_number - 1
        opponent_defections = np.sum(~history.opponent_actions[last_round_idx, :])
        my_last_action = history.my_actions[last_round_idx]
        my_last_defected = not my_last_action
        total_defections = opponent_defections + (1 if my_last_defected else 0)
        defection_rate = total_defections / self.n_players
        return float(defection_rate)

class Strategy_COLLECTIVE_80(BaseStrategy):
    """
    Adaptive Sustainable Stewardship Strategy (ASSS)
    
    Prioritizes long-term collective sustainability while remaining robust against exploitation.
    Adapts decisions based on stock health indicator (SHI), recent defection rate (RDR),
    and remaining rounds. Uses a decision matrix to balance cooperation for commons preservation
    with strategic defection when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.high_threshold = 0.7
        self.medium_threshold = 0.4
        self.low_threshold = 0.4
        self.defection_tolerance = 0.5
        self.critical_defection = 0.75
        self.critical_stock = 2 * self.n_players

    def _calculate_stock_health_indicator(self, current_stock: float) -> float:
        """Calculate SHI = current_stock / capacity"""
        if self.capacity == 0:
            return 0.0
        return current_stock / self.capacity

    def _calculate_recent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate RDR as proportion of defectors in last 3 rounds.
        Returns defection rate across observed opponents.
        """
        lookback = min(3, current_round)
        if lookback == 0:
            return 0.0
        total_defections = 0
        total_observations = 0
        for round_idx in range(current_round - lookback, current_round):
            if round_idx >= 0:
                defectors_in_round = np.sum(~history.opponent_actions[round_idx, :])
                total_defections += defectors_in_round
                total_observations += self.n_players
        if total_observations == 0:
            return 0.0
        return total_defections / total_observations

    def _get_last_round_defection_count(self, history: PlayerHistory, current_round: int) -> int:
        """Count number of defectors in the immediately previous round"""
        if current_round == 0:
            return 0
        return int(np.sum(~history.opponent_actions[current_round - 1, :]))

    def _calculate_sustainability_ratio(self, current_round: int) -> float:
        """Calculate SR = rounds_remaining / total_rounds"""
        rounds_remaining = self.n_rounds - current_round
        if self.n_rounds == 0:
            return 0.0
        return rounds_remaining / self.n_rounds

    def _apply_decision_matrix(self, shi: float, rdr: float, sustainability_ratio: float, current_round: int, history: PlayerHistory) -> Action:
        """
        Apply the decision matrix based on stock health, defection rate, and time remaining.
        Returns Action.C or Action.D
        """
        if shi >= self.high_threshold:
            return Action.C
        elif shi < self.low_threshold:
            if current_round > 0:
                defectors_last_round = self._get_last_round_defection_count(history, current_round)
                last_round_defection_rate = defectors_last_round / self.n_players
            else:
                last_round_defection_rate = 0.0
            if last_round_defection_rate >= self.critical_defection:
                return Action.D
            if rdr > self.defection_tolerance:
                return Action.D
            if sustainability_ratio <= 2.0 / self.n_rounds:
                return Action.D
            return Action.C
        elif rdr < self.defection_tolerance:
            if sustainability_ratio > 2.0 / self.n_rounds:
                return Action.C
            else:
                return self._apply_conditional_cooperation(history, current_round)
        else:
            return self._apply_conditional_cooperation(history, current_round)

    def _apply_conditional_cooperation(self, history: PlayerHistory, current_round: int) -> Action:
        """
        Conditional cooperation rule for uncertain situations.
        Endgame or high-defection scenarios.
        """
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= 2:
            return Action.D
        if current_round > 0:
            defectors_last_round = self._get_last_round_defection_count(history, current_round)
            last_round_defection_rate = defectors_last_round / self.n_players
            if last_round_defection_rate >= self.defection_tolerance:
                return Action.D
        return Action.C

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            shi = self._calculate_stock_health_indicator(current_stock)
            if shi >= 0.5:
                return Action.C
            else:
                return Action.D
        shi = self._calculate_stock_health_indicator(current_stock)
        rdr = self._calculate_recent_defection_rate(history, current_round)
        sustainability_ratio = self._calculate_sustainability_ratio(current_round)
        if current_stock <= self.critical_stock:
            if current_round > 0:
                defectors_last_round = self._get_last_round_defection_count(history, current_round)
                last_round_defection_rate = defectors_last_round / self.n_players
            else:
                last_round_defection_rate = 0.0
            if last_round_defection_rate >= self.critical_defection:
                return Action.D
            else:
                return Action.C
        return self._apply_decision_matrix(shi, rdr, sustainability_ratio, current_round, history)

class Strategy_COLLECTIVE_81(BaseStrategy):
    """
    Adaptive Stewardship: A collective strategy that prioritizes long-term sustainability
    by using stock-conditional cooperation. The decision threshold dynamically adjusts
    based on remaining rounds, creating aggressive early/middle-game protection and
    graceful late-game degradation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number
        progress_ratio = rounds_remaining / self.n_rounds
        threshold = self.capacity * progress_ratio ** 2
        if current_stock >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_82(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS) Strategy
    
    A collective strategy that prioritizes sustainable resource management by assessing
    stock health and adapting behavior accordingly. Cooperates when resources are healthy,
    responds to defection when stressed, and extracts value when critical.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        shr = current_stock / self.capacity if self.capacity > 0 else 0.0
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            if shr >= 0.6:
                return Action.C
            else:
                return Action.D
        if shr >= 0.6:
            return Action.C
        elif shr >= 0.3:
            prior_round_actions = history.opponent_actions[current_round - 1, :]
            defection_count = sum((1 for action in prior_round_actions if not action))
            defection_rate = defection_count / self.n_players if self.n_players > 0 else 0.0
            if defection_rate >= 0.5:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_83(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS): Balances individual payoff maximization 
    with resource sustainability through dynamic thresholds based on stock health 
    and opponent aggression indices.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        shi = current_stock / self.capacity if self.capacity > 0 else 0.0
        oai = self._calculate_oai(history, state.round_number)
        growth_ratio = self._calculate_growth_ratio(current_stock)
        if current_stock <= 0:
            return Action.D
        if shi < 0.3 and oai > 0.6:
            return Action.D
        if shi < 0.2:
            return Action.C
        if shi > 0.8:
            return Action.C
        if 0.2 <= shi <= 0.6:
            if growth_ratio > 0.5 and oai < 0.5:
                return Action.C
            elif oai > 0.6:
                return Action.D
            else:
                return Action.C
        if shi > 0.6:
            if oai < 0.3:
                return Action.C
            else:
                return Action.D
        return Action.C

    def _calculate_oai(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate Opponent Aggression Index based on defections in last 2 rounds.
        OAI = (total_defections_observed_last_2_rounds) / (2 × n × 2)
        """
        if round_number < 1:
            return 0.0
        start_round = max(0, round_number - 2)
        end_round = round_number
        defection_count = 0
        total_opponent_actions = 0
        for r in range(start_round, end_round):
            if r < len(history.opponent_actions):
                defections_this_round = np.sum(history.opponent_actions[r, :] == False)
                defection_count += defections_this_round
                total_opponent_actions += self.n
        if total_opponent_actions == 0:
            return 0.0
        oai = defection_count / total_opponent_actions
        return oai

    def _calculate_growth_ratio(self, current_stock: float) -> float:
        """
        Calculate Expected Growth Potential ratio.
        If stock is consumed uniformly by all cooperators:
        remaining_after_universal_C = stock - (stock / 2)
        growth = 2 * remaining * (1 - remaining / capacity)
        growth_ratio = growth / remaining
        """
        if current_stock <= 0 or self.capacity <= 0:
            return 0.0
        remaining_after_universal_c = current_stock - current_stock / 2.0
        if remaining_after_universal_c <= 0:
            return 0.0
        growth = 2.0 * remaining_after_universal_c * (1.0 - remaining_after_universal_c / self.capacity)
        growth_ratio = growth / remaining_after_universal_c
        return growth_ratio

class Strategy_COLLECTIVE_84(BaseStrategy):
    """
    Collective Adaptive Resource Stewardship (CARS) Strategy
    
    Balances individual payoff maximization with collective long-term sustainability
    through adaptive threshold-based cooperation driven by a Dynamic Sustainability Index (DSI).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_high = 0.75
        self.threshold_medium = 0.5
        self.threshold_low = 0.15

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        dsi = state.current_stock / self.game_description.capacity if self.game_description.capacity > 0 else 0.0
        if state.round_number == self.game_description.n_rounds - 1:
            if dsi >= self.threshold_medium:
                return Action.C
            else:
                return Action.D
        if dsi < self.threshold_low:
            return Action.D
        previous_round_idx = state.round_number - 1
        defector_count = sum((1 for action in history.opponent_actions[previous_round_idx, :] if not action))
        dps = defector_count / self.game_description.n_players if self.game_description.n_players > 0 else 0.0
        if dps > 0.5:
            if dsi < 0.6:
                return Action.C
            else:
                return Action.D
        if dsi >= self.threshold_high:
            return Action.D
        elif dsi >= self.threshold_medium:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_85(BaseStrategy):
    """
    Adaptive Sustainability Protocol (ASP): Balances collective resource preservation
    with individual payoff maximization. Cooperates when stock is healthy, conditionally
    cooperates under stress based on opponent behavior, and defects when resource is
    critically depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        health_ratio = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        if health_ratio >= 0.75:
            status = 'THRIVING'
        elif health_ratio >= 0.5:
            status = 'HEALTHY'
        elif health_ratio >= 0.25:
            status = 'STRESSED'
        elif health_ratio > 0:
            status = 'CRITICAL'
        else:
            status = 'COLLAPSED'
        prev_round_idx = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        defection_count = int(sum(~opponent_actions_prev))
        defection_rate = defection_count / (self.n_players - 1) if self.n_players > 1 else 0.0
        if status in ['THRIVING', 'HEALTHY']:
            return Action.C
        elif status == 'STRESSED':
            if defection_rate <= 0.5:
                return Action.C
            else:
                return Action.D
        elif status in ['CRITICAL', 'COLLAPSED']:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_86(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS): Balances individual gain with collective 
    sustainability by adapting cooperation based on stock health and opponent behavior.
    
    Core logic:
    - CRITICAL/DANGER zones (0-40% capacity): DEFECT for survival
    - CAUTION zone (40-70%): DEFECT if defection rate > 25%, else COOPERATE
    - HEALTHY zone (70-100%): COOPERATE unless high defection or last round
    - Last round: DEFECT if stock > CRITICAL threshold
    - First round: COOPERATE to establish baseline
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        stock_percentage = current_stock / self.capacity * 100.0 if self.capacity > 0 else 0.0
        if current_stock <= 0:
            return Action.C
        if stock_percentage < 20.0:
            return Action.D
        if stock_percentage < 40.0:
            return Action.D
        if round_number == self.n_rounds - 1:
            if stock_percentage >= 20.0:
                return Action.D
            else:
                return Action.C
        if stock_percentage < 70.0:
            recent_defection_rate = self._calculate_recent_defection_rate(history)
            if recent_defection_rate > 0.5:
                return Action.D
            elif recent_defection_rate > 0.25:
                return Action.D
            else:
                return Action.C
        recent_defection_rate = self._calculate_recent_defection_rate(history)
        if recent_defection_rate >= 0.25:
            return Action.D
        else:
            return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the defection rate of opponents in the most recent 
        min(3, rounds_played) rounds.
        
        Returns defection rate as a float in [0, 1].
        Handles edge cases where no history exists.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        rounds_played = len(history.opponent_actions)
        lookback_rounds = min(3, rounds_played)
        recent_actions = history.opponent_actions[-lookback_rounds:, :]
        num_defections = np.sum(recent_actions == False)
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        defection_rate = float(num_defections) / float(total_actions)
        return defection_rate

class Strategy_COLLECTIVE_87(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual payoff maximization with collective resource preservation.
    Uses stock-based thresholds, defection rate monitoring, and adaptive endgame tactics
    to maintain sustainable cooperation while protecting against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.critical_threshold = self.capacity * 0.4
        self.collapse_threshold = self.capacity * 0.1
        self.recovery_threshold = self.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - state.round_number
        if rounds_remaining <= 2:
            if current_stock > self.critical_threshold:
                return Action.C
            else:
                return Action.D
        if current_stock < self.collapse_threshold and rounds_remaining > 2:
            return Action.D
        recent_defection_rate = self._calculate_recent_defection_rate(history)
        if self._is_unanimous_cooperation(history):
            if current_stock > self.critical_threshold:
                return Action.C
        if self._is_unanimous_defection(history):
            return Action.D
        if recent_defection_rate > 0.5:
            return Action.D
        if recent_defection_rate < 0.33 and current_stock > self.critical_threshold:
            return Action.C
        if 0.25 < recent_defection_rate < 0.75:
            return Action.C if current_stock > self.critical_threshold else Action.D
        return Action.C if current_stock > self.critical_threshold else Action.D

    def _calculate_recent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate defection rate across all players in the last 3 rounds.
        Returns proportion of DEFECT actions (False/0) in recent history.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        start_idx = max(0, len(history.opponent_actions) - 3)
        recent_opponent_actions = history.opponent_actions[start_idx:]
        total_actions = recent_opponent_actions.size
        if total_actions == 0:
            return 0.0
        defections = total_actions - int(np.sum(recent_opponent_actions))
        return defections / total_actions

    def _is_unanimous_cooperation(self, history: PlayerHistory) -> bool:
        """
        Check if all opponents cooperated in the last round.
        """
        if history is None or len(history.opponent_actions) == 0:
            return False
        last_round_actions = history.opponent_actions[-1, :]
        return bool(np.all(last_round_actions))

    def _is_unanimous_defection(self, history: PlayerHistory) -> bool:
        """
        Check if all opponents defected in the last round.
        """
        if history is None or len(history.opponent_actions) == 0:
            return False
        last_round_actions = history.opponent_actions[-1, :]
        return bool(np.sum(last_round_actions) == 0)

class Strategy_COLLECTIVE_88(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Enforcement strategy for Common Pool Resource Game.
    
    Balances immediate self-interest with long-term collective sustainability through:
    - Zone-based decision making (critical, healthy, decline)
    - Adaptive response to observed defection rates
    - Graduated enforcement with redemption opportunities
    - Special handling for final rounds and edge cases
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if stock <= 1.5 * self.n_players:
            return Action.C
        if round_num == 0:
            self.previous_stock = stock
            return Action.C
        defection_rate = self._calculate_defection_rate(history, round_num)
        stock_is_declining = self.previous_stock is not None and stock < self.previous_stock and (stock > 1.5 * self.n_players)
        capacity_threshold = 0.8 * self.capacity
        if stock_is_declining and stock <= capacity_threshold:
            self.previous_stock = stock
            if defection_rate >= 0.4:
                return Action.D
            elif defection_rate < 0.4:
                return Action.D if random.random() < 0.6 else Action.C
        if round_num == self.n_rounds - 1:
            self.previous_stock = stock
            if stock > 1.5 * self.n_players and defection_rate <= 0.3:
                return Action.C
            else:
                return Action.D
        if defection_rate < 0.2:
            self.previous_stock = stock
            return Action.C
        elif defection_rate < 0.5:
            p_cooperate = 1.0 - defection_rate
            self.previous_stock = stock
            return Action.C if random.random() < p_cooperate else Action.D
        else:
            self.previous_stock = stock
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the average defection rate across all opponents in all previous rounds.
        
        Returns a value between 0 and 1.
        - Defect is encoded as False/0
        - Cooperate is encoded as True/1
        - Defection rate = (number of D actions) / (total actions)
        """
        if round_num == 0:
            return 0.0
        previous_actions = history.opponent_actions[:round_num, :]
        total_actions = previous_actions.size
        if total_actions == 0:
            return 0.0
        num_defections = np.sum(~previous_actions)
        defection_rate = float(num_defections) / float(total_actions)
        return defection_rate

class Strategy_COLLECTIVE_89(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Defection Detection.
    
    A collective strategy that balances individual payoff maximization with system sustainability.
    Uses phase-based decision rules (early/mid/end game), defection rate thresholds, stock health
    monitoring, and adaptive recovery modes to protect the common pool resource while responding
    to opponent defection patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.deficit_recovery_counter = 0
        self.last_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_stock <= 0:
            return Action.D
        phase_threshold_early = max(1, self.n_rounds // 3)
        phase_threshold_mid = max(2, 2 * self.n_rounds // 3)
        if self.last_stock > 0 and current_stock < self.last_stock * 0.5:
            self.last_stock = current_stock
            return Action.D
        self.last_stock = current_stock
        defection_rate = self._calculate_defection_rate(history, current_round)
        if current_stock < 0.5 * self.capacity and current_round < 3 * self.n_rounds // 4:
            if self.deficit_recovery_counter < 3:
                self.deficit_recovery_counter += 1
                return Action.C
            else:
                self.deficit_recovery_counter = 0
        if current_round < phase_threshold_early:
            return Action.C
        elif current_round < phase_threshold_mid:
            if defection_rate < 0.3:
                return Action.C
            elif defection_rate < 0.6:
                defectors_last_round = sum(1 - history.opponent_actions[-1, :])
                cooperators_last_round = self.n_players - 1 - defectors_last_round
                return Action.D if defectors_last_round > cooperators_last_round else Action.C
            else:
                return Action.D
        else:
            if current_stock < 0.2 * self.capacity:
                return Action.D
            if defection_rate < 0.4:
                return Action.C
            else:
                return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate weighted defection rate, with recent rounds weighted more heavily.
        Lookback window: last 5 rounds (or fewer if fewer rounds have been played).
        """
        if current_round == 0:
            return 0.0
        lookback = min(5, current_round)
        start_round = current_round - lookback
        total_weighted_defections = 0.0
        total_weighted_rounds = 0.0
        for i in range(lookback):
            round_idx = start_round + i
            weight = i + 1
            defectors_in_round = sum(1 - history.opponent_actions[round_idx, :])
            total_weighted_defections += defectors_in_round * weight
            total_weighted_rounds += (self.n_players - 1) * weight
        if total_weighted_rounds == 0:
            return 0.0
        return total_weighted_defections / total_weighted_rounds

class Strategy_COLLECTIVE_90(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A dynamic strategy balancing individual benefit,
    stock preservation, and adaptive response to opponent behavior in common pool games.
    
    Core logic:
    - Assess stock health relative to capacity
    - Cooperate when stock is healthy (≥75%) or critically low (<40%)
    - Defect when stock is degraded (40-75%)
    - Track opponent defection rates and retaliate against systematic free-riding
    - Apply end-game logic in terminal rounds
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < 2 * self.n_players:
            return Action.C
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        rounds_remaining = self.n_rounds - current_round
        defection_rate = self._compute_defection_rate(history)
        if defection_rate > 0.8:
            return Action.D
        if defection_rate > 0.65 and stock_ratio < 0.5:
            return Action.D
        if rounds_remaining <= 2:
            return Action.D
        if rounds_remaining <= self.n_rounds / 3:
            adjusted_threshold = 0.5
        else:
            adjusted_threshold = 0.4
        if stock_ratio >= 0.75:
            return Action.C
        elif stock_ratio >= adjusted_threshold:
            return Action.D
        else:
            return Action.C

    def _compute_defection_rate(self, history: PlayerHistory) -> float:
        """
        Compute the aggregate defection rate of opponents across all observed rounds.
        
        Defection is encoded as False (0), Cooperation as True (1).
        Defection rate = (total defections) / (total opponent actions)
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        opponent_actions = history.opponent_actions
        total_opponent_actions = opponent_actions.size
        if total_opponent_actions == 0:
            return 0.0
        total_defections = total_opponent_actions - int(np.sum(opponent_actions))
        defection_rate = total_defections / total_opponent_actions
        return defection_rate

class Strategy_COLLECTIVE_91(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Response
    
    Balances sustainability, adaptability, and robustness by:
    1. Cooperating when stock is healthy (≥80% capacity)
    2. Conditionally cooperating based on observed defection rates (50-80% stock)
    3. Defecting when stock is critically low (<50% stock)
    4. Using a 5-round rolling window to assess opponent cooperation
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_pct = state.current_stock / self.capacity
        defection_rate = self._calculate_defection_rate(history, state.round_number)
        if state.round_number == self.n_rounds - 1:
            return Action.C if stock_pct >= 0.5 else Action.D
        if state.current_stock < 2 * self.n_players:
            return Action.D
        if stock_pct >= 0.8:
            return Action.C
        elif stock_pct >= 0.5:
            return Action.C if defection_rate <= 0.5 else Action.D
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the observed defection rate of opponents over a rolling 5-round window.
        
        Returns:
            float: Proportion of defections observed (0.0 to 1.0)
        """
        recent_rounds = min(5, current_round)
        if recent_rounds == 0:
            return 0.0
        start_idx = current_round - recent_rounds
        recent_opponent_actions = history.opponent_actions[start_idx:current_round, :]
        total_actions = recent_opponent_actions.size
        defection_count = total_actions - np.sum(recent_opponent_actions)
        defection_rate = defection_count / total_actions if total_actions > 0 else 0.0
        return defection_rate

class Strategy_COLLECTIVE_92(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Reciprocity strategy.
    
    Balances individual benefit with collective sustainability by:
    - Cooperating when stock is healthy (≥60% capacity)
    - Using reciprocal defection in danger zone (30-60% capacity)
    - Defecting in critical stock (<30% capacity)
    - Adjusting behavior based on opponent cooperation rates
    - Detecting sustained defection patterns and stock collapse trajectories
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.low_coop_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio < 0.1:
            return Action.D
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.C if stock_ratio >= 0.3 else Action.D
        if round_num == self.n_rounds - 2:
            coop_rate_last = self._get_cooperation_rate(history, round_num - 1)
            if coop_rate_last >= 0.7 and stock_ratio >= 0.4:
                return Action.C
        if stock_ratio >= 0.6:
            return Action.C
        if stock_ratio >= 0.3:
            coop_rate_last = self._get_cooperation_rate(history, round_num - 1)
            stock_decline = self._get_stock_decline(history, round_num)
            if stock_decline < -0.3 * self.capacity:
                return Action.D
            threshold = 0.6
            if self._detect_sustained_defection(history, round_num):
                threshold = 0.4
                self.low_coop_rounds += 1
            else:
                self.low_coop_rounds = 0
            if self._detect_recovery_signal(history, round_num):
                return Action.C
            return Action.C if coop_rate_last >= threshold else Action.D
        return Action.D

    def _get_cooperation_rate(self, history: PlayerHistory, round_idx: int) -> float:
        """Calculate the proportion of opponent cooperators in a given round."""
        if round_idx < 0 or round_idx >= history.opponent_actions.shape[0]:
            return 0.0
        cooperators = sum(history.opponent_actions[round_idx, :])
        return cooperators / self.n_players if self.n_players > 0 else 0.0

    def _get_stock_decline(self, history: PlayerHistory, round_idx: int) -> float:
        """Calculate stock decline from previous round to current."""
        if round_idx <= 0:
            return 0.0
        prev_round_payoffs = history.opponent_payoffs[round_idx - 1, :]
        my_prev_payoff = history.my_payoffs[round_idx - 1]
        total_prev_consumption = sum(prev_round_payoffs) + my_prev_payoff
        return -total_prev_consumption

    def _detect_sustained_defection(self, history: PlayerHistory, round_idx: int) -> bool:
        """Check if cooperation rate has been < 0.5 for 2+ consecutive rounds."""
        if round_idx < 2:
            return False
        coop_rate_prev = self._get_cooperation_rate(history, round_idx - 1)
        coop_rate_prev_prev = self._get_cooperation_rate(history, round_idx - 2)
        return coop_rate_prev < 0.5 and coop_rate_prev_prev < 0.5

    def _detect_recovery_signal(self, history: PlayerHistory, round_idx: int) -> bool:
        """Check if stock recovered ≥20% in last round and cooperation rate ≥50%."""
        if round_idx < 1:
            return False
        coop_rate = self._get_cooperation_rate(history, round_idx - 1)
        if coop_rate >= 0.5:
            if round_idx >= 2:
                avg_prev_payoff = np.mean(history.opponent_payoffs[round_idx - 1, :])
                avg_prev_prev_payoff = np.mean(history.opponent_payoffs[round_idx - 2, :])
                if avg_prev_payoff > avg_prev_prev_payoff * 1.2:
                    return True
        return False

class Strategy_COLLECTIVE_93(BaseStrategy):
    """
    Adaptive Stock-Preservation with Defection Detection.
    
    Prioritizes long-term collective welfare through stock-level thresholds and 
    defection detection. Cooperates when stock is abundant or critical, selectively 
    defects in moderate ranges based on detected exploitation, with special handling 
    for the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        high_threshold = self.capacity * (1.0 - 1.0 / self.n)
        critical_threshold = self.capacity * 0.2
        end_threshold = self.capacity * 0.3
        if round_number == 0:
            return Action.C
        if current_stock > high_threshold:
            return Action.C
        if current_stock <= critical_threshold:
            return Action.C
        if round_number == self.n_rounds - 1:
            if current_stock > end_threshold:
                return Action.C
            else:
                return Action.D
        defection_signal = self._calculate_defection_signal(history, round_number)
        defection_threshold = (self.n - 1) / (2.0 * self.n)
        if defection_signal >= defection_threshold:
            return Action.D
        else:
            return Action.C

    def _calculate_defection_signal(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the defection signal as the proportion of rounds where 
        actual stock fell below expected stock.
        
        Expected stock assumes all cooperators in previous rounds.
        """
        if current_round <= 1:
            return 0.0
        defection_count = 0
        for past_round in range(current_round):
            if past_round == 0:
                stock_before = self.capacity
            else:
                total_payoff_previous = float(history.my_payoffs[past_round]) + np.sum(history.opponent_payoffs[past_round, :])
                cooperators_count = np.sum(history.opponent_actions[past_round, :])
                if history.my_actions[past_round]:
                    cooperators_count += 1
                if cooperators_count < self.n:
                    defection_count += 1
                continue
            cooperators_count = np.sum(history.opponent_actions[past_round, :])
            if history.my_actions[past_round]:
                cooperators_count += 1
            if cooperators_count < self.n:
                defection_count += 1
        if current_round <= 1:
            return 0.0
        return float(defection_count) / float(current_round)

class Strategy_COLLECTIVE_94(BaseStrategy):
    """
    Collective Stewardship Strategy: Adaptive Stock Preservation with Conditional Reciprocity
    
    Balances fair extraction, stock sustainability, and punishment of exploitation through:
    1. Stock health assessment (Healthy/Sustainable/Stressed/Critical)
    2. Opponent behavior classification (Cooperative/Mixed/Exploitative)
    3. Decision matrix based on both factors
    4. Memory-based reciprocity adjustments
    5. Terminal round exploitation when justified
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.C
        health_ratio = stock / self.capacity if self.capacity > 0 else 0
        if health_ratio > 0.75:
            health = 'HEALTHY'
        elif health_ratio >= 0.5:
            health = 'SUSTAINABLE'
        elif health_ratio > 0.25:
            health = 'STRESSED'
        else:
            health = 'CRITICAL'
        if round_num == self.n_rounds - 1:
            if stock > 0.25 * self.capacity:
                return Action.D
            else:
                return Action.C
        prev_round_opponent_actions = history.opponent_actions[round_num - 1, :]
        defection_count = np.sum(~prev_round_opponent_actions)
        defection_rate = defection_count / self.n_players if self.n_players > 0 else 0
        if defection_rate <= 0.25:
            opponent_behavior = 'COOPERATIVE'
        elif defection_rate < 0.75:
            opponent_behavior = 'MIXED'
        else:
            opponent_behavior = 'EXPLOITATIVE'
        decision_matrix = {'HEALTHY': {'COOPERATIVE': Action.C, 'MIXED': Action.C if random.random() > defection_rate else Action.D, 'EXPLOITATIVE': Action.D if defection_rate > 0.5 else Action.C}, 'SUSTAINABLE': {'COOPERATIVE': Action.C, 'MIXED': Action.C if random.random() > defection_rate else Action.D, 'EXPLOITATIVE': Action.D}, 'STRESSED': {'COOPERATIVE': Action.C, 'MIXED': Action.D, 'EXPLOITATIVE': Action.D}, 'CRITICAL': {'COOPERATIVE': Action.C, 'MIXED': Action.D, 'EXPLOITATIVE': Action.D}}
        base_action = decision_matrix[health][opponent_behavior]
        if round_num >= 2:
            prev_round_1_actions = history.opponent_actions[round_num - 1, :]
            prev_round_2_actions = history.opponent_actions[round_num - 2, :]
            prev_defection_rate_1 = np.sum(~prev_round_1_actions) / self.n_players if self.n_players > 0 else 0
            prev_defection_rate_2 = np.sum(~prev_round_2_actions) / self.n_players if self.n_players > 0 else 0
            if prev_defection_rate_1 >= 0.5 and prev_defection_rate_2 >= 0.5:
                if random.random() < 0.25 and base_action == Action.C:
                    base_action = Action.D
            if prev_defection_rate_1 <= 0.25 and prev_defection_rate_2 <= 0.25:
                if random.random() < 0.15 and base_action == Action.D:
                    base_action = Action.C
        return base_action

class Strategy_COLLECTIVE_95(BaseStrategy):
    """
    Dynamic Threshold Cooperation (DTC) Strategy for Common Pool Resource Game.
    
    Balances individual rational self-interest with collective resource stewardship.
    Adapts cooperation based on stock health, defection rates, and round number.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_THRESHOLD = 0.15
        self.SUSTAINABLE_THRESHOLD = 0.35
        self.BOOTSTRAP_COOPERATION_TOLERANCE = 0.6
        self.COOPERATION_TOLERANCE = (self.n_players - 1) / (2 * self.n_players)
        self.RECOVERY_THRESHOLD = self.SUSTAINABLE_THRESHOLD + 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            if self.n_players > 20:
                return Action.C if random.random() < 0.8 else Action.D
            return Action.C
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        if current_stock <= 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            if stock_health > 0.7:
                return Action.C
            return Action.D
        if stock_health < self.CRITICAL_THRESHOLD:
            return Action.D
        last_round_idx = current_round - 1
        opponent_actions_last_round = history.opponent_actions[last_round_idx, :]
        defectors_last_round = np.sum(~opponent_actions_last_round)
        defection_rate_last_round = defectors_last_round / self.n_players
        if current_round <= 2:
            cooperation_tolerance = self.BOOTSTRAP_COOPERATION_TOLERANCE
        else:
            cooperation_tolerance = self.COOPERATION_TOLERANCE
        if defection_rate_last_round > cooperation_tolerance:
            return Action.D
        if stock_health < self.SUSTAINABLE_THRESHOLD:
            return Action.D
        if stock_health > self.RECOVERY_THRESHOLD:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_96(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection.
    
    This strategy prioritizes sustainable commons management while remaining robust to exploitation.
    It balances collective sustainability, personal security, and adaptive responsiveness to 
    observable community behavior through stock-conditional cooperation and defection rate tracking.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        defection_rate = self._calculate_defection_rate(history, round_number)
        high_stock_threshold = 1.5 * self.capacity / 2
        low_stock_threshold = 0.4 * self.capacity
        collapse_threshold = 0.2 * self.capacity
        if current_stock < collapse_threshold:
            return Action.C
        if current_stock > high_stock_threshold:
            return Action.C
        if round_number == self.r - 1:
            if current_stock > self.capacity / 2:
                return Action.C
        if current_stock < low_stock_threshold:
            return self._conditional_response(defection_rate)
        else:
            return self._conditional_response(defection_rate)

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the proportion of defections in the previous round.
        Defection is encoded as False (0), Cooperation as True (1).
        """
        if round_number <= 0:
            return 0.0
        prev_round_actions = history.opponent_actions[round_number - 1, :]
        num_defections = np.sum(~prev_round_actions)
        total_actions = self.n
        if total_actions == 0:
            return 0.0
        defection_rate = float(num_defections) / float(total_actions)
        return defection_rate

    def _conditional_response(self, defection_rate: float) -> Action:
        """
        Apply the conditional response based on defection rate thresholds.
        
        - If defection_rate <= 1/n: cooperate
        - If 1/n < defection_rate <= 2/n: probabilistic (cooperate with prob 1 - defection_rate)
        - If defection_rate > 2/n: defect
        """
        threshold_1 = 1.0 / self.n
        threshold_2 = 2.0 / self.n
        if defection_rate <= threshold_1:
            return Action.C
        elif defection_rate <= threshold_2:
            if random.random() < 1.0 - defection_rate:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_97(BaseStrategy):
    """
    Adaptive Conservation with Graduated Defection Strategy.
    
    Prioritizes collective welfare by maintaining stock sustainability while remaining
    robust to exploitation. Adapts to observed defection rates and transitions gradually
    based on stock health and opponent behavior.
    
    Decision rules:
    - Stock ≥ 75% capacity: COOPERATE
    - Stock < 40% capacity: DEFECT
    - 40% ≤ Stock < 75% capacity: Adaptive based on observed defection rate
      - Defection rate ≤ 25%: COOPERATE
      - Defection rate > 25%: DEFECT
    - First round: COOPERATE (establish cooperative norm)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_high = 0.75
        self.threshold_low = 0.4
        self.defection_rate_low = 0.25
        self.defection_rate_high = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        n_players = self.game_description.n_players
        if stock_ratio >= self.threshold_high:
            return Action.C
        if stock_ratio < self.threshold_low:
            return Action.D
        most_recent_round_idx = state.round_number - 1
        opponent_actions_last_round = history.opponent_actions[most_recent_round_idx, :]
        defection_count = np.sum(opponent_actions_last_round == False)
        observed_defection_rate = defection_count / (n_players - 1) if n_players > 1 else 0.0
        if observed_defection_rate <= self.defection_rate_low:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_98(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Maintains resource health through dynamic cooperation, with opportunistic defection
    only when the resource is healthy and defection is widespread. Uses stock health
    assessment and defection rate tracking to adapt behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if health_ratio < 0.3:
            return Action.C
        if health_ratio < 0.6:
            if round_number >= self.n_rounds - 2:
                return Action.C
            return Action.C
        if round_number >= self.n_rounds - 2:
            return Action.C
        defection_rate = self._calculate_defection_rate(history, round_number)
        if defection_rate > 0.5:
            return Action.D
        elif defection_rate > 0.3:
            return Action.D
        else:
            return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the historical defection rate from observed opponent actions.
        
        defection_rate = (total_defections_observed) / (n × rounds_completed)
        
        Returns a value in [0, 1].
        """
        if round_number == 0 or history is None:
            return 0.0
        total_defections = 0
        total_actions = self.n_players * round_number
        if total_actions == 0:
            return 0.0
        defections = np.sum(~history.opponent_actions[:round_number, :])
        defection_rate = defections / total_actions
        return defection_rate

class Strategy_COLLECTIVE_99(BaseStrategy):
    """
    Collective Adaptive Stewardship Strategy (CASS)
    
    Treats the common pool as a shared resource requiring active stewardship.
    Uses stock-conditional cooperation with adaptive responses to observed defection.
    Maximizes collective long-term payoff while remaining robust to defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = 0.75 * self.capacity
        self.threshold_mid = 0.5 * self.capacity
        self.threshold_critical = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            if stock > self.threshold_critical:
                return Action.D
            else:
                return Action.D
        if stock > self.threshold_high:
            return Action.C
        elif stock > self.threshold_mid:
            return self._adaptive_response(history, round_number)
        elif stock > self.threshold_critical:
            return Action.D
        else:
            return Action.D

    def _adaptive_response(self, history: PlayerHistory, round_number: int) -> Action:
        """
        Conditional tit-for-tat scaled to group behavior.
        Observe defection rate in the most recent round and respond accordingly.
        """
        opponent_actions_last_round = history.opponent_actions[round_number - 1, :]
        defectors_last_round = np.sum(~opponent_actions_last_round)
        defection_rate = defectors_last_round / self.n_players
        if defection_rate <= 0.33:
            return Action.C
        elif defection_rate < 0.67:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_100(BaseStrategy):
    """
    Adaptive Stewardship with Defensive Thresholds: A collective resource management strategy
    that balances cooperation with rational self-preservation based on stock health and
    observable defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.depletion_threshold = 0.3
        self.critical_threshold = 0.1
        self.defection_tolerance = 0.5
        self.high_defection_threshold = 0.75
        self.recovery_threshold = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if round_number == 0:
            return Action.C
        if stock_ratio < self.depletion_threshold:
            if stock_ratio < self.critical_threshold:
                estimated_defection_rate = self._estimate_defection_rate(history, round_number)
                if estimated_defection_rate > 0.8:
                    return Action.C
            return Action.D
        if rounds_remaining == 1:
            return Action.D
        estimated_defection_rate = self._estimate_defection_rate(history, round_number)
        if round_number >= 2:
            previous_stock_ratio = history.opponent_payoffs[round_number - 2, 0] / (self.capacity / (2 * self.n_players))
            if stock_ratio > previous_stock_ratio and stock_ratio > self.recovery_threshold:
                return Action.C
        if round_number < 3 and stock_ratio < self.recovery_threshold:
            return Action.D
        if estimated_defection_rate > self.high_defection_threshold:
            return Action.D
        elif estimated_defection_rate > self.defection_tolerance:
            if stock_ratio < 0.5:
                return Action.D
            return Action.C
        else:
            return Action.C

    def _estimate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Estimate the defection rate from the previous round.
        Returns a value between 0.0 and 1.0.
        """
        if round_number == 0 or history is None:
            return 0.0
        last_round_idx = round_number - 1
        if last_round_idx < 0 or last_round_idx >= len(history.opponent_actions):
            return 0.0
        last_round_actions = history.opponent_actions[last_round_idx, :]
        cooperators = np.sum(last_round_actions)
        defection_rate = (self.n_players - cooperators) / self.n_players if self.n_players > 0 else 0.0
        return float(defection_rate)

class Strategy_COLLECTIVE_101(BaseStrategy):
    """
    Collective Resource Stewardship Strategy: A conditionally cooperative approach
    that balances individual benefit with collective sustainability. Cooperates when
    stock is healthy and opponents are trustworthy, defects to punish excessive
    defection or capture final-round gains when sustainable.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_health_ratio = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        stock_danger_zone = 0.25
        stock_recovery_zone = 0.6
        defection_tolerance = 0.4
        rounds_remaining = self.n_rounds - state.round_number
        current_round_idx = state.round_number
        opponent_actions = history.opponent_actions[:current_round_idx, :]
        total_opponent_actions = opponent_actions.size
        if total_opponent_actions > 0:
            defections = total_opponent_actions - np.sum(opponent_actions)
            historical_defection_rate = float(defections) / float(total_opponent_actions)
        else:
            historical_defection_rate = 0.0
        opponent_defection_count = int(total_opponent_actions - np.sum(opponent_actions)) if total_opponent_actions > 0 else 0
        if rounds_remaining == 0:
            if stock_health_ratio > stock_recovery_zone:
                return Action.D
            else:
                return Action.C
        crisis_window = math.ceil(self.n_rounds / 4)
        if rounds_remaining <= crisis_window:
            if stock_health_ratio < 0.4:
                return Action.C
            if historical_defection_rate > 0.3:
                return Action.D
        if stock_health_ratio < stock_danger_zone:
            return Action.C
        if stock_health_ratio >= stock_danger_zone and stock_health_ratio < stock_recovery_zone:
            if historical_defection_rate <= defection_tolerance:
                return Action.C
            else:
                return Action.D
        if stock_health_ratio >= stock_recovery_zone:
            if historical_defection_rate <= defection_tolerance:
                return Action.C
            else:
                punishment_duration = min(3, opponent_defection_count / 2)
                if punishment_duration > 0:
                    return Action.D
                else:
                    return Action.C
        return Action.C

class Strategy_COLLECTIVE_102(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game
    
    Treats the common pool as a shared resource requiring stewardship.
    Adapts behavior based on stock health and observed defection prevalence.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_number = state.round_number
        critical_threshold = 0.4 * self.capacity
        degraded_threshold = 0.2 * self.capacity
        if stock < degraded_threshold:
            return Action.C
        if stock < critical_threshold:
            return Action.C
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            if stock >= critical_threshold:
                return Action.D
            else:
                return Action.C
        previous_round_idx = round_number - 1
        previous_actions = history.opponent_actions[previous_round_idx, :]
        defectors_count = self.n_players - 1 - np.sum(previous_actions)
        defection_rate = defectors_count / (self.n_players - 1)
        if defection_rate > self.cooperation_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_103(BaseStrategy):
    """
    Adaptive Stock-Preservation with Defection Deterrence.
    
    Prioritizes long-term collective welfare by maintaining stock sustainability
    while protecting against exploitation. Uses reciprocal fairness and defection
    deterrence based on observed defection rates and stock health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        stock = state.current_stock
        if round_number == 0:
            return Action.C
        last_round_idx = round_number - 1
        last_round_opponent_actions = history.opponent_actions[last_round_idx, :]
        defectors_last_round = self.n_players - 1 - np.sum(last_round_opponent_actions)
        defection_rate = defectors_last_round / (self.n_players - 1) if self.n_players > 1 else 0.0
        if stock <= 0.15 * self.capacity:
            if defection_rate <= 0.25:
                return Action.C
            else:
                return Action.D
        stock_healthy = stock >= 0.4 * self.capacity
        if round_number == self.n_rounds - 1:
            if stock >= 0.5 * self.capacity:
                return Action.C
            else:
                return Action.D
        if stock < 0.3 * self.capacity:
            return Action.D
        if not stock_healthy:
            return Action.D
        if defection_rate <= 0.25:
            return Action.C
        elif defection_rate <= 0.5:
            if random.random() < defection_rate:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_104(BaseStrategy):
    """
    Adaptive Threshold Cooperation (ATC) strategy for Common Pool Resource Game.
    
    Prioritizes collective long-term welfare while remaining robust against defectors.
    - Round 1: Always cooperate
    - Final round: Always defect
    - Middle rounds: Cooperate if stock ≥ 0.4*capacity AND recent_defection_rate ≤ 0.5
    - Otherwise: Defect
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity * 0.4
        self.defection_tolerance = 0.5
        self.lookback_window = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.stock_threshold:
            return Action.D
        recent_defection_rate = self._calculate_recent_defection_rate(history, state.round_number)
        if recent_defection_rate > self.defection_tolerance:
            return Action.D
        return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the proportion of opponent defections in the recent lookback window.
        
        Args:
            history: Player history containing opponent actions
            current_round: Current round number (0-indexed)
        
        Returns:
            Defection rate as a float in [0, 1]
        """
        rounds_elapsed = current_round
        window_size = min(self.lookback_window, rounds_elapsed)
        if window_size == 0:
            return 0.0
        recent_opponent_actions = history.opponent_actions[-window_size:, :]
        total_opponent_slots = window_size * self.game_description.n_players
        defection_count = np.sum(~recent_opponent_actions)
        defection_rate = float(defection_count) / float(total_opponent_slots)
        return defection_rate

class Strategy_COLLECTIVE_105(BaseStrategy):
    """
    Adaptive Stock-Conserving Tit-for-Tat (ASCTT)
    
    Balances individual rationality with collective sustainability through:
    1. Unconditional cooperation in critical stock states (< 20% capacity)
    2. Conditional cooperation based on recent majority behavior in healthy states
    3. Reciprocal defection only against coordinated defection
    4. Special handling for last round to avoid reputation damage
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.k = max(2, min(5, self.r // 3))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        current_stock = state.current_stock
        if round_t == 0:
            return Action.C
        cooperation_rate = self._calculate_cooperation_rate(history, round_t)
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 1.0
        if stock_ratio < 0.2:
            return Action.C
        elif stock_ratio < 0.4:
            return Action.C
        else:
            near_universal_threshold = (self.n - 1) / self.n if self.n > 1 else 1.0
            if cooperation_rate >= near_universal_threshold:
                return Action.C
            elif cooperation_rate >= 0.5:
                return Action.C
            elif round_t == self.r - 1:
                if cooperation_rate < 0.25:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D
        return Action.C

    def _calculate_cooperation_rate(self, history: PlayerHistory, round_t: int) -> float:
        """
        Calculate the cooperation rate of opponents in recent history.
        
        Returns proportion of opponents who played C in recent rounds.
        """
        if history is None or round_t == 0:
            return 1.0
        lookback_start = max(0, round_t - self.k)
        lookback_end = round_t
        if lookback_start >= lookback_end:
            return 1.0
        recent_opponent_actions = history.opponent_actions[lookback_start:lookback_end, :]
        cooperators_per_round = np.sum(recent_opponent_actions, axis=1)
        total_cooperations = np.sum(cooperators_per_round)
        num_rounds_in_window = lookback_end - lookback_start
        num_opponents = self.n - 1
        total_possible = num_rounds_in_window * num_opponents
        if total_possible == 0:
            return 1.0
        cooperation_rate = total_cooperations / total_possible
        return cooperation_rate

class Strategy_COLLECTIVE_106(BaseStrategy):
    """
    Adaptive Stewardship with Defensive Threshold Strategy
    
    Balances collective sustainability with defensive resilience by:
    1. Leading with cooperation in early rounds to establish norms
    2. Maintaining cooperation when stock is healthy (≥60% capacity) and defection is limited
    3. Adapting defection thresholds based on stock health
    4. Protecting against collapse with emergency defection when stock is critically low
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_health_ratio = state.current_stock / self.game_description.capacity
        if state.round_number <= 2:
            return Action.C
        if stock_health_ratio < 0.1:
            return Action.D
        defection_rate = self._calculate_defection_rate(history, state.round_number)
        if stock_health_ratio < 0.3:
            return Action.D
        if stock_health_ratio < 0.6:
            if defection_rate <= 0.25:
                return Action.C
            else:
                return Action.D
        if stock_health_ratio >= 0.6:
            if defection_rate <= 0.5:
                return Action.C
            else:
                return Action.D
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the defection rate in the previous round.
        Defection is represented as False (0) in opponent_actions.
        Cooperation is represented as True (1) in opponent_actions.
        Defection rate = number of defectors / total opponents
        """
        if round_number == 0:
            return 0.0
        previous_round_idx = round_number - 1
        opponent_actions_prev = history.opponent_actions[previous_round_idx, :]
        num_defectors = int(np.sum(opponent_actions_prev == False))
        num_opponents = self.game_description.n_players - 1
        if num_opponents == 0:
            return 0.0
        defection_rate = num_defectors / num_opponents
        return defection_rate

class Strategy_COLLECTIVE_107(BaseStrategy):
    """
    Adaptive Threshold with Regenerative Safeguard.
    
    Balances individual payoff maximization with collective long-term sustainability.
    Core strategy: cooperate when stock is below threshold, defect when abundant.
    Includes special rules for first round, last round, and collapse prevention.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = self.capacity * (2 / 3) + self.n_players * 0.5
        self.previous_regeneration_rate = None

    def _calculate_regeneration_rate(self, stock: float) -> float:
        """Calculate regeneration rate based on current stock."""
        if self.capacity <= 0:
            return 0.0
        return 2 * stock * (1 - stock / self.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if current_stock < self.capacity * (1 / 6):
            return Action.C
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            if current_stock >= self.threshold:
                return Action.C
            else:
                return Action.D
        current_regeneration = self._calculate_regeneration_rate(current_stock)
        if self.previous_regeneration_rate is not None:
            if current_regeneration < self.previous_regeneration_rate and current_stock < 1.2 * self.threshold:
                self.previous_regeneration_rate = current_regeneration
                return Action.C
        self.previous_regeneration_rate = current_regeneration
        if current_stock >= self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_108(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A strategy that balances individual payoff
    maximization with collective stock preservation through conditional cooperation.
    
    Core logic:
    - Round 1: Always cooperate (establish baseline)
    - Middle rounds: Cooperate by default, defect only when stock is abundant (≥75%)
    - Final round: Defect (unless stock is critically depleted <20%)
    - Adjust thresholds based on game parameters (n, r)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defect_threshold = self._compute_defect_threshold()

    def _compute_defect_threshold(self) -> float:
        """
        Compute the stock_health threshold above which to defect in middle rounds.
        Adjusts for edge cases: very small n, very large n, many rounds.
        """
        threshold = 0.75
        if self.n_players > 20:
            threshold = 0.8
        elif self.n_players == 2:
            threshold = 0.65
        if self.n_rounds > 50:
            threshold = 0.7
        return threshold

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decide action based on current round and stock health.
        """
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_stock <= 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            stock_health = current_stock / self.capacity
            if stock_health < 0.2:
                return Action.C
            else:
                return Action.D
        stock_health = current_stock / self.capacity
        if stock_health >= self.defect_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_109(BaseStrategy):
    """
    Adaptive Stock Guardianship (ASG): A collective strategy for common pool resource management.
    
    Core philosophy: Prioritize stock sustainability through adaptive decision rules that balance
    individual benefit with collective welfare. Cooperate when stock is healthy, defect when critical,
    and conditionally cooperate based on opponent behavior in the degraded zone.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.HEALTHY_THRESHOLD = 0.7
        self.CRITICAL_THRESHOLD = 0.3
        self.RECOVERY_THRESHOLD = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        is_last_round = state.round_number == self.n_rounds - 1
        lookback_rounds = min(5, state.round_number)
        opponent_defection_rate = self._calculate_opponent_defection_rate(history, lookback_rounds)
        if stock_health >= self.HEALTHY_THRESHOLD:
            if is_last_round:
                return Action.C
            if opponent_defection_rate > 0.8:
                return Action.D
            return Action.C
        elif stock_health < self.CRITICAL_THRESHOLD:
            if opponent_defection_rate < 0.3 and self._is_stock_recovering(history):
                return Action.C
            if is_last_round:
                return Action.D
            return Action.D
        else:
            if is_last_round:
                return Action.D
            if opponent_defection_rate > 0.6:
                return Action.D
            elif opponent_defection_rate <= 0.2:
                return Action.C
            else:
                recent_opponent_behavior = self._get_recent_opponent_behavior(history)
                if recent_opponent_behavior >= 0.5:
                    return Action.C
                else:
                    return Action.D

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """
        Calculate the proportion of defections by opponents in recent rounds.
        Returns a value between 0 and 1.
        """
        if lookback_rounds <= 0 or history.opponent_actions.shape[0] == 0:
            return 0.0
        start_idx = max(0, history.opponent_actions.shape[0] - lookback_rounds)
        recent_actions = history.opponent_actions[start_idx:, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        defection_count = np.sum(recent_actions == False)
        return float(defection_count) / float(total_actions)

    def _get_recent_opponent_behavior(self, history: PlayerHistory) -> float:
        """
        Get the average cooperation rate of opponents in the last round.
        Returns a value between 0 and 1, where 1 is all cooperate and 0 is all defect.
        """
        if history.opponent_actions.shape[0] == 0:
            return 0.5
        last_round_actions = history.opponent_actions[-1, :]
        cooperation_count = np.sum(last_round_actions == True)
        total_opponents = len(last_round_actions)
        if total_opponents == 0:
            return 0.5
        return float(cooperation_count) / float(total_opponents)

    def _is_stock_recovering(self, history: PlayerHistory) -> bool:
        """
        Check if stock is on a recovery trajectory.
        Returns True if stock has been increasing over recent rounds toward recovery threshold.
        """
        if history is None or len(history.my_payoffs) < 2:
            return False
        lookback = min(3, len(history.my_payoffs))
        if lookback < 2:
            return False
        recent_payoffs = history.my_payoffs[-lookback:]
        if len(recent_payoffs) < 2:
            return False
        mid_point = len(recent_payoffs) // 2
        if mid_point == 0:
            mid_point = 1
        earlier_avg = np.mean(recent_payoffs[:mid_point])
        later_avg = np.mean(recent_payoffs[mid_point:])
        return later_avg > earlier_avg

class Strategy_COLLECTIVE_110(BaseStrategy):
    """
    Adaptive Threshold Conservation (ATC) Strategy for Common Pool Resource Game.
    
    Balances individual gain-seeking with collective sustainability by using stock health
    thresholds to determine cooperation. In healthy conditions (stock > 60% capacity),
    defects to maximize payoff. As stock declines into warning range (25-60%), gradually
    increases cooperation probability. In critical range (≤25%), always cooperates to
    prevent collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = 0.25
        self.warning_threshold = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decide action based on current stock health ratio.
        """
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        stock_clamped = min(current_stock, capacity)
        if capacity <= 0:
            stock_ratio = 0.0
        else:
            stock_ratio = stock_clamped / capacity
        if stock_ratio <= self.critical_threshold:
            return Action.C
        if stock_ratio <= self.warning_threshold:
            denominator = self.warning_threshold - self.critical_threshold
            if denominator <= 0:
                p_coop = 0.0
            else:
                p_coop = (self.warning_threshold - stock_ratio) / denominator
            p_coop = max(0.0, min(1.0, p_coop))
            if random.random() < p_coop:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_COLLECTIVE_111(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Reciprocity strategy for Common Pool Resource Game.
    
    Balances sustainability, reciprocal fairness, and robustness by:
    - Starting with cooperation to establish norms
    - Monitoring stock health and observed defection rates
    - Adapting action thresholds based on resource pressure
    - Defecting only when cooperation becomes unsustainable
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        defection_rate = self._calculate_defection_rate(history, current_round)
        is_final_round = current_round == self.n_rounds - 1
        if is_final_round:
            if health_ratio >= 0.5 and defection_rate <= 0.4:
                return Action.C
            else:
                return Action.D
        if health_ratio >= 0.6:
            if defection_rate <= 0.5:
                return Action.C
            else:
                return Action.D
        elif health_ratio >= 0.3:
            if defection_rate <= 0.4:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the proportion of observed defections by other players.
        
        Returns a value in [0, 1] representing the defection rate.
        Handles edge case where no actions have been observed yet.
        """
        if current_round <= 0:
            return 0.0
        total_possible_actions = (self.n_players - 1) * current_round
        if total_possible_actions == 0:
            return 0.0
        opponent_actions = history.opponent_actions[:current_round, :]
        total_defections = np.sum(~opponent_actions)
        defection_rate = total_defections / total_possible_actions
        return float(defection_rate)

class Strategy_COLLECTIVE_112(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Maintains resource sustainability through dynamic decision-making based on stock health
    and remaining rounds. Cooperates when stock is healthy to preserve growth cycle, transitions
    to defection when resources are critical or game is ending. Balances individual extraction
    with collective long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - round_number
        if round_number == 0:
            return Action.C
        if current_stock <= 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            if current_stock > self.capacity * 0.05:
                return Action.D
            else:
                return Action.C
        stock_health_ratio = current_stock / self.capacity if self.capacity > 0 else 0
        if stock_health_ratio > 0.4:
            if rounds_remaining > 2:
                return Action.C
            else:
                return Action.D
        elif stock_health_ratio > 0.25:
            if rounds_remaining > 1:
                return Action.C
            else:
                return Action.D
        elif stock_health_ratio > 0.05:
            if rounds_remaining >= 3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_113(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection.
    
    Maintains sustainable commons exploitation by:
    1. Cooperating when stock is healthy (≥75% capacity)
    2. Monitoring defection prevalence in declining stock (40-75% capacity)
    3. Defecting when stock is critical (<40% capacity) or in final round
    4. Always defecting in terminal round to maximize immediate payoff
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.n_rounds - 1:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio >= 0.75:
            return Action.C
        if stock_ratio < 0.4:
            return Action.D
        defection_rate = self._calculate_defection_rate(history, round_number)
        if defection_rate > 0.5:
            return Action.D
        else:
            return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the defection rate (proportion of D actions) in the last 3 rounds.
        Returns a value in [0, 1].
        """
        rounds_available = round_number
        window_size = min(3, rounds_available)
        if window_size == 0:
            return 0.0
        start_idx = rounds_available - window_size
        end_idx = rounds_available
        recent_opponent_actions = history.opponent_actions[start_idx:end_idx, :]
        defection_count = np.sum(recent_opponent_actions == False)
        total_actions = recent_opponent_actions.size
        if total_actions == 0:
            return 0.0
        defection_rate = defection_count / total_actions
        return defection_rate

class Strategy_COLLECTIVE_114(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A strategy that balances individual payoff
    maximization with collective resource preservation through adaptive defection
    thresholds based on stock health rather than opponent behavior.
    
    Core principle: Cooperate when stock is above a dynamically calculated threshold
    that adapts to remaining rounds and sustainable equilibrium levels. Special handling
    for round 1 (cooperate), final round (defect), collapsed stock (defect), and full
    capacity (cooperate).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        if current_stock <= self.capacity / 20:
            return Action.D
        if current_stock >= self.capacity * 0.99:
            return Action.C
        remaining_rounds = self.n_rounds - round_number
        threshold = self.capacity * (0.4 + 0.1 * remaining_rounds / self.n_rounds)
        if current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_115(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Response strategy for Common Pool Resource Game.
    
    Balances collective long-term sustainability with individual security against exploitation.
    Uses stock-contingent cooperation with reciprocal behavior based on recent opponent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < 2 * self.n_players:
            return Action.D
        high_threshold = 0.75 * self.capacity
        if current_stock > high_threshold:
            return Action.C
        low_threshold = 0.25 * self.capacity
        if current_stock <= low_threshold:
            return Action.D
        window_size = max(1, min(5, self.n_rounds // 2))
        start_idx = max(0, current_round - window_size)
        recent_actions = history.opponent_actions[start_idx:current_round, :]
        total_rounds_in_window = current_round - start_idx
        total_possible_cooperations = (self.n_players - 1) * total_rounds_in_window
        if total_possible_cooperations > 0:
            total_cooperations = int(np.sum(recent_actions))
            cooperation_rate = total_cooperations / total_possible_cooperations
        else:
            cooperation_rate = 0.0
        if cooperation_rate >= 2.0 / 3.0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_116(BaseStrategy):
    """
    Adaptive Sustainability Management (ASM): A stock-responsive strategy that prioritizes
    long-term collective resource sustainability by cooperating when stock is healthy and
    defecting only when necessary to prevent collapse or when stock thresholds are breached.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.C
        if stock < 0.05 * self.capacity:
            return Action.C
        growth_potential = 2.0 * stock * (1.0 - stock / self.capacity)
        if growth_potential > 0.15 * self.capacity:
            return Action.C
        if stock < 0.2 * self.capacity:
            return Action.C
        decay_factor = max(0.3, 1.0 - round_num / (2.0 * self.n_rounds))
        threshold = self.capacity * decay_factor
        if stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_117(BaseStrategy):
    """
    Adaptive Sustainability Protocol (ASP): A stock-state-based strategy that cooperates
    when resources are abundant (stock >= 50% capacity) and defects when scarce (stock < 50% capacity).
    Special case: defect in the final round if stock is healthy to maximize individual payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock_ratio = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        if state.round_number == self.game_description.n_rounds - 1:
            if stock_ratio >= 0.5:
                return Action.D
        if stock_ratio >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_118(BaseStrategy):
    """
    Adaptive Stewardship Strategy: Dynamic Threshold Cooperation
    
    Balances resource sustainability with adaptive defection based on stock levels
    and observed cooperation ratios. Uses stock-based thresholds and opponent behavior
    to decide between cooperation and defection across repeated rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.danger_threshold = 0.4 * game_description.capacity
        self.sustainable_level = 0.7 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperation_ratio = self._calculate_cooperation_ratio(history, state.round_number)
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > self.danger_threshold and cooperation_ratio > 0.5:
                return Action.C
            else:
                return Action.D
        if state.current_stock > self.sustainable_level:
            if cooperation_ratio > 0.6:
                return Action.C
            else:
                return Action.D
        elif state.current_stock > self.danger_threshold:
            if cooperation_ratio > 0.75:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _calculate_cooperation_ratio(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the ratio of cooperators in the previous round.
        
        Args:
            history: Player history containing opponent actions
            current_round: Current round number (0-indexed)
        
        Returns:
            Cooperation ratio as a float between 0 and 1
        """
        if current_round == 0:
            return 0.0
        previous_round_idx = current_round - 1
        cooperators_in_previous = int(np.sum(history.opponent_actions[previous_round_idx, :]))
        total_opponents = self.game_description.n_players - 1
        if total_opponents == 0:
            return 0.0
        return cooperators_in_previous / total_opponents

class Strategy_COLLECTIVE_119(BaseStrategy):
    """
    Collective Adaptive Stock Stewardship Strategy
    
    Prioritizes sustainable collective prosperity through conditional cooperation.
    Cooperates by default, defects strategically to prevent resource collapse,
    deter systematic exploitation, and maximize payoff in final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if current_round == self.n_rounds - 1:
            return Action.D
        if health_ratio < 0.1:
            return Action.D
        if current_round == 0:
            return Action.C
        recent_defection_rate = self._calculate_recent_defection_rate(history, current_round)
        if health_ratio <= 0.25:
            return Action.D
        if health_ratio <= 0.5 and recent_defection_rate > 0.5:
            return Action.D
        if health_ratio >= 0.75 and recent_defection_rate < 0.3:
            return Action.C
        return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the defection rate of opponents in recent rounds.
        Uses adaptive window: min(current_round, 5) rounds.
        """
        window_size = min(current_round, 5)
        if window_size == 0:
            return 0.0
        start_idx = max(0, current_round - window_size)
        end_idx = current_round
        recent_opponent_actions = history.opponent_actions[start_idx:end_idx, :]
        total_actions = recent_opponent_actions.size
        if total_actions == 0:
            return 0.0
        defection_count = np.sum(~recent_opponent_actions)
        defection_rate = defection_count / total_actions
        return float(defection_rate)

class Strategy_COLLECTIVE_120(BaseStrategy):
    """
    Adaptive Stock Guardianship (ASG): A collective strategy for common pool resource management.
    
    Cooperates or defects based on current stock health relative to a dynamic threshold that
    adapts with round progression. Early rounds require higher stock levels (62.5% of capacity)
    to cooperate, encouraging sustainable growth. Later rounds lower the threshold (approaching 50%)
    to reflect increased urgency. The strategy implicitly learns opponent behavior through stock
    dynamics and responds defensively when stock declines below threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            threshold_final = 0.5 * self.capacity
            if current_stock >= threshold_final:
                return Action.C
            else:
                return Action.D
        remaining_rounds = self.n_rounds - round_number
        threshold = self.capacity * (0.5 + 0.25 * (remaining_rounds / self.n_rounds))
        if current_stock >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_121(BaseStrategy):
    """
    Adaptive Stock-Preserving Cooperation (ASPC) strategy for Common Pool Resource Game.
    
    Balances individual payoff maximization with collective sustainability by:
    1. Cooperating when stock is healthy (above 35% of capacity)
    2. Defecting when majority (>50%) of opponents defect
    3. Defecting in final round (no future consequences)
    4. Defecting when stock collapses (<10% of capacity)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.danger_threshold = 0.35 * self.capacity
        self.collapse_threshold = 0.1 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.collapse_threshold:
            return Action.D
        if current_round == 0:
            return Action.C
        if current_stock <= self.danger_threshold:
            return Action.D
        prev_round_opponent_actions = history.opponent_actions[current_round - 1, :]
        num_defectors = int(np.sum(~prev_round_opponent_actions))
        defection_rate = num_defectors / self.n_players
        if defection_rate > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_122(BaseStrategy):
    """
    Adaptive Stock-Preserving Cooperation (ASPC): A history-dependent strategy
    that prioritizes collective resource sustainability while maintaining individual
    competitiveness through strategic retaliation against excessive defection.
    
    Core decision logic:
    1. Last round: defect to capture remaining value
    2. Critical stock (< 30%): cooperate for emergency recovery
    3. Moderate crisis (stock < 50% AND defection > 50%): cooperate to stabilize
    4. High defection + escalation: defect as punishment/warning
    5. Endgame with healthy stock: defect to secure value before others do
    6. Default: cooperate to sustain the commons
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        if current_round == 0:
            return Action.C
        if rounds_remaining == 1:
            if current_stock > 0:
                return Action.D
            else:
                return Action.C
        if stock_health < 0.3:
            return Action.C
        total_opponent_actions = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
        if total_opponent_actions > 0:
            total_defections = np.sum(~history.opponent_actions)
            defection_rate = float(total_defections) / float(total_opponent_actions)
        else:
            defection_rate = 0.0
        if stock_health < 0.5 and defection_rate > 0.5:
            return Action.C
        defection_escalating = False
        if current_round > 3:
            recent_rounds = history.opponent_actions[-3:, :]
            historical_rounds = history.opponent_actions[:-3, :]
            recent_defections = np.sum(~recent_rounds)
            recent_actions_count = recent_rounds.shape[0] * recent_rounds.shape[1]
            historical_defections = np.sum(~historical_rounds)
            historical_actions_count = historical_rounds.shape[0] * historical_rounds.shape[1]
            if historical_actions_count > 0:
                recent_defection_rate = float(recent_defections) / float(recent_actions_count) if recent_actions_count > 0 else 0.0
                historical_defection_rate = float(historical_defections) / float(historical_actions_count)
                defection_escalating = recent_defection_rate > historical_defection_rate * 1.3
        if defection_rate >= 0.6 and defection_escalating:
            return Action.D
        if rounds_remaining <= 2 and stock_health >= 0.6:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_123(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances cooperative sustainability with self-protective defection.
    Maintains stock health through conditional cooperation, punishes exploitation,
    and adapts thresholds based on stock trajectory and observed defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        health_ratio = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        rounds_remaining = self.n_rounds - state.round_number
        prev_round_idx = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        defectors_prev = np.sum(~opponent_actions_prev)
        defection_rate_prev = defectors_prev / self.n_players if self.n_players > 0 else 0.0
        defection_trend = 0.0
        if state.round_number >= 2:
            prev_prev_round_idx = state.round_number - 2
            opponent_actions_prev_prev = history.opponent_actions[prev_prev_round_idx, :]
            defectors_prev_prev = np.sum(~opponent_actions_prev_prev)
            defection_rate_prev_prev = defectors_prev_prev / self.n_players if self.n_players > 0 else 0.0
            defection_trend = defection_rate_prev - defection_rate_prev_prev
        defection_threshold_low = 0.25
        defection_threshold_mid = 0.5
        if defection_trend > 0.2:
            defection_threshold_low = 0.15
            defection_threshold_mid = 0.4
        elif defection_trend < -0.2:
            defection_threshold_low = 0.35
            defection_threshold_mid = 0.6
        if health_ratio > 0.75:
            if defection_rate_prev <= defection_threshold_low:
                return Action.C
            elif defection_rate_prev <= defection_threshold_mid:
                return Action.D
            else:
                return Action.D
        elif health_ratio > 0.4:
            if defection_rate_prev <= 0.15:
                return Action.C
            else:
                return Action.D
        elif health_ratio > 0.2:
            if defection_rate_prev == 0.0:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_124(BaseStrategy):
    """
    Adaptive Collective Stewardship Strategy (ACS)
    
    Balances individual benefit with collective sustainability by:
    1. Leading with unconditional cooperation in round 1
    2. Monitoring stock health and defection rates
    3. Adapting actions based on a decision matrix
    4. Applying round-specific modifiers (first, middle, penultimate, final)
    5. Handling edge cases like stock collapse and isolated defection
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.C
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_health >= 0.75:
            health_state = 'ROBUST'
        elif stock_health >= 0.4:
            health_state = 'STABLE'
        elif stock_health >= 0.2:
            health_state = 'STRESSED'
        else:
            health_state = 'CRITICAL'
        last_round_defections = self.n_players - 1 - int(sum(history.opponent_actions[-1, :]))
        defection_rate = last_round_defections / self.n_players
        if defection_rate <= 0.25:
            cooperation_level = 'HIGH'
        elif defection_rate <= 0.5:
            cooperation_level = 'MODERATE'
        else:
            cooperation_level = 'LOW'
        if round_num == self.n_rounds - 1:
            if stock_health < 0.2:
                return Action.D
            else:
                return Action.C
        if round_num == self.n_rounds - 2:
            action = self._get_decision_matrix_action(health_state, cooperation_level)
            if action == Action.C:
                return Action.C
            if random.random() < 0.3:
                return Action.C
            return Action.D
        if health_state == 'CRITICAL':
            return Action.D
        if round_num >= 1:
            my_last_action = history.my_actions[-1]
            total_defections = self.n_players - 1 - int(sum(history.opponent_actions[-1, :]))
            if total_defections == 0 and my_last_action == False:
                return Action.C
        if round_num >= 2 and health_state != 'ROBUST':
            recent_defections = 0
            for i in range(max(0, round_num - 2), round_num):
                recent_def = self.n_players - 1 - int(sum(history.opponent_actions[i, :]))
                recent_defections += recent_def
            if recent_defections > (self.n_players - 1) * 2 * 0.75:
                if stock_health < 0.5:
                    return Action.D
        action = self._get_decision_matrix_action(health_state, cooperation_level)
        if action == Action.C:
            return Action.C
        elif action == Action.D:
            return Action.D
        elif random.random() < 0.5:
            return Action.D
        else:
            return Action.C

    def _get_decision_matrix_action(self, health_state: str, cooperation_level: str) -> Action:
        """
        Decision matrix mapping (health_state, cooperation_level) to action.
        Returns Action.C, Action.D, or a special marker for probabilistic decisions.
        """
        decision_matrix = {('ROBUST', 'HIGH'): Action.C, ('ROBUST', 'MODERATE'): Action.C, ('ROBUST', 'LOW'): Action.C, ('STABLE', 'HIGH'): Action.C, ('STABLE', 'MODERATE'): Action.C, ('STABLE', 'LOW'): Action.C, ('STRESSED', 'HIGH'): Action.C, ('STRESSED', 'MODERATE'): 'D_PROB', ('STRESSED', 'LOW'): Action.D, ('CRITICAL', 'HIGH'): Action.D, ('CRITICAL', 'MODERATE'): Action.D, ('CRITICAL', 'LOW'): Action.D}
        result = decision_matrix.get((health_state, cooperation_level), Action.C)
        if result == 'D_PROB':
            return 'D_PROB'
        return result

class Strategy_COLLECTIVE_125(BaseStrategy):
    """
    Adaptive Sustainable Harvesting (ASH) Strategy
    
    Prioritizes long-term collective welfare by cooperating when stock is healthy,
    defecting defensively when depleted, and adapting to observed defection patterns.
    Recognizes that maximum sustainable payoff emerges when stock remains near
    optimal growth point (capacity/2).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.C
        if stock <= 0.1:
            return Action.C
        if stock < self.capacity * 0.25:
            return Action.D
        if stock >= self.capacity * 0.5:
            return Action.C
        if 0.25 <= stock / self.capacity < 0.5:
            recent_defection_rate = self._calculate_recent_defection_rate(history, round_num)
            if recent_defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        if round_num == self.n_rounds - 1:
            if stock >= self.capacity * 0.25:
                return Action.D
            else:
                return Action.C
        return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate proportion of opponent defections in recent rounds.
        Recent = last 2 rounds, or all previous rounds if fewer than 2 exist.
        """
        recent_rounds_count = min(2, round_num)
        if recent_rounds_count <= 0:
            return 0.0
        start_idx = max(0, round_num - recent_rounds_count)
        end_idx = round_num
        defection_count = 0
        total_actions = 0
        for round_idx in range(start_idx, end_idx):
            opponent_actions_in_round = history.opponent_actions[round_idx]
            defections_in_round = np.sum(~opponent_actions_in_round)
            defection_count += defections_in_round
            total_actions += len(opponent_actions_in_round)
        if total_actions == 0:
            return 0.0
        defection_rate = defection_count / total_actions
        return defection_rate

class Strategy_COLLECTIVE_126(BaseStrategy):
    """
    Adaptive Stewardship with Reciprocal Monitoring
    
    Balances individual security with collective welfare by initiating cooperation,
    monitoring defection rates, escalating enforcement proportionally to observed
    exploitation, and protecting the commons as rounds decrease.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        defection_rate = self._calculate_defection_rate(history, current_round)
        depletion_rate = (self.capacity - current_stock) / self.capacity if self.capacity > 0 else 0.0
        stock_health = self._assess_stock_health(depletion_rate)
        rounds_remaining = self.r - current_round
        threshold = self._calculate_threshold(rounds_remaining)
        if stock_health == 'CRITICAL':
            if defection_rate > 0:
                return Action.D
            threshold = 0.0
        elif stock_health == 'DECLINING':
            threshold = min(threshold, 0.25)
        if current_round >= 0.8 * self.r:
            if current_stock < 2 * self.n or defection_rate > 0:
                return Action.D
        if current_stock < 2 * self.n:
            return Action.D
        if defection_rate <= threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the proportion of defectors in the previous round.
        A player defects if they consumed stock/n (True means cooperate, False means defect).
        """
        if current_round == 0:
            return 0.0
        last_round_actions = history.opponent_actions[current_round - 1, :]
        num_defectors = np.sum(~last_round_actions)
        defection_rate = float(num_defectors) / self.n
        return defection_rate

    def _assess_stock_health(self, depletion_rate: float) -> str:
        """
        Assess stock health based on depletion rate.
        """
        if depletion_rate < 0.2:
            return 'HEALTHY'
        elif depletion_rate < 0.5:
            return 'DECLINING'
        else:
            return 'CRITICAL'

    def _calculate_threshold(self, rounds_remaining: int) -> float:
        """
        Determine dynamic threshold based on rounds remaining.
        """
        if rounds_remaining > self.r / 3:
            return 0.5
        elif rounds_remaining > self.r / 6:
            return 0.3
        else:
            return 0.1

class Strategy_COLLECTIVE_127(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection.
    
    Prioritizes sustainable collective outcomes while protecting against exploitation.
    Responds to stock levels and observed defection rates to adapt behavior dynamically.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if current_stock == 0:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0
        if stock_ratio > 0.75:
            return Action.C
        if stock_ratio > 0.4:
            return Action.C
        if stock_ratio > 0.1:
            prev_round_idx = round_num - 1
            defect_count = int(np.sum(~history.opponent_actions[prev_round_idx, :]))
            cooperation_ratio = (self.n_players - defect_count) / self.n_players
            stock_previous = state.current_stock
            if round_num >= 2:
                stock_trend = 0
                stock_decline_from_capacity = self.capacity - current_stock
                if cooperation_ratio >= 0.5:
                    return Action.C
                if cooperation_ratio < 0.5:
                    if stock_decline_from_capacity > 0.1 * self.capacity:
                        return Action.D
                    else:
                        return Action.C
            else:
                cooperation_ratio = (self.n_players - defect_count) / self.n_players
                if cooperation_ratio >= 0.5:
                    return Action.C
                else:
                    return Action.D
        return Action.D

class Strategy_COLLECTIVE_128(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection.
    
    Balances individual security with collective sustainability by using stock health
    as a coordination signal. Cooperates when stock is healthy above adaptive thresholds,
    defects when stressed or in final round. Thresholds adjust based on game progress.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.minimum_safety_threshold = 0.15

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if round_number == 0:
            if stock_ratio >= 0.5:
                return Action.C
            return Action.D
        remaining_rounds = self.n_rounds - round_number
        if round_number == self.n_rounds - 1:
            if stock_ratio > 0.15:
                return Action.D
            else:
                return Action.D
        if stock_ratio < self.minimum_safety_threshold:
            return Action.D
        threshold = self._calculate_threshold(remaining_rounds)
        if history is not None and round_number >= 1:
            previous_stock = history.opponent_payoffs[-1, :].sum() if round_number >= 1 else current_stock
            if stock_ratio > 0.4:
                if stock_ratio >= threshold:
                    return Action.C
        if stock_ratio >= threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_threshold(self, remaining_rounds: int) -> float:
        """
        Calculate adaptive threshold based on remaining rounds.
        
        Args:
            remaining_rounds: Number of rounds left (including current round)
        
        Returns:
            Stock ratio threshold for cooperation
        """
        if remaining_rounds == 1:
            return 0.35
        elif remaining_rounds <= self.n_rounds // 2:
            return 0.4
        else:
            return 0.5

class Strategy_COLLECTIVE_129(BaseStrategy):
    """
    Adaptive Resource Stewardship Strategy for Common Pool Resource Games.
    
    Prioritizes long-term collective sustainability while maintaining individual resilience.
    Uses threshold-based decision rules driven by stock health rather than opponent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = 2 * self.n
        self.previous_stock = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            self.previous_stock = current_stock
            return Action.C
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        stock_velocity = current_stock - self.previous_stock
        rounds_remaining = self.r - round_number
        self.previous_stock = current_stock
        if stock_health < 0.02:
            return Action.D
        if round_number == self.r - 1:
            if current_stock < 0.5 * self.n:
                return Action.C
            return Action.D
        if current_stock < self.threshold and rounds_remaining <= 3:
            return Action.D
        if stock_velocity < -0.05 * self.capacity:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_130(BaseStrategy):
    """
    Adaptive Stock-Preserving Cooperation (ASPC) strategy for Common Pool Resource Game.
    
    Balances individual benefit with collective sustainability by responding to stock levels
    and observed defection patterns. Cooperates when critical, adapts in transitional zones,
    and exploits responsibly in abundant zones.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cumulative_payoff = 0.0
        self.rounds_played = 0
        self.defection_counts = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if history is not None:
            if self.rounds_played == 0:
                self.cumulative_payoff = float(np.sum(history.my_payoffs[:current_round]))
                self.rounds_played = current_round
            else:
                self.cumulative_payoff += history.my_payoffs[current_round - 1]
                self.rounds_played = current_round
        avg_payoff = self.cumulative_payoff / max(1, self.rounds_played) if self.rounds_played > 0 else 1.0
        stock_zone = self._classify_stock(current_stock)
        if current_round == self.n_rounds - 1:
            return Action.D
        if stock_zone == 'CRITICAL':
            return Action.C
        if stock_zone == 'ABUNDANT':
            defection_payoff = current_stock / self.n_players
            cooperation_payoff = current_stock / (2 * self.n_players)
            rounds_remaining = self.n_rounds - current_round
            if rounds_remaining <= 3:
                threshold_multiplier = 1.2
            else:
                threshold_multiplier = 1.5
            recent_defection_rate = self._get_recent_defection_rate(history, current_round)
            if recent_defection_rate > 0.5:
                threshold_multiplier = 2.0
            if defection_payoff > threshold_multiplier * avg_payoff:
                return Action.D
            else:
                return Action.C
        if stock_zone == 'TRANSITIONAL':
            recent_defections = self._count_recent_defections(history, current_round, window=3)
            if recent_defections == 0:
                return Action.C
            elif recent_defections >= 2:
                return Action.D
            else:
                prob_defect = 1.0 - current_stock / self.capacity
                return Action.D if random.random() < prob_defect else Action.C
        return Action.C

    def _classify_stock(self, stock: float) -> str:
        """Classify stock into health zones."""
        if stock < self.capacity / 4:
            return 'CRITICAL'
        elif stock < 3 * self.capacity / 4:
            return 'TRANSITIONAL'
        else:
            return 'ABUNDANT'

    def _count_recent_defections(self, history: None | PlayerHistory, current_round: int, window: int=3) -> int:
        """Count defections by opponents in recent rounds (rolling window)."""
        if history is None or current_round == 0:
            return 0
        start_round = max(0, current_round - window)
        end_round = current_round
        recent_actions = history.opponent_actions[start_round:end_round, :]
        defection_count = np.sum(~recent_actions)
        return int(defection_count)

    def _get_recent_defection_rate(self, history: None | PlayerHistory, current_round: int, window: int=3) -> float:
        """Calculate the defection rate in recent rounds across all opponents."""
        if history is None or current_round == 0:
            return 0.0
        start_round = max(0, current_round - window)
        end_round = current_round
        recent_actions = history.opponent_actions[start_round:end_round, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        defection_count = np.sum(~recent_actions)
        return float(defection_count) / float(total_actions)

class Strategy_COLLECTIVE_131(BaseStrategy):
    """
    Adaptive Stewardship with Tit-for-Tat Governance.
    
    Balances sustainability, reciprocity, robustness, and fairness by:
    1. Cooperating when stock is healthy (>70% capacity)
    2. Responding to majority defection patterns (40-70% capacity)
    3. Defecting under stress (<40% capacity) to secure payoff
    4. Adjusting for final rounds and catastrophic depletion
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if current_round == 0:
            return Action.C
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining == 1:
            return Action.D
        if current_stock == 0:
            return Action.D
        critical_threshold = 2 * self.n_players
        if current_stock < critical_threshold:
            if current_stock > 0:
                urgency_prob = 1.0 - current_stock / critical_threshold
                defect_prob = min(0.9, urgency_prob)
                return Action.D if random.random() < defect_prob else Action.C
            else:
                return Action.D
        defectors_last_round = np.sum(~history.opponent_actions[current_round - 1, :])
        defection_rate = defectors_last_round / self.n_players
        if health_ratio > 0.7:
            return Action.C
        if health_ratio > 0.4:
            if defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        if rounds_remaining <= 3:
            return Action.D if random.random() < 0.7 else Action.C
        return Action.D if random.random() < 0.8 else Action.C

class Strategy_COLLECTIVE_132(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Retaliation
    
    Balances individual incentives with collective sustainability by:
    1. Maintaining stock above safety thresholds to ensure growth
    2. Tolerating defection up to 25% rate; responding if exceeded
    3. Using a sliding window of recent behavior (not eternal punishment)
    4. Recognizing endgame and adjusting strategy accordingly
    5. Transitioning to recovery mode when stock becomes critical
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.C
        if stock < 1.0:
            return Action.D
        remaining_rounds = self.n_rounds - round_num
        stock_safety_threshold = self.capacity * (0.4 + 0.1 * remaining_rounds / self.n_rounds)
        window_size = min(3, max(1, round_num // 2))
        defections_in_window = 0
        for i in range(max(0, round_num - window_size), round_num):
            defectors = np.sum(~history.opponent_actions[i, :])
            defections_in_window += defectors
        total_possible = window_size * self.n_players
        recent_defection_rate = defections_in_window / max(1, total_possible)
        defection_tolerance = 0.25
        if stock < self.capacity * 0.2:
            if round_num > 0:
                last_round_defectors = np.sum(~history.opponent_actions[round_num - 1, :])
                all_defected = last_round_defectors == self.n_players
                if all_defected:
                    return Action.D
            return Action.C
        if stock < stock_safety_threshold:
            return Action.D
        if remaining_rounds <= 2:
            if round_num == self.n_rounds - 1:
                if stock >= self.capacity * 0.6:
                    return Action.C
                else:
                    return Action.D
            else:
                stock_at_last_round = history.opponent_payoffs[round_num - 1, 0] * self.n_players
                stock_declining = stock < stock_at_last_round or stock < self.capacity * 0.5
                if stock_declining:
                    return Action.D
                else:
                    return Action.C
        if recent_defection_rate <= defection_tolerance:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_133(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collectively-minded strategy that balances
    individual and collective interests by adapting to resource depletion trends.
    
    Core logic:
    - DEFECT only when stock is critically depleted (< 2n) or in emergency scenarios
    - COOPERATE to sustain the resource and maximize long-term collective welfare
    - COOPERATE in early rounds to establish cooperation signal
    - COOPERATE in late rounds to preserve legacy
    - Adapt to stock trends (declining → cooperate to stabilize; healthy → cooperate)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 2 * self.n_players
        self.healthy_threshold = self.capacity * 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_stock < self.critical_threshold:
            return Action.D
        if current_stock >= self.healthy_threshold:
            return Action.C
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            if current_stock > self.critical_threshold:
                return Action.C
            else:
                return Action.D
        if self.n_rounds <= 3:
            return Action.C
        if history is not None and current_round > 0:
            previous_stock = self._get_previous_stock(history, current_round)
            if previous_stock is not None:
                if current_stock < previous_stock * 0.95:
                    return Action.C
        return Action.C

    def _get_previous_stock(self, history: PlayerHistory, current_round: int) -> float | None:
        """
        Reconstruct the previous round's stock level from history.
        
        Stock dynamics:
        S_new = min(S_consumed + growth, capacity)
        where growth = 2 * S_consumed * (1 - S_consumed / capacity)
        
        We can estimate the previous stock by working backwards from payoffs.
        For a player who cooperated (C): payoff = stock / (2*n)
        For a player who defected (D): payoff = stock / n
        
        We'll use the average of reconstructed stock from all players' payoffs.
        """
        if current_round == 0:
            return None
        prev_round_idx = current_round - 1
        payoffs_prev = history.my_payoffs[prev_round_idx]
        my_action = history.my_actions[prev_round_idx]
        if my_action:
            estimated_stock = payoffs_prev * 2 * self.n_players
        else:
            estimated_stock = payoffs_prev * self.n_players
        return estimated_stock

class Strategy_COLLECTIVE_134(BaseStrategy):
    """
    Adaptive Sustainability Strategy (ASS) for Common Pool Resource Game.
    
    Maximizes long-term collective welfare by maintaining stock health while adapting to
    environmental conditions and opponent behavior. Cooperates when stock is healthy and
    defection risk is low, defects when resource is stressed or heavily exploited.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.defection_threshold = 0.4
        self.stock_health_threshold = 0.5 * self.capacity
        self.critical_threshold = 0.3 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_stock < self.critical_threshold:
            return Action.D
        k = min(3, current_round)
        opponent_defections = 0
        for round_idx in range(current_round - k, current_round):
            if round_idx >= 0:
                for player_idx in range(self.n_players - 1):
                    if not history.opponent_actions[round_idx, player_idx]:
                        opponent_defections += 1
        opponent_actions_observed = k * (self.n_players - 1)
        if opponent_actions_observed == 0:
            recent_defection_rate = 0.0
        else:
            recent_defection_rate = opponent_defections / opponent_actions_observed
        if current_stock >= self.stock_health_threshold:
            if recent_defection_rate <= self.defection_threshold:
                return Action.C
            else:
                return Action.D
        elif recent_defection_rate > self.defection_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_135(BaseStrategy):
    """
    Adaptive Stock-Preserving Equilibrium (ASPE): A strategy that balances individual incentives
    with collective sustainability by monitoring stock levels and adapting to observed cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = 0.7 * self.capacity
        self.threshold_low = 0.3 * self.capacity
        self.threshold_critical = 0.05 * self.capacity
        self.threshold_capacity = 0.95 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            return Action.C
        if rounds_remaining <= 2:
            return Action.D
        if stock_ratio < self.threshold_critical:
            return Action.C
        if stock_ratio >= self.threshold_capacity:
            return Action.C
        if stock_ratio > self.threshold_high:
            return Action.C
        if stock_ratio < self.threshold_low:
            return Action.C
        cooperation_rate = self._calculate_cooperation_rate(history)
        if cooperation_rate > 0.5:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the proportion of cooperations observed across all opponents
        and all rounds played so far.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.5
        total_cooperations = np.sum(history.opponent_actions)
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.5
        cooperation_rate = float(total_cooperations) / float(total_actions)
        return cooperation_rate

class Strategy_COLLECTIVE_136(BaseStrategy):
    """
    Adaptive Resource Stewardship Strategy (ARSS)
    
    Balances individual payoff maximization with collective resource sustainability.
    Uses three-tier adaptive framework based on stock levels and opponent defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        rounds_remaining = self.n_rounds - round_number - 1
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio <= 1.0 / 3.0:
            return Action.C
        if stock_ratio <= 2.0 / 3.0:
            prev_round_idx = round_number - 1
            defectors_last_round = self.n_players - int(sum(history.opponent_actions[prev_round_idx, :]))
            defection_rate = defectors_last_round / self.n_players if self.n_players > 0 else 0.0
            if defection_rate > 0.55:
                return Action.D
            else:
                return Action.C
        if rounds_remaining == 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_137(BaseStrategy):
    """
    Collective Pool Stewardship Strategy (CPSS)
    
    Balances cooperative resource management with individual rationality through
    stock-dependent decision rules. Maintains the common pool above critical thresholds
    in early/middle rounds while accepting defection in final rounds per subgame
    perfect equilibrium. Includes safety valves for collapse avoidance and historical
    depletion detection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.max_historical_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if stock < 2 * self.n_players:
            return Action.C
        if history is not None:
            all_observed_stocks = [stock] + [self.capacity]
            if len(history.my_payoffs) > 0:
                pass
            self.max_historical_stock = max(self.max_historical_stock, stock)
        rounds_remaining = self.n_rounds - current_round
        base_threshold_ratio = 0.5 + 0.5 * (rounds_remaining / self.n_rounds)
        dynamic_threshold = self.capacity * base_threshold_ratio
        depletion_magnitude = self.max_historical_stock - stock
        if depletion_magnitude > 0.6 * self.capacity:
            dynamic_threshold *= 1.1
        if rounds_remaining <= 2:
            if stock > 3 * self.n_players:
                return Action.D
            else:
                return Action.C
        if stock > dynamic_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_138(BaseStrategy):
    """
    Adaptive Stock Preservation with Conditional Reciprocity.
    
    Prioritizes long-term collective welfare by maintaining common pool sustainability
    while remaining robust to exploitation through stock-state-based reciprocity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        self.stock_history.append(state.current_stock)
        current_stock = state.current_stock
        round_num = state.round_number
        safe_zone_threshold = self.capacity * (1 - math.sqrt(1 - 2 / self.n))
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0
        if stock_ratio > 0.75:
            defection_threshold = 0.6
        elif stock_ratio > 0.5:
            defection_threshold = 0.3
        else:
            defection_threshold = 0.0
        recent_rounds = min(3, round_num)
        recent_defections = 0
        for r in range(round_num - recent_rounds, round_num):
            if r >= 0:
                defections_in_round = np.sum(~history.opponent_actions[r, :])
                recent_defections += defections_in_round
        total_opponent_rounds = (self.n - 1) * recent_rounds
        recent_defection_rate = recent_defections / total_opponent_rounds if total_opponent_rounds > 0 else 0
        progress_indicator = 0
        if round_num >= 2:
            stock_two_rounds_ago = self.stock_history[-3]
            stock_change = (current_stock - stock_two_rounds_ago) / self.capacity if self.capacity > 0 else 0
            progress_indicator = stock_change
        else:
            progress_indicator = 0
        if current_stock <= safe_zone_threshold:
            return Action.D
        if recent_defection_rate > defection_threshold:
            return Action.D
        if progress_indicator < -0.05:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_139(BaseStrategy):
    """
    Adaptive Stewardship with Defection Deterrence.
    
    A collective strategy that prioritizes long-term resource sustainability
    while remaining robust against exploitation. It cooperates in round 1,
    adapts based on defection rates and stock health in middle rounds,
    and cooperates in the final round for principled collective alignment.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.ma_window = min(3, game_description.n_rounds - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.C
        return self._adaptive_decision(state, history)

    def _adaptive_decision(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        """
        Conditional cooperation with defection deterrence for middle rounds.
        """
        stock = state.current_stock
        round_num = state.round_number
        stock_health = stock / self.capacity if self.capacity > 0 else 0.0
        if stock_health < 0.3:
            return Action.D
        defection_rate = self._calculate_recent_defection_rate(history, round_num)
        if defection_rate <= 0.25:
            return Action.C
        if defection_rate > 0.75:
            return Action.D
        if stock_health >= 0.7:
            return Action.C
        else:
            return Action.D

    def _calculate_recent_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the moving average defection rate over the last ma_window rounds.
        Defection is encoded as False (0), Cooperation as True (1).
        Defection rate = fraction of opponents who defected (played False).
        """
        start_round = max(0, round_num - self.ma_window)
        end_round = round_num
        if start_round >= end_round:
            return 0.0
        window_actions = history.opponent_actions[start_round:end_round, :]
        num_rounds_in_window = end_round - start_round
        num_opponents = self.n_players - 1
        if num_opponents == 0 or num_rounds_in_window == 0:
            return 0.0
        total_defections = np.sum(~window_actions)
        total_plays = num_rounds_in_window * num_opponents
        defection_rate = float(total_defections) / float(total_plays)
        return defection_rate

class Strategy_COLLECTIVE_140(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances collective sustainability with rational self-interest by:
    1. Playing C (Cooperate) in round 0 to establish cooperation
    2. Playing C when stock > 25% of capacity (resource is healthy)
    3. Playing D when stock ≤ 25% of capacity (resource is stressed)
    4. Playing D in the final round (no future benefit to preservation)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.danger_threshold = game_description.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        n_rounds = self.game_description.n_rounds
        if round_number == 0:
            return Action.C
        if round_number == n_rounds - 1:
            return Action.D
        if current_stock > self.danger_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_141(BaseStrategy):
    """
    Adaptive Stock-Preserving Cooperation (ASPC) Strategy
    
    Balances collective sustainability, individual rationality, and adaptive robustness
    by maintaining stock above dynamic thresholds and comparing expected stock outcomes
    for cooperation vs. defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        rounds_remaining = self.r - round_num
        if rounds_remaining == 1:
            return Action.D
        if stock < 0.15 * self.capacity:
            return Action.C
        threshold = self.capacity * (0.3 + 0.4 * (rounds_remaining / self.r))
        expected_stock_if_C = self._project_stock(stock, True)
        expected_stock_if_D = self._project_stock(stock, False)
        if stock > threshold or expected_stock_if_C >= expected_stock_if_D:
            return Action.C
        else:
            return Action.D

    def _project_stock(self, stock: float, cooperate: bool) -> float:
        """
        Project expected stock after next round, assuming worst case (all others defect).
        
        Args:
            stock: Current stock level
            cooperate: True if this player cooperates, False if defects
        
        Returns:
            Expected stock level after growth phase
        """
        if cooperate:
            my_consumption = stock / (2 * self.n)
        else:
            my_consumption = stock / self.n
        others_consumption = (self.n - 1) * stock / self.n
        total_consumption = my_consumption + others_consumption
        stock_after = stock - total_consumption
        stock_after = max(0.0, stock_after)
        if self.capacity > 0:
            growth = 2 * stock_after * (1 - stock_after / self.capacity)
        else:
            growth = 0.0
        expected_stock = min(stock_after + growth, self.capacity)
        return expected_stock

class Strategy_COLLECTIVE_142(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual security with collective sustainability by dynamically
    adapting to ecosystem health and opponent behavior patterns. Uses stock-level
    thresholds and recent defection rate tracking to make decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1 and stock > 0:
            return Action.D
        if stock > 0.75 * self.capacity:
            return Action.C
        if stock > 0.4 * self.capacity:
            recent_defection_rate = self._calculate_recent_defection_rate(history)
            if recent_defection_rate < 0.5:
                return Action.C
            else:
                return Action.D
        if stock > 0.1 * self.capacity:
            return Action.D
        return Action.D

    def _calculate_recent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the defection rate among opponents in the last min(3, rounds_played) rounds.
        
        True = Cooperate (Action.C), False = Defect (Action.D)
        We want to count defections, which are False values.
        """
        rounds_played = history.my_actions.shape[0]
        lookback_rounds = min(3, rounds_played)
        if lookback_rounds == 0:
            return 0.0
        recent_opponent_actions = history.opponent_actions[-lookback_rounds:, :]
        total_actions = recent_opponent_actions.size
        if total_actions == 0:
            return 0.0
        defection_count = np.sum(recent_opponent_actions == False)
        defection_rate = float(defection_count) / float(total_actions)
        return defection_rate

class Strategy_COLLECTIVE_143(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game
    
    Balances individual payoff maximization with collective sustainability by:
    - Cooperating when stock is healthy (>75% capacity) or critical (<25% capacity)
    - Defecting strategically in middle ranges when stock is abundant but not depleting
    - Adapting cooperation thresholds based on observed opponent behavior
    - Monitoring stock trajectory to detect and prevent resource collapse
    - Playing conservatively in first round and last round
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainable_threshold_base = 0.75 * self.capacity
        self.critical_threshold = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        sustainable_threshold = self.sustainable_threshold_base
        if history is not None and round_num > 0:
            coop_rate = self._calculate_opponent_coop_rate(history, round_num)
            if coop_rate > 0.5:
                sustainable_threshold = 0.7 * self.capacity
            elif coop_rate < 0.25:
                sustainable_threshold = 0.8 * self.capacity
            else:
                sustainable_threshold = 0.75 * self.capacity
            if round_num >= 3:
                trend = self._calculate_stock_trend(history, round_num)
                if trend < -0.2:
                    return Action.C
        if round_num == self.n_rounds - 1:
            if stock > self.critical_threshold:
                return Action.D
            else:
                return Action.C
        if stock > sustainable_threshold:
            return Action.C
        elif stock <= self.critical_threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_opponent_coop_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the proportion of opponent cooperative actions across all previous rounds.
        Handles edge case of division by zero.
        """
        if round_num <= 0:
            return 0.5
        total_opponent_actions = history.opponent_actions[:round_num, :].sum()
        total_possible_actions = round_num * self.n_players
        if total_possible_actions == 0:
            return 0.5
        coop_rate = total_opponent_actions / total_possible_actions
        return coop_rate

    def _calculate_stock_trend(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate stock trend over last 3 rounds.
        Returns (current_stock - stock_3_rounds_ago) / stock_3_rounds_ago
        Handles edge cases and division by zero.
        """
        if round_num < 3:
            return 0.0
        stock_3_rounds_ago = self._reconstruct_stock_at_round(history, round_num - 3)
        current_stock = self._reconstruct_stock_at_round(history, round_num)
        if stock_3_rounds_ago <= 0:
            return 0.0
        trend = (current_stock - stock_3_rounds_ago) / stock_3_rounds_ago
        return trend

    def _reconstruct_stock_at_round(self, history: PlayerHistory, target_round: int) -> float:
        """
        Reconstruct stock level at the beginning of target_round by working backwards
        from payoff history. This is an approximation based on consumption patterns.
        """
        if target_round < 0 or target_round > len(history.my_payoffs):
            return self.capacity
        if target_round == 0:
            return self.capacity
        total_my_consumption = history.my_payoffs[:target_round].sum()
        total_consumption_estimate = total_my_consumption * self.n_players
        remaining_stock = max(0.0, self.capacity - total_consumption_estimate)
        return remaining_stock

class Strategy_COLLECTIVE_144(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection strategy for Common Pool Resource Game.
    
    Prioritizes long-term collective welfare while remaining robust against exploitation.
    Uses stock-health-based cooperation with historical punishment and end-game adjustments.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        capacity = self.capacity
        n = self.n_players
        r = self.n_rounds
        if round_num == 0:
            self.punishment_counter = 0
            return Action.C
        current_stock_ratio = stock / capacity if capacity > 0 else 0.0
        if round_num >= r - 2:
            if current_stock_ratio < 0.4:
                return Action.D
            else:
                return Action.C
        total_past_defections = 0
        for past_round in range(round_num):
            for opponent_idx in range(n - 1):
                if not history.opponent_actions[past_round, opponent_idx]:
                    total_past_defections += 1
        defection_rate = total_past_defections / (n * round_num) if round_num > 0 else 0.0
        if defection_rate >= 0.6:
            if self.punishment_counter > 0:
                self.punishment_counter -= 1
                return Action.D
            else:
                punishment_duration = math.ceil(defection_rate * r)
                self.punishment_counter = punishment_duration - 1
                return Action.D
        else:
            self.punishment_counter = 0
        if current_stock_ratio >= 0.75:
            return Action.C
        elif current_stock_ratio < 0.5:
            return Action.D
        else:
            cooperation_prob = (current_stock_ratio - 0.5) / 0.25
            if random.random() < cooperation_prob:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_145(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS) - A strategy that balances individual payoff
    maximization with collective resource preservation in a common pool resource game.
    
    Core approach:
    - Cooperate early to establish trust and maintain stock health
    - Adapt behavior based on observed defection ratios
    - Defect in terminal rounds and under critical stock conditions
    - Punish widespread defection while rewarding cooperation
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - round_number
        if self.capacity <= 0:
            return Action.D
        stock_ratio = current_stock / self.capacity
        if stock_ratio <= 0.01:
            return Action.D
        if rounds_remaining == 1:
            return Action.D
        if round_number <= 1:
            return Action.C
        if round_number > 1:
            observed_defection_ratio = self._estimate_defection_ratio(history, round_number, current_stock)
            if stock_ratio > 0.6:
                if observed_defection_ratio > 0.5:
                    return Action.D
                else:
                    return Action.C
            elif stock_ratio > 0.2:
                if rounds_remaining >= 3:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        return Action.C

    def _estimate_defection_ratio(self, history: PlayerHistory, current_round: int, current_stock: float) -> float:
        """
        Estimate the proportion of players who defected in the previous round.
        
        Uses stock depletion as a proxy: higher consumption indicates more defection.
        """
        if current_round <= 1:
            return 0.0
        last_round_idx = current_round - 1
        opponent_last_actions = history.opponent_actions[last_round_idx, :]
        defectors = np.sum(~opponent_last_actions)
        defection_ratio = defectors / self.n_players
        return float(defection_ratio)

class Strategy_COLLECTIVE_146(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game
    
    Balances personal benefit with system health by cooperating when stock is healthy
    and defecting only when the resource is critically depleted. Adapts thresholds
    based on observed opponent behavior and game phase.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        threshold_high = 0.6 * self.capacity
        threshold_critical = 0.15 * self.capacity
        if self.n == 2:
            threshold_high = 0.7 * self.capacity
        defection_rate = self._calculate_defection_rate(history, round_num)
        if defection_rate > 0.5:
            threshold_high = 0.5 * self.capacity
            threshold_critical = 0.1 * self.capacity
        elif defection_rate < 0.2:
            threshold_high = 0.75 * self.capacity
        if stock < 0.1 * self.capacity and round_num > 0:
            return Action.D
        if round_num == self.r - 1:
            if stock > threshold_critical:
                return Action.C
            else:
                return Action.D
        if stock > threshold_high:
            return Action.C
        elif stock > threshold_critical:
            probability = stock / threshold_critical
            return Action.C if random.random() < probability else Action.D
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the rate at which opponents have defected.
        Returns a value between 0 and 1.
        """
        if round_num == 0:
            return 0.0
        defection_rounds = 0
        for r in range(round_num):
            if np.any(history.opponent_actions[r, :] == False):
                defection_rounds += 1
        return defection_rounds / round_num if round_num > 0 else 0.0

class Strategy_COLLECTIVE_147(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A pragmatic strategy balancing individual benefit-seeking
    with collective resource preservation in common pool resource games.
    
    Core logic:
    - Round 1: Always cooperate (establish goodwill baseline)
    - Final round: Defect unless stock critically low (<10% capacity)
    - Main rounds: Stock-responsive with adaptive defection tolerance based on recent history
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            if current_stock < 0.1 * self.capacity:
                return Action.C
            else:
                return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        recent_rounds = min(3, current_round)
        defectors_count = self._count_recent_defectors(history, recent_rounds)
        denominator = (self.n_players - 1) * recent_rounds
        defection_rate = defectors_count / denominator if denominator > 0 else 0.0
        is_critical = stock_ratio < 0.2
        is_healthy = stock_ratio >= 0.5
        if is_critical:
            return Action.D
        if is_healthy:
            if defection_rate <= 0.3:
                return Action.C
            else:
                return Action.D
        if defection_rate > 0.6:
            return Action.D
        else:
            return Action.C

    def _count_recent_defectors(self, history: PlayerHistory, recent_rounds: int) -> int:
        """
        Count total defections by all opponents in the last N rounds.
        
        Args:
            history: PlayerHistory object containing opponent actions
            recent_rounds: Number of recent rounds to examine
        
        Returns:
            Total count of defections (False values) across all opponents in recent rounds
        """
        if recent_rounds <= 0 or history.opponent_actions.size == 0:
            return 0
        start_idx = max(0, len(history.opponent_actions) - recent_rounds)
        recent_actions = history.opponent_actions[start_idx:, :]
        defectors = np.sum(~recent_actions)
        return int(defectors)

class Strategy_COLLECTIVE_148(BaseStrategy):
    """
    Adaptive Reciprocal Stewardship (ARS) - A collective pool stewardship strategy
    that balances individual payoff maximization with resource sustainability through
    threshold-based decisions and reciprocal matching of observed defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock = state.current_stock
        round_num = state.round_number
        stock_health = stock / self.capacity if self.capacity > 0 else 0.0
        defection_rate = self._calculate_defection_rate(history, round_num)
        if stock < 2 * self.n_players:
            return Action.C
        if stock < 0.3 * self.capacity:
            if defection_rate < 0.5:
                return Action.C
            else:
                return Action.D
        if stock < 0.75 * self.capacity:
            if defection_rate <= 0.25:
                return Action.C
            elif defection_rate >= 0.75:
                return Action.D
            else:
                prob_cooperate = 1.0 - defection_rate
                if random.random() < prob_cooperate:
                    return Action.C
                else:
                    return Action.D
        if defection_rate <= 0.5:
            return Action.C
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the defection rate from the previous round.
        Defection is encoded as False/0, cooperation as True/1.
        Defection rate = (number of defectors) / (total opponents)
        """
        if round_num <= 0:
            return 0.0
        prev_round_idx = round_num - 1
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        num_defectors = np.sum(~opponent_actions_prev)
        num_opponents = len(opponent_actions_prev)
        if num_opponents == 0:
            return 0.0
        defection_rate = float(num_defectors) / float(num_opponents)
        return defection_rate

class Strategy_COLLECTIVE_149(BaseStrategy):
    """
    Adaptive Collective Stewardship Strategy (ACS)
    
    Balances individual security with collective welfare through adaptive behavior that:
    1. Protects against exploitation while rewarding cooperation
    2. Maintains stock health to sustain long-term payoffs
    3. Adapts to detected defection patterns without requiring explicit coordination
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_history = []
        self.cooperation_history = []
        self.cumulative_payoff = 0.0
        self.consecutive_high_depletion = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        self.stock_history.append(current_stock)
        if history is not None:
            self.cumulative_payoff += history.my_payoffs[round_number - 1]
        if round_number == 0:
            return Action.C
        if round_number <= 2:
            return Action.C
        if current_stock < self.capacity * 0.1:
            return Action.D
        recent_cooperation_rate = self._calculate_recent_cooperation_rate(history, round_number)
        depletion_crisis = self._detect_depletion_crisis(round_number)
        if depletion_crisis:
            self.consecutive_high_depletion += 1
            if self.consecutive_high_depletion >= 2:
                return Action.D
        else:
            self.consecutive_high_depletion = 0
        stock_trend = self._determine_stock_trend()
        if stock_trend == 'increasing':
            min_threshold = 0.4
        elif stock_trend == 'declining':
            min_threshold = 0.6
        else:
            min_threshold = 0.5
        if current_stock > self.capacity * 0.9:
            min_threshold = max(0.4, min_threshold)
        critical_threshold = self.capacity * 0.35
        critical_stock = current_stock <= critical_threshold
        if round_number == self.n_rounds - 1:
            if current_stock > critical_threshold:
                return Action.D
            else:
                return Action.C
        if not critical_stock and recent_cooperation_rate >= min_threshold:
            return Action.C
        elif critical_stock and recent_cooperation_rate >= min_threshold:
            return Action.C
        return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, round_number: int) -> float:
        """Calculate the fraction of opponents who cooperated in the last round."""
        if round_number == 0 or history is None:
            return 0.5
        last_round_idx = round_number - 1
        cooperators = np.sum(history.opponent_actions[last_round_idx, :])
        return cooperators / self.n_players

    def _detect_depletion_crisis(self, round_number: int) -> bool:
        """Check if current stock depletion rate exceeds sustainable threshold."""
        if len(self.stock_history) < 2:
            return False
        current_stock = self.stock_history[-1]
        previous_stock = self.stock_history[-2]
        if previous_stock == 0:
            return False
        depletion_rate = (previous_stock - current_stock) / previous_stock
        return depletion_rate > 0.5

    def _determine_stock_trend(self) -> str:
        """Determine if stock is increasing, stable, or declining over last 3 rounds."""
        if len(self.stock_history) < 3:
            return 'stable'
        recent_stocks = self.stock_history[-3:]
        if recent_stocks[-1] > recent_stocks[0]:
            return 'increasing'
        elif recent_stocks[-1] < recent_stocks[0] * 0.95:
            return 'declining'
        else:
            return 'stable'

class Strategy_COLLECTIVE_150(BaseStrategy):
    """
    Adaptive Sustainability Protocol (ASP): A collective strategy that prioritizes
    long-term common pool resource health while adapting to opponent behavior patterns.
    Uses stock health ratios and defection rate estimation to make decisions that
    balance individual rationality with collective welfare.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainable_threshold = 0.6
        self.critical_threshold = 0.25
        self.collapse_threshold = 0.15
        self.adaptive_threshold = 0.55
        self.low_defection_threshold = 0.25
        self.high_defection_threshold = 0.6
        self.observation_phase_end = 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        capacity = self.capacity
        stock_ratio = current_stock / capacity if capacity > 0 else 0.0
        if round_num == 0:
            return Action.C
        if stock_ratio < self.collapse_threshold:
            return Action.D
        if round_num == self.n_rounds - 1:
            if stock_ratio > self.sustainable_threshold:
                return Action.C
            else:
                return Action.D
        if round_num >= self.n_rounds - 2 and stock_ratio > 0.5:
            return Action.C
        if round_num < self.observation_phase_end:
            return Action.C
        defection_rate = self._calculate_defection_rate(history, round_num)
        if defection_rate < self.low_defection_threshold:
            return Action.C
        elif defection_rate > self.high_defection_threshold:
            return Action.D
        elif stock_ratio > self.adaptive_threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the observed defection rate from opponent actions in history.
        Defection is False (Action.D), Cooperation is True (Action.C).
        """
        if round_num < 1:
            return 0.0
        opponent_actions = history.opponent_actions[:round_num, :]
        total_actions = opponent_actions.size
        if total_actions == 0:
            return 0.0
        defection_count = np.sum(~opponent_actions)
        defection_rate = float(defection_count) / float(total_actions)
        return defection_rate

class Strategy_COLLECTIVE_151(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Games.
    
    Balances individual payoff maximization with collective resource sustainability.
    Dynamically shifts between cooperation and defection based on stock health,
    resource trends, and game phase (early, middle, final round).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.upper_threshold = 0.75 * self.capacity
        self.lower_threshold = 0.15 * self.capacity
        self.critical_level = 0.1 * self.capacity
        self.recovery_protection_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        total_rounds = self.n_rounds
        if round_num == 0:
            return Action.C
        stock_history = self._build_stock_history(state, history)
        trend = self._determine_trend(stock_history)
        consecutive_declines = self._count_consecutive_declines(stock_history)
        if current_stock <= self.critical_level:
            self.recovery_protection_rounds_remaining = 2
            return Action.C
        if self.recovery_protection_rounds_remaining > 0:
            self.recovery_protection_rounds_remaining -= 1
            return Action.C
        if len(stock_history) >= 2:
            growth_rate = (stock_history[-1] - stock_history[-2]) / max(stock_history[-2], 1e-06)
            if growth_rate > 0.5:
                return Action.C
        if current_stock > self.upper_threshold:
            return Action.C
        if self.lower_threshold < current_stock <= self.upper_threshold:
            if consecutive_declines >= 3:
                return Action.D
            if trend == 'DECLINING':
                return Action.D
            else:
                return Action.C
        if round_num == total_rounds - 1:
            if current_stock > self.lower_threshold:
                return Action.D
            else:
                return Action.C
        return Action.C

    def _build_stock_history(self, state: CommonPoolState, history: None | PlayerHistory) -> list:
        """
        Reconstruct stock levels from history and current state.
        Returns list of stock levels from round 0 to current round (exclusive).
        """
        if history is None or len(history.my_payoffs) == 0:
            return []
        stock_history = []
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        for round_idx in range(len(history.my_payoffs)):
            my_action = history.my_actions[round_idx]
            my_payoff = history.my_payoffs[round_idx]
            if my_action:
                inferred_stock = my_payoff * (2 * n_players)
            else:
                inferred_stock = my_payoff * n_players
            stock_history.append(inferred_stock)
        return stock_history

    def _determine_trend(self, stock_history: list) -> str:
        """
        Determine stock trend: DECLINING, STABLE_OR_RECOVERING.
        """
        if len(stock_history) < 2:
            return 'STABLE_OR_RECOVERING'
        if stock_history[-1] < stock_history[-2]:
            return 'DECLINING'
        else:
            return 'STABLE_OR_RECOVERING'

    def _count_consecutive_declines(self, stock_history: list) -> int:
        """
        Count consecutive rounds of stock decline at the end of history.
        """
        if len(stock_history) < 2:
            return 0
        count = 0
        for i in range(len(stock_history) - 1, 0, -1):
            if stock_history[i] < stock_history[i - 1]:
                count += 1
            else:
                break
        return count

class Strategy_COLLECTIVE_152(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS) - A strategy that balances individual payoff 
    maximization with collective sustainability in common pool resource games.
    
    Core logic:
    1. First round: cooperate (gather information)
    2. Stock critically low: cooperate (resource preservation)
    3. High defection rate observed: defect (self-defense)
    4. Otherwise: cooperate (maintain sustainability)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.depletion_threshold = self.capacity * 0.25
        self.critical_threshold = self.depletion_threshold * 0.5
        self.aggression_threshold = 0.5
        self.historical_window = max(3, self.n_rounds // 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        current_round = state.round_number
        if current_stock < self.critical_threshold:
            return Action.C
        if current_stock <= self.depletion_threshold:
            return Action.C
        defection_rate = self._calculate_defection_rate(history, current_round)
        if defection_rate > self.aggression_threshold:
            return Action.D
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the proportion of opponent defections in recent history.
        Returns a value in [0, 1] representing defection rate among opponents.
        """
        window_start = max(0, current_round - self.historical_window)
        window_end = current_round
        window_size = window_end - window_start
        if window_size == 0:
            return 0.0
        recent_opponent_actions = history.opponent_actions[window_start:window_end, :]
        defection_count = np.sum(~recent_opponent_actions)
        total_possible_defections = (self.n_players - 1) * window_size
        if total_possible_defections == 0:
            return 0.0
        defection_rate = defection_count / total_possible_defections
        return float(defection_rate)

class Strategy_COLLECTIVE_153(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Games.
    
    A cooperation-first, punishment-as-last-resort strategy that:
    - Leads with cooperation to establish collaborative norms
    - Punishes excessive defection (>40%) proportionally
    - Switches to preservation mode when stock falls below 20% capacity
    - Maintains cooperation when stock is healthy (>70% capacity)
    - Enables recovery through emergency cooperation
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.stock_danger_threshold = self.capacity * 0.2
        self.stock_healthy_threshold = self.capacity * 0.7
        self.defection_tolerance = 0.4
        self.recent_rounds_window = min(3, self.n_rounds - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        defection_rate = self._calculate_recent_defection_rate(history)
        if state.current_stock < self.stock_danger_threshold:
            return Action.C
        if defection_rate > self.defection_tolerance:
            return Action.D
        if state.current_stock >= self.stock_healthy_threshold:
            return Action.C
        return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the defection rate of other players in the recent window.
        
        Returns:
            float: Proportion of other players who defected in recent rounds
        """
        current_round = history.my_actions.shape[0]
        start_round = max(0, current_round - self.recent_rounds_window)
        recent_opponent_actions = history.opponent_actions[start_round:current_round, :]
        if recent_opponent_actions.size == 0:
            return 0.0
        defection_count = np.sum(~recent_opponent_actions)
        total_actions = recent_opponent_actions.size
        if total_actions == 0:
            return 0.0
        defection_rate = defection_count / total_actions
        return defection_rate

class Strategy_COLLECTIVE_154(BaseStrategy):
    """
    Adaptive Stewardship with Defensive Thresholds.
    
    Balances collective welfare with individual security through:
    - Default cooperation when stock is healthy
    - Conditional cooperation based on observed cooperation rates
    - Defensive defection when stock is critically low or majority defects
    - Terminal round defection (backward induction)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = 0.15 * game_description.capacity
        self.caution_threshold = 0.4 * game_description.capacity
        self.observation_window = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.critical_threshold:
            return Action.D
        if state.current_stock < self.caution_threshold:
            observed_cooperation_rate = self._calculate_cooperation_rate(history, state.round_number)
            if observed_cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        recent_defection_rate = self._calculate_defection_rate(history, state.round_number)
        if recent_defection_rate <= 0.25:
            return Action.C
        elif recent_defection_rate <= 0.5:
            if random.random() < 0.6:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the observed cooperation rate of opponents in recent rounds.
        Returns value in [0, 1] where 1 = all cooperate, 0 = all defect.
        """
        if current_round == 0:
            return 1.0
        look_back_rounds = min(self.observation_window, current_round)
        start_round = current_round - look_back_rounds
        total_actions = history.opponent_actions[start_round:current_round, :].sum()
        total_possible = look_back_rounds * self.game_description.n_players
        if total_possible == 0:
            return 1.0
        return total_actions / total_possible

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the observed defection rate of opponents in recent rounds.
        Returns value in [0, 1] where 0 = all cooperate, 1 = all defect.
        """
        cooperation_rate = self._calculate_cooperation_rate(history, current_round)
        return 1.0 - cooperation_rate

class Strategy_COLLECTIVE_155(BaseStrategy):
    """
    Adaptive Sustainability Strategy (ASS) for Common Pool Resource Game.
    
    Balances personal payoff, commons preservation, and adaptation to opponent defection.
    Opens cooperatively, escalates enforcement based on opponent defection rates,
    and switches to survival mode if stock health becomes critical.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        stock_health = stock / self.capacity if self.capacity > 0 else 0.0
        if stock_health < 0.15:
            return Action.D
        rounds_observed = round_num
        if rounds_observed == 0:
            opponent_defection_rate = 0.0
        else:
            opponent_defections = np.sum(~history.opponent_actions[:rounds_observed, :])
            total_opponent_actions = rounds_observed * (self.n_players - 1)
            opponent_defection_rate = opponent_defections / total_opponent_actions if total_opponent_actions > 0 else 0.0
        rounds_remaining = self.n_rounds - round_num
        if rounds_remaining <= 3:
            threshold = 0.3
        else:
            threshold = 0.5
        if opponent_defection_rate > threshold:
            return Action.D
        min_stock_for_cooperation = 1.5 * self.n_players
        if stock < min_stock_for_cooperation:
            return Action.D
        if opponent_defection_rate > 0.4:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_156(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collectively rational strategy for common pool resource games.
    
    Maintains stock viability through three-state health classification (CRITICAL, DEGRADED, HEALTHY)
    and proportional response to opponent defection rates. Prioritizes resource sustainability over
    individual payoff maximization.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        health = current_stock / self.capacity if self.capacity > 0 else 0.0
        if round_number == 0:
            return Action.C
        if health < 0.05:
            return Action.C
        defection_rate = self._calculate_defection_rate(history, round_number)
        if health < 0.25:
            return Action.C
        elif health < 0.5:
            if defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        elif defection_rate == 0.0:
            return Action.C
        elif defection_rate > 0.75:
            return Action.D
        elif defection_rate > 0.33:
            return Action.D
        else:
            return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the proportion of opponents who defected in the previous round.
        
        Args:
            history: Player history containing opponent actions
            round_number: Current round number (0-indexed)
        
        Returns:
            Defection rate in range [0.0, 1.0]
        """
        if round_number <= 0:
            return 0.0
        last_round_opponent_actions = history.opponent_actions[round_number - 1, :]
        num_defectors = np.sum(~last_round_opponent_actions)
        num_opponents = self.n_players - 1
        if num_opponents <= 0:
            return 0.0
        defection_rate = float(num_defectors) / float(num_opponents)
        return defection_rate

class Strategy_COLLECTIVE_157(BaseStrategy):
    """
    Adaptive Commons Stewardship Strategy (ACS)
    
    Balances individual payoff maximization with collective resource sustainability
    by adaptively responding to stock health, recent depletion trends, and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_health >= 0.75:
            return Action.C
        if stock_health < 0.25:
            return Action.C
        if round_number == self.n_rounds - 1:
            if stock_health >= 0.5:
                return Action.D
            else:
                return Action.C
        if round_number < 2:
            return Action.C
        if stock_health >= 0.5:
            stock_2_rounds_ago = history.opponent_payoffs[round_number - 2, 0] * self.n_players
            recent_depletion = self._calculate_recent_depletion(history, round_number)
            if recent_depletion < 0.05:
                return Action.C
            elif recent_depletion < 0.15:
                if round_number % 3 != 0:
                    return Action.C
                else:
                    return Action.D
        if round_number >= 2:
            opponent_defect_rate = self._calculate_opponent_defection_rate(history, round_number)
            if opponent_defect_rate > 0.6:
                return Action.D
            elif opponent_defect_rate > 0.35:
                prob_defect = min(0.5, opponent_defect_rate - 0.35)
                if random.random() < prob_defect:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        return Action.C

    def _calculate_recent_depletion(self, history: PlayerHistory, round_number: int) -> float:
        """
        Estimate recent depletion from last 2 rounds.
        Uses opponent actions to infer stock changes.
        """
        if round_number < 2:
            return 0.0
        defections_prev_2 = 0
        for r in range(max(0, round_number - 2), round_number):
            defections_prev_2 += self.n_players - 1 - np.sum(history.opponent_actions[r, :])
            if history.my_actions[r]:
                defections_prev_2 += 0
            else:
                defections_prev_2 += 1
        max_defections = 2 * self.n_players
        estimated_depletion = defections_prev_2 / max_defections if max_defections > 0 else 0.0
        return estimated_depletion

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate opponent defection rate over last 3 rounds.
        True/1 = Cooperate, False/0 = Defect
        """
        look_back = min(3, round_number)
        if look_back == 0:
            return 0.0
        start_round = round_number - look_back
        total_opponent_actions = 0
        total_cooperations = 0
        for r in range(start_round, round_number):
            cooperations_this_round = np.sum(history.opponent_actions[r, :])
            total_cooperations += cooperations_this_round
            total_opponent_actions += self.n_players - 1
        if total_opponent_actions == 0:
            return 0.0
        defection_rate = 1.0 - total_cooperations / total_opponent_actions
        return defection_rate

class Strategy_COLLECTIVE_158(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Prioritizes sustainable resource management while remaining resilient to exploitation.
    Balances collective welfare with individual security using observable history to adapt
    defensively when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        stock_ratio = current_stock / self.capacity
        if stock_ratio < 0.25:
            return Action.D
        trajectory = self._calculate_trajectory(history, round_number)
        defection_rate = self._calculate_defection_rate(history, round_number)
        if stock_ratio >= 0.5:
            if defection_rate <= 0.25:
                return Action.C
            elif defection_rate <= 0.6:
                if trajectory >= 0:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        elif stock_ratio >= 0.25:
            if trajectory < 0:
                return Action.D
            else:
                return Action.C
        return Action.C

    def _calculate_trajectory(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate stock trajectory using 3-round window if available.
        Returns normalized change rate, or 0 if insufficient history.
        """
        if round_number < 4:
            return 0.0
        recent_round_idx = round_number - 1
        older_round_idx = round_number - 4
        if recent_round_idx < 0 or older_round_idx < 0:
            return 0.0
        recent_payoff = history.my_payoffs[recent_round_idx]
        older_payoff = history.my_payoffs[older_round_idx]
        if older_payoff == 0:
            if recent_payoff > 0:
                return 1.0
            else:
                return 0.0
        trajectory = (recent_payoff - older_payoff) / older_payoff
        return trajectory

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate observed defection rate across all players over observable history.
        Defection is encoded as False (0), Cooperation as True (1).
        """
        if round_number == 0:
            return 0.0
        rounds_to_analyze = round_number
        total_opponent_actions = 0
        total_defections = 0
        for r in range(rounds_to_analyze):
            for p in range(self.n_players - 1):
                total_opponent_actions += 1
                if not history.opponent_actions[r, p]:
                    total_defections += 1
        for r in range(rounds_to_analyze):
            total_opponent_actions += 1
            if not history.my_actions[r]:
                total_defections += 1
        if total_opponent_actions == 0:
            return 0.0
        defection_rate = total_defections / total_opponent_actions
        return defection_rate

class Strategy_COLLECTIVE_159(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS) for Common Pool Resource Game.
    
    Balances individual payoff maximization with collective sustainability through:
    - Cooperative initialization to signal good faith
    - Adaptive defection based on stock health and historical defection rates
    - Final-round defection for subgame-perfect equilibrium
    - Threshold-based tolerance for observed defection behavior
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        shr = current_stock / self.capacity if self.capacity > 0 else 1.0
        hdr = self._calculate_hdr(history)
        if shr < 0.25:
            return Action.D
        if shr < 0.4:
            if hdr < 0.3:
                return Action.C
            else:
                return Action.D
        if hdr < 0.4:
            return Action.C
        else:
            return Action.D

    def _calculate_hdr(self, history: PlayerHistory) -> float:
        """
        Calculate Historical Defection Rate (HDR) from all observed actions.
        
        HDR = (count of defections in all rounds) / (total possible action slots)
        True = Cooperate, False = Defect
        """
        round_num = history.my_actions.shape[0]
        if round_num == 0:
            return 0.0
        my_defections = np.sum(~history.my_actions)
        opponent_defections = np.sum(~history.opponent_actions)
        total_defections = my_defections + opponent_defections
        total_slots = round_num * (1 + self.n_players)
        if total_slots == 0:
            return 0.0
        hdr = total_defections / total_slots
        return hdr

class Strategy_COLLECTIVE_160(BaseStrategy):
    """
    Collective Pool Preservation Strategy (CPPS)
    
    Maximizes collective welfare by maintaining stock sustainability through adaptive cooperation.
    Core insight: the common pool's regenerative capacity is the real prize.
    
    Decision rule:
    - First round: COOPERATE (establish cooperative signal)
    - Last round: DEFECT (no future consequences)
    - Otherwise: Stock-level adaptive rule
      * stock > 0.75*capacity: COOPERATE (sustainable zone)
      * 2n ≤ stock ≤ 0.75*capacity: DEFECT (scarcity zone)
      * 0 < stock < 2n: DEFECT (emergency zone)
      * stock = 0: COOPERATE (reset attempt)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = 0.75 * self.capacity
        self.threshold_critical = 2 * self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            if current_stock > 0:
                return Action.D
            else:
                return Action.C
        if current_stock > self.threshold_high:
            return Action.C
        elif current_stock > self.threshold_critical:
            return Action.D
        elif current_stock > 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_161(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS) Strategy
    
    A collective strategy that prioritizes sustainable resource management while
    remaining robust to exploitation. It cooperates when stock is healthy and
    cooperation is reciprocated, defects to punish free-riders, and maximizes
    individual payoff in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainability_threshold = self.capacity * 0.4
        self.cooperation_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.sustainability_threshold:
            return Action.D
        lookback_window = min(3, current_round)
        total_cooperations = 0
        for t in range(current_round - lookback_window, current_round):
            if history.my_actions[t]:
                total_cooperations += 1
            for opponent_coop in history.opponent_actions[t, :]:
                if opponent_coop:
                    total_cooperations += 1
        total_player_rounds = (self.n_players + 1) * lookback_window
        if total_player_rounds == 0:
            recent_cooperation_rate = 0.0
        else:
            recent_cooperation_rate = total_cooperations / total_player_rounds
        if recent_cooperation_rate >= self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_162(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Games.
    
    Balances self-interest with pool preservation through health-based decision rules.
    Cooperates in crisis (stock < 40% capacity), defects in abundance (stock > 75% capacity),
    and calibrates selectively in between based on rounds remaining and trajectory analysis.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        health_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        if stock <= 2 * self.n:
            return Action.C
        rounds_remaining = self.r - round_num - 1
        if round_num == self.r - 1:
            if health_ratio > 0.6:
                return Action.D
            else:
                return Action.C
        if health_ratio > 0.75:
            return Action.D
        elif health_ratio >= 0.5:
            if rounds_remaining > 3:
                return Action.C
            else:
                return Action.D
        elif health_ratio >= 0.4:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_163(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual payoff maximization with collective resource preservation
    through stock-threshold cooperation, catastrophe avoidance, and adaptive
    sensitivity to game progression and resource health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.C
        if stock < 2 * self.n_players:
            return Action.C
        if current_round == self.n_rounds - 1:
            if stock >= 2 * self.n_players:
                return Action.D
            else:
                return Action.C
        threshold = self.capacity * (1.0 - 1.0 / self.n_rounds)
        if stock < threshold:
            return Action.C
        elapsed_ratio = float(current_round) / float(self.n_rounds)
        stock_ratio = stock / self.capacity
        defection_probability = elapsed_ratio * stock_ratio
        defection_probability = max(0.0, min(1.0, defection_probability))
        if random.random() < defection_probability:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_164(BaseStrategy):
    """
    Adaptive Stock-Preservation Strategy (ASPS)
    
    Prioritizes long-term collective resource preservation while remaining robust to exploitation.
    Uses stock health classification and opponent behavior monitoring to adapt defection/cooperation
    decisions dynamically.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        health = self._classify_health(stock)
        if round_num == 0:
            defection_rate = 0.5
        else:
            defection_rate = self._calculate_defection_rate(history, round_num)
        if defection_rate > 0.6:
            health = self._step_down_health(health)
        elif defection_rate < 0.25:
            health = self._step_up_health(health)
        if round_num == self.n_rounds - 1 and stock > 0:
            return Action.D
        if round_num == self.n_rounds - 2 and health == 2:
            stock_after_my_defection = stock - stock / self.n_players
            if stock_after_my_defection > 0.1 * self.capacity:
                return Action.D
            else:
                return Action.C
        if health == 0 or health == 1:
            return Action.C
        elif health == 2:
            stock_after_my_defection = stock - stock / self.n_players
            if stock_after_my_defection > 0.1 * self.capacity:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

    def _classify_health(self, stock: float) -> int:
        """
        Classify stock health into states.
        Returns: 0=HEALTHY, 1=STABLE, 2=CRITICAL, 3=DEPLETED
        """
        if stock >= 0.75 * self.capacity:
            return 0
        elif stock >= 0.4 * self.capacity:
            return 1
        elif stock > 0.05 * self.capacity:
            return 2
        else:
            return 3

    def _calculate_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the rate at which opponents defected in prior rounds.
        """
        if round_num == 0:
            return 0.5
        total_defections = 0
        total_observations = 0
        for past_round in range(round_num):
            opponent_cooperations = np.sum(history.opponent_actions[past_round, :])
            defections_in_round = self.n_players - 1 - opponent_cooperations
            total_defections += defections_in_round
            total_observations += self.n_players - 1
        if total_observations == 0:
            return 0.5
        return total_defections / total_observations

    def _step_down_health(self, health: int) -> int:
        """
        Shift one step down in health classification (more defensive).
        """
        if health == 0:
            return 1
        elif health == 1:
            return 2
        elif health == 2:
            return 3
        else:
            return 3

    def _step_up_health(self, health: int) -> int:
        """
        Shift one step up in health classification (more cooperative).
        """
        if health == 3:
            return 2
        elif health == 2:
            return 1
        elif health == 1:
            return 0
        else:
            return 0

class Strategy_COLLECTIVE_165(BaseStrategy):
    """
    Adaptive Commons Stewardship Strategy
    
    Prioritizes sustainable collective resource management while adapting to observed defection.
    Cooperates initially, protects commons in crisis, and punishes systematic exploitation
    based on adaptive thresholds that account for game progress and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.C
        if current_stock < self.capacity / 4:
            return Action.C
        num_prior_rounds = round_num
        if num_prior_rounds < 2:
            return Action.C
        defection_round_count = 0
        for round_idx in range(num_prior_rounds):
            opponent_actions_in_round = history.opponent_actions[round_idx, :]
            cooperators_in_round = np.sum(opponent_actions_in_round)
            if cooperators_in_round < self.n_players / 2:
                defection_round_count += 1
        defection_rate = defection_round_count / num_prior_rounds
        remaining_rounds = self.n_rounds - round_num
        progress_ratio = remaining_rounds / self.n_rounds if self.n_rounds > 0 else 0
        base_threshold = 0.3 + progress_ratio * 0.2
        if round_num > 0.75 * self.n_rounds:
            base_threshold = 0.35 + progress_ratio * 0.25
        if num_prior_rounds <= 2:
            base_threshold = 0.5
        if self.capacity / 4 < current_stock < self.capacity / 2:
            if defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        if defection_rate > base_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_166(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A strategy that prioritizes long-term collective
    sustainability of the common pool resource over short-term individual exploitation.
    
    Core mechanism:
    - Cooperate by default when stock is healthy
    - Increase cooperation probability as stock depletes
    - Defect only in the final round (if stock is abundant)
    - Adapt thresholds based on observed stock trends
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        self.stock_history.append(current_stock)
        critical_threshold = self.capacity * 0.15
        sustainable_threshold = self.capacity * 0.45
        if len(self.stock_history) >= 2:
            trend = self.stock_history[-1] - self.stock_history[-2]
            if trend < -0.1 * self.capacity:
                critical_threshold = max(0, critical_threshold - self.capacity * 0.05)
                sustainable_threshold = max(0, sustainable_threshold - self.capacity * 0.05)
        if current_round == self.n_rounds - 1:
            if current_stock > self.capacity * 0.5:
                return Action.D
            else:
                return Action.C
        if current_round == 0:
            return Action.C
        if current_stock >= self.capacity * 0.95:
            return Action.C
        if current_stock <= 1e-06:
            return Action.D
        if current_stock < critical_threshold:
            return Action.C
        if current_stock < sustainable_threshold:
            denominator = critical_threshold - sustainable_threshold
            if denominator > 1e-06:
                p_cooperate = (sustainable_threshold - current_stock) / denominator
            else:
                p_cooperate = 1.0
            p_cooperate = max(0.0, min(1.0, p_cooperate))
            if random.random() < p_cooperate:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_167(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy for Common Pool Resource games
    that balances immediate payoff maximization with long-term stock preservation through
    dynamic sustainability metrics and graduated defection deterrence.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.previous_stock = game_description.capacity
        self.consecutive_cooperation_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        previous_actions = history.opponent_actions[current_round - 1, :]
        defection_rate = float(self.n_players - np.sum(previous_actions)) / self.n_players
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        stock_momentum = 0.0
        if self.previous_stock > 0:
            stock_momentum = (current_stock - self.previous_stock) / self.previous_stock
        rounds_remaining = self.n_rounds - current_round
        if current_stock <= 0:
            return Action.D
        if defection_rate == 0.0:
            self.consecutive_cooperation_rounds += 1
            if self.consecutive_cooperation_rounds >= 2:
                self.previous_stock = current_stock
                return Action.C
            self.previous_stock = current_stock
            return Action.C
        if defection_rate >= 1.0:
            self.previous_stock = current_stock
            return Action.D
        if defection_rate > 0.0:
            self.consecutive_cooperation_rounds = 0
        if stock_ratio < 0.3:
            self.previous_stock = current_stock
            return Action.D
        if stock_ratio < 0.5 and defection_rate > 0.4:
            self.previous_stock = current_stock
            return Action.D
        if stock_momentum < -0.15 and defection_rate > 0.25:
            self.previous_stock = current_stock
            return Action.D
        if rounds_remaining <= 2:
            self.previous_stock = current_stock
            return Action.D
        if stock_ratio > 0.7 and defection_rate < 0.3:
            self.previous_stock = current_stock
            return Action.C
        if stock_ratio >= 0.5 and defection_rate <= 0.4:
            self.previous_stock = current_stock
            return Action.C
        self.previous_stock = current_stock
        return Action.D

class Strategy_COLLECTIVE_168(BaseStrategy):
    """
    Collective Adaptive Resource Stewardship (CARS) Strategy
    
    Manages common pool consumption based on stock levels relative to capacity.
    Cooperates when stock is healthy, defects when stock is critically depleted,
    balancing individual payoff security with system sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_rounds
        self.threshold_upper = 0.85 * self.capacity
        self.threshold_middle = 0.65 * self.capacity
        self.threshold_lower = 0.4 * self.capacity
        self.threshold_critical = 0.1 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock = state.current_stock
        if stock < self.threshold_critical:
            return Action.D
        if stock >= self.threshold_upper:
            return Action.C
        elif stock >= self.threshold_middle:
            return Action.C
        elif stock >= self.threshold_lower:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_169(BaseStrategy):
    """
    Adaptive Stock-Preserving Equilibrium (ASPE):
    A collective strategy that balances sustainability and rational self-interest
    by conditioning cooperation on stock health and adapting to observed opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_safe = 0.6
        self.threshold_critical = 0.3
        self.threshold_middle = 0.45
        self.threshold_survival = 0.15
        self.threshold_last_round = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        capacity = self.capacity
        n = self.n_players
        if capacity > 0:
            stock_ratio = current_stock / capacity
        else:
            stock_ratio = 0.0
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            if stock_ratio >= self.threshold_last_round:
                return Action.D
            else:
                return Action.C
        if stock_ratio < self.threshold_survival:
            return Action.D
        if stock_ratio >= self.threshold_safe:
            return Action.C
        if stock_ratio < self.threshold_critical:
            return Action.D
        recent_defection_rate = self._calculate_recent_defection_rate(history, round_number)
        if recent_defection_rate <= 0.25:
            return Action.C
        if recent_defection_rate >= 0.75:
            return Action.D
        if stock_ratio >= self.threshold_middle:
            return Action.C
        else:
            return Action.D

    def _calculate_recent_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the defection rate of opponents in the last 2-3 rounds.
        Returns a rate between 0.0 and 1.0.
        """
        if history is None or round_number == 0:
            return 0.0
        lookback_rounds = min(3, round_number)
        start_round = max(0, round_number - lookback_rounds)
        total_opponent_actions = 0
        total_defections = 0
        for round_idx in range(start_round, round_number):
            opponent_round_actions = history.opponent_actions[round_idx, :]
            defectors_this_round = np.sum(~opponent_round_actions)
            total_defections += defectors_this_round
            total_opponent_actions += len(opponent_round_actions)
        if total_opponent_actions == 0:
            return 0.0
        defection_rate = total_defections / total_opponent_actions
        return defection_rate

class Strategy_COLLECTIVE_170(BaseStrategy):
    """
    Adaptive Stock-Preserving Cooperation (ASPC): A conditional cooperation strategy
    that balances individual payoff maximization with collective resource sustainability.
    
    Core logic:
    - Cooperate when stock is abundant (ratio > 0.70)
    - Defect when stock is critically depleted (ratio < 0.20)
    - In the middle zone, adapt based on opponent behavior and stock health
    - Special handling for first round, last round, and critical depletion scenarios
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_upper = 0.7
        self.threshold_lower = 0.2
        self.critical_depletion_threshold = 0.15
        self.last_round_threshold = 0.4
        self.high_defection_threshold = 0.6
        self.medium_high_defection_threshold = 0.4
        self.medium_low_defection_threshold = 0.2
        self.defection_prob_high = 0.8
        self.defection_prob_medium_high = 0.4
        self.defection_prob_medium_low = 0.15
        self.defection_prob_low = 0.05
        self.critical_cooperation_prob = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio < self.critical_depletion_threshold:
            if random.random() < self.critical_cooperation_prob:
                return Action.C
            else:
                return Action.D
        if round_number == self.n_rounds - 1:
            if stock_ratio > self.last_round_threshold:
                return Action.C
            else:
                return Action.D
        if stock_ratio > self.threshold_upper:
            return Action.C
        elif stock_ratio < self.threshold_lower:
            return Action.D
        else:
            opponent_defection_rate = self._calculate_opponent_defection_rate(history, round_number)
            defection_probability = self._get_defection_probability(opponent_defection_rate)
            if random.random() < defection_probability:
                return Action.D
            else:
                return Action.C

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the average defection rate of opponents over recent rounds.
        Uses a sliding window of the last min(5, rounds_elapsed) rounds.
        """
        if round_number == 0:
            return 0.0
        window_size = min(5, round_number)
        start_idx = round_number - window_size
        recent_opponent_actions = history.opponent_actions[start_idx:round_number, :]
        total_actions = recent_opponent_actions.size
        cooperations = np.sum(recent_opponent_actions)
        defections = total_actions - cooperations
        if total_actions == 0:
            return 0.0
        defection_rate = defections / total_actions
        return defection_rate

    def _get_defection_probability(self, opponent_defection_rate: float) -> float:
        """
        Return the defection probability based on opponent's observed defection rate.
        """
        if opponent_defection_rate > self.high_defection_threshold:
            return self.defection_prob_high
        elif opponent_defection_rate > self.medium_high_defection_threshold:
            return self.defection_prob_medium_high
        elif opponent_defection_rate > self.medium_low_defection_threshold:
            return self.defection_prob_medium_low
        else:
            return self.defection_prob_low

class Strategy_COLLECTIVE_171(BaseStrategy):
    """
    Adaptive Stewardship with Resilient Defection Detection.
    
    Balances collective resource preservation with robust self-defense against exploitation.
    Uses observable history to distinguish cooperative players from exploiters, maintaining
    a bias toward cooperation that benefits everyone while protecting against tragedy of commons.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_stock = state.current_stock
            return Action.C
        stock_worsening = state.current_stock < self.previous_stock
        self.previous_stock = state.current_stock
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock <= self.game_description.capacity * 0.1:
                return Action.C
            else:
                return Action.D
        defections_observed = 0
        total_actions_observed = 0
        for round_idx in range(state.round_number):
            for player_idx in range(self.game_description.n_players - 1):
                if not history.opponent_actions[round_idx, player_idx]:
                    defections_observed += 1
                total_actions_observed += 1
        defection_rate = 0.0
        if total_actions_observed > 0:
            defection_rate = defections_observed / total_actions_observed
        if state.current_stock <= self.game_description.capacity * 0.25:
            return Action.D
        if state.current_stock <= self.game_description.capacity * 0.5:
            if defection_rate > 0.4 or stock_worsening:
                return Action.D
            else:
                return Action.C
        if defection_rate > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_172(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Maintains stock health by cooperating when resource is abundant and majority
    doesn't defect, while defecting strategically to prevent resource collapse
    and punish overexploitation. Uses stock-level thresholds, defection counts,
    and trend analysis to adapt dynamically.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_threshold = math.ceil(self.n / 2)
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        self.stock_history.append(current_stock)
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            if current_stock > 0.5 * self.capacity:
                return Action.C
            else:
                return Action.D
        if current_stock <= 0.5 * self.capacity:
            return Action.D
        prev_round_defectors = self._count_defectors(history, round_num - 1)
        stock_trend = self._calculate_stock_trend(round_num)
        if prev_round_defectors > self.defection_threshold:
            return Action.D
        elif stock_trend >= 0:
            return Action.C
        elif current_stock > 0.65 * self.capacity:
            return Action.C
        else:
            return Action.D

    def _count_defectors(self, history: PlayerHistory, round_idx: int) -> int:
        """Count how many opponents defected in the given round."""
        if round_idx < 0 or round_idx >= history.opponent_actions.shape[0]:
            return 0
        defections = np.sum(history.opponent_actions[round_idx, :] == False)
        return int(defections)

    def _calculate_stock_trend(self, round_num: int) -> float:
        """
        Calculate stock trend: current - previous.
        Returns 0 if insufficient history.
        """
        if round_num < 1 or len(self.stock_history) < 2:
            return 0.0
        current = self.stock_history[round_num]
        previous = self.stock_history[round_num - 1]
        return current - previous

class Strategy_COLLECTIVE_173(BaseStrategy):
    """
    Adaptive Collective Strategy: Dynamic Sustainability Threshold (DST)
    
    Balances individual gain with collective sustainability by dynamically adjusting
    cooperation based on stock health and time horizon. Cooperates early to preserve
    the commons, but becomes pragmatic as stock depletes or final rounds approach.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        elapsed_rounds = round_number
        total_rounds = self.n_rounds
        if round_number == total_rounds - 1:
            threshold_final = 2.0 * self.capacity / self.n_players
            if current_stock > threshold_final:
                return Action.C
            else:
                return Action.D
        ratio = elapsed_rounds / total_rounds
        base_threshold = self.capacity * (1.0 - ratio ** 2)
        adjusted_threshold = base_threshold
        if history is not None and round_number > 0:
            total_opponent_actions = history.opponent_actions[:round_number, :]
            total_cooperations = np.sum(total_opponent_actions)
            total_possible_actions = round_number * self.n_players
            if total_possible_actions > 0:
                observed_defection_rate = 1.0 - total_cooperations / total_possible_actions
                if observed_defection_rate > 0.6:
                    adjusted_threshold = base_threshold * 0.85
                elif observed_defection_rate < 0.2:
                    adjusted_threshold = base_threshold * 1.1
        if current_stock < adjusted_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_174(BaseStrategy):
    """
    Adaptive Sustainable Yield Strategy (ASYS) - A threshold-based, state-dependent strategy
    for common pool resource management that cooperates when resources are abundant,
    maintains cooperation during recovery phases, and switches to defection only when
    critically endangered.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.upper_threshold = 0.75 * self.capacity
        self.lower_threshold = 0.3 * self.capacity
        self.emergency_threshold = 0.1 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        stock = state.current_stock
        if round_number == 0:
            return Action.C
        if stock >= self.upper_threshold:
            return Action.C
        elif stock >= self.lower_threshold:
            return Action.C
        elif stock >= self.emergency_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_175(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Response: A collective strategy that prioritizes
    long-term resource sustainability through stock-dependent cooperation, with adaptive
    memory and edge-case collapse prevention.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_low = 0.4 * self.capacity
        self.threshold_high = 0.75 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if stock <= 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            if stock > 0.4 * self.capacity:
                return Action.C
            else:
                return Action.D
        self._update_thresholds(history, round_num)
        if stock > self.threshold_high:
            return Action.C
        elif stock >= self.threshold_low:
            prob_cooperate = (stock - self.threshold_low) / (self.threshold_high - self.threshold_low)
            if random.random() < prob_cooperate:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _update_thresholds(self, history: PlayerHistory, round_num: int) -> None:
        """
        Adjust cooperation thresholds based on observed stock trajectory.
        """
        if round_num < 3:
            return
        recent_rounds = min(3, round_num)
        recent_stock_levels = self._infer_stock_levels(history, round_num, recent_rounds)
        if len(recent_stock_levels) >= 2:
            is_declining = all((recent_stock_levels[i] > recent_stock_levels[i + 1] for i in range(len(recent_stock_levels) - 1)))
            is_positive = all((recent_stock_levels[i] <= recent_stock_levels[i + 1] for i in range(len(recent_stock_levels) - 1)))
            if is_declining:
                self.threshold_low = min(self.threshold_low + 0.05 * self.capacity, 0.5 * self.capacity)
                self.threshold_high = min(self.threshold_high + 0.05 * self.capacity, 0.85 * self.capacity)
            elif is_positive:
                self.threshold_low = max(self.threshold_low - 0.02 * self.capacity, 0.3 * self.capacity)
                self.threshold_high = min(self.threshold_high + 0.02 * self.capacity, 0.8 * self.capacity)

    def _infer_stock_levels(self, history: PlayerHistory, round_num: int, recent_rounds: int) -> list:
        """
        Infer stock levels from recent payoff history.
        In round t with stock S:
        - If action is C: payoff = S / (2n)
        - If action is D: payoff = S / n
        We can reverse-engineer S from payoff and action.
        """
        stock_levels = []
        for i in range(max(0, round_num - recent_rounds), round_num):
            my_action = history.my_actions[i]
            my_payoff = history.my_payoffs[i]
            if my_payoff <= 0:
                inferred_stock = 0
            elif my_action:
                inferred_stock = my_payoff * 2 * self.n_players
            else:
                inferred_stock = my_payoff * self.n_players
            stock_levels.append(inferred_stock)
        return stock_levels

class Strategy_COLLECTIVE_176(BaseStrategy):
    """
    Collective Adaptive Resource Stewardship (CARS) Strategy
    
    Balances individual payoff maximization with collective welfare by using
    stock-conditional cooperation. Cooperates when the common pool is healthy
    (≥50% capacity), defects when depleted (<50%), with special handling for
    endgame and recovery phases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number
        if self.capacity <= 0:
            return Action.C
        health_ratio = current_stock / self.capacity
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            if health_ratio > 0.3:
                return Action.C
            else:
                return Action.D
        if health_ratio >= 0.5:
            return Action.C
        elif health_ratio >= 0.3:
            if rounds_remaining > self.n_rounds / 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_177(BaseStrategy):
    """
    Adaptive Stewardship with Contingent Escalation
    
    A collective strategy for the Common Pool Resource Game that:
    1. Preserves the resource through stock-health responsive cooperation
    2. Adapts dynamically to opponent defection rates
    3. Escalates strategically when sustainability is threatened
    4. Remains robust against exploitation while maintaining cooperation potential
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.collapse_defect_countdown = 0
        self.previous_stock = game_description.capacity
        self.was_critically_low = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_stock = state.current_stock
            return Action.C
        health_ratio = state.current_stock / self.game_description.capacity
        defection_rate = self._calculate_defection_rate(history)
        if self.previous_stock > 0:
            stock_drop_ratio = (self.previous_stock - state.current_stock) / self.previous_stock
            if stock_drop_ratio > 0.4:
                self.collapse_defect_countdown = 2
        self.previous_stock = state.current_stock
        if self.collapse_defect_countdown > 0:
            self.collapse_defect_countdown -= 1
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C if health_ratio >= 0.5 else Action.D
        if self.was_critically_low and health_ratio > 0.6:
            self.was_critically_low = False
            return Action.C
        if health_ratio < 0.25:
            self.was_critically_low = True
        if health_ratio >= 0.7:
            return Action.C
        if 0.4 <= health_ratio < 0.7:
            if defection_rate <= 0.25:
                return Action.C
            else:
                return Action.D
        if health_ratio < 0.4:
            if health_ratio < 0.15:
                return Action.D
            elif defection_rate <= 0.3:
                return Action.C
            else:
                return Action.D
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the defection rate from opponent actions.
        
        Returns a value between 0 and 1 representing the proportion of
        observed opponent defections.
        """
        if history.opponent_actions.size == 0:
            return 0.0
        total_defections = np.sum(history.opponent_actions == False)
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.0
        return float(total_defections) / float(total_actions)

class Strategy_COLLECTIVE_178(BaseStrategy):
    """
    Adaptive Sustainable Harvest Strategy (ASHS)
    
    Prioritizes long-term collective sustainability over short-term individual gain.
    Uses stock-health-based thresholds to decide between cooperation and defection,
    with adaptive adjustments based on observed defection rates and stock trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.base_cooperation_threshold = 0.75 * self.capacity
        self.critical_threshold = 0.3 * self.capacity
        self.min_threshold = 0.5 * self.capacity
        self.current_cooperation_threshold = self.base_cooperation_threshold
        self.stock_history = []
        self.defection_rate_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        self.stock_history.append(current_stock)
        if current_round == 0:
            return Action.C
        prev_round_idx = current_round - 1
        n_defectors_prev = np.sum(~history.opponent_actions[prev_round_idx, :])
        defection_rate = n_defectors_prev / self.n_players
        self.defection_rate_history.append(defection_rate)
        if 3 < current_round < self.n_rounds - 1:
            if len(self.stock_history) >= 2:
                recent_low_count = sum((1 for s in self.stock_history[-2:] if s < self.current_cooperation_threshold))
                if recent_low_count >= 2:
                    self.current_cooperation_threshold = max(self.min_threshold, self.current_cooperation_threshold - 0.1 * self.capacity)
            if defection_rate > 0.5:
                self.current_cooperation_threshold = max(self.min_threshold, self.current_cooperation_threshold - 0.05 * self.capacity)
        if len(self.stock_history) >= 2:
            stock_decline_rate = (self.stock_history[-2] - self.stock_history[-1]) / max(self.stock_history[-2], 1e-06)
            if stock_decline_rate > 0.2:
                if current_round < self.n_rounds - 2:
                    return Action.D
        if current_round == self.n_rounds - 1:
            if current_stock > self.critical_threshold:
                return Action.D
            else:
                return Action.D
        if current_stock == 0:
            return Action.D
        if current_stock >= self.capacity:
            return Action.C
        if current_stock > self.current_cooperation_threshold:
            return Action.C
        elif current_stock > self.critical_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_179(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection.
    
    Balances individual rationality with collective welfare by:
    - Cooperating when resource is healthy and defection pressure is low
    - Defecting when resource depleted or others defect excessively
    - Recovering cooperation when conditions improve
    - Treating final round differently to avoid end-game collapse
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        total_opponent_actions = current_round * self.n_players
        total_defections = np.sum(~history.opponent_actions[:current_round, :])
        observed_defection_rate = total_defections / total_opponent_actions if total_opponent_actions > 0 else 0.5
        if current_round == self.n_rounds - 1:
            if current_stock >= 0.5 * self.capacity:
                return Action.C
            else:
                return Action.D
        threshold_stock = self.capacity * 0.6 + self.capacity * 0.4 * (1.0 - observed_defection_rate)
        expected_defection_rate = max(0.3, 0.5 - 0.02 * (current_round - 1))
        defection_pressure = observed_defection_rate - expected_defection_rate
        stock_health_ok = current_stock >= threshold_stock
        defection_pressure_ok = defection_pressure <= 0.35
        if stock_health_ok and defection_pressure_ok:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_182(BaseStrategy):
    """
    Adaptive Conservation with Degradation Monitoring
    
    Balances individual benefit-seeking with collective sustainability through
    conditional cooperation based on stock health and observed cooperation levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.degradation_threshold = self.capacity * 0.5
        self.critical_threshold = self.capacity * 0.3
        self.defection_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < self.critical_threshold:
            return Action.C
        stock_healthy = current_stock >= self.degradation_threshold
        last_round_cooperator_count = int(np.sum(history.opponent_actions[-1, :]))
        last_round_cooperator_fraction = last_round_cooperator_count / self.n_players
        sufficient_cooperation = last_round_cooperator_fraction >= self.defection_threshold
        if stock_healthy and sufficient_cooperation:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_183(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Response for Common Pool Resource Game.
    
    Balances personal benefit with system health by:
    1. Prioritizing stock preservation when health is critical
    2. Reciprocating opponent cooperation with graduated response
    3. Applying graduated punishment for excessive defection
    4. Treating the pool as a regenerating resource requiring collective stewardship
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 0.25
        self.low_stock_threshold = 0.5
        self.low_stock_coop_prob = 0.7
        self.cooperation_threshold_high = 0.6
        self.cooperation_threshold_low = 0.3
        self.early_game_coop_prob = 0.8
        self.recent_window = 5
        self.defection_pressure_limit = 3
        self.high_consumption_ratio = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        capacity = self.capacity
        if round_num == 0:
            return Action.C
        stock_health_ratio = current_stock / capacity if capacity > 0 else 0.0
        if stock_health_ratio < self.critical_threshold:
            return Action.C
        if round_num <= 2:
            if random.random() < self.early_game_coop_prob:
                return Action.C
            return Action.D
        if round_num == self.n_rounds - 1:
            if stock_health_ratio < 0.6:
                return Action.C
            else:
                defector_count = self._count_high_defectors(history, 0.4)
                if defector_count > self.n_players / 2:
                    return Action.D
                return self._apply_behavior_assessment(history, round_num)
        if stock_health_ratio < self.low_stock_threshold:
            if random.random() < self.low_stock_coop_prob:
                return Action.C
            return Action.D
        defection_pressure = self._calculate_defection_pressure(history, round_num)
        if defection_pressure > self.defection_pressure_limit:
            return Action.D
        return self._apply_behavior_assessment(history, round_num)

    def _apply_behavior_assessment(self, history: PlayerHistory, round_num: int) -> Action:
        """Apply Rules B and C: assess opponent cooperation and respond."""
        recent_coop_rate = self._calculate_recent_cooperation_rate(history, round_num)
        if recent_coop_rate > self.cooperation_threshold_high:
            return Action.C
        elif self.cooperation_threshold_low <= recent_coop_rate <= self.cooperation_threshold_high:
            return Action.D
        else:
            return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, round_num: int) -> float:
        """Calculate mean cooperation rate of all opponents in recent rounds."""
        if round_num == 0:
            return 0.0
        start_idx = max(0, round_num - self.recent_window)
        end_idx = round_num
        if end_idx <= start_idx:
            return 0.0
        recent_actions = history.opponent_actions[start_idx:end_idx, :]
        coop_count = np.sum(recent_actions)
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        return float(coop_count) / float(total_actions)

    def _count_high_defectors(self, history: PlayerHistory, defection_threshold: float) -> int:
        """Count opponents with cooperation rate below threshold."""
        if history.opponent_actions.shape[0] == 0:
            return 0
        defector_count = 0
        for opponent_idx in range(self.n_players - 1):
            opponent_coop_actions = np.sum(history.opponent_actions[:, opponent_idx])
            total_rounds = history.opponent_actions.shape[0]
            if total_rounds > 0:
                coop_rate = float(opponent_coop_actions) / float(total_rounds)
                if coop_rate < defection_threshold:
                    defector_count += 1
        return defector_count

    def _calculate_defection_pressure(self, history: PlayerHistory, round_num: int) -> int:
        """
        Calculate defection pressure: count consecutive rounds where 
        total group consumption exceeded 75% of stock.
        """
        if history.opponent_actions.shape[0] == 0:
            return 0
        consecutive_high_consumption = 0
        max_consecutive = 0
        for round_idx in range(history.opponent_actions.shape[0]):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx, :]
            total_consume_count = np.sum(opponent_actions)
            total_consume_count += int(not my_action)
            total_coop_count = self.n_players - int(total_consume_count)
            if total_consume_count > self.n_players / 2:
                consecutive_high_consumption += 1
                max_consecutive = max(max_consecutive, consecutive_high_consumption)
            else:
                consecutive_high_consumption = 0
        return max_consecutive

class Strategy_COLLECTIVE_184(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy that balances sustainability,
    reciprocity, and pragmatism by maintaining stock health above critical thresholds and
    adapting behavior based on community defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.C
        defection_count_last_round = self._count_defectors_last_round(history)
        if stock < 0.2 * self.capacity:
            if round_num <= self.n_rounds / 3 and defection_count_last_round == 0:
                return Action.C
            else:
                return Action.D
        if round_num == self.n_rounds - 1:
            defection_rate = defection_count_last_round / max(1, self.n_players - 1)
            max_defectors_allowed = 0.3 * (self.n_players - 1)
            if stock >= 0.5 * self.capacity and defection_count_last_round <= max_defectors_allowed:
                return Action.C
            else:
                return Action.D
        defection_rate = defection_count_last_round / max(1, self.n_players - 1)
        if stock >= 0.4 * self.capacity and defection_rate <= 0.5:
            return Action.C
        else:
            return Action.D

    def _count_defectors_last_round(self, history: PlayerHistory) -> int:
        """
        Count the number of opponents who defected in the last round.
        False (0) = Defect, True (1) = Cooperate
        Returns the count of defectors (players who played False).
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0
        last_round_actions = history.opponent_actions[-1, :]
        defectors = sum((1 for action in last_round_actions if not action))
        return defectors

class Strategy_COLLECTIVE_185(BaseStrategy):
    """
    Adaptive Commons Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual payoff maximization with collective resource sustainability
    by using stock level as primary decision signal, with secondary opponent adaptation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if current_stock < 0.15 * self.capacity:
            return Action.C
        if round_number == 0:
            return Action.C
        opponent_coop_rate = self._calculate_opponent_coop_rate(history)
        if opponent_coop_rate > 0.6:
            high_threshold = 0.75 * self.capacity
            low_threshold = 0.4 * self.capacity
        elif opponent_coop_rate < 0.3:
            high_threshold = 0.85 * self.capacity
            low_threshold = 0.45 * self.capacity
        else:
            high_threshold = 0.75 * self.capacity
            low_threshold = 0.42 * self.capacity
        if current_stock > high_threshold:
            return Action.C
        elif current_stock > low_threshold:
            threshold_range = high_threshold - low_threshold
            if threshold_range > 0:
                probability = (current_stock - low_threshold) / threshold_range
            else:
                probability = 0.5
            if random.random() < probability:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

    def _calculate_opponent_coop_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the average cooperation rate across all opponents.
        Returns value in [0, 1], or 0.5 if no history available.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.5
        total_cooperations = np.sum(history.opponent_actions)
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.5
        coop_rate = float(total_cooperations) / float(total_actions)
        return coop_rate

class Strategy_COLLECTIVE_186(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Sanctions for Common Pool Resources.
    
    Prioritizes long-term collective welfare by maintaining stock sustainability
    while responding adaptively to observed defection rates. Uses graduated escalation
    phases based on stock health and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_phase_rounds = 0
        self.min_punishment_duration = 2
        self.critical_threshold = 0.3
        self.escalation_threshold = 0.5
        self.recovery_threshold_shi = 0.7
        self.recovery_threshold_odr = 0.3
        self.collapse_threshold = 0.05
        self.emergency_rebuild_threshold = 0.15
        self.rolling_window = 5

    def _calculate_stock_health_indicator(self, stock: float) -> float:
        """SHI = stock / capacity. Returns fraction of maximum sustainability."""
        if self.capacity <= 0:
            return 0.0
        return stock / self.capacity

    def _calculate_rolling_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate observed defection rate over rolling window.
        ODR = total_defections_observed / total_possible_actions (excluding own actions)
        """
        if current_round == 0:
            return 0.0
        window_start = max(0, current_round - self.rolling_window)
        window_size = current_round - window_start
        if window_size <= 0:
            return 0.0
        opponent_actions_window = history.opponent_actions[window_start:current_round, :]
        defections = np.sum(opponent_actions_window == False)
        total_possible = opponent_actions_window.size
        if total_possible <= 0:
            return 0.0
        return float(defections) / float(total_possible)

    def _get_phase(self, shi: float, odr: float, punishment_phase_rounds: int) -> int:
        """
        Determine current phase based on stock health and defection rate.
        
        Phase 0: COOPERATION (Default)
        Phase 1: VIGILANCE (Early Warning)
        Phase 2: ESCALATED PUNISHMENT (Graduated Response)
        Phase 3: EMERGENCY REBUILD (Resource Crisis)
        """
        if shi < self.emergency_rebuild_threshold:
            return 3
        if odr >= self.escalation_threshold or shi < self.critical_threshold:
            return 2
        if 0.3 <= odr < self.escalation_threshold or self.critical_threshold <= shi <= 0.5:
            return 1
        return 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Main decision function for Adaptive Stewardship strategy.
        """
        if state.round_number == 0:
            self.punishment_phase_rounds = 0
            return Action.C
        shi = self._calculate_stock_health_indicator(state.current_stock)
        odr = self._calculate_rolling_defection_rate(history, state.round_number)
        rounds_left = self.n_rounds - state.round_number
        if shi < self.collapse_threshold:
            self.punishment_phase_rounds = 0
            return Action.C
        if state.round_number == self.n_rounds - 1:
            if shi > 0.6 and odr < 0.4:
                return Action.C
            else:
                return Action.D
        if state.round_number == self.n_rounds - 2:
            if shi < 0.2:
                return Action.D
            phase = self._get_phase(shi, odr, self.punishment_phase_rounds)
            if phase >= 2:
                return Action.D
            elif phase == 1:
                return Action.D if random.random() < 0.2 else Action.C
            else:
                return Action.C
        phase = self._get_phase(shi, odr, self.punishment_phase_rounds)
        if phase == 3:
            self.punishment_phase_rounds = 0
            return Action.C
        if phase == 2:
            self.punishment_phase_rounds += 1
            if self.punishment_phase_rounds >= self.min_punishment_duration and shi > self.recovery_threshold_shi and (odr < self.recovery_threshold_odr):
                self.punishment_phase_rounds = 0
                return Action.C
            return Action.D
        if phase == 2 and self.punishment_phase_rounds > 0:
            self.punishment_phase_rounds += 1
            return Action.D
        else:
            self.punishment_phase_rounds = 0
            return Action.C

class Strategy_COLLECTIVE_187(BaseStrategy):
    """
    Collective Pool Stewardship Strategy (CPSS)
    
    Prioritizes long-term collective sustainability over short-term individual gain.
    Cooperates generously with cooperators, responds to defectors, and monitors pool health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def _classify_stock_state(self, stock: float) -> str:
        """Classify current stock level into health categories."""
        if stock <= 0:
            return 'Collapsed'
        elif stock > 0.75 * self.capacity:
            return 'Abundant'
        elif stock > 0.5 * self.capacity:
            return 'Healthy'
        elif stock > 0.25 * self.capacity:
            return 'Stressed'
        else:
            return 'Critical'

    def _calculate_cooperator_ratio(self, history: PlayerHistory, round_number: int) -> float:
        """Calculate the ratio of players who cooperated in the previous round."""
        if round_number == 0:
            return 1.0
        prev_round_actions = history.opponent_actions[round_number - 1, :]
        cooperators = int(np.sum(prev_round_actions))
        return cooperators / self.n_players if self.n_players > 0 else 1.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decide action based on stock health, cooperator ratio, and round number.
        """
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_left = self.n_rounds - current_round
        if current_round == 0:
            return Action.C
        stock_state = self._classify_stock_state(current_stock)
        cooperator_ratio = self._calculate_cooperator_ratio(history, current_round)
        if rounds_left == 1:
            return Action.D
        if stock_state == 'Collapsed':
            return Action.D
        if stock_state in ('Stressed', 'Critical'):
            if stock_state == 'Critical' and cooperator_ratio < 0.5:
                return Action.D
            if cooperator_ratio >= 0.5:
                return Action.C
            else:
                return Action.D
        if stock_state in ('Healthy', 'Abundant'):
            if cooperator_ratio >= 0.5:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_188(BaseStrategy):
    """
    Adaptive Stewardship with Graceful Degradation.
    
    Treats the common pool as a shared resource requiring active stewardship.
    Uses conditional cooperation based on a dynamically declining danger threshold,
    detects exploitation patterns, and gracefully degrades to defensive posture
    when sustainability fails. Cooperates early, defects strategically in final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defensive_posture = False
        self.defection_count = 0
        self.total_observed_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.C
        if round_num == self.r - 1:
            if stock > 0:
                return Action.D
            else:
                return Action.C
        if stock < 2 * self.n:
            return Action.D
        if history is not None and len(history.my_actions) > 0:
            self.total_observed_rounds = len(history.my_actions)
            unsustainable_rounds = self._count_unsustainable_rounds(history)
            defection_ratio = unsustainable_rounds / max(1, self.total_observed_rounds)
            if defection_ratio > 0.5:
                self.defensive_posture = True
                return Action.D
            if defection_ratio > 0.3:
                return Action.D
            if self._last_n_rounds_at_capacity(history, 2):
                self.defensive_posture = False
                return Action.C
        if self.defensive_posture:
            return Action.D
        rounds_remaining = self.r - round_num
        stock_danger_threshold = 2 * self.n + (self.capacity - 2 * self.n) * (rounds_remaining / self.r)
        if stock > stock_danger_threshold:
            return Action.C
        else:
            return Action.D

    def _count_unsustainable_rounds(self, history: PlayerHistory) -> int:
        """
        Count rounds where aggregate extraction exceeded sustainable level.
        Sustainable level for a round with stock S is S / (2*n) per player.
        """
        count = 0
        for round_idx in range(len(history.my_actions)):
            my_action = history.my_actions[round_idx]
            my_payoff = history.my_payoffs[round_idx]
            if my_action:
                round_stock = my_payoff * 2 * self.n
            else:
                round_stock = my_payoff * self.n
            sustainable_extraction = round_stock / 2.0
            actual_extraction = my_payoff + np.sum(history.opponent_payoffs[round_idx])
            if actual_extraction > sustainable_extraction + 1e-09:
                count += 1
        return count

    def _last_n_rounds_at_capacity(self, history: PlayerHistory, n: int) -> bool:
        """
        Check if the last n rounds showed stock recovery to capacity.
        We infer stock level from the payoffs and actions.
        """
        if len(history.my_actions) < n:
            return False
        for round_idx in range(len(history.my_actions) - n, len(history.my_actions)):
            my_action = history.my_actions[round_idx]
            my_payoff = history.my_payoffs[round_idx]
            if my_action:
                round_stock = my_payoff * 2 * self.n
            else:
                round_stock = my_payoff * self.n
            if round_stock < self.capacity - 1e-06:
                return False
        return True

class Strategy_COLLECTIVE_189(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS) for Common Pool Resource Game.
    
    Balances individual payoff maximization with collective resource sustainability.
    Adapts to observed cooperation levels while maintaining commitment to resource preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.consecutive_shrink_rounds = 0
        self.chi_threshold_high = 0.75
        self.chi_threshold_low = 0.4
        self.stock_healthy_threshold = 0.6
        self.stock_critical_threshold = 0.4
        self.stock_collapse_threshold = 0.1
        self.perfect_coop_lock = False
        self.perfect_coop_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        return self._adaptive_decision(state, history)

    def _adaptive_decision(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if current_stock < self.capacity * self.stock_collapse_threshold:
            return Action.C
        if self.perfect_coop_lock:
            return Action.C
        prev_round_idx = round_num - 1
        cooperators_prev = np.sum(history.opponent_actions[prev_round_idx, :])
        chi = cooperators_prev / self.n_players
        if chi == 1.0:
            self.perfect_coop_rounds += 1
            if self.perfect_coop_rounds >= 3:
                self.perfect_coop_lock = True
                return Action.C
        else:
            self.perfect_coop_rounds = 0
        if round_num >= 2:
            prev_prev_stock = self._estimate_stock_at_round(history, round_num - 2)
            if prev_prev_stock is not None and prev_prev_stock > current_stock:
                self.consecutive_shrink_rounds += 1
                if self.consecutive_shrink_rounds >= 2:
                    self.chi_threshold_high = 0.5
            else:
                self.consecutive_shrink_rounds = 0
        if chi >= self.chi_threshold_high:
            return Action.C
        elif chi > self.chi_threshold_low:
            if current_stock > self.capacity * self.stock_healthy_threshold:
                return Action.C
            else:
                return Action.D
        elif current_stock > self.capacity * self.stock_critical_threshold:
            return Action.D
        else:
            return Action.C

    def _estimate_stock_at_round(self, history: PlayerHistory, target_round: int) -> float | None:
        """
        Estimate stock level at a given round by reconstructing from initial state.
        Returns None if estimate is not reliable.
        """
        if target_round < 0 or target_round >= len(history.my_actions):
            return None
        stock = float(self.capacity)
        for round_idx in range(target_round + 1):
            my_action = 1 if history.my_actions[round_idx] else 0
            opponent_actions = np.sum(history.opponent_actions[round_idx, :])
            total_cooperators = my_action + opponent_actions
            c_consumption = stock / (2 * self.n_players)
            d_consumption = stock / self.n_players
            total_consumption = total_cooperators * c_consumption + (self.n_players - total_cooperators) * d_consumption
            stock_after = stock - total_consumption
            stock_after = max(0.0, stock_after)
            if stock_after > 0:
                growth = 2 * stock_after * (1 - stock_after / self.capacity)
            else:
                growth = 0.0
            stock = min(stock_after + growth, float(self.capacity))
        return stock

class Strategy_COLLECTIVE_190(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy that cooperates when the common pool
    is healthy, punishes systematic defection, and rationally defects when the pool is depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.sustainable_threshold = game_description.capacity * 0.4
        self.critical_threshold = game_description.capacity * 0.1
        self.healthy_threshold = game_description.capacity * 0.6
        self.mid_healthy_threshold = game_description.capacity * 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock = state.current_stock
        rounds_remaining = self.game_description.n_rounds - state.round_number
        n_players = self.game_description.n_players
        if stock < self.critical_threshold:
            return Action.D
        if rounds_remaining == 1:
            if stock > self.healthy_threshold:
                return Action.D
            else:
                return Action.C
        if stock <= self.sustainable_threshold:
            return Action.D
        if stock > self.sustainable_threshold:
            defection_rate = self._calculate_defection_rate(history, n_players)
            if defection_rate > 0.25:
                if stock > self.mid_healthy_threshold:
                    punishment_prob = min(0.4, defection_rate - 0.15)
                    if random.random() < punishment_prob:
                        return Action.D
                return Action.C
            else:
                return Action.C
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, n_players: int) -> float:
        """
        Calculate the defection rate as: (total defections by all players) / 
        (total possible defections in history)
        
        True = Cooperate (C), False = Defect (D)
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        n_rounds_history = len(history.opponent_actions)
        total_defections = 0
        for round_idx in range(n_rounds_history):
            for player_idx in range(n_players - 1):
                if not history.opponent_actions[round_idx, player_idx]:
                    total_defections += 1
        for action in history.my_actions:
            if not action:
                total_defections += 1
        total_possible = n_rounds_history * n_players
        if total_possible == 0:
            return 0.0
        return total_defections / total_possible

class Strategy_COLLECTIVE_191(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Sanctions for Common Pool Resource Game.
    
    Uses stock health as primary signal, supplemented by observed defection rates
    and round position to decide between cooperation and defection. Balances
    long-term sustainability with protection against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_health = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_health > 0.75:
            return Action.C
        if stock_health > 0.5:
            return Action.C
        if stock_health > 0.25:
            previous_round_idx = state.round_number - 1
            defectors_count = sum((1 for action in history.opponent_actions[previous_round_idx, :] if not action))
            defection_rate = defectors_count / self.n_players if self.n_players > 0 else 0.0
            mid_game_threshold = self.n_rounds / 2
            is_mid_game = state.round_number >= mid_game_threshold
            high_defection_threshold = 0.35 if is_mid_game else 0.5
            medium_defection_threshold = 0.25 if not is_mid_game else 0.2
            if defection_rate > high_defection_threshold:
                return Action.D
            elif defection_rate > medium_defection_threshold:
                return Action.D
            else:
                return Action.C
        if stock_health <= 0.25:
            if state.round_number == self.n_rounds - 1:
                if stock_health >= 0.5:
                    return Action.C
                else:
                    return Action.D
            if stock_health <= 0.1:
                return Action.D
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_192(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collectively rational strategy for common pool resource games.
    
    Monitors stock health and adapts cooperation based on:
    1. Current stock ratio relative to capacity (primary rule)
    2. Observed defection rates among opponents (secondary rule)
    3. Round position in the game (tertiary rule)
    
    Core insight: sustainable extraction maximizes long-term payoff by preserving pool viability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        defection_rate = self._calculate_defection_rate(history, round_number)
        phase = self._determine_phase(round_number)
        if health_ratio >= 0.5:
            return Action.C
        elif 0.25 <= health_ratio < 0.5:
            if defection_rate > 0.4:
                return Action.D
            else:
                return Action.C
        elif health_ratio < 0.25:
            return Action.D
        if phase == 'late':
            if health_ratio >= 0.6 and defection_rate <= 0.3:
                return Action.C
            elif health_ratio < 0.3 or defection_rate > 0.5:
                return Action.D
        if defection_rate > 0.7:
            return Action.D
        if defection_rate == 0.0 and round_number > 0:
            return Action.C
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate cumulative defection rate based on rounds where majority of opponents defected.
        Returns a value between 0.0 and 1.0.
        """
        if round_number == 0:
            return 0.0
        total_previous_rounds = round_number
        defections_observed = 0
        for round_idx in range(total_previous_rounds):
            opponent_actions_in_round = history.opponent_actions[round_idx, :]
            cooperators = np.sum(opponent_actions_in_round)
            defectors = len(opponent_actions_in_round) - cooperators
            if defectors > cooperators:
                defections_observed += 1
        defection_rate = defections_observed / total_previous_rounds
        return defection_rate

    def _determine_phase(self, round_number: int) -> str:
        """
        Determine the phase of the game: early, middle, or late.
        """
        early_threshold = self.n_rounds / 3
        late_threshold = 2 * self.n_rounds / 3
        if round_number <= early_threshold:
            return 'early'
        elif round_number <= late_threshold:
            return 'middle'
        else:
            return 'late'

class Strategy_COLLECTIVE_193(BaseStrategy):
    """
    Adaptive Stewardship with Defection Deterrence: A stock-conditional cooperation strategy
    that balances individual security with collective sustainability in common pool resource games.
    
    Core mechanism: Cooperate when stock is healthy (≥60% capacity), defect when depleted (<60%),
    with adaptive adjustments based on observed cooperation rates in the group.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        sustainability_threshold = self.capacity * 0.6
        critical_threshold = self.capacity * 0.2
        if round_number == 0:
            return Action.C
        total_c_actions = 0
        total_actions = 0
        if history is not None:
            total_c_actions = np.sum(history.opponent_actions)
            total_c_actions += np.sum(history.my_actions)
            total_actions = self.n_players * round_number
        cooperation_rate = total_c_actions / total_actions if total_actions > 0 else 0.0
        if current_stock >= sustainability_threshold:
            if cooperation_rate >= 0.7:
                return Action.C
            else:
                return Action.C
        elif current_stock > critical_threshold:
            if cooperation_rate >= 0.7:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_194(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Response: A threshold-based collective strategy
    that prioritizes long-term sustainability by adapting actions based on stock health phases.
    
    - Abundance Phase (≥75%): Cooperate (resource can sustain)
    - Stability Phase (50-75%): Cooperate (protect resource)
    - Decline Phase (25-50%): Defect if others defected, else cooperate (conditional matching)
    - Critical Phase (<25%): Cooperate (recovery requires restraint)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if self.capacity <= 0:
            stock_health_ratio = 0.0
        else:
            stock_health_ratio = current_stock / self.capacity
        if stock_health_ratio >= 0.75:
            return Action.C
        elif stock_health_ratio >= 0.5:
            return Action.C
        elif stock_health_ratio >= 0.25:
            if history is None or round_number == 0:
                return Action.C
            else:
                last_round_actions = history.opponent_actions[-1, :]
                num_defectors = np.sum(last_round_actions == False)
                if num_defectors > 0:
                    return Action.D
                else:
                    return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_195(BaseStrategy):
    """
    Adaptive Commons Stewardship Strategy
    
    Balances individual payoff maximization with collective resource sustainability.
    Cooperates when commons is healthy, defects strategically when stock is depleted
    or others are defecting, and always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0
        rounds_remaining = self.n_rounds - round_number - 1
        recent_defection_rate = self._calculate_recent_defection_rate(history, round_number)
        if round_number == self.n_rounds - 1:
            return Action.D
        if stock_ratio < 0.1:
            return Action.D
        if stock_ratio < 0.3 and recent_defection_rate > 0.5:
            return Action.D
        if stock_ratio < 0.5 and recent_defection_rate > 0.25:
            return Action.D
        if stock_ratio >= 0.6:
            if recent_defection_rate <= 0.25:
                return Action.C
            elif rounds_remaining <= 2:
                return Action.D
            else:
                return Action.C
        if 0.5 <= stock_ratio < 0.6:
            if recent_defection_rate == 0:
                return Action.C
            elif recent_defection_rate > 0.5:
                return Action.D
            elif rounds_remaining <= 3:
                return Action.D
            else:
                return Action.C
        return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the fraction of opponents who defected in the last 2 rounds.
        Returns a value between 0 and 1.
        """
        if round_number == 0:
            return 0.0
        rounds_to_check = min(2, round_number)
        start_idx = round_number - rounds_to_check
        recent_actions = history.opponent_actions[start_idx:round_number, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        defection_count = total_actions - np.sum(recent_actions)
        defection_rate = float(defection_count) / float(total_actions)
        return defection_rate

class Strategy_COLLECTIVE_196(BaseStrategy):
    """
    Adaptive Stewardship with Decay Detection: A collective strategy that prioritizes
    long-term resource sustainability while remaining robust to exploitation.
    
    Core behaviors:
    - Round 1: Cooperate (establish good faith baseline)
    - Critical depletion (stock < 15% capacity): Cooperate (last stand)
    - Abundant resources (stock > 95% capacity): Cooperate (low-cost sustainability)
    - High depletion urgency (>80% consumed): Cooperate (prioritize recovery)
    - Recent cooperation high (>60%) AND healthy stock (>50%): Cooperate
    - Recent cooperation low (<30%) OR sharp decline (>65% consumed): Defect
    - Mid-game ambiguity (round < 70% of total): Cooperate (patience)
    - Late-game ambiguity (round >= 70% of total): Defect (extract value)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.capacity
        depletion_ratio = 1.0 - stock_ratio
        if stock_ratio <= 0.15:
            return Action.C
        if stock_ratio > 0.95:
            return Action.C
        if depletion_ratio > 0.8:
            return Action.C
        k = max(3, min(5, self.n_rounds // 4))
        recent_cooperation_rate = self._calculate_recent_cooperation_rate(history, k)
        if recent_cooperation_rate > 0.6 and stock_ratio > 0.5:
            return Action.C
        if recent_cooperation_rate < 0.3 or depletion_ratio > 0.65:
            return Action.D
        progress_ratio = state.round_number / self.n_rounds
        if progress_ratio < 0.7:
            return Action.C
        else:
            return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, k: int) -> float:
        """
        Calculate the rate at which recent rounds showed stock recovery.
        
        A "recovery" is detected by comparing stock states across consecutive rounds.
        Higher recovery indicates others are cooperating; lower indicates defection.
        
        We infer cooperation from the payoff pattern: if players received low payoffs
        in recent rounds (stock depletion), recovery rate is low. If opponents collectively
        managed to maintain/grow stock, we assume cooperation.
        
        Simplified heuristic: Use opponent action history directly.
        Count rounds where opponent cooperation was predominant.
        """
        start_idx = max(0, len(history.my_actions) - k)
        recent_rounds = len(history.my_actions) - start_idx
        if recent_rounds == 0:
            return 0.5
        recovery_count = 0
        for round_idx in range(start_idx, len(history.my_actions)):
            opponent_cooperators = np.sum(history.opponent_actions[round_idx, :])
            if opponent_cooperators > self.n_players / 2.0:
                recovery_count += 1
        cooperation_rate = recovery_count / recent_rounds
        return cooperation_rate

class Strategy_COLLECTIVE_197(BaseStrategy):
    """
    Adaptive Commons Stewardship Strategy (ACS)
    
    Balances individual reward-seeking with collective sustainability by:
    1. Starting with cooperation to establish benevolence
    2. Adapting to pool health and observed defection rates
    3. Using reciprocal defection to punish overexploitation
    4. Defecting in final round when cooperation cannot carry forward
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        health_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        if health_ratio >= 0.6:
            pool_status = 'healthy'
        elif health_ratio >= 0.3:
            pool_status = 'stressed'
        else:
            pool_status = 'critical'
        recent_window_size = min(3, round_num)
        recent_defections = 0
        for i in range(round_num - recent_window_size, round_num):
            for opponent_action in history.opponent_actions[i, :]:
                if not opponent_action:
                    recent_defections += 1
        total_recent_actions = recent_window_size * self.n_players
        defection_ratio = recent_defections / total_recent_actions if total_recent_actions > 0 else 0.0
        expected_defection_ratio = 1.0 / self.n_players
        exploitation_index = defection_ratio - expected_defection_ratio
        if pool_status == 'healthy':
            if exploitation_index <= 0.15:
                return Action.C
            else:
                return Action.D
        elif pool_status == 'stressed':
            if defection_ratio > 0.4:
                return Action.D
            else:
                return Action.C
        else:
            last_round_defectors = sum((1 for action in history.opponent_actions[round_num - 1, :] if not action))
            if last_round_defectors == self.n_players - 1:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_198(BaseStrategy):
    """
    Collective Adaptive Pool Management Strategy
    
    Prioritizes sustainable collective welfare through stock-based conditional cooperation.
    Starts cooperatively, adapts based on stock health and depletion pressure, and defects
    in the final round or under critical stock conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            if current_stock > 0:
                return Action.D
            else:
                return Action.C
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        depletion_pressure = (self.capacity - current_stock) / self.capacity if self.capacity > 0 else 0.0
        if stock_health >= 0.6:
            return Action.C
        elif stock_health >= 0.4:
            if depletion_pressure < 0.3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_199(BaseStrategy):
    """
    Adaptive Stock-Preserving Cooperation (ASPC) Strategy
    
    Prioritizes collective long-term welfare through conditional cooperation,
    stock-aware adaptation, and graceful degradation when resources are depleted.
    Uses a four-tier framework: stock health assessment, defection rate calculation,
    cooperative pressure index, and adaptive decision logic.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        defection_rate = self._calculate_defection_rate(history, current_round)
        cooperative_pressure = defection_rate * (1.0 - stock_health)
        if stock_health < 0.2 and current_round < self.n_rounds - 1:
            return Action.D
        if cooperative_pressure > 0.3:
            return Action.D
        if current_round == self.n_rounds - 1:
            if stock_health >= 0.3:
                return Action.C
            else:
                return Action.D
        if current_round == self.n_rounds - 2:
            if stock_health >= 0.5 and defection_rate <= 0.4:
                return Action.C
        if stock_health >= 0.6 and defection_rate <= 0.4:
            return Action.C
        if 0.4 <= stock_health < 0.6 and defection_rate <= 0.25:
            return Action.C
        if 0.2 <= stock_health < 0.4 and defection_rate <= 0.15:
            return Action.C
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate empirical defection rate from opponent actions in history.
        
        Defection rate = (total defections observed) / (n * rounds_elapsed)
        where defection is represented as False/0 in opponent_actions
        """
        if current_round == 0:
            return 0.0
        opponent_actions_so_far = history.opponent_actions[:current_round, :]
        total_defections = np.sum(opponent_actions_so_far == False)
        rounds_elapsed = current_round
        total_possible = self.n_players * rounds_elapsed
        if total_possible == 0:
            return 0.0
        defection_rate = float(total_defections) / float(total_possible)
        return defection_rate

class Strategy_COLLECTIVE_200(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Games.
    
    Core philosophy: Conditional cooperation with sustainability guardrails.
    Cooperates when stock is healthy and others mostly cooperated, defects when
    resource collapses or cooperation drops below adaptive threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        stock_health_ratio = current_stock / self.capacity if self.capacity > 0 else 0
        if stock_health_ratio < 0.3:
            return Action.D
        cooperators_prev = int(sum(history.opponent_actions[current_round - 1, :]))
        cooperation_rate_prev = cooperators_prev / self.n_players
        rounds_remaining = self.n_rounds - current_round
        base_threshold = 0.5 + 0.3 * rounds_remaining / self.n_rounds
        cooperation_threshold = base_threshold
        if current_round >= 1:
            stock_trend = current_stock - history.my_payoffs[current_round - 1]
            if stock_trend > 0 and stock_health_ratio > 0.5:
                cooperation_threshold = max(0.4, base_threshold * 0.8)
            elif stock_trend < 0 and stock_health_ratio < 0.5:
                cooperation_threshold = min(0.9, base_threshold * 1.3)
        if stock_health_ratio > 0.9:
            cooperation_threshold = max(0.3, cooperation_threshold - 0.1)
        if cooperation_rate_prev >= cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_201(BaseStrategy):
    """
    Adaptive Sustainability Management (ASM) Strategy for Common Pool Resource Games.
    
    Balances individual resilience with collective long-term welfare by using stock-conditional
    cooperation. Cooperates while stock is sustainable, defects when resource is threatened,
    and always defects in the final round (backward induction).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.safe_threshold = game_description.capacity / 3.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_stock <= self.safe_threshold:
            return Action.D
        if current_round == n_rounds - 1:
            return Action.C if current_stock == 0 else Action.D
        total_actions_so_far = current_round * n_players
        total_defections = 0
        my_cooperations = np.sum(history.my_actions[:current_round])
        my_defections = current_round - my_cooperations
        opponent_cooperations = np.sum(history.opponent_actions[:current_round, :])
        opponent_defections = current_round * (n_players - 1) - opponent_cooperations
        total_defections = my_defections + opponent_defections
        avg_defection_rate = total_defections / total_actions_so_far if total_actions_so_far > 0 else 0.0
        stock_change = current_stock - history.opponent_payoffs[current_round - 1, 0] if current_round >= 1 else 0.0
        if current_round >= 2:
            stock_two_rounds_ago = self._estimate_stock_two_rounds_ago(history, current_round)
            stock_change = current_stock - stock_two_rounds_ago
        else:
            stock_change = 0.0
        stock_change_pct = stock_change / capacity if capacity > 0 else 0.0
        if stock_change_pct < -0.05:
            sustainability_risk = 'CRITICAL'
        elif stock_change_pct < 0:
            sustainability_risk = 'WARNING'
        else:
            sustainability_risk = 'SAFE'
        if sustainability_risk == 'CRITICAL':
            return Action.D
        if sustainability_risk == 'WARNING' and avg_defection_rate > 0.5:
            return Action.D
        if current_round >= 4:
            recent_defection_rate = self._calculate_defection_rate_for_rounds(history, current_round - 3, current_round, n_players)
            earlier_defection_rate = self._calculate_defection_rate_for_rounds(history, 1, min(4, current_round), n_players)
            defection_trend = recent_defection_rate - earlier_defection_rate
            if sustainability_risk == 'WARNING' and defection_trend > 0.15:
                return Action.D
        return Action.C

    def _estimate_stock_two_rounds_ago(self, history: PlayerHistory, current_round: int) -> float:
        """
        Estimate stock level from 2 rounds ago using payoff history.
        Returns an approximate value based on available data.
        """
        if current_round < 2:
            return self.game_description.capacity
        try:
            round_index = current_round - 2
            if round_index >= 0 and round_index < len(history.my_payoffs):
                my_payoff = history.my_payoffs[round_index]
                avg_opponent_payoff = np.mean(history.opponent_payoffs[round_index, :]) if history.opponent_payoffs.shape[0] > round_index else 0.0
                return max(0, self.game_description.capacity * 0.5)
        except (IndexError, TypeError):
            pass
        return self.game_description.capacity

    def _calculate_defection_rate_for_rounds(self, history: PlayerHistory, start_round: int, end_round: int, n_players: int) -> float:
        """
        Calculate defection rate for a range of rounds.
        Returns fraction of defections (False=0=D) in the specified range.
        """
        if start_round >= end_round or start_round < 0:
            return 0.0
        num_rounds = end_round - start_round
        if num_rounds <= 0:
            return 0.0
        try:
            my_cooperations = np.sum(history.my_actions[start_round:end_round])
            my_defections = num_rounds - my_cooperations
            opponent_cooperations = np.sum(history.opponent_actions[start_round:end_round, :])
            opponent_defections = num_rounds * (n_players - 1) - opponent_cooperations
            total_defections = my_defections + opponent_defections
            total_actions = num_rounds * n_players
            return total_defections / total_actions if total_actions > 0 else 0.0
        except (IndexError, TypeError):
            return 0.0

class Strategy_COLLECTIVE_202(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection strategy for Common Pool Resource Game.
    
    Prioritizes collective resource sustainability while protecting against exploitation.
    Uses stock-conditional cooperation: cooperates when stock is above sustainable threshold,
    defects when stock is depleted or in final round (with pristine exception).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.sustainable_threshold = self.capacity * 0.4
        self.pristine_threshold = self.capacity * 0.9
        self.collapse_threshold = self.capacity * 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decide action based on current stock level and round number.
        
        Decision logic:
        1. If stock collapsed (< 20% capacity): Defect
        2. If final round: Cooperate if pristine (≥90%), else Defect
        3. Otherwise: Cooperate if stock ≥ 40% capacity, else Defect
        """
        stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number
        if stock < self.collapse_threshold:
            return Action.D
        if rounds_remaining == 1:
            if stock >= self.pristine_threshold:
                return Action.C
            else:
                return Action.D
        if stock >= self.sustainable_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_203(BaseStrategy):
    """
    Adaptive Stock Stewardship Strategy for Common Pool Resource Games.
    
    Prioritizes long-term collective welfare through conditional cooperation,
    adaptive opponent classification, and escalating response protocols.
    Maintains stock health through threshold-based decision-making while
    responding to observed defection patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.C
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio < 0.25:
            return Action.C
        if round_num == self.n_rounds - 1:
            if stock_ratio > 0.3:
                return Action.D
            else:
                return Action.C
        defection_rate = self._calculate_defection_rate(history, round_num)
        rounds_remaining = self.n_rounds - round_num - 1
        if stock_ratio < 0.5:
            if defection_rate > 0.75:
                return Action.C
            return Action.C
        if defection_rate < 0.25:
            return Action.C
        if defection_rate > 0.75:
            if stock_ratio > 0.6:
                return Action.D
            else:
                return Action.C
        if defection_rate > 0.4:
            last_defection_distance = self._rounds_since_last_opponent_defection(history, round_num)
            if last_defection_distance <= 2 and last_defection_distance >= 0:
                return Action.D
            if rounds_remaining > 3:
                return Action.C
            else:
                return Action.D
        if rounds_remaining > 3:
            return Action.C
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the rate of defection observed from all opponents.
        
        True = Cooperate (Action.C), False = Defect (Action.D)
        We count False values as defections.
        """
        if current_round == 0:
            return 0.0
        opponent_actions = history.opponent_actions[:current_round, :]
        total_observations = opponent_actions.size
        if total_observations == 0:
            return 0.0
        defections = np.sum(~opponent_actions)
        defection_rate = float(defections) / float(total_observations)
        return defection_rate

    def _rounds_since_last_opponent_defection(self, history: PlayerHistory, current_round: int) -> int:
        """
        Calculate how many rounds ago the most recent opponent defection occurred.
        Returns -1 if no defection has been observed.
        """
        if current_round == 0:
            return -1
        for round_idx in range(current_round - 1, -1, -1):
            opponent_actions_in_round = history.opponent_actions[round_idx, :]
            if np.any(~opponent_actions_in_round):
                return current_round - round_idx - 1
        return -1

class Strategy_COLLECTIVE_204(BaseStrategy):
    """
    Adaptive Stewardship: A collective strategy for common pool resource management.
    
    Balances three competing pressures: personal payoff, resource sustainability, and
    punishment of free-riders. Uses stock-conditional cooperation with temporal adaptation
    and escalating responses to persistent defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_safe = self.capacity * 0.4
        self.threshold_critical = self.capacity * 0.25
        self.threshold_endgame = self.capacity * 0.5
        self.tolerance_threshold = 0.25
        self.tolerance_strict = 0.15
        self.defection_high = 0.5
        self.defection_severe = 0.7
        self.defection_endgame = 0.3
        self.punishment_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.C
        defection_ratio = self._calculate_defection_ratio(history, round_num)
        if stock < self.threshold_critical:
            return Action.C
        if round_num >= 3:
            avg_defection_3 = self._calculate_avg_defection_last_n(history, round_num, 3)
            if avg_defection_3 > self.defection_severe:
                if self.punishment_rounds_remaining > 0:
                    self.punishment_rounds_remaining -= 1
                    return Action.D
                else:
                    self.punishment_rounds_remaining = 2
                    return Action.D
            if avg_defection_3 > self.defection_high:
                return Action.D
        tolerance = self.tolerance_threshold
        if round_num >= 2:
            stock_two_ago = self._get_stock_two_rounds_ago(history, round_num)
            if stock_two_ago > 0 and stock / stock_two_ago < 0.6:
                tolerance = self.tolerance_strict
        if stock > self.threshold_safe and defection_ratio <= tolerance:
            if round_num == self.n_rounds - 1:
                if stock < self.threshold_endgame and defection_ratio > self.defection_endgame:
                    return Action.D
            return Action.C
        else:
            return Action.D

    def _calculate_defection_ratio(self, history: PlayerHistory, round_num: int) -> float:
        """Calculate the ratio of defectors in the previous round."""
        if round_num == 0 or history is None:
            return 0.0
        prev_round_actions = history.opponent_actions[round_num - 1, :]
        num_defectors = np.sum(~prev_round_actions)
        return float(num_defectors) / float(self.n_players)

    def _calculate_avg_defection_last_n(self, history: PlayerHistory, round_num: int, n: int) -> float:
        """Calculate average defection ratio over last n rounds."""
        if round_num < n or history is None:
            return 0.0
        start_idx = max(0, round_num - n)
        end_idx = round_num
        total_defections = 0.0
        for round_idx in range(start_idx, end_idx):
            round_actions = history.opponent_actions[round_idx, :]
            num_defectors = np.sum(~round_actions)
            total_defections += float(num_defectors)
        num_rounds = float(end_idx - start_idx)
        if num_rounds == 0:
            return 0.0
        return total_defections / (num_rounds * float(self.n_players))

    def _get_stock_two_rounds_ago(self, history: PlayerHistory, round_num: int) -> float:
        """Estimate stock two rounds ago based on consumption patterns."""
        if round_num < 2 or history is None:
            return self.capacity
        my_action_two_ago = history.my_actions[round_num - 2]
        opponent_actions_two_ago = history.opponent_actions[round_num - 2, :]
        return self.capacity

class Strategy_COLLECTIVE_205(BaseStrategy):
    """
    Adaptive Stewardship with Contingent Defection.
    
    Balances collective resource preservation with individual resilience by adapting
    behavior based on stock health and opponent defection rates. Uses three modes:
    - MODE 1 (Healthy): Cooperate when stock > 60% capacity
    - MODE 2 (Stressed): Conditional defection based on defection rate threshold
    - MODE 3 (Critical): Defect when stock <= 30% capacity
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.mode_3_threshold = 0.3
        self.mode_2_lower = 0.3
        self.mode_2_upper = 0.6
        self.stock_depleted_heavily_round_2 = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == 1 and history is not None:
            stock_depletion = self.capacity - current_stock
            if stock_depletion > 0.4 * self.capacity:
                self.stock_depleted_heavily_round_2 = True
                self.mode_3_threshold = 0.4
        rounds_remaining = self.n_rounds - round_number
        if current_stock > self.mode_2_upper * self.capacity:
            return Action.C
        elif current_stock > self.mode_3_threshold * self.capacity:
            defectors_last_round = sum((1 for action in history.opponent_actions[-1, :] if not action))
            defection_rate = defectors_last_round / self.n_players
            if self.n_rounds > 0:
                threshold_defection_rate = 0.5 * (rounds_remaining / self.n_rounds) + 0.3
            else:
                threshold_defection_rate = 0.3
            if defection_rate > threshold_defection_rate:
                return Action.D
            else:
                return Action.C
        else:
            if round_number == self.n_rounds - 1 and current_stock > 0.5 * self.capacity:
                return Action.C
            return Action.D

class Strategy_COLLECTIVE_206(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Reciprocity.
    
    Treats the common pool as a shared resource requiring stewardship.
    Uses health-based assessment and depletion rate detection to decide between
    cooperation and defection, with graduated responses to detect free-riders.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        round_num = state.round_number
        rounds_elapsed = round_num
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if current_stock < 2 * self.n_players:
            if round_num > 0:
                prev_stock = history.my_payoffs[round_num - 1] * self.n_players
                if round_num >= 2:
                    stock_trend = self._calculate_stock_trend(history, round_num)
                    if stock_trend < 0:
                        return Action.D
            return Action.D
        if round_num == self.n_rounds - 1:
            if current_stock >= self.capacity * 0.5:
                return Action.C
            else:
                return Action.D
        if health_ratio >= 0.75:
            return Action.C
        if health_ratio < 0.25:
            return Action.D
        depletion_rate = (self.capacity - current_stock) / (rounds_elapsed + 1)
        sustainable_rate = self.capacity / (2 * self.n_players)
        if depletion_rate > sustainable_rate:
            defection_count = self._count_last_round_defectors(history, round_num)
            if defection_count >= self.n_players / 2:
                return Action.D
            if defection_count >= 1:
                return self._evaluate_punishment(history, round_num)
        if health_ratio >= 0.5:
            return Action.C
        consecutive_deficit_rounds = self._count_consecutive_deficit_rounds(history, round_num)
        if consecutive_deficit_rounds >= 2:
            return Action.D
        return Action.C

    def _count_last_round_defectors(self, history: PlayerHistory, round_num: int) -> int:
        """Count how many opponents defected in the most recent round."""
        if round_num == 0:
            return 0
        last_round_actions = history.opponent_actions[round_num - 1, :]
        defectors = sum((1 for action in last_round_actions if not action))
        return defectors

    def _evaluate_punishment(self, history: PlayerHistory, round_num: int) -> Action:
        """Tertiary rule: Conditional strategy against mixed populations."""
        consecutive_deficit = self._count_consecutive_deficit_rounds(history, round_num)
        if consecutive_deficit >= 2:
            if round_num > 0:
                my_last_action = history.my_actions[round_num - 1]
                if not my_last_action:
                    last_round_defectors = self._count_last_round_defectors(history, round_num)
                    if last_round_defectors > 0:
                        return Action.D
                else:
                    return Action.D
            return Action.C
        return Action.C

    def _calculate_stock_trend(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate whether stock is trending up or down.
        Returns positive if growing, negative if declining.
        """
        if round_num < 2:
            return 0.0
        stocks = []
        for r in range(round_num):
            avg_opp_payoff = np.mean(history.opponent_payoffs[r, :])
            if r < len(history.opponent_actions[r]):
                is_coop = history.opponent_actions[r, 0] if len(history.opponent_actions[r]) > 0 else True
                estimated_stock = avg_opp_payoff * (2 * self.n_players if is_coop else self.n_players)
                stocks.append(estimated_stock)
        if len(stocks) >= 2:
            return stocks[-1] - stocks[-2]
        return 0.0

    def _count_consecutive_deficit_rounds(self, history: PlayerHistory, round_num: int) -> int:
        """
        Count consecutive recent rounds where stock declined.
        A deficit round is one where growth < consumption (stock decreased).
        """
        if round_num == 0:
            return 0
        consecutive = 0
        look_back = min(3, round_num)
        for r in range(round_num - look_back, round_num):
            if r < 0:
                continue
            current_payoffs = np.sum(history.my_payoffs[r]) + np.sum(history.opponent_payoffs[r, :])
            if r > 0:
                prev_payoffs = np.sum(history.my_payoffs[r - 1]) + np.sum(history.opponent_payoffs[r - 1, :])
                if current_payoffs > prev_payoffs * 1.2:
                    consecutive += 1
                else:
                    consecutive = 0
            elif current_payoffs > self.capacity / (2 * self.n_players) * self.n_players * 0.8:
                consecutive += 1
        return consecutive

class Strategy_COLLECTIVE_207(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Maintains stock sustainability through conditional cooperation, adapting to observed
    defection rates in the population. Cooperates when stock is healthy and defection is low,
    defects when stock is stressed or defection becomes systemic, and always defects in final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        capacity = self.capacity
        n = self.n_players
        total_rounds = self.n_rounds
        stock_ratio = stock / capacity if capacity > 0 else 0.0
        rounds_remaining = total_rounds - round_num - 1
        if stock_ratio < 0.3:
            return Action.D
        if rounds_remaining == 0:
            return Action.D
        if rounds_remaining == 1:
            if stock_ratio < 0.5:
                return Action.D
            else:
                return Action.C
        if round_num == 0:
            return Action.C
        defections_observed = 0
        for r in range(round_num):
            for p in range(n - 1):
                if not history.opponent_actions[r, p]:
                    defections_observed += 1
        total_observations = round_num * (n - 1)
        if total_observations == 0:
            defection_rate = 0.0
        else:
            defection_rate = defections_observed / total_observations
        if stock_ratio > 0.7:
            tolerance = 0.4
        elif stock_ratio > 0.5:
            tolerance = 0.3
        else:
            tolerance = 0.15
        if defection_rate > tolerance:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_208(BaseStrategy):
    """
    Adaptive Conservation Strategy (ACS): Conditional cooperation with adaptive thresholds.
    
    Monitors common pool health and adjusts behavior based on resource state and observed
    defection rates. Cooperates when resources are healthy, pivots to defection when stressed
    or critical, and defects in the final round (backward induction).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_number = state.round_number
        health = self._classify_health(stock)
        if round_number == self.n_rounds - 1:
            return Action.D
        if round_number == 0:
            return Action.C
        defection_rate = self._calculate_defection_rate(history, round_number)
        if health == 'HEALTHY':
            return Action.C
        elif health == 'STRESSED':
            if defection_rate < 0.3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _classify_health(self, stock: float) -> str:
        """
        Classify resource health based on stock level relative to capacity.
        """
        if stock > 0.6 * self.capacity:
            return 'HEALTHY'
        elif stock > 0.3 * self.capacity:
            return 'STRESSED'
        else:
            return 'CRITICAL'

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the observed defection rate across all players and rounds so far.
        
        Defection is when a player took Action.D (False/0 in the boolean array).
        Cooperation is when a player took Action.C (True/1 in the boolean array).
        """
        if round_number <= 0:
            return 0.0
        total_defections = 0
        total_actions = 0
        for r in range(round_number):
            for opponent_idx in range(self.n_players - 1):
                if history.opponent_actions[r, opponent_idx] == False:
                    total_defections += 1
                total_actions += 1
            if history.my_actions[r] == False:
                total_defections += 1
            total_actions += 1
        if total_actions == 0:
            return 0.0
        return total_defections / total_actions

class Strategy_COLLECTIVE_209(BaseStrategy):
    """
    Adaptive Threshold with Decay Recovery (ATDR) Strategy for Common Pool Resource Game.
    
    This strategy balances prudent consumption with responsive defection by:
    1. Using a dynamically declining threshold based on game progress
    2. Detecting resource collapse and responding defensively
    3. Implementing recovery phases to rebuild cooperation
    4. Starting cooperatively and adapting based on stock dynamics
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.consecutive_defections = 0
        self.last_stock = game_description.capacity
        self.in_recovery_phase = False
        self.recovery_phase_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock_current = state.current_stock
        if round_t == 0:
            self.last_stock = stock_current
            return Action.C
        stock_previous = self.last_stock
        self.last_stock = stock_current
        if stock_current <= self.capacity * 0.15:
            self.consecutive_defections += 1
            return Action.D
        if stock_previous > 0 and stock_previous - stock_current > self.capacity * 0.4:
            self.consecutive_defections += 1
            self.in_recovery_phase = True
            self.recovery_phase_counter = 2
            return Action.D
        if self.in_recovery_phase:
            self.recovery_phase_counter -= 1
            if self.recovery_phase_counter <= 0:
                self.in_recovery_phase = False
        threshold = self.capacity * (0.5 - 0.15 * (round_t / self.n_rounds))
        stock_recovering = stock_current > stock_previous and stock_current > self.capacity * 0.45
        if self.consecutive_defections >= 2:
            self.consecutive_defections = 0
            if stock_current > self.capacity * 0.4:
                self.in_recovery_phase = True
                self.recovery_phase_counter = 2
                return Action.C
        if stock_current > threshold:
            if stock_recovering:
                self.consecutive_defections = 0
                return Action.C
            if self.consecutive_defections == 0:
                self.consecutive_defections = 0
                return Action.C
            else:
                self.consecutive_defections += 1
                return Action.D
        else:
            self.consecutive_defections += 1
            return Action.D

class Strategy_COLLECTIVE_210(BaseStrategy):
    """
    Adaptive Collective Stewardship Strategy (ACS)
    
    Prioritizes sustainable resource management while remaining robust against exploitation.
    Uses stock-conditional cooperation with adaptive defection based on observed behavior
    and resource health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = 0.75
        self.threshold_critical = 0.25
        self.threshold_moderate = 0.5
        self.tolerance_threshold = 0.35
        self.consecutive_unanimous_cooperation = 0
        self.previous_defection_rate = 0.0
        self.locked_cooperation = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        if state.round_number == self.n_rounds - 1:
            if stock_ratio >= 0.6:
                return Action.C
            else:
                return Action.D
        if stock_ratio >= self.threshold_high:
            return Action.C
        if stock_ratio < self.threshold_critical:
            return Action.D
        previous_round_idx = state.round_number - 1
        opponent_actions_previous = history.opponent_actions[previous_round_idx, :]
        defectors_count = sum((1 for action in opponent_actions_previous if not action))
        observed_defection_rate = defectors_count / self.n_players if self.n_players > 0 else 0.0
        if self.locked_cooperation:
            return Action.C
        if observed_defection_rate == 0.0:
            self.consecutive_unanimous_cooperation += 1
            if self.consecutive_unanimous_cooperation >= 2:
                self.threshold_high = 0.8
                self.locked_cooperation = True
                return Action.C
        else:
            self.consecutive_unanimous_cooperation = 0
        current_tolerance = self.tolerance_threshold
        if state.round_number > 1:
            defection_rate_increase = observed_defection_rate - self.previous_defection_rate
            if defection_rate_increase > 0.1:
                current_tolerance = 0.25
        self.previous_defection_rate = observed_defection_rate
        if observed_defection_rate > current_tolerance:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_211(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Response (ASGR)
    
    A sustainable common pool strategy that balances immediate consumption with long-term
    resource preservation. Uses tit-for-tat with defection thresholds, graduated responses
    to defection, and stock-health monitoring to avoid resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_health = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        prev_round_idx = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        num_defectors = np.sum(~opponent_actions_prev)
        defection_rate = num_defectors / self.n_players if self.n_players > 0 else 0.0
        is_final_rounds = state.round_number >= self.n_rounds - 2
        stock_health_threshold = 0.25 if not is_final_rounds else 0.35
        if state.current_stock < 2 * self.n_players:
            return Action.D
        if defection_rate > 0.5 and stock_health < 0.5:
            return Action.D
        if defection_rate > 0.25:
            return Action.D
        if stock_health < stock_health_threshold:
            return Action.D
        if defection_rate == 0.0 and stock_health >= 0.4:
            return Action.C
        if defection_rate <= 0.25 and stock_health >= 0.3:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_212(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Operates on sustainability-first principle with conditional defection.
    Maintains regenerative capacity while adapting to collective cooperation level.
    Uses stock trajectory to infer defection rates and adjust behavior dynamically.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_tolerance = 0.35
        self.tolerance_escalation_rounds = 0
        self.historical_growth = []
        self.historical_stock = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            self.historical_stock.append(current_stock)
            return Action.C
        self.historical_stock.append(current_stock)
        if current_stock >= self.capacity * 0.95:
            return Action.C
        if current_stock < self.capacity * 0.2:
            return Action.D
        remaining_rounds = self.n_rounds - round_num
        total_rounds = self.n_rounds
        critical_threshold = self.capacity * (0.4 + 0.1 * (remaining_rounds / total_rounds))
        if current_stock >= critical_threshold:
            return Action.C
        estimated_defection = self._estimate_defection_rate(state, history)
        if estimated_defection > self.defection_tolerance:
            self.tolerance_escalation_rounds += 1
        else:
            self.tolerance_escalation_rounds = max(0, self.tolerance_escalation_rounds - 1)
        current_tolerance = self.defection_tolerance
        if self.tolerance_escalation_rounds >= 2:
            current_tolerance = 0.5
        if estimated_defection > current_tolerance:
            if round_num > 2 * self.n_rounds / 3:
                return Action.D
            elif round_num > self.n_rounds / 3:
                if self._should_attempt_stabilization(state, history):
                    return Action.C
                return Action.D
            else:
                return Action.C
        if round_num == self.n_rounds - 1:
            if len(self.historical_stock) > 1:
                median_historical = np.median(self.historical_stock[:-1])
                if current_stock > median_historical:
                    return Action.D
            return Action.C
        return Action.C

    def _estimate_defection_rate(self, state: CommonPoolState, history: PlayerHistory) -> float:
        """
        Infer aggregate defection rate from stock consumption patterns.
        
        Returns value between 0 and 2:
        - 1.0 = all players cooperating (minimal consumption)
        - 2.0 = all players defecting (maximal consumption)
        """
        if state.round_number == 0:
            return 0.0
        prev_stock = self.historical_stock[-2] if len(self.historical_stock) >= 2 else state.current_stock
        ideal_consumption = prev_stock / (2 * self.n_players)
        if ideal_consumption < 1e-09:
            return 0.0
        actual_consumption = prev_stock - state.current_stock
        consumption_efficiency = actual_consumption / ideal_consumption if ideal_consumption > 0 else 1.0
        defection_rate_estimate = max(0.0, (consumption_efficiency - 1.0) / 1.0)
        return defection_rate_estimate

    def _should_attempt_stabilization(self, state: CommonPoolState, history: PlayerHistory) -> bool:
        """
        Determine if attempting stabilization (cooperation) is beneficial
        despite observed high defection rate.
        """
        round_num = state.round_number
        if len(self.historical_growth) > 0:
            avg_growth = np.mean(self.historical_growth)
            if avg_growth > 0:
                prev_stock = self.historical_stock[-2] if len(self.historical_stock) >= 2 else state.current_stock
                recent_growth = state.current_stock - prev_stock
                if recent_growth > avg_growth * 1.5:
                    return True
        if round_num <= self.n_rounds / 3:
            return True
        return False

class Strategy_COLLECTIVE_213(BaseStrategy):
    """
    Adaptive Sustainable Harvesting (ASH): A collective strategy that prioritizes
    long-term resource sustainability while adapting to opponent behavior.
    
    Core logic:
    - Critical stock (< 30% capacity): Always cooperate to recover
    - Healthy stock (>= 60% capacity): Cooperate unless opponents defect heavily (>55%)
    - Moderate stock (30-60% capacity): Cooperate unless opponents defect heavily (>55%)
    - First round: Always cooperate
    - Stock collapse recovery: Cooperate for 2 rounds after collapse
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_collapse_recovery_counter = 0
        self.last_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_stock = state.current_stock
            return Action.C
        if state.current_stock <= 0.01 and self.last_stock > 0.01:
            self.stock_collapse_recovery_counter = 2
        self.last_stock = state.current_stock
        if self.stock_collapse_recovery_counter > 0:
            self.stock_collapse_recovery_counter -= 1
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        defection_rate = self._calculate_weighted_defection_rate(history, state.round_number)
        if stock_ratio < 0.3:
            return Action.C
        if stock_ratio >= 0.6:
            if defection_rate > 0.55:
                return Action.D
            else:
                return Action.C
        if defection_rate > 0.55:
            return Action.D
        else:
            return Action.C

    def _calculate_weighted_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate opponent defection rate with exponential decay weighting.
        Recent behavior weighted more heavily than historical behavior.
        """
        if current_round <= 1:
            return 0.5
        n_opponents = self.game_description.n_players - 1
        total_weighted_defections = 0.0
        total_weight = 0.0
        for round_idx in range(current_round):
            rounds_ago = current_round - 1 - round_idx
            if rounds_ago <= 2:
                weight = 1.0
            elif rounds_ago <= 5:
                weight = 0.7
            else:
                weight = 0.4
            defections_this_round = n_opponents - np.sum(history.opponent_actions[round_idx, :])
            total_weighted_defections += defections_this_round * weight
            total_weight += n_opponents * weight
        if total_weight == 0:
            return 0.5
        defection_rate = total_weighted_defections / total_weight
        return defection_rate

class Strategy_COLLECTIVE_214(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy that prioritizes long-term
    resource sustainability while adapting to observed defection rates. It cooperates in
    abundant conditions, becomes cautious as stock depletes, and defects strategically to
    prevent exploitation or in emergency phases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        observed_defection_rate = self._calculate_defection_rate(history, round_number)
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        if stock_health >= 0.95:
            if observed_defection_rate < 0.4:
                return Action.C
            else:
                return Action.D
        if stock_health >= 0.6:
            if observed_defection_rate < 0.4:
                return Action.C
            else:
                return Action.D
        elif stock_health >= 0.3:
            if observed_defection_rate < 0.25:
                return Action.C
            elif observed_defection_rate < 0.5:
                return Action.D
            else:
                return Action.D
        elif observed_defection_rate < 0.3:
            return Action.C
        else:
            return Action.D

    def _calculate_defection_rate(self, history: None | PlayerHistory, round_number: int) -> float:
        """
        Calculate the observed defection rate among opponents in recent rounds.
        Defection is when opponent plays False (Action.D).
        """
        if history is None or round_number == 0:
            return 0.0
        recent_rounds_count = min(5, round_number)
        if recent_rounds_count == 0:
            return 0.0
        recent_opponent_actions = history.opponent_actions[-recent_rounds_count:, :]
        total_actions = recent_opponent_actions.size
        if total_actions == 0:
            return 0.0
        defection_count = np.sum(recent_opponent_actions == False)
        defection_rate = float(defection_count) / float(total_actions)
        return defection_rate

class Strategy_COLLECTIVE_215(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy for common pool resource games
    that prioritizes long-term sustainability while remaining robust to defectors.
    
    Decision-making is based on:
    1. Current stock level relative to capacity (primary)
    2. Historical defection rate (secondary)
    3. End-game adjustments (tertiary)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0 or history is None:
            return Action.C
        healthy_threshold = 0.75 * self.capacity
        moderate_threshold = 0.5 * self.capacity
        critical_threshold = 0.25 * self.capacity
        defection_rate = self._calculate_defection_rate(history, round_number)
        if round_number == self.n_rounds - 1:
            if current_stock > moderate_threshold:
                return Action.C
            else:
                return Action.D
        if current_stock > healthy_threshold:
            return Action.C
        elif current_stock > moderate_threshold:
            return Action.C
        elif current_stock > critical_threshold:
            if defection_rate < 0.25:
                return Action.C
            elif defection_rate < 0.5:
                threshold = 0.25 + (defection_rate - 0.25) * 0.5
                if random.random() < threshold:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the historical defection rate across all opponents.
        Defection is encoded as False (0), Cooperation as True (1).
        Defection rate = (number of defections) / (total actions observed)
        """
        if round_number == 0:
            return 0.0
        opponent_actions = history.opponent_actions[:round_number, :]
        cooperations = np.sum(opponent_actions)
        total_actions = opponent_actions.size
        if total_actions == 0:
            return 0.0
        defection_rate = 1.0 - cooperations / total_actions
        return defection_rate

class Strategy_COLLECTIVE_216(BaseStrategy):
    """
    Adaptive Conservation with Proportional Accountability.
    
    Prioritizes sustainable collective welfare through conditional cooperation.
    Cooperates in healthy conditions, responds proportionally to defection when stressed,
    and maintains preservation mode when critical to prevent resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_healthy = 0.7
        self.threshold_critical = 0.2
        self.threshold_near_capacity = 0.95
        self.recent_window = 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_health = state.current_stock / self.game_description.capacity
        if stock_health > self.threshold_near_capacity:
            return Action.C
        if stock_health <= self.threshold_critical:
            return Action.C
        if stock_health > self.threshold_healthy:
            return Action.C
        recent_defection_rate = self._calculate_recent_defection_rate(history, state.round_number)
        defection_threshold = 0.5 * ((self.game_description.n_players - 1) / self.game_description.n_players)
        if recent_defection_rate > defection_threshold:
            return Action.D
        else:
            return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the defection rate among opponents in the recent window.
        
        Args:
            history: Player history containing opponent actions
            round_number: Current round number (1-indexed from perspective of this function)
        
        Returns:
            Defection rate as a float between 0 and 1
        """
        window_size = min(self.recent_window, round_number)
        if window_size == 0:
            return 0.0
        start_round = round_number - window_size
        opponent_actions_slice = history.opponent_actions[start_round:round_number, :]
        defections = np.sum(opponent_actions_slice == False)
        total_actions = opponent_actions_slice.size
        if total_actions == 0:
            return 0.0
        defection_rate = defections / total_actions
        return defection_rate

class Strategy_COLLECTIVE_217(BaseStrategy):
    """
    Adaptive Stewardship with Tit-for-Tat Recovery.
    
    Balances rational self-interest with collective sustainability by:
    1. Defecting when stock is abundant (>1.5× capacity)
    2. Cooperating when stock is critically depleted (<0.4× capacity)
    3. Adapting based on observed defection rates and trends in healthy range
    4. Prioritizing resource recovery over short-term exploitation
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if stock < 0.1 * self.capacity:
            return Action.C
        if stock > 1.5 * self.capacity:
            return Action.D
        if stock < 0.4 * self.capacity:
            return Action.C
        if round_num == 0:
            return Action.C
        prev_defections = np.sum(~history.opponent_actions[round_num - 1, :])
        defection_rate = prev_defections / self.n
        if defection_rate <= 0.25:
            return Action.C
        if defection_rate > 0.75:
            return Action.D
        if 0.25 < defection_rate <= 0.75:
            if round_num >= 1:
                prev_prev_defections = np.sum(~history.opponent_actions[round_num - 2, :])
                prev_defection_rate = prev_prev_defections / self.n
                trend = defection_rate - prev_defection_rate
                if trend < 0:
                    return Action.C
                if trend > 0:
                    return Action.D
                if stock > self.capacity:
                    return Action.C
                else:
                    return Action.D
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_218(BaseStrategy):
    """
    Adaptive Sustainable Harvesting (ASH) Strategy
    
    Balances individual resilience with collective sustainability through:
    - Stock health monitoring (maintains commons above 40% capacity)
    - Conditional tit-for-tat (tolerates up to 25% defection)
    - Trajectory checking (detects rapid stock decline)
    - Endgame adjustments (prevents final-round exploitation)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.early_game_end = math.ceil(self.n_rounds / 3)
        self.mid_game_end = math.floor(2 * self.n_rounds / 3)
        if self.n_rounds > 20:
            self.early_game_end = math.ceil(self.n_rounds / 4)
        self.stock_history: list[float] = []

    def _count_defections(self, history: PlayerHistory, current_round: int) -> int:
        """
        Count rounds where majority of other players defected.
        A defection round is when >50% of opponents played D.
        """
        defection_count = 0
        for round_idx in range(current_round):
            opponent_defections = sum((1 for i in range(self.n_players - 1) if not history.opponent_actions[round_idx, i]))
            if opponent_defections > (self.n_players - 1) / 2:
                defection_count += 1
        return defection_count

    def _get_stock_health_threshold(self, current_round: int) -> float:
        """
        Determine stock health threshold based on game phase.
        Higher threshold in second-to-last round.
        """
        if current_round == self.n_rounds - 2:
            return 0.5 * self.capacity
        else:
            return 0.4 * self.capacity

    def _infer_stock_decline(self, current_stock: float, previous_stock: float) -> bool:
        """
        Check if stock declined rapidly (>10% drop).
        """
        if previous_stock <= 0:
            return False
        return current_stock < 0.9 * previous_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            self.stock_history.append(current_stock)
            return Action.C
        self.stock_history.append(current_stock)
        previous_stock = self.stock_history[-2] if len(self.stock_history) >= 2 else current_stock
        if current_round == self.n_rounds - 1:
            defection_count = self._count_defections(history, current_round)
            if current_stock > 0.6 * self.capacity and defection_count == 0:
                return Action.C
            else:
                return Action.D
        if current_stock < 0.1 * self.capacity:
            return Action.D
        stock_health_threshold = self._get_stock_health_threshold(current_round)
        stock_healthy = current_stock >= stock_health_threshold
        defection_count = self._count_defections(history, current_round)
        max_tolerable_defections = 0.25 * (self.n_players - 1)
        if self.n_players == 2:
            max_tolerable_defections = 0
        cooperative_environment = defection_count <= max_tolerable_defections
        trajectory_ok = not self._infer_stock_decline(current_stock, previous_stock)
        not_emergency = current_stock >= 0.1 * self.capacity
        if stock_healthy and cooperative_environment and trajectory_ok and not_emergency:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_219(BaseStrategy):
    """
    Adaptive Stock-Preservation with Graduated Response strategy for Common Pool Resource Game.
    
    Prioritizes collective long-term welfare by maintaining stock sustainability while responding
    proportionally to actual defection patterns. Uses a Stock Health Index (SHI) to drive decisions
    through graduated thresholds with recovery windows.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_stock = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        shi = state.current_stock / self.game_description.capacity
        stock_delta = state.current_stock - self.previous_stock
        self.previous_stock = state.current_stock
        defectors_last_round = int(np.sum(~history.opponent_actions[-1, :]))
        in_recovery_window = False
        if state.round_number >= 2:
            previous_shi = history.my_payoffs[-2] * 2 * self.game_description.n_players / state.current_stock if state.current_stock > 0 else 0
            if state.round_number >= 1:
                try:
                    if stock_delta > 0.05 * self.game_description.capacity:
                        in_recovery_window = True
                except (IndexError, ZeroDivisionError):
                    in_recovery_window = False
        if shi >= 0.75:
            return Action.C
        elif 0.5 <= shi < 0.75:
            if defectors_last_round <= 1:
                return Action.C
            else:
                return Action.D
        elif 0.3 <= shi < 0.5:
            if in_recovery_window or stock_delta >= -0.1 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_220(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Defection Detection.
    
    A collective strategy that prioritizes sustainable commons management through
    conditional cooperation. Defaults to cooperation but switches to defection when
    stock becomes critically depleted or defection pressure is high in stressed conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        shi = current_stock / self.capacity if self.capacity > 0 else 0.0
        if shi < 0.3:
            return Action.D
        defection_rate = self._calculate_defection_rate(history, state.round_number)
        if 0.3 <= shi < 0.6:
            if defection_rate >= 0.6:
                return Action.D
            else:
                return Action.C
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the defection rate from recent rounds.
        
        Looks at the last k rounds where k = min(3, round_number).
        Defection rate = (total defections observed) / (n_players × k)
        """
        if round_number <= 0:
            return 0.0
        k = min(3, round_number)
        start_idx = round_number - k
        recent_opponent_actions = history.opponent_actions[start_idx:round_number, :]
        defection_count = np.sum(~recent_opponent_actions)
        total_slots = self.n_players * k
        if total_slots == 0:
            return 0.0
        defection_rate = float(defection_count) / float(total_slots)
        return defection_rate

class Strategy_COLLECTIVE_221(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy that prioritizes long-term
    resource maintenance through adaptive decision rules based on stock health, while
    remaining individually rational through graduated defection when resources are depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        shi = current_stock / self.capacity if self.capacity > 0 else 0.0
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            if shi >= 0.5:
                return Action.C
            else:
                return Action.D
        consecutive_critical = self._count_consecutive_critical(history, round_number)
        if consecutive_critical >= 2:
            if shi <= 0.35:
                return Action.D
            else:
                return self._apply_normal_rules(history, round_number, shi)
        if self._detect_stock_rebound(history, round_number):
            return self._apply_caution_rules(history, round_number)
        return self._apply_normal_rules(history, round_number, shi)

    def _apply_normal_rules(self, history: PlayerHistory, round_number: int, shi: float) -> Action:
        """Apply standard decision logic based on stock health phases."""
        if shi >= 0.65:
            return Action.C
        elif shi <= 0.35:
            return Action.D
        else:
            defection_rate = self._calculate_defection_rate(history, round_number)
            if defection_rate <= 0.4:
                return Action.C
            else:
                return Action.D

    def _apply_caution_rules(self, history: PlayerHistory, round_number: int) -> Action:
        """Apply caution phase rules (used during stock rebound detection)."""
        defection_rate = self._calculate_defection_rate(history, round_number)
        if defection_rate <= 0.4:
            return Action.C
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """Calculate the proportion of opponent defections in the last 3 rounds."""
        look_back = min(3, round_number)
        if look_back == 0:
            return 0.0
        start_round = round_number - look_back
        defection_count = 0
        total_actions = 0
        for r in range(start_round, round_number):
            opponent_actions = history.opponent_actions[r, :]
            defection_count += np.sum(opponent_actions == False)
            total_actions += len(opponent_actions)
        if total_actions == 0:
            return 0.0
        return float(defection_count) / float(total_actions)

    def _count_consecutive_critical(self, history: PlayerHistory, round_number: int) -> int:
        """Count consecutive rounds where stock health index was <= 0.35."""
        if round_number == 0:
            return 0
        consecutive = 0
        for r in range(round_number - 1, -1, -1):
            consecutive += 1
            if consecutive > round_number:
                break
        if round_number < 2:
            return 0
        recent_my_actions = history.my_actions[max(0, round_number - 2):round_number]
        if len(recent_my_actions) >= 2 and np.all(recent_my_actions == False):
            return 2
        return 0

    def _detect_stock_rebound(self, history: PlayerHistory, round_number: int) -> bool:
        """Detect if stock increased by >15% in the most recent round after critical phase."""
        if round_number < 2:
            return False
        prev_round = round_number - 1
        if prev_round > 0 and history.my_actions[prev_round] == False:
            recent_payoffs = history.my_payoffs[max(0, prev_round - 1):prev_round + 1]
            if len(recent_payoffs) >= 2:
                payoff_change = recent_payoffs[-1] - recent_payoffs[-2]
                if payoff_change > 0:
                    return True
        return False

class Strategy_COLLECTIVE_222(BaseStrategy):
    """
    Adaptive Stewardship Strategy: Stock-Responsive Conditional Cooperation
    
    Treats the common pool as a shared resource requiring active stewardship.
    Cooperates when sustainable, defects when necessary to prevent collapse.
    Adapts based on observed defection rates and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.danger_threshold = self.capacity * 0.15
        self.abundance_threshold = self.capacity * 0.6
        self.cooperation_viability = self.capacity * 0.3
        self.final_defection_stock_threshold = self.capacity * 0.4
        self.rapid_depletion_threshold = 0.25
        self.high_defection_threshold = 0.65
        self.low_defection_threshold = 0.3
        self.escape_defection_threshold = 0.65

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        observed_defection_rate = self._calculate_defection_rate(history, round_number)
        is_rapid_depletion = self._detect_rapid_depletion(history, round_number)
        if current_stock <= self.danger_threshold:
            return Action.C
        if current_stock >= self.abundance_threshold and observed_defection_rate < 0.4:
            return Action.C
        if current_stock < self.cooperation_viability and observed_defection_rate > self.escape_defection_threshold:
            return Action.D
        if round_number == self.n_rounds - 1:
            if current_stock > self.final_defection_stock_threshold and observed_defection_rate > 0.6:
                return Action.D
            return Action.C
        if is_rapid_depletion and current_stock > self.danger_threshold:
            return Action.D
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the observed defection rate from opponents across all completed rounds.
        Defection is encoded as False (0), so we count False values.
        """
        if round_number == 0:
            return 0.5
        opponent_actions = history.opponent_actions[:round_number, :]
        total_defections = np.sum(opponent_actions == False)
        total_observations = round_number * (self.n_players - 1)
        if total_observations == 0:
            return 0.5
        defection_rate = total_defections / total_observations
        return defection_rate

    def _detect_rapid_depletion(self, history: PlayerHistory, round_number: int) -> bool:
        """
        Detect if stock has declined >25% per round for 2+ consecutive rounds.
        """
        if round_number < 2:
            return False
        recent_payoffs = history.my_payoffs[max(0, round_number - 3):round_number]
        if len(recent_payoffs) < 2:
            return False
        avg_recent = np.mean(recent_payoffs)
        if avg_recent > 0 and len(recent_payoffs) >= 2:
            recent_trend = recent_payoffs[-1] / (recent_payoffs[-2] + 1e-10)
            if recent_trend < 0.75 and avg_recent < self.capacity / (4 * self.n_players):
                return True
        return False

class Strategy_COLLECTIVE_223(BaseStrategy):
    """
    Collective Pool Stewardship Strategy
    
    Treats the common pool as a shared resource requiring active stewardship.
    Balances resource sustainability, temporal fairness, and robustness by adapting
    decisions based on pool health (stock/capacity ratio) and observed cooperation patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if current_round == 0:
            return Action.C
        if current_stock < 0.01 * self.capacity:
            return Action.D
        if health_ratio >= 0.6:
            return Action.C
        if health_ratio < 0.35:
            return Action.D
        recent_coop_rate = self._measure_recent_cooperation(history, current_round)
        if recent_coop_rate >= 0.6:
            return Action.C
        elif recent_coop_rate < 0.4:
            return Action.D
        elif self._is_depletion_accelerating(history, current_round):
            return Action.D
        else:
            return Action.C

    def _measure_recent_cooperation(self, history: PlayerHistory, current_round: int) -> float:
        """
        Measure cooperation rate over the last 3 rounds (or fewer if < 3 rounds elapsed).
        Returns fraction of opponent cooperators across recent rounds.
        """
        if current_round <= 0:
            return 0.0
        start_round = max(0, current_round - 3)
        end_round = current_round
        total_cooperators = 0
        total_slots = 0
        for round_idx in range(start_round, end_round):
            if round_idx < len(history.opponent_actions):
                cooperators_in_round = sum(history.opponent_actions[round_idx, :])
                total_cooperators += cooperators_in_round
                total_slots += self.n_players
        if total_slots == 0:
            return 0.0
        return total_cooperators / total_slots

    def _is_depletion_accelerating(self, history: PlayerHistory, current_round: int) -> bool:
        """
        Check if stock depletion rate is accelerating over recent rounds.
        Returns True if depletion is occurring faster than expected.
        """
        if current_round < 2:
            return False
        round_idx_prev = current_round - 2
        round_idx_curr = current_round - 1
        if round_idx_prev < 0 or round_idx_curr >= len(history.my_payoffs):
            return False
        prev_payoff = history.my_payoffs[round_idx_prev] if round_idx_prev < len(history.my_payoffs) else 0.0
        curr_payoff = history.my_payoffs[round_idx_curr]
        if round_idx_prev < len(history.opponent_actions):
            coop_prev = sum(history.opponent_actions[round_idx_prev, :]) / self.n_players
        else:
            coop_prev = 0.5
        coop_curr = sum(history.opponent_actions[round_idx_curr, :]) / self.n_players
        if abs(coop_curr - coop_prev) < 0.2:
            if prev_payoff > 0 and curr_payoff < prev_payoff * 0.7:
                return True
        return False

class Strategy_COLLECTIVE_224(BaseStrategy):
    """
    Adaptive Stock Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual security with collective sustainability by conditioning
    cooperation on stock health and observed defection rates. Cooperates when stock
    is abundant, conditionally cooperates when declining, and defects when critical.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        threshold_high = 0.75 * self.capacity
        threshold_mid_high = 0.4 * self.capacity
        threshold_mid_low = 0.1 * self.capacity
        threshold_critical = 0.05 * self.capacity
        threshold_final = 0.5 * self.capacity
        if current_stock <= threshold_critical:
            return Action.D
        if round_number == self.n_rounds - 1:
            if current_stock > threshold_final:
                return Action.C
            else:
                return Action.D
        defectors_last_round = self.n_players - int(np.sum(history.opponent_actions[-1, :]))
        defection_rate = defectors_last_round / self.n_players
        if current_stock > threshold_high:
            return Action.C
        elif current_stock > threshold_mid_high:
            defector_threshold = 0.25
            if defection_rate >= defector_threshold:
                return Action.D
            else:
                return Action.C
        elif current_stock > threshold_mid_low:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_225(BaseStrategy):
    """
    Adaptive Stock Stewardship: A sustainable resource management strategy for common pool games.
    
    This strategy prioritizes collective resource health while protecting individual interests through
    stock-based (not reputation-based) decision making. It cooperates when stock is healthy, adapts
    conditionally in caution zones based on depletion trends, and defects when resources are critical
    or in endgame rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.healthy_threshold = 0.75 * self.capacity
        self.caution_threshold = 0.4 * self.capacity
        self.previous_stock = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == 0:
            self.previous_stock = current_stock
            return Action.C
        if current_round >= self.n_rounds - 2:
            if current_stock > self.healthy_threshold:
                return Action.C
            else:
                return Action.D
        if current_stock > self.healthy_threshold:
            self.previous_stock = current_stock
            return Action.C
        if current_stock <= self.caution_threshold:
            self.previous_stock = current_stock
            return Action.D
        if self.previous_stock > 0:
            depletion_trend = (current_stock - self.previous_stock) / self.previous_stock
        else:
            depletion_trend = 0
        if depletion_trend >= 0:
            self.previous_stock = current_stock
            return Action.C
        caution_zone_width = 0.35 * self.capacity
        stock_position_in_caution = self.healthy_threshold - current_stock
        defect_probability = stock_position_in_caution / caution_zone_width
        defect_probability = max(0.0, min(1.0, defect_probability))
        self.previous_stock = current_stock
        if random.random() < defect_probability:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_226(BaseStrategy):
    """
    Adaptive Stock-Preserving Cooperation (ASPC) Strategy
    
    This strategy treats the common pool as a shared resource whose preservation
    benefits all players. Cooperation is maintained when stock is healthy, and
    defection occurs only when stock becomes critically depleted or the game is
    ending with low stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        self.stock_history.append(current_stock)
        if current_round == 0:
            return Action.C
        stock_ratio = current_stock / capacity if capacity > 0 else 0.0
        rounds_remaining = total_rounds - current_round
        if len(self.stock_history) > 1:
            prev_stock = self.stock_history[-2]
            if prev_stock > 0:
                recent_decline = (current_stock - prev_stock) / prev_stock
                if recent_decline < -0.2:
                    return Action.D
        if stock_ratio < 0.1:
            return Action.D
        if current_round == total_rounds - 1:
            if stock_ratio > 0.2:
                return Action.C
            else:
                return Action.D
        if stock_ratio > 0.5:
            return Action.C
        elif stock_ratio > 0.3 and rounds_remaining > 3:
            return Action.C
        elif stock_ratio > 0.15 and rounds_remaining > 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_227(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A strategy that balances sustainability,
    reciprocity, and robustness in common pool resource games.
    
    Core logic:
    - Round 1: Cooperate to establish norms
    - Final round: Defect (no future consequences)
    - Otherwise: Decide based on stock health and observed defection rates
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        last_round_index = round_number - 1
        opponent_actions_last_round = history.opponent_actions[last_round_index, :]
        num_defectors_last_round = np.sum(opponent_actions_last_round == False)
        defection_ratio = num_defectors_last_round / self.n_players
        if defection_ratio >= (self.n_players - 1) / self.n_players:
            return Action.D
        if stock_ratio >= 0.75:
            return Action.C
        if stock_ratio >= 0.5:
            if defection_ratio <= 0.25:
                return Action.C
            else:
                return Action.D
        if stock_ratio >= 0.25:
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_228(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Sanctions strategy for Common Pool Resource Game.
    
    Balances sustainability, fairness, and robustness by:
    - Assessing stock health and operating in NORMAL/CAUTIOUS/CRITICAL modes
    - Detecting defection rates among opponents
    - Applying mode-dependent decision rules with graduated sanctions
    - Supporting recovery phases and avoiding revenge cycles
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio < 0.4:
            mode = 'CRITICAL'
            defection_threshold = 0.1
        elif stock_ratio < 0.6:
            mode = 'CAUTIOUS'
            defection_threshold = 0.25
        else:
            mode = 'NORMAL'
            defection_threshold = 0.5
        recent_window = min(3, state.round_number)
        recent_actions = history.opponent_actions[-recent_window:, :]
        defections_observed = np.sum(~recent_actions)
        total_other_actions = (self.n_players - 1) * recent_window
        defection_rate = defections_observed / total_other_actions if total_other_actions > 0 else 0.0
        stock_recovering = False
        if state.round_number > 0:
            stock_recovering = self._is_stock_recovering(history, state.round_number)
        my_recent_actions = history.my_actions[-min(2, len(history.my_actions)):]
        my_defection_streak = 0
        if len(my_recent_actions) > 0:
            for action in reversed(my_recent_actions):
                if not action:
                    my_defection_streak += 1
                else:
                    break
        if current_stock < self.n_players * 0.5:
            all_others_cooperate = np.all(history.opponent_actions[-1, :])
            if all_others_cooperate:
                return Action.C
            else:
                return Action.D
        if mode == 'NORMAL':
            if defection_rate > defection_threshold:
                return Action.D
            else:
                return Action.C
        elif mode == 'CAUTIOUS':
            if defection_rate > defection_threshold:
                return Action.D
            elif stock_recovering:
                return Action.C
            else:
                return Action.C
        elif defection_rate > defection_threshold:
            return Action.D
        else:
            return Action.C

    def _is_stock_recovering(self, history: PlayerHistory, round_number: int) -> bool:
        """
        Determine if stock is recovering by analyzing payoff trends.
        Stock recovers if total consumption decreased (payoffs are proxy for consumption).
        """
        if round_number < 2:
            return False
        recent_payoffs = history.opponent_payoffs[-2:, :]
        if len(recent_payoffs) < 2:
            return False
        avg_payoff_prev = np.mean(recent_payoffs[0, :])
        avg_payoff_curr = np.mean(recent_payoffs[1, :])
        recovery_signal = avg_payoff_curr > 0 and avg_payoff_curr >= avg_payoff_prev * 0.9
        return recovery_signal

class Strategy_COLLECTIVE_229(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual short-term gains against collective long-term sustainability
    by adapting decisions based on stock levels and observed opponent behavior.
    Uses stock-conditional thresholds and probabilistic responses in intermediate zones.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_number = state.round_number
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        if round_number == 0:
            return Action.C
        if stock_ratio < 0.15:
            return Action.D
        if stock_ratio > 0.75:
            return Action.C
        if round_number == self.n_rounds - 1:
            if stock_ratio > 0.5:
                return Action.C
            else:
                return Action.D
        recent_rounds = min(3, round_number)
        opponent_defection_rate = self._calculate_opponent_defection_rate(history, round_number, recent_rounds)
        defection_pressure = 1.0 - stock_ratio
        cooperation_probability = 1.0 - defection_pressure
        if opponent_defection_rate > 0.5:
            return Action.D
        if opponent_defection_rate <= 0.2:
            return Action.C
        if random.random() < cooperation_probability:
            return Action.C
        else:
            return Action.D

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, current_round: int, num_recent_rounds: int) -> float:
        """
        Calculate the fraction of opponent actions that were defections
        in the last num_recent_rounds rounds.
        
        Returns a value in [0, 1].
        """
        if num_recent_rounds == 0 or current_round == 0:
            return 0.0
        start_round = max(0, current_round - num_recent_rounds)
        end_round = current_round
        recent_actions = history.opponent_actions[start_round:end_round, :]
        total_opponent_actions = recent_actions.size
        if total_opponent_actions == 0:
            return 0.0
        cooperations = np.sum(recent_actions)
        defections = total_opponent_actions - cooperations
        defection_rate = defections / total_opponent_actions
        return float(defection_rate)

class Strategy_COLLECTIVE_230(BaseStrategy):
    """
    Adaptive Stewardship Strategy: Balances individual rational self-interest with collective
    resource preservation through conditional cooperation that responds to observable system health.
    
    Core mechanism: Defect when resource is abundant (stock > 75% capacity), cooperate when
    vulnerable (stock < 40% capacity), with adaptive adjustments based on stock trajectory
    and emergency safeguards for critical depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.threshold_high_base = 0.75
        self.threshold_mid = 0.4
        self.threshold_low = 0.2
        self.critical_depletion = 0.1
        self.stock_history = []
        self.last_capacity_round = -1
        self.defection_count_recent = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            self.stock_history.append(current_stock)
            if current_stock >= self.capacity * 0.99:
                self.last_capacity_round = 0
            return Action.C
        self.stock_history.append(current_stock)
        if current_stock >= self.capacity * 0.99:
            self.last_capacity_round = current_round
        if current_stock < self.critical_depletion * self.capacity:
            return Action.C
        threshold_high = self.threshold_high_base * self.capacity
        if current_round >= 3:
            stock_3_ago = self.stock_history[current_round - 3]
            if stock_3_ago > 0:
                trend = (current_stock - stock_3_ago) / stock_3_ago
                if trend < -0.15:
                    threshold_high = 0.65 * self.capacity
        if current_round >= 3:
            stagnant = True
            for i in range(current_round - 2, current_round + 1):
                if i >= 0 and self.stock_history[i] >= self.capacity * 0.99:
                    stagnant = False
                    break
            if stagnant and current_round >= 3:
                threshold_high = threshold_high * 0.9
        self.defection_count_recent = 0
        if current_round >= 1 and (not history.my_actions[current_round - 1]):
            self.defection_count_recent += 1
        if current_round >= 2 and (not history.my_actions[current_round - 2]):
            self.defection_count_recent += 1
        if current_round == self.n_rounds - 1:
            if current_stock <= self.threshold_low * self.capacity:
                if self.defection_count_recent <= 2:
                    return Action.C
        threshold_mid_stock = self.threshold_mid * self.capacity
        if current_stock > threshold_high:
            return Action.D
        elif current_stock > threshold_mid_stock:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_231(BaseStrategy):
    """
    Adaptive Sustainable Harvesting (ASH): A collective strategy that prioritizes
    long-term resource sustainability while remaining robust to defection.
    
    Uses stock health metrics and adaptive tier-based decision making with
    punishment mechanisms for exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_health = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_health >= 0.65:
            tier = 1
        elif stock_health >= 0.35:
            tier = 2
        else:
            tier = 3
        if self._has_recent_exploitation(history, state.round_number):
            tier = min(tier + 1, 3)
        is_final_round = state.round_number == self.n_rounds - 1
        if is_final_round and tier <= 2:
            return Action.D
        min_viable_stock = 2.0 * self.n_players
        if state.current_stock < min_viable_stock:
            return Action.D
        if self._detect_universal_cooperation(history, state.round_number, threshold=3):
            return Action.C
        if tier == 1:
            return Action.C
        elif tier == 2:
            return Action.C
        else:
            return Action.D

    def _has_recent_exploitation(self, history: PlayerHistory, current_round: int) -> bool:
        """
        Check if player cooperated but was exploited in the last 2 rounds.
        Returns True if recent_defection_rate > 0.5
        """
        if current_round < 1:
            return False
        lookback_window = min(2, current_round)
        recent_rounds = range(current_round - lookback_window, current_round)
        exploitation_count = 0
        for round_idx in recent_rounds:
            if history.my_actions[round_idx]:
                opponent_defections = sum((1 for opp_action in history.opponent_actions[round_idx, :] if not opp_action))
                opponent_cooperations = self.n_players - 1 - opponent_defections
                if opponent_defections > opponent_cooperations:
                    exploitation_count += 1
        recent_defection_rate = exploitation_count / lookback_window if lookback_window > 0 else 0.0
        return recent_defection_rate > 0.5

    def _detect_universal_cooperation(self, history: PlayerHistory, current_round: int, threshold: int=3) -> bool:
        """
        Detect if all players have cooperated for threshold+ consecutive recent rounds.
        Returns True if universal cooperation is detected.
        """
        if current_round < threshold:
            return False
        for round_idx in range(current_round - threshold, current_round):
            if not history.my_actions[round_idx]:
                return False
            all_opponents_cooperated = all(history.opponent_actions[round_idx, :])
            if not all_opponents_cooperated:
                return False
        return True

class Strategy_COLLECTIVE_232(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual security with collective sustainability by adapting
    cooperation decisions based on current stock health and remaining rounds.
    Cooperates when stock is healthy, defects when depleted or in final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number
        if rounds_remaining <= 1:
            return Action.D
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if rounds_remaining <= 3:
            threshold = 0.3
        elif rounds_remaining <= self.n_rounds / 2:
            threshold = 0.45
        else:
            threshold = 0.55
        if health_ratio >= threshold:
            return Action.C
        simulated_consumption_per_player = current_stock / (2 * self.n_players)
        simulated_total_consumption = self.n_players * simulated_consumption_per_player
        simulated_remaining_stock = current_stock - simulated_total_consumption
        if simulated_remaining_stock < 0:
            simulated_remaining_stock = 0.0
        if self.capacity > 0:
            growth_factor = 1.0 - simulated_remaining_stock / self.capacity
        else:
            growth_factor = 0.0
        simulated_growth = 2.0 * simulated_remaining_stock * growth_factor
        projected_stock = min(simulated_remaining_stock + simulated_growth, self.capacity)
        recovery_threshold = threshold * self.capacity
        if projected_stock >= recovery_threshold and rounds_remaining > 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_233(BaseStrategy):
    """
    Adaptive Stock-Preservation with Conditional Defection (ASPCD).
    
    Balances sustainability, fairness, and resilience by using stock-based thresholds
    to decide between cooperation and defection. Monitors recent defection rates in
    the warning zone and responds to collective non-cooperation while prioritizing
    resource preservation over individual exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.healthy_threshold = self.capacity * 0.6
        self.warning_threshold = self.capacity * 0.3
        self.critical_threshold = self.capacity * 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if current_stock >= self.healthy_threshold:
            return Action.C
        elif current_stock >= self.warning_threshold:
            defection_rate = self._calculate_defection_rate(history, round_number)
            if defection_rate <= 0.25:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the defection rate over the last 3 rounds (or fewer if not available).
        
        Defection rate = count of defections by all players / (lookback_rounds × n_players)
        """
        lookback_rounds = min(3, round_number)
        if lookback_rounds == 0:
            return 0.0
        recent_actions = history.opponent_actions[-lookback_rounds:, :]
        defections = np.sum(~recent_actions)
        defection_rate = defections / (lookback_rounds * self.n_players)
        return defection_rate

class Strategy_COLLECTIVE_234(BaseStrategy):
    """
    Adaptive Collective Stewardship Strategy (ACS) for Common Pool Resource Games.
    
    Balances individual resilience with collective sustainability by using adaptive
    thresholds based on stock health and depletion rates. Cooperates when stock is
    healthy, conditionally cooperates in moderate ranges, and defects when stock
    is threatened or being rapidly depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if round_number == 0:
            return Action.C
        if health_ratio <= 0.1:
            return Action.D
        if health_ratio > 0.7:
            return Action.C
        if health_ratio > 0.4:
            if history is not None and len(history.my_payoffs) > 0:
                previous_stock = self._get_previous_stock(current_stock, history, round_number)
                if previous_stock > 0:
                    depletion_rate = (previous_stock - current_stock) / previous_stock
                    if depletion_rate < 0.15:
                        return Action.C
                    elif depletion_rate < 0.3:
                        coop_probability = (0.7 - health_ratio) / 0.3
                        if random.random() < coop_probability:
                            return Action.C
                        else:
                            return Action.D
                    else:
                        if rounds_remaining <= 2:
                            return Action.D
                        recent_defections = self._count_recent_defectors(history, round_number)
                        if recent_defections > self.n_players // 2:
                            return Action.D
                        return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        return Action.D

    def _get_previous_stock(self, current_stock: float, history: PlayerHistory, round_number: int) -> float:
        """
        Estimate previous stock level from current stock and consumption history.
        
        Work backwards from current round to infer the stock before this round's consumption.
        """
        if round_number <= 0:
            return self.capacity
        if round_number > 0:
            prev_round_idx = round_number - 1
            my_action_prev = history.my_actions[prev_round_idx]
            my_consumption_prev = self._get_consumption(my_action_prev, current_stock)
            opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
            opponent_consumption = sum((self._get_consumption(action, current_stock) for action in opponent_actions_prev))
            total_consumption_prev = my_consumption_prev + opponent_consumption
            estimated_previous_stock = current_stock + total_consumption_prev
            estimated_previous_stock = min(estimated_previous_stock, self.capacity)
            return estimated_previous_stock
        return self.capacity

    def _get_consumption(self, action: bool, stock: float) -> float:
        """
        Calculate consumption amount for a given action.
        True (1) = Cooperate = stock / (2n)
        False (0) = Defect = stock / n
        """
        if action:
            return stock / (2 * self.n_players)
        else:
            return stock / self.n_players

    def _count_recent_defectors(self, history: PlayerHistory, round_number: int) -> int:
        """
        Count number of defectors in the most recent round.
        """
        if round_number <= 0 or history is None:
            return 0
        recent_actions = history.opponent_actions[round_number - 1, :]
        defectors = sum((1 for action in recent_actions if not action))
        return defectors

class Strategy_COLLECTIVE_235(BaseStrategy):
    """
    Adaptive Stock-Preservation Protocol (ASPP):
    A provisionally cooperative strategy that balances individual gain with collective 
    long-term sustainability in common pool resource games. Cooperates when sustainable,
    defects when necessary, and adapts to opponent behavior dynamically.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D if current_stock > 0 else Action.C
        rounds_remaining = self.n_rounds - current_round
        sustainable_stock = self.capacity * (rounds_remaining / self.n_rounds)
        current_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        defection_rate = 0.0
        if current_round > 0 and history is not None:
            defectors_last_round = np.sum(~history.opponent_actions[current_round - 1, :])
            defection_rate = defectors_last_round / self.n_players
        if current_stock < 2 * self.n_players and rounds_remaining > 1:
            return Action.C
        if defection_rate > 0.5:
            if current_ratio > 0.3:
                return Action.C
            else:
                return Action.D
        endgame_threshold = 0.8
        if current_round / self.n_rounds >= endgame_threshold:
            threshold_adjustment = (current_round / self.n_rounds - endgame_threshold) / 0.2
            effective_threshold = sustainable_stock * (1.0 - threshold_adjustment)
            sustainable_threshold = effective_threshold / self.capacity if self.capacity > 0 else 0.0
            return Action.C if current_ratio >= sustainable_threshold else Action.D
        sustainable_threshold = sustainable_stock / self.capacity if self.capacity > 0 else 0.0
        return Action.C if current_ratio >= sustainable_threshold else Action.D

class Strategy_COLLECTIVE_236(BaseStrategy):
    """
    Collective Pool Stewardship Strategy (CPSS)
    
    Balances personal sustainability, pool preservation, and adaptive resilience.
    Uses stock-level thresholds and opponent defection rates to decide between
    cooperation and defection, preventing tragedy of the commons while remaining
    robust against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_tolerance = 0.5
        self.lookback_window = min(3, game_description.n_rounds - 1)

    def _calculate_critical_threshold(self, round_num: int) -> float:
        """
        Calculate critical stock threshold for the given round.
        
        critical_threshold(t) = capacity × max(0.15, (r - t) / (2r))
        - Linearly relaxes as game progresses
        - Never drops below 15% of capacity
        """
        if self.n_rounds <= 1:
            return self.capacity * 0.15
        relaxation_factor = (self.n_rounds - round_num) / (2.0 * self.n_rounds)
        threshold = self.capacity * max(0.15, relaxation_factor)
        return threshold

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the defection rate of opponents over the lookback window.
        
        Returns: proportion of opponent actions that were defections (False/0)
        """
        if current_round == 0:
            return 0.0
        lookback = min(self.lookback_window, current_round)
        start_round = current_round - lookback
        recent_opponent_actions = history.opponent_actions[start_round:current_round, :]
        total_actions = recent_opponent_actions.size
        if total_actions == 0:
            return 0.0
        cooperations = np.sum(recent_opponent_actions)
        defections = total_actions - cooperations
        defection_rate = defections / total_actions
        return defection_rate

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Main decision function for CPSS strategy.
        """
        current_stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        crit_threshold = self._calculate_critical_threshold(round_num)
        if current_stock < 0.2 * self.capacity:
            return Action.C
        if current_stock <= crit_threshold:
            return Action.C
        defection_rate = self._calculate_defection_rate(history, round_num)
        if 1 <= round_num <= 2 and defection_rate > 0.75:
            return Action.D
        if defection_rate >= self.defection_tolerance:
            if round_num == self.n_rounds - 1:
                if current_stock > crit_threshold:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_237(BaseStrategy):
    """
    Adaptive Threshold Cooperation (ATC) Strategy for Common Pool Resource Games.
    
    Cooperates when stock health is above threshold, defects when depleted.
    Thresholds vary by game phase: primary threshold is 50%, final round uses 30% (or 40% for small games).
    Naturally adapts to opponent behavior through stock level observation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if self.capacity <= 0:
            stock_ratio = 0.0
        else:
            stock_ratio = current_stock / self.capacity
        is_final_round = current_round == self.n_rounds - 1
        if self.n_rounds <= 3:
            final_threshold = 0.4
        else:
            final_threshold = 0.3
        if is_final_round:
            threshold = final_threshold
        else:
            threshold = 0.5
        if stock_ratio >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_238(BaseStrategy):
    """
    Collective Resource Stewardship Strategy (CRSS)
    
    Balances individual security with collective long-term welfare through adaptive
    threshold-based cooperation. Cooperates early when resources are abundant, tightens
    conservation as time runs out, and defects strategically in endgame scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.growth_rate_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        current_round = state.round_number
        stock = state.current_stock
        self.stock_history.append(stock)
        if current_round == 0:
            return Action.C
        growth_rate = 0.0
        if len(self.stock_history) >= 2:
            prev_stock = self.stock_history[-2]
            if prev_stock > 0:
                growth_rate = (stock - prev_stock) / prev_stock
            self.growth_rate_history.append(growth_rate)
        if stock <= capacity / 10:
            return Action.D
        if growth_rate > 0.2:
            return Action.C
        if len(self.stock_history) >= 3:
            stock_prev_2 = self.stock_history[-3]
            stock_prev_1 = self.stock_history[-2]
            if stock_prev_2 == stock_prev_1 and stock == stock_prev_1:
                if stock <= capacity / 3:
                    return Action.D
                else:
                    return Action.C
        if current_round == total_rounds - 1:
            if stock > 2 * capacity / 3:
                return Action.C
            else:
                return Action.D
        rounds_remaining = total_rounds - current_round
        if total_rounds > 1:
            threshold = capacity * (1 - math.sqrt(rounds_remaining / total_rounds))
        else:
            threshold = capacity / 2
        if stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_239(BaseStrategy):
    """
    Adaptive Stewardship with Defection Deterrence: A collective resource
    management strategy that balances sustainability, fairness, and robustness.
    
    Core behavior:
    - Cooperate by default to establish trustworthiness
    - Monitor collective defection rates and stock health
    - Punish excessive defection proportionally to its severity
    - Enforce strict cooperation during resource crises
    - Avoid endgame defection spirals in final rounds
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 1.0
        if stock_ratio < 0.3:
            return Action.C
        if round_number >= self.n_rounds - 1:
            if stock_ratio > 0.5:
                return Action.C
            else:
                return Action.C
        prev_round_idx = round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        num_defectors = np.sum(opponent_actions_prev == False)
        defection_rate = num_defectors / self.n_players
        threshold = self._calculate_threshold(stock_ratio)
        if defection_rate > threshold:
            p_defect = self._calculate_punishment_probability(defection_rate, threshold, stock_ratio)
            if random.random() < p_defect:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

    def _calculate_threshold(self, stock_ratio: float) -> float:
        """
        Adaptive defection tolerance threshold.
        Becomes stricter as stock approaches critical levels.
        """
        if stock_ratio >= 0.7:
            return 0.5 + 0.25 * self.n_players / 10.0
        elif stock_ratio >= 0.5:
            return 0.35 + 0.15 * self.n_players / 10.0
        elif stock_ratio >= 0.3:
            return 0.2
        else:
            return 0.0

    def _calculate_punishment_probability(self, defection_rate: float, threshold: float, stock_ratio: float) -> float:
        """
        Calculate probability of defecting as proportional punishment.
        Scales with how much defection exceeds acceptable level,
        discounted by stock abundance.
        """
        excess_defection = defection_rate - threshold
        if excess_defection <= 0:
            return 0.0
        scaling_factor = 1.0 - stock_ratio * 0.5
        p_defect = excess_defection * scaling_factor * 2.0
        return min(p_defect, 1.0)

class Strategy_COLLECTIVE_240(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual payoff maximization with collective resource sustainability
    through conditional cooperation based on resource health and observed defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        resource_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        previous_round_idx = state.round_number - 1
        opponent_actions_prev_round = history.opponent_actions[previous_round_idx, :]
        defection_count = np.sum(~opponent_actions_prev_round)
        defection_rate = defection_count / self.n_players if self.n_players > 0 else 0.0
        if resource_health >= 0.6:
            if defection_rate <= 0.4:
                return Action.C
            else:
                return Action.D
        elif resource_health >= 0.3:
            if defection_rate <= 0.2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_241(BaseStrategy):
    """
    Adaptive Conservation with Threshold-Based Reciprocity
    
    A collective strategy that prioritizes long-term resource sustainability while
    protecting against systematic exploitation. Uses stock health assessment combined
    with adaptive reciprocity to balance cooperation and self-interest.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        health_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        observed_defection_rate = self._calculate_defection_rate(history, round_num)
        threshold = 0.6 + 0.3 * (round_num / self.r)
        if self.n <= 3:
            base_coop_threshold = 0.8
        else:
            base_coop_threshold = 0.75
        if round_num == self.r - 1:
            if health_ratio > 0.4:
                return Action.D
            else:
                return Action.C
        base_decision = self._get_base_decision(health_ratio, base_coop_threshold)
        adjusted_decision = self._apply_defection_adjustment(base_decision, observed_defection_rate, threshold)
        if round_num > 1:
            adjusted_decision = self._apply_single_defector_logic(history, round_num, adjusted_decision)
        return adjusted_decision

    def _calculate_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """Calculate the observed defection rate of opponents."""
        if round_num <= 1:
            return 0.0
        defections = 0
        for r in range(round_num):
            defectors_this_round = np.sum(history.opponent_actions[r, :] == False)
            defections += defectors_this_round
        total_observations = (self.n - 1) * round_num
        if total_observations == 0:
            return 0.0
        return defections / total_observations

    def _get_base_decision(self, health_ratio: float, base_threshold: float) -> Action:
        """Determine base decision based on stock health."""
        if health_ratio > base_threshold:
            return Action.C
        elif health_ratio > 0.5:
            prob = (health_ratio - 0.5) / (base_threshold - 0.5)
            if random.random() < prob:
                return Action.C
            else:
                return Action.D
        elif health_ratio > 0.25:
            return Action.D
        else:
            return Action.D

    def _apply_defection_adjustment(self, base_decision: Action, observed_rate: float, threshold: float) -> Action:
        """Adjust decision based on observed defection rate."""
        if observed_rate > threshold:
            return Action.D
        return base_decision

    def _apply_single_defector_logic(self, history: PlayerHistory, round_num: int, current_decision: Action) -> Action:
        """Special logic: if you're the only defector among cooperators, switch back."""
        if current_decision == Action.D and round_num >= 2:
            my_last_action = history.my_actions[round_num - 1]
            if not my_last_action:
                cooperators_last_round = np.sum(history.opponent_actions[round_num - 1, :] == True)
                cooperator_rate = cooperators_last_round / (self.n - 1)
                observed_defection_rate = self._calculate_defection_rate(history, round_num)
                if cooperator_rate > 0.7 and observed_defection_rate < 0.3:
                    return Action.C
        return current_decision

class Strategy_COLLECTIVE_242(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS) for Common Pool Resource Game.
    
    Balances cooperation for sustainability with strategic defection based on:
    - Stock health (ratio to capacity)
    - Defection rates in previous rounds
    - Current round number (endgame adjustment)
    
    Core principle: Preserve the common pool through conditional cooperation,
    with proportional punishment for defection and emergency salvage for critical stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        if round_num == self.n_rounds - 1:
            return Action.D
        if round_num == self.n_rounds - 2:
            if stock_ratio > 0.7:
                return Action.C
            else:
                return Action.D
        if round_num == 0:
            defection_rate = 0.0
        else:
            defectors_last_round = sum((1 for action in history.opponent_actions[round_num - 1, :] if not action))
            defection_rate = defectors_last_round / self.n_players if self.n_players > 0 else 0.0
        if round_num <= 2 and round_num > 0:
            if defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        if stock_ratio > 0.6:
            return Action.C
        elif stock_ratio > 0.35:
            if defection_rate <= 0.25:
                return Action.C
            elif defection_rate <= 0.5:
                if random.random() < 1.0 - defection_rate:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        elif stock_ratio > 0.2:
            if defection_rate <= 0.4:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_243(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    A conditional cooperative approach that prioritizes sustainable resource management
    while maintaining individual resilience. Uses stock levels and observed defection
    rates to dynamically adjust cooperation probability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.consecutive_growth_rounds = 0
        self.previous_stock = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            self.previous_stock = current_stock
            return Action.C
        if round_number == self.n_rounds - 1:
            if current_stock > self.capacity * 0.3:
                return Action.C
            else:
                return Action.D
        if current_stock < self.capacity * 0.15:
            return Action.D
        stock_growth = current_stock - self.previous_stock
        if stock_growth > 0:
            self.consecutive_growth_rounds += 1
        else:
            self.consecutive_growth_rounds = 0
        self.previous_stock = current_stock
        if current_stock > self.capacity * 0.75:
            return Action.C
        elif current_stock > self.capacity * 0.4:
            cooperation_probability = self._calculate_cooperation_probability(history)
            if stock_growth > 0:
                cooperation_probability = min(1.0, cooperation_probability + 0.15)
            elif stock_growth < 0:
                cooperation_probability = max(0.0, cooperation_probability - 0.15)
            if self.consecutive_growth_rounds >= 3:
                cooperation_probability = min(1.0, cooperation_probability + 0.2)
            return Action.C if random.random() < cooperation_probability else Action.D
        else:
            return Action.D

    def _calculate_cooperation_probability(self, history: PlayerHistory) -> float:
        """Calculate cooperation probability based on observed defection rate."""
        if history is None or len(history.opponent_actions) == 0:
            return 0.9
        total_opponent_actions = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
        if total_opponent_actions == 0:
            return 0.9
        total_cooperations = np.sum(history.opponent_actions)
        total_defections = total_opponent_actions - total_cooperations
        defection_rate = total_defections / total_opponent_actions
        if defection_rate < 0.25:
            return 0.9
        elif defection_rate < 0.5:
            return 0.6
        elif defection_rate < 0.75:
            return 0.3
        else:
            return 0.0

class Strategy_COLLECTIVE_244(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection.
    
    Treats the common pool as a shared resource requiring active stewardship.
    Cooperates to maintain stock health, but conditionally defects when:
    - Stock falls below adaptive threshold, or
    - Opponent defection rate is unsustainably high, or
    - In endgame with depleted resources
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        remaining_rounds = self.n_rounds - round_number
        base_threshold = self.capacity * max(0.15, remaining_rounds / self.n_rounds)
        if remaining_rounds <= 2:
            base_threshold = self.capacity * 0.05
        observed_defection_rate = self._analyze_defection_pattern(history)
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if current_stock < base_threshold:
            return Action.D
        if observed_defection_rate > 0.4 and stock_ratio < 0.5:
            return Action.D
        if remaining_rounds <= 2 and stock_ratio > 0.3:
            return Action.C
        if stock_ratio > 0.6:
            return Action.C
        return Action.C

    def _analyze_defection_pattern(self, history: PlayerHistory) -> float:
        """
        Analyze opponent defection pattern from recent history.
        Returns the fraction of recent rounds where >50% of opponents played D.
        """
        if history is None or len(history.opponent_actions) < 2:
            return 0.0
        recent_rounds = history.opponent_actions[-3:]
        defection_rounds = 0
        for round_actions in recent_rounds:
            defectors = np.sum(round_actions == False)
            if defectors > self.n_players / 2:
                defection_rounds += 1
        num_recent = len(recent_rounds)
        return defection_rounds / num_recent if num_recent > 0 else 0.0

class Strategy_COLLECTIVE_245(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection.
    
    A stock-responsive strategy that prioritizes sustainable collective outcomes
    while protecting against exploitation. Monitors defection rates and stock trends
    to dynamically adjust cooperation thresholds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        rounds_remaining = self.n_rounds - round_num
        if round_num == 0:
            if stock == self.capacity:
                return Action.C
            return Action.C
        prev_round_idx = round_num - 1
        defection_rate = self._calculate_defection_rate(history, prev_round_idx)
        stock_trend = self._calculate_stock_trend(history, prev_round_idx)
        if stock < 0.1 * self.capacity:
            return Action.D
        if round_num == self.n_rounds - 1:
            if stock > 0.4 * self.capacity:
                return Action.C
            return Action.D
        if defection_rate > 0.75 * (self.n_players - 1) / self.n_players:
            return Action.D
        if defection_rate > 0.5:
            if stock > 0.6 * self.capacity:
                return Action.C
            return Action.D
        if stock_trend < -0.2:
            return Action.D
        if stock > 0.75 * self.capacity:
            return Action.C
        if stock > 0.5 * self.capacity:
            return Action.C
        if stock > 0.3 * self.capacity:
            if rounds_remaining > 3:
                return Action.C
            return Action.D
        return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, round_idx: int) -> float:
        """
        Calculate the rate of defection among opponents in the given round.
        
        Returns a value between 0 and 1, where 1 means all opponents defected
        and 0 means all opponents cooperated.
        """
        if round_idx < 0 or round_idx >= len(history.opponent_actions):
            return 0.0
        opponent_actions = history.opponent_actions[round_idx, :]
        num_defectors = np.sum(~opponent_actions)
        total_opponents = len(opponent_actions)
        if total_opponents == 0:
            return 0.0
        return float(num_defectors) / float(total_opponents)

    def _calculate_stock_trend(self, history: PlayerHistory, current_round_idx: int) -> float:
        """
        Calculate the recent stock trend.
        
        Returns the normalized change in stock from the previous round to current.
        Negative values indicate decline.
        """
        if current_round_idx < 1:
            return 0.0
        prev_round_idx = current_round_idx - 1
        my_action_prev = history.my_actions[prev_round_idx]
        my_payoff_prev = history.my_payoffs[prev_round_idx]
        if my_payoff_prev > 0:
            if my_action_prev:
                stock_prev = my_payoff_prev * 2 * self.n_players
            else:
                stock_prev = my_payoff_prev * self.n_players
        else:
            return 0.0
        if current_round_idx < 2:
            return 0.0
        payoff_prev_prev = history.my_payoffs[prev_round_idx - 1]
        payoff_prev = history.my_payoffs[prev_round_idx]
        if payoff_prev_prev <= 0:
            return 0.0
        trend = (payoff_prev - payoff_prev_prev) / payoff_prev_prev
        return trend

class Strategy_COLLECTIVE_246(BaseStrategy):
    """
    Collective Adaptive Stewardship Strategy (CASS)
    
    Balances individual security, collective sustainability, and adaptive responsiveness.
    - Round 1: Cooperate (test the water with full capacity)
    - Middle rounds: Conditional cooperation based on stock health and exploitation rate
    - Last round: Defect (unless stock is critically depleted)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            if current_stock < self.capacity * 0.1:
                return Action.C
            else:
                return Action.D
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_health < 0.4:
            return Action.D
        exploitation_ratio = self._calculate_exploitation_ratio(history, current_round)
        if stock_health > 0.6:
            if exploitation_ratio < 1.3:
                return Action.C
            else:
                return Action.D
        elif exploitation_ratio < 1.0:
            return Action.C
        elif exploitation_ratio < 1.3:
            p = 0.5 + (0.6 - stock_health) * 10
            p = max(0.0, min(1.0, p))
            return Action.C if random.random() < p else Action.D
        else:
            return Action.D

    def _calculate_exploitation_ratio(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate exploitation ratio based on total consumption in the previous round.
        exploitation_ratio = observed_consumption / sustainable_consumption
        sustainable_consumption = capacity * 0.5
        """
        if current_round == 0:
            return 0.0
        prev_round_idx = current_round - 1
        my_action = history.my_actions[prev_round_idx]
        my_consumption = self.capacity / (2 * self.n_players) if my_action else self.capacity / self.n_players
        opponent_actions = history.opponent_actions[prev_round_idx]
        opponent_consumptions = np.where(opponent_actions, self.capacity / (2 * self.n_players), self.capacity / self.n_players)
        total_consumption = my_consumption + np.sum(opponent_consumptions)
        sustainable_consumption = self.capacity * 0.5
        if sustainable_consumption <= 0:
            return 0.0
        exploitation_ratio = total_consumption / sustainable_consumption
        return float(exploitation_ratio)

class Strategy_COLLECTIVE_247(BaseStrategy):
    """
    Adaptive Conservation with Defensive Thresholds Strategy.
    
    Prioritizes collective resource sustainability while maintaining defensive responses
    to exploitation. Cooperates during growth phases, defects under critical depletion
    or when majority defects, with special handling for early and late game phases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        previous_stock = self.capacity if round_num == 1 else state.current_stock
        observed_defection_rate = self._calculate_defection_rate(history, round_num)
        stock_trend = current_stock - previous_stock if round_num > 0 else 0
        if current_stock < 0.2 * self.capacity:
            return Action.D
        if observed_defection_rate > 0.6:
            return Action.D
        if round_num <= 3:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        if current_stock >= 0.7 * self.capacity and stock_trend > 0:
            return Action.C
        if current_stock < 0.3 * self.capacity and stock_trend < -0.05 * self.capacity:
            return Action.D
        if current_stock >= 0.8 * self.capacity:
            return Action.C
        if observed_defection_rate > 0.4 and stock_trend < 0:
            return Action.D
        if 0.4 * self.capacity <= current_stock < 0.7 * self.capacity and stock_trend >= 0:
            return Action.C
        if round_num >= self.n_rounds - 2 and current_stock > 0.5 * self.capacity:
            return Action.C
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the defection rate from the previous round.
        
        Args:
            history: PlayerHistory object with opponent actions
            round_num: Current round number (1-indexed for this calculation)
        
        Returns:
            Defection rate as float between 0 and 1
        """
        if round_num == 0:
            return 0.0
        previous_round_index = round_num - 1
        opponent_actions_prev = history.opponent_actions[previous_round_index, :]
        defectors = np.sum(~opponent_actions_prev)
        defection_rate = defectors / self.n_players
        return float(defection_rate)

class Strategy_COLLECTIVE_248(BaseStrategy):
    """
    Adaptive Stewardship: A collective strategy for common pool resource games that balances
    individual payoff maximization with sustainability through dynamic cooperation thresholds,
    responsive to stock health, remaining rounds, and observed defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.consecutive_defections = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number
        if stock < 0.05 * self.capacity:
            self.consecutive_defections += 1
            return Action.D
        if round_number == 0:
            self.consecutive_defections = 0
            return Action.C
        defection_rate_last_round = self._compute_defection_rate(history, round_number - 1)
        last_round_all_cooperated = defection_rate_last_round == 0
        if rounds_remaining <= 2:
            if stock > 0.5 * self.capacity:
                self.consecutive_defections = 0
                return Action.C
            else:
                self.consecutive_defections += 1
                return Action.D
        if last_round_all_cooperated:
            self.consecutive_defections = 0
            return Action.C
        if self.consecutive_defections >= 2 and stock > 0.3 * self.capacity:
            self.consecutive_defections = 0
        stock_ratio = stock / self.capacity
        theta = self._compute_cooperation_threshold(defection_rate_last_round, rounds_remaining)
        if stock_ratio >= theta:
            self.consecutive_defections = 0
            return Action.C
        else:
            self.consecutive_defections += 1
            return Action.D

    def _compute_defection_rate(self, history: PlayerHistory, round_idx: int) -> float:
        """
        Compute the proportion of opponents who defected in the given round.
        """
        if round_idx < 0 or round_idx >= history.opponent_actions.shape[0]:
            return 0.0
        defectors = np.sum(~history.opponent_actions[round_idx, :])
        defection_rate = defectors / self.n_players
        return float(defection_rate)

    def _compute_cooperation_threshold(self, defection_rate_last_round: float, rounds_remaining: int) -> float:
        """
        Compute the dynamic cooperation threshold based on strategy rules.
        """
        base_threshold = 0.4
        defection_penalty = 0.3 * defection_rate_last_round
        endgame_adjustment = 0.2 * (1.0 - rounds_remaining / self.n_rounds)
        theta = base_threshold + defection_penalty + endgame_adjustment
        if defection_rate_last_round > 0.66:
            theta += 0.15
        if defection_rate_last_round < 0.25:
            theta = max(0.3, theta - 0.1)
        return theta

class Strategy_COLLECTIVE_249(BaseStrategy):
    """
    Collective Adaptive Stock Management Strategy (CASM)
    
    Balances individual payoff maximization with collective sustainability by:
    - Cooperating in early rounds to establish cooperative equilibrium
    - Adapting cooperation based on stock levels and observed defection rates
    - Punishing high defection environments while maintaining sustainability
    - Avoiding unnecessary endgame defection cascades
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 2 * self.n
        self.warning_threshold = self.capacity * 0.4
        self.safe_threshold = self.capacity * 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.C
        recent_defection_rate = self._calculate_recent_defection_rate(history, current_round)
        if stock < self.critical_threshold:
            return Action.D
        if stock < self.warning_threshold:
            return Action.C
        if recent_defection_rate <= 0.3:
            return Action.C
        if recent_defection_rate <= 0.5:
            return Action.C if random.random() < 0.85 else Action.D
        if recent_defection_rate > 0.5:
            return Action.D if random.random() < 0.3 else Action.C
        if current_round == self.r - 1:
            if stock >= self.warning_threshold:
                return Action.C
            else:
                return Action.D
        return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate defection rate from opponents in the last 3 rounds.
        Returns a rate between 0 and 1.
        """
        if current_round < 1:
            return 0.0
        start_round = max(0, current_round - 3)
        end_round = current_round
        defection_count = 0
        total_actions = 0
        for round_idx in range(start_round, end_round):
            if round_idx < len(history.opponent_actions):
                round_actions = history.opponent_actions[round_idx, :]
                defection_count += sum((1 for action in round_actions if not action))
                total_actions += len(round_actions)
        if total_actions == 0:
            return 0.0
        recent_defection_rate = defection_count / total_actions
        return recent_defection_rate

class Strategy_COLLECTIVE_250(BaseStrategy):
    """
    Adaptive Stewardship Strategy: Sustainability-First with Opportunistic Defense
    
    Maximizes collective welfare by maintaining stock health while remaining robust to exploitation.
    Uses conditional cooperation with adaptive thresholds based on stock health and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        critical_threshold = 0.4 * self.capacity
        endangered_threshold = 0.6 * self.capacity
        saturation_threshold = 0.95 * self.capacity
        if current_stock < critical_threshold:
            return Action.C
        if current_stock < endangered_threshold:
            recovery_probability = (current_stock - critical_threshold) / (endangered_threshold - critical_threshold)
            if random.random() < recovery_probability:
                return Action.C
            else:
                return Action.D
        opponent_coop_rate = self._calculate_opponent_cooperation_rate(history, current_round)
        if opponent_coop_rate >= 0.75:
            return Action.C
        if opponent_coop_rate < 0.25:
            return Action.D
        return Action.C

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the average cooperation rate of opponents up to current round.
        Recent rounds (last 3) count double.
        
        Args:
            history: PlayerHistory object containing opponent actions
            current_round: Current round number (0-indexed)
        
        Returns:
            Cooperation rate as a float between 0 and 1
        """
        if current_round == 0:
            return 0.0
        opponent_actions = history.opponent_actions[:current_round, :]
        weighted_cooperations = 0.0
        total_weight = 0.0
        for round_idx in range(current_round):
            rounds_ago = current_round - 1 - round_idx
            weight = 2.0 if rounds_ago < 3 else 1.0
            round_cooperations = np.sum(opponent_actions[round_idx, :])
            weighted_cooperations += round_cooperations * weight
            total_weight += self.n_players * weight
        if total_weight == 0:
            return 0.0
        cooperation_rate = weighted_cooperations / total_weight
        return cooperation_rate

class Strategy_COLLECTIVE_251(BaseStrategy):
    """
    Adaptive Stock Stewardship: A strategy that prioritizes long-term collective welfare
    in common pool resource games by dynamically adjusting cooperation based on stock health,
    depletion rates, and remaining rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        self.stock_history.append(state.current_stock)
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        stock_health = current_stock / capacity if capacity > 0 else 0.0
        if stock_health < 0.1:
            return Action.C
        if stock_health >= 0.99 and round_number <= 2:
            return Action.C
        stock_last_round = self.stock_history[-2] if len(self.stock_history) >= 2 else current_stock
        depletion_rate = 0.0
        if stock_last_round > 0:
            depletion_rate = (stock_last_round - current_stock) / stock_last_round
        depletion_rate = max(0.0, min(1.0, depletion_rate))
        rounds_remaining = total_rounds - round_number
        if rounds_remaining == 1:
            threshold = 0.95
        else:
            base_threshold = 0.4
            if depletion_rate > 0.75:
                base_threshold -= 0.25
            elif depletion_rate > 0.5:
                base_threshold -= 0.15
            threshold = base_threshold * (rounds_remaining / total_rounds)
            threshold = max(0.0, min(0.95, threshold))
        if stock_health > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_252(BaseStrategy):
    """
    Adaptive Stock-Preserving Cooperation (ASPC): A collective strategy that prioritizes
    long-term resource sustainability while maintaining reciprocal fairness and resilience
    to exploitation. Balances cooperation, stock health monitoring, and adaptive responses
    to defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_health = self._assess_stock_health(state.current_stock)
        recent_coop_rate = self._calculate_recent_cooperation_rate(history, state.round_number)
        action = self._decide_action(stock_health, recent_coop_rate, state.round_number)
        return action

    def _assess_stock_health(self, stock: float) -> str:
        """Classify stock into health categories."""
        if stock >= 0.75 * self.capacity:
            return 'STRONG'
        elif stock >= 0.4 * self.capacity:
            return 'MODERATE'
        elif stock >= 0.15 * self.capacity:
            return 'WEAK'
        else:
            return 'CRITICAL'

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate recent cooperation rate based on estimated defector count.
        Looks back k = min(3, current_round) rounds.
        Returns proportion of recent rounds where defectors <= n/2.
        """
        k = min(3, current_round)
        if k == 0:
            return 1.0
        cooperation_count = 0
        for round_idx in range(current_round - k, current_round):
            if round_idx < 0:
                continue
            cooperators = np.sum(history.opponent_actions[round_idx, :])
            defectors = self.n_players - 1 - cooperators
            if defectors <= self.n_players / 2:
                cooperation_count += 1
        return cooperation_count / k if k > 0 else 1.0

    def _decide_action(self, stock_health: str, recent_coop_rate: float, current_round: int) -> Action:
        """Apply decision tree logic based on stock health and cooperation rate."""
        is_final_round = current_round == self.n_rounds - 1
        if stock_health == 'CRITICAL':
            return Action.D
        elif stock_health == 'WEAK':
            if recent_coop_rate >= 0.5:
                return Action.C if random.random() < 0.6 else Action.D
            else:
                return Action.D
        elif stock_health == 'MODERATE':
            if recent_coop_rate >= 0.5:
                return Action.C
            elif recent_coop_rate >= 0.3:
                return Action.C if random.random() < 0.7 else Action.D
            else:
                return Action.D
        elif stock_health == 'STRONG':
            if is_final_round:
                if recent_coop_rate >= 0.5:
                    return Action.C
                else:
                    return Action.D
            elif recent_coop_rate >= 0.5:
                return Action.C
            else:
                return Action.C if random.random() < 0.5 else Action.D
        return Action.C

class Strategy_COLLECTIVE_253(BaseStrategy):
    """
    Adaptive Sustainability with Defensive Thresholds Strategy.
    
    Balances collective sustainability, individual resilience, and adaptive responsiveness
    by making decisions based on stock health, observed defection rates, and payoff ratios.
    Cooperates in early rounds and healthy states, defects in emergencies and final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        capacity = self.capacity
        n_rounds = self.n_rounds
        if round_num == 0:
            return Action.C
        if round_num == n_rounds - 1:
            return Action.D
        stock_health = stock / capacity if capacity > 0 else 0.0
        if stock_health < 0.2:
            return Action.D
        if stock_health < 0.4:
            defection_rate = self._calculate_recent_defection_rate(history, round_num)
            if defection_rate > 0.3:
                return Action.D
            else:
                return Action.C
        if stock_health >= 0.6:
            return Action.C
        c_payoff_avg = self._calculate_average_payoff_for_action(history, True)
        d_payoff_avg = self._calculate_average_payoff_for_action(history, False)
        if d_payoff_avg > 0:
            cooperation_success = c_payoff_avg / d_payoff_avg
        else:
            cooperation_success = 1.0 if c_payoff_avg > 0 else 0.5
        if cooperation_success > 0.75:
            return Action.C
        else:
            return Action.D

    def _calculate_recent_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the defection rate from opponents in recent rounds (up to 3 rounds back).
        Returns a value between 0 and 1.
        """
        if round_num == 0:
            return 0.0
        start_round = max(0, round_num - 3)
        end_round = round_num
        total_opponent_actions = 0
        total_defections = 0
        for r in range(start_round, end_round):
            opponent_actions_in_round = history.opponent_actions[r, :]
            total_opponent_actions += len(opponent_actions_in_round)
            total_defections += np.sum(~opponent_actions_in_round)
        if total_opponent_actions == 0:
            return 0.0
        return float(total_defections) / float(total_opponent_actions)

    def _calculate_average_payoff_for_action(self, history: PlayerHistory, action_is_cooperate: bool) -> float:
        """
        Calculate average payoff for rounds where I played a specific action.
        action_is_cooperate: True for cooperation (C), False for defection (D).
        Uses recent history (up to last 5 rounds).
        """
        my_actions = history.my_actions
        my_payoffs = history.my_payoffs
        start_idx = max(0, len(my_actions) - 5)
        matching_payoffs = []
        for idx in range(start_idx, len(my_actions)):
            if my_actions[idx] == action_is_cooperate:
                matching_payoffs.append(my_payoffs[idx])
        if len(matching_payoffs) == 0:
            return 0.0
        return float(np.mean(matching_payoffs))

class Strategy_COLLECTIVE_254(BaseStrategy):
    """
    Adaptive Stewardship with Defection Deterrence strategy for Common Pool Resource Game.
    
    Balances sustainable resource management with responsiveness to opponent defection.
    Cooperates initially and in crises, punishes systematic defection at moderate depletion,
    and defects in the final round (unless critically depleted).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        is_final_round = current_round == self.n_rounds - 1
        if is_final_round:
            if current_stock <= self.capacity * 0.25:
                return Action.C
            else:
                return Action.D
        k = min(3, current_round)
        defection_rate = self._calculate_opponent_defection_rate(history, k)
        if current_stock <= self.capacity * 0.25:
            return Action.C
        elif current_stock <= self.capacity * 0.5:
            if defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        elif defection_rate >= 0.75:
            return Action.D
        elif defection_rate >= 0.4:
            return Action.C
        else:
            return Action.C

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, k: int) -> float:
        """
        Calculate the defection rate of opponents over the last k rounds.
        
        Defection is encoded as False (0), Cooperation as True (1).
        So defection_rate = count of False values / total opponent actions in window.
        
        Args:
            history: PlayerHistory object containing opponent actions
            k: Number of recent rounds to consider
        
        Returns:
            Defection rate as a float between 0 and 1
        """
        if k <= 0:
            return 0.0
        current_round = history.opponent_actions.shape[0]
        start_round = max(0, current_round - k)
        recent_actions = history.opponent_actions[start_round:current_round, :]
        total_opponent_actions = recent_actions.size
        if total_opponent_actions == 0:
            return 0.0
        defections = np.sum(recent_actions == False)
        defection_rate = float(defections) / float(total_opponent_actions)
        return defection_rate

class Strategy_COLLECTIVE_255(BaseStrategy):
    """
    Adaptive Stock Guardian (ASG): A collective strategy that maximizes long-term shared welfare
    by maintaining resource stock health while defensively responding to widespread defection.
    
    Core logic:
    - Round 1: Always cooperate (set cooperative tone)
    - Last round: Cooperate if stock > 40% capacity, else follow standard logic
    - Standard logic: Cooperate if stock > 60% capacity, else defect only if >50% of players defected last round
    - Edge case: At zero stock, always cooperate (signal non-participation in resource destruction)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = 0.6 * self.capacity
        self.last_round_threshold = 0.4 * self.capacity
        self.defection_rate_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            if current_stock > self.last_round_threshold:
                return Action.C
        if current_stock == 0:
            return Action.C
        previous_round_idx = current_round - 1
        opponent_actions_previous = history.opponent_actions[previous_round_idx, :]
        num_defectors = np.sum(~opponent_actions_previous)
        defection_rate_previous = num_defectors / self.n_players
        if current_stock > self.critical_stock_threshold:
            return Action.C
        elif defection_rate_previous > self.defection_rate_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_256(BaseStrategy):
    """
    Adaptive Threshold Stewardship (ATS): Balances individual benefit-seeking with collective
    resource preservation through dynamic thresholds based on stock health and observed defection.
    
    Core mechanism: Cooperate when stock is fragile, allow measured defection when abundant,
    and adapt based on observed defector counts and game phase.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        health = current_stock / self.capacity if self.capacity > 0 else 0.0
        if round_number == 0:
            return Action.C
        observed_defectors = int(np.sum(~history.opponent_actions[round_number - 1, :]))
        capacity_safe_threshold = math.floor(self.n_players / 3)
        rounds_remaining = self.n_rounds - round_number
        if health < 0.15:
            return Action.C
        if rounds_remaining <= 2 and health > 0.5:
            if health > 0.65 or observed_defectors <= capacity_safe_threshold:
                return Action.D
            else:
                return Action.C
        if health >= 0.75:
            return Action.D
        elif health >= 0.5:
            if observed_defectors > capacity_safe_threshold:
                return Action.C
            else:
                return Action.D
        elif health >= 0.25:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_257(BaseStrategy):
    """
    Adaptive Stewardship with Defection Deterrence: A conditional cooperator strategy
    that balances resource preservation with punishment of over-exploitation.
    
    Core logic:
    - Cooperate by default to preserve the commons
    - Defect when stock falls below critical threshold (2.5n) or cooperation rate drops
    - Signal warnings through single-round defections when exploitation is detected
    - Recover to cooperation when conditions improve
    - Special handling for final round to maintain cooperative narrative
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 2.5 * self.n_players
        self.healthy_threshold = 0.5 * self.capacity
        self.cooperation_threshold = 0.6
        self.low_cooperation_threshold = 0.4
        self.recovery_cooperation_threshold = 0.5
        self.previous_defection_rate = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            if current_stock <= self.critical_threshold:
                return Action.D
            else:
                return Action.C
        if current_stock <= self.critical_threshold:
            return Action.D
        window_size = min(5, max(1, self.n_rounds // 3))
        start_idx = max(0, round_number - window_size)
        recent_opponent_actions = history.opponent_actions[start_idx:round_number, :]
        if recent_opponent_actions.size == 0:
            return Action.C
        total_opponent_actions = recent_opponent_actions.size
        cooperation_count = np.sum(recent_opponent_actions)
        cooperation_rate = float(cooperation_count) / float(total_opponent_actions) if total_opponent_actions > 0 else 1.0
        defection_count = total_opponent_actions - cooperation_count
        defection_rate = float(defection_count) / float(total_opponent_actions) if total_opponent_actions > 0 else 0.0
        defection_increasing = defection_rate > self.previous_defection_rate
        self.previous_defection_rate = defection_rate
        if current_stock >= self.healthy_threshold:
            if cooperation_rate >= self.cooperation_threshold:
                return Action.C
            elif defection_increasing:
                return Action.D
            else:
                return Action.C
        elif defection_rate >= self.low_cooperation_threshold:
            return Action.D
        elif cooperation_rate >= self.recovery_cooperation_threshold:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_258(BaseStrategy):
    """
    Collective Resilience Strategy (CRS) for Common Pool Resource Games.
    
    Maximizes collective welfare while remaining robust against exploitation by
    prioritizing stock sustainability. Uses stock-based thresholds and adaptive
    responses to opponent cooperation rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number - 1
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            if current_stock >= self.capacity * 0.5:
                return Action.C
            else:
                return Action.D
        threshold_high = self.capacity * (2.0 / 3.0)
        threshold_low = self.capacity * (1.0 / 3.0)
        threshold_medium = self.capacity * 0.5
        if current_stock >= threshold_high:
            return Action.C
        if current_stock < threshold_low:
            return Action.D
        last_round_opponent_actions = history.opponent_actions[-1, :]
        cooperation_count = np.sum(last_round_opponent_actions)
        cooperation_rate = cooperation_count / self.n_players
        if cooperation_rate >= 0.4:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_259(BaseStrategy):
    """
    Adaptive Conservation with Graduated Defection Deterrence.
    
    Balances individual payoff maximization with collective resource sustainability.
    Uses conditional cooperation based on stock health, defection rates, and rounds remaining.
    Applies graduated responses to encourage cooperation while protecting against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        current_round = state.round_number
        rounds_remaining = self.n_rounds - current_round
        health = self._assess_stock_health(current_stock)
        d_prev = self._calculate_previous_defection_rate(history, current_round)
        avg_defection = self._calculate_average_defection(history, current_round)
        base_threshold = 0.25 + rounds_remaining / self.n_rounds * 0.25
        if avg_defection > 0.4:
            threshold = base_threshold - 0.1
        else:
            threshold = base_threshold
        if rounds_remaining <= 3:
            return self._decide_final_phase(health, d_prev, current_stock)
        if health == 'HEALTHY' and d_prev <= threshold:
            return Action.C
        elif health == 'CRITICAL' and d_prev <= threshold - 0.15:
            return Action.C
        else:
            return Action.D

    def _assess_stock_health(self, stock: float) -> str:
        """Determine stock health category."""
        if stock > 0.6 * self.capacity:
            return 'HEALTHY'
        elif stock > 0.2 * self.capacity:
            return 'CRITICAL'
        else:
            return 'DEPLETED'

    def _calculate_previous_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """Calculate the proportion of players who defected in the previous round."""
        if current_round <= 1:
            return 0.0
        defections = np.sum(~history.opponent_actions[-1, :])
        return float(defections) / self.n_players

    def _calculate_average_defection(self, history: PlayerHistory, current_round: int) -> float:
        """Calculate running average of defection rates across all rounds."""
        if current_round <= 1:
            return 0.0
        total_defections = 0
        for round_idx in range(current_round):
            defections_in_round = np.sum(~history.opponent_actions[round_idx, :])
            total_defections += defections_in_round
        total_possible = current_round * self.n_players
        if total_possible == 0:
            return 0.0
        return float(total_defections) / total_possible

    def _decide_final_phase(self, health: str, d_prev: float, stock: float) -> Action:
        """Decision logic for the final 3 rounds."""
        if health == 'DEPLETED':
            return Action.D
        elif health == 'CRITICAL':
            if d_prev == 0.0:
                return Action.C
            else:
                return Action.D
        elif d_prev <= 0.125:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_260(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Response: A stock-aware strategy that cooperates
    when the commons can sustain it, matches collective cooperation levels with a lag,
    and defects strategically when stock is depleted or in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        coop_rate_prev = self._get_previous_cooperation_rate(history, round_number)
        if current_stock > self.capacity * 0.75:
            if random.random() < 0.8:
                return Action.C
            else:
                return Action.D
        if current_stock >= self.capacity * 0.4 and coop_rate_prev >= 0.5:
            return Action.C
        if current_stock < self.capacity * 0.4:
            if coop_rate_prev > 0.75:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _get_previous_cooperation_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the cooperation rate among all players in the previous round.
        Returns a float in [0, 1].
        """
        if round_number <= 0:
            return 0.0
        prev_round_idx = round_number - 1
        opponent_cooperators = int(sum(history.opponent_actions[prev_round_idx, :]))
        my_cooperators = int(history.my_actions[prev_round_idx])
        total_cooperators = opponent_cooperators + my_cooperators
        coop_rate = total_cooperators / self.n_players
        return coop_rate

class Strategy_COLLECTIVE_261(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    This strategy maximizes personal payoff while maintaining stock sustainability.
    It uses a stock-based threshold to decide between cooperation and defection:
    - Cooperate when stock is above a safe threshold (40% normally, 25% in final rounds)
    - Defect when stock is below threshold or critically depleted (≤5%)
    - Responds to empirical stock outcomes rather than individual opponent tracking
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.normal_threshold = self.capacity * 0.4
        self.final_threshold = self.capacity * 0.25
        self.critical_threshold = self.capacity * 0.05

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_stock <= self.critical_threshold:
            return Action.D
        if current_round >= self.n_rounds - 2:
            threshold = self.final_threshold
        else:
            threshold = self.normal_threshold
        if current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_262(BaseStrategy):
    """
    Collective Adaptive Resource Management Strategy (CARM)
    
    Prioritizes sustainable collective outcomes while maintaining individual competitiveness.
    Uses stock-dependent adaptive cooperation with three decision zones:
    - High stock (>60% capacity): Cooperate to sustain regeneration
    - Critical stock (≤20% capacity): Cooperate to preserve resource
    - Mid-range stock: Adapt based on observed defection rate in last 3 rounds
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.sustainable_threshold = game_description.capacity * 0.6
        self.critical_threshold = game_description.capacity * 0.2
        self.observation_window = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock = state.current_stock
        round_num = state.round_number
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if stock > self.sustainable_threshold:
            return Action.C
        if stock <= self.critical_threshold:
            return Action.C
        k = min(self.observation_window, round_num)
        defection_count = 0
        for i in range(round_num - k, round_num):
            defections_this_round = n_players - 1 - int(np.sum(history.opponent_actions[i, :]))
            defection_count += defections_this_round
        total_opponent_actions = k * (n_players - 1)
        if total_opponent_actions > 0:
            defection_rate = defection_count / total_opponent_actions
        else:
            defection_rate = 0.0
        if defection_rate > 0.5:
            return Action.D
        elif defection_rate <= 0.2:
            return Action.C
        elif random.random() < 1 - defection_rate:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_263(BaseStrategy):
    """
    Adaptive Stock-Aware Cooperation (ASAC): A collective strategy that maximizes
    total payoff by preserving the common pool resource through adaptive, 
    stock-dependent cooperation thresholds.
    
    Core rules:
    1. Always defect in the final round (subgame perfect)
    2. Defect if stock has collapsed (< capacity/4n)
    3. Otherwise, cooperate if stock >= threshold, where threshold declines over time
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock = state.current_stock
        if round_t == self.n_rounds - 1:
            return Action.D
        collapse_threshold = self.capacity / (4 * self.n_players)
        if stock < collapse_threshold:
            return Action.D
        threshold = self.capacity * (1.0 - 0.5 * round_t / self.n_rounds)
        if stock >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_264(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy that prioritizes
    long-term resource sustainability through stock-health-based decision rules
    and tally-based reciprocity in moderate conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_health = state.current_stock / self.capacity
        if stock_health >= 0.75:
            return Action.C
        if stock_health < 0.4:
            return Action.C
        return self._tally_based_decision(history)

    def _tally_based_decision(self, history: PlayerHistory) -> Action:
        """
        Evaluate defection rate of all other players and decide accordingly.
        """
        rounds_played = history.my_actions.shape[0]
        n_others = self.n_players - 1
        total_other_defections = np.sum(~history.opponent_actions[:rounds_played, :])
        total_other_actions = rounds_played * n_others
        if total_other_actions == 0:
            return Action.C
        defection_rate = total_other_defections / total_other_actions
        if defection_rate <= 0.25:
            return Action.C
        elif defection_rate <= 0.6:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_265(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS) for Common Pool Resource Games.
    
    Balances individual payoff maximization with long-term collective sustainability
    by adaptively shifting between cooperation and defection based on:
    - Stock health (resource depletion level)
    - Opponent behavior (cooperation rate)
    - Time horizon (rounds remaining)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        health_ratio = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        cooperation_rate = self._calculate_cooperation_rate(history)
        rounds_left = self.n_rounds - state.round_number
        if health_ratio < 0.3:
            return Action.C
        if health_ratio < 0.6:
            return Action.C
        if health_ratio >= 0.6 and cooperation_rate >= 0.7:
            return Action.C
        if health_ratio >= 0.6 and cooperation_rate < 0.5:
            return Action.D
        if health_ratio >= 0.6 and 0.5 <= cooperation_rate < 0.7:
            if rounds_left <= 2:
                return Action.D
            else:
                return Action.C
        return Action.C

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the observed cooperation rate from all opponents across all previous rounds.
        
        Returns:
            float: Cooperation rate in [0, 1]. Returns 0 if no history exists.
        """
        if history is None or history.opponent_actions.size == 0:
            return 0.0
        total_cooperations = np.sum(history.opponent_actions)
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.0
        return float(total_cooperations) / float(total_actions)

class Strategy_COLLECTIVE_266(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual benefit maximization with collective resource preservation
    through state-dependent conditional cooperation. Cooperates when stock health
    is sufficient, defects when resource is stressed or being depleted, with special
    handling for first/last rounds and critical depletion scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            self.stock_history = [current_stock]
        else:
            self.stock_history.append(current_stock)
        if round_number == self.n_rounds - 1:
            return Action.D
        if current_stock <= 2 * self.n_players:
            return Action.D
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        consecutive_declines = False
        if len(self.stock_history) >= 3:
            last_decline = self.stock_history[-1] < self.stock_history[-2]
            second_last_decline = self.stock_history[-2] < self.stock_history[-3]
            consecutive_declines = last_decline and second_last_decline
        if health_ratio < 0.3 and consecutive_declines:
            return Action.D
        if health_ratio < 0.5 and consecutive_declines:
            return Action.D
        if health_ratio >= 0.7:
            return Action.C
        sustainability_threshold = (2 * self.n_players - 1) / (2 * self.n_players)
        if health_ratio >= sustainability_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_267(BaseStrategy):
    """
    Adaptive Stewardship with Threshold Triggers
    
    Prioritizes long-term collective resource sustainability while maintaining individual viability.
    Uses stock-responsive thresholds, deficit recovery triggers, and endgame extraction to balance
    cooperation and individual payoff across repeated rounds of a common pool resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.previous_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        remaining_rounds = self.n_rounds - current_round
        if current_round == 0:
            return Action.C
        if current_round >= self.n_rounds - 2:
            if current_stock > 0:
                return Action.D
            else:
                return Action.C
        if history is not None and current_round > 0:
            previous_stock = history.my_payoffs[current_round - 1]
            self.previous_stock = current_stock
        if current_stock < self.capacity * 0.25 and remaining_rounds > 3:
            return Action.C
        adjustment_factor = 0.45
        base_threshold = self.capacity * (remaining_rounds / self.n_rounds) * adjustment_factor
        stock_decline = self.previous_stock - current_stock
        critical_decline = self.capacity * 0.15
        if stock_decline > critical_decline:
            threshold = base_threshold * 1.2
        else:
            threshold = base_threshold
        if current_stock >= threshold:
            self.previous_stock = current_stock
            return Action.C
        else:
            self.previous_stock = current_stock
            return Action.D

class Strategy_COLLECTIVE_268(BaseStrategy):
    """
    Adaptive Stock-Preserving Cooperation (ASPC) Strategy
    
    A collectively-minded strategy for common pool resource games that:
    - Defaults to cooperation to maintain stock sustainability
    - Punishes excessive defection by other players
    - Switches to pure cooperation during stock crises
    - Defects opportunistically in the final round (if stock is safe)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.danger_threshold = self.capacity * 0.15
        self.tolerance_threshold = (1.0 - 1.0 / self.n_players) * 0.6
        self.max_lookback_window = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        defection_rate = self._calculate_recent_defection_rate(history, current_round)
        if stock <= self.danger_threshold:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if defection_rate > self.tolerance_threshold:
            return Action.D
        return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the proportion of opponent defections in recent rounds.
        Uses a lookback window of min(3, current_round) rounds.
        """
        lookback_window = min(self.max_lookback_window, current_round)
        if lookback_window == 0:
            return 0.0
        start_idx = current_round - lookback_window
        recent_opponent_actions = history.opponent_actions[start_idx:current_round, :]
        total_actions = recent_opponent_actions.size
        total_cooperations = np.sum(recent_opponent_actions)
        total_defections = total_actions - total_cooperations
        if total_actions == 0:
            return 0.0
        defection_rate = total_defections / total_actions
        return defection_rate

class Strategy_COLLECTIVE_269(BaseStrategy):
    """
    Adaptive Stewardship with Proportional Reciprocity strategy for Common Pool Resource Game.
    
    Maximizes collective long-term payoffs by maintaining stock sustainability while adapting
    to opponent defection. Uses stock-conditional cooperation with graduated defection responses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.last_defection_buffer = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock = state.current_stock
        round_num = state.round_number
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio < 0.05:
            return Action.D
        defection_count = np.sum(~history.opponent_actions[round_num - 1, :])
        defection_rate = defection_count / self.n_players
        if round_num >= 2:
            recent_window = min(3, round_num)
            consistency_variance = 0.0
            for i in range(1, recent_window):
                prev_defect_rate = np.sum(~history.opponent_actions[round_num - i, :]) / self.n_players
                consistency_variance += abs(prev_defect_rate - defection_rate)
            if consistency_variance > 0.3:
                defection_rate = min(1.0, defection_rate + 0.1)
        if stock_ratio >= 0.6:
            health_status = 'HEALTHY'
        elif stock_ratio >= 0.3:
            health_status = 'VULNERABLE'
        else:
            health_status = 'CRITICAL'
        if round_num == self.n_rounds - 1:
            if stock_ratio >= 0.5 and defection_rate <= 0.3:
                return Action.C
        if health_status == 'CRITICAL':
            self.last_defection_buffer = 0.1
            return Action.D
        if health_status == 'HEALTHY':
            adjusted_defection_rate = defection_rate - self.last_defection_buffer
            if adjusted_defection_rate <= 0.2:
                self.last_defection_buffer = 0.0
                return Action.C
            elif adjusted_defection_rate <= 0.5:
                self.last_defection_buffer = 0.0
                return Action.C
            else:
                self.last_defection_buffer = 0.1
                return Action.D
        if health_status == 'VULNERABLE':
            adjusted_defection_rate = defection_rate - self.last_defection_buffer
            if adjusted_defection_rate <= 0.3:
                self.last_defection_buffer = 0.0
                return Action.C
            else:
                self.last_defection_buffer = 0.1
                return Action.D
        self.last_defection_buffer = 0.0
        return Action.C

class Strategy_COLLECTIVE_270(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual payoff maximization with collective resource sustainability.
    Uses stock-based thresholds, trend detection, and round-dependent adjustments
    to prevent tragedy of the commons while exploiting opportunities when safe.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.safe_threshold = self.capacity * (1 + 1 / self.n) / (2 * self.n)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if stock < self.capacity / 10:
            return Action.C
        if round_num == self.r - 1:
            return Action.D
        if round_num == 0:
            return Action.D
        if stock > self.safe_threshold:
            action = Action.D
        else:
            action = Action.C
        if round_num >= 3 and history is not None:
            recent_stocks = self._get_recent_stocks(history, round_num)
            if self._is_declining(recent_stocks):
                my_recent_defects = self._count_recent_defects(history, round_num)
                if my_recent_defects > 1:
                    action = Action.C
        if round_num > self.r / 2 and history is not None:
            if self._stock_remained_healthy(history, round_num):
                action = Action.D
            else:
                action = Action.C
        return action

    def _get_recent_stocks(self, history: PlayerHistory, round_num: int) -> list:
        """Extract stock levels from last 3 rounds using payoff data."""
        start_idx = max(0, round_num - 3)
        recent_rounds = list(range(start_idx, round_num))
        return recent_rounds

    def _is_declining(self, recent_stocks: list) -> bool:
        """Check if stock trajectory shows decline over recent rounds."""
        if len(recent_stocks) < 2:
            return False
        return len(recent_stocks) >= 3

    def _count_recent_defects(self, history: PlayerHistory, round_num: int) -> int:
        """Count player's defections in last 3 rounds."""
        start_idx = max(0, round_num - 3)
        end_idx = round_num
        recent_actions = history.my_actions[start_idx:end_idx]
        defect_count = sum((1 for action in recent_actions if not action))
        return defect_count

    def _stock_remained_healthy(self, history: PlayerHistory, round_num: int) -> bool:
        """Check if stock has remained above safe threshold throughout game so far."""
        if round_num < 2:
            return True
        my_payoffs = history.my_payoffs[:round_num]
        avg_payoff = float(np.mean(my_payoffs)) if len(my_payoffs) > 0 else 0
        baseline = self.capacity / (2 * self.n)
        return avg_payoff > baseline * 0.7

class Strategy_COLLECTIVE_271(BaseStrategy):
    """
    Adaptive Stock-Preserving Reciprocity (ASPR): A strategy that prioritizes
    common pool sustainability while adapting to observed defection rates and
    stock trajectories. Cooperates when stock is healthy, conditionally defects
    under stress, and always defects when the pool is critical.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        shi = current_stock / self.capacity if self.capacity > 0 else 0.0
        if round_number == 0:
            return Action.C
        dr = self._calculate_defection_rate(history, round_number)
        stock_trending_up = self._is_stock_trending_up(history, round_number)
        if round_number == self.n_rounds - 1:
            if shi >= 0.6:
                return Action.C
            else:
                return Action.D
        if shi >= 0.75:
            return Action.C
        if shi >= 0.5:
            if dr >= 0.5:
                return Action.D
            else:
                return Action.C
        if shi >= 0.25:
            if stock_trending_up and dr < 0.25:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the defection rate from observed opponent actions.
        DR = total_defections_observed / total_opponent_actions_observed
        """
        if round_number <= 0:
            return 0.25
        opponent_actions_so_far = history.opponent_actions[:round_number, :]
        defections = np.sum(~opponent_actions_so_far)
        total_actions = opponent_actions_so_far.size
        if total_actions == 0:
            return 0.25
        dr = defections / total_actions
        return dr

    def _is_stock_trending_up(self, history: PlayerHistory, round_number: int) -> bool:
        """
        Determine if stock is trending upward by comparing stock across rounds.
        We infer stock from payoff aggregates: higher payoffs suggest higher stock.
        
        Since we don't have direct stock history, we use a proxy:
        Compare sum of payoffs in recent rounds to detect trend.
        
        Simpler approach: if we're in round >= 2, check if total payoffs
        are increasing on average.
        """
        if round_number < 2:
            return True
        last_round_payoff = np.mean(history.my_payoffs[round_number - 1])
        prev_round_payoff = np.mean(history.my_payoffs[round_number - 2])
        return last_round_payoff > prev_round_payoff

class Strategy_COLLECTIVE_272(BaseStrategy):
    """
    Adaptive Stewardship with Defection Deterrence.
    
    Balances long-term collective resource sustainability with individual competitiveness.
    Cooperates by default to preserve the commons, detects defection waves, and escalates
    graduated responses to punish free-riding while keeping the door open for cooperation recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_escalation_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.C
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if health_ratio < 0.25:
            self.defection_escalation_count = 0
            return Action.C
        window = max(3, self.n_rounds // 4)
        recent_defection_rate = self._calculate_recent_defection_rate(history, window)
        stock_trend = self._calculate_stock_trend(history)
        if round_num == self.n_rounds - 1:
            self.defection_escalation_count = 0
            return Action.D if current_stock > 0 else Action.C
        if round_num == self.n_rounds - 2:
            if recent_defection_rate > 0.5:
                self.defection_escalation_count = 0
                return Action.C if current_stock > 0.6 * self.capacity else Action.D
            else:
                self.defection_escalation_count = 0
                return Action.C
        if recent_defection_rate > 0.6:
            if health_ratio >= 0.5:
                self.defection_escalation_count = 1
                return Action.D
            elif self.defection_escalation_count > 0:
                self.defection_escalation_count += 1
                return Action.D if self.defection_escalation_count <= 2 else Action.C
            else:
                self.defection_escalation_count = 1
                return Action.D
        if 0.4 <= recent_defection_rate <= 0.6 and stock_trend < -0.05 and (health_ratio < 0.5):
            if self.defection_escalation_count == 0:
                self.defection_escalation_count = 1
                return Action.D
            else:
                self.defection_escalation_count = 0
                return Action.C
        if recent_defection_rate <= 0.4:
            self.defection_escalation_count = 0
        return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory, window: int) -> float:
        """
        Calculate the proportion of opponents who played D in recent rounds.
        Returns value between 0 and 1.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        start_idx = max(0, len(history.opponent_actions) - window)
        recent_actions = history.opponent_actions[start_idx:]
        if len(recent_actions) == 0:
            return 0.0
        total_actions = recent_actions.size
        defection_count = np.sum(recent_actions == False)
        return float(defection_count) / float(total_actions) if total_actions > 0 else 0.0

    def _calculate_stock_trend(self, history: PlayerHistory) -> float:
        """
        Calculate stock trend over recent rounds.
        Returns normalized change: (recent_stock - past_stock) / capacity
        """
        if history is None or len(history.my_payoffs) < 3:
            return 0.0
        if len(history.my_payoffs) < 2:
            return 0.0
        recent_payoff = history.my_payoffs[-1]
        past_payoff = history.my_payoffs[-3] if len(history.my_payoffs) >= 3 else history.my_payoffs[0]
        payoff_trend = (recent_payoff - past_payoff) / max(self.capacity / (2 * self.n_players), 1e-06)
        return max(-1.0, min(1.0, payoff_trend))

class Strategy_COLLECTIVE_273(BaseStrategy):
    """
    Adaptive Sustainability Strategy (ASS) for Common Pool Resource Game.
    
    Balances individual payoff maximization with collective sustainability by:
    1. Cooperating when stock is healthy (sustainability_ratio >= 0.5)
    2. Detecting widespread defection and adapting response
    3. Defecting only when commons is critically depleted or defection is rampant
    4. Adjusting behavior in final rounds to prioritize immediate gains
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        sustainability_ratio = current_stock / self.capacity if self.capacity > 0 else 1.0
        if current_round == 0:
            return Action.C
        if sustainability_ratio < 0.1:
            return Action.D
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= 2:
            if sustainability_ratio >= 0.6:
                return Action.C
            else:
                return Action.D
        defection_rate = self._calculate_defection_rate(history, current_round)
        if sustainability_ratio >= 0.5:
            return Action.C
        elif sustainability_ratio >= 0.2:
            exploitation_threshold = 0.5
            if defection_rate > exploitation_threshold:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the observed defection rate from recent rounds.
        Uses up to the last 5 rounds or all available history.
        
        Returns: fraction of defections observed (0.0 to 1.0)
        """
        if current_round <= 0 or history is None:
            return 0.0
        lookback = min(5, current_round)
        recent_actions = history.opponent_actions[-lookback:, :]
        total_observations = recent_actions.size
        if total_observations == 0:
            return 0.0
        defection_count = np.sum(recent_actions == False)
        defection_rate = float(defection_count) / float(total_observations)
        return defection_rate

class Strategy_COLLECTIVE_274(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy that prioritizes
    long-term sustainability of the common pool resource over short-term gains.
    
    Core mechanism: Adapts behavior based on stock health thresholds, rounds remaining,
    and detection of collective overexploitation (death spiral).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.danger_threshold = 0.3 * self.capacity
        self.safe_threshold = 0.7 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            return Action.C
        if rounds_remaining == 0:
            return Action.D
        if rounds_remaining <= 2:
            return Action.D
        if len(history.my_payoffs) >= 2:
            stock_history = self._extract_stock_history(history, current_stock)
            if len(stock_history) >= 3:
                if stock_history[0] < stock_history[1] and stock_history[1] < stock_history[2]:
                    return Action.C
        if current_stock < 0.01:
            return Action.D
        if current_stock <= self.danger_threshold:
            return Action.C
        elif current_stock >= self.safe_threshold:
            if rounds_remaining <= self.n_rounds / 3:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

    def _extract_stock_history(self, history: PlayerHistory, current_stock: float) -> list:
        """
        Reconstruct stock levels from payoff history.
        
        Payoff in round t with current stock S:
        - If cooperated: payoff = S / (2n)
        - If defected: payoff = S / n
        
        We can infer the stock at the start of each round from payoffs and actions.
        This is approximate but provides death spiral detection.
        """
        stock_history = [current_stock]
        if len(history.my_payoffs) > 0:
            last_payoff = history.my_payoffs[-1]
            last_action = history.my_actions[-1]
            if last_action:
                inferred_stock = last_payoff * 2 * self.n_players
            else:
                inferred_stock = last_payoff * self.n_players
            stock_history.insert(0, inferred_stock)
        return stock_history

class Strategy_COLLECTIVE_275(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A strategy that balances individual gain with 
    collective sustainability in common pool resource games.
    
    Core principle: Cooperate by default to maintain sustainable stock levels, but defect
    when stock health deteriorates or defection becomes endemic among other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainability_threshold = self.capacity * (1.0 - 1.0 / self.n_players)
        self.epidemic_threshold = math.ceil(self.n_players / 3.0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        if current_stock < self.sustainability_threshold:
            return Action.D
        defections_last_round = np.sum(~history.opponent_actions[round_number - 1, :])
        if defections_last_round > self.epidemic_threshold:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_276(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual security with collective sustainability by responding to stock levels
    rather than opponent actions. Uses stock-responsive cooperation with probabilistic transitions
    in the middle band, cascade detection, and recovery signal adaptation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_rounds
        self.n_rounds = game_description.n_rounds
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        self.stock_history.append(current_stock)
        if round_num == 0:
            return Action.C
        threshold = self._get_threshold()
        cascade_multiplier = self._get_cascade_multiplier()
        if current_stock >= threshold * self.capacity:
            return Action.C
        elif current_stock < 0.4 * self.capacity:
            return Action.D
        else:
            return self._probabilistic_decision(current_stock, threshold, cascade_multiplier)

    def _get_threshold(self) -> float:
        """
        Determine threshold based on recovery signals.
        If stock increased in last round, use lower threshold (0.65).
        Otherwise use default threshold (0.75).
        """
        if len(self.stock_history) >= 2:
            if self.stock_history[-1] > self.stock_history[-2]:
                return 0.65
        return 0.75

    def _get_cascade_multiplier(self) -> float:
        """
        Detect rapid stock depletion (>20% decline) and increase defection probability.
        Returns multiplier for transition probability.
        """
        if len(self.stock_history) < 2:
            return 1.0
        previous_stock = self.stock_history[-2]
        current_stock = self.stock_history[-1]
        if previous_stock == 0:
            return 1.0
        decline_rate = (previous_stock - current_stock) / previous_stock
        if decline_rate > 0.2:
            return 1.15
        return 1.0

    def _probabilistic_decision(self, current_stock: float, threshold: float, cascade_multiplier: float) -> Action:
        """
        Make probabilistic decision in the middle band (40% to threshold*capacity).
        Probability of cooperation increases with stock level.
        """
        lower_bound = 0.4 * self.capacity
        upper_bound = threshold * self.capacity
        band_width = upper_bound - lower_bound
        if band_width <= 0:
            return Action.C
        transition_prob = (current_stock - lower_bound) / band_width
        transition_prob *= cascade_multiplier
        transition_prob = min(transition_prob, 1.0)
        if random.random() < transition_prob:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_277(BaseStrategy):
    """
    Adaptive Stock Stewardship Strategy (ASS)
    
    Balances individual payoff maximization with collective sustainability by:
    1. Cooperating in round 1 to establish goodwill and maximize growth
    2. Defecting in the final round (backward induction)
    3. Monitoring stock health and defection rates in middle rounds
    4. Cooperating when stock is healthy (≥70% capacity)
    5. Defecting when stock is critical (<30% capacity)
    6. In the danger zone (30-70%), cooperating if defection rate ≤40%, else defecting
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        stock_ratio = current_stock / capacity if capacity > 0 else 0.0
        if stock_ratio >= 0.7:
            return Action.C
        if stock_ratio < 0.3:
            return Action.D
        prev_round_idx = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        num_defectors = np.sum(~opponent_actions_prev)
        defection_rate = num_defectors / n_players if n_players > 0 else 0.0
        tolerance_threshold = 0.4
        if defection_rate <= tolerance_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_278(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS) - A collective sustainability strategy for common pool resource games.
    
    Core philosophy: Maintain stock health across all rounds by cooperating when sustainable,
    adapting to observed cooperation rates, and gracefully degrading when stock is depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.C
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if current_stock < self.capacity / 6:
            return Action.D
        observed_coop_rate = self._calculate_cooperation_rate(history, round_num)
        if round_num == 1:
            if observed_coop_rate >= 0.75:
                return Action.C
            elif observed_coop_rate >= 0.5:
                return Action.C
        if round_num == self.n_rounds - 1:
            if stock_ratio >= 0.4:
                return Action.C
            else:
                return Action.D
        r_remaining = self.n_rounds - round_num
        if r_remaining > self.n_rounds / 3:
            base_threshold = 0.5
            coop_bonus = 0.3
        else:
            base_threshold = 0.3
            coop_bonus = 0.4
        sustainability_threshold = base_threshold + coop_bonus * observed_coop_rate
        if round_num >= 3:
            avg_decline = self._calculate_average_stock_decline(history, round_num)
            if avg_decline > self.capacity / 10:
                sustainability_threshold = max(0.0, sustainability_threshold - 0.15)
        if stock_ratio >= sustainability_threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the observed cooperation rate from all other players in previous rounds.
        Returns a value between 0.0 and 1.0.
        """
        if round_num == 0 or history is None:
            return 1.0
        total_c_count = 0
        total_actions = 0
        for past_round in range(round_num):
            for player_idx in range(self.n_players - 1):
                total_c_count += int(history.opponent_actions[past_round, player_idx])
                total_actions += 1
        if total_actions == 0:
            return 1.0
        return total_c_count / total_actions

    def _calculate_average_stock_decline(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate average stock decline over the last 3 rounds.
        Returns the average amount of stock lost per round.
        """
        if round_num < 3 or history is None:
            return 0.0
        recent_rounds = min(3, round_num)
        if recent_rounds < 3:
            return 0.0
        recent_payoffs = history.my_payoffs[-3:]
        if len(recent_payoffs) >= 2:
            first_payoff = recent_payoffs[0]
            last_payoff = recent_payoffs[-1]
            if first_payoff > 0:
                decline = (first_payoff - last_payoff) / 3
                estimated_decline = decline * (self.capacity / (self.capacity / (2 * self.n_players)))
                return max(0.0, estimated_decline)
        return 0.0

class Strategy_COLLECTIVE_279(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Defection: A stock-conscious, defection-aware,
    time-aware strategy that cooperates when sustainable, defects when necessary, and
    preserves collective welfare through resource-based decision rules.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        total_rounds = self.n_rounds
        rounds_remaining = total_rounds - round_num
        if round_num == 0:
            if self.n_players > 10 and self.capacity / self.n_players < 2.5:
                return Action.D
            return Action.C
        if round_num == total_rounds - 1:
            if current_stock >= 0.4 * self.capacity:
                return Action.C
            return Action.D
        defection_rate = self._calculate_defection_rate(history)
        if defection_rate > 0.6:
            return Action.D
        threshold = self.capacity * (0.5 + 0.3 * (rounds_remaining / total_rounds))
        if current_stock >= threshold:
            return Action.C
        return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the defection rate (proportion of defectors) over the last k rounds.
        k = min(3, rounds_played)
        
        Defection is encoded as False (0), Cooperation as True (1).
        So a defector has value False, and we count those.
        """
        rounds_played = history.opponent_actions.shape[0]
        k = min(3, rounds_played)
        recent_actions = history.opponent_actions[-k:, :]
        total_actions = k * self.n_players
        total_defections = total_actions - np.sum(recent_actions)
        if total_actions == 0:
            return 0.0
        defection_rate = float(total_defections) / float(total_actions)
        return defection_rate

class Strategy_COLLECTIVE_280(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy that prioritizes
    long-term resource sustainability by adjusting cooperation based on stock
    health, round position, and detected defection trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            self.previous_stock = current_stock
            return Action.C
        stock_trend = current_stock - self.previous_stock
        self.previous_stock = current_stock
        if stock_trend < -0.2 * capacity:
            return Action.D
        if stock_trend > 0.1 * capacity:
            return Action.C
        rounds_remaining = n_rounds - current_round
        if rounds_remaining <= 2:
            threshold_high = 0.6 * capacity
            threshold_mid = 0.35 * capacity
            threshold_low = 0.1 * capacity
        else:
            threshold_high = 0.75 * capacity
            threshold_mid = 0.5 * capacity
            threshold_low = 0.25 * capacity
        if rounds_remaining > n_rounds / 2 and current_stock >= 0.9 * capacity:
            return Action.C
        if current_stock >= threshold_high:
            return Action.C
        elif current_stock >= threshold_mid:
            return Action.C
        elif current_stock >= threshold_low:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_281(BaseStrategy):
    """
    Adaptive Stewardship with Contingent Defection.
    
    Cooperates by default to sustain the common pool resource, but defects
    conditionally when: (1) others are already defecting, (2) stock falls
    critically low, or (3) it's the final round. Recovers cooperation when
    conditions improve.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 0.3 * self.capacity
        self.recovery_threshold = 0.5 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == self.r - 1:
            return Action.D
        if current_stock < self.critical_threshold:
            return Action.D
        if round_num == 0:
            return Action.C
        previous_stock = state.current_stock
        if round_num > 0:
            if round_num >= 2:
                pass
        if round_num > 0:
            previous_round_idx = round_num - 1
            my_action_prev = history.my_actions[previous_round_idx]
            opponent_actions_prev = history.opponent_actions[previous_round_idx, :]
            my_payoff_prev = history.my_payoffs[previous_round_idx]
            if my_action_prev:
                if my_payoff_prev > 0:
                    stock_before_prev = my_payoff_prev * 2 * self.n
                else:
                    stock_before_prev = 0.0
            elif my_payoff_prev > 0:
                stock_before_prev = my_payoff_prev * self.n
            else:
                stock_before_prev = 0.0
            num_opponent_cooperators = int(np.sum(opponent_actions_prev))
            num_opponent_defectors = self.n - 1 - num_opponent_cooperators
            expected_consumption_if_all_coop = (self.n - 1) * stock_before_prev / (2 * self.n)
            my_consumption_prev = my_payoff_prev
            actual_opponent_consumption = num_opponent_cooperators * stock_before_prev / (2 * self.n) + num_opponent_defectors * stock_before_prev / self.n
            if actual_opponent_consumption > expected_consumption_if_all_coop and num_opponent_defectors > 0:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_282(BaseStrategy):
    """
    Adaptive Stock-Aware Stewardship (ASAS): A collective strategy that maintains
    common pool health by dynamically adjusting cooperation based on stock levels,
    defection detection, and endgame considerations.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.capacity
        rounds_remaining = self.n_rounds - state.round_number
        recent_coop_rate = self._get_recent_coop_rate(history)
        if stock_ratio > 0.75:
            return Action.C
        if stock_ratio > 0.4:
            p_adapt = (stock_ratio - 0.4) / 0.35
            if recent_coop_rate < 0.4 and stock_ratio > 0.2:
                p_adapt = max(0.0, p_adapt - 0.15)
            return Action.C if random.random() < p_adapt else Action.D
        if stock_ratio > 0.2:
            if rounds_remaining > 3:
                return Action.C
            else:
                return Action.D
        if stock_ratio > 0.05:
            if state.round_number >= 1:
                prev_stock = self._get_previous_stock(history)
                stock_increased = state.current_stock > prev_stock
                if stock_increased:
                    return Action.C
            coop_rate = recent_coop_rate
            if coop_rate < 0.4:
                return Action.D
            else:
                return Action.C
        return Action.D

    def _get_recent_coop_rate(self, history: PlayerHistory) -> float:
        """
        Calculate cooperation rate of opponents in the most recent 3 rounds.
        """
        rounds_played = history.my_actions.shape[0]
        window_size = min(3, rounds_played)
        if window_size == 0:
            return 1.0
        recent_actions = history.opponent_actions[-window_size:, :]
        total_cooperations = np.sum(recent_actions)
        total_actions = window_size * self.n_players
        if total_actions == 0:
            return 1.0
        coop_rate = total_cooperations / total_actions
        return float(coop_rate)

    def _get_previous_stock(self, history: PlayerHistory) -> float:
        """
        Estimate the previous round's stock level based on current consumption.
        This is approximate since we don't have direct stock history.
        """
        if history.my_actions.shape[0] < 2:
            return self.capacity
        two_rounds_ago_idx = -2
        my_action = history.my_actions[two_rounds_ago_idx]
        opponent_actions = history.opponent_actions[two_rounds_ago_idx, :]
        n_cooperators = int(my_action) + np.sum(opponent_actions)
        n_defectors = self.n_players - n_cooperators
        return self.capacity

class Strategy_COLLECTIVE_283(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection strategy for Common Pool Resource Game.
    
    Balances collective welfare maximization with resilience to exploitation through:
    - Cooperation by default to preserve shared resources
    - Adaptive response to observed defection rates
    - Last-round defection (subgame optimal)
    - Stock health monitoring to prevent resource collapse
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_low = 0.25
        self.threshold_high = 0.6
        self.threshold_critical = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        rounds_remaining = self.game_description.n_rounds - state.round_number
        min_required_per_round = state.current_stock / rounds_remaining if rounds_remaining > 0 else float('inf')
        critical_threshold = 2 * self.game_description.n_players
        if state.current_stock < critical_threshold:
            return Action.D
        if state.current_stock < critical_threshold * rounds_remaining:
            sustainable_coop_consumption = state.current_stock / 2
            remaining_rounds_needed = rounds_remaining - 1
            if remaining_rounds_needed > 0:
                required_per_remaining_round = state.current_stock / remaining_rounds_needed
                if sustainable_coop_consumption < required_per_remaining_round:
                    return Action.D
        if state.round_number == 0:
            return Action.C
        observed_defection_rate = self._calculate_observed_defection_rate(history)
        if observed_defection_rate > self.threshold_critical:
            return Action.D
        if observed_defection_rate > self.threshold_high:
            if random.random() < observed_defection_rate:
                return Action.D
            else:
                return Action.C
        if observed_defection_rate < self.threshold_low:
            return Action.C
        if self._is_defection_trend_increasing(history):
            return Action.D
        else:
            return Action.C

    def _calculate_observed_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate observed defection rate from opponent actions.
        Uses all history with slight weighting toward recent rounds.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.5
        n_opponents = history.opponent_actions.shape[1]
        n_rounds_observed = history.opponent_actions.shape[0]
        if n_opponents == 0 or n_rounds_observed == 0:
            return 0.5
        total_cooperations = np.sum(history.opponent_actions)
        total_actions = n_opponents * n_rounds_observed
        cooperation_rate = total_cooperations / total_actions if total_actions > 0 else 0.5
        defection_rate = 1.0 - cooperation_rate
        return float(defection_rate)

    def _is_defection_trend_increasing(self, history: PlayerHistory) -> bool:
        """
        Check if the recent defection trend is increasing.
        Compare recent rounds against earlier rounds.
        """
        if history is None or len(history.opponent_actions) < 2:
            return False
        n_rounds = history.opponent_actions.shape[0]
        n_opponents = history.opponent_actions.shape[1]
        if n_opponents == 0:
            return False
        split_point = max(1, n_rounds // 2)
        early_cooperations = np.sum(history.opponent_actions[:split_point, :])
        early_total = split_point * n_opponents
        early_defection_rate = 1.0 - (early_cooperations / early_total if early_total > 0 else 0.5)
        recent_cooperations = np.sum(history.opponent_actions[split_point:, :])
        recent_total = (n_rounds - split_point) * n_opponents
        recent_defection_rate = 1.0 - (recent_cooperations / recent_total if recent_total > 0 else 0.5)
        return recent_defection_rate > early_defection_rate + 0.1

class Strategy_COLLECTIVE_284(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy that maximizes long-term aggregate welfare
    by maintaining the common pool while adapting defensively based on stock health and defection patterns.
    
    Core logic:
    - HEALTHY (stock ≥ 0.75*capacity): COOPERATE
    - VULNERABLE (0.40*capacity ≤ stock < 0.75*capacity): Conditional (Tit-for-Tat on defection rate)
    - CRITICAL (0 < stock < 0.40*capacity): DEFECT
    - COLLAPSED (stock = 0): DEFECT
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if current_stock >= 0.75 * self.capacity:
            stock_state = 'HEALTHY'
        elif current_stock >= 0.4 * self.capacity:
            stock_state = 'VULNERABLE'
        elif current_stock > 0:
            stock_state = 'CRITICAL'
        else:
            stock_state = 'COLLAPSED'
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            if stock_state == 'HEALTHY':
                return Action.C
            elif stock_state == 'VULNERABLE':
                defection_rate = self._get_defection_rate(history, round_number - 1)
                if defection_rate >= 0.5:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D
        if stock_state == 'HEALTHY':
            return Action.C
        elif stock_state == 'VULNERABLE':
            defection_rate = self._get_defection_rate(history, round_number - 1)
            if defection_rate >= 0.5:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _get_defection_rate(self, history: PlayerHistory, round_idx: int) -> float:
        """
        Calculate the defection rate (fraction of opponents who defected) in a given round.
        Defection is encoded as False (0), Cooperation as True (1).
        """
        if round_idx < 0 or round_idx >= len(history.opponent_actions):
            return 0.0
        actions_in_round = history.opponent_actions[round_idx, :]
        num_defectors = np.sum(~actions_in_round)
        if self.n_players == 0:
            return 0.0
        defection_rate = float(num_defectors) / float(self.n_players)
        return defection_rate

class Strategy_COLLECTIVE_285(BaseStrategy):
    """
    Collective Adaptive Resource Stewardship Strategy (CARS)
    
    Balances individual payoff maximization with collective sustainability by:
    - Cooperating in early rounds to establish prosocial baseline
    - Defecting when stock approaches dangerous levels (survival instinct)
    - Reciprocating defection when escalation threshold is crossed
    - Defecting in final round only if defection is widespread
    - Defaulting to cooperation to promote collective welfare
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.danger_threshold = 0.15 * self.capacity
        self.safe_threshold = 0.5 * self.capacity
        self.escalation_threshold = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        current_round = state.round_number
        if current_stock < self.danger_threshold:
            return Action.C
        last_round_idx = current_round - 1
        opponent_actions_last_round = history.opponent_actions[last_round_idx, :]
        defection_count = self.n_players - int(np.sum(opponent_actions_last_round))
        defection_rate = defection_count / self.n_players if self.n_players > 0 else 0.0
        if defection_rate > self.escalation_threshold:
            return Action.D
        if current_round == self.n_rounds - 1:
            if defection_rate > 0.4:
                return Action.D
            else:
                return Action.C
        if current_stock >= self.safe_threshold:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_286(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Reciprocity: A collective strategy that balances
    individual resilience against defection with collective long-term sustainability.
    Cooperates when stock is healthy and defection levels are acceptable, defects when
    resources are scarce or majority defection is observed.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        rounds_remaining = self.n_rounds - current_round
        if current_stock <= 0.2 * self.capacity:
            return Action.D
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < 0.6 * self.capacity:
            return Action.D
        if rounds_remaining <= 3:
            if current_stock < 0.7 * self.capacity:
                return Action.D
        last_round_idx = current_round - 1
        defectors_last_round = int(np.sum(~history.opponent_actions[last_round_idx, :]))
        proportion_defectors = defectors_last_round / self.n_players
        base_tolerance = min(0.5, 1.0 - 1.0 / self.n_players)
        if current_stock >= 0.95 * self.capacity:
            defection_tolerance = min(0.65, 1.2 - 1.0 / self.n_players)
        else:
            defection_tolerance = base_tolerance
        if proportion_defectors > defection_tolerance:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_287(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Enforcement strategy.
    
    Balances individual reward-seeking with collective sustainability through:
    1. Mandatory cooperation when stock health is critical (< 30% capacity)
    2. Graduated punishment of defectors based on observed defection rates
    3. Dynamic adaptation to recent opponent behavior (5-round rolling window)
    4. Preservation of commons even in final round if stock is depleted
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        health = current_stock / self.capacity if self.capacity > 0 else 0.0
        if current_stock <= 0:
            return Action.C
        if round_number == 0:
            return Action.C
        if health < 0.3:
            return Action.C
        if round_number == self.n_rounds - 1:
            if health < 0.3:
                return Action.C
            return Action.D
        observed_defection_rate = self._calculate_defection_rate(history, round_number)
        if health < 0.5:
            return Action.C
        if observed_defection_rate <= 0.33:
            return Action.C
        if observed_defection_rate > 0.66:
            return Action.D
        prob_defect = (observed_defection_rate - 0.33) / 0.33
        if random.random() < prob_defect:
            return Action.D
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the observed defection rate over the last min(5, round_number) rounds.
        
        Defection is encoded as False (0) in opponent_actions.
        Defection rate = fraction of opponents who defected in recent rounds.
        """
        recent_rounds = min(5, round_number)
        if recent_rounds == 0:
            return 0.0
        start_idx = round_number - recent_rounds
        recent_actions = history.opponent_actions[start_idx:round_number, :]
        total_opponents = self.n_players - 1
        total_slots = recent_rounds * total_opponents
        cooperations = np.sum(recent_actions)
        defections = total_slots - cooperations
        defection_rate = defections / total_slots if total_slots > 0 else 0.0
        return defection_rate

class Strategy_COLLECTIVE_288(BaseStrategy):
    """
    Adaptive Sustainability Management (ASM) Strategy
    
    Balances individual rational incentives with collective sustainability by:
    1. Using Stock Health Indicator (SHI) to assess resource state
    2. Cooperating when stock is healthy (SHI ≥ 0.75)
    3. Adapting to observed defection rates in caution zone (0.50 ≤ SHI < 0.75)
    4. Defecting in critical zone (SHI < 0.50) to secure immediate payoff
    5. Implementing special logic for first/last rounds and collapse prevention
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_threshold = 0.3
        self.lookback_rounds = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determine action based on current stock health and observed behavior.
        """
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_stock <= 0:
            return Action.D
        shi = current_stock / self.capacity if self.capacity > 0 else 0.0
        if shi >= 0.75:
            return Action.C
        if shi >= 0.5:
            defection_rate = self._calculate_defection_rate(history, current_round)
            if defection_rate <= self.defection_threshold:
                return Action.C
            else:
                return Action.D
        if current_round == self.n_rounds - 1:
            return Action.C
        return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate defection rate from opponent actions in the last 3 rounds.
        
        defection_rate = (observed D plays) / (3 × (n-1) possible plays)
        Returns a value in [0, 1]
        """
        start_round = max(0, current_round - self.lookback_rounds)
        rounds_to_check = current_round - start_round
        if rounds_to_check <= 0:
            return 0.0
        defection_count = 0
        for round_idx in range(start_round, current_round):
            opponent_actions_in_round = history.opponent_actions[round_idx, :]
            defections_in_round = np.sum(opponent_actions_in_round == False)
            defection_count += defections_in_round
        total_possible = rounds_to_check * (self.n_players - 1)
        if total_possible <= 0:
            return 0.0
        defection_rate = defection_count / total_possible
        return defection_rate

class Strategy_COLLECTIVE_289(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game
    
    Treats the common pool as a shared resource requiring active stewardship.
    Balances cooperation, punishment, and resource preservation based on:
    - Current stock health (phase classification)
    - Opponent cooperation momentum (rolling average)
    - Round number (final round special handling)
    
    Core principle: Maximize long-term collective value while remaining robust
    to exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.healthy_threshold = 0.75 * self.capacity
        self.stable_threshold = 0.5 * self.capacity
        self.stressed_threshold = 0.25 * self.capacity
        self.normal_coop_threshold = 0.6
        self.recovery_coop_threshold = 0.75
        self.final_round_exploit_threshold = 0.5
        self._previous_stock = None

    def _classify_phase(self, stock: float) -> str:
        """Classify current stock phase."""
        if stock >= self.healthy_threshold:
            return 'HEALTHY'
        elif stock >= self.stable_threshold:
            return 'STABLE'
        elif stock >= self.stressed_threshold:
            return 'STRESSED'
        else:
            return 'CRITICAL'

    def _calculate_coop_momentum(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate rolling average of cooperation rates over last 3 rounds.
        Returns proportion of players (across all opponents) playing C.
        """
        if round_number == 0:
            return 0.0
        lookback = min(3, round_number)
        recent_rounds = history.opponent_actions[-lookback:, :]
        total_cooperators = np.sum(recent_rounds)
        total_player_actions = recent_rounds.size
        if total_player_actions == 0:
            return 0.0
        return float(total_cooperators) / float(total_player_actions)

    def _get_cooperation_threshold(self, stock: float, previous_stock: float) -> float:
        """
        Adjust cooperation threshold based on recovery mode.
        If stock transitioned from STRESSED/CRITICAL to HEALTHY, increase threshold.
        """
        current_phase = self._classify_phase(stock)
        if previous_stock is not None:
            previous_phase = self._classify_phase(previous_stock)
            if current_phase == 'HEALTHY' and previous_phase in ['STRESSED', 'CRITICAL']:
                return self.recovery_coop_threshold
        return self.normal_coop_threshold

    def _check_sudden_defection_wave(self, coop_momentum: float, history: PlayerHistory, round_number: int, stock: float) -> bool:
        """
        Detect sudden drop in cooperation momentum.
        Returns True if emergency cooperation is needed.
        """
        if round_number < 2:
            return False
        if round_number >= 2:
            prev_round_coop = float(np.sum(history.opponent_actions[-2, :])) / self.n_players
            curr_round_coop = float(np.sum(history.opponent_actions[-1, :])) / self.n_players
            momentum_drop = prev_round_coop - curr_round_coop
            if momentum_drop > 0.3 and stock < self.stable_threshold:
                return True
        return False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if current_stock < self.stressed_threshold:
            return Action.C
        coop_momentum = self._calculate_coop_momentum(history, round_number)
        if self._check_sudden_defection_wave(coop_momentum, history, round_number, current_stock):
            return Action.C
        coop_threshold = self._get_cooperation_threshold(current_stock, self._previous_stock)
        if round_number == self.n_rounds - 1:
            if current_stock >= self.stable_threshold and coop_momentum < self.final_round_exploit_threshold:
                return Action.D
            else:
                return Action.C
        if coop_momentum >= coop_threshold:
            self._previous_stock = current_stock
            return Action.C
        elif current_stock >= self.stable_threshold:
            self._previous_stock = current_stock
            return Action.D
        else:
            self._previous_stock = current_stock
            return Action.C

class Strategy_COLLECTIVE_290(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS) - A conditional cooperation strategy
    that responds to stock health and defection density to maximize long-term
    collective payoff while remaining individually rational.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold = 60.0
        self.survival_threshold = 30.0
        self.tolerance_threshold = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        stock_health = current_stock / self.capacity * 100.0
        if round_number == 0:
            return Action.C
        rounds_remaining = self.n_rounds - round_number
        endgame_threshold = math.ceil(0.15 * self.n_rounds)
        if rounds_remaining <= endgame_threshold:
            if stock_health > 50.0:
                return Action.C
            else:
                return Action.D
        if round_number >= 2:
            stock_two_rounds_ago = self._get_stock_two_rounds_ago(history, round_number)
            if stock_two_rounds_ago is not None:
                recent_trend = (current_stock - stock_two_rounds_ago) / self.capacity
                if recent_trend < -0.15:
                    return Action.D
                if recent_trend > 0.1:
                    return Action.C
        if round_number >= 1:
            defection_rate = self._calculate_defection_rate(history, round_number - 1)
            tolerance = 0.25 + (self.n_rounds - round_number) / self.n_rounds * 0.1
            if stock_health >= 60.0 and defection_rate > tolerance:
                self.cooperation_threshold = 65.0
            else:
                self.cooperation_threshold = 60.0
        if stock_health >= self.cooperation_threshold:
            return Action.C
        elif stock_health >= self.survival_threshold:
            return Action.D
        else:
            return Action.D

    def _get_stock_two_rounds_ago(self, history: PlayerHistory, round_number: int) -> float | None:
        """
        Reconstruct stock level from two rounds ago using payoff history.
        Since we don't have explicit stock history, we estimate based on the
        known mechanics: payoff depends on stock and action distribution.
        
        For simplicity, we use a heuristic: if we can't reliably reconstruct,
        return None to skip trajectory analysis.
        """
        return None

    def _calculate_defection_rate(self, history: PlayerHistory, round_index: int) -> float:
        """
        Calculate the proportion of opponents who defected in a given round.
        True = Cooperate (Action.C), False = Defect (Action.D)
        Defection rate = proportion of False values
        """
        if round_index < 0 or round_index >= history.opponent_actions.shape[0]:
            return 0.0
        opponent_actions_in_round = history.opponent_actions[round_index, :]
        defections = np.sum(~opponent_actions_in_round)
        n_opponents = opponent_actions_in_round.shape[0]
        if n_opponents == 0:
            return 0.0
        return float(defections) / float(n_opponents)

class Strategy_COLLECTIVE_291(BaseStrategy):
    """
    Adaptive Stewardship with Defensive Safeguards.
    
    Balances collective long-term sustainability with individual resilience against exploitation.
    Cooperates to maintain stock at productive levels, but defects when stock is threatened or
    in the final round. Uses stock level and recent cooperation rates to adapt behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.threshold_high = 0.75 * self.capacity
        self.threshold_low = 0.4 * self.capacity
        self.critical = 0.2 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == self.n_rounds - 1:
            return Action.D
        if current_stock < self.critical:
            return Action.D
        if current_stock < self.threshold_low:
            if history is None or round_num == 0:
                cooperation_rate = 0.0
            else:
                prev_round_actions = history.opponent_actions[round_num - 1, :]
                cooperation_rate = float(np.sum(prev_round_actions)) / self.n_players
            if cooperation_rate > 0.5:
                return Action.C
            else:
                return Action.D
        if current_stock >= self.threshold_high:
            if history is None or round_num == 0:
                return Action.C
            else:
                start_round = max(0, round_num - 3)
                recent_actions = history.opponent_actions[start_round:round_num, :]
                if recent_actions.shape[0] == 0:
                    return Action.C
                recent_coop_rate = float(np.sum(recent_actions)) / (recent_actions.shape[0] * self.n_players)
                if recent_coop_rate >= 0.6:
                    return Action.C
                else:
                    return Action.C
        return Action.C

class Strategy_COLLECTIVE_292(BaseStrategy):
    """
    Adaptive Threshold Stewardship (ATS) Strategy for Common Pool Resource Game
    
    Balances self-preservation with collective welfare by adapting decisions based on
    current stock health and observed defection patterns. Treats the common pool as a
    shared resource whose sustainability is essential to long-term welfare.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if round_number == 0:
            return Action.C
        if stock_ratio > 0.75:
            return Action.C
        elif stock_ratio >= 0.5:
            defection_ratio = self._calculate_defection_ratio(history, round_number)
            if defection_ratio < 0.5:
                return Action.C
            else:
                return Action.D
        elif stock_ratio > 0.25:
            return Action.C
        else:
            return Action.C

    def _calculate_defection_ratio(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the proportion of opponents who defected in the last 2 rounds
        (or all available rounds if fewer than 2 have been played).
        
        Returns a value in [0.0, 1.0] representing the ratio of defectors to total opponents.
        """
        if history is None or round_number == 0:
            return 0.0
        rounds_to_examine = min(2, round_number)
        start_round = round_number - rounds_to_examine
        recent_opponent_actions = history.opponent_actions[start_round:round_number, :]
        defection_count = np.sum(~recent_opponent_actions)
        total_actions = recent_opponent_actions.size
        if total_actions == 0:
            return 0.0
        defection_ratio = float(defection_count) / float(total_actions)
        return defection_ratio

class Strategy_COLLECTIVE_293(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection: A stock-conditional strategy
    that prioritizes collective long-term welfare while remaining robust to exploitation.
    
    Core logic:
    - Cooperate when stock is abundant/healthy (≥0.8 capacity)
    - Assess defection risk when stock is moderate (0.5-0.8 capacity)
    - Defect when stock is critical (<0.5 capacity)
    - In first round, always cooperate to establish baseline
    - In final round, apply same rules (no end-game defection bonus)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.capacity
        if current_stock >= 1.5 * capacity:
            return Action.C
        elif current_stock >= 0.8 * capacity:
            return Action.C
        elif current_stock >= 0.5 * capacity:
            return self._assess_defection_risk(state, history)
        else:
            return Action.D

    def _assess_defection_risk(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        """
        Assess whether to defect when stock is in moderate range [0.5, 0.8) × capacity.
        
        Distinguishes between:
        - Collective overexploitation (widespread defection + declining stock)
        - External defection pressure (isolated defectors)
        """
        n = self.n_players
        round_idx = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[round_idx, :]
        n_defectors_prev = n - np.sum(opponent_actions_prev)
        defection_rate = n_defectors_prev / n
        stock_trajectory = 0.0
        if round_idx > 0:
            stock_trajectory = self._calculate_stock_trajectory(history, round_idx)
        if defection_rate > 0.5:
            return Action.D
        if stock_trajectory < -0.15:
            return Action.D
        if defection_rate > 0.4 and stock_trajectory < -0.1:
            return Action.D
        return Action.C

    def _calculate_stock_trajectory(self, history: PlayerHistory, current_round_idx: int) -> float:
        """
        Calculate stock change trajectory from round to round.
        
        Estimates stock change by examining how payoffs changed.
        Returns relative change: (stock_t - stock_t-1) / stock_t-1
        """
        if current_round_idx < 1:
            return 0.0
        my_payoff_prev = history.my_payoffs[current_round_idx - 1]
        my_payoff_curr = history.my_payoffs[current_round_idx]
        if my_payoff_prev <= 0:
            return 0.0
        payoff_ratio = my_payoff_curr / my_payoff_prev if my_payoff_prev > 0 else 1.0
        payoff_ratio = max(0.0, min(2.0, payoff_ratio))
        stock_trajectory = payoff_ratio - 1.0
        return stock_trajectory

class Strategy_COLLECTIVE_294(BaseStrategy):
    """
    Collective Resource Stewardship Strategy (CRSS)
    
    Balances individual resilience with collective sustainability through adaptive
    decision-making. Responds to observed depletion patterns and defection rates
    rather than following predetermined patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        stock_depletion_ratio = (self.capacity - current_stock) / self.capacity if self.capacity > 0 else 0.0
        stock_health = self._classify_stock_health(stock_depletion_ratio)
        defection_risk = self._calculate_defection_risk(history, current_round)
        trajectory = self._analyze_trajectory(history, current_stock, current_round)
        if stock_health == 'CRITICAL':
            return Action.C
        if stock_health == 'DEGRADED':
            if defection_risk == 'HIGH':
                return Action.D
            else:
                return Action.C
        if defection_risk == 'HIGH':
            return Action.D
        elif trajectory == 'POSITIVE':
            return Action.C
        elif trajectory == 'COLLAPSING':
            return Action.D
        elif current_round == self.n_rounds - 1:
            if defection_risk == 'HIGH':
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

    def _classify_stock_health(self, depletion_ratio: float) -> str:
        """Classify stock health based on depletion ratio."""
        if depletion_ratio > 0.7:
            return 'CRITICAL'
        elif depletion_ratio > 0.4:
            return 'DEGRADED'
        else:
            return 'HEALTHY'

    def _calculate_defection_risk(self, history: PlayerHistory, current_round: int) -> str:
        """Calculate defection risk based on observed behavior."""
        if current_round == 0:
            return 'LOW'
        high_defection_rounds = 0
        for round_idx in range(current_round):
            defectors_in_round = np.sum(~history.opponent_actions[round_idx, :])
            if defectors_in_round > self.n_players / 2:
                high_defection_rounds += 1
        observed_defection_rate = high_defection_rounds / current_round if current_round > 0 else 0.0
        high_threshold = 0.4 if self.n_players == 2 else 0.6
        moderate_threshold = 0.3
        if observed_defection_rate > high_threshold:
            return 'HIGH'
        elif observed_defection_rate > moderate_threshold:
            return 'MODERATE'
        else:
            return 'LOW'

    def _analyze_trajectory(self, history: PlayerHistory, current_stock: float, current_round: int) -> str:
        """Analyze stock trajectory over recent rounds."""
        if current_round < 2:
            return 'STABLE'
        recent_window = min(5, current_round)
        recent_payoffs = history.my_payoffs[max(0, current_round - recent_window):current_round]
        if len(recent_payoffs) < 2:
            return 'STABLE'
        average_payoff_change = (recent_payoffs[-1] - recent_payoffs[0]) / len(recent_payoffs)
        if average_payoff_change > 0:
            return 'POSITIVE'
        elif average_payoff_change < -(self.capacity / 20):
            return 'COLLAPSING'
        else:
            return 'STABLE'

class Strategy_COLLECTIVE_295(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances collective resource preservation with individual resilience through
    threshold-based conditional cooperation, exploitation detection, and dynamic
    threshold adjustment based on game phase and stock health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if self.capacity > 0:
            health_ratio = current_stock / self.capacity
        else:
            health_ratio = 0.0
        if current_stock >= 0.95 * self.capacity:
            return Action.C
        if current_stock < self.n_players:
            return Action.D
        if round_number == 0:
            return Action.C
        rounds_remaining = self.n_rounds - round_number
        if rounds_remaining <= 1:
            if health_ratio > 0.25:
                return Action.C
            else:
                return Action.D
        threshold = 0.4 + 0.3 * rounds_remaining / self.n_rounds
        recent_window = min(5, round_number)
        if recent_window > 0 and history is not None:
            recent_opponent_actions = history.opponent_actions[-recent_window:, :]
            defection_count = np.sum(~recent_opponent_actions)
            total_observations = recent_window * self.n_players
            if total_observations > 0:
                defection_rate = defection_count / total_observations
            else:
                defection_rate = 0.0
            if defection_rate > 0.6 and health_ratio < 0.5:
                return Action.D
        if health_ratio > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_296(BaseStrategy):
    """
    Adaptive Collective Stewardship Strategy (ACS)
    
    Implements enlightened self-interest through unconditional cooperation.
    The strategy recognizes that in common pool resource games, long-term 
    individual payoffs are maximized when resource stock remains healthy.
    Defection provides short-term gains but destroys future value for all players.
    
    Decision rule: Always cooperate, as defection accelerates resource collapse
    which harms the defector as much as others. The strategy is adaptive to 
    stock health but always chooses cooperation across all stock conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """Initialize the strategy with game parameters."""
        self.game_description = game_description
        self.sustainable_stock = game_description.capacity * 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decide action based on current stock health.
        
        Always returns COOPERATE because:
        1. Stock health is objectively observable but irreversible depletion
           from defection harms all players including ourselves
        2. Cooperation enables stock recovery and sustainable long-term payoffs
        3. Even in final rounds or stock collapse scenarios, cooperation
           prevents further degradation and maintains recovery potential
        4. The strategy is forward-looking optimization, not backward punishment
        
        Args:
            state: Current game state with stock level and round number
            history: Previous actions and payoffs (None on round 0)
            
        Returns:
            Action.C (COOPERATE) unconditionally
        """
        if state.round_number == 0:
            return Action.C
        if self.sustainable_stock > 0:
            stock_health_ratio = state.current_stock / self.sustainable_stock
        else:
            stock_health_ratio = 0.0
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock <= 0.0:
            return Action.C
        if history is not None and state.round_number > 0:
            pass
        return Action.C

class Strategy_COLLECTIVE_297(BaseStrategy):
    """
    Adaptive Collective Stewardship Strategy (ACS)
    
    Balances individual payoff maximization with long-term collective sustainability
    through conditional reciprocity and adaptive threshold management based on stock
    health and observed defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_collapsed_last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        observed_defection_rate = self._calculate_defection_rate(history, current_round)
        if self.stock_collapsed_last_round:
            self.stock_collapsed_last_round = False
        if current_stock <= 0:
            self.stock_collapsed_last_round = True
            return Action.D
        if current_round == self.n_rounds - 1:
            if current_stock >= self.capacity * 0.4:
                return Action.D
            else:
                return Action.C
        if self.n_rounds <= 3:
            if current_round == 1:
                if current_stock > 0:
                    return Action.D
            return Action.C
        if observed_defection_rate > 0.8:
            consecutive_high_defection = self._check_consecutive_high_defection(history, current_round)
            if consecutive_high_defection >= 3:
                return Action.D
        threshold = self._calculate_adaptive_threshold(current_round, observed_defection_rate)
        if current_stock >= threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the observed defection rate across all players and all rounds so far.
        Defection is when action is False (Action.D), cooperation is True (Action.C).
        """
        if current_round == 0:
            return 0.0
        my_defections = np.sum(~history.my_actions[:current_round])
        opponent_defections = np.sum(~history.opponent_actions[:current_round, :])
        total_actions = current_round * (1 + self.n_players - 1)
        if total_actions == 0:
            return 0.0
        defection_rate = (my_defections + opponent_defections) / total_actions
        return float(defection_rate)

    def _check_consecutive_high_defection(self, history: PlayerHistory, current_round: int) -> int:
        """
        Check how many consecutive rounds have had defection rate > 0.80.
        """
        if current_round < 3:
            return 0
        consecutive_count = 0
        for i in range(current_round - 1, max(current_round - 4, -1), -1):
            round_defections = (1 if not history.my_actions[i] else 0) + np.sum(~history.opponent_actions[i, :])
            round_total = 1 + self.n_players - 1
            round_defection_rate = round_defections / round_total if round_total > 0 else 0.0
            if round_defection_rate > 0.8:
                consecutive_count += 1
            else:
                break
        return consecutive_count

    def _calculate_adaptive_threshold(self, current_round: int, observed_defection_rate: float) -> float:
        """
        Calculate phase-based adaptive threshold based on round number and defection rate.
        Returns the stock level threshold; cooperate if stock >= threshold.
        """
        one_third = self.n_rounds / 3.0
        two_thirds = 2.0 * self.n_rounds / 3.0
        if current_round <= one_third:
            base_threshold = 0.7 - 0.15 * observed_defection_rate
        elif current_round <= two_thirds:
            base_threshold = 0.6 - 0.2 * observed_defection_rate
        else:
            base_threshold = 0.5 - 0.25 * observed_defection_rate
        base_threshold = max(0.0, min(1.0, base_threshold))
        threshold = self.capacity * base_threshold
        return threshold

class Strategy_COLLECTIVE_298(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A sustainable resource management strategy
    that cooperates when stock levels justify it, adapts to defection patterns,
    and defects only in the final round or when exploitation threatens the commons.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        rounds_elapsed = round_number
        rounds_remaining = self.n_rounds - round_number - 1
        threshold_stock = self.capacity * (1 - rounds_elapsed / self.n_rounds) * 0.6
        last_round_actions = history.opponent_actions[round_number - 1, :]
        defectors_last_round = sum(~last_round_actions)
        total_rounds_observed = round_number
        total_defectors_observed = sum(~history.opponent_actions[:round_number, :].flatten())
        total_observations = total_rounds_observed * self.n_players
        if total_observations > 0:
            observed_defection_rate = total_defectors_observed / total_observations
        else:
            observed_defection_rate = 0.0
        if observed_defection_rate > 0.5:
            tolerance_threshold = math.ceil(self.n_players * 0.15)
            adjusted_threshold = threshold_stock
        elif observed_defection_rate < 0.2:
            tolerance_threshold = math.ceil(self.n_players * 0.25)
            adjusted_threshold = threshold_stock * 0.95
        else:
            tolerance_threshold = math.ceil(self.n_players * 0.25)
            adjusted_threshold = threshold_stock
        stock_sufficient = current_stock >= adjusted_threshold
        defection_acceptable = defectors_last_round <= tolerance_threshold or rounds_remaining > 2
        if stock_sufficient and defection_acceptable:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_299(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collectively-optimal strategy for common pool resource games.
    
    Prioritizes long-term resource sustainability while adapting to opponent behavior.
    Cooperates by default, punishes exploitation proportionally, and prioritizes stock recovery
    when critical thresholds are breached.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_critical = 2 * self.n_players
        self.stock_healthy = self.capacity * 0.6
        self.stock_buffer = self.capacity * 0.4
        self.defection_tolerance = 0.4
        self.window = min(3, max(1, self.n_rounds // 2))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        current_round = state.round_number
        remaining_rounds = self.n_rounds - current_round
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        defection_rate = self._calculate_defection_rate(history, current_round)
        if current_stock < self.stock_critical:
            return Action.C
        if current_stock >= self.stock_healthy and defection_rate < self.defection_tolerance:
            return Action.C
        if defection_rate >= self.defection_tolerance:
            if current_stock >= self.stock_buffer:
                return Action.D
            else:
                return Action.C
        if current_stock < self.stock_buffer:
            return Action.C
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the defection rate of opponents in the recent window.
        
        Returns a float between 0 and 1 representing the proportion of opponent defections.
        """
        if history is None or current_round == 0:
            return 0.0
        start_round = max(0, current_round - self.window)
        end_round = current_round
        total_opponent_decisions = 0
        total_defections = 0
        for round_idx in range(start_round, end_round):
            if round_idx < len(history.opponent_actions):
                opponent_actions_this_round = history.opponent_actions[round_idx, :]
                defections_this_round = np.sum(opponent_actions_this_round == False)
                total_defections += defections_this_round
                total_opponent_decisions += len(opponent_actions_this_round)
        if total_opponent_decisions == 0:
            return 0.0
        defection_rate = total_defections / total_opponent_decisions
        return defection_rate

class Strategy_COLLECTIVE_300(BaseStrategy):
    """
    Collective Pool Protection Strategy (CPPS)
    
    Balances individual resource security with collective sustainability by:
    1. Assessing pool health (HEALTHY/STRESSED/CRITICAL)
    2. Detecting exploitation through stock depletion analysis
    3. Adapting actions based on pool status and defection signals
    4. Punishing detected free-riders while protecting collective welfare
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.exploitation_count = 0
        self.previous_stock = game_description.capacity
        self.punishment_phase = False
        self.punishment_duration = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            self.previous_stock = current_stock
            return Action.C
        self._update_exploitation_detection(current_stock, history, round_number)
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0
        if health_ratio > 0.5:
            pool_status = 'HEALTHY'
        elif health_ratio > 0.2:
            pool_status = 'STRESSED'
        else:
            pool_status = 'CRITICAL'
        if round_number == self.r - 1:
            return self._final_round_action(current_stock, pool_status)
        action = self._adaptive_action(pool_status, current_stock)
        self.previous_stock = current_stock
        return action

    def _update_exploitation_detection(self, current_stock: float, history: PlayerHistory, round_number: int) -> None:
        """
        Detect exploitation by comparing expected vs. actual stock depletion.
        """
        if round_number < 1:
            return
        prev_stock = self.previous_stock
        expected_consumption = prev_stock / 2.0
        expected_stock_after = prev_stock - expected_consumption
        if self.capacity > 0:
            expected_growth = 2.0 * expected_stock_after * (1.0 - expected_stock_after / self.capacity)
        else:
            expected_growth = 0
        expected_new_stock = min(expected_stock_after + expected_growth, self.capacity)
        if expected_new_stock > 0:
            defection_signal = (expected_new_stock - current_stock) / expected_new_stock
        else:
            defection_signal = 0
        if defection_signal > 0.15:
            self.exploitation_count += 1
        else:
            self.exploitation_count = max(0, self.exploitation_count - 1)
        if self.previous_stock > 0 and current_stock / self.previous_stock < 0.3:
            self.exploitation_count = 3
            self.punishment_phase = True
            self.punishment_duration = 2
        if expected_new_stock > 0:
            actual_growth = current_stock - expected_stock_after
            if actual_growth > expected_growth + 0.01:
                self.exploitation_count = max(0, self.exploitation_count - 2)

    def _adaptive_action(self, pool_status: str, current_stock: float) -> Action:
        """
        Determine action based on pool status and exploitation detection.
        """
        if self.punishment_phase and self.punishment_duration > 0:
            self.punishment_duration -= 1
            return Action.D
        else:
            self.punishment_phase = False
        min_sustainable = 2 * self.n
        if current_stock < min_sustainable:
            return Action.D
        if pool_status == 'HEALTHY':
            if self.exploitation_count < 2:
                return Action.C
            else:
                self.punishment_phase = True
                self.punishment_duration = 2
                return Action.D
        elif pool_status == 'STRESSED':
            if self.exploitation_count > 0:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _final_round_action(self, current_stock: float, pool_status: str) -> Action:
        """
        Special logic for final round.
        """
        min_viable_buffer = 2 * self.n * 1.5
        if current_stock > min_viable_buffer:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_301(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Reciprocity
    
    A collective strategy for the Common Pool Resource game that balances individual
    rationality with sustainability. It cooperates by default, reciprocates defection
    when exploitation becomes systematic, and switches to survival mode when stock
    becomes critically depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity * 0.15
        self.lookback_rounds = max(3, math.ceil(self.n_rounds / 3))
        self.defection_tolerance = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < self.critical_threshold:
            return Action.D
        defection_ratio = self._calculate_defection_ratio(state.round_number, history)
        if defection_ratio > self.defection_tolerance:
            return Action.D
        return Action.C

    def _calculate_defection_ratio(self, round_number: int, history: PlayerHistory) -> float:
        """
        Calculate the proportion of defections in the last k rounds across all players.
        
        defection_ratio = (count of D actions in recent window) / (k * n)
        
        Returns a value in [0, 1].
        """
        start_round = max(0, round_number - self.lookback_rounds)
        end_round = round_number
        defection_count = 0
        for round_idx in range(start_round, end_round):
            if not history.my_actions[round_idx]:
                defection_count += 1
        for round_idx in range(start_round, end_round):
            for opponent_idx in range(self.n_players - 1):
                if not history.opponent_actions[round_idx, opponent_idx]:
                    defection_count += 1
        window_size = end_round - start_round
        total_decisions = window_size * self.n_players
        if total_decisions == 0:
            return 0.0
        defection_ratio = defection_count / total_decisions
        return defection_ratio

class Strategy_COLLECTIVE_302(BaseStrategy):
    """
    Collective Adaptive Resource Stewardship (CARS) Strategy
    
    Prioritizes long-term collective sustainability over short-term individual gains.
    Adapts cooperation based on stock health and observed defection rates in the group.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainability_threshold = 0.75 * self.capacity
        self.critical_threshold = 0.25 * self.capacity
        self.golden_low = 0.3 * self.capacity
        self.golden_high = 0.6 * self.capacity
        self.near_capacity_threshold = 0.95 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        defection_rate = self._calculate_defection_rate(history, round_number)
        if current_stock >= self.near_capacity_threshold:
            return Action.C
        if current_stock < self.critical_threshold:
            return Action.D
        if current_stock >= self.sustainability_threshold:
            return Action.C
        if self.critical_threshold <= current_stock < self.sustainability_threshold:
            if self.golden_low <= current_stock <= self.golden_high and defection_rate <= 0.33:
                return Action.C
            if defection_rate > 0.67:
                return Action.D
            if 0.33 < defection_rate <= 0.67:
                return Action.D
            if defection_rate <= 0.33:
                return Action.C
        if round_number == self.n_rounds - 1:
            if current_stock >= self.critical_threshold and defection_rate <= 0.5:
                return Action.C
            else:
                return Action.D
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the empirical defection rate among all players in previous rounds.
        
        Returns a value between 0 and 1, where 1 means all observed actions were defections.
        """
        if round_number <= 0:
            return 0.0
        opponent_actions = history.opponent_actions[:round_number, :]
        total_defections = np.sum(~opponent_actions)
        total_actions = round_number * (self.n_players - 1)
        if total_actions == 0:
            return 0.0
        defection_rate = float(total_defections) / float(total_actions)
        return defection_rate

class Strategy_COLLECTIVE_303(BaseStrategy):
    """
    Adaptive Stewardship with Defensive Safeguards: A cooperative strategy that 
    prioritizes long-term collective welfare while defensively responding to exploitation.
    Monitors stock health and opponent defection rates to determine cooperation viability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio < 0.3:
            return Action.D
        defection_rate = self._calculate_recent_defection_rate(history, current_round)
        if stock_ratio > 0.9:
            return Action.C
        if stock_ratio >= 0.6:
            if defection_rate <= 0.25:
                return Action.C
            elif defection_rate > 0.5:
                return Action.D
            else:
                trend = self._get_defection_trend(history, current_round)
                if trend > 0:
                    return Action.D
                else:
                    return Action.C
        elif defection_rate > 0.5:
            return Action.D
        else:
            trend = self._get_defection_trend(history, current_round)
            if trend > 0 or defection_rate > 0.25:
                return Action.D
            else:
                return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate defection rate from the last min(3, rounds_elapsed) rounds.
        Defection is when opponent_actions is False (0).
        """
        if current_round == 0:
            return 0.0
        lookback = min(3, current_round)
        start_idx = current_round - lookback
        recent_actions = history.opponent_actions[start_idx:current_round, :]
        defections = np.sum(~recent_actions)
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        defection_rate = defections / total_actions
        return float(defection_rate)

    def _get_defection_trend(self, history: PlayerHistory, current_round: int) -> float:
        """
        Compare defection rate of last 2 rounds to detect trend.
        Returns: positive if increasing, negative if decreasing, 0 if stable/insufficient data.
        """
        if current_round < 2:
            return 0.0
        round_t_minus_2_actions = history.opponent_actions[current_round - 2, :]
        defection_rate_t_minus_2 = float(np.sum(~round_t_minus_2_actions)) / self.n_players if self.n_players > 0 else 0.0
        round_t_minus_1_actions = history.opponent_actions[current_round - 1, :]
        defection_rate_t_minus_1 = float(np.sum(~round_t_minus_1_actions)) / self.n_players if self.n_players > 0 else 0.0
        trend = defection_rate_t_minus_1 - defection_rate_t_minus_2
        return trend

class Strategy_COLLECTIVE_304(BaseStrategy):
    """
    Adaptive Commons Stewardship Strategy
    
    Balances individual payoff maximization with collective resource sustainability through:
    - Stock-conditional cooperation (high stock: cooperate, low stock: defect, middle: reciprocate)
    - Adaptive reciprocation based on recent opponent cooperation rates
    - Endgame defection and collapse-mode survival
    - Recovery-mode cooperation boost
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.threshold_upper = self.capacity * 0.7
        self.threshold_lower = self.capacity * 0.25
        self.threshold_critical = self.capacity * 0.15
        self.threshold_recovery = self.capacity * 0.6
        self.consecutive_recovery_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.consecutive_recovery_rounds = 0
            return Action.C
        stock = state.current_stock
        round_num = state.round_number
        if round_num == self.n_rounds - 1:
            return Action.D
        if stock <= self.threshold_critical:
            self.consecutive_recovery_rounds = 0
            return Action.D
        if stock > self.threshold_upper:
            self.consecutive_recovery_rounds += 1
            return Action.C
        if stock < self.threshold_lower:
            self.consecutive_recovery_rounds = 0
            return Action.D
        self.consecutive_recovery_rounds = 0
        recent_coop_rate = self._calculate_recent_cooperation_rate(history)
        if self.consecutive_recovery_rounds >= 2:
            recent_coop_rate += 0.1
        if recent_coop_rate > 0.6:
            return Action.C
        elif recent_coop_rate > 0.3:
            return Action.C if random.random() < 0.6 else Action.D
        else:
            return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the cooperation rate of opponents in the last 3 rounds.
        Returns a value between 0.0 and 1.0.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.5
        current_round = len(history.opponent_actions)
        lookback_rounds = min(3, current_round)
        start_idx = current_round - lookback_rounds
        recent_actions = history.opponent_actions[start_idx:current_round, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.5
        cooperations = np.sum(recent_actions)
        cooperation_rate = float(cooperations) / float(total_actions)
        return cooperation_rate

class Strategy_COLLECTIVE_305(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Enforcement
    
    Balances individual resilience against exploitation with collective long-term value creation.
    Uses phase-based decision making (HEALTHY/MODERATE/CRITICAL) based on stock health,
    with graduated enforcement and recovery mechanisms.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.was_in_critical = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_health >= 0.6:
            phase = 'HEALTHY'
        elif stock_health >= 0.3:
            phase = 'MODERATE'
        else:
            phase = 'CRITICAL'
        if round_number == 0:
            return Action.C
        last_round_idx = round_number - 1
        defectors_last_round = int(self.n_players - np.sum(history.opponent_actions[last_round_idx, :]))
        defection_rate = defectors_last_round / self.n_players if self.n_players > 0 else 0.0
        if self.was_in_critical and stock_health >= 0.4:
            self.was_in_critical = False
            return Action.C
        if phase == 'HEALTHY':
            if defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        elif phase == 'MODERATE':
            if defection_rate <= 0.25:
                return Action.C
            else:
                return Action.D
        else:
            self.was_in_critical = True
            return Action.D

class Strategy_COLLECTIVE_306(BaseStrategy):
    """
    Adaptive Commons Stewardship Strategy
    
    Dynamically adjusts cooperation based on stock health and observed defection rates.
    Maintains cooperative baseline when resources are healthy, shifts toward defection
    under stress, and reciprocates based on collective consumption patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_health > 0.95:
            return Action.C
        if current_stock < 1.0:
            return Action.D
        if current_stock < self.capacity / self.n_players:
            return Action.D
        if round_number == self.n_rounds - 1:
            return Action.D
        previous_round_idx = round_number - 1
        opponent_actions_last_round = history.opponent_actions[previous_round_idx, :]
        num_defectors = np.sum(~opponent_actions_last_round)
        defection_rate = num_defectors / self.n_players if self.n_players > 0 else 0.0
        adjusted_health_threshold_c = 0.6
        if defection_rate > 0.5:
            adjusted_health_threshold_c = 0.65
        elif defection_rate <= 0.25:
            adjusted_health_threshold_c = 0.45
        early_round_threshold = min(3, max(1, self.n_rounds // 4))
        if round_number <= early_round_threshold and stock_health >= 0.5:
            adjusted_health_threshold_c = max(0.4, adjusted_health_threshold_c - 0.05)
        if stock_health >= adjusted_health_threshold_c:
            return Action.C
        elif stock_health >= 0.3:
            health_range = adjusted_health_threshold_c - 0.3
            if health_range > 0:
                probability_cooperate = (stock_health - 0.3) / health_range
            else:
                probability_cooperate = 0.0
            if random.random() < probability_cooperate:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_307(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS) for Common Pool Resource Games.
    
    Optimizes for sustained collective resource value by using stock health as the
    primary signal. Adapts cooperation dynamically based on stock depletion and
    observed defection rates, with special handling for first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock = state.current_stock
        if round_t == 0:
            return Action.C
        if round_t == self.n_rounds - 1:
            return Action.D
        if stock <= 0:
            return Action.D
        health_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        opponent_defections_last_round = np.sum(~history.opponent_actions[round_t - 1, :])
        defection_rate = opponent_defections_last_round / self.n_players
        if round_t == self.n_rounds - 2:
            adjusted_defection_rate = defection_rate * 0.5
            if health_ratio > 0.4:
                if adjusted_defection_rate < 0.25:
                    return Action.C
                elif adjusted_defection_rate < 0.5:
                    prob_cooperate = 1.0 - adjusted_defection_rate
                    return Action.C if random.random() < prob_cooperate else Action.D
                else:
                    prob_defect = adjusted_defection_rate
                    return Action.D if random.random() < prob_defect else Action.C
            elif health_ratio > 0.15:
                if adjusted_defection_rate < 0.5:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        if health_ratio > 0.4:
            if defection_rate < 0.25:
                return Action.C
            elif defection_rate < 0.5:
                prob_cooperate = 1.0 - defection_rate
                return Action.C if random.random() < prob_cooperate else Action.D
            else:
                prob_defect = defection_rate
                return Action.D if random.random() < prob_defect else Action.C
        elif health_ratio > 0.15:
            if defection_rate < 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_308(BaseStrategy):
    """
    Adaptive Stewardship with Proportional Reciprocity: A collective strategy that maintains
    stock health through conditional cooperation, reciprocal defection, and graceful degradation.
    
    Core principles:
    - Round 1: Cooperate (establish baseline)
    - Rounds 2 to r-1: Adaptive reciprocity based on observed cooperation rate and stock health
    - Final round: Defect (backward induction)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        return self._adaptive_reciprocity(current_round, current_stock, history)

    def _adaptive_reciprocity(self, current_round: int, current_stock: float, history: PlayerHistory) -> Action:
        """
        Apply adaptive reciprocity logic based on observed cooperation rate and stock health.
        """
        prev_round_actions = history.opponent_actions[current_round - 1, :]
        observed_cooperators = np.sum(prev_round_actions)
        cooperation_rate = observed_cooperators / (self.n_players - 1)
        if cooperation_rate >= 0.5:
            return Action.C
        stock_threshold_healthy = 0.75 * self.capacity
        stock_threshold_degraded = 0.5 * self.capacity
        if current_stock > stock_threshold_healthy:
            defection_rate = 1.0 - cooperation_rate
            prob_cooperate = 1.0 - defection_rate ** 2
            if random.random() < prob_cooperate:
                return Action.C
            else:
                return Action.D
        elif current_stock > stock_threshold_degraded:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_309(BaseStrategy):
    """
    Adaptive Sustainability Management (ASM) - A collective strategy that prioritizes
    long-term resource sustainability while defending against exploitation.
    
    Core logic:
    - Cooperate when stock is healthy (>50% capacity)
    - Defect when stock is depleted (<50% capacity)
    - Detect and respond to greedy opponents (>50% defection rate)
    - Adjust behavior for last round and severe depletion scenarios
    - Reward sustained cooperation when conditions permit
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number
        if round_number == 0:
            return Action.C
        if rounds_remaining == 1:
            if stock > self.capacity * 0.3:
                return Action.C
            else:
                return Action.D
        if stock < self.capacity * 0.1:
            return Action.D
        if stock < self.capacity * 0.2:
            if random.random() < 0.8:
                return Action.D
            else:
                return Action.C
        if history is not None and round_number > 0:
            last_round_opponent_actions = history.opponent_actions[round_number - 1, :]
            defection_count = np.sum(~last_round_opponent_actions)
            defection_rate = float(defection_count) / (self.n_players - 1)
        else:
            defection_rate = 0.0
        if rounds_remaining > 1 and defection_rate > 0.5:
            return Action.D
        if stock > self.capacity * 0.5:
            if history is not None and round_number > 0:
                last_round_opponent_actions = history.opponent_actions[round_number - 1, :]
                all_cooperated = np.all(last_round_opponent_actions)
                if all_cooperated and stock > self.capacity * 0.6:
                    if random.random() < 0.95:
                        return Action.C
                    else:
                        return Action.D
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_310(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS) Strategy
    
    Balances collective welfare (maintaining stock sustainability) with individual security
    (protecting against exploitation). Adapts behavior based on stock health ratio and
    observed opponent defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        h = current_stock / self.capacity if self.capacity > 0 else 0.0
        if current_round == self.n_rounds - 1:
            return Action.D
        defection_ratio = self._calculate_defection_ratio(history, current_round)
        if h >= 0.7:
            return Action.C
        elif 0.4 <= h < 0.7:
            return self._conditional_cooperation(defection_ratio)
        else:
            return Action.D

    def _calculate_defection_ratio(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the proportion of opponents who defected in recent rounds.
        Uses a sliding 3-round window or full history if fewer rounds available.
        """
        window_size = 3
        start_round = max(0, current_round - window_size)
        recent_actions = history.opponent_actions[start_round:current_round, :]
        if recent_actions.size == 0:
            return 0.0
        defections = np.sum(~recent_actions)
        total_actions = recent_actions.size
        defection_ratio = defections / total_actions if total_actions > 0 else 0.0
        return defection_ratio

    def _conditional_cooperation(self, defection_ratio: float) -> Action:
        """
        Conditional cooperation logic for stressed stock levels.
        Adjust thresholds based on number of players.
        """
        n = self.n_players
        if n == 2:
            if defection_ratio > 0.25:
                return Action.D
            else:
                return Action.C
        elif n > 8:
            if defection_ratio > 0.6:
                return Action.D
            else:
                return Action.C
        elif defection_ratio <= 0.25:
            return Action.C
        elif defection_ratio <= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_311(BaseStrategy):
    """
    Adaptive Stewardship with Threshold Defense: A collective strategy that balances
    resource preservation with individual security. Cooperates when stock is healthy
    and defection rates are low, switches to defense when resources are depleted or
    defection is widespread.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.sustainable_threshold = game_description.capacity * 0.4
        self.defection_detection_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == r - 1:
            if stock >= self.sustainable_threshold:
                return Action.C
            else:
                return Action.D
        recent_rounds = min(3, round_num)
        defection_count = 0
        for i in range(round_num - recent_rounds, round_num):
            defectors_in_round = n - np.sum(history.opponent_actions[i, :])
            defection_count += defectors_in_round
        total_opponent_actions = n * recent_rounds
        if total_opponent_actions > 0:
            defection_rate = defection_count / total_opponent_actions
        else:
            defection_rate = 0.0
        stock_ratio = stock / capacity if capacity > 0 else 0.0
        if stock_ratio < 0.4:
            return Action.D
        elif defection_rate > self.defection_detection_threshold:
            return Action.D
        elif stock_ratio >= 0.6 and defection_rate <= 0.25:
            return Action.C
        elif stock_ratio >= 0.4 and defection_rate <= self.defection_detection_threshold:
            return Action.C
        elif defection_rate >= 0.25:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_312(BaseStrategy):
    """
    Adaptive Regenerative Management (ARM) Strategy for Common Pool Resource Game.
    
    Prioritizes collective long-term welfare through stock-health-based cooperation,
    adapting to opponent behavior and resource depletion dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        critical_threshold = 0.5 * self.capacity
        healthy_threshold = 0.75 * self.capacity
        if current_stock <= 0:
            return Action.D
        if current_stock >= healthy_threshold:
            return Action.C
        elif critical_threshold <= current_stock < healthy_threshold:
            defection_rate = self._calculate_defection_rate(history, round_number)
            if defection_rate < 0.5:
                return Action.C
            else:
                return Action.D
        else:
            if self._detect_cascading_collapse(history, round_number):
                return Action.D
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the defection rate over the last 3 rounds (or fewer if unavailable).
        
        Returns: fraction of opponent defections in the rolling window
        """
        window_size = min(3, round_number)
        if window_size == 0:
            return 0.0
        start_idx = round_number - window_size
        recent_actions = history.opponent_actions[start_idx:round_number, :]
        num_defections = np.sum(recent_actions == False)
        total_observations = window_size * self.n_players
        if total_observations == 0:
            return 0.0
        defection_rate = float(num_defections) / float(total_observations)
        return defection_rate

    def _detect_cascading_collapse(self, history: PlayerHistory, round_number: int) -> bool:
        """
        Detect if stock has decreased for 2 consecutive rounds.
        
        Returns: True if cascading collapse is detected
        """
        if round_number < 2:
            return False
        recent_defection_rate = self._calculate_defection_rate(history, round_number)
        if round_number >= 2:
            window_size = min(2, round_number)
            start_idx = round_number - window_size
            recent_actions = history.opponent_actions[start_idx:round_number, :]
            if recent_defection_rate > 0.6:
                return True
        return False

class Strategy_COLLECTIVE_313(BaseStrategy):
    """
    Adaptive Sustainable Yield (ASY) Strategy for Common Pool Resource Game.
    
    Prioritizes collective long-term welfare by maintaining stock sustainability
    while remaining robust to exploitation. Uses stock-conditional cooperation with
    adaptive defection based on opponent behavior and resource trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = self.capacity * 0.6
        self.safety_minimum = 2 * self.n * 1.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.C
        if stock < self.safety_minimum:
            return Action.D
        if stock < self.threshold:
            return Action.D
        c_rate = self._calculate_cooperation_rate(history, round_num)
        stock_trend = self._calculate_stock_trend(history, round_num)
        if c_rate < 0.3:
            return Action.D
        if stock_trend < 0 and c_rate < 0.6:
            return Action.D
        if round_num == self.r - 1:
            if stock >= self.threshold and c_rate >= 0.5:
                return Action.C
            elif stock < self.threshold or c_rate < 0.3:
                return Action.D
            else:
                return Action.C
        return Action.C

    def _calculate_cooperation_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the rate at which opponents have cooperated.
        
        Args:
            history: PlayerHistory object containing opponent actions
            round_num: Current round number (0-indexed)
        
        Returns:
            Cooperation rate in [0, 1]
        """
        if round_num <= 0:
            return 1.0
        total_c_actions = 0
        total_actions = 0
        for round_idx in range(round_num):
            for opponent_idx in range(self.n - 1):
                if opponent_idx < len(history.opponent_actions[round_idx]):
                    if history.opponent_actions[round_idx, opponent_idx]:
                        total_c_actions += 1
                    total_actions += 1
        if total_actions == 0:
            return 1.0
        return total_c_actions / total_actions

    def _calculate_stock_trend(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the trend in stock level (change from previous round).
        
        Args:
            history: PlayerHistory object
            round_num: Current round number (0-indexed)
        
        Returns:
            Stock trend (positive if increasing, negative if decreasing)
        """
        if round_num < 1:
            return 0.0
        if round_num < 2:
            return 0.0
        prev_payoff = float(history.my_payoffs[round_num - 2]) if round_num >= 2 else 0.0
        curr_payoff = float(history.my_payoffs[round_num - 1])
        return curr_payoff - prev_payoff

class Strategy_COLLECTIVE_314(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS) for Common Pool Resource Games.
    
    Balances individual security with collective long-term welfare through adaptive
    thresholds based on stock health and observed cooperation rates. Transitions between
    stewardship (healthy stock), conditional (declining stock), and extraction (critical stock) modes.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        current_stock = state.current_stock
        capacity = self.capacity
        n = self.n_players
        r = self.n_rounds
        if round_t == 0:
            return Action.C
        if round_t == r - 1:
            return Action.D
        stock_ratio = current_stock / capacity if capacity > 0 else 0.0
        cooperators_last_round = int(np.sum(history.opponent_actions[-1, :]))
        cooperation_rate = cooperators_last_round / n if n > 0 else 0.0
        stock_growing = False
        if round_t >= 1:
            prev_stock = state.current_stock
            if cooperation_rate > 0.5 and current_stock > 0:
                stock_growing = True
        unanimous_cooperation = False
        if round_t >= 3:
            recent_cooperation_rates = []
            for i in range(max(0, round_t - 3), round_t):
                recent_coop = int(np.sum(history.opponent_actions[i, :])) / n
                recent_cooperation_rates.append(recent_coop)
            if all((rate == 1.0 for rate in recent_cooperation_rates)):
                unanimous_cooperation = True
        unanimous_defection = False
        if round_t >= 2:
            defection_count = 0
            for i in range(max(0, round_t - 2), round_t):
                if int(np.sum(history.opponent_actions[i, :])) == 0:
                    defection_count += 1
            if defection_count >= 2:
                unanimous_defection = True
        if unanimous_defection:
            return Action.D
        if unanimous_cooperation and stock_ratio > 0.3:
            return Action.C
        if stock_ratio > 0.6:
            return Action.C
        elif stock_ratio > 0.3:
            if cooperation_rate > 0.5:
                return Action.C if random.random() < 0.75 else Action.D
            elif stock_growing:
                return Action.C
            else:
                return Action.D if random.random() < 0.5 else Action.C
        elif stock_ratio > 0.1:
            if cooperation_rate > 0.6:
                return Action.D if random.random() < 0.6 else Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_315(BaseStrategy):
    """
    Adaptive Stewardship with Contingent Defection.
    
    Balances individual resilience against exploitation with collective long-term welfare.
    Starts cooperatively, monitors defection rates of others, adapts based on stock health
    and collective behavior patterns. Uses dynamic sustainability thresholds that become
    more lenient in late rounds, includes punitive and recovery modes.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        stock = state.current_stock
        if round_number == 0:
            return Action.C
        rounds_remaining = self.n_rounds - round_number
        threshold = self.capacity * (0.4 + 0.15 * rounds_remaining / self.n_rounds)
        others_defection_rate = self._calculate_others_defection_rate(history, round_number)
        if round_number == self.n_rounds - 1:
            if stock > 0.3 * self.capacity:
                return Action.C
            else:
                return Action.D
        if others_defection_rate > 0.6:
            return Action.D
        if stock < 0.3 * self.capacity:
            recent_defection_trend = self._get_recent_defection_trend(history, round_number)
            if recent_defection_trend < others_defection_rate - 0.2:
                return Action.C
            else:
                return Action.D
        if stock > threshold:
            if others_defection_rate <= 0.3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _calculate_others_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the empirical defection rate of all other players combined.
        Defection is when action is False (0), cooperation is when action is True (1).
        """
        if round_number == 0:
            return 0.0
        opponent_actions = history.opponent_actions[:round_number, :]
        total_defections = np.sum(~opponent_actions)
        total_actions = (self.n_players - 1) * round_number
        if total_actions == 0:
            return 0.0
        return float(total_defections) / float(total_actions)

    def _get_recent_defection_trend(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate defection rate of others in the last 3 rounds (or fewer if not available).
        Returns the recent trend to detect if others are reducing defection.
        """
        if round_number == 0:
            return 0.0
        look_back = min(3, round_number)
        recent_actions = history.opponent_actions[round_number - look_back:round_number, :]
        total_defections = np.sum(~recent_actions)
        total_actions = (self.n_players - 1) * look_back
        if total_actions == 0:
            return 0.0
        return float(total_defections) / float(total_actions)

class Strategy_COLLECTIVE_316(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A strategy that prioritizes long-term collective
    value creation by maintaining stock health while remaining robust against exploitation.
    
    Uses dynamic thresholds based on stock level, rounds remaining, and observed defection
    rates to decide between cooperation (sustainable extraction) and defection (opportunistic
    extraction).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if stock < 2 * self.n:
            return Action.D
        if round_num == 0:
            return Action.C
        if round_num == self.total_rounds - 1:
            if stock > self.capacity * 0.4:
                return Action.C
            else:
                return Action.D
        rounds_remaining = self.total_rounds - round_num
        ratio = rounds_remaining / self.total_rounds
        threshold = self.capacity * (1 - ratio * ratio) * (1 + 0.1 * self.n)
        defection_rate = self._calculate_defection_rate(history, round_num)
        if defection_rate > 0.5:
            threshold = threshold * 0.8
        elif defection_rate > 0.25:
            threshold = threshold * 0.9
        if stock > threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the proportion of opponents who defected in previous rounds.
        
        Args:
            history: Player history containing opponent actions
            current_round: Current round number (0-indexed)
        
        Returns:
            Defection rate as a float between 0 and 1
        """
        if current_round == 0:
            return 0.0
        previous_rounds = history.opponent_actions[:current_round, :]
        total_actions = previous_rounds.size
        if total_actions == 0:
            return 0.0
        defections = np.sum(previous_rounds == False)
        defection_rate = float(defections) / float(total_actions)
        return defection_rate

class Strategy_COLLECTIVE_317(BaseStrategy):
    """
    Adaptive Stewardship with Contingent Reciprocity
    
    A collective strategy that balances sustainability, individual security, and reciprocal fairness
    through three distinct phases: initial cooperation, adaptive steady-state with contingent defection,
    and endgame cooperation. Maintains running defection rate estimates and adapts tolerance thresholds
    based on remaining rounds and current stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defections_observed = 0
        self.total_actions_observed = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round <= 1:
            return Action.C
        if current_round >= self.n_rounds - 2:
            return Action.C
        critical_threshold = self.capacity * 0.3
        if current_stock < 2 * self.n_players:
            return Action.C
        if current_stock < critical_threshold:
            return Action.C
        self._update_defection_counts(history)
        if self.total_actions_observed == 0:
            defection_rate = 0.0
        else:
            defection_rate = self.defections_observed / self.total_actions_observed
        tolerance_threshold = 0.4 + (self.n_rounds - current_round) / (2.0 * self.n_rounds)
        if defection_rate > tolerance_threshold:
            p_escalate = min(0.7, defection_rate)
            if random.random() < p_escalate:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

    def _update_defection_counts(self, history: PlayerHistory) -> None:
        """
        Update running counts of observed defections and total actions from opponent behavior.
        Only counts new rounds since last update by tracking total_actions_observed.
        """
        if history is None:
            return
        n_rounds_completed = history.my_actions.shape[0]
        n_opponents = self.n_players - 1
        total_possible_actions = n_rounds_completed * n_opponents
        if total_possible_actions > self.total_actions_observed:
            opponent_defections = np.sum(~history.opponent_actions)
            self.defections_observed = int(opponent_defections)
            self.total_actions_observed = total_possible_actions

class Strategy_COLLECTIVE_318(BaseStrategy):
    """
    Adaptive Collective Stewardship Strategy (ACS) for Common Pool Resource Game.
    
    Balances individual payoff optimization with collective sustainability by:
    - Cooperating when stock is healthy (≥60% capacity)
    - Detecting and responding to decay phases
    - Defecting in final round and under critical depletion
    - Punishing unanimous defection
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.decay_counter = 0
        self.stock_history = []
        self.unanimous_defection_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            self.stock_history.append(current_stock)
            return Action.C
        self.stock_history.append(current_stock)
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock <= 0.1 * self.capacity:
            return Action.D
        if len(self.stock_history) >= 2:
            recent_stocks = self.stock_history[-3:]
            recent_avg = np.mean(recent_stocks)
            if len(self.stock_history) >= 6:
                prior_stocks = self.stock_history[-6:-3]
                prior_avg = np.mean(prior_stocks)
            else:
                prior_avg = recent_avg
            if prior_avg > 0 and recent_avg < 0.5 * prior_avg:
                self.decay_counter += 1
                if self.decay_counter <= 2:
                    return Action.D
            elif self.decay_counter > 0:
                self.decay_counter = 0
        if self.unanimous_defection_counter > 0:
            self.unanimous_defection_counter -= 1
            return Action.D
        if len(history.my_actions) > 0:
            prev_round_idx = current_round - 1
            opponents_defected = np.sum(~history.opponent_actions[prev_round_idx, :])
            if opponents_defected == self.n_players - 1 and (not history.my_actions[prev_round_idx]):
                self.unanimous_defection_counter = 1
                return Action.D
        if current_round == self.n_rounds - 2:
            threshold = 0.65 * self.capacity
        else:
            threshold = 0.6 * self.capacity
        if current_stock >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_319(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection.
    
    A three-state strategy that balances individual rationality with collective resource
    sustainability. Cooperates when stock is critical (PRESERVE mode), reciprocates based
    on observed cooperation rates at moderate stock levels (RECIPROCATE mode), and
    strategically defects when stock is abundant (EXPLOIT mode).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.capacity
        if stock_ratio < 0.35:
            return Action.C
        if stock_ratio >= 0.75:
            return Action.D
        cooperation_rate = self._calculate_cooperation_rate(history)
        if cooperation_rate >= 0.5:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the proportion of C (cooperate) actions by other players in history.
        Returns value in [0, 1]. If no history, returns 1.0 (assume cooperation).
        """
        if history is None or len(history.opponent_actions) == 0:
            return 1.0
        total_opponent_actions = history.opponent_actions.size
        if total_opponent_actions == 0:
            return 1.0
        cooperate_count = np.sum(history.opponent_actions)
        cooperation_rate = float(cooperate_count) / float(total_opponent_actions)
        return cooperation_rate

class Strategy_COLLECTIVE_320(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances self-protection against defectors with resource sustainability through:
    1. Health-based cooperation (stock thresholds)
    2. Dynamic defection tolerance (adapted to game progress)
    3. Expected value alignment checks
    4. Adaptive responsiveness to opponent behavior patterns
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustained_defection_counter = 0
        self.last_defection_rate = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            defection_rate = self._calculate_defection_rate(history, round_num)
            if stock > self.capacity * 0.6 and defection_rate < 0.2:
                return Action.C
            return Action.D
        if stock < self.capacity * 0.15:
            return Action.D
        defection_rate = self._calculate_defection_rate(history, round_num)
        threshold = 0.35 + 0.15 * (round_num / self.n_rounds)
        if stock <= self.capacity * 0.4:
            return Action.D
        if defection_rate > threshold:
            self.sustained_defection_counter += 1
            if self.sustained_defection_counter >= 2:
                return Action.D
            return Action.D
        else:
            self.sustained_defection_counter = 0
        if round_num >= 1:
            prev_defection_rate = self.last_defection_rate
            if defection_rate - prev_defection_rate > 0.3:
                return Action.D
        self.last_defection_rate = defection_rate
        payoff_if_cooperate = stock / (2 * self.n_players)
        payoff_if_defect = stock / self.n_players
        if payoff_if_cooperate >= payoff_if_defect * 0.85:
            return Action.C
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate opponent defection rate over last 3 rounds (or all previous rounds if fewer).
        Returns proportion of defection actions observed.
        """
        if current_round == 0:
            return 0.0
        window_start = max(0, current_round - 3)
        window_size = current_round - window_start
        defection_count = 0
        total_observations = 0
        for round_idx in range(window_start, current_round):
            opponent_actions_this_round = history.opponent_actions[round_idx, :]
            defections_this_round = np.sum(~opponent_actions_this_round)
            defection_count += defections_this_round
            total_observations += self.n_players
        if total_observations == 0:
            return 0.0
        return defection_count / total_observations

class Strategy_COLLECTIVE_321(BaseStrategy):
    """
    Adaptive Commons Stewardship Strategy
    
    Balances individual gain against long-term collective sustainability by monitoring
    stock health and community defection rates. Starts cooperatively, adapts based on
    observed behavior patterns, and transitions defensively when sustainability is threatened.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.window_size = max(3, self.n_rounds // 4)
        self.shi_threshold = 50.0
        self.defection_tolerance = 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock_s = state.current_stock
        if round_t == 0:
            return Action.C
        shi = stock_s / self.capacity * 100.0
        defection_rate = self._calculate_defection_rate(history, round_t)
        stock_momentum = self._calculate_stock_momentum(history, round_t)
        if round_t > self.n_rounds - 2 and shi < 20.0:
            return Action.D
        self._adjust_thresholds_based_on_behavior(history, round_t)
        if shi < 35.0:
            return Action.D
        if stock_momentum < -0.15:
            return Action.D
        if defection_rate > 0.6 and shi < 50.0:
            return Action.D
        if shi >= self.shi_threshold and defection_rate <= self.defection_tolerance:
            action = Action.C
        elif 35.0 <= shi < self.shi_threshold and defection_rate <= 0.1:
            action = Action.C
        elif defection_rate > self.defection_tolerance:
            action = Action.D
        else:
            action = Action.D
        if round_t == self.n_rounds - 1:
            if shi >= 50.0:
                action = Action.C
            else:
                action = Action.D
        return action

    def _calculate_defection_rate(self, history: PlayerHistory, round_t: int) -> float:
        """
        Calculate the defection rate over the recent rolling window.
        Returns the proportion of rounds with net defection (more D than C among opponents).
        """
        if round_t == 0:
            return 0.0
        window_start = max(0, round_t - self.window_size)
        window_end = round_t
        window_length = window_end - window_start
        if window_length == 0:
            return 0.0
        net_defection_count = 0
        for t in range(window_start, window_end):
            cooperators = int(np.sum(history.opponent_actions[t, :]))
            defectors = self.n_players - cooperators
            if defectors > cooperators:
                net_defection_count += 1
        return float(net_defection_count) / float(window_length)

    def _calculate_stock_momentum(self, history: PlayerHistory, round_t: int) -> float:
        """
        Calculate the rate of stock change from the previous round.
        Returns the relative change: (current - previous) / previous
        """
        if round_t <= 1:
            return 0.0
        recent_payoff = history.my_payoffs[round_t - 1]
        previous_payoff = history.my_payoffs[round_t - 2] if round_t >= 2 else recent_payoff
        if previous_payoff < 1e-09:
            return 0.0
        payoff_momentum = (recent_payoff - previous_payoff) / (previous_payoff + 1e-09)
        return payoff_momentum

    def _adjust_thresholds_based_on_behavior(self, history: PlayerHistory, round_t: int) -> None:
        """
        Adjust decision thresholds based on observed community behavior in the previous round.
        """
        if round_t < 1:
            return
        prev_round = round_t - 1
        cooperators = int(np.sum(history.opponent_actions[prev_round, :]))
        majority_threshold = self.n_players / 2.0
        if cooperators > majority_threshold:
            self.shi_threshold = max(40.0, self.shi_threshold - 5.0)
            self.defection_tolerance = min(0.5, self.defection_tolerance + 0.05)
        elif cooperators < majority_threshold:
            self.shi_threshold = min(65.0, self.shi_threshold + 5.0)
            self.defection_tolerance = max(0.2, self.defection_tolerance - 0.05)

class Strategy_COLLECTIVE_322(BaseStrategy):
    """
    Adaptive Stock Stewardship: A conditional cooperation strategy that balances
    personal payoffs with long-term resource sustainability. Monitors stock health
    and opponent defection rates, adapting cooperation thresholds dynamically.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.C
        threshold_stock = self.capacity * (1 - round_num / (2 * self.n_rounds))
        window_size = max(2, math.floor(self.n_rounds / 4))
        recent_defection_rate = self._calculate_recent_defection_rate(history, round_num, window_size)
        defection_tolerance = 0.4 + round_num / self.n_rounds * 0.2
        if stock < 0.15 * self.capacity:
            return Action.C
        if round_num == self.n_rounds - 1 and stock < 0.25 * self.capacity and (recent_defection_rate > 0.5):
            return Action.D
        if stock >= threshold_stock and recent_defection_rate <= defection_tolerance:
            return Action.C
        else:
            return Action.D

    def _calculate_recent_defection_rate(self, history: PlayerHistory, current_round: int, window_size: int) -> float:
        """
        Calculate the proportion of defections by other players in recent rounds.
        
        Returns a value in [0, 1] representing the defection rate.
        """
        start_round = max(0, current_round - window_size)
        end_round = current_round
        if start_round >= end_round:
            return 0.0
        rounds_to_check = end_round - start_round
        total_possible_defections = (self.n_players - 1) * rounds_to_check
        if total_possible_defections == 0:
            return 0.0
        defection_count = 0
        for round_idx in range(start_round, end_round):
            for player_idx in range(self.n_players - 1):
                if not history.opponent_actions[round_idx, player_idx]:
                    defection_count += 1
        return defection_count / total_possible_defections

class Strategy_COLLECTIVE_323(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Reciprocity strategy for Common Pool Resource Game.
    
    Balances stewardship (maintaining stock health), reciprocity (matching cooperation levels),
    and adaptability (responding to defection patterns). Uses threshold-based decision rules:
    - Critical zone (health < 0.25): Always cooperate for emergency conservation
    - Abundance zone (health > 0.70): Cooperate if recent cooperation rate ≥ 0.5
    - Normal zone: Cooperate if recent cooperation rate ≥ 0.4
    - Round 1: Always cooperate to establish baseline
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        health_ratio = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        if health_ratio < 0.25:
            return Action.C
        recent_coop_rate = self._calculate_recent_cooperation_rate(history, state.round_number)
        if health_ratio > 0.7:
            threshold = 0.5
        else:
            threshold = 0.4
        if recent_coop_rate >= threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the cooperation rate of opponents in the last K rounds.
        K = min(3, round_number) to look back up to 3 rounds or all available history.
        """
        if round_number <= 0:
            return 0.0
        lookback_rounds = min(3, round_number)
        start_idx = max(0, round_number - lookback_rounds)
        end_idx = round_number
        if start_idx >= end_idx:
            return 0.0
        recent_actions = history.opponent_actions[start_idx:end_idx, :]
        total_cooperations = np.sum(recent_actions)
        total_opponent_actions = (self.n_players - 1) * (end_idx - start_idx)
        if total_opponent_actions == 0:
            return 0.0
        cooperation_rate = float(total_cooperations) / float(total_opponent_actions)
        return cooperation_rate

class Strategy_COLLECTIVE_324(BaseStrategy):
    """
    Collective Resource Stewardship Strategy (CRSS)
    
    Prioritizes long-term collective sustainability over short-term individual gain.
    Uses dynamic stock-based thresholds, redemption recovery after damage,
    and endgame pragmatism to maintain resource health while resisting exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players
        self.recovery_rounds_remaining = 0
        self.previous_stock = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_left = self.n_rounds - current_round
        if current_round == 0:
            self.previous_stock = current_stock
            return Action.C
        if rounds_left == 0:
            if current_stock > 0.2 * self.capacity:
                return Action.C
            else:
                return Action.D
        if current_stock < 0.1 * self.capacity:
            self.recovery_rounds_remaining = min(3, rounds_left)
            return Action.D
        if self.recovery_rounds_remaining > 0:
            self.recovery_rounds_remaining -= 1
            return Action.C
        if current_stock < 0.4 * self.capacity:
            self.recovery_rounds_remaining = min(3, rounds_left) - 1
            return Action.C
        threshold = self.capacity * (0.5 + 0.25 * (rounds_left / self.n_rounds))
        stock_growth_rate = (current_stock - self.previous_stock) / max(self.previous_stock, 1e-06)
        if stock_growth_rate > 0.3:
            threshold *= 0.95
        self.previous_stock = current_stock
        if current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_325(BaseStrategy):
    """
    Steward with Sanctions: Adaptive strategy that balances individual security with collective welfare.
    
    Cooperates when the resource is healthy, detects defection through consumption patterns,
    and escalates punishment proportionally to threat level. Last-round behavior depends on
    resource health to maximize long-term collective outcomes.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_counter = 0
        self.punishment_duration = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        sustainable_level = self.capacity / 2.0
        defection_detected = self._detect_defection(history, current_round)
        threat_level = self._assess_threat_level(stock_ratio)
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            return Action.D
        if current_round == self.n_rounds - 1:
            if stock_ratio > 0.6:
                return Action.C
            else:
                return Action.D
        if threat_level == 'CRITICAL':
            if defection_detected:
                self.punishment_counter = 4
                return Action.D
            else:
                return Action.C
        elif threat_level == 'HIGH':
            if defection_detected:
                self.punishment_counter = 2
                return Action.D
            else:
                return Action.C
        elif threat_level == 'MODERATE':
            if defection_detected:
                self.punishment_counter = 1
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

    def _detect_defection(self, history: PlayerHistory, current_round: int) -> bool:
        """
        Detect if aggregate consumption suggests defection is occurring.
        Uses consumption trend over past few rounds.
        """
        if current_round < 2:
            return False
        lookback = min(3, current_round)
        start_idx = max(0, current_round - lookback)
        total_consumptions = []
        for round_idx in range(start_idx, current_round):
            my_action_is_coop = history.my_actions[round_idx]
            my_consumption = 1.0 / (2 * self.n_players) if my_action_is_coop else 1.0 / self.n_players
            opponent_coop_count = np.sum(history.opponent_actions[round_idx, :])
            opponent_defect_count = self.n_players - 1 - opponent_coop_count
            consumption_rate = my_consumption + opponent_coop_count * 1.0 / (2 * self.n_players) + opponent_defect_count * 1.0 / self.n_players
            total_consumptions.append(consumption_rate)
        if len(total_consumptions) == 0:
            return False
        avg_consumption = np.mean(total_consumptions)
        expected_if_all_cooperate = 0.5
        threshold = expected_if_all_cooperate * 1.15
        return avg_consumption > threshold

    def _assess_threat_level(self, stock_ratio: float) -> str:
        """
        Categorize threat level based on stock ratio.
        """
        if stock_ratio < 0.3:
            return 'CRITICAL'
        elif stock_ratio < 0.5:
            return 'HIGH'
        elif stock_ratio < 0.75:
            return 'MODERATE'
        else:
            return 'LOW'

class Strategy_COLLECTIVE_326(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS) Strategy for Common Pool Resource Game.
    
    Prioritizes collective long-term welfare by assessing stock health, detecting defectors,
    and dynamically adjusting between cooperation and defection based on resource sustainability
    and systemic exploitation pressure.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_threshold = 0.6
        self.last_defection_pressure = 0.0
        self.consecutive_actions = 0
        self.last_action = None
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            self.last_action = Action.C
            self.consecutive_actions = 1
            return Action.C
        self.stock_history.append(state.current_stock)
        health_ratio = state.current_stock / self.capacity if self.capacity > 0 else 1.0
        if health_ratio >= 0.75:
            stock_status = 'HEALTHY'
        elif health_ratio >= 0.4:
            stock_status = 'VULNERABLE'
        else:
            stock_status = 'CRITICAL'
        current_round = state.round_number
        if current_round > 0:
            opponent_actions_last_round = history.opponent_actions[current_round - 1, :]
            defections_last_round = np.sum(~opponent_actions_last_round)
            defection_pressure = defections_last_round / (self.n_players - 1) if self.n_players > 1 else 0.0
        else:
            defection_pressure = 0.0
        recovery_momentum = 0.0
        if current_round >= 2 and len(self.stock_history) >= 3:
            stock_2_rounds_ago = self.stock_history[-3]
            if stock_2_rounds_ago > 0:
                recovery_momentum = (state.current_stock - stock_2_rounds_ago) / stock_2_rounds_ago
        defection_pressure_decreased = self.last_defection_pressure - defection_pressure > 0.2
        if current_round == self.n_rounds - 1:
            if stock_status == 'CRITICAL':
                action = Action.D
            elif state.current_stock > self.capacity * 0.6:
                action = Action.C
            else:
                action = Action.D
        elif stock_status == 'CRITICAL':
            action = Action.D
        elif stock_status == 'VULNERABLE':
            if defection_pressure > 0.33:
                action = Action.D
            else:
                action = Action.C
        elif defection_pressure > 0.5 and defection_pressure >= self.last_defection_pressure:
            action = Action.D
        elif recovery_momentum > 0.1 and defection_pressure < 0.4:
            action = Action.C
        else:
            action = Action.C
        if current_round > 3 and defection_pressure_decreased:
            self.defection_threshold = max(0.5, self.defection_threshold - 0.05)
            action = Action.C
        if self.last_action is not None:
            if action == self.last_action:
                self.consecutive_actions += 1
            else:
                if self.consecutive_actions < 2:
                    action = self.last_action
                self.consecutive_actions = 1
        self.last_action = action
        self.last_defection_pressure = defection_pressure
        return action

class Strategy_COLLECTIVE_327(BaseStrategy):
    """
    Adaptive Stock-Preservation Protocol (ASPP): A conditionally cooperative strategy
    that prioritizes collective long-term sustainability while adapting to observed
    cooperation levels and stock health. Cooperates when stock is healthy and sufficient
    cooperation is observed; defects when stock is critically depleted or cooperation fails.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        if state.round_number == self.n_rounds - 1:
            if stock_ratio >= 0.4:
                return Action.C
            else:
                return Action.D
        cooperation_rate = self._calculate_cooperation_rate(history, state.round_number)
        if stock_ratio < 0.15:
            return Action.D
        if stock_ratio < 0.35:
            if cooperation_rate > 0.5:
                return Action.C
            else:
                return Action.D
        if stock_ratio >= 0.35:
            if cooperation_rate > 0.3:
                return Action.C
            elif cooperation_rate > 0.0:
                return Action.C
            else:
                return Action.D
        return Action.C

    def _calculate_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate cooperation rate from observed opponent actions.
        Uses recent window (last 3 rounds) if available, otherwise all completed rounds.
        """
        if current_round == 0:
            return 0.0
        window_size = min(3, current_round)
        start_index = current_round - window_size
        total_cooperations = 0
        total_actions = 0
        for round_idx in range(start_index, current_round):
            cooperations_in_round = np.sum(history.opponent_actions[round_idx, :])
            total_cooperations += cooperations_in_round
            total_actions += self.n_players - 1
        if total_actions == 0:
            return 0.0
        cooperation_rate = total_cooperations / total_actions
        return cooperation_rate

class Strategy_COLLECTIVE_328(BaseStrategy):
    """
    Adaptive Stewardship with Defensive Defection.
    
    Balances three principles:
    1. Sustainability First: Preserve stock regeneration capacity
    2. Reciprocal Fairness: Reward cooperation, punish defection
    3. Defensive Pragmatism: Defect when necessary to prevent tragedy
    
    Uses stock-based thresholds and cooperation norm detection to decide
    between cooperation and defection, with special handling for endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainability_threshold = self.capacity * 0.5
        self.critical_threshold = self.sustainability_threshold / 2.0
        self.cooperation_threshold = 0.6
        self.endgame_cooperation_threshold = 0.7
        self.recovery_improvement_threshold = 0.15

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if stock < self.sustainability_threshold:
            if stock < self.critical_threshold:
                cooperation_trend = self._get_cooperation_trend(history, current_round)
                if cooperation_trend > self.recovery_improvement_threshold:
                    return Action.C
            return Action.D
        cooperation_rate = self._get_cooperation_rate(history, current_round)
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= 3:
            threshold = self.endgame_cooperation_threshold
        else:
            threshold = self.cooperation_threshold
        if cooperation_rate < threshold:
            return Action.D
        return Action.C

    def _get_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the proportion of recent rounds where cooperation norm holds.
        A round is 'cooperative' if defectors <= n_players/2.
        """
        recent_window = max(3, self.n_rounds // 3)
        start_round = max(0, current_round - recent_window)
        if start_round >= current_round:
            return 1.0
        cooperative_rounds = 0
        for round_idx in range(start_round, current_round):
            defectors = np.sum(~history.opponent_actions[round_idx, :])
            if defectors <= self.n_players / 2.0:
                cooperative_rounds += 1
        window_length = current_round - start_round
        if window_length == 0:
            return 1.0
        return cooperative_rounds / window_length

    def _get_cooperation_trend(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the change in cooperation rate between two recent windows.
        Returns improvement (current - previous).
        """
        recent_window = max(3, self.n_rounds // 3)
        current_start = max(0, current_round - recent_window)
        if current_start >= current_round:
            current_rate = 1.0
        else:
            current_rate = self._calculate_window_cooperation(history, current_start, current_round)
        previous_end = current_start
        previous_start = max(0, previous_end - recent_window)
        if previous_start >= previous_end or previous_end == 0:
            previous_rate = 1.0
        else:
            previous_rate = self._calculate_window_cooperation(history, previous_start, previous_end)
        return current_rate - previous_rate

    def _calculate_window_cooperation(self, history: PlayerHistory, start_round: int, end_round: int) -> float:
        """
        Calculate cooperation rate for a specific window of rounds.
        """
        if start_round >= end_round:
            return 1.0
        cooperative_rounds = 0
        for round_idx in range(start_round, end_round):
            defectors = np.sum(~history.opponent_actions[round_idx, :])
            if defectors <= self.n_players / 2.0:
                cooperative_rounds += 1
        window_length = end_round - start_round
        if window_length == 0:
            return 1.0
        return cooperative_rounds / window_length

class Strategy_COLLECTIVE_329(BaseStrategy):
    """
    Adaptive Threshold Stewardship (ATS): A conditional cooperation strategy that balances
    individual incentives with collective sustainability by adapting cooperation thresholds
    based on stock scarcity and observed defection patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.deficit_mode_counter = 0
        self.prev_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            self.prev_stock = stock
            return Action.C
        rounds_remaining = self.n_rounds - round_num
        total_rounds = self.n_rounds
        scarcity_term = self.capacity * (0.5 + 0.3 * (rounds_remaining / total_rounds))
        my_cooperations = np.sum(history.my_actions[:round_num])
        my_defection_rate = 1.0 - my_cooperations / round_num if round_num > 0 else 0.0
        base_threshold = scarcity_term + self.capacity * 0.2 * my_defection_rate
        if round_num > 0:
            cooperators_last_round = np.sum(history.opponent_actions[round_num - 1, :])
            cooperation_rate = cooperators_last_round / self.n_players
            if cooperation_rate > 0.6:
                base_threshold -= 0.1 * self.capacity
            elif cooperation_rate < 0.3:
                base_threshold += 0.15 * self.capacity
        if stock < 0.35 * self.capacity:
            self.deficit_mode_counter += 1
            if self.deficit_mode_counter <= 2:
                self.prev_stock = stock
                return Action.D
        elif stock >= 0.5 * self.capacity:
            self.deficit_mode_counter = 0
        if stock < 0.1 * self.capacity:
            self.prev_stock = stock
            return Action.D
        if round_num > 0 and self.prev_stock > 0:
            stock_change_rate = (stock - self.prev_stock) / self.prev_stock
            if stock_change_rate < -0.6:
                self.deficit_mode_counter = 2
                self.prev_stock = stock
                return Action.D
        if round_num == total_rounds - 1:
            self.prev_stock = stock
            if stock >= 0.4 * self.capacity:
                return Action.C
            else:
                return Action.D
        self.prev_stock = stock
        if stock >= base_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_330(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual incentives with collective sustainability through dynamic
    threshold-based cooperation that maintains commons above critical sustainability levels,
    exploits defectors opportunistically, and adapts to observed player behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.base_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round_opponent_actions = history.opponent_actions[-1, :]
        num_defectors = np.sum(~last_round_opponent_actions)
        observed_defection_rate = num_defectors / (self.game_description.n_players - 1)
        alpha = self.base_threshold
        if observed_defection_rate > 0.5:
            alpha = 0.6
        elif observed_defection_rate < 0.25 and state.current_stock > 0.7 * self.game_description.capacity:
            alpha = 0.45
        else:
            alpha = self.base_threshold
        if state.current_stock >= alpha * self.game_description.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_331(BaseStrategy):
    """
    Adaptive Stewardship with Defensive Safeguards.
    
    Prioritizes collective long-term sustainability while maintaining individual payoff competitiveness.
    Uses stock-responsive cooperation with adaptive defection when opponent defection rates exceed critical thresholds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_rounds
        self.n_rounds = game_description.n_rounds
        self.critical_threshold = self.capacity * 0.35
        self.emergency_threshold = self.capacity * 0.15
        self.recovery_threshold = self.capacity * 0.4
        self.defection_rate_threshold = 0.4
        self.crisis_defection_threshold = 0.5
        self.rounds_in_defensive_posture = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if current_stock <= self.emergency_threshold:
            return Action.D
        prev_round_idx = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        cooperators_prev = np.sum(opponent_actions_prev)
        defectors_prev = self.game_description.n_players - cooperators_prev
        defection_rate_prev = defectors_prev / self.game_description.n_players if self.game_description.n_players > 0 else 0.0
        if current_stock < self.recovery_threshold and defection_rate_prev > self.crisis_defection_threshold:
            if self.rounds_in_defensive_posture < 2:
                self.rounds_in_defensive_posture += 1
                return Action.D
            else:
                self.rounds_in_defensive_posture = 0
        else:
            self.rounds_in_defensive_posture = 0
        if current_stock > self.critical_threshold:
            if defection_rate_prev > self.defection_rate_threshold:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_332(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): Balances individual reward extraction with
    collective resource preservation through adaptive punishment and cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock_current = state.current_stock
        if round_t == 0:
            return Action.C
        observed_defection_rate = self._calculate_defection_rate(history, round_t)
        if stock_current < 2 * self.n:
            return Action.C
        if round_t < 4:
            punishment_threshold = 0.6
        else:
            defection_threshold = (1 + round_t / self.r) * 0.35
            punishment_threshold = defection_threshold
        if observed_defection_rate > punishment_threshold:
            return Action.D
        rounds_remaining = self.r - round_t
        if rounds_remaining <= self.r / 3 and stock_current >= self.capacity * 0.8:
            return Action.D
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, round_t: int) -> float:
        """
        Calculate the observed defection rate across all players in all prior rounds.
        Defection is represented as False (0) in the boolean arrays.
        """
        if round_t == 0:
            return 0.0
        prior_rounds = round_t
        total_defections = 0
        for r in range(prior_rounds):
            defections_in_round = np.sum(~history.opponent_actions[r, :])
            total_defections += defections_in_round
        own_defections = np.sum(~history.my_actions[:prior_rounds])
        total_defections += own_defections
        total_possible = self.n * prior_rounds
        if total_possible == 0:
            return 0.0
        return total_defections / total_possible

class Strategy_COLLECTIVE_333(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A strategy that prioritizes long-term collective welfare
    by monitoring resource health and adapting to opponent behavior patterns.
    
    Core mechanism: Decisions are based on stock-to-capacity ratio (ρ), with adaptive thresholds
    that shift when opponent defection rates exceed 75%.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.C
        rho = current_stock / self.capacity if self.capacity > 0 else 0.0
        last_round_opponent_actions = history.opponent_actions[round_num - 1, :]
        opponent_defections = np.sum(~last_round_opponent_actions)
        defection_rate = opponent_defections / (self.n_players - 1) if self.n_players > 1 else 0.0
        high_threshold = 0.75
        mid_threshold = 0.5
        low_threshold = 0.25
        if defection_rate > 0.75 and rho > 0.5:
            high_threshold = 0.5
            mid_threshold = 0.35
            low_threshold = 0.15
        if rho > high_threshold:
            return Action.C
        elif rho > mid_threshold:
            return Action.C
        elif rho > low_threshold:
            if defection_rate >= 0.5:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_334(BaseStrategy):
    """
    Adaptive Collective Stewardship Strategy (ACS)
    
    Balances individual payoff maximization with collective resource sustainability.
    Monitors stock health and adapts behavior based on whether the system is in a
    sustainable equilibrium or trajectory toward depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if self.capacity > 0:
            stock_health_ratio = current_stock / self.capacity
        else:
            stock_health_ratio = 0.0
        if round_number == 0:
            return Action.C
        if stock_health_ratio >= 0.75:
            return Action.C
        if stock_health_ratio < 0.4:
            return Action.D
        if round_number >= self.n_rounds - 2:
            if stock_health_ratio >= 0.5:
                return Action.C
            else:
                return Action.D
        cooperation_rate = self._measure_recent_cooperation(history, round_number)
        if cooperation_rate >= 0.6:
            return Action.C
        elif cooperation_rate >= 0.4:
            return Action.C if random.random() < 0.65 else Action.D
        else:
            return Action.D

    def _measure_recent_cooperation(self, history: PlayerHistory, round_number: int) -> float:
        """
        Measure the cooperation rate of other players in the last k rounds.
        k = min(3, rounds_played)
        
        Returns: fraction of cooperations observed (0.0 to 1.0)
        """
        if round_number == 0:
            return 1.0
        k = min(3, round_number)
        start_idx = round_number - k
        recent_opponent_actions = history.opponent_actions[start_idx:round_number, :]
        total_cooperations = np.sum(recent_opponent_actions)
        total_possible = k * (self.n_players - 1)
        if total_possible > 0:
            cooperation_rate = total_cooperations / total_possible
        else:
            cooperation_rate = 0.0
        return cooperation_rate

class Strategy_COLLECTIVE_335(BaseStrategy):
    """
    Adaptive Sustainability with Reciprocal Enforcement strategy for Common Pool Resource Game.
    
    Prioritizes long-term collective welfare through stock-health monitoring and reciprocal
    punishment of defectors, while maintaining cooperation during critical stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_stock = 0.4
        self.critical_stock = 0.15
        self.recovery_stock = 0.5
        self.healthy_stock = 0.6
        self.defection_memory = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if stock < self.capacity * self.critical_stock:
            return Action.C
        if stock < self.capacity * self.threshold_stock:
            return Action.D
        defection_rate_prev = self._calculate_defection_rate(history, round_num - 1)
        if round_num == self.n_rounds - 1:
            if stock >= self.capacity * self.healthy_stock and defection_rate_prev <= 0.25:
                return Action.C
            else:
                return Action.D
        if self.n_rounds - round_num <= 2 and stock < self.capacity * 0.3:
            return Action.C
        if defection_rate_prev == 0:
            return Action.C
        elif defection_rate_prev <= 0.25:
            return Action.C
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, round_idx: int) -> float:
        """
        Calculate the defection rate in a given round.
        Returns the fraction of opponents who defected (played D, which is False/0).
        """
        if round_idx < 0 or round_idx >= len(history.opponent_actions):
            return 0.0
        round_actions = history.opponent_actions[round_idx, :]
        num_defectors = np.sum(~round_actions)
        defection_rate = num_defectors / self.n_players if self.n_players > 0 else 0.0
        return float(defection_rate)

class Strategy_COLLECTIVE_336(BaseStrategy):
    """
    Adaptive Stewardship with Reciprocal Monitoring for Common Pool Resource Game.
    
    Balances personal benefit through selective defection with collective sustainability
    by monitoring stock levels and opponent defection patterns. Uses stock-conditional
    cooperation thresholds and reciprocal monitoring to adapt to opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.threshold_critical = self.capacity * 0.25
        self.threshold_high = self.capacity * 0.7
        self.threshold_mid = self.capacity * 0.45
        self.threshold_collapse = self.capacity * 0.1
        self.threshold_stabilize = self.capacity * 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_stock < self.threshold_collapse:
            return Action.C
        if current_stock <= self.threshold_critical:
            return Action.C
        if current_round == self.n_rounds - 1:
            if current_stock <= self.threshold_critical:
                return Action.C
            else:
                return Action.D
        if current_round == 0:
            return Action.C
        if current_round >= 3 and history is not None:
            stocks_last_3 = [history.my_payoffs[current_round - 3], history.my_payoffs[current_round - 2], history.my_payoffs[current_round - 1]]
            recent_actions = history.my_actions[max(0, current_round - 3):current_round]
            recent_defections = np.sum(~recent_actions)
            if recent_defections >= 2 and current_stock < self.threshold_stabilize:
                return Action.C
        if current_stock >= self.threshold_high:
            return Action.D
        if current_round >= 1 and history is not None:
            lookback = min(3, current_round)
            recent_opponent_actions = history.opponent_actions[current_round - lookback:current_round, :]
            defections_observed = np.sum(~recent_opponent_actions)
            total_possible = lookback * self.n_players
            if total_possible > 0:
                defection_ratio = defections_observed / total_possible
            else:
                defection_ratio = 0.0
            if defection_ratio > 0.6:
                return Action.C
            elif defection_ratio < 0.3:
                return Action.D
            else:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_337(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Defection
    
    A stock-health responsive strategy that maintains sustainable collective outcomes
    while protecting against exploitation. Cooperation is keyed to resource abundance
    and observed defection rates, with graduated intolerance as scarcity increases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            if self.capacity >= 4 * self.n_players:
                return Action.C
            else:
                return Action.D
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        observed_defection_rate = self._get_defection_rate(history, round_number - 1)
        if stock_health < 0.3:
            return Action.D
        elif stock_health < 0.6:
            tolerance = 0.1 + 0.3 * (stock_health - 0.3) / 0.3
            if observed_defection_rate <= tolerance:
                return Action.C
            else:
                return Action.D
        else:
            tolerance = 0.5 - 0.4 * (1.0 - stock_health)
            if round_number == self.n_rounds - 1:
                if stock_health >= 0.7 and observed_defection_rate <= 0.3:
                    return Action.C
                else:
                    return Action.D
            if observed_defection_rate <= tolerance:
                return Action.C
            else:
                return Action.D

    def _get_defection_rate(self, history: PlayerHistory, round_idx: int) -> float:
        """
        Calculate the defection rate from the previous round.
        
        Boolean encoding: True = Cooperate (Action.C), False = Defect (Action.D)
        Defection rate = number of defectors / total opponents
        """
        if round_idx < 0 or round_idx >= history.opponent_actions.shape[0]:
            return 0.0
        actions_in_round = history.opponent_actions[round_idx, :]
        num_defectors = np.sum(~actions_in_round)
        total_opponents = actions_in_round.shape[0]
        if total_opponents == 0:
            return 0.0
        return float(num_defectors) / float(total_opponents)

class Strategy_COLLECTIVE_338(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A stock-health-aware strategy that cooperates
    when stocks are abundant or critical, and adaptively responds to defection rates
    in the medium range. Prioritizes collective sustainability while remaining robust
    to defectors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.upper_threshold = 1.2 * self.capacity / 2.0
        self.lower_threshold = 0.15 * self.capacity
        self.defection_threshold = 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_level = state.current_stock
        round_number = state.round_number
        recent_defection_rate = self._calculate_recent_defection_rate(history)
        if stock_level <= 0.05 * self.capacity:
            return Action.C
        if stock_level > self.upper_threshold:
            return Action.C
        elif stock_level > self.lower_threshold:
            if recent_defection_rate < self.defection_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the defection rate from the most recent round.
        Returns a float between 0 and 1 representing the proportion of opponents who defected.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        last_round_opponent_actions = history.opponent_actions[-1, :]
        defection_count = np.sum(last_round_opponent_actions == False)
        total_opponents = len(last_round_opponent_actions)
        if total_opponents == 0:
            return 0.0
        defection_rate = float(defection_count) / float(total_opponents)
        return defection_rate

class Strategy_COLLECTIVE_339(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS) for Common Pool Resource Games.
    
    Balances individual reward maximization with collective long-term sustainability.
    Uses stock health to adaptively adjust cooperation probability, with special handling
    for critical stock levels and final round defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_health >= 0.75:
            return Action.C
        elif stock_health >= 0.4:
            p_adapt = (stock_health - 0.4) / 0.35
            if random.random() < p_adapt:
                return Action.C
            else:
                return Action.D
        elif stock_health >= 0.15:
            if random.random() < 0.3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_340(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy for Common Pool Resource games
    that prioritizes long-term stock sustainability while maintaining resilience against exploitation.
    
    Uses stock-phase-based decision rules (Abundant, Healthy, Stressed, Critical, Depleted)
    combined with defection-rate monitoring to balance cooperation and self-protection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        recent_defection_rate = self._calculate_recent_defection_rate(history, state.round_number)
        if recent_defection_rate > 0.6:
            return Action.D
        phase = self._classify_stock_phase(stock_ratio)
        rounds_remaining = self.n_rounds - state.round_number
        if rounds_remaining <= 2 and phase in ['ABUNDANT', 'HEALTHY']:
            return Action.C
        if phase == 'ABUNDANT':
            return Action.C
        elif phase == 'HEALTHY':
            return Action.C
        elif phase == 'STRESSED':
            coop_rate = self._calculate_cooperation_rate(history, state.round_number)
            if coop_rate >= 0.75:
                return Action.C
            else:
                return Action.D
        elif phase == 'CRITICAL':
            return Action.D
        else:
            return Action.D

    def _classify_stock_phase(self, stock_ratio: float) -> str:
        """Classify stock health into phases based on stock ratio."""
        if stock_ratio > 0.75:
            return 'ABUNDANT'
        elif stock_ratio > 0.5:
            return 'HEALTHY'
        elif stock_ratio > 0.25:
            return 'STRESSED'
        elif stock_ratio > 0.0:
            return 'CRITICAL'
        else:
            return 'DEPLETED'

    def _calculate_recent_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the defection rate by others in recent rounds.
        Track: recent_defection_rate = (defections by others in last k rounds) / (k × (n-1))
        where k = min(5, rounds_completed)
        """
        rounds_completed = round_number
        if rounds_completed == 0:
            return 0.0
        k = min(5, rounds_completed)
        start_idx = max(0, rounds_completed - k)
        recent_opponent_actions = history.opponent_actions[start_idx:rounds_completed, :]
        defection_count = np.sum(~recent_opponent_actions)
        total_possible = k * (self.n_players - 1)
        if total_possible == 0:
            return 0.0
        defection_rate = defection_count / total_possible
        return float(defection_rate)

    def _calculate_cooperation_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the cooperation rate by others in recent k rounds.
        k = min(3, rounds_completed)
        """
        rounds_completed = round_number
        if rounds_completed == 0:
            return 0.0
        k = min(3, rounds_completed)
        start_idx = max(0, rounds_completed - k)
        recent_opponent_actions = history.opponent_actions[start_idx:rounds_completed, :]
        cooperation_count = np.sum(recent_opponent_actions)
        total_possible = k * (self.n_players - 1)
        if total_possible == 0:
            return 0.0
        cooperation_rate = cooperation_count / total_possible
        return float(cooperation_rate)

class Strategy_COLLECTIVE_341(BaseStrategy):
    """
    Adaptive Stewardship with Resilient Defection
    
    Balances collective resource preservation with individual resilience against exploitation.
    - Cooperates when stock is healthy (≥40% capacity) and defection pressure is low
    - Defects when stock is critically depleted, majority defects, or degradation trend detected
    - Always cooperates in round 1 to establish baseline
    - Tracks consecutive defection rounds to limit defensive escalation
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.healthy_threshold = self.capacity * 0.4
        self.collapse_threshold = self.capacity * 0.15
        self.intermediate_threshold = self.capacity * 0.25
        self.defection_trigger = 0.5
        self.defection_trajectory_trigger = 0.3
        self.stock_trend_threshold = -0.1 * self.capacity
        self.max_consecutive_defections = 2
        self.consecutive_defection_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.consecutive_defection_rounds = 0
            return Action.C
        current_stock = state.current_stock
        current_round = state.round_number
        previous_round_idx = current_round - 1
        opponent_actions_prev = history.opponent_actions[previous_round_idx, :]
        defection_ratio_previous = 1.0 - np.sum(opponent_actions_prev) / self.n_players
        stock_history = [state.current_stock]
        stock_trend = 0.0
        if current_round >= 2:
            stock_trend = 0.0
        if current_stock < self.collapse_threshold:
            self.consecutive_defection_rounds += 1
            return Action.D
        if defection_ratio_previous >= self.defection_trigger:
            if self.consecutive_defection_rounds < self.max_consecutive_defections:
                self.consecutive_defection_rounds += 1
                return Action.D
            elif current_stock >= self.healthy_threshold:
                self.consecutive_defection_rounds = 0
                return Action.C
            else:
                self.consecutive_defection_rounds += 1
                return Action.D
        if stock_trend < self.stock_trend_threshold and defection_ratio_previous > self.defection_trajectory_trigger:
            self.consecutive_defection_rounds += 1
            return Action.D
        if current_stock >= self.healthy_threshold and defection_ratio_previous < self.defection_trigger:
            self.consecutive_defection_rounds = 0
            if current_round == self.n_rounds - 1:
                return Action.C
            return Action.C
        if current_stock >= self.intermediate_threshold:
            if defection_ratio_previous < 0.33:
                self.consecutive_defection_rounds = 0
                return Action.C
            else:
                self.consecutive_defection_rounds += 1
                return Action.D
        self.consecutive_defection_rounds += 1
        return Action.D

class Strategy_COLLECTIVE_342(BaseStrategy):
    """
    Collective Adaptive Stewardship Strategy (CASS)
    
    Balances individual benefit extraction with collective sustainability by adapting
    behavior based on stock health. Operates in three modes:
    - Abundant (ratio ≥ 0.6): Cooperate
    - Transitional (0.3 ≤ ratio < 0.6): Probabilistic defection
    - Critical (ratio < 0.3): Cooperate
    
    Includes end-game adjustments and round-based caution for sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 1.0
        rounds_remaining = self.n_rounds - current_round
        if stock_ratio < 0.3:
            return Action.C
        if rounds_remaining <= 2 and stock_ratio < 0.5:
            return Action.C
        if stock_ratio >= 0.6:
            return Action.C
        if stock_ratio >= 0.3:
            defection_probability = (0.6 - stock_ratio) / 0.3
            if random.random() < defection_probability:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_COLLECTIVE_343(BaseStrategy):
    """
    Collective Pool Stewardship Strategy (CPSS)
    
    Balances immediate gains with long-term sustainability through stock-based
    cooperation thresholds. Defects when stock is healthy (H ≥ 0.75), cooperates
    when stressed, with dynamic adjustment based on stock momentum and end-game logic.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        round_num = state.round_number
        rounds_total = self.game_description.n_rounds
        self.stock_history.append(current_stock)
        if current_stock < capacity * 0.25:
            return Action.C
        rounds_remaining = rounds_total - round_num
        if rounds_remaining <= 2:
            if current_stock < capacity * 0.5:
                return Action.C
            else:
                return Action.D
        if round_num == 0:
            return Action.D
        health = current_stock / capacity
        base_threshold = 0.75
        if len(self.stock_history) >= 3:
            recent_change = self.stock_history[-1] - self.stock_history[-3]
            if recent_change > 0:
                base_threshold -= 0.05
            elif recent_change < 0:
                base_threshold += 0.05
        base_threshold = max(0.0, min(1.0, base_threshold))
        if health >= base_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_344(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Reciprocity
    
    A collective strategy that maximizes long-term aggregate welfare by:
    1. Cooperating when stock is healthy (above 25% capacity)
    2. Defecting when stock is critically low (below 25% capacity)
    3. Matching defection when more than half opponents defect
    4. Detecting tragedy spirals and increasing defensive posture
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_critical = self.capacity * 0.25
        self.threshold_defection = math.floor(self.n_players / 2)
        self.adjusted_threshold_defection = self.threshold_defection
        self.detected_spiral = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if stock < 2 * self.n_players:
            return Action.D
        defection_count = self.n_players - int(sum(history.opponent_actions[-1, :]))
        if round_num >= 3 and (not self.detected_spiral):
            self.detected_spiral = self._detect_tragedy_spiral(history, round_num)
            if self.detected_spiral:
                self.adjusted_threshold_defection = max(1, self.threshold_defection - 1)
        if defection_count > self.adjusted_threshold_defection:
            return Action.D
        if stock > self.threshold_critical:
            return Action.C
        else:
            return Action.D

    def _detect_tragedy_spiral(self, history: PlayerHistory, round_num: int) -> bool:
        """
        Detect if there's a tragedy spiral:
        - Stock declined by >20% over last 3 rounds
        - Defection count in previous round > threshold
        """
        if round_num < 3:
            return False
        recent_defections = []
        for i in range(max(0, round_num - 3), round_num):
            defect_count = self.n_players - int(sum(history.opponent_actions[i, :]))
            recent_defections.append(defect_count)
        avg_recent_defections = sum(recent_defections) / len(recent_defections)
        return avg_recent_defections > self.threshold_defection

class Strategy_COLLECTIVE_345(BaseStrategy):
    """
    Adaptive Resource Stewardship: Conditional cooperation with punishment.
    
    Maximizes long-term collective welfare by cooperating when others cooperate,
    punishing widespread defection, and maintaining restraint even in endgame
    scenarios to signal commitment to collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        prev_cooperators = int(np.sum(history.opponent_actions[round_number - 1, :]))
        defection_count = self.n_players - prev_cooperators
        cooperation_threshold = (self.n_players - 1) / self.n_players
        punish_threshold = math.ceil(self.n_players / 2)
        cooperation_rate = prev_cooperators / self.n_players
        if round_number >= 2:
            recent_stocks = [current_stock]
            if round_number >= 1:
                pass
            if current_stock < 2 * self.n_players:
                return Action.C
        rounds_remaining = self.n_rounds - round_number
        if rounds_remaining <= 2 and current_stock < self.capacity / 2:
            return Action.C
        if current_stock > 2 / 3 * self.capacity:
            return Action.C
        if cooperation_rate >= cooperation_threshold:
            return Action.C
        if defection_count >= punish_threshold:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_346(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Reciprocity.
    
    Balances self-protection against free-riders with stock preservation for long-term
    collective benefit. Uses Stock Health Index and Defection Rate to make adaptive
    decisions based on resource state and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.consecutive_high_defection_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        stock_health_index = self._compute_stock_health_index(state.current_stock)
        defection_rate = self._compute_defection_rate(history)
        decision = self._make_decision(stock_health_index, defection_rate)
        return decision

    def _compute_stock_health_index(self, current_stock: float) -> float:
        """Compute SHI = current_stock / capacity."""
        if self.capacity <= 0:
            return 0.0
        return current_stock / self.capacity

    def _compute_defection_rate(self, history: PlayerHistory) -> float:
        """
        Compute defection rate in the previous round.
        DR = number_of_defectors / n
        
        True = Cooperate (Action.C), False = Defect (Action.D)
        So defectors are those with False values.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        last_round_actions = history.opponent_actions[-1, :]
        num_defectors = np.sum(~last_round_actions)
        if self.n_players <= 0:
            return 0.0
        return float(num_defectors) / float(self.n_players)

    def _make_decision(self, shi: float, dr: float) -> Action:
        """
        Apply decision logic based on Stock Health Index and Defection Rate.
        
        Returns Action.C (Cooperate) or Action.D (Defect).
        """
        if shi >= 0.5:
            if dr <= 0.25:
                return Action.C
            else:
                return Action.D
        elif shi >= 0.25:
            if dr <= 0.33:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_347(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Treats the common pool as a shared resource requiring active stewardship.
    Uses conditional tit-for-tat with stock awareness to balance cooperation
    and self-preservation across three phases: abundance (high stock),
    reciprocal (moderate stock), and crisis (low stock).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.abundance_threshold = 0.75 * self.capacity
        self.crisis_threshold = 0.4 * self.capacity
        self.cooperation_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        return self._decide_middle_rounds(current_stock, round_number, history)

    def _decide_middle_rounds(self, current_stock: float, round_number: int, history: PlayerHistory) -> Action:
        """
        Primary decision logic for middle rounds (1 to r-2).
        Implements three-phase strategy based on stock levels.
        """
        if current_stock >= self.abundance_threshold:
            return Action.C
        if current_stock < self.crisis_threshold:
            return Action.D
        previous_round_idx = round_number - 1
        opponent_actions_prev_round = history.opponent_actions[previous_round_idx, :]
        num_cooperators = int(np.sum(opponent_actions_prev_round))
        cooperation_rate = num_cooperators / self.n_players
        if cooperation_rate >= self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_348(BaseStrategy):
    """
    Adaptive Stewardship with Contingent Defection.
    
    This strategy maintains a common pool resource by balancing sustainability,
    reciprocity, and robustness. It uses stock health and observed defection rates
    to determine whether to cooperate or defect, with special handling for the
    final round and critical stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if round_number == self.n_rounds - 1:
            if health_ratio < 0.2:
                return Action.C
            else:
                return Action.D
        defection_rate = self._calculate_defection_rate(history, round_number)
        if health_ratio >= 0.7:
            if defection_rate <= 0.25:
                return Action.C
            else:
                return Action.D
        elif health_ratio >= 0.4:
            if defection_rate <= 0.15:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the proportion of opponent actions that were defections.
        Defection is represented by False (Action.D).
        Cooperation is represented by True (Action.C).
        
        Returns a value in [0, 1] representing defection_rate.
        """
        if round_number <= 0:
            return 0.0
        opponent_actions_array = history.opponent_actions[:round_number, :]
        total_actions = opponent_actions_array.size
        if total_actions == 0:
            return 0.0
        defection_count = np.sum(opponent_actions_array == False)
        defection_rate = float(defection_count) / float(total_actions)
        return defection_rate

class Strategy_COLLECTIVE_349(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy that prioritizes long-term
    resource health while adapting to stock levels and observed defection rates.
    
    Core logic:
    - High stock (>75% capacity): Always cooperate for sustained growth
    - Medium stock (40-75% capacity): Cooperate if <50% defection observed, else defect
    - Low stock (<=40% capacity): Defect to protect self, with hysteresis mechanism
    - First round: Always cooperate
    - Hysteresis: After defecting, require 2 rounds of <30% defection before re-cooperating
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_action = None
        self.rounds_defecting = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_action = Action.C
            self.rounds_defecting = 0
            return Action.C
        prev_round_idx = state.round_number - 1
        defection_count = np.sum(~history.opponent_actions[prev_round_idx, :])
        defection_rate = defection_count / self.game_description.n_players
        stock = state.current_stock
        capacity = self.game_description.capacity
        upper_threshold = capacity * 0.75
        middle_threshold = capacity * 0.4
        if stock > upper_threshold:
            self.last_action = Action.C
            self.rounds_defecting = 0
            return Action.C
        elif stock > middle_threshold:
            if defection_rate < 0.5:
                self.last_action = Action.C
                self.rounds_defecting = 0
                return Action.C
            else:
                self.last_action = Action.D
                self.rounds_defecting += 1
                return Action.D
        elif self.last_action == Action.D:
            if defection_rate < 0.3:
                self.last_action = Action.C
                self.rounds_defecting = 0
                return Action.C
            else:
                self.rounds_defecting += 1
                return Action.D
        else:
            self.last_action = Action.D
            self.rounds_defecting = 1
            return Action.D

class Strategy_COLLECTIVE_350(BaseStrategy):
    """
    Adaptive Collective Stewardship Strategy (ACS)
    
    A stock-aware, history-sensitive strategy that balances individual payoff maximization
    with collective sustainability. It uses adaptive thresholds based on remaining rounds
    and stock levels, combined with graduated responses to opponent defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock_t = state.current_stock
        if round_t == 0:
            return Action.C
        if stock_t < 0.2 * self.capacity:
            return Action.C
        if round_t == self.n_rounds - 1:
            terminal_threshold = self.capacity * 0.3
            if stock_t < terminal_threshold:
                return Action.C
            else:
                return Action.D
        remaining_rounds = self.n_rounds - round_t
        stock_threshold = self.capacity * (0.4 + 0.1 * remaining_rounds / self.n_rounds)
        if stock_t < stock_threshold:
            return Action.C
        history_depth = min(3, round_t)
        recent_history_start = round_t - history_depth
        recent_opponent_actions = history.opponent_actions[recent_history_start:round_t, :]
        total_opponent_actions = recent_opponent_actions.size
        if total_opponent_actions == 0:
            defection_rate = 0.0
        else:
            defections = np.sum(recent_opponent_actions == 0)
            defection_rate = float(defections) / float(total_opponent_actions)
        if round_t <= self.n_rounds / 3:
            defection_threshold_low = 0.15
        else:
            defection_threshold_low = 0.25
        if defection_rate > 0.5:
            return Action.C
        elif defection_rate > defection_threshold_low:
            cooperation_prob = 1.0 - defection_rate
            if random.random() < cooperation_prob:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_351(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances sustainability, fairness, and adaptability by:
    - Always cooperating in round 1 to establish trust
    - Prioritizing resource recovery when stock is critically low
    - Monitoring defection rates and responding proportionally
    - Avoiding final-round defection to maintain collective welfare
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity * 0.25
        self.defection_tolerance = 1.0 / self.n_players + 0.15

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        if current_stock < self.critical_threshold:
            return Action.C
        observed_defection_rate = self._calculate_defection_rate(round_number, history)
        if observed_defection_rate > self.defection_tolerance:
            return Action.D
        else:
            return Action.C

    def _calculate_defection_rate(self, round_number: int, history: PlayerHistory) -> float:
        """
        Calculate the defection rate from the last k rounds.
        k = min(3, current_round - 1) to smooth noise.
        
        Defection is represented as False (0) in the arrays.
        We count defections (False values) among all opponents.
        """
        k = min(3, round_number)
        if k == 0:
            return 0.0
        start_idx = max(0, round_number - k)
        recent_opponent_actions = history.opponent_actions[start_idx:round_number, :]
        defections = np.sum(recent_opponent_actions == False)
        total_actions = k * self.n_players
        if total_actions == 0:
            return 0.0
        observed_defection_rate = defections / total_actions
        return observed_defection_rate

class Strategy_COLLECTIVE_352(BaseStrategy):
    """
    Collective Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances sustainability, adaptability, and robustness by:
    - Cooperating as default in stable conditions
    - Defecting when resource is critical or defection is widespread
    - Responding to stock trends in final rounds
    - Opening with cooperation to establish collective intent
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.minimum_safe_stock = self.capacity * 0.3
        self.danger_stock = self.capacity * 0.15

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if current_stock < self.danger_stock:
            return Action.D
        if current_stock < self.minimum_safe_stock:
            return Action.C
        total_rounds_played = round_number
        total_player_rounds = self.n_players * total_rounds_played
        opponent_defections = np.sum(~history.opponent_actions)
        my_defections = np.sum(~history.my_actions)
        total_defections = opponent_defections + my_defections
        if total_player_rounds > 0:
            defection_rate = total_defections / total_player_rounds
            high_defection_threshold = (self.n_players - 1) / self.n_players * 0.6
            low_defection_threshold = (self.n_players - 1) / self.n_players * 0.2
            if defection_rate > high_defection_threshold:
                return Action.D
            if defection_rate < low_defection_threshold:
                return Action.C
        if round_number >= self.n_rounds - 2:
            if round_number > 0:
                stock_trend = self._estimate_stock_trend(history, round_number)
                if stock_trend >= 0:
                    return Action.C
                else:
                    return Action.D
        return Action.C

    def _estimate_stock_trend(self, history: PlayerHistory, current_round: int) -> float:
        """
        Estimate stock trend from recent rounds.
        Returns positive if stock appears stable/growing, negative if declining.
        """
        if current_round < 2:
            return 0.0
        recent_cooperators_prev = np.sum(history.opponent_actions[current_round - 2, :])
        recent_cooperators_curr = np.sum(history.opponent_actions[current_round - 1, :])
        if recent_cooperators_prev >= self.n_players / 2 and recent_cooperators_curr >= self.n_players / 2:
            return 1.0
        return -1.0

class Strategy_COLLECTIVE_353(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection.
    
    Balances individual payoff maximization with collective resource sustainability.
    Core insight: defection is rational only when the resource is sufficiently abundant.
    When scarcity threatens, shift to cooperation to preserve the commons.
    
    Decision rule:
    - Final round: defect if stock > 0
    - Early/mid game: cooperate if stock ≤ threshold_aggressive, else defect
    - Threshold: 1.5 × (capacity / n)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_aggressive = 1.5 * (self.capacity / self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            if current_stock > 0:
                return Action.D
            else:
                return Action.C
        if current_stock <= self.threshold_aggressive:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_354(BaseStrategy):
    """
    Adaptive Stewardship with Defensive Safeguards strategy for Common Pool Resource Game.
    
    Prioritizes sustainable collective welfare through conditional cooperation:
    - Cooperates when stock is healthy and defection rate is low
    - Defects when stock is critically depleted or majority defection is observed
    - Always cooperates in round 1 to establish cooperative baseline
    - Cooperates in final round if conditions allow, signaling intrinsic valuation of cooperation
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock = self.capacity * 0.3
        self.optimal_stock = self.capacity * 0.5
        self.defection_threshold = 0.5
        self.lookback_rounds = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        last_k_rounds = min(self.lookback_rounds, current_round)
        defections_observed = self._count_defections(history, last_k_rounds, current_round)
        total_actions_observed = current_round * self.n_players
        if total_actions_observed > 0:
            defection_rate = defections_observed / total_actions_observed
        else:
            defection_rate = 0.0
        if current_stock <= self.critical_stock:
            return Action.D
        if defection_rate > self.defection_threshold:
            return Action.D
        if current_round == self.n_rounds - 1:
            if current_stock > self.critical_stock and defection_rate <= self.defection_threshold:
                return Action.C
            else:
                return Action.D
        return Action.C

    def _count_defections(self, history: PlayerHistory, last_k_rounds: int, current_round: int) -> int:
        """
        Count the number of defection actions (False/0) in opponent history over last k rounds.
        
        Args:
            history: PlayerHistory object containing opponent_actions
            last_k_rounds: Number of recent rounds to examine
            current_round: Current round number (0-indexed)
        
        Returns:
            Total count of defections observed in opponent actions
        """
        if current_round == 0:
            return 0
        start_round = max(0, current_round - last_k_rounds)
        end_round = current_round
        relevant_actions = history.opponent_actions[start_round:end_round, :]
        defections = np.sum(relevant_actions == False)
        return int(defections)

class Strategy_COLLECTIVE_355(BaseStrategy):
    """
    Adaptive Stewardship Strategy: Stock-Aware Tit-for-Tat with Sustainability Thresholds
    
    Balances collective sustainability, reciprocal fairness, and individual security by:
    1. Monitoring stock health (GREEN/YELLOW/RED zones)
    2. Tracking observed cooperation rates among opponents
    3. Adapting decisions based on stock stress and cooperation levels
    4. Using mixed strategies to prevent exploitation while maintaining sustainability
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.prev_coop_rate = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.capacity
        prev_round_idx = state.round_number - 1
        opponent_cooperations = np.sum(history.opponent_actions[prev_round_idx, :])
        observed_coop_rate = opponent_cooperations / (self.n_players - 1)
        if self.prev_coop_rate is not None:
            observed_coop_rate = (self.prev_coop_rate + observed_coop_rate) / 2.0
        self.prev_coop_rate = observed_coop_rate
        coop_threshold_adjustment = 0.1 if self.n_players > 10 else 0.0
        if state.current_stock < 2 * self.n_players:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            if stock_ratio < 0.3:
                return Action.C
            elif observed_coop_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if stock_ratio < 0.3:
            return Action.C
        elif stock_ratio < 0.5:
            threshold_high = 0.75 - coop_threshold_adjustment
            threshold_mid = 0.5 - coop_threshold_adjustment
            if observed_coop_rate >= threshold_high:
                return Action.C
            elif observed_coop_rate >= threshold_mid:
                return Action.C if random.random() < 0.75 else Action.D
            else:
                return Action.D
        else:
            threshold_high = 0.6 - coop_threshold_adjustment
            threshold_mid = 0.4 - coop_threshold_adjustment
            if observed_coop_rate >= threshold_high:
                return Action.C
            elif observed_coop_rate >= threshold_mid:
                return Action.C if random.random() < 0.6 else Action.D
            else:
                return Action.D

class Strategy_COLLECTIVE_356(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Accountability for Common Pool Resource Game.
    
    Uses stock health assessment and inferred cooperation rates to make decisions:
    - Round 1: Always cooperate (bootstrap)
    - Final rounds: Defect if cooperation rate < threshold, else cooperate
    - Other rounds: Decision matrix based on stock health and cooperation rate
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = [game_description.capacity]
        self.coop_rate = 0.0

    def _infer_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Infer cooperation rate from stock dynamics and observed payoffs.
        
        Estimates what fraction of players cooperated based on:
        - Stock trajectory changes
        - Personal payoff relative to theoretical maximums
        """
        if len(self.stock_history) < 2:
            return 1.0
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        prev_stock = self.stock_history[-2]
        curr_stock = self.stock_history[-1]
        if prev_stock <= 0:
            return 0.0
        if history is not None and len(history.my_payoffs) > 0:
            my_last_payoff = history.my_payoffs[-1]
            theoretical_coop_payoff = prev_stock / (2 * n)
            theoretical_def_payoff = prev_stock / n
            stock_ratio = curr_stock / max(capacity, 0.001)
            if stock_ratio > 0.75:
                estimated_coop = 0.85
            elif stock_ratio > 0.6:
                estimated_coop = 0.7
            elif stock_ratio > 0.4:
                estimated_coop = 0.55
            elif stock_ratio > 0.2:
                estimated_coop = 0.35
            else:
                estimated_coop = 0.15
            return estimated_coop
        return 0.5

    def _assess_stock_health(self, current_stock: float) -> str:
        """Classify stock health as HEALTHY, MODERATE, or DEPLETED."""
        capacity = self.game_description.capacity
        stock_ratio = current_stock / max(capacity, 0.001)
        if stock_ratio > 0.75:
            return 'HEALTHY'
        elif stock_ratio >= 0.4:
            return 'MODERATE'
        else:
            return 'DEPLETED'

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        n_rounds = self.game_description.n_rounds
        self.stock_history.append(current_stock)
        if round_num == 0:
            return Action.C
        self.coop_rate = self._infer_cooperation_rate(history)
        health = self._assess_stock_health(current_stock)
        if round_num == n_rounds - 1:
            if self.coop_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        if round_num == n_rounds - 2:
            if self.coop_rate >= 0.45:
                return Action.C
            else:
                return Action.D
        if health == 'HEALTHY':
            if self.coop_rate >= 0.7:
                return Action.C
            elif self.coop_rate >= 0.4:
                return Action.C
            else:
                return Action.D
        elif health == 'MODERATE':
            if self.coop_rate >= 0.7:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_357(BaseStrategy):
    """
    Adaptive Stock Management with Resilient Cooperation.
    
    Prioritizes collective long-term welfare by maintaining a stock-dependent
    cooperation threshold. Cooperates when stock is healthy, defects when
    stock falls below critical levels or in final round with compromised stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if stock < 0.1 * self.capacity:
            return Action.D
        if stock > 1.8 * self.capacity:
            return Action.C
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            if stock >= 1.5 * self.capacity:
                return Action.C
            else:
                return Action.D
        threshold = 1.5 * self.capacity
        stock_low = 0.3 * self.capacity
        if stock >= threshold and stock >= stock_low:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_358(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Reciprocity: A stock-health-responsive strategy
    that prioritizes long-term collective sustainability while remaining robust to exploitation.
    
    Core mechanism:
    - Cooperates when stock is healthy (≥60% capacity)
    - Tracks recent and lifetime defection rates of opponents
    - Applies graduated retaliation based on defection severity
    - Adjusts behavior in crisis zones and special cases (first/last round)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock = state.current_stock
        round_num = state.round_number
        health_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        recent_rcdr = self._calculate_recent_rcdr(history, round_num)
        lifetime_ldr = self._calculate_lifetime_ldr(history, round_num)
        if round_num == self.n_rounds - 1:
            return Action.C if health_ratio > 0.3 else Action.D
        if recent_rcdr > 0.7:
            return Action.D
        if recent_rcdr > 0.4 and health_ratio < 0.6:
            return Action.D
        if lifetime_ldr > 0.6:
            return Action.D
        if health_ratio >= 0.6:
            return Action.C
        if health_ratio >= 0.3 and recent_rcdr <= 0.4:
            return Action.C
        return Action.D

    def _calculate_recent_rcdr(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate Recent Collective Defection Rate (RCDR).
        Uses last 5 rounds (or fewer if not available).
        Returns defection rate among all opponents in recent rounds.
        """
        lookback_rounds = min(5, round_num)
        if lookback_rounds == 0:
            return 0.0
        start_idx = round_num - lookback_rounds
        recent_opponent_actions = history.opponent_actions[start_idx:round_num, :]
        defections = np.sum(recent_opponent_actions == 0)
        total_actions = recent_opponent_actions.size
        if total_actions == 0:
            return 0.0
        rcdr = defections / total_actions
        return rcdr

    def _calculate_lifetime_ldr(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate Lifetime Defection Rate (LDR).
        Returns defection rate among all opponents across all past rounds.
        """
        if round_num == 0:
            return 0.0
        all_opponent_actions = history.opponent_actions[:round_num, :]
        defections = np.sum(all_opponent_actions == 0)
        total_actions = all_opponent_actions.size
        if total_actions == 0:
            return 0.0
        ldr = defections / total_actions
        return ldr

class Strategy_COLLECTIVE_359(BaseStrategy):
    """
    Adaptive Stewardship with Defensive Stabilization strategy for Common Pool Resource Game.
    
    This strategy prioritizes long-term collective payoff by conditioning cooperation on stock health.
    It cooperates when stock is abundant, probabilistically adapts in the middle range, and defects
    when stock is critically depleted. End-game adjustments slightly increase defection bias to
    account for reduced future value of stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.threshold_high = 0.75 * self.capacity
        self.threshold_low = 0.2 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock_level = state.current_stock
        round_number = state.round_number
        if stock_level >= self.capacity:
            return Action.C
        if stock_level <= 0:
            return Action.D
        rounds_remaining = self.n_rounds - round_number
        normalized_progress = round_number / self.n_rounds if self.n_rounds > 0 else 0
        end_game_factor = 1.0 - 0.15 * normalized_progress
        if stock_level > self.threshold_high:
            cooperation_prob = 1.0
        elif stock_level < self.threshold_low:
            cooperation_prob = 0.0
        else:
            cooperation_prob = (stock_level - self.threshold_low) / (self.threshold_high - self.threshold_low)
        cooperation_prob = cooperation_prob * end_game_factor
        if history is not None and round_number > 0:
            last_round_actions = history.opponent_actions[-1, :]
            defection_count = np.sum(~last_round_actions)
            defection_rate = defection_count / len(last_round_actions) if len(last_round_actions) > 0 else 0
            if defection_rate > 0.5:
                cooperation_prob = cooperation_prob * 0.8
        cooperation_prob = max(0.0, min(1.0, cooperation_prob))
        if random.random() < cooperation_prob:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_360(BaseStrategy):
    """
    Adaptive Stock-Preserving Reciprocity (ASPR): A collective strategy that prioritizes
    common pool sustainability while reciprocating group cooperation. Cooperates by default,
    with special handling for critical stock levels and reciprocity-based adjustments.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity * 0.15
        self.cooperation_target = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.C
        if state.current_stock <= self.critical_threshold:
            return Action.C
        cooperation_rate_prev = self._calculate_cooperation_rate(history, state.round_number - 1)
        if cooperation_rate_prev >= self.cooperation_target:
            return Action.C
        if self._is_stock_unsustainable(history, state):
            return Action.C
        return Action.C

    def _calculate_cooperation_rate(self, history: PlayerHistory, round_idx: int) -> float:
        """
        Calculate the fraction of opponents who cooperated in the given round.
        True/1 represents cooperation (Action.C).
        """
        if round_idx < 0 or round_idx >= len(history.opponent_actions):
            return 0.0
        cooperators = int(np.sum(history.opponent_actions[round_idx, :]))
        return cooperators / self.n_players if self.n_players > 0 else 0.0

    def _is_stock_unsustainable(self, history: PlayerHistory, state: CommonPoolState) -> bool:
        """
        Check if the current consumption trajectory will lead to stock collapse
        below the critical threshold in the near future.
        """
        prev_round_idx = state.round_number - 1
        if prev_round_idx < 0:
            return False
        my_action_prev = history.my_actions[prev_round_idx]
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        cooperators_count = int(my_action_prev) + int(np.sum(opponent_actions_prev))
        defectors_count = self.n_players - cooperators_count
        my_payoff_prev = history.my_payoffs[prev_round_idx]
        if my_action_prev:
            stock_at_prev_start = my_payoff_prev * 2 * self.n_players
        else:
            stock_at_prev_start = my_payoff_prev * self.n_players
        stock_at_prev_start = max(0.0, min(stock_at_prev_start, self.capacity))
        consumption_per_coop = stock_at_prev_start / (2 * self.n_players)
        consumption_per_defect = stock_at_prev_start / self.n_players
        total_consumption = cooperators_count * consumption_per_coop + defectors_count * consumption_per_defect
        stock_after_consumption = max(0.0, stock_at_prev_start - total_consumption)
        if self.capacity > 0:
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
        else:
            growth = 0.0
        projected_stock = min(stock_after_consumption + growth, self.capacity)
        return projected_stock < self.critical_threshold

class Strategy_COLLECTIVE_361(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game
    
    Balances individual welfare with collective sustainability through:
    - Stock health assessment (critical/stressed/moderate/healthy)
    - Opponent behavior classification (defection rate tracking)
    - Time horizon awareness (early/mid/end-game)
    - Context-dependent decision making with recovery orientation
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        rounds_left = self.n_rounds - round_number
        if health_ratio < 0.2:
            health_tier = 'CRITICAL'
        elif health_ratio < 0.4:
            health_tier = 'STRESSED'
        elif health_ratio < 0.7:
            health_tier = 'MODERATE'
        else:
            health_tier = 'HEALTHY'
        defection_rate = self._calculate_defection_rate(history, round_number)
        if current_stock < 2 * self.n_players:
            return Action.C
        if health_tier == 'CRITICAL':
            return Action.C
        if health_tier == 'STRESSED':
            if defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        if health_tier == 'HEALTHY':
            if defection_rate < 0.33:
                return Action.C
            elif defection_rate <= 0.67:
                return Action.C
            else:
                return Action.D
        if health_tier == 'MODERATE':
            if defection_rate < 0.5:
                return Action.C
            elif rounds_left > self.n_rounds * 0.25:
                return Action.C
            else:
                return Action.D
        if round_number == self.n_rounds - 1:
            if health_ratio >= 0.4 and defection_rate < 0.6:
                return Action.C
            else:
                return Action.D
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the rate of defection observed from opponents.
        Defection is False (0), Cooperation is True (1).
        Returns a value between 0.0 and 1.0.
        """
        if round_number <= 1:
            return 0.0
        opponent_actions = history.opponent_actions[:round_number]
        total_defections = np.sum(opponent_actions == False)
        max_possible_defections = (self.n_players - 1) * round_number
        if max_possible_defections == 0:
            return 0.0
        defection_rate = total_defections / max_possible_defections
        return float(defection_rate)

class Strategy_COLLECTIVE_362(BaseStrategy):
    """
    Adaptive Collective Stewardship Strategy for Common Pool Resource Game.
    
    Balances robustness against defectors, sustainability of the resource, and fairness
    in burden-sharing. Uses stock health and defection rate to adaptively choose between
    cooperation and defection, with special handling for edge cases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_health = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        last_round_defections = sum(~history.opponent_actions[-1, :])
        defection_rate = last_round_defections / self.n_players if self.n_players > 0 else 0.0
        is_last_round = state.round_number == self.n_rounds - 1
        if stock_health <= 0.15:
            return Action.D
        if stock_health <= 0.35:
            if defection_rate < 0.4:
                return Action.C
            else:
                return Action.D
        if stock_health > 0.75:
            if defection_rate < 0.6:
                return Action.C
            else:
                return Action.D
        if defection_rate < 0.3:
            return Action.C
        elif defection_rate < 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_363(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Defection Control.
    
    A state-dependent strategy that balances individual rationality with collective
    sustainability in common pool resource games. Uses stock health thresholds and
    recent defection rates to adaptively choose between cooperation and defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.safe_threshold = self.capacity * 0.75
        self.critical_threshold = self.capacity * 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            if current_stock > self.critical_threshold:
                return Action.C
            else:
                return Action.D
        if history is not None and len(history.my_actions) > 0:
            previous_stock = self._get_previous_stock(state, history)
            if previous_stock > 0 and current_stock / previous_stock < 0.5:
                return Action.D
        if current_stock > self.safe_threshold:
            return Action.C
        if current_stock <= self.critical_threshold:
            return Action.D
        if history is None or len(history.opponent_actions) < 3:
            return Action.C
        defection_rate = self._calculate_recent_defection_rate(history)
        if defection_rate < 0.25:
            return Action.C
        elif defection_rate > 0.6:
            return Action.D
        else:
            return Action.D if random.random() < defection_rate else Action.C

    def _get_previous_stock(self, state: CommonPoolState, history: PlayerHistory) -> float:
        """
        Reconstruct the stock level before the current round.
        Works backwards from current stock using the consumption patterns.
        """
        if len(history.my_actions) == 0:
            return self.capacity
        last_round_idx = len(history.my_actions) - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_last_actions = history.opponent_actions[last_round_idx, :]
        n_cooperators = int(opponent_last_actions.sum()) + (1 if my_last_action else 0)
        n_defectors = self.n_players - n_cooperators
        return state.current_stock

    def _calculate_recent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the defection rate over the last 3 rounds (or fewer if not available).
        Defection is represented as False (0) in the arrays.
        """
        n_rounds_to_check = min(3, len(history.opponent_actions))
        if n_rounds_to_check == 0:
            return 0.0
        last_n_rounds = history.opponent_actions[-n_rounds_to_check:, :]
        total_cooperations = int(last_n_rounds.sum())
        total_possible_actions = n_rounds_to_check * self.n_players
        total_defections = total_possible_actions - total_cooperations
        defection_rate = total_defections / total_possible_actions if total_possible_actions > 0 else 0.0
        return defection_rate

class Strategy_COLLECTIVE_364(BaseStrategy):
    """
    Collective Pool Stewardship Strategy (CPSS)
    
    Prioritizes sustainable collective flourishing by adapting cooperation based on:
    1. Stock health ratio relative to a dynamic cooperation threshold
    2. Observed defection rates from other players
    3. Emergency protocols for stock collapse
    4. Special handling for first and final rounds
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.baseline_threshold = (self.n + 2) / (2 * self.n)
        self.cooperation_threshold = self.baseline_threshold
        self.defection_tolerance = 0.35
        self.threshold_lower_rate = 0.05
        self.threshold_lower_max = 0.15
        self.threshold_lower_min = 0.4
        self.threshold_recover_rate = 0.02
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            if current_stock >= self.capacity and current_stock >= 2 * self.n + 0.1 * self.capacity:
                return Action.C
            else:
                return Action.D
        self.stock_history.append(current_stock)
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        defection_rate = self._calculate_defection_rate(history, round_number)
        self.cooperation_threshold = self._update_threshold(defection_rate, round_number)
        effective_threshold = self._get_effective_threshold(stock_ratio)
        if round_number == self.r - 1:
            if self._should_defect_in_final_round(history):
                return Action.D
        if stock_ratio >= effective_threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """Calculate the rate of defection in the previous round"""
        if round_number <= 0:
            return 0.0
        last_round_actions = history.opponent_actions[round_number - 1, :]
        num_defectors = np.sum(~last_round_actions)
        defection_rate = float(num_defectors) / self.n
        return defection_rate

    def _update_threshold(self, defection_rate: float, round_number: int) -> float:
        """Update cooperation threshold based on defection rate"""
        if round_number < 2:
            return self.baseline_threshold
        volatility = self._get_stock_volatility()
        adjustment_scale = 0.5 if volatility > self.capacity / 3 else 1.0
        adjusted_tolerance = 0.4 if volatility > self.capacity / 3 else self.defection_tolerance
        if defection_rate > adjusted_tolerance:
            self.cooperation_threshold = max(self.threshold_lower_min, self.cooperation_threshold - self.threshold_lower_rate * adjustment_scale)
        elif defection_rate == 0.0:
            self.cooperation_threshold = min(self.baseline_threshold, self.cooperation_threshold + self.threshold_recover_rate * adjustment_scale)
        return self.cooperation_threshold

    def _get_effective_threshold(self, stock_ratio: float) -> float:
        """Determine effective threshold based on stock health"""
        if stock_ratio < 0.25:
            return 0.0
        elif stock_ratio < 0.5:
            return 0.6
        else:
            return self.cooperation_threshold

    def _should_defect_in_final_round(self, history: PlayerHistory) -> bool:
        """Determine if we should defect in the final round"""
        cumulative_payoff = float(np.sum(history.my_payoffs))
        expected_equal_share = self._calculate_expected_equal_share(history)
        if cumulative_payoff < 0.9 * expected_equal_share:
            return True
        return False

    def _calculate_expected_equal_share(self, history: PlayerHistory) -> float:
        """Estimate the expected equal-share payoff based on history"""
        if len(history.my_payoffs) == 0:
            return 0.0
        avg_payoff_per_round = float(np.mean(history.my_payoffs))
        expected_total = avg_payoff_per_round * len(history.my_payoffs)
        return expected_total

    def _get_stock_volatility(self) -> float:
        """Calculate stock volatility from history"""
        if len(self.stock_history) < 2:
            return 0.0
        stock_array = np.array(self.stock_history)
        variance = float(np.var(stock_array))
        return math.sqrt(variance) if variance > 0 else 0.0

class Strategy_COLLECTIVE_365(BaseStrategy):
    """
    Adaptive Commons Stewardship Strategy (ACS)
    
    Balances individual payoff maximization with system sustainability through
    stock-conditional cooperation and history-weighted reciprocity. Cooperates
    when the pool is healthy, defects opportunistically when stressed, and
    sacrifices short-term payoff when critical to prevent mutual collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        stock_ratio = stock / self.capacity if self.capacity > 0 else 1.0
        round_number = state.round_number
        final_rounds_threshold = max(1, int(0.1 * self.n_rounds))
        rounds_remaining = self.n_rounds - round_number
        in_final_phase = rounds_remaining <= final_rounds_threshold
        coop_threshold = 0.7 if in_final_phase else 0.75
        if round_number == 0:
            if stock_ratio >= coop_threshold:
                return Action.C
            else:
                return Action.C
        if stock_ratio < 0.35:
            return Action.C
        elif stock_ratio < coop_threshold:
            return Action.D
        else:
            collective_coop_rate = self._calculate_collective_coop_rate(history)
            if collective_coop_rate < 0.4:
                return Action.D
            else:
                return Action.C

    def _calculate_collective_coop_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the empirical cooperation rate of all players (self + opponents)
        across all previous rounds.
        
        Returns a value between 0 and 1, where 1 means all plays were cooperation.
        """
        if history is None or len(history.my_actions) == 0:
            return 1.0
        my_cooperations = np.sum(history.my_actions)
        opponent_cooperations = np.sum(history.opponent_actions)
        total_actions = len(history.my_actions) + np.sum(history.opponent_actions.shape)
        if total_actions == 0:
            return 1.0
        total_cooperations = my_cooperations + opponent_cooperations
        collective_coop_rate = float(total_cooperations) / float(total_actions)
        return collective_coop_rate

class Strategy_COLLECTIVE_366(BaseStrategy):
    """
    Adaptive Conservation Strategy (ACS) for Common Pool Resource Game.
    
    Balances three objectives: (1) prevent resource collapse, (2) maintain relative 
    position against defectors, (3) preserve collective gains when possible.
    
    Uses stock-health thresholds and adaptive history response to decide between
    cooperation and defection, with special end-game adjustments.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        capacity = self.capacity
        if current_round == 0:
            if current_stock >= capacity * 0.75:
                return Action.D
            elif current_stock <= capacity * 0.25:
                return Action.C
            else:
                return Action.C
        opponent_defections = np.sum(~history.opponent_actions[:current_round])
        rounds_completed = current_round
        if rounds_completed > 0:
            opponent_defection_ratio = opponent_defections / rounds_completed
        else:
            opponent_defection_ratio = 0.0
        if current_stock <= capacity * 0.3:
            return Action.C
        if current_round == self.n_rounds - 1:
            if current_stock <= capacity * 0.2:
                return Action.C
            else:
                return Action.D
        if opponent_defection_ratio > 0.7:
            return Action.D
        elif opponent_defection_ratio < 0.3:
            return Action.C
        if current_stock >= capacity * 0.75:
            return Action.D
        elif current_stock <= capacity * 0.25:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_367(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS) for Common Pool Resource Game.
    
    Balances cooperation for sustainability with adaptive defection based on:
    1. Stock health relative to capacity (CRITICAL_THRESHOLD = 0.4)
    2. Group defection rate (DEFECTION_TOLERANCE = 0.5)
    
    Core logic:
    - Cooperate when stock is healthy (>40% capacity) and defection rate is low
    - Defect when stock is depleted (<40%) or majority defected despite healthy stock
    - Always cooperate in first round as peaceful opening bid
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = 0.4
        self.defection_tolerance = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_health = state.current_stock / self.game_description.capacity
        if stock_health < self.critical_threshold:
            return Action.D
        most_recent_round_idx = state.round_number - 1
        opponent_actions_last_round = history.opponent_actions[most_recent_round_idx, :]
        defection_count = np.sum(~opponent_actions_last_round)
        defection_rate = defection_count / self.game_description.n_players
        if defection_rate > self.defection_tolerance:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_368(BaseStrategy):
    """
    Adaptive Stock-Preservation Protocol (ASPP): A stock-dependent threshold strategy
    that balances individual benefit with collective sustainability in common pool games.
    
    Core logic:
    - Cooperate when stock is below critical threshold (30% capacity) for recovery
    - Cooperate when stock is below dynamically calculated threshold based on remaining rounds
    - Defect when stock is above threshold and game conditions permit
    - Special handling for first and last rounds
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        remaining_rounds = self.n_rounds - round_num
        if round_num == 0:
            if stock >= 0.7 * self.capacity:
                return Action.D
            else:
                return Action.C
        if round_num == self.n_rounds - 1:
            if stock >= 0.5 * self.capacity:
                return Action.D
            else:
                return Action.C
        critical_threshold = 0.3 * self.capacity
        if stock < critical_threshold:
            return Action.C
        optimal_threshold = self.capacity * (1.0 - remaining_rounds / (2.0 * self.n_rounds))
        if stock >= optimal_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_369(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resources.
    
    Balances sustainable collective welfare with individual payoff maximization through:
    1. Stock-dependent cooperation thresholds (critical, recovery, abundance)
    2. Adaptive defection monitoring based on opponent behavior
    3. Endgame defection to secure final payoffs
    4. Reciprocal responses to exploitation patterns
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.critical_threshold = 0.15 * self.capacity
        self.recovery_threshold = 0.4 * self.capacity
        self.abundance_threshold = 0.8 * self.capacity
        self.defection_tolerance = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        rounds_remaining = self.n_rounds - round_num
        if stock <= self.critical_threshold:
            return Action.D
        if round_num == 0:
            return Action.C
        if rounds_remaining <= 2:
            return Action.D
        if stock <= self.recovery_threshold:
            return Action.C
        history_length = min(3, round_num)
        if history_length > 0:
            defection_rounds = 0
            for i in range(history_length):
                round_idx = round_num - history_length + i
                opponent_actions = history.opponent_actions[round_idx, :]
                defectors = np.sum(~opponent_actions)
                if defectors > self.n_players * 0.5:
                    defection_rounds += 1
            recent_defection_rate = defection_rounds / history_length
            if recent_defection_rate > self.defection_tolerance:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_370(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A self-interested but enlightened strategy
    that balances individual payoff maximization with resource sustainability.
    
    Core mechanism: Cooperate when stock is healthy (>=50%), transition probabilistically
    in the critical zone (30-50%), defect when depleted (<30%). Adjust thresholds based
    on remaining rounds and aggregate defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        remaining_rounds = self.r - current_round
        if current_round == 0:
            return Action.C
        if remaining_rounds == 1:
            return Action.D
        if current_stock < 2 * self.n or current_stock / self.capacity < 0.1:
            return Action.D
        health = current_stock / self.capacity
        defection_rate = self._calculate_defection_rate(history)
        if defection_rate > 0.6 * (self.n - 1):
            return Action.D
        threshold_c = 0.5
        if defection_rate > 0.4 * (self.n - 1):
            threshold_c = 0.6
        if remaining_rounds <= 3:
            threshold_c = 0.6
        if remaining_rounds > self.r * 0.8:
            threshold_c = 0.45
        if remaining_rounds < self.r * 0.2:
            threshold_c = 0.55
        if health >= threshold_c:
            return Action.C
        lower_bound = threshold_c - 0.2
        if health >= lower_bound:
            prob_cooperate = (health - lower_bound) / 0.2
            if random.random() < prob_cooperate:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the aggregate defection rate of all other players.
        Defection is represented by False (0) in opponent_actions.
        Returns: proportion of defections across all rounds and players.
        """
        if history is None or history.opponent_actions.size == 0:
            return 0.0
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.0
        cooperations = np.sum(history.opponent_actions)
        defections = total_actions - cooperations
        return defections / total_actions

class Strategy_COLLECTIVE_371(BaseStrategy):
    """
    Adaptive Sustainability Strategy (ASS) for Common Pool Resource Game.
    
    Prioritizes long-term collective sustainability while maintaining individual competitiveness.
    Uses stock-based thresholds, temporal adjustment, reciprocal monitoring, and edge case handling
    to balance cooperation and defection based on resource health and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_confirm_counter = 0
        self.previous_threshold_breached = False
        self.memory_window = 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            if current_stock > self.capacity * 0.25:
                return Action.D
            else:
                return Action.C
        if current_stock <= self.capacity * 0.2:
            return Action.D
        threshold = self.capacity * 0.4
        rounds_elapsed = round_number
        rounds_remaining = self.n_rounds - round_number
        rounds_remaining_factor = rounds_remaining / self.n_rounds if self.n_rounds > 0 else 0
        if rounds_remaining_factor < 0.15:
            threshold = self.capacity * 0.25
            return Action.D
        initial_stock = self.capacity
        depletion_rate = (initial_stock - current_stock) / max(rounds_elapsed, 1)
        if depletion_rate > self.capacity * 0.05:
            threshold = self.capacity * 0.35
        elif current_stock > self.capacity * 0.8:
            threshold = self.capacity * 0.45
        else:
            threshold = self.capacity * 0.4
        window_size = min(self.memory_window, rounds_elapsed)
        if window_size > 0:
            recent_opponent_actions = history.opponent_actions[-window_size:, :]
            total_opponent_actions = recent_opponent_actions.size
            total_defections = np.sum(~recent_opponent_actions)
            opponent_defection_rate = total_defections / max(total_opponent_actions, 1)
            if opponent_defection_rate > 0.6:
                threshold += self.capacity * 0.1
            elif opponent_defection_rate < 0.2:
                threshold -= self.capacity * 0.05
        current_threshold_breached = current_stock <= threshold
        if self.previous_threshold_breached != current_threshold_breached:
            self.threshold_confirm_counter += 1
            if self.threshold_confirm_counter < 2:
                last_action = history.my_actions[-1]
                return Action.C if last_action else Action.D
            else:
                self.threshold_confirm_counter = 0
        else:
            self.threshold_confirm_counter = 0
        self.previous_threshold_breached = current_threshold_breached
        if current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_372(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances personal benefit with collective sustainability through conditional
    cooperation based on stock health and observed cooperation rates. Adapts to
    defection patterns and enters punitive mode when exploitation is detected.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defect_recovery_counter = 0
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        self.stock_history.append(state.current_stock)
        health_ratio = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        prev_round_idx = state.round_number - 1
        prev_round_cooperators = int(sum(history.opponent_actions[prev_round_idx, :]))
        prev_round_coop_rate = prev_round_cooperators / self.n_players
        coop_threshold = 0.5
        if self._is_stock_declining_rapidly():
            coop_threshold = 0.6
        if self.defect_recovery_counter > 0:
            self.defect_recovery_counter -= 1
            return Action.D
        if state.round_number <= 2:
            if state.current_stock < 0.4 * self.capacity:
                self.defect_recovery_counter = 2
                return Action.D
        if prev_round_coop_rate < 0.3:
            self.defect_recovery_counter = 2
            return Action.D
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if health_ratio >= 0.6:
            if prev_round_coop_rate >= coop_threshold:
                return Action.C
            else:
                return Action.D
        elif health_ratio >= 0.3:
            required_threshold = coop_threshold + 0.15
            if prev_round_coop_rate >= required_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _is_stock_declining_rapidly(self) -> bool:
        """
        Check if stock is declining at an accelerating rate.
        Returns True if velocity is increasing (stock depleting faster).
        """
        if len(self.stock_history) < 3:
            return False
        velocity_prev = (self.stock_history[-3] - self.stock_history[-2]) / (self.stock_history[-3] + 1e-09)
        velocity_curr = (self.stock_history[-2] - self.stock_history[-1]) / (self.stock_history[-2] + 1e-09)
        return velocity_curr > velocity_prev

class Strategy_COLLECTIVE_373(BaseStrategy):
    """
    Adaptive Conservation with Defection Deterrence Strategy
    
    Prioritizes collective long-term welfare by maintaining common pool sustainability
    while pragmatically adapting to exploitation. Uses stock level as primary signal
    for resource health and adjusts cooperation accordingly through tiered framework.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_decline_rounds = 0
        self.last_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_stock = state.current_stock
            return Action.C
        health_ratio = state.current_stock / self.game_description.capacity
        if self.last_stock is not None:
            if state.current_stock < self.last_stock:
                self.consecutive_decline_rounds += 1
            else:
                self.consecutive_decline_rounds = 0
        self.last_stock = state.current_stock
        defection_rate = self._calculate_defection_rate(history, state.round_number)
        recovery_signal = self._check_recovery_signal(history, state.current_stock, defection_rate)
        all_cooperated = self._check_all_cooperated(history, state.round_number)
        if state.round_number == self.game_description.n_rounds - 1:
            if health_ratio > 0.75:
                return Action.C
            else:
                return Action.D
        if health_ratio > 0.75:
            return Action.C
        elif 0.4 < health_ratio <= 0.75:
            if defection_rate > 0:
                return Action.D
            else:
                return Action.C
        else:
            if health_ratio < 0.05:
                return Action.D
            if self.consecutive_decline_rounds >= 2:
                return Action.D
            if recovery_signal:
                return Action.C
            if all_cooperated and health_ratio > 0.5:
                return Action.C
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """Calculate proportion of opponents defecting in previous round."""
        if round_number == 0:
            return 0.0
        previous_round_actions = history.opponent_actions[round_number - 1, :]
        defections = np.sum(~previous_round_actions)
        defection_rate = defections / self.game_description.n_players
        return defection_rate

    def _check_recovery_signal(self, history: PlayerHistory, current_stock: float, defection_rate: float) -> bool:
        """Check if stock is increasing significantly after high defection."""
        if history is None or len(history.my_actions) < 2:
            return False
        if len(history.my_actions) < 3:
            return False
        current_round = len(history.my_actions) - 1
        if current_round < 2:
            return False
        if defection_rate > 0.25:
            recent_actions = history.my_actions[-2:]
            if recent_actions[0] == recent_actions[1]:
                return True
        return False

    def _check_all_cooperated(self, history: PlayerHistory, round_number: int) -> bool:
        """Check if all opponents played cooperate in previous round."""
        if round_number == 0:
            return False
        previous_round_actions = history.opponent_actions[round_number - 1, :]
        all_cooperated = np.all(previous_round_actions)
        return bool(all_cooperated)

class Strategy_COLLECTIVE_374(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS) - A collectively rational strategy for common pool resource games.
    
    Balances individual rationality with collective sustainability by:
    1. Starting cooperatively (round 1)
    2. Adapting based on observed defection rates and stock health
    3. Prioritizing resource preservation via stock health thresholds
    4. Using graduated punishment for moderate defection
    5. Enabling recovery and re-cooperation
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.C
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        rounds_remaining = self.n_rounds - round_num
        defection_rate = self._calculate_defection_rate(history, round_num)
        if round_num == self.n_rounds - 1:
            if stock_health >= 0.5:
                return Action.D
            else:
                return Action.C
        if stock_health < 0.3:
            return Action.C
        if defection_rate <= 0.25 and stock_health >= 0.6:
            return Action.C
        if defection_rate > 0.5:
            return Action.D
        if defection_rate > 0.25:
            random_value = random.random()
            if random_value < defection_rate * 0.8:
                return Action.D
            else:
                return Action.C
        if stock_health < 0.5:
            return Action.C
        else:
            return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the proportion of opponents who defected in the previous round.
        
        Args:
            history: Player history object containing opponent actions
            round_num: Current round number (0-indexed)
        
        Returns:
            Defection rate as a float between 0.0 and 1.0
        """
        if round_num == 0:
            return 0.0
        previous_round_index = round_num - 1
        opponent_actions_prev_round = history.opponent_actions[previous_round_index, :]
        num_defectors = np.sum(~opponent_actions_prev_round)
        total_opponents = len(opponent_actions_prev_round)
        if total_opponents == 0:
            return 0.0
        defection_rate = float(num_defectors) / float(total_opponents)
        return defection_rate

class Strategy_COLLECTIVE_375(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS) for Common Pool Resource Game.
    
    Balances individual benefit-seeking with collective resource sustainability through
    adaptive threshold-based decision-making. Cooperates when stock is healthy, adapts
    to competitive pressure when degraded, and defects when critical or in endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.healthy_threshold = 0.75 * self.capacity
        self.critical_threshold = 0.35 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num >= self.n_rounds - 2:
            if stock > 0:
                return Action.D
            else:
                return Action.D
        health = self._classify_health(stock)
        if health == 'CRITICAL':
            return Action.D
        elif health == 'HEALTHY':
            return Action.C
        else:
            return self._degraded_decision(history, round_num)

    def _classify_health(self, stock: float) -> str:
        """Classify current stock into health states."""
        if stock >= self.healthy_threshold:
            return 'HEALTHY'
        elif stock >= self.critical_threshold:
            return 'DEGRADED'
        else:
            return 'CRITICAL'

    def _degraded_decision(self, history: PlayerHistory, round_num: int) -> Action:
        """
        In DEGRADED state, use adaptive defection based on opponent behavior
        in the previous round.
        """
        prev_round_idx = round_num - 1
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        defectors_last_round = sum((1 for action in opponent_actions_prev if not action))
        prob_defect = defectors_last_round / max(1, self.n_players - 1)
        if random.random() < prob_defect:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_376(BaseStrategy):
    """
    Adaptive Stock-Preservation (ASP) Strategy
    
    A collective-minded strategy that prioritizes long-term sustainability of the common pool
    resource while remaining robust to exploitation. Uses conditional cooperation with adaptive
    punishment and stock health assessment.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_threshold = 0.4
        self.critical_depletion_threshold = 0.25
        self.sustainability_lower = 0.25
        self.sustainability_upper = 0.85
        self.abundance_threshold = 0.85

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        round_number = state.round_number
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if health_ratio < self.critical_depletion_threshold:
            return Action.C
        if round_number > self.n_rounds - 3:
            if health_ratio > 0.3:
                return Action.C
            else:
                return Action.C
        defection_rate = self._calculate_defection_rate(history, round_number)
        if self._should_punish(defection_rate, history, round_number):
            return Action.D
        if health_ratio >= self.sustainability_lower:
            return Action.C
        if not self._is_trajectory_sustainable(history, current_stock, round_number):
            return Action.D
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the rate of defections observed in opponent actions.
        Returns fraction of observed actions that were defections (False).
        """
        if round_number == 0:
            return 0.0
        opponent_actions = history.opponent_actions[:round_number]
        if opponent_actions.size == 0:
            return 0.0
        total_actions = opponent_actions.size
        defections = np.sum(~opponent_actions)
        defection_rate = float(defections) / float(total_actions) if total_actions > 0 else 0.0
        return defection_rate

    def _should_punish(self, defection_rate: float, history: PlayerHistory, round_number: int) -> bool:
        """
        Determine if we should punish with defection.
        Apply punishment if defection rate is high AND pattern is sustained.
        Punishment is limited to one round.
        """
        if round_number < 2:
            return False
        if defection_rate <= self.punishment_threshold:
            return False
        recent_rounds_to_check = min(2, round_number)
        recent_opponent_actions = history.opponent_actions[round_number - recent_rounds_to_check:round_number]
        if recent_opponent_actions.size == 0:
            return False
        recent_defections = np.sum(~recent_opponent_actions)
        recent_total = recent_opponent_actions.size
        recent_defection_rate = float(recent_defections) / float(recent_total) if recent_total > 0 else 0.0
        if recent_defection_rate > self.punishment_threshold:
            if round_number > 0 and (not history.my_actions[round_number - 1]):
                return False
            return True
        return False

    def _is_trajectory_sustainable(self, history: PlayerHistory, current_stock: float, round_number: int) -> bool:
        """
        Assess whether the current stock trajectory will be sustainable.
        Returns False if we're on a path toward depletion.
        """
        if round_number < 2:
            return True
        if current_stock < self.capacity * 0.4:
            if round_number > 1:
                defection_rate = self._calculate_defection_rate(history, round_number)
                if defection_rate > 0.5:
                    return False
        return True

class Strategy_COLLECTIVE_377(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS): Balances individual payoff optimization with
    collective resource sustainability through state-dependent cooperation thresholds,
    adaptive defection based on recent history, and graduated response to observed behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainable_threshold = 0.75 * self.capacity
        self.critical_threshold = 0.25 * self.capacity
        self.defection_threshold = 0.5 * self.capacity
        self.collapse_imminent_threshold = 0.15 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if stock > self.sustainable_threshold:
            return Action.C
        if stock <= self.critical_threshold:
            if random.random() < 0.9:
                return Action.C
            else:
                return Action.D
        if stock < self.collapse_imminent_threshold:
            if random.random() < 0.9:
                return Action.C
            else:
                return Action.D
        if round_number == self.n_rounds - 1:
            if stock <= self.critical_threshold:
                return Action.D
            else:
                return Action.C
        recent_window = min(3, round_number)
        if recent_window > 0:
            recent_opponent_actions = history.opponent_actions[round_number - recent_window:round_number, :]
            total_defections = np.sum(~recent_opponent_actions)
            total_decisions = recent_opponent_actions.size
            defection_rate = total_defections / total_decisions if total_decisions > 0 else 0.0
            cooperation_rate = 1.0 - defection_rate
            if defection_rate > 0.8:
                return Action.D
            if cooperation_rate >= 0.67:
                return Action.C
            if cooperation_rate <= 0.33:
                return Action.D
            if random.random() < cooperation_rate:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_378(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Games.
    
    Maintains resource sustainability through stock-conditional cooperation with
    defection detection. Cooperates when stock is healthy, defects when critical,
    and monitors for systematic exploitation in the declining zone.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if round_number == 0:
            return Action.C
        if stock_ratio > 0.6:
            return Action.C
        if stock_ratio <= 0.3:
            return Action.D
        recent_rounds = min(3, round_number)
        if recent_rounds > 0 and history is not None:
            defection_count = 0
            total_opponent_actions = 0
            for round_idx in range(round_number - recent_rounds, round_number):
                if round_idx >= 0 and round_idx < len(history.opponent_actions):
                    round_defections = np.sum(~history.opponent_actions[round_idx, :])
                    defection_count += round_defections
                    total_opponent_actions += self.n_players - 1
            if total_opponent_actions > 0:
                defection_rate = defection_count / total_opponent_actions
            else:
                defection_rate = 0.0
            if defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_COLLECTIVE_379(BaseStrategy):
    """
    Adaptive Stock-Preservation Strategy (ASPS)
    
    Prioritizes long-term collective sustainability by making cooperation decisions
    based on current stock health relative to capacity. Cooperates when stock is
    healthy (≥50% capacity), defects when stressed (<50%), with higher thresholds
    in terminal rounds. Includes collapse prevention for critically depleted pools.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number
        min_viable_stock = 2 * self.n_players
        if current_stock < min_viable_stock:
            return Action.D
        if self.capacity <= 0:
            stock_health_ratio = 0.0
        else:
            stock_health_ratio = current_stock / self.capacity
        k = math.ceil(math.log2(self.n_rounds)) if self.n_rounds > 1 else 1
        k = max(k, 1)
        if rounds_remaining <= k:
            threshold = 0.6
        else:
            threshold = 0.5
        if stock_health_ratio >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_380(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Response strategy for Common Pool Resource Game.
    
    Treats the common pool as a shared resource requiring active stewardship through:
    1. Resource preservation as primary objective
    2. Graduated responses to detect and adapt to free-riding
    3. Collective long-term thinking that benefits all players
    
    Decision logic:
    - High stock (>75%): Cooperate to preserve resources
    - Moderate stock (40-75%): Adaptive tit-for-tat based on recent cooperation rate
    - Low stock (15-40%): Mostly defect with rare cooperation signals
    - Critical stock (<15%): Defect to salvage remaining resources
    - First round: Cooperate unconditionally
    - Last round: Apply normal rules (no end-game defection)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio < 0.05:
            return Action.D
        if stock_ratio > 0.75:
            return Action.C
        if stock_ratio > 0.4:
            return self._adaptive_response(history, state.round_number)
        if stock_ratio > 0.15:
            if random.random() < 0.8:
                return Action.D
            else:
                return Action.C
        return Action.D

    def _adaptive_response(self, history: PlayerHistory, round_number: int) -> Action:
        """
        Tit-for-tat-with-tolerance approach for moderate stock levels.
        
        Evaluates cooperation rate of other players in recent rounds and responds:
        - cooperation_rate >= 66%: Cooperate
        - cooperation_rate >= 33%: Mixed response (50% coop, 50% defect)
        - cooperation_rate < 33%: Defect
        """
        n_completed_rounds = round_number
        if n_completed_rounds < 1:
            return Action.C
        lookback = min(3, n_completed_rounds)
        recent_start = n_completed_rounds - lookback
        cooperation_count = 0
        for round_idx in range(recent_start, n_completed_rounds):
            if round_idx < 0 or round_idx >= len(history.opponent_actions):
                continue
            opponent_actions_this_round = history.opponent_actions[round_idx, :]
            cooperators_in_round = np.sum(opponent_actions_this_round)
            if cooperators_in_round >= (self.n_players - 1) / 2.0:
                cooperation_count += 1
        recent_rounds_count = n_completed_rounds - recent_start
        if recent_rounds_count > 0:
            cooperation_rate = cooperation_count / recent_rounds_count
        else:
            cooperation_rate = 0.0
        if cooperation_rate >= 0.66:
            return Action.C
        elif cooperation_rate >= 0.33:
            return Action.C if random.random() < 0.5 else Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_381(BaseStrategy):
    """
    Adaptive Commons Stewardship Strategy
    
    Operates on conditional cooperation with damage control. Maintains the resource
    for collective benefit while protecting against exploitation, with emphasis on
    preventing catastrophic collapse.
    
    Decision logic:
    - HEALTHY stock (≥60%): Cooperate unless high defection + declining/stable trajectory
    - STRESSED stock (30-60%): Cooperate unless high defection + stable trajectory
    - CRITICAL stock (<30%): Always cooperate to enable recovery
    - Special: Always cooperate when stock <10% or depleted
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        current_stock = state.current_stock
        capacity = self.capacity
        if round_t == 0:
            return Action.C
        health_ratio = current_stock / capacity if capacity > 0 else 0.0
        if health_ratio >= 0.6:
            stock_status = 'HEALTHY'
        elif health_ratio >= 0.3:
            stock_status = 'STRESSED'
        else:
            stock_status = 'CRITICAL'
        stock_previous = history.opponent_payoffs[round_t - 1, 0]
        trajectory = 'UNKNOWN'
        if round_t >= 1:
            if round_t >= 2:
                prev_round_idx = round_t - 2
                defections_prev = np.sum(~history.opponent_actions[prev_round_idx, :])
                cooperations_prev = self.n_players - 1 - defections_prev
                if history.my_actions[prev_round_idx]:
                    cooperations_prev += 1
                consumption_ratio = (self.n_players - cooperations_prev) / self.n_players
                if consumption_ratio > 0.5:
                    trajectory = 'DECLINING'
                else:
                    trajectory = 'RECOVERING'
            else:
                trajectory = 'UNKNOWN'
        defection_pressure = 'LOW'
        if round_t >= 1:
            defections_count = 0
            total_actions = 0
            for prev_round in range(round_t):
                defections_count += np.sum(~history.opponent_actions[prev_round, :])
                total_actions += self.n_players - 1
            if total_actions > 0:
                defection_rate = defections_count / total_actions
                threshold_high = 0.6 * ((self.n_players - 1) / self.n_players)
                threshold_moderate = 0.3 * ((self.n_players - 1) / self.n_players)
                if defection_rate >= threshold_high:
                    defection_pressure = 'HIGH'
                elif defection_rate >= threshold_moderate:
                    defection_pressure = 'MODERATE'
                else:
                    defection_pressure = 'LOW'
        if current_stock == 0 or health_ratio < 0.1:
            return Action.C
        if stock_status == 'CRITICAL':
            return Action.C
        elif stock_status == 'HEALTHY':
            if trajectory == 'RECOVERING':
                return Action.C
            elif trajectory == 'STABLE':
                if defection_pressure == 'HIGH':
                    return Action.D
                else:
                    return Action.C
            elif trajectory == 'DECLINING':
                if defection_pressure == 'HIGH':
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        elif stock_status == 'STRESSED':
            if trajectory == 'RECOVERING':
                return Action.C
            elif trajectory == 'DECLINING':
                return Action.C
            elif trajectory == 'STABLE':
                if defection_pressure in ('LOW', 'MODERATE'):
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_COLLECTIVE_382(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS) Strategy for Common Pool Resource Game.
    
    Prioritizes long-term collective welfare by maintaining stock sustainability
    through threshold-based adaptive cooperation. Cooperates when stock health is
    strong, defends when depleted, and adjusts thresholds based on observed
    defection rates and game phase.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 2 * self.n

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        if current_stock < self.critical_threshold:
            return Action.C
        phase_ratio_1 = self.r / 3.0
        phase_ratio_2 = 2 * self.r / 3.0
        if round_num < phase_ratio_1:
            base_threshold = 0.6
        elif round_num < phase_ratio_2:
            base_threshold = 0.5
        else:
            base_threshold = 0.4
        if history is not None and round_num > 0:
            total_actions = self.n * round_num
            total_defections = 0
            for r_idx in range(round_num):
                if not history.my_actions[r_idx]:
                    total_defections += 1
                for opp_idx in range(self.n - 1):
                    if not history.opponent_actions[r_idx, opp_idx]:
                        total_defections += 1
            defection_rate = total_defections / total_actions if total_actions > 0 else 0.0
            if defection_rate > 0.4:
                base_threshold += 0.15
            elif defection_rate < 0.2:
                base_threshold -= 0.05
            if round_num >= 2:
                recent_depletion_detected = False
                for check_round in range(max(0, round_num - 2), round_num):
                    if check_round > 0:
                        expected_recovery = 2 * current_stock * (1 - current_stock / self.capacity)
                        if expected_recovery < 0.1 * self.capacity:
                            recent_depletion_detected = True
                            break
                if recent_depletion_detected:
                    base_threshold = max(base_threshold, 0.65)
            if round_num == int(phase_ratio_1) + 1:
                initial_stock = self.capacity
                stock_drop_ratio = (initial_stock - current_stock) / initial_stock if initial_stock > 0 else 0.0
                if stock_drop_ratio > 0.2:
                    base_threshold = 0.65
        cooperation_threshold = base_threshold
        if round_num == self.r - 1:
            if stock_health >= 0.5:
                return Action.C
            elif current_stock < self.critical_threshold:
                return Action.C
            elif stock_health >= cooperation_threshold:
                return Action.C
            else:
                return Action.D
        if stock_health >= cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_383(BaseStrategy):
    """
    Collective Pool Stewardship Strategy - Adaptive commons management through graduated
    response to defection, emergency conservation, and proportional retaliation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        health_ratio = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        if health_ratio < 0.25:
            return Action.C
        group_defection_rate = self._calculate_group_defection_rate(history, state.round_number)
        if state.round_number == self.n_rounds - 1:
            if health_ratio >= 0.4:
                return Action.C
            else:
                return Action.D
        if group_defection_rate <= 0.2:
            return Action.C
        elif group_defection_rate <= 0.5:
            defection_probability = (group_defection_rate - 0.2) / 0.8
            if random.random() < defection_probability:
                return Action.D
            else:
                return Action.C
        elif health_ratio >= 0.6:
            return Action.D
        else:
            return Action.C

    def _calculate_group_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the group defection rate from observed history.
        Defection is encoded as False (0), Cooperation as True (1).
        """
        if current_round <= 0:
            return 0.0
        total_opponent_actions = history.opponent_actions[:current_round, :]
        defections = np.sum(total_opponent_actions == False)
        total_possible = self.n_players * current_round
        if total_possible == 0:
            return 0.0
        defection_rate = float(defections) / float(total_possible)
        return defection_rate

class Strategy_COLLECTIVE_384(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Reciprocity.
    
    Balances individual benefit extraction with collective resource preservation,
    adapting dynamically to observed opponent behavior. Uses stock health ratio
    and opponent defection rate to guide decisions with special handling for
    opening, steady state, and endgame phases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        capacity = self.capacity
        if current_round == 0:
            return Action.C
        stock_ratio = stock / capacity if capacity > 0 else 0.0
        avg_opponent_defection = self._calculate_opponent_defection_rate(history, current_round)
        if stock_ratio < 0.2:
            return Action.D
        if stock_ratio >= 0.5:
            if avg_opponent_defection <= 0.4:
                return Action.C
            else:
                return Action.D
        if avg_opponent_defection <= 0.3:
            return Action.C
        else:
            return Action.D

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the average defection rate of opponents from observable history.
        
        Defection rate is measured as the proportion of defect actions (False/0)
        across all opponents in all completed rounds.
        """
        if current_round == 0:
            return 0.5
        completed_actions = history.opponent_actions[:current_round, :]
        total_actions = completed_actions.size
        if total_actions == 0:
            return 0.5
        cooperations = np.sum(completed_actions)
        defections = total_actions - cooperations
        defection_rate = defections / total_actions
        return defection_rate

class Strategy_COLLECTIVE_385(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A conditional cooperation strategy that balances
    individual benefit with collective sustainability in common pool resource games.
    
    Core approach:
    - Round 1: Cooperate (establish cooperative signal)
    - Rounds 2 to (r-2): Adaptive based on stock health and observed cooperation rates
    - Final round: Defect (standard last-round incentive)
    
    Stock thresholds guide decisions:
    - stock >= 0.6*capacity: Cooperate if majority cooperated; else defect
    - 0.3*capacity <= stock < 0.6*capacity: Stricter threshold for cooperation
    - stock < 0.3*capacity: Always defect (critical depletion)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        observed_cooperations = int(sum(history.opponent_actions[round_number - 1, :]))
        observed_defections = self.n_players - observed_cooperations
        cooperation_rate = observed_cooperations / self.n_players if self.n_players > 0 else 0.0
        if stock_ratio >= 0.6:
            if cooperation_rate > 0.5:
                return Action.C
            else:
                return Action.D
        elif stock_ratio >= 0.3:
            if cooperation_rate > 0.7:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_386(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances personal sustainability with collective resource preservation through
    phase-aware conditional cooperation. Adapts to observed defection rates while
    maintaining pressure toward cooperative equilibrium.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_threshold = 0.3
        self.rolling_window = 3
        self.stock_health_high = 0.6
        self.stock_health_moderate = 0.4
        self.stock_health_critical = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        phase = self._classify_phase(state.round_number)
        stock_health = state.current_stock / self.capacity
        defection_rate = self._calculate_defection_rate(history, state.round_number)
        if phase == 'EARLY':
            return self._decide_early_game(stock_health)
        elif phase == 'MID':
            return self._decide_mid_game(stock_health, defection_rate)
        else:
            return self._decide_end_game(state.round_number, stock_health, defection_rate)

    def _classify_phase(self, round_number: int) -> str:
        """Classify current phase as EARLY, MID, or END."""
        third = self.n_rounds / 3.0
        if round_number < third:
            return 'EARLY'
        elif round_number < 2 * third:
            return 'MID'
        else:
            return 'END'

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """Calculate the defection rate of opponents in recent rounds."""
        if round_number == 0:
            return 0.0
        start_round = max(0, round_number - self.rolling_window)
        recent_actions = history.opponent_actions[start_round:round_number, :]
        defectors = np.sum(recent_actions == False)
        total_opportunities = recent_actions.size
        if total_opportunities == 0:
            return 0.0
        defection_rate = defectors / total_opportunities
        return defection_rate

    def _decide_early_game(self, stock_health: float) -> Action:
        """Early game: Establish cooperative norms."""
        if stock_health > 0.5:
            return Action.C
        else:
            return Action.D

    def _decide_mid_game(self, stock_health: float, defection_rate: float) -> Action:
        """Mid game: Respond to observed defection patterns."""
        if defection_rate < self.defection_threshold:
            if stock_health > self.stock_health_moderate:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _decide_end_game(self, round_number: int, stock_health: float, defection_rate: float) -> Action:
        """End game: Minimize defection risk while preserving remaining stock."""
        if round_number == self.n_rounds - 1:
            return Action.D
        if stock_health > self.stock_health_high and defection_rate < 0.4:
            return Action.C
        if stock_health < self.stock_health_critical:
            return Action.D
        if defection_rate < 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_387(BaseStrategy):
    """
    Adaptive Regeneration Stewardship (ARS): A collective strategy that prioritizes
    long-term resource sustainability while adaptively responding to defection.
    
    Core logic:
    - Cooperate when stock is healthy (>75% capacity)
    - Conditionally cooperate when stock is moderate (40-75%), based on defection rates
    - Defect when stock is critically low (<40%), except in special cases
    - Special handling for first, middle, and last rounds
    - Track stock recovery and consecutive declines to prevent collapse
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.previous_stock = None
        self.consecutive_decline_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            self.previous_stock = current_stock
            return Action.C
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        stock_change = current_stock - self.previous_stock if self.previous_stock is not None else 0
        if stock_change < 0:
            self.consecutive_decline_count += 1
        else:
            self.consecutive_decline_count = 0
        stock_recovery = stock_change > 0.15 * self.previous_stock if self.previous_stock is not None else False
        self.previous_stock = current_stock
        if stock_ratio < 0.05:
            return Action.D
        if current_round == self.n_rounds - 1:
            if stock_ratio > 0.6:
                return Action.C
            else:
                return Action.D
        defection_rate = self._get_last_round_defection_rate(history)
        own_last_action_was_defect = not history.my_actions[-1]
        if stock_ratio > 0.75:
            if defection_rate == 0 and stock_ratio >= 0.95:
                return Action.C
            return Action.C
        elif stock_ratio > 0.4:
            if own_last_action_was_defect and defection_rate <= 0.33:
                return Action.C
            if defection_rate <= 0.33:
                return Action.C
            else:
                return Action.D
        else:
            if self.consecutive_decline_count >= 2 and stock_ratio < 0.5:
                return Action.D
            if own_last_action_was_defect and defection_rate <= 0.33:
                return Action.C
            return Action.D

    def _get_last_round_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the defection rate (proportion of defectors) in the last round.
        
        Returns a value between 0 and 1.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        last_round_actions = history.opponent_actions[-1, :]
        num_defectors = np.sum(~last_round_actions)
        defection_rate = num_defectors / self.n_players if self.n_players > 0 else 0.0
        return float(defection_rate)

class Strategy_COLLECTIVE_388(BaseStrategy):
    """
    Adaptive Stewardship: A stock-health-based strategy for common pool resource management.
    
    Dynamically adjusts cooperation based on resource health thresholds, round position,
    and trend detection. Cooperates when stock is abundant, defects under scarcity,
    and punishes exploitation through trend-aware switching.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == self.n_rounds - 1:
            return Action.D
        if stock <= 0.05 * self.capacity:
            return Action.D
        if stock >= self.capacity:
            return Action.C
        if round_num > 2 and history is not None:
            prev_stock = self._get_stock_after_round(history, round_num - 2)
            prev_cooperation_count = int(np.sum(history.opponent_actions[round_num - 2, :]))
            prev_cooperation_rate = prev_cooperation_count / self.n_players
            trend = stock - prev_stock
            if trend < 0 and prev_cooperation_rate > 0.5:
                return Action.D
            if trend > 0.05 * self.capacity:
                return Action.C
        if round_num == self.n_rounds - 2:
            if stock > 0.6 * self.capacity:
                return Action.C
        if stock > 0.75 * self.capacity:
            return Action.C
        elif stock > 0.4 * self.capacity:
            return Action.C
        elif stock > 0.15 * self.capacity:
            return Action.D
        else:
            return Action.D

    def _get_stock_after_round(self, history: PlayerHistory, round_idx: int) -> float:
        """
        Reconstruct stock level after a given round by working backwards from current state.
        
        Uses the inverse of stock dynamics:
        - Round consumption = sum of individual consumptions
        - Individual consumption: C plays consume stock/(2n), D plays consume stock/n
        - Stock before growth = stock_after_growth - growth
        - Growth = 2 * stock_before_growth * (1 - stock_before_growth / capacity)
        
        For simplicity, we estimate by computing forward from round 0.
        Track the sequence of actions and compute resulting stock.
        """
        if round_idx < 0:
            return self.capacity
        stock = self.capacity
        for r in range(round_idx + 1):
            cooperators = 0
            if history.my_actions[r]:
                cooperators += 1
            opponent_cooperators = int(np.sum(history.opponent_actions[r, :]))
            cooperators += opponent_cooperators
            defectors = self.n_players - cooperators
            if stock > 0:
                consumption = cooperators * (stock / (2 * self.n_players)) + defectors * (stock / self.n_players)
                stock_after_consumption = max(0, stock - consumption)
            else:
                stock_after_consumption = 0
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
                stock = min(stock_after_consumption + growth, self.capacity)
            else:
                stock = 0
        return stock

class Strategy_COLLECTIVE_389(BaseStrategy):
    """
    Adaptive Stewardship with Defensive Safeguards: A stock-health-based strategy
    that prioritizes sustainable collective welfare while maintaining robust defenses
    against exploitation. Cooperates when stock is healthy (>75% capacity), defects
    when stock is degraded (40-75%) or critically low (<40%), with special handling
    for first/last rounds and recovery signals.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.last_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if current_stock < self.capacity * 0.1:
            return Action.D
        if round_num == self.n_rounds - 1:
            if current_stock > self.capacity * 0.75 and self.n_rounds <= 3:
                return Action.C
            else:
                return Action.D
        if round_num == 0:
            return Action.C
        stock_increased = False
        if history is not None and round_num > 0:
            if self.last_stock is not None:
                stock_increased = current_stock > self.last_stock
        self.last_stock = current_stock
        if current_stock > self.capacity * 0.75:
            return Action.C
        elif current_stock > self.capacity * 0.4:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_390(BaseStrategy):
    """
    Adaptive Commons Stewardship Strategy (ACS)
    
    Balances individual security with resource sustainability by:
    1. Using a stock-based sustainability index to determine cooperation threshold
    2. Adapting to observed opponent defection rates
    3. Employing end-game defection and collapse handling
    4. Adjusting thresholds in near-final rounds
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        total_rounds = self.n_rounds
        if round_number == 0:
            return Action.C
        if current_stock < 1e-09:
            return Action.D
        if round_number == total_rounds - 1:
            return Action.D
        sustainability_index = current_stock / self.capacity
        total_opponent_actions = history.opponent_actions.size
        if total_opponent_actions > 0:
            defect_count = np.sum(~history.opponent_actions)
            defection_rate = defect_count / total_opponent_actions
        else:
            defection_rate = 0.0
        threshold = 0.5
        if defection_rate > 0.7:
            threshold = 0.65
        elif defection_rate <= 0.3:
            threshold = 0.4
        rounds_remaining = total_rounds - round_number
        if rounds_remaining <= 2:
            threshold = threshold + 0.1 * (3 - rounds_remaining)
        if sustainability_index >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_391(BaseStrategy):
    """
    Adaptive Stock Stewardship Strategy for Common Pool Resource Games.
    
    Prioritizes long-term collective welfare while maintaining individual competitiveness.
    Adapts to observed cooperation/defection patterns while monitoring stock health.
    Uses stock ratio thresholds and recent defection rates to make decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cumulative_defection_index = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if current_round == 0:
            return Action.C
        recent_defection_rate = self._calculate_recent_defection_rate(history, current_round)
        if current_round > 0:
            self.cumulative_defection_index = self._update_cumulative_defection(history, current_round)
        if current_round == self.n_rounds - 1:
            if stock_ratio >= 0.5:
                return Action.C
            else:
                return Action.D
        if stock_ratio < 0.4:
            if stock_ratio >= 0.6 and self.cumulative_defection_index <= 0.3:
                return Action.C if random.random() > 0.1 else Action.D
            if stock_ratio < 0.3 and self.cumulative_defection_index >= 0.7:
                return Action.D
            return Action.D
        if stock_ratio >= 0.75:
            return Action.C
        defection_threshold = 0.5 if self.n_players > 2 else 0.4
        cooperation_threshold = 0.25 if self.n_players > 2 else 0.15
        if recent_defection_rate >= defection_threshold:
            return Action.D
        elif recent_defection_rate <= cooperation_threshold:
            return Action.C
        else:
            cooperation_probability = 1.0 - recent_defection_rate
            return Action.C if random.random() < cooperation_probability else Action.D

    def _calculate_recent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the observed defection rate in the last k rounds.
        k = min(3, rounds_elapsed)
        """
        if current_round == 0:
            return 0.0
        k = min(3, current_round)
        start_idx = current_round - k
        total_opponent_actions = 0
        defection_count = 0
        for round_idx in range(start_idx, current_round):
            opponent_actions_in_round = history.opponent_actions[round_idx, :]
            for action in opponent_actions_in_round:
                total_opponent_actions += 1
                if not action:
                    defection_count += 1
        if total_opponent_actions == 0:
            return 0.0
        return defection_count / total_opponent_actions

    def _update_cumulative_defection(self, history: PlayerHistory, current_round: int) -> float:
        """
        Track cumulative group defections across all rounds.
        cumulative_defection_index = Σ(observed_defections_t / (n-1))
        """
        if current_round == 0:
            return 0.0
        cumulative_index = 0.0
        for round_idx in range(0, current_round):
            opponent_actions_in_round = history.opponent_actions[round_idx, :]
            defection_count = sum((1 for action in opponent_actions_in_round if not action))
            if self.n_players > 1:
                round_defection_rate = defection_count / (self.n_players - 1)
                cumulative_index += round_defection_rate
        return cumulative_index

class Strategy_COLLECTIVE_392(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Reciprocity.
    
    Maintains common pool resource through conditional cooperation based on:
    1. Stock health (≥60% capacity)
    2. Reciprocity (defection rate ≤50% in recent rounds)
    3. Sustainability projection (estimated next-round stock ≥40% capacity)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if stock < 0.1 * self.capacity:
            return Action.D
        if stock < 0.6 * self.capacity:
            return Action.D
        defection_rate = self._calculate_recent_defection_rate(history, round_num)
        if defection_rate > 0.5:
            return Action.D
        projected_stock_next = self._project_next_stock(state, history, round_num)
        if projected_stock_next < 0.4 * self.capacity:
            return Action.D
        return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the proportion of opponent defections in the last 3 rounds.
        Returns value in [0, 1].
        """
        lookback = min(3, round_num)
        if lookback == 0:
            return 0.0
        start_idx = round_num - lookback
        recent_opponent_actions = history.opponent_actions[start_idx:round_num, :]
        num_defections = np.sum(~recent_opponent_actions)
        total_actions = recent_opponent_actions.size
        if total_actions == 0:
            return 0.0
        defection_rate = float(num_defections) / float(total_actions)
        return defection_rate

    def _project_next_stock(self, state: CommonPoolState, history: PlayerHistory, round_num: int) -> float:
        """
        Project stock level after next round assuming:
        - This player cooperates (consumes stock / (2*n))
        - Opponents continue their recent average strategy
        """
        stock = state.current_stock
        n = self.n_players
        capacity = self.capacity
        if round_num > 0:
            last_round_actions = history.opponent_actions[round_num - 1, :]
            coop_count = np.sum(last_round_actions)
            coop_rate = float(coop_count) / float(len(last_round_actions))
        else:
            coop_rate = 1.0
        defect_count = n - 1 - int(coop_rate * (n - 1))
        coop_count_opponents = int(coop_rate * (n - 1))
        expected_opponent_consumption = coop_count_opponents * (stock / (2 * n)) + defect_count * (stock / n)
        our_consumption = stock / (2 * n)
        total_consumption = expected_opponent_consumption + our_consumption
        stock_after_consumption = max(0.0, stock - total_consumption)
        if stock_after_consumption > 0 and capacity > 0:
            growth_rate = 1.0 - stock_after_consumption / capacity
            growth = 2.0 * stock_after_consumption * growth_rate
        else:
            growth = 0.0
        projected_stock_next = min(stock_after_consumption + growth, capacity)
        return projected_stock_next

class Strategy_COLLECTIVE_393(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resources.
    
    Maintains collective resource health through stock-based conditional cooperation.
    - Early rounds: unconditional cooperation to establish norms
    - Healthy stock (>60% capacity): cooperate to preserve ecosystem
    - Critical stock (≤30% capacity): cooperate to prevent collapse
    - Moderate stock (30-60%): cooperate unless recent defection rate >40%
    - Last round: cooperate if stock above critical (resist final-round defection trap)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainable_threshold = 0.6 * self.capacity
        self.critical_threshold = 0.3 * self.capacity
        self.emergency_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round <= 2:
            return Action.C
        if self.emergency_rounds_remaining > 0:
            self.emergency_rounds_remaining -= 1
            return Action.C
        if current_round > 0:
            previous_stock = history.my_payoffs[current_round - 1] * self.n_players
            if previous_stock > 0 and current_stock / previous_stock < 0.5:
                self.emergency_rounds_remaining = 2
                return Action.C
        if current_stock <= self.critical_threshold:
            return Action.C
        if current_stock > self.sustainable_threshold:
            return Action.C
        if current_round == self.n_rounds - 1:
            if current_stock >= self.critical_threshold:
                return Action.C
        defection_rate = self._calculate_defection_rate(history, current_round)
        if defection_rate > 0.4:
            return Action.D
        else:
            return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate recent defection rate from opponents.
        
        Looks at last 5 rounds, with extra weight on recent rounds if stock
        is dropping rapidly. Defection = opponent plays False (Action.D).
        """
        lookback = min(5, current_round)
        if lookback == 0:
            return 0.0
        start_idx = max(0, current_round - lookback)
        recent_actions = history.opponent_actions[start_idx:current_round, :]
        defection_count = 0
        for round_idx in range(recent_actions.shape[0]):
            cooperators = np.sum(recent_actions[round_idx, :])
            majority_threshold = self.n_players / 2.0
            if cooperators < majority_threshold:
                defection_count += 1
        if current_round > 0:
            stock_ratio = history.my_payoffs[-1] * self.n_players / max(1e-06, self.capacity)
            if stock_ratio < 0.4:
                crisis_lookback = min(3, current_round)
                crisis_start = max(0, current_round - crisis_lookback)
                crisis_actions = history.opponent_actions[crisis_start:current_round, :]
                crisis_defection_count = 0
                for round_idx in range(crisis_actions.shape[0]):
                    cooperators = np.sum(crisis_actions[round_idx, :])
                    majority_threshold = self.n_players / 2.0
                    if cooperators < majority_threshold:
                        crisis_defection_count += 1
                defection_count = (defection_count + crisis_defection_count) / 2.0
        defection_rate = defection_count / max(1, lookback)
        return defection_rate

class Strategy_COLLECTIVE_394(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A strategy that prioritizes collective 
    long-term sustainability of the common pool resource while remaining robust 
    against exploitation. Decisions are based on stock health, remaining rounds, 
    historical consumption patterns, and observed opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.initial_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.C
        if current_stock < self.capacity * 0.2:
            return Action.C
        threshold = self._calculate_threshold(current_round, current_stock, history)
        if current_stock > threshold:
            return Action.D
        else:
            return Action.C

    def _calculate_threshold(self, current_round: int, current_stock: float, history: PlayerHistory) -> float:
        """Calculate the dynamic defection threshold based on stock health and history."""
        safe_stock = self.capacity * 0.6
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            avg_consumption = 0.0
        else:
            avg_consumption = (self.initial_stock - current_stock) / current_round
        projected_demand = avg_consumption * rounds_remaining
        threshold = safe_stock + projected_demand * 0.5
        threshold = max(threshold, self.capacity * 0.4)
        opponent_defection_rate = self._get_opponent_defection_rate(history, current_round)
        if opponent_defection_rate > 0.7:
            threshold = threshold * 0.85
        elif opponent_defection_rate < 0.3:
            threshold = threshold * 1.1
        if self._is_stock_declining(history, current_round) and opponent_defection_rate > 0.6:
            threshold = threshold * 0.9
        return threshold

    def _get_opponent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """Calculate the average defection rate of opponents up to current round."""
        if current_round == 0:
            return 0.0
        total_opponent_actions = history.opponent_actions[:current_round, :].size
        if total_opponent_actions == 0:
            return 0.0
        defection_count = np.sum(~history.opponent_actions[:current_round, :])
        defection_rate = float(defection_count) / float(total_opponent_actions)
        return defection_rate

    def _is_stock_declining(self, history: PlayerHistory, current_round: int) -> bool:
        """Check if stock was declining in recent rounds due to heavy defection."""
        if current_round < 2:
            return False
        recent_defection_rate = self._get_opponent_defection_rate(history, current_round)
        return recent_defection_rate > 0.6

class Strategy_COLLECTIVE_395(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS) for Common Pool Resource Games.
    
    Balances sustainability with opportunistic extraction through adaptive decision rules:
    - Cooperate in round 1 to establish baseline
    - Monitor stock health and defection rates
    - Extract when safe (high stock), recover when threatened (low stock)
    - Respond to sustained defection while allowing forgiveness
    - Special handling for endgame and critical thresholds
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 0.25
        self.recovery_target = 0.5
        self.optimal_range_min = 0.6
        self.optimal_range_max = 0.85
        self.defection_tolerance_base = 0.5
        self.collapse_threshold = 2 * self.n_players * 1.5

    def _calculate_health(self, stock: float) -> float:
        """Calculate stock health as a ratio of current to capacity."""
        if self.capacity <= 0:
            return 0.0
        return stock / self.capacity

    def _get_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """Calculate the rate at which opponents have defected (False = D, True = C)."""
        if len(history.opponent_actions) == 0:
            return 0.0
        total_rounds = len(history.opponent_actions)
        high_defection_rounds = 0
        for round_idx in range(total_rounds):
            cooperators = np.sum(history.opponent_actions[round_idx, :])
            defectors = self.n_players - cooperators
            if defectors > self.n_players / 2:
                high_defection_rounds += 1
        return high_defection_rounds / total_rounds if total_rounds > 0 else 0.0

    def _get_recent_defection_rate(self, history: PlayerHistory, window: int=3) -> float:
        """Calculate defection rate in the last N rounds."""
        if len(history.opponent_actions) == 0:
            return 0.0
        recent_rounds = min(window, len(history.opponent_actions))
        high_defection_count = 0
        for round_idx in range(len(history.opponent_actions) - recent_rounds, len(history.opponent_actions)):
            cooperators = np.sum(history.opponent_actions[round_idx, :])
            defectors = self.n_players - cooperators
            if defectors > self.n_players / 2:
                high_defection_count += 1
        return high_defection_count / recent_rounds if recent_rounds > 0 else 0.0

    def _count_sustained_defection(self, history: PlayerHistory, window: int=2) -> int:
        """Count consecutive recent rounds with high defection."""
        if len(history.opponent_actions) == 0:
            return 0
        consecutive_count = 0
        for round_idx in range(len(history.opponent_actions) - 1, -1, -1):
            cooperators = np.sum(history.opponent_actions[round_idx, :])
            defectors = self.n_players - cooperators
            if defectors > self.n_players / 2:
                consecutive_count += 1
                if consecutive_count >= window:
                    return consecutive_count
            else:
                break
        return consecutive_count

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        health = self._calculate_health(stock)
        if stock < self.collapse_threshold or health < self.critical_threshold:
            return Action.C
        defection_rate = self._get_opponent_defection_rate(history)
        recent_defection = self._get_recent_defection_rate(history, window=3)
        sustained_defection = self._count_sustained_defection(history, window=2)
        defection_tolerance = (1.0 + defection_rate * self.n_players / self.n_players) / 2.0
        if current_round >= 3:
            if sustained_defection >= 2 and recent_defection > 0.6 and (health > 0.5):
                return Action.D
        if current_round == self.n_rounds - 1:
            if health > 0.5:
                return Action.D
            else:
                return Action.C
        if health > self.optimal_range_max:
            return Action.D
        if health >= self.optimal_range_min:
            return Action.C
        if health >= self.recovery_target:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_396(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resources.
    
    Balances individual security with collective sustainability by monitoring
    resource health and responding dynamically to observed defection patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainable_threshold = 0.6 * self.capacity
        self.critical_threshold = 0.3 * self.capacity
        self.collapse_threshold = 0.1 * self.capacity
        self.recovery_threshold = 0.9 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if history is None or round_num == 0:
            return Action.C
        if stock < self.collapse_threshold:
            return Action.D
        if stock > self.sustainable_threshold:
            return Action.C
        if stock <= self.critical_threshold:
            return Action.D
        recent_rounds = min(3, round_num)
        if recent_rounds > 0:
            defection_rate = self._calculate_defection_rate(history, recent_rounds)
            if defection_rate > 0.5:
                return Action.D
            elif defection_rate <= 0.25:
                return Action.C
            else:
                return Action.C
        if round_num == self.n_rounds - 1:
            if stock > 0:
                coop_rate = self._calculate_cooperation_rate(history, recent_rounds if recent_rounds > 0 else 1)
                if coop_rate > 0.6:
                    return Action.C
            return Action.D
        if self.n_rounds - round_num <= 2:
            if stock < self.critical_threshold:
                return Action.D
            else:
                coop_rate = self._calculate_cooperation_rate(history, recent_rounds if recent_rounds > 0 else 1)
                if coop_rate > 0.5:
                    return Action.C
                else:
                    return Action.D
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, recent_rounds: int) -> float:
        """
        Calculate the defection rate among opponents in recent rounds.
        Returns fraction of defections observed (0 to 1).
        """
        if recent_rounds <= 0 or len(history.opponent_actions) == 0:
            return 0.0
        start_idx = max(0, len(history.opponent_actions) - recent_rounds)
        recent_opponent_actions = history.opponent_actions[start_idx:]
        total_actions = recent_opponent_actions.size
        if total_actions == 0:
            return 0.0
        defection_count = np.sum(recent_opponent_actions == False)
        return float(defection_count) / float(total_actions)

    def _calculate_cooperation_rate(self, history: PlayerHistory, recent_rounds: int) -> float:
        """
        Calculate the cooperation rate among opponents in recent rounds.
        Returns fraction of cooperations observed (0 to 1).
        """
        if recent_rounds <= 0 or len(history.opponent_actions) == 0:
            return 0.0
        start_idx = max(0, len(history.opponent_actions) - recent_rounds)
        recent_opponent_actions = history.opponent_actions[start_idx:]
        total_actions = recent_opponent_actions.size
        if total_actions == 0:
            return 0.0
        cooperation_count = np.sum(recent_opponent_actions == True)
        return float(cooperation_count) / float(total_actions)

class Strategy_COLLECTIVE_397(BaseStrategy):
    """
    Adaptive Stock Stewardship Strategy: A collective strategy that maximizes
    long-term aggregate welfare by maintaining the common pool's health while
    remaining robust to free-riding. Uses stock-relative thresholds and recent
    defection rates to guide decisions between cooperation and proportional defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.danger_threshold = 0.3 * self.capacity
        self.safety_threshold = 0.7 * self.capacity
        self.tolerance_threshold = 0.5
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        self.stock_history.append(current_stock)
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.C
        stock_health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        recent_defection_rate = self._calculate_recent_defection_rate(history, round_number)
        recent_stock_trend = self._calculate_stock_trend(round_number)
        if stock_health_ratio < 0.3:
            return Action.C
        elif stock_health_ratio < 0.6:
            return Action.C
        elif recent_defection_rate > self.tolerance_threshold:
            return Action.D
        elif recent_stock_trend < 0 and stock_health_ratio < 0.8:
            return Action.C
        else:
            return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the proportion of defections by other players in recent rounds.
        Uses last min(3, round_number) rounds.
        """
        if round_number == 0:
            return 0.0
        lookback_rounds = min(3, round_number)
        start_idx = round_number - lookback_rounds
        recent_opponent_actions = history.opponent_actions[start_idx:round_number, :]
        defection_count = np.sum(~recent_opponent_actions)
        total_observations = lookback_rounds * (self.n_players - 1)
        if total_observations == 0:
            return 0.0
        defection_rate = defection_count / total_observations
        return defection_rate

    def _calculate_stock_trend(self, round_number: int) -> float:
        """
        Calculate recent stock trend: current_stock - stock_2_rounds_ago.
        Returns 0 if insufficient history.
        """
        if round_number < 2:
            return 0.0
        current_stock = self.stock_history[-1]
        stock_2_rounds_ago = self.stock_history[-3]
        trend = current_stock - stock_2_rounds_ago
        return trend

class Strategy_COLLECTIVE_398(BaseStrategy):
    """
    Adaptive Stock-Preserving Reciprocity (ASPR): A dynamic strategy that balances
    sustainability and reciprocal accountability in common pool resource games.
    
    Core principles:
    - Cooperate when stock is healthy (ρ > 0.75)
    - Condition cooperation on defection rates in moderate stock ranges
    - Defect when stock is critically endangered (ρ ≤ 0.25)
    - Track 3-round moving window of opponent defection rates
    - Special case: first round always cooperates
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        rho = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        window_size = min(3, state.round_number)
        defection_rate = self._calculate_defection_rate(history, window_size)
        if rho > 0.75:
            decision = Action.C
        elif rho > 0.5:
            if defection_rate >= 0.5:
                decision = Action.D
            else:
                decision = Action.C
        elif rho > 0.25:
            if defection_rate < 0.33:
                decision = Action.C
            else:
                decision = Action.D
        else:
            decision = Action.D
        if state.round_number == self.n_rounds - 1:
            if rho > 0.5 and defection_rate < 0.5:
                decision = Action.C
        return decision

    def _calculate_defection_rate(self, history: PlayerHistory, window_size: int) -> float:
        """
        Calculate the defection rate in the most recent window_size rounds.
        
        True = Cooperate (Action.C), False = Defect (Action.D)
        Defection rate = (number of defectors) / (n_players * window_size)
        """
        if window_size <= 0 or history is None:
            return 0.0
        recent_actions = history.opponent_actions[-window_size:, :]
        total_actions = window_size * self.n_players
        total_cooperations = np.sum(recent_actions)
        total_defections = total_actions - total_cooperations
        defection_rate = total_defections / total_actions if total_actions > 0 else 0.0
        return defection_rate

class Strategy_COLLECTIVE_399(BaseStrategy):
    """
    Collective Pool Stewardship Strategy
    
    Balances individual benefit with collective survival through conditional cooperation.
    Core principle: cooperate when stock can sustain it, defect when depleted or in final round.
    Includes adaptive thresholds and stock recovery modes.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.consecutive_coop_turns = 0
        self.previous_defection_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock_current = state.current_stock
        rounds_remaining = self.n_rounds - round_t
        if round_t == self.n_rounds - 1:
            return Action.D
        if stock_current < self.capacity / 3.0:
            if self.consecutive_coop_turns < 2:
                self.consecutive_coop_turns += 1
                return Action.C
            else:
                self.consecutive_coop_turns = 0
        sustainability_threshold = 2.0 * self.capacity * (rounds_remaining / self.n_rounds)
        if round_t > 0:
            current_defection_count = int(np.sum(~history.opponent_actions[round_t - 1, :]))
            if current_defection_count > self.previous_defection_count:
                sustainability_threshold *= 1.25
            self.previous_defection_count = current_defection_count
        if stock_current >= sustainability_threshold:
            self.consecutive_coop_turns += 1
            return Action.C
        else:
            self.consecutive_coop_turns = 0
            return Action.D

class Strategy_COLLECTIVE_400(BaseStrategy):
    """
    Adaptive Commons Stewardship Strategy
    
    Balances exploitation protection with sustainability through conditional cooperation.
    Uses a sustainability threshold (30% capacity) as a circuit breaker and monitors
    defection rates to adapt between cooperation and punishment phases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.sustainability_threshold = game_description.capacity * 0.3
        self.tolerance_threshold = 0.33
        self.in_defection_mode = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_stock < self.sustainability_threshold:
            self.in_defection_mode = False
            return Action.C
        last_round_idx = current_round - 1
        opponent_actions_last_round = history.opponent_actions[last_round_idx, :]
        num_defectors = sum(~opponent_actions_last_round)
        defection_rate = num_defectors / n_players
        if defection_rate > self.tolerance_threshold:
            self.in_defection_mode = True
        elif defection_rate <= self.tolerance_threshold:
            self.in_defection_mode = False
        if current_round == n_rounds - 1 and current_stock >= self.sustainability_threshold:
            return Action.C
        if self.in_defection_mode:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_401(BaseStrategy):
    """
    Adaptive Stock-Preservation Protocol: A collectively rational strategy for common pool resource games.
    
    Core philosophy: Preserve the resource to maintain future payoff potential, punish over-consumption,
    reward cooperation, and adapt dynamically based on observed behavior and stock health.
    
    Decision logic:
    1. Emergency preservation: If stock < 30% capacity, cooperate
    2. Punishment phase: If recent defection rate > 40%, defect
    3. Endgame (last 2 rounds): Cooperate to maximize sustainability
    4. Default: Cooperate
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 0.3 * self.capacity
        self.tolerance_threshold = 0.4
        self.lookback_window = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock_current = state.current_stock
        if round_num == 0:
            return Action.C
        if stock_current < self.critical_threshold:
            return Action.C
        defection_rate = self._calculate_recent_defection_rate(history, round_num)
        rounds_remaining = self.n_rounds - round_num
        if rounds_remaining <= 2:
            return Action.C
        if defection_rate > self.tolerance_threshold:
            return Action.D
        return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the defection rate of opponents in the recent lookback window.
        
        Returns a value in [0, 1] representing the proportion of opponent defections.
        """
        lookback = min(self.lookback_window, round_num)
        if lookback == 0:
            return 0.0
        recent_actions = history.opponent_actions[-lookback:, :]
        defection_count = np.sum(~recent_actions)
        total_possible = (self.n_players - 1) * lookback
        if total_possible == 0:
            return 0.0
        defection_rate = defection_count / total_possible
        return float(defection_rate)

class Strategy_COLLECTIVE_402(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual payoff maximization with collective resource sustainability.
    Starts cooperative, adapts to observed defection rates, monitors ecosystem stress,
    and switches to defection in end-game or under stress conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.danger_threshold = self.capacity * 0.25
        self.tolerance_threshold = 0.4
        self.end_game_threshold = 2
        self.stress_threshold = 0.15 * self.capacity
        self.previous_stock = None
        self.previous_defection_rate = 0.0
        self.adjusted_tolerance = self.tolerance_threshold

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determine action based on current state and history.
        """
        round_num = state.round_number
        stock = state.current_stock
        remaining_rounds = self.n_rounds - round_num
        if round_num == 0:
            self.previous_stock = stock
            return Action.C
        defection_rate = self._calculate_defection_rate(history, round_num)
        stock_decline = self.previous_stock - stock if self.previous_stock is not None else 0.0
        ecosystem_stress = stock_decline > self.stress_threshold
        if defection_rate > self.previous_defection_rate and defection_rate > 0.3:
            self.adjusted_tolerance = max(0.0, self.adjusted_tolerance - 0.1)
        self.previous_stock = stock
        self.previous_defection_rate = defection_rate
        if ecosystem_stress:
            return Action.D
        if stock < self.danger_threshold:
            return Action.D
        if remaining_rounds <= self.end_game_threshold:
            return Action.D
        if stock == 0:
            return Action.D
        if stock > self.danger_threshold and defection_rate <= self.adjusted_tolerance:
            return Action.C
        return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the defection rate of opponents in the previous round.
        
        Returns a value in [0, 1] representing the fraction of opponents who defected.
        """
        if round_num <= 0:
            return 0.0
        prev_round_idx = round_num - 1
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        num_opponents = self.n_players - 1
        if num_opponents == 0:
            return 0.0
        defections = np.sum(opponent_actions_prev == False)
        defection_rate = float(defections) / float(num_opponents)
        return defection_rate

class Strategy_COLLECTIVE_403(BaseStrategy):
    """
    Adaptive Collective Strategy: Regenerative Stewardship
    
    Employs adaptive resource management based on stock health metrics.
    Transitions between cooperative, conditional, and defensive postures
    based on current pool health and observed defection patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        health_ratio = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        defectors_last_round = self._count_defectors_last_round(history, state.round_number)
        if health_ratio >= 0.6:
            return Action.C
        elif 0.3 <= health_ratio < 0.6:
            defection_threshold = math.ceil(self.n_players / 2)
            if defectors_last_round >= defection_threshold:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _count_defectors_last_round(self, history: PlayerHistory, round_number: int) -> int:
        """
        Count the number of defectors in the previous round.
        
        Boolean encoding: True = Cooperate (C), False = Defect (D)
        So we count False values in the last round across all opponents.
        """
        if round_number <= 0:
            return 0
        last_round_idx = round_number - 1
        opponent_actions_last_round = history.opponent_actions[last_round_idx, :]
        defectors = np.sum(~opponent_actions_last_round)
        return int(defectors)

class Strategy_COLLECTIVE_404(BaseStrategy):
    """
    Collective Adaptive Resource Management Strategy
    
    Balances sustainable resource preservation, exploitation defense, and adaptive resilience
    through stock-based cooperation thresholds and dynamic defection rate monitoring.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D if current_stock > 0 else Action.C
        if current_stock < self.capacity / 20:
            return Action.C
        k = min(3, round_number)
        recent_start = max(0, round_number - k)
        total_actions = 0
        total_defections = 0
        for past_round in range(recent_start, round_number):
            for opponent_idx in range(self.n_players - 1):
                total_actions += 1
                if not history.opponent_actions[past_round, opponent_idx]:
                    total_defections += 1
        if total_actions > 0:
            recent_defection_rate = total_defections / total_actions
        else:
            recent_defection_rate = 0.0
        rounds_remaining = self.n_rounds - round_number
        dynamic_threshold = 0.5 - 0.15 * rounds_remaining / self.n_rounds
        sustained_defect = False
        if round_number >= 2:
            defect_count = 0
            for past_round in range(round_number - 2, round_number):
                round_defection_count = 0
                round_total = 0
                for opponent_idx in range(self.n_players - 1):
                    round_total += 1
                    if not history.opponent_actions[past_round, opponent_idx]:
                        round_defection_count += 1
                if round_total > 0 and round_defection_count / round_total > 0.8:
                    defect_count += 1
            if defect_count >= 2:
                sustained_defect = True
        if sustained_defect:
            return Action.D
        if current_stock >= 0.6 * self.capacity and recent_defection_rate <= dynamic_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_405(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): Balances individual sustainability with collective
    resource preservation through stock-health-based cooperation and recency-weighted
    defection tracking.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.4 * game_description.capacity
        self.critical_threshold = 0.1 * game_description.capacity
        self.recency_window = 3
        self.defection_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        rounds_remaining = self.game_description.n_rounds - state.round_number
        if state.current_stock < self.critical_threshold and rounds_remaining > 1:
            return Action.C
        recent_defection_rate = self._calculate_recent_defection_rate(history, state.round_number)
        if recent_defection_rate > self.defection_threshold:
            return Action.D
        if state.current_stock > self.stock_threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_recent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the defection rate among opponents in the last K rounds.
        K = min(3, current_round)
        """
        k = min(self.recency_window, current_round)
        if k == 0:
            return 0.0
        recent_opponent_actions = history.opponent_actions[-k:, :]
        defection_count = np.sum(~recent_opponent_actions)
        total_actions = k * self.game_description.n_players
        if total_actions == 0:
            return 0.0
        recent_defection_rate = defection_count / total_actions
        return recent_defection_rate

class Strategy_COLLECTIVE_406(BaseStrategy):
    """
    Adaptive Conservation Strategy (ACS) for Common Pool Resource Games.
    
    Balances sustainability and exploitation resilience through stock-based thresholds,
    history-based cooperation adjustments, and end-game defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_high = 0.75
        self.threshold_mid = 0.4
        self.threshold_critical = 0.1
        self.cooperation_rate_threshold = 0.6
        self.min_stock_for_cooperation = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n = self.game_description.n_players
        round_num = state.round_number
        stock_ratio = current_stock / capacity if capacity > 0 else 0.0
        if stock_ratio < self.threshold_critical:
            return Action.D
        threshold_mid = self.threshold_mid
        if round_num >= 3 and history is not None:
            recent_defections = self._count_recent_defections(history, round_num, n, 3)
            cooperation_rate = 1.0 - recent_defections / (n * 3) if n * 3 > 0 else 1.0
            if cooperation_rate >= self.cooperation_rate_threshold and current_stock >= capacity * self.min_stock_for_cooperation:
                threshold_mid = 0.3
        if round_num >= 3 and history is not None:
            stock_two_rounds_ago = history.my_payoffs[round_num - 2] if round_num >= 2 else current_stock
            if round_num >= 2:
                prev_stock = self._estimate_previous_stock(history, round_num, capacity, n)
                if prev_stock > 0 and current_stock > prev_stock:
                    threshold_mid = max(0.25, threshold_mid - 0.05)
        if stock_ratio >= self.threshold_high:
            return Action.D
        elif stock_ratio >= threshold_mid:
            return Action.C
        else:
            return Action.D

    def _count_recent_defections(self, history: PlayerHistory, current_round: int, n_players: int, window: int) -> float:
        """
        Count defections in the last 'window' rounds by all players.
        True = Cooperate (C), False = Defect (D)
        """
        start_round = max(0, current_round - window)
        defection_count = 0.0
        for round_idx in range(start_round, current_round):
            if round_idx < len(history.opponent_actions):
                round_defections = np.sum(~history.opponent_actions[round_idx, :])
                defection_count += round_defections
        return defection_count

    def _estimate_previous_stock(self, history: PlayerHistory, current_round: int, capacity: float, n_players: int) -> float:
        """
        Estimate the stock level from two rounds ago by analyzing payoff patterns.
        This is a heuristic estimate based on available history.
        """
        if current_round < 2:
            return capacity
        prev_payoff = history.my_payoffs[current_round - 1]
        estimated_stock = prev_payoff * (1.5 * n_players)
        return min(estimated_stock, capacity)

class Strategy_COLLECTIVE_407(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS): Balances individual resilience against exploitation
    with collective welfare optimization through stock-health responsive cooperation,
    temporal adjustments, exploitation detection, and emergency protocols.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold = self.capacity * 0.4
        self.recovery_threshold = self.capacity * 0.5
        self.emergency_threshold = self.capacity * 0.1
        self.recovery_defection_rate = 0.3
        self.exploitation_mode = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_stock < self.emergency_threshold:
            return Action.D
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        defection_count = 0
        rounds_played = current_round
        for round_idx in range(rounds_played):
            opponent_actions_this_round = history.opponent_actions[round_idx, :]
            defectors_this_round = np.sum(opponent_actions_this_round == False)
            if defectors_this_round > self.n_players / 2:
                defection_count += 1
        defection_rate = defection_count / rounds_played if rounds_played > 0 else 0.0
        if defection_rate > 0.5:
            if current_stock > self.recovery_threshold:
                recent_rounds = min(3, rounds_played)
                recent_defection_count = 0
                for round_idx in range(rounds_played - recent_rounds, rounds_played):
                    opponent_actions_this_round = history.opponent_actions[round_idx, :]
                    defectors_this_round = np.sum(opponent_actions_this_round == False)
                    if defectors_this_round > self.n_players / 2:
                        recent_defection_count += 1
                recent_defection_rate = recent_defection_count / recent_rounds if recent_rounds > 0 else 0.0
                if recent_defection_rate <= self.recovery_defection_rate:
                    self.exploitation_mode = False
                else:
                    self.exploitation_mode = True
                    return Action.D
            else:
                self.exploitation_mode = True
                return Action.D
        else:
            self.exploitation_mode = False
        if current_stock > self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_408(BaseStrategy):
    """
    Adaptive Threshold Stewardship (ATS): A collective strategy for common pool resource games
    that prioritizes long-term sustainability through dynamic thresholds and adaptive defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        sustainability = 0.0
        if current_round > 0 and history is not None:
            prev_round_idx = current_round - 1
            my_action_prev = history.my_actions[prev_round_idx]
            opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
            n_cooperators = int(my_action_prev) + int(np.sum(opponent_actions_prev))
            n_defectors = self.n_players - n_cooperators
            stock_before_consumption_prev = current_stock
            consumption_per_cooperator = stock_before_consumption_prev / (2 * self.n_players)
            consumption_per_defector = stock_before_consumption_prev / self.n_players
            total_consumption_prev = n_cooperators * consumption_per_cooperator + n_defectors * consumption_per_defector
            if stock_before_consumption_prev > 0:
                sustainability = 1.0 - total_consumption_prev / stock_before_consumption_prev
            else:
                sustainability = 0.0
        urgency = (self.n_rounds - current_round) / self.n_rounds if self.n_rounds > 0 else 0.0
        if current_stock < 1e-06:
            return Action.D
        if health_ratio < 0.3 or sustainability < -0.2:
            return Action.D
        if health_ratio >= 0.6 and sustainability >= 0:
            return Action.C
        threshold = 0.45 + urgency * 0.15
        if health_ratio >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_409(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collectively-minded strategy that conditions
    cooperation on stock health. Cooperates when stock is above a dynamic threshold,
    defects when stock is critically low. The threshold starts at 40% of capacity and
    increases to 50% by the final round, with a special 35% threshold in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        progress_ratio = current_round / self.n_rounds
        dynamic_threshold = self.capacity * (0.4 + 0.1 * progress_ratio)
        if current_round == self.n_rounds - 1:
            dynamic_threshold = self.capacity * 0.35
        if current_stock > dynamic_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_410(BaseStrategy):
    """
    Adaptive Commons Stewardship Strategy: Maintains sustainable cooperation by conditioning
    actions on stock levels, detecting defection-driven collapses, and extracting value when
    the commons is degraded or the game is ending.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        if history is not None and round_number > 0:
            prev_round_idx = round_number - 1
            if prev_round_idx >= 0:
                prev_cooperators = int(history.opponent_actions[prev_round_idx].sum())
                if history.my_actions[prev_round_idx]:
                    prev_cooperators += 1
                prev_defectors = self.n_players - prev_cooperators
                if prev_defectors >= math.ceil(self.n_players / 2):
                    return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio >= 0.75:
            return Action.C
        elif 0.5 <= stock_ratio < 0.75:
            if random.random() < 0.8:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_411(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection.
    
    This strategy prioritizes collective long-term sustainability while maintaining
    individual competitiveness. It cooperates conditionally based on stock health
    and opponent defection rates, defects to punish excessive defection, and always
    defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0
        previous_round_idx = current_round - 1
        opponent_defections = sum((1 for i in range(self.n_players - 1) if not history.opponent_actions[previous_round_idx, i]))
        defection_rate = opponent_defections / max(1, self.n_players - 1)
        if stock_ratio > 0.75:
            if defection_rate <= 0.33:
                return Action.C
            else:
                return Action.D
        elif stock_ratio > 0.4:
            if defection_rate <= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_412(BaseStrategy):
    """
    Adaptive Collective Stewardship Strategy (ACS)
    
    Balances individual rationality with collective sustainability by monitoring
    resource health, adapting to observed behaviors, and optimizing long-term payoffs.
    Cooperates when stock is healthy and others cooperate; defects strategically when
    stock is threatened or environment is exploitative.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.estimated_defection_rate = 0.5
        self.stock_ratio_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        self.stock_ratio_history.append(stock_ratio)
        if round_number == 0:
            return Action.C
        self._update_defection_estimate(history, round_number)
        environment = self._classify_environment()
        if stock_ratio < 0.05:
            return Action.D
        if stock_ratio > 0.6:
            if environment == 'COOPERATIVE':
                return Action.C
            else:
                return Action.D
        elif 0.3 < stock_ratio <= 0.6:
            if environment == 'COOPERATIVE':
                return Action.C
            elif environment == 'MIXED':
                prob = (stock_ratio - 0.3) / 0.3
                return Action.C if random.random() < prob else Action.D
            else:
                return Action.D
        else:
            return Action.D

    def _update_defection_estimate(self, history: PlayerHistory, round_number: int) -> None:
        """
        Estimate the average defection rate of other players from history.
        Smooth with prior estimate to resist single-round noise.
        """
        if round_number == 1:
            observed_d = np.sum(~history.opponent_actions[0, :])
            observed_defection_rate = observed_d / (self.n_players - 1)
        else:
            total_opponent_actions = np.sum(~history.opponent_actions[:round_number, :])
            total_possible = (self.n_players - 1) * round_number
            observed_defection_rate = total_opponent_actions / total_possible if total_possible > 0 else 0.5
        self.estimated_defection_rate = 0.7 * observed_defection_rate + 0.3 * self.estimated_defection_rate

    def _classify_environment(self) -> str:
        """
        Classify the environment based on estimated defection rate.
        """
        if self.estimated_defection_rate < 0.15:
            return 'COOPERATIVE'
        elif self.estimated_defection_rate < 0.5:
            return 'MIXED'
        else:
            return 'EXPLOITATIVE'

class Strategy_COLLECTIVE_413(BaseStrategy):
    """
    Adaptive Stewardship with Defection Deterrence: A collective strategy that balances
    individual security with collective sustainability. Maintains high resource levels through
    cooperation, detects and punishes defection in critical zones, and recovers from collapse
    through coordinated restraint.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.defection_threshold = (self.n_players - 1) / self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_number = state.round_number
        if self.capacity <= 0:
            stock_ratio = 0.0
        else:
            stock_ratio = stock / self.capacity
        if stock_ratio >= 0.75:
            return Action.C
        if stock_ratio < 0.4:
            return Action.C
        if round_number == 0:
            return Action.C
        prev_round_idx = round_number - 1
        opponent_actions_prev_round = history.opponent_actions[prev_round_idx, :]
        defection_count = np.sum(~opponent_actions_prev_round)
        if self.n_players > 0:
            defection_rate = defection_count / self.n_players
        else:
            defection_rate = 0.0
        if defection_rate > self.defection_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_414(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual payoff maximization with collective sustainability through
    adaptive conditional cooperation. Cooperates when stock health is good and recent
    defection rates are low, but switches to defection under crisis conditions or
    at endgame. Uses dynamic thresholds that tighten as the game progresses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_t = state.round_number
        if round_t == 0:
            return Action.C
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        recent_window = min(3, round_t)
        defection_rate = self._calculate_recent_defection_rate(history, recent_window)
        if stock_health < 0.2:
            return Action.D
        if round_t == self.n_rounds - 1 and stock_health > 0.1:
            return Action.D
        time_pressure = (self.n_rounds - round_t) / self.n_rounds if self.n_rounds > 0 else 0.0
        stock_threshold = 0.4 + 0.15 * time_pressure
        defection_tolerance = 0.35 - 0.2 * time_pressure
        if stock_health > 0.85:
            defection_tolerance = min(defection_tolerance + 0.15, 0.5)
        if stock_health > stock_threshold and defection_rate <= defection_tolerance:
            return Action.C
        else:
            return Action.D

    def _calculate_recent_defection_rate(self, history: PlayerHistory, window_size: int) -> float:
        """
        Calculate the fraction of players defecting in the most recent window_size rounds.
        
        Args:
            history: PlayerHistory object containing opponent actions
            window_size: Number of recent rounds to examine
            
        Returns:
            Fraction of defectors (0.0 to 1.0)
        """
        if window_size <= 0 or history.opponent_actions.shape[0] == 0:
            return 0.0
        start_idx = max(0, history.opponent_actions.shape[0] - window_size)
        recent_actions = history.opponent_actions[start_idx:, :]
        defector_count = np.sum(~recent_actions)
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        defection_rate = float(defector_count) / float(total_actions)
        return defection_rate

class Strategy_COLLECTIVE_415(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection.
    
    Cooperates when stock is healthy and cooperation rates are high,
    defects when stock is depleted or cooperation is low. Adapts to
    resource depletion and free-rider behavior while maintaining long-term
    sustainability when conditions permit.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        depletion_threshold = max(0.01 * self.capacity, 0.01)
        if current_stock < depletion_threshold:
            return Action.D
        if current_round == self.n_rounds - 1:
            if current_stock >= 0.5 * self.capacity:
                return Action.C
            else:
                return Action.D
        if current_stock >= 0.6 * self.capacity:
            stock_status = 'HEALTHY'
        elif current_stock >= 0.3 * self.capacity:
            stock_status = 'MODERATE'
        else:
            stock_status = 'CRITICAL'
        previous_round_idx = current_round - 1
        if history is not None and previous_round_idx >= 0:
            previous_opponent_actions = history.opponent_actions[previous_round_idx, :]
            cooperators_count = np.sum(previous_opponent_actions)
            cooperation_rate = cooperators_count / self.n_players
        else:
            cooperation_rate = 0.5
        if cooperation_rate >= 0.5:
            coop_status = 'HIGH'
        else:
            coop_status = 'LOW'
        if stock_status == 'CRITICAL':
            return Action.D
        if stock_status == 'HEALTHY':
            if coop_status == 'HIGH':
                return Action.C
            else:
                return Action.D
        if coop_status == 'HIGH':
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_416(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy for common pool resource games
    that prioritizes long-term stock preservation over short-term individual gain.
    
    Core approach:
    - Maintain stock above critical thresholds through cooperative extraction
    - Adjust cooperation probability based on current stock health
    - Only defect when stock is abundant (endgame) or mathematically unrecoverable
    - Never escalate into mutual destruction spirals
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = 0.75 * self.capacity
        self.threshold_medium = 0.5 * self.capacity
        self.threshold_low = 0.25 * self.capacity
        self.threshold_critical = self.capacity / (2 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        n_rounds = self.n_rounds
        if round_number == 0:
            return Action.C
        if round_number <= 2:
            return Action.C
        if round_number >= n_rounds - 1:
            if current_stock > 2 * self.threshold_high:
                return Action.D
            return Action.C
        if round_number >= n_rounds - 3:
            conservative_threshold_high = self.threshold_high * 1.1
            conservative_threshold_medium = self.threshold_medium * 1.1
            conservative_threshold_low = self.threshold_low * 1.1
            if current_stock > conservative_threshold_high:
                return Action.C
            elif current_stock > conservative_threshold_low:
                return self._probabilistic_cooperation(current_stock, conservative_threshold_low, conservative_threshold_high)
            else:
                return Action.C
        if current_stock <= 0.1 * self.capacity:
            return Action.C
        if current_stock <= self.threshold_critical:
            return Action.C
        if round_number >= 2:
            stock_decline = self._calculate_stock_decline(history, round_number)
            if stock_decline > 0.3:
                return Action.C
            elif stock_decline > 0.15:
                return Action.C if random.random() < 0.8 else Action.D
            elif stock_decline > 0:
                pass
        if current_stock > self.threshold_high:
            return Action.C
        elif current_stock > self.threshold_medium:
            return self._probabilistic_cooperation(current_stock, self.threshold_low, self.threshold_high)
        else:
            return Action.C

    def _calculate_stock_decline(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the stock decline rate over recent rounds.
        Returns the fractional decline from 2 rounds ago to current round.
        """
        if round_number < 2:
            return 0.0
        stock_at_t_minus_2 = self._reconstruct_stock_at_round(history, round_number - 2)
        stock_at_t = self._reconstruct_stock_at_round(history, round_number - 1)
        if stock_at_t_minus_2 <= 0:
            return 0.0
        decline = (stock_at_t_minus_2 - stock_at_t) / stock_at_t_minus_2
        return max(0.0, decline)

    def _reconstruct_stock_at_round(self, history: PlayerHistory, round_index: int) -> float:
        """
        Reconstruct the stock level at the end of a given round.
        Start from capacity and simulate forward using action history.
        """
        stock = self.capacity
        for r in range(round_index + 1):
            my_action = history.my_actions[r]
            opponent_actions = history.opponent_actions[r, :]
            my_consumption = stock / self.capacity if my_action else stock / (2 * self.capacity)
            total_consumption = my_consumption
            for opp_action in opponent_actions:
                if opp_action:
                    total_consumption += stock / (2 * self.n_players)
                else:
                    total_consumption += stock / self.n_players
            stock_after_consumption = max(0.0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
                stock = min(stock_after_consumption + growth, self.capacity)
            else:
                stock = 0.0
        return stock

    def _probabilistic_cooperation(self, current_stock: float, threshold_low: float, threshold_high: float) -> Action:
        """
        Smooth probabilistic transition in the medium stock zone.
        Cooperation probability increases from 0 to 1 as stock goes from low to high.
        """
        if current_stock <= threshold_low:
            coop_prob = 0.0
        elif current_stock >= threshold_high:
            coop_prob = 1.0
        else:
            coop_prob = (current_stock - threshold_low) / (threshold_high - threshold_low)
        return Action.C if random.random() < coop_prob else Action.D

class Strategy_COLLECTIVE_417(BaseStrategy):
    """
    Adaptive Stewardship with Defensive Threshold Strategy
    
    Balances collective long-term sustainability with individual security.
    Cooperates when stock is healthy, defects when depleted or environment is hostile.
    Adaptively adjusts cooperation threshold based on observed defection patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.defection_count = 0
        self.total_opponent_actions = 0
        self.threshold = self.capacity * 0.4
        self.previous_stock = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        self._update_defection_tracking(history, round_num)
        self._adjust_threshold()
        if round_num > 0:
            self._check_stock_recovery(current_stock)
        if current_stock < self.capacity * 0.1:
            return Action.D
        if current_stock >= self.threshold:
            return Action.C
        else:
            return Action.D

    def _update_defection_tracking(self, history: PlayerHistory, round_num: int) -> None:
        """
        Update defection count and total opponent actions from the previous round.
        """
        if round_num > 0 and history is not None:
            prev_round_idx = round_num - 1
            opponent_actions_prev_round = history.opponent_actions[prev_round_idx, :]
            defections_in_round = np.sum(~opponent_actions_prev_round)
            self.defection_count += int(defections_in_round)
            self.total_opponent_actions += self.n_players - 1

    def _adjust_threshold(self) -> None:
        """
        Adjust threshold based on observed defection ratio.
        """
        if self.total_opponent_actions == 0:
            return
        defection_ratio = self.defection_count / self.total_opponent_actions
        if defection_ratio > 0.75:
            self.threshold = self.capacity * 0.6
        elif defection_ratio > 0.5:
            self.threshold = self.capacity * 0.5
        elif defection_ratio < 0.2:
            self.threshold = self.capacity * 0.3
        else:
            self.threshold = self.capacity * 0.4

    def _check_stock_recovery(self, current_stock: float) -> None:
        """
        Detect stock recovery signal and adjust threshold downward if recovery is strong.
        """
        if self.previous_stock > 0:
            stock_increase_ratio = (current_stock - self.previous_stock) / self.previous_stock
            if stock_increase_ratio > 0.3:
                self.threshold = self.capacity * 0.35
        self.previous_stock = current_stock

class Strategy_COLLECTIVE_418(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Response.
    
    Balances long-term resource sustainability with robustness to exploitation.
    Uses graduated responses to defection and maintains cooperation when conditions
    allow for mutual benefit.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = game_description.capacity * 0.35
        self.defection_tolerance = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        defection_rate = self._calculate_defection_rate(state.round_number, history)
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > self.critical_threshold:
                return Action.C
            else:
                return Action.D
        if state.current_stock < self.critical_threshold:
            return Action.D
        if defection_rate > self.defection_tolerance:
            return Action.D
        return Action.C

    def _calculate_defection_rate(self, current_round: int, history: PlayerHistory) -> float:
        """
        Calculate the recent defection rate among all players.
        
        Looks back k = min(3, current_round) rounds.
        Returns fraction of total consumption actions that were defections.
        """
        k = min(3, current_round)
        start_idx = current_round - k
        end_idx = current_round
        recent_opponent_actions = history.opponent_actions[start_idx:end_idx, :]
        defections = np.sum(~recent_opponent_actions)
        total_actions = self.game_description.n_players * k
        if total_actions == 0:
            return 0.0
        defection_rate = defections / total_actions
        return defection_rate

class Strategy_COLLECTIVE_419(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS) for Common Pool Resource Game.
    
    Balances personal security, collective sustainability, and adaptive response
    to observed defection patterns using a three-tier framework based on stock health
    and defection detection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.C
        health_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        defection_rate = self._calculate_defection_rate(history, round_num)
        if round_num == self.n_rounds - 1:
            return Action.D
        if stock < 0.15 * self.capacity:
            return Action.D
        base_coop_threshold_healthy = 0.33
        base_coop_threshold_stressed = 0.25
        if self.n_players == 2:
            base_coop_threshold_healthy = 0.4
            base_coop_threshold_stressed = 0.33
        if self.n_rounds > 10:
            base_coop_threshold_healthy = 0.3
            base_coop_threshold_stressed = 0.23
        if round_num <= 2:
            defection_rate = max(0.0, defection_rate - 0.1)
        if health_ratio >= 0.6:
            if defection_rate <= base_coop_threshold_healthy:
                return Action.C
            else:
                return Action.D
        elif health_ratio >= 0.3:
            if defection_rate <= base_coop_threshold_stressed:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Estimate the defection rate from observed history.
        
        A significant decline is detected when stock fails to maintain or grow
        as expected under optimal (all-cooperate) consumption.
        """
        if round_num <= 1:
            return 0.0
        significant_declines = 0
        for r in range(1, round_num):
            stock_before = history.my_payoffs[r - 1] * 2 * self.n_players if r == 1 else None
            if r == 1:
                stock_prev = self.capacity
            else:
                stock_prev = self.capacity * 0.8
            opponent_defects = sum((1 for i in range(self.n_players - 1) if not history.opponent_actions[r, i]))
            if opponent_defects > (self.n_players - 1) / 2:
                significant_declines += 1
        defection_rate = significant_declines / (round_num - 1) if round_num > 1 else 0.0
        return min(1.0, max(0.0, defection_rate))

class Strategy_COLLECTIVE_420(BaseStrategy):
    """
    Adaptive Stewardship with Defensive Compliance: A state-aware conditional cooperation strategy
    that maximizes collective welfare while protecting against defection through proportional responses.
    
    Core mechanism: Adjusts cooperation based on stock health and observed defection rates,
    with stricter enforcement as resources become scarcer.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_health = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        last_round_idx = state.round_number - 1
        opponent_actions_last_round = history.opponent_actions[last_round_idx, :]
        defection_count = np.sum(~opponent_actions_last_round)
        defection_rate = defection_count / self.n_players if self.n_players > 0 else 0.0
        if np.all(history.my_actions[:last_round_idx + 1]):
            all_opponent_coop = np.all(history.opponent_actions[:last_round_idx + 1, :])
            if all_opponent_coop and stock_health >= 0.25:
                return Action.C
        if state.round_number == self.n_rounds - 1:
            if stock_health >= 0.5:
                return Action.C
        if stock_health >= 0.75:
            return Action.C
        elif stock_health >= 0.5:
            defection_threshold = 2.0 / self.n_players if self.n_players > 0 else 0.0
            if defection_rate <= defection_threshold:
                return Action.C
            else:
                return Action.D
        elif stock_health >= 0.25:
            defection_threshold = 1.0 / self.n_players if self.n_players > 0 else 0.0
            if defection_rate <= defection_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_421(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): Balances individual payoff maximization with
    collective resource preservation. Adapts to opponent behavior while maintaining
    a bias toward cooperation when it serves collective interests and stock health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        defection_rate = self._calculate_defection_rate(history, round_number)
        if health_ratio < 0.2:
            return Action.C
        if health_ratio < 0.5:
            if defection_rate > 0.65:
                prob_defect = min(0.7, defection_rate)
                return Action.D if random.random() < prob_defect else Action.C
            else:
                return Action.C
        if health_ratio < 0.85:
            if defection_rate > 0.65:
                return Action.D
            elif defection_rate > 0.4:
                return Action.C
            else:
                return Action.C
        if health_ratio >= 0.85:
            if defection_rate > 0.65:
                return Action.C if random.random() < 0.5 else Action.D
            else:
                return Action.C
        if round_number >= self.n_rounds - 2:
            if health_ratio < 0.5:
                return Action.C
            else:
                return Action.C
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the defection rate of opponents from history.
        
        Returns a value in [0.0, 1.0] representing the proportion of opponent actions
        that were defections (False).
        """
        if round_number == 0:
            return 0.0
        rounds_played = round_number
        num_opponents = self.n_players - 1
        if rounds_played == 0 or num_opponents == 0:
            return 0.0
        defection_count = 0
        for r in range(rounds_played):
            for opp in range(num_opponents):
                if not history.opponent_actions[r, opp]:
                    defection_count += 1
        total_actions = rounds_played * num_opponents
        defection_rate = defection_count / total_actions if total_actions > 0 else 0.0
        return defection_rate

class Strategy_COLLECTIVE_422(BaseStrategy):
    """
    Adaptive Stewardship with Defection Deterrence
    
    Balances sustainability, reciprocity, and pragmatism by:
    1. Cooperating when stock is healthy AND defection rates are low
    2. Defecting when stock is at risk OR others are defecting excessively
    3. Applying special logic for last round and stock collapse scenarios
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            threshold = self.capacity * (0.4 + 0.1 * self.r / self.r)
            if stock >= threshold:
                return Action.C
            else:
                return Action.D
        rounds_played = round_number
        rounds_remaining = self.r - round_number
        threshold = self.capacity * (0.4 + 0.1 * rounds_remaining / self.r)
        opponent_defections = np.sum(~history.opponent_actions[:rounds_played, :])
        my_defections = np.sum(~history.my_actions[:rounds_played])
        total_defections = opponent_defections + my_defections
        total_possible_actions = self.n * rounds_played
        defection_rate = total_defections / max(1, total_possible_actions)
        tolerance = 0.25 + 0.5 * (rounds_remaining / self.r)
        if round_number == self.r - 1:
            if stock >= self.capacity * 0.3:
                return Action.D
            else:
                return Action.C
        if stock < self.capacity * 0.2:
            return Action.D
        if stock < self.capacity * 0.4:
            strict_tolerance = 0.15
            if stock >= threshold and defection_rate <= strict_tolerance:
                return Action.C
            else:
                return Action.D
        if stock >= threshold and defection_rate <= tolerance:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_423(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS): Maintains common pool sustainability
    through stock-conditional reciprocal cooperation. Cooperates when stock is
    healthy and opponents show low defection rates, defects when stock is
    critically depleted or exploitation is detected.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainability_threshold = self.capacity * 0.4
        self.exploitation_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_stock < self.sustainability_threshold:
            return Action.D
        window_size = min(3, current_round)
        start_idx = max(0, current_round - window_size)
        opponent_defections = 0
        total_opponent_actions = 0
        for round_idx in range(start_idx, current_round):
            for opponent_idx in range(self.n_players - 1):
                if not history.opponent_actions[round_idx, opponent_idx]:
                    opponent_defections += 1
                total_opponent_actions += 1
        if total_opponent_actions == 0:
            defection_rate = 0.0
        else:
            defection_rate = opponent_defections / total_opponent_actions
        if current_round == self.n_rounds - 1:
            if current_stock >= self.sustainability_threshold:
                return Action.C
            else:
                return Action.D
        if defection_rate >= self.exploitation_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_424(BaseStrategy):
    """
    Adaptive Resource Stewardship Strategy (ARS) for Common Pool Resource Game.
    
    Balances long-term sustainability, adaptive reciprocity, and robustness by:
    - Starting with cooperation to build goodwill
    - Defecting in terminal round (subgame perfect equilibrium)
    - Cooperating at critical depletion to enable mutual recovery
    - Adapting to observed defection rates with graduated responses
    - Forgiving defectors who return to cooperation
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.forgiveness_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        critical_threshold = self.capacity * 0.15
        if stock <= critical_threshold:
            return Action.C
        defection_rate = self._calculate_recent_defection_rate(history, round_num)
        if defection_rate == 0:
            self.forgiveness_counter += 1
        else:
            self.forgiveness_counter = 0
        if self.forgiveness_counter >= 2:
            return Action.C
        if defection_rate == 0:
            return Action.C
        elif defection_rate >= 0.5:
            return Action.D
        else:
            stock_buffer_threshold = self.capacity * 0.5
            if stock > stock_buffer_threshold:
                return Action.C
            else:
                return Action.D

    def _calculate_recent_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the defection rate from recent rounds (up to 3 rounds lookback).
        Defection is encoded as False (0), Cooperation as True (1).
        """
        if round_num <= 3:
            lookback = round_num
        else:
            lookback = 3
        if lookback == 0:
            return 0.0
        total_defectors = 0
        for t in range(round_num - lookback, round_num):
            if t >= 0:
                defectors_in_round = np.sum(~history.opponent_actions[t, :])
                total_defectors += defectors_in_round
        total_actions = self.n_players * lookback
        if total_actions == 0:
            return 0.0
        defection_rate = total_defectors / total_actions
        return defection_rate

class Strategy_COLLECTIVE_425(BaseStrategy):
    """
    Adaptive Threshold Cooperation (ATC): A collective strategy that balances
    individual security with collective sustainability in common pool resource games.
    
    Core logic:
    - Cooperate when stock is healthy (above adaptive threshold)
    - Defect when stock is depleted or threshold breached
    - Threshold adapts based on observed depletion rates
    - Special handling for first and last rounds
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_multiplier = 1.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.C
        base_threshold = self.capacity * (1.0 - 1.0 / math.sqrt(self.n_rounds + 1))
        critical_threshold = base_threshold * self.threshold_multiplier
        if round_num > 0 and history is not None:
            depletion_rate = (self.capacity - stock) / (self.capacity * round_num)
            sustainable_rate = 0.5
            if depletion_rate > sustainable_rate:
                self.threshold_multiplier *= 0.95
                critical_threshold = base_threshold * self.threshold_multiplier
        if round_num == self.n_rounds - 1:
            if stock >= critical_threshold * 1.5:
                return Action.C
            else:
                return Action.D
        if stock >= critical_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_426(BaseStrategy):
    """
    Adaptive Threshold Stewardship (ATS): Balances individual payoff maximization
    with collective resource preservation through threshold-based decisions and
    conditional reciprocity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity * 0.35
        self.healthy_threshold_low = self.capacity * 0.55
        self.healthy_threshold_high = self.capacity * 0.95
        self.defection_threshold_base = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            if current_stock > self.critical_threshold:
                return Action.D
            else:
                return Action.C
        if current_stock < self.critical_threshold:
            return Action.C
        if round_number <= 2:
            return Action.C
        defection_threshold = self.defection_threshold_base
        if round_number >= self.n_rounds - 2:
            defection_threshold = 0.4
        estimated_defection_rate = self._estimate_defection_rate(history, round_number)
        stock_trend_adjustment = self._assess_stock_trend(history, round_number)
        defection_threshold += stock_trend_adjustment
        if estimated_defection_rate > defection_threshold and current_stock >= self.healthy_threshold_low:
            return Action.D
        else:
            return Action.C

    def _estimate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Estimate the proportion of players defecting in recent rounds.
        Uses weighted average favoring recent rounds.
        """
        if round_number < 1:
            return 0.0
        recent_rounds_count = min(3, round_number)
        recent_start = round_number - recent_rounds_count
        total_defections = 0.0
        total_observations = 0.0
        weight = 0.7
        for i in range(recent_start, round_number):
            round_offset = i - recent_start
            current_weight = weight ** (recent_rounds_count - 1 - round_offset)
            round_actions = history.opponent_actions[i, :]
            defector_count = np.sum(round_actions == False)
            total_defections += defector_count * current_weight
            total_observations += self.n_players * current_weight
        if total_observations == 0:
            return 0.0
        return total_defections / total_observations

    def _assess_stock_trend(self, history: PlayerHistory, round_number: int) -> float:
        """
        Assess whether stock is declining or improving.
        Returns adjustment to defection threshold.
        """
        if round_number < 2:
            return 0.0
        prev_round = round_number - 1
        my_prev_action = history.my_actions[prev_round]
        prev_consumption_per_player = self._estimate_consumption(my_prev_action, history, prev_round)
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        total_prev_consumption = prev_consumption_per_player * self.n_players
        recent_defection_rate = self._estimate_defection_rate(history, round_number)
        if recent_defection_rate > 0.5:
            return -0.05
        else:
            return 0.0

    def _estimate_consumption(self, my_action: bool, history: PlayerHistory, round_num: int) -> float:
        """
        Estimate per-player consumption based on action.
        True/1 = Cooperate, False/0 = Defect
        """
        if round_num < 0 or round_num >= len(history.my_actions):
            return 0.0
        stock_estimate = self.capacity * 0.7
        if my_action:
            return stock_estimate / (2 * self.n_players)
        else:
            return stock_estimate / self.n_players

class Strategy_COLLECTIVE_427(BaseStrategy):
    """
    Collective Sustainability Strategy (CSS)
    
    Balances individual security against collective long-term value by using
    stock-responsive thresholds to decide cooperation vs. defection. Cooperates
    when resource is abundant, defects when depleted, and adapts to rapid
    depletion patterns or endgame conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_decline_rounds = 0
        self.last_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.game_description.n_rounds - round_number
        if round_number == 0:
            self.last_stock = stock
            return Action.C
        depletion_ratio = stock / self.last_stock if self.last_stock > 0 else 1.0
        if depletion_ratio < 0.85:
            self.consecutive_decline_rounds += 1
        else:
            self.consecutive_decline_rounds = 0
        self.last_stock = stock
        if self.consecutive_decline_rounds >= 2:
            return Action.D
        if stock <= 0:
            return Action.C
        if rounds_remaining <= 2:
            if stock >= capacity * 0.6:
                return Action.C
            else:
                return Action.D
        if stock >= capacity * 0.75:
            return Action.C
        elif stock >= capacity * 0.4:
            return Action.C
        elif stock >= capacity * 0.2:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_428(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual payoff maximization with collective resource sustainability
    through adaptive threshold-based decision-making that responds to stock depletion
    rates and remaining rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.C
        sustainability_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        rounds_remaining = self.n_rounds - current_round
        if sustainability_ratio <= 0.2:
            return Action.D
        if stock <= 0:
            return Action.D
        if sustainability_ratio >= 0.5:
            if rounds_remaining <= 2:
                return Action.D
            else:
                return Action.C
        if current_round >= 2:
            previous_stock = history.opponent_payoffs[-2, 0] if history.opponent_payoffs[-2, 0] > 0 else stock
            depletion_rate = self._calculate_depletion_rate(history, current_round)
            if depletion_rate > 0.3:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

    def _calculate_depletion_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the observed depletion rate from recent rounds.
        
        Depletion rate = (previous_stock - current_stock) / previous_stock
        We estimate this from opponent behavior patterns in recent rounds.
        """
        if current_round < 2:
            return 0.0
        prev_round_actions = history.opponent_actions[-2, :]
        defections_prev = np.sum(~prev_round_actions)
        defection_ratio_prev = defections_prev / self.n_players if self.n_players > 0 else 0.0
        curr_round_actions = history.opponent_actions[-1, :]
        defections_curr = np.sum(~curr_round_actions)
        defection_ratio_curr = defections_curr / self.n_players if self.n_players > 0 else 0.0
        depletion_signal = max(0.0, defection_ratio_curr - defection_ratio_prev + defection_ratio_curr * 0.5)
        return min(1.0, depletion_signal)

class Strategy_COLLECTIVE_429(BaseStrategy):
    """
    Collective Pool Stewardship Strategy
    
    Balances individual security with collective sustainability by:
    1. Monitoring stock health and depletion trends
    2. Adapting consumption based on stock levels and opponent behavior
    3. Signaling restraint while maintaining defensive posture
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == self.n_rounds - 2:
            stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0
            return Action.C if stock_ratio > 0.6 else Action.D
        if current_stock < 0.2 * self.capacity:
            return Action.D
        if current_stock < 0.35 * self.capacity and self._is_stock_declining(history):
            return Action.D
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= 2:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0
        threshold = 0.5
        if self._is_depletion_unsustainable(current_stock, history):
            threshold = 0.65
        defection_rate = self._infer_defection_rate(history, current_round)
        if defection_rate > 0.6:
            threshold = threshold - 0.15
        if rounds_remaining <= self.n_rounds / 3:
            threshold = threshold - 0.1
        if stock_ratio >= threshold:
            return Action.C
        else:
            return Action.D

    def _is_stock_declining(self, history: PlayerHistory) -> bool:
        """Check if stock has been declining in recent rounds."""
        if history is None or len(history.my_payoffs) < 2:
            return False
        if len(history.my_payoffs) >= 2:
            return history.my_payoffs[-1] < history.my_payoffs[-2]
        return False

    def _is_depletion_unsustainable(self, current_stock: float, history: None | PlayerHistory) -> bool:
        """
        Check if expected depletion exceeds recovery potential.
        Uses early warning system to be more conservative in high-depletion scenarios.
        """
        if self.capacity <= 0:
            return False
        if current_stock <= 0:
            return True
        expected_defection_depletion = current_stock / self.n_players
        if self.capacity > 0:
            recovery_potential = 2.0 * current_stock * (1.0 - current_stock / self.capacity)
        else:
            recovery_potential = 0
        return expected_defection_depletion > recovery_potential

    def _infer_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Infer aggregate opponent defection rate from stock dynamics.
        Sharp stock declines suggest widespread defection.
        """
        if history is None or current_round < 2:
            return 0.0
        sharp_decline_rounds = 0
        for round_idx in range(1, min(current_round, len(history.my_payoffs))):
            prev_payoff = history.my_payoffs[round_idx - 1]
            curr_payoff = history.my_payoffs[round_idx]
            if prev_payoff > 0 and curr_payoff < prev_payoff * 0.7:
                sharp_decline_rounds += 1
        rounds_analyzed = max(1, min(current_round, len(history.my_payoffs)))
        return sharp_decline_rounds / rounds_analyzed if rounds_analyzed > 0 else 0.0

class Strategy_COLLECTIVE_430(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection strategy for Common Pool Resource Game.
    
    Core approach:
    1. Preserve commons through stock health assessment (CRITICAL/DEPLETED/HEALTHY/ABUNDANT regions)
    2. Track opponent defection rates to classify regimes (High/Mixed/Cooperative)
    3. Apply conditional reciprocity in HEALTHY stock regions
    4. Terminal defection in final round if stock permits
    5. Cooperative opening in first round
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        stock_ratio = current_stock / self.capacity
        if stock_ratio < 0.2:
            return Action.C
        if stock_ratio < 0.5:
            return Action.C
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            if stock_ratio > 0.2:
                return Action.D
            else:
                return Action.C
        if stock_ratio >= 0.5:
            lookback_window = min(3, current_round)
            if lookback_window == 0:
                return Action.C
            defections_by_others = 0
            for round_idx in range(current_round - lookback_window, current_round):
                defections_in_round = self.n_players - 1 - np.sum(history.opponent_actions[round_idx, :])
                defections_by_others += defections_in_round
            total_possible = lookback_window * (self.n_players - 1)
            if total_possible == 0:
                recent_defection_rate = 0.0
            else:
                recent_defection_rate = defections_by_others / total_possible
            if recent_defection_rate > 0.6:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_COLLECTIVE_431(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection.
    
    A hybrid strategy combining tit-for-tat with stock health awareness.
    Cooperates initially and in middle rounds unless opponents defect frequently,
    switches to emergency conservation if stock drops below critical thresholds,
    and defects in final round (unless stock is critically low).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.in_emergency_mode = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        capacity = self.capacity
        if current_stock < 0.2 * capacity:
            self.in_emergency_mode = True
            return Action.C
        if self.in_emergency_mode and current_stock >= 0.4 * capacity:
            self.in_emergency_mode = False
        if self.in_emergency_mode:
            return Action.C
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            if current_stock < 0.3 * capacity:
                return Action.C
            else:
                return Action.D
        recent_window = max(3, self.n_rounds // 4)
        start_idx = max(0, round_number - recent_window)
        recent_opponent_actions = history.opponent_actions[start_idx:round_number, :]
        if recent_opponent_actions.size > 0:
            total_actions = recent_opponent_actions.size
            defection_count = total_actions - np.sum(recent_opponent_actions)
            defection_rate = defection_count / total_actions
        else:
            defection_rate = 0.0
        if defection_rate > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_432(BaseStrategy):
    """
    Adaptive Sustainability Stewardship: A collective strategy prioritizing long-term
    resource sustainability through conditional cooperation, stock health monitoring,
    and strategic defection to signal costs of exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        stock_health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        cooperation_rate = self._get_cooperation_rate(history, current_round - 1)
        if current_round == self.n_rounds - 1:
            if stock_health_ratio >= 0.4:
                return Action.C
            else:
                return Action.D
        if stock_health_ratio < 0.3:
            return Action.C
        if 0.3 <= stock_health_ratio < 0.6:
            if cooperation_rate >= 0.5:
                return Action.C
            elif cooperation_rate == 0.0:
                return Action.D
            else:
                return Action.C
        if current_round >= self.n_rounds - 2:
            if stock_health_ratio >= 0.6:
                return Action.C
            elif 0.4 <= stock_health_ratio < 0.6:
                if cooperation_rate > 0.5:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        if current_round <= 2:
            if cooperation_rate >= 1.0:
                return Action.C
            elif cooperation_rate >= 0.5:
                return Action.C
            elif stock_health_ratio >= 0.7:
                return Action.C
            else:
                return Action.D
        if stock_health_ratio >= 0.5 and cooperation_rate >= 0.5:
            return Action.C
        elif stock_health_ratio >= 0.5 and cooperation_rate < 0.25:
            return Action.C
        elif stock_health_ratio < 0.5:
            if cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _get_cooperation_rate(self, history: PlayerHistory, round_idx: int) -> float:
        """
        Calculate the cooperation rate in a given round.
        Returns the fraction of opponents who cooperated in that round.
        """
        if round_idx < 0 or round_idx >= len(history.opponent_actions):
            return 0.0
        cooperators = float(np.sum(history.opponent_actions[round_idx, :]))
        total_opponents = len(history.opponent_actions[round_idx, :])
        if total_opponents == 0:
            return 0.0
        return cooperators / total_opponents

class Strategy_COLLECTIVE_433(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection.
    
    Cooperates when the commons is healthy; defects when depleted.
    Uses dynamic stock-based thresholds informed by observed opponent behavior.
    Implements emergency defection on stock collapse and adaptive mid/end-game strategies.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.emergency_mode = False
        self.pre_emergency_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.C
        observed_cooperation_rate = self._calculate_cooperation_rate(history, current_round)
        if stock < 0.25 * self.capacity:
            self.emergency_mode = True
            self.pre_emergency_stock = stock
            return Action.D
        if self.emergency_mode and stock >= 0.4 * self.capacity:
            self.emergency_mode = False
            self.pre_emergency_stock = None
        if current_round <= 2:
            return Action.C
        if stock >= 0.99 * self.capacity:
            return Action.C
        if current_round <= self.n_rounds - 3:
            sustainability_threshold = self.capacity * (0.5 + 0.3 * observed_cooperation_rate)
        else:
            sustainability_threshold = self.capacity * max(0.3, observed_cooperation_rate)
        if stock >= sustainability_threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the observed cooperation rate from opponents' past actions.
        Returns a value in [0, 1].
        """
        if current_round == 0:
            return 1.0
        total_opponent_actions = current_round * (self.n_players - 1)
        if total_opponent_actions == 0:
            return 1.0
        cooperations = np.sum(history.opponent_actions[:current_round, :])
        cooperation_rate = cooperations / total_opponent_actions
        return float(cooperation_rate)

class Strategy_COLLECTIVE_434(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy that maintains common pool
    health through stock-based thresholds, adapting to opponent behavior and game phase.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.minimum_viable_stock = self.capacity * 0.25
        self.emergency_threshold = self.capacity * 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            if stock > 0:
                return Action.D
            else:
                return Action.C
        if stock < self.emergency_threshold:
            return Action.C
        threshold = self.capacity * (1.0 - (round_num / self.n_rounds) ** 2)
        cooperation_rate = self._calculate_recent_cooperation_rate(history, round_num)
        if cooperation_rate <= 0.5:
            threshold *= 0.95
        if self._is_stock_declining(history, round_num):
            threshold *= 1.1
        if stock >= threshold:
            estimated_next_stock = self._estimate_stock_after_cooperation(stock)
            if estimated_next_stock >= self.minimum_viable_stock:
                return Action.C
        return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, round_num: int) -> float:
        """Calculate cooperation rate in the last 3 rounds (or fewer if early game)."""
        if round_num == 0:
            return 1.0
        start_round = max(0, round_num - 3)
        recent_actions = history.opponent_actions[start_round:round_num, :]
        if recent_actions.size == 0:
            return 1.0
        cooperators = np.sum(recent_actions)
        total_actions = recent_actions.size
        if total_actions == 0:
            return 1.0
        return cooperators / total_actions

    def _is_stock_declining(self, history: PlayerHistory, round_num: int) -> bool:
        """Check if stock was lower in the last round compared to 2 rounds ago."""
        if round_num < 2:
            return False
        recent_coop = self._calculate_recent_cooperation_rate(history, round_num)
        if recent_coop > 0.7:
            if history.my_payoffs[round_num - 1] < self.capacity / (2 * self.n_players) * 0.8:
                return True
        return False

    def _estimate_stock_after_cooperation(self, current_stock: float) -> float:
        """
        Estimate stock level after this round if player cooperates.
        Assumes pessimistic scenario: majority of others also cooperate.
        """
        consumption_per_cooperator = current_stock / (2 * self.n_players)
        total_consumption = self.n_players * consumption_per_cooperator
        stock_after_consumption = current_stock - total_consumption
        stock_after_consumption = max(0, stock_after_consumption)
        if self.capacity > 0:
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
        else:
            growth = 0
        new_stock = min(stock_after_consumption + growth, self.capacity)
        return new_stock

class Strategy_COLLECTIVE_435(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective-first strategy that prioritizes
    long-term common pool sustainability while adapting to stock levels and observed
    defection rates. Cooperates when stock is healthy, defects when depleted or when
    others defect excessively, with special handling for first/last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_countdown = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if round_number == 0:
            return Action.C
        if self.punishment_countdown > 0:
            self.punishment_countdown -= 1
            if self.punishment_countdown > 0:
                return Action.D
        if stock_ratio >= 0.75:
            return Action.C
        if stock_ratio < 0.4:
            return Action.D
        last_round_idx = round_number - 1
        last_round_actions = history.opponent_actions[last_round_idx, :]
        num_cooperators_last = np.sum(last_round_actions)
        num_defectors_last = self.n_players - num_cooperators_last
        defection_rate = num_defectors_last / self.n_players
        if round_number >= 2:
            prev_round_idx = round_number - 2
            prev_round_actions = history.opponent_actions[prev_round_idx, :]
            prev_num_cooperators = np.sum(prev_round_actions)
            prev_defection_rate = (self.n_players - prev_num_cooperators) / self.n_players
            defection_spike = defection_rate - prev_defection_rate
            if defection_spike > 0.3:
                self.punishment_countdown = 2
                return Action.D
        threshold = 0.35 if self.n_players == 2 else 0.25
        if defection_rate <= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_436(BaseStrategy):
    """
    Adaptive Conservation with Resilience (ACR) Strategy
    
    Balances individual short-term gains against collective long-term sustainability.
    Uses adaptive decision rules based on stock levels, defection rates, and game phase.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.C
        if stock < self.capacity * 0.15:
            return Action.D
        if round_num == self.n_rounds - 1:
            if stock > self.capacity * 0.3:
                return Action.C
            else:
                return Action.D
        if round_num >= 1:
            prev_stock = history.opponent_payoffs[round_num - 1].sum() / self.n_players
            if round_num >= 2:
                stock_drop_pct = (history.opponent_payoffs[round_num - 2].sum() / self.n_players - stock) / max(stock, 1e-06)
                if stock_drop_pct > 0.3:
                    return Action.D
        opponent_actions_prev = history.opponent_actions[round_num - 1, :]
        defection_count = (opponent_actions_prev == False).sum()
        defection_rate = defection_count / (self.n_players - 1) if self.n_players > 1 else 0.0
        if defection_rate > 0.5:
            return Action.D
        elif defection_rate > 0.2:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_437(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Operates on conditional cooperation with adaptive thresholds, targeting
    stock health while protecting against exploitation. Uses stock ratio
    thresholds and recent defection history to make decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        rounds_remaining = self.n_rounds - state.round_number
        if rounds_remaining == 1:
            return Action.D
        if rounds_remaining == 2:
            if stock_ratio > 0.5:
                return Action.C
            else:
                return Action.D
        if stock_ratio >= 0.75:
            return Action.C
        if stock_ratio >= 0.5:
            recent_defection_rate = self._calculate_recent_defection_rate(history)
            if recent_defection_rate < 0.25:
                return Action.C
            else:
                return Action.D
        if stock_ratio >= 0.25:
            recent_defection_rate = self._calculate_recent_defection_rate(history)
            if recent_defection_rate > 0.75:
                return Action.D
            else:
                return Action.C
        return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the defection rate among all players in the last k rounds.
        k = min(3, rounds_completed)
        
        Returns a value between 0.0 and 1.0.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        rounds_completed = len(history.opponent_actions)
        k = min(3, rounds_completed)
        defection_count = 0
        for i in range(rounds_completed - k, rounds_completed):
            if i >= 0:
                defection_count += self.n_players - int(np.sum(history.opponent_actions[i, :]))
        total_actions = self.n_players * k
        if total_actions == 0:
            return 0.0
        return defection_count / total_actions

class Strategy_COLLECTIVE_438(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection.
    
    Balances individual payoff maximization with collective resource sustainability.
    Uses conditional reciprocity based on resource health and observed group behavior.
    Cooperates when resources are healthy and others reciprocate; defects when necessary
    to protect individual interests or when collective stewardship is no longer viable.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 0.3 * self.capacity
        self.warning_threshold = 0.65 * self.capacity
        self.defection_tolerance = 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        defection_rate = self._calculate_defection_rate(history, current_round)
        if current_stock < self.critical_threshold:
            return Action.D
        if current_stock < self.warning_threshold:
            if defection_rate > self.defection_tolerance:
                return Action.D
            else:
                return Action.C
        if defection_rate > self.defection_tolerance:
            return Action.D
        else:
            return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the observed defection rate from opponent history.
        Defection is represented as False (0), Cooperation as True (1).
        """
        if current_round == 0:
            return 0.5
        total_defections = 0
        total_observations = 0
        for round_idx in range(current_round):
            round_defections = np.sum(~history.opponent_actions[round_idx, :])
            total_defections += round_defections
            total_observations += self.n_players
        if total_observations == 0:
            return 0.5
        defection_rate = total_defections / total_observations
        return defection_rate

class Strategy_COLLECTIVE_439(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Defection Detection.
    
    A three-state system balancing resource health, cooperation health, and game phase
    to make decisions that prioritize long-term collective welfare while maintaining
    individual security. Cooperates by default unless resource is critical, opponents
    are hostile, or game is in terminal phase.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        resource_state = self._classify_resource(state.current_stock)
        cooperation_state = self._classify_cooperation(history, state.round_number)
        phase = self._classify_phase(state.round_number)
        rounds_remaining = self.r - state.round_number
        if resource_state == 'CRITICAL':
            return Action.D
        if resource_state == 'STRESSED' and cooperation_state == 'HOSTILE':
            return Action.D
        if phase == 'LATE' and rounds_remaining <= 2:
            return Action.D
        if cooperation_state == 'DEFECTING':
            if resource_state == 'ABUNDANT':
                return Action.D
            else:
                return Action.C
        if cooperation_state == 'HOSTILE' and resource_state == 'HEALTHY':
            if random.random() < 0.7:
                return Action.D
            else:
                return Action.C
        return Action.C

    def _classify_resource(self, stock: float) -> str:
        """Classify resource health based on current stock level."""
        if stock > 1.5 * self.capacity:
            return 'ABUNDANT'
        elif stock > 0.75 * self.capacity:
            return 'HEALTHY'
        elif stock > 0.4 * self.capacity:
            return 'STRESSED'
        else:
            return 'CRITICAL'

    def _classify_cooperation(self, history: PlayerHistory, current_round: int) -> str:
        """
        Classify cooperation health based on observed defection rates.
        defection_rate = fraction of rounds where >50% of players played D
        """
        if current_round == 0:
            return 'COOPERATIVE'
        defection_rounds = 0
        rounds_to_analyze = current_round
        for round_idx in range(rounds_to_analyze):
            defectors = sum((1 for action in history.opponent_actions[round_idx, :] if not action))
            if not history.my_actions[round_idx]:
                defectors += 1
            total_players = self.n + 1
            if defectors > total_players / 2:
                defection_rounds += 1
        defection_rate = defection_rounds / rounds_to_analyze if rounds_to_analyze > 0 else 0
        if defection_rate < 0.25:
            return 'COOPERATIVE'
        elif defection_rate < 0.5:
            return 'CAUTIOUS'
        elif defection_rate < 0.75:
            return 'DEFECTING'
        else:
            return 'HOSTILE'

    def _classify_phase(self, current_round: int) -> str:
        """Classify game phase based on rounds remaining."""
        rounds_remaining = self.r - current_round
        if rounds_remaining > 0.5 * self.r:
            return 'EARLY'
        elif rounds_remaining > 0.2 * self.r:
            return 'MIDDLE'
        else:
            return 'LATE'

class Strategy_COLLECTIVE_440(BaseStrategy):
    """
    Adaptive Sustainable Harvesting (ASH) Strategy
    
    Balances individual payoff maximization with long-term resource sustainability
    through adaptive thresholds that respond to resource health and game phase.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        rounds_remaining = self.n_rounds - round_num
        stock_declining = False
        if round_num > 0 and history is not None:
            if round_num > 0:
                prev_round_idx = round_num - 1
                my_action_prev = history.my_actions[prev_round_idx]
                opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
                my_consumption_prev = stock / (2 * self.n_players) if my_action_prev else stock / self.n_players
                opponent_consumption_prev = sum((stock / (2 * self.n_players) if opp_action else stock / self.n_players for opp_action in opponent_actions_prev))
                total_consumption_prev = my_consumption_prev + opponent_consumption_prev
                stock_after_consumption = stock - total_consumption_prev
                if round_num > 0:
                    stock_declining = stock < self.capacity
        danger_threshold = 0.3 + rounds_remaining / self.n_rounds * 0.15
        recovery_threshold = 0.55 + rounds_remaining / self.n_rounds * 0.2
        if round_num == self.n_rounds - 1:
            if stock_ratio > 0.4:
                return Action.D
            else:
                return Action.C
        if stock_declining or stock_ratio < danger_threshold:
            return Action.C
        if stock_ratio > recovery_threshold:
            return Action.D
        if recovery_threshold > danger_threshold:
            cooperation_probability = (recovery_threshold - stock_ratio) / (recovery_threshold - danger_threshold)
        else:
            cooperation_probability = 0.5
        cooperation_probability = max(0.0, min(1.0, cooperation_probability))
        if random.random() < cooperation_probability:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_441(BaseStrategy):
    """
    Adaptive Sustainability Management (ASM) Strategy
    
    A common pool resource strategy that prioritizes collective long-term sustainability
    by maintaining stock near the growth-optimal level (50% capacity) while adapting to
    defection rates and remaining rounds. Implements stock-health thresholds, observational
    adaptation, and special end-game logic.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.safe_threshold = 0.5 * game_description.capacity
        self.critical_threshold = 0.25 * game_description.capacity
        self.collapse_threshold = 0.1 * game_description.capacity
        self.high_defection_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock_level = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        round_num = state.round_number
        total_rounds = self.game_description.n_rounds
        rounds_remaining = total_rounds - round_num
        if history is None or round_num == 0:
            if stock_level > self.safe_threshold:
                return Action.C
            return Action.C
        if stock_level < self.collapse_threshold:
            return Action.D
        if round_num == total_rounds - 1:
            if stock_level / capacity > 0.6:
                return Action.C
            else:
                return Action.D
        last_round_idx = round_num - 1
        if last_round_idx >= 0 and last_round_idx < len(history.opponent_actions):
            opponent_actions_last_round = history.opponent_actions[last_round_idx, :]
            defectors_last_round = np.sum(~opponent_actions_last_round)
            defection_ratio = defectors_last_round / n_players
            if defection_ratio > self.high_defection_threshold:
                return Action.D
        if stock_level > self.safe_threshold:
            return Action.C
        if stock_level <= self.safe_threshold and stock_level > self.critical_threshold:
            return Action.C
        if stock_level <= self.critical_threshold:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_442(BaseStrategy):
    """
    Adaptive Stock-Preserving Cooperation (ASPC): A collective strategy that balances
    resource sustainability with adaptive responses to defection pressure. Cooperates
    when stock is healthy, conditionally cooperates based on defection rates when stock
    is moderate, and defects when stock is critically depleted or in the final round
    with healthy stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        stock_health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_health_ratio >= 0.75:
            return Action.C
        if round_number > 3 and stock_health_ratio >= 0.7:
            defection_rate = self._calculate_defection_rate(history, round_number)
            if defection_rate < 0.3:
                return Action.C
        if round_number == self.n_rounds - 1:
            if stock_health_ratio > 0.5:
                return Action.D
            else:
                return Action.C
        if 0.5 <= stock_health_ratio < 0.75:
            defection_rate = self._calculate_defection_rate(history, round_number)
            if defection_rate < 0.25:
                return Action.C
            else:
                return Action.D
        if stock_health_ratio < 0.5:
            return Action.D
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the aggregate defection rate from all observed rounds.
        Defection rate = (total_defections) / (n_players × rounds_completed)
        
        Uses boolean encoding: True = Cooperate (C), False = Defect (D)
        So defections are counted where opponent_actions == False
        """
        if round_number <= 1:
            return 0.0
        total_defections = 0
        total_observations = 0
        for r in range(round_number):
            defections_in_round = np.sum(~history.opponent_actions[r, :])
            total_defections += defections_in_round
            total_observations += self.n_players
        if total_observations == 0:
            return 0.0
        defection_rate = total_defections / total_observations
        return defection_rate

class Strategy_COLLECTIVE_443(BaseStrategy):
    """
    Adaptive Stock Preservation (ASP) Strategy for Common Pool Resource Game.
    
    Prioritizes long-term collective sustainability by switching between cooperation
    and defection based on current stock levels and observed defection rates.
    Uses threshold-based decision rules with endgame adjustment.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players
        self.upper_threshold = self.capacity * 0.75
        self.lower_threshold = self.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        defection_rate = self._calculate_defection_rate(history, round_num)
        if round_num == self.n_rounds - 1:
            if stock > 0:
                return Action.D
            return Action.D
        if stock > self.upper_threshold:
            return Action.C
        if stock > self.lower_threshold:
            if defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the implied defection rate from stock dynamics.
        
        A defection is inferred when stock decreased more than expected given
        the assumed consumption pattern. We estimate this by checking if the
        stock reduction was larger than what full cooperation would cause.
        """
        if round_num < 1:
            return 0.0
        recent_rounds = min(3, round_num)
        if recent_rounds == 0:
            return 0.0
        unexplained_drops = 0
        for i in range(round_num - recent_rounds, round_num):
            if i < 0:
                continue
            opponent_actions = history.opponent_actions[i, :]
            cooperators = sum(opponent_actions)
            defectors = self.n_players - cooperators
            if defectors > cooperators:
                unexplained_drops += 1
        if recent_rounds == 0:
            return 0.0
        return unexplained_drops / recent_rounds

class Strategy_COLLECTIVE_444(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS) for Common Pool Resource Game.
    
    Balances personal welfare with collective sustainability through a three-tier framework:
    1. Always cooperate when stock is critical (preservation)
    2. Detect exploitation and retaliate conditionally
    3. Default to cooperation (restoration)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        stock_threshold = 1.5 * 2 * self.n_players
        if current_stock <= stock_threshold:
            return Action.C
        if self._is_stock_declining(history, window=3):
            return Action.C
        window = min(5, round_num)
        if window > 0:
            defection_count = self._count_defections_in_window(history, window)
            exploitation_rate = defection_count / (self.n_players * window) if window > 0 else 0.0
            rounds_remaining = self.n_rounds - round_num
            if current_stock > 1.8 * 2 * self.n_players:
                threshold = 0.35
            elif current_stock > 1.2 * 2 * self.n_players:
                threshold = 0.5
            else:
                threshold = 0.6
            if round_num == self.n_rounds - 1:
                if current_stock <= 3 * self.n_players:
                    return Action.C
                else:
                    return Action.D if exploitation_rate > threshold else Action.C
            if self._is_lone_cooperator(history, round_num):
                if current_stock > stock_threshold:
                    return Action.D
            if exploitation_rate > threshold:
                return Action.D
        return Action.C

    def _is_stock_declining(self, history: PlayerHistory, window: int) -> bool:
        """Check if stock has been declining for window+ consecutive rounds."""
        if history is None or len(history.my_payoffs) < window:
            return False
        recent_rounds = min(window, len(history.my_payoffs))
        if recent_rounds < window:
            return False
        my_recent = history.my_payoffs[-window:]
        for i in range(1, len(my_recent)):
            if my_recent[i] >= my_recent[i - 1]:
                return False
        return True

    def _count_defections_in_window(self, history: PlayerHistory, window: int) -> int:
        """Count total defections (False/0 values) in opponent actions over window rounds."""
        if history is None or len(history.opponent_actions) == 0:
            return 0
        window = min(window, len(history.opponent_actions))
        recent_actions = history.opponent_actions[-window:, :]
        cooperations = np.sum(recent_actions)
        total_actions = window * self.n_players
        defections = total_actions - cooperations
        return int(defections)

    def _is_lone_cooperator(self, history: PlayerHistory, round_num: int) -> bool:
        """Check if this player was the lone cooperator in the previous round."""
        if round_num == 0 or history is None or len(history.my_actions) == 0:
            return False
        prev_round = round_num - 1
        my_action = history.my_actions[prev_round]
        if not my_action:
            return False
        opponent_actions = history.opponent_actions[prev_round, :]
        opponent_cooperations = np.sum(opponent_actions)
        return opponent_cooperations == 0

class Strategy_COLLECTIVE_445(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy for common pool resource games
    that prioritizes long-term sustainability while remaining robust against defection.
    
    Core approach:
    - Cooperate when stock is healthy (≥40% capacity) and defection rate is low (≤25%)
    - Defect when stock is critically depleted (<20% capacity) or defection is rampant (>25%)
    - Special handling for round 1 (cooperate to establish baseline) and final round
    - Tolerance for occasional defection; graduated response to escalating defection
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainability_threshold = 0.4 * self.capacity
        self.critical_depletion_threshold = 0.2 * self.capacity
        self.defection_tolerance = 0.25
        self.history_defection_tolerance = 0.4
        self.unanimous_cooperation_bonus = 0.05
        self.sudden_spike_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.C
        last_round_idx = round_num - 1
        defection_count_last_round = int(np.sum(~history.opponent_actions[last_round_idx, :]))
        defection_rate_last_round = defection_count_last_round / self.n_players
        avg_defection_rate = np.mean(~history.opponent_actions[:round_num, :])
        if current_stock < self.critical_depletion_threshold:
            return Action.D
        if round_num == self.n_rounds - 1:
            if avg_defection_rate > self.history_defection_tolerance or current_stock < self.critical_depletion_threshold:
                return Action.D
            else:
                return Action.C
        if round_num >= 2:
            prev_prev_round_idx = round_num - 2
            prev_defection_count = int(np.sum(~history.opponent_actions[prev_prev_round_idx, :]))
            prev_defection_rate = prev_defection_count / self.n_players
            defection_jump = abs(defection_rate_last_round - prev_defection_rate)
            if defection_jump > self.sudden_spike_threshold:
                return Action.D
        unanimous_cooperation_last_round = defection_count_last_round == 0
        adjusted_sustainability_threshold = self.sustainability_threshold
        if unanimous_cooperation_last_round:
            adjusted_sustainability_threshold *= 1.0 - self.unanimous_cooperation_bonus
        if current_stock >= adjusted_sustainability_threshold and defection_rate_last_round <= self.defection_tolerance:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_446(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS) for Common Pool Resource Games.
    
    Treats the common pool as a shared resource requiring active stewardship.
    Monitors ecosystem health via stock levels and adapts to observed defection rates
    while maintaining long-term sustainability. Punishes exploitation only when necessary
    to preserve the resource, and rewards cooperation when conditions improve.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        health_indicator = current_stock / self.capacity if self.capacity > 0 else 0.0
        defections_last_round = np.sum(~history.opponent_actions[-1, :])
        defection_pressure = defections_last_round / self.n_players if self.n_players > 0 else 0.0
        if current_round == self.n_rounds - 1:
            if health_indicator < 0.3:
                return Action.D
            else:
                return Action.C
        if health_indicator < 0.2:
            return Action.D
        elif health_indicator < 0.4 and defection_pressure > 0.5:
            return Action.D
        elif health_indicator < 0.4 and defection_pressure <= 0.5:
            return Action.C
        elif health_indicator < 0.7:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_447(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances personal gain with collective sustainability through adaptive responses
    to observed group behavior and resource health. Cooperates initially and in
    critical situations, adapts to cooperation rates in mid-range stock, and defects
    in final round or when defection dominates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_round = state.round_number
        rounds_remaining = n_rounds - current_round - 1
        if current_round == n_rounds - 1:
            return Action.D
        if current_stock < capacity * 0.3:
            return Action.C
        if current_stock > capacity * 0.7 and rounds_remaining >= 2:
            return Action.C
        if capacity * 0.3 <= current_stock <= capacity * 0.7:
            if len(self.stock_history) >= 3:
                stock_two_rounds_ago = self.stock_history[-3]
                if stock_two_rounds_ago > 0:
                    stock_trend = (current_stock - stock_two_rounds_ago) / stock_two_rounds_ago
                    if stock_trend < -0.15 and current_stock > capacity * 0.2:
                        return Action.C
            observed_cooperation_rate = self._calculate_cooperation_rate(history, n_players)
            if observed_cooperation_rate >= 0.6:
                return Action.C
            elif observed_cooperation_rate >= 0.3:
                defection_probability = (1.0 - observed_cooperation_rate) * 0.7
                if random.random() < defection_probability:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D
        return Action.C

    def _calculate_cooperation_rate(self, history: PlayerHistory, n_players: int) -> float:
        """
        Calculate the observed cooperation rate from opponent history.
        Returns a value in [0, 1] representing proportion of cooperators.
        """
        if len(history.opponent_actions) == 0:
            return 0.5
        total_actions = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
        total_cooperations = int(np.sum(history.opponent_actions))
        if total_actions == 0:
            return 0.5
        cooperation_rate = total_cooperations / total_actions
        return cooperation_rate

class Strategy_COLLECTIVE_448(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual resilience with collective sustainability by:
    - Cooperating when stock health is strong and defection rates are low
    - Adapting thresholds dynamically across game phases
    - Defecting in final round and during resource collapse
    - Using proportional punishment with quick forgiveness
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        previous_stock = None
        if history is not None and round_number > 0:
            pass
        recent_defections = 0
        rounds_to_check = min(3, round_number)
        if history is not None and rounds_to_check > 0:
            for i in range(round_number - rounds_to_check, round_number):
                if i >= 0:
                    defections_in_round = self.n_players - 1 - np.sum(history.opponent_actions[i, :])
                    recent_defections += defections_in_round
        total_opponent_actions_observed = rounds_to_check * (self.n_players - 1)
        if total_opponent_actions_observed > 0:
            defection_rate = recent_defections / total_opponent_actions_observed
        else:
            defection_rate = 0.0
        if round_number <= self.n_rounds / 3:
            stock_threshold = 0.75
        elif round_number <= 2 * self.n_rounds / 3:
            stock_threshold = 0.6
        else:
            stock_threshold = 0.7
        if round_number >= self.n_rounds - 1:
            defection_tolerance = 0.25
        else:
            defection_tolerance = 0.4
        critical_stock_threshold = 2 * self.n_players
        if current_stock < critical_stock_threshold:
            if health_ratio < 0.9:
                return Action.D
        if health_ratio >= stock_threshold and defection_rate <= defection_tolerance:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_449(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A dynamic strategy for common pool resource games
    that prioritizes stock sustainability while adapting to defection threats.
    
    Core approach:
    1. Early cooperation (rounds 1-r/3) to signal commitment
    2. Stock-based conservation (C when stock < 50% or in 40-70% growth zone)
    3. Defection risk assessment based on opponent behavior
    4. Last-round salvage phase to protect remaining value
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock_s = state.current_stock
        capacity_c = self.capacity
        n = self.n_players
        r = self.n_rounds
        if stock_s < 0.5 * capacity_c:
            return Action.C
        if 0.4 * capacity_c <= stock_s <= 0.7 * capacity_c:
            return Action.C
        if round_t <= r / 3:
            return Action.C
        if round_t > r - 2 and stock_s > 0.2 * capacity_c:
            return Action.C
        if round_t == 0:
            return Action.C
        previous_defection_rate = self._calculate_defection_rate(history, round_t - 1, n)
        if previous_defection_rate > 0.6:
            return Action.D
        if previous_defection_rate <= 0.3:
            return Action.C
        if 0.3 < previous_defection_rate <= 0.6:
            return Action.D
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, round_idx: int, n: int) -> float:
        """
        Calculate the proportion of opponents who defected in a given round.
        True/1 = Cooperate, False/0 = Defect
        Defection rate = number of defectors / total opponents
        """
        if round_idx < 0 or round_idx >= len(history.opponent_actions):
            return 0.0
        round_actions = history.opponent_actions[round_idx, :]
        num_defectors = np.sum(round_actions == False)
        if n == 0:
            return 0.0
        defection_rate = float(num_defectors) / float(n)
        return defection_rate

class Strategy_COLLECTIVE_450(BaseStrategy):
    """
    Adaptive Stewardship with Tit-for-Tat Feedback strategy.
    
    Treats the common pool as a shared resource requiring active stewardship.
    Uses reciprocal logic with stock-health awareness and terminal generosity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        recent_defection_rate = self._calculate_recent_defection_rate(history, round_number)
        defection_threshold = 0.35 - 0.25 * (1.0 - stock_ratio)
        if stock_ratio < 0.2:
            return Action.C
        if stock_ratio < 0.4:
            if recent_defection_rate > defection_threshold:
                return Action.D
            else:
                return Action.C
        if recent_defection_rate > defection_threshold:
            return Action.D
        else:
            return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the defection rate of opponents in the last k rounds.
        k = min(3, current_round) to handle early game.
        
        Returns a value in [0, 1] representing the proportion of opponent actions that were defections.
        """
        if history is None or current_round == 0:
            return 0.0
        k = min(3, current_round)
        start_round = current_round - k
        recent_opponent_actions = history.opponent_actions[start_round:current_round, :]
        cooperation_rate = np.mean(recent_opponent_actions)
        defection_rate = 1.0 - cooperation_rate
        return float(defection_rate)

class Strategy_COLLECTIVE_451(BaseStrategy):
    """
    Adaptive Sustainability with Escalating Accountability.
    
    Balances collective welfare with individual security through conditional cooperation.
    Uses observable history to classify opponents and scales accountability dynamically.
    Includes crisis mode to force cooperation when resource is near collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        round_num = state.round_number
        defection_rates = self._compute_opponent_defection_rates(history)
        average_defection_rate = self._compute_average_defection_rate(defection_rates)
        critical_threshold = self.capacity * 0.2
        moderate_threshold = self.capacity * 0.4
        final_threshold = self.capacity * 0.3
        if current_stock <= critical_threshold:
            return Action.C
        if current_stock <= moderate_threshold:
            base_action = self._classify_and_decide(defection_rates)
            if base_action == Action.D and random.random() < 0.4:
                return Action.C
            return base_action
        if round_num == self.n_rounds - 1:
            if current_stock <= final_threshold:
                return Action.C
            elif average_defection_rate <= 0.4:
                return Action.C
            else:
                return Action.D
        if round_num > 0:
            prev_stock = self._get_previous_stock(history, round_num)
            if prev_stock > 0 and current_stock > prev_stock * 1.1:
                return Action.C
        if round_num > 0:
            prev_stock = self._get_previous_stock(history, round_num)
            if prev_stock > 0 and current_stock < prev_stock * 0.85:
                defecting_count = sum((1 for rate in defection_rates.values() if rate > 0.5))
                if defecting_count > self.n_players * 0.5:
                    coop_probability = 1.0 - average_defection_rate
                    if random.random() < coop_probability:
                        return Action.C
        return self._classify_and_decide(defection_rates)

    def _compute_opponent_defection_rates(self, history: PlayerHistory) -> dict:
        """Compute defection rate for each opponent."""
        defection_rates = {}
        rounds_played = history.opponent_actions.shape[0]
        if rounds_played == 0:
            return defection_rates
        for opponent_idx in range(self.n_players - 1):
            defections = sum((1 for action in history.opponent_actions[:, opponent_idx] if not action))
            defection_rates[opponent_idx] = defections / rounds_played
        return defection_rates

    def _compute_average_defection_rate(self, defection_rates: dict) -> float:
        """Compute average defection rate across all opponents."""
        if not defection_rates:
            return 0.0
        return sum(defection_rates.values()) / len(defection_rates)

    def _classify_and_decide(self, defection_rates: dict) -> Action:
        """Classify opponents and determine action based on defection rates."""
        if all((rate <= 0.25 for rate in defection_rates.values())):
            return Action.C
        if all((rate > 0.6 for rate in defection_rates.values())):
            return Action.D
        for rate in defection_rates.values():
            if rate > 0.6:
                return Action.D
            if rate > 0.25:
                return Action.D
        return Action.C

    def _get_previous_stock(self, history: PlayerHistory, current_round: int) -> float:
        """Estimate previous stock from game dynamics."""
        if current_round <= 1:
            return self.capacity
        prev_round_idx = current_round - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_prev_actions = history.opponent_actions[prev_round_idx, :]
        cooperators = sum((1 for action in opponent_actions_prev if action)) + (1 if my_prev_action else 0)
        defectors = self.n_players - cooperators
        return self.capacity * 0.5

    def _get_previous_stock(self, history: PlayerHistory, current_round: int) -> float:
        """Estimate previous stock from payoff history."""
        if current_round <= 1:
            return self.capacity
        prev_round_idx = current_round - 1
        my_prev_payoff = history.my_payoffs[prev_round_idx]
        estimated_stock = min(my_prev_payoff * 2 * self.n_players * 1.5, self.capacity)
        return max(estimated_stock, 0.0)

class Strategy_COLLECTIVE_452(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Reciprocity.
    
    Preserves common pool resources through cooperation when stock is healthy
    and opponents are cooperative, while defending against exploitation through
    defection when conditions deteriorate. Adapts to empirical defection rates
    and stock levels using a moving average to assess trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = self.capacity * 0.4
        self.tolerance_threshold = 0.5
        self.critical_threshold = self.capacity * 0.05
        self.observation_window = max(3, self.n_rounds // 4)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.critical_threshold:
            return Action.D
        defection_ratio = self._calculate_defection_ratio(history, current_round)
        stock_healthy = current_stock > self.threshold
        opponents_cooperative = defection_ratio <= self.tolerance_threshold
        if stock_healthy and opponents_cooperative:
            return Action.C
        elif stock_healthy and (not opponents_cooperative):
            return Action.D
        else:
            return Action.D

    def _calculate_defection_ratio(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the recent defection ratio using a moving average window.
        Returns ratio in [0, 1] where 1 means all opponents defected.
        """
        window_start = max(0, current_round - self.observation_window)
        window_end = current_round
        window_actions = history.opponent_actions[window_start:window_end, :]
        total_opponent_actions = window_actions.size
        if total_opponent_actions == 0:
            return 0.0
        defection_count = np.sum(~window_actions)
        defection_ratio = float(defection_count) / float(total_opponent_actions)
        return defection_ratio

class Strategy_COLLECTIVE_453(BaseStrategy):
    """
    Adaptive Stock-Preserving Cooperation (ASPC): A collective strategy for common pool
    resource games that balances individual payoff maximization with resource sustainability.
    
    Core mechanisms:
    1. Stock-conditional cooperation: Cooperate when stock is healthy (>25% capacity)
    2. Adaptive defection response: Increase defection if >40% of players defect
    3. Round-position adjustments: Always cooperate in round 1, apply standard rules in final round
    4. Edge case handling: Defect when stock is critically depleted, stabilize on unanimous cooperation
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = game_description.capacity * 0.25
        self.defection_tolerance = 0.4
        self.stock_depletion_threshold = 0.01 * game_description.capacity
        self.prev_defection_rate = 0.0
        self.unanimous_coop_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if round_num == 0:
            return Action.C
        if current_stock < self.stock_depletion_threshold:
            return Action.D
        if round_num == total_rounds - 1:
            if current_stock > self.critical_threshold:
                return Action.C
            else:
                return Action.D
        observed_defection_rate = self._calculate_defection_rate(history, round_num - 1, n_players)
        if observed_defection_rate == 0.0:
            self.unanimous_coop_rounds += 1
        else:
            self.unanimous_coop_rounds = 0
        if self.unanimous_coop_rounds >= 2 and current_stock > self.critical_threshold:
            return Action.C
        stock_healthy = current_stock > self.critical_threshold
        if not stock_healthy:
            return Action.D
        if observed_defection_rate > self.defection_tolerance:
            if random.random() < 0.2:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, round_index: int, n_players: int) -> float:
        """
        Calculate the observed defection rate in a specific round.
        True = Cooperate (Action.C), False = Defect (Action.D)
        So defection count = number of False values
        """
        if round_index < 0 or round_index >= len(history.opponent_actions):
            return 0.0
        actions_in_round = history.opponent_actions[round_index, :]
        defectors = np.sum(~actions_in_round)
        defection_rate = defectors / n_players if n_players > 0 else 0.0
        return float(defection_rate)

class Strategy_COLLECTIVE_454(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual security with collective sustainability through adaptive,
    information-driven decision-making. Conditions behavior on stock health and
    opponent responsiveness to avoid tragedy of the commons while maintaining
    individual payoff security.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.upper_threshold = 0.75 * self.capacity
        self.lower_threshold = 0.25 * self.capacity
        self.critical_threshold = 0.1 * self.capacity
        self.last_stock = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock_level = state.current_stock
        round_number = state.round_number
        if stock_level < self.critical_threshold:
            return Action.D
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            if stock_level >= self.lower_threshold:
                return Action.C
            else:
                return Action.D
        if stock_level >= self.upper_threshold:
            self.last_stock = stock_level
            return Action.C
        if stock_level < self.lower_threshold:
            self.last_stock = stock_level
            return Action.D
        if history is not None and len(history.opponent_actions) > 0:
            total_cooperations = float(np.sum(history.opponent_actions))
            total_observations = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
            if total_observations > 0:
                opponent_coop_rate = total_cooperations / total_observations
                if opponent_coop_rate >= 0.6:
                    self.last_stock = stock_level
                    return Action.C
                else:
                    self.last_stock = stock_level
                    return Action.D
        self.last_stock = stock_level
        return Action.C

class Strategy_COLLECTIVE_455(BaseStrategy):
    """
    Adaptive Stock-Aware Cooperation Strategy (ASAC)
    
    Balances conditional cooperation with stock health monitoring.
    Cooperates when stock is healthy or critically low, defects when
    majority of players are defecting and stock can sustain it.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.capacity
        if stock_ratio < 0.05:
            return Action.C
        lookback_rounds = min(3, state.round_number)
        recent_defection_rate = self._calculate_recent_defection_rate(history, lookback_rounds)
        if stock_ratio < 0.15:
            return Action.C
        if stock_ratio < 0.3 and recent_defection_rate > 0.5:
            return Action.D
        if stock_ratio < 0.3:
            return Action.C
        if recent_defection_rate >= 0.75:
            return Action.D
        if recent_defection_rate >= 0.5:
            return Action.D
        if recent_defection_rate >= 0.25:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            if stock_ratio >= 0.15 and recent_defection_rate < 0.5:
                return Action.D
        return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory, lookback_rounds: int) -> float:
        """
        Calculate the defection rate among opponents in the last lookback_rounds.
        
        True = Cooperate, False = Defect
        """
        if lookback_rounds == 0:
            return 0.0
        start_idx = max(0, history.opponent_actions.shape[0] - lookback_rounds)
        recent_actions = history.opponent_actions[start_idx:, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        defectors_count = np.sum(recent_actions == 0)
        defection_rate = float(defectors_count) / float(total_actions)
        return defection_rate

class Strategy_COLLECTIVE_456(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy that prioritizes long-term
    stock preservation through health-based cooperation, proportional punishment of defection,
    and graduated escalation rather than permanent retaliation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        if current_round == self.n_rounds - 1:
            return Action.C if stock_health > 0.3 else Action.D
        if stock_health < 0.05:
            return Action.C
        window_size = min(3, current_round)
        if window_size == 0:
            recent_defection_rate = 0.0
        else:
            recent_opponent_actions = history.opponent_actions[-window_size:, :]
            recent_defections = np.sum(~recent_opponent_actions)
            total_possible_defections = self.n_players * window_size
            recent_defection_rate = recent_defections / total_possible_defections if total_possible_defections > 0 else 0.0
        if stock_health >= 0.75:
            return Action.C
        elif stock_health >= 0.5:
            threshold = (self.n_players - 1) / (2 * self.n_players)
            if recent_defection_rate > threshold:
                return Action.D
            else:
                return Action.C
        elif stock_health >= 0.25:
            if recent_defection_rate > 0.3:
                return Action.D
            else:
                return Action.C
        elif recent_defection_rate > 0.2:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_457(BaseStrategy):
    """
    Adaptive Stewardship with Graduated Deterrence: A stock-conditional cooperation strategy
    that maintains sustainable resource levels while remaining robust to defection.
    Balances collective sustainability, individual security, and adaptive responsiveness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if current_stock < self.capacity * 0.2:
            return Action.D
        if current_stock > self.capacity * 0.95:
            return Action.C
        previous_stock = history.my_payoffs[round_number - 1] * self.n_players if round_number > 0 else current_stock
        if round_number > 0 and history is not None:
            if round_number == 1:
                previous_stock = self.capacity
            else:
                previous_stock = self.capacity
        rounds_remaining = self.n_rounds - round_number
        base_threshold = self.capacity * (0.6 + 0.1 * rounds_remaining / self.n_rounds)
        if history is not None:
            opponent_defection_count = np.sum(~history.opponent_actions[:round_number, :])
            opponent_total_actions = round_number * self.n_players
            if opponent_total_actions > 0:
                opponent_defection_rate = opponent_defection_count / opponent_total_actions
            else:
                opponent_defection_rate = 0.0
        else:
            opponent_defection_rate = 0.0
        adaptive_threshold = base_threshold * (0.95 if opponent_defection_rate > 0.7 else 1.0)
        if round_number == self.n_rounds - 1:
            last_round_threshold = self.capacity * 0.55
            if current_stock >= last_round_threshold:
                return Action.C
            else:
                return Action.D
        cooperation_bias = 0.0
        if round_number > 0 and previous_stock > 0:
            trajectory = (current_stock - previous_stock) / previous_stock
            if trajectory > 0.05:
                cooperation_bias = 0.15
            elif trajectory < -0.1:
                cooperation_bias = -0.15
        if current_stock > adaptive_threshold:
            return Action.C
        if adaptive_threshold > 0:
            deficit_ratio = (adaptive_threshold - current_stock) / adaptive_threshold
        else:
            deficit_ratio = 0.0
        deficit_ratio = max(0.0, min(1.0, deficit_ratio))
        if deficit_ratio < 0.1:
            return Action.C
        elif deficit_ratio < 0.3:
            coop_prob = max(0.0, min(1.0, 0.8 - deficit_ratio + cooperation_bias))
            return Action.C if random.random() < coop_prob else Action.D
        elif deficit_ratio < 0.5:
            coop_prob = max(0.0, min(1.0, 0.4 + cooperation_bias))
            return Action.C if random.random() < coop_prob else Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_458(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Games.
    
    Prioritizes sustainable collective welfare by monitoring resource health and adjusting
    behavior to maintain the commons at productive levels, while protecting against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio >= 0.75:
            health_status = 'HEALTHY'
        elif stock_ratio >= 0.4:
            health_status = 'MODERATE'
        elif stock_ratio >= 0.15:
            health_status = 'STRESSED'
        else:
            health_status = 'CRITICAL'
        prev_round_idx = current_round - 1
        defectors_last_round = self.n_players - int(sum(history.opponent_actions[prev_round_idx, :]))
        defection_rate = defectors_last_round / self.n_players if self.n_players > 0 else 0.0
        if defection_rate >= 0.75:
            exploitation_condition = 'HIGH_EXPLOITATION'
        elif defection_rate >= 0.4:
            exploitation_condition = 'MODERATE_EXPLOITATION'
        else:
            exploitation_condition = 'LOW_EXPLOITATION'
        if current_round == self.n_rounds - 1:
            return Action.C
        if health_status in ['CRITICAL', 'STRESSED']:
            return Action.C
        if health_status == 'HEALTHY':
            if defection_rate >= 0.75:
                return Action.D
            else:
                return Action.C
        if health_status == 'MODERATE':
            if defection_rate >= 0.75:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_COLLECTIVE_459(BaseStrategy):
    """
    Collective Pool Stewardship Strategy
    
    Treats the common pool as a shared ecosystem requiring active management.
    Uses conditional cooperation based on stock health and estimated cooperation rates,
    with adaptive escalation/de-escalation via rolling averages.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.rolling_coop_rates = []

    def _infer_defectors_from_payoffs(self, payoffs: NDArray[np.float64], stock: float) -> int:
        """
        Infer the number of defectors in the previous round by analyzing payoffs.
        
        A defector gets payoff = stock / n
        A cooperator gets payoff = stock / (2n)
        We classify based on which threshold each payoff is closer to.
        """
        defector_payoff_threshold = stock / self.n_players
        cooperator_payoff_threshold = stock / (2 * self.n_players)
        defectors = 0
        for payoff in payoffs:
            if stock == 0:
                defectors += 1
                continue
            dist_to_defect = abs(payoff - defector_payoff_threshold)
            dist_to_coop = abs(payoff - cooperator_payoff_threshold)
            if dist_to_defect < dist_to_coop:
                defectors += 1
        return defectors

    def _estimate_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Estimate cooperation rate from payoff history.
        Returns a value in [0, 1].
        """
        if current_round == 0:
            return 1.0
        opponent_payoffs = history.opponent_payoffs[current_round - 1, :]
        stock_before_round = self._compute_stock_before_round(history, current_round - 1)
        estimated_defectors = self._infer_defectors_from_payoffs(opponent_payoffs, stock_before_round)
        cooperation_rate = (self.n_players - estimated_defectors) / self.n_players
        return cooperation_rate

    def _compute_stock_before_round(self, history: PlayerHistory, round_idx: int) -> float:
        """
        Reconstruct the stock level at the start of a given round.
        """
        if round_idx == 0:
            return self.capacity
        stock = self.capacity
        for t in range(round_idx):
            my_action = history.my_actions[t]
            opponent_actions = history.opponent_actions[t, :]
            num_defectors = int(not my_action) + int(np.sum(~opponent_actions))
            num_cooperators = self.n_players - num_defectors
            consumption = num_defectors * stock / self.n_players + num_cooperators * stock / (2 * self.n_players)
            consumption = min(consumption, stock)
            stock_remaining = max(0, stock - consumption)
            growth = 2 * stock_remaining * (1 - stock_remaining / self.capacity) if self.capacity > 0 else 0
            stock = min(stock_remaining + growth, self.capacity)
        return stock

    def _get_rolling_cooperation_rate(self) -> float:
        """
        Return the average cooperation rate over the last 3 rounds (or fewer if history is short).
        """
        if not self.rolling_coop_rates:
            return 1.0
        window = self.rolling_coop_rates[-3:]
        return float(np.mean(window))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decide action based on stock health, cooperation rate, and round number.
        """
        round_t = state.round_number
        stock_t = state.current_stock
        capacity = self.capacity
        n = self.n_players
        r = self.n_rounds
        if round_t == 0:
            return Action.C
        current_coop_rate = self._estimate_cooperation_rate(history, round_t)
        self.rolling_coop_rates.append(current_coop_rate)
        rolling_coop = self._get_rolling_cooperation_rate()
        health = stock_t / capacity if capacity > 0 else 1.0
        if round_t == r - 1:
            if health >= 0.5:
                return Action.C
            else:
                return Action.D
        if health >= 0.4 and rolling_coop >= 2 / 3:
            return Action.C
        elif rolling_coop <= 0.4 or health < 0.2:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_460(BaseStrategy):
    """
    Sustainable Threshold with Adaptive Defection Control (STADC)
    
    Prioritizes long-term collective sustainability while protecting against exploitation.
    Uses stock level monitoring, depletion trend analysis, and inferred defection rates
    to adapt between cooperation (default) and defection (when necessary).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.danger_threshold = self.capacity * 0.25
        self.sustainability_threshold = self.capacity * 0.5
        self.stock_history = []
        self.defection_rate_estimate = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == 1:
            self.stock_history = [self.capacity]
        else:
            self.stock_history.append(history.my_payoffs[current_round - 1] * self.n_players + np.sum(history.opponent_payoffs[current_round - 1, :]))
        depletion_trend = self._calculate_depletion_trend()
        self._update_defection_rate_estimate(current_stock, current_round)
        if current_stock <= self.danger_threshold:
            return Action.C
        if depletion_trend:
            return Action.C
        if current_round == self.n_rounds - 1:
            avg_recent = np.mean(self.stock_history[-3:]) if len(self.stock_history) >= 1 else self.capacity
            if avg_recent > self.sustainability_threshold:
                return Action.C
        if current_stock >= self.capacity * 0.95:
            if self.defection_rate_estimate > 0.7:
                if random.random() < min(self.defection_rate_estimate, 0.8):
                    return Action.D
            return Action.C
        if len(self.stock_history) >= 2:
            stock_drop_rate = (self.stock_history[-2] - current_stock) / max(self.stock_history[-2], 1e-06)
            if stock_drop_rate > 0.3:
                if current_stock > self.danger_threshold:
                    if random.random() < 0.6:
                        return Action.D
        defect_probability = min(self.defection_rate_estimate, 0.8)
        if random.random() < defect_probability:
            return Action.D
        else:
            return Action.C

    def _calculate_depletion_trend(self) -> bool:
        """
        Determine if system is in decline by checking average recent stock.
        Returns True if system shows unsustainable extraction pattern.
        """
        if len(self.stock_history) < 2:
            return False
        recent_history = self.stock_history[max(0, len(self.stock_history) - 3):]
        avg_recent = np.mean(recent_history)
        return avg_recent < self.sustainability_threshold

    def _update_defection_rate_estimate(self, current_stock: float, current_round: int) -> None:
        """
        Infer opponent defection rate from stock dynamics.
        Compare expected stock (with baseline consumption) to actual stock.
        """
        if current_round <= 1:
            return
        prev_stock = self.stock_history[-1] if len(self.stock_history) >= 1 else self.capacity
        baseline_total_consumption = prev_stock / 2.0
        expected_stock_after_consumption = prev_stock - baseline_total_consumption
        if expected_stock_after_consumption > 0:
            growth = 2 * expected_stock_after_consumption * (1 - expected_stock_after_consumption / self.capacity)
            expected_stock = min(expected_stock_after_consumption + growth, self.capacity)
        else:
            expected_stock = 0
        actual_shortfall = max(0, expected_stock - current_stock)
        expected_denominator = max(expected_stock, 1e-06)
        observed_defection_rate = min(actual_shortfall / expected_denominator, 1.0)
        self.defection_rate_estimate = 0.6 * self.defection_rate_estimate + 0.4 * observed_defection_rate

class Strategy_COLLECTIVE_461(BaseStrategy):
    """
    Adaptive Stock-Preserving Cooperation (ASPC): A collective strategy for common pool resource games.
    
    Prioritizes resource sustainability through a three-layer decision framework:
    1. Preserve stock above critical thresholds (emergency mode)
    2. Respond proportionally to observed defection rates
    3. Default to cooperation to signal sustainability viability
    
    The strategy tracks stock health, depletion rates, and opponent defection patterns
    to balance collective welfare with protection against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        round_num = state.round_number
        shi = current_stock / self.capacity if self.capacity > 0 else 0.0
        dr = 0.0
        if round_num > 0 and len(history.my_payoffs) > 0:
            my_last_action_was_c = history.my_actions[round_num - 1]
            if my_last_action_was_c:
                stock_prev = history.my_payoffs[round_num - 1] * (2 * self.n_players)
            else:
                stock_prev = history.my_payoffs[round_num - 1] * self.n_players
            if stock_prev > 0:
                dr = (stock_prev - current_stock) / stock_prev
                dr = max(0.0, min(1.0, dr))
        odr = 0.0
        if round_num > 0 and len(history.opponent_actions) > 0:
            defectors_last_round = self.n_players - np.sum(history.opponent_actions[round_num - 1])
            odr = defectors_last_round / self.n_players if self.n_players > 0 else 0.0
        cst = self.capacity / 4.0
        extreme_collapse_threshold = self.capacity / 8.0
        if current_stock < extreme_collapse_threshold:
            return Action.C
        if shi < 0.2:
            return Action.C
        if shi < 0.35 and dr > 0.4:
            return Action.C
        if odr > 0.6:
            defect_probability = min(0.9, odr)
            if random.random() < defect_probability:
                return Action.D
            else:
                return Action.C
        if odr > 0.3 and odr <= 0.6:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_462(BaseStrategy):
    """
    Adaptive Collective Resource Stewardship Strategy for Common Pool Resource Game.
    
    Employs conditional resource preservation coupled with adaptive defection deterrence.
    Cooperates when stock is healthy, defects when stock is critically depleted or
    opponents are systematically exploitative.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        h = current_stock / self.capacity if self.capacity > 0 else 0.0
        if round_number == 0:
            return Action.C
        defection_rate = self._calculate_defection_rate(history, round_number)
        if round_number == self.n_rounds - 1:
            if h >= 0.6:
                return Action.C
            else:
                return Action.D
        if h < 0.05:
            return Action.D
        if h >= 0.6:
            return Action.C
        if h >= 0.2:
            if defection_rate > 0.66:
                return Action.D
            else:
                return Action.C
        if h >= 0.05:
            if defection_rate > 0.33:
                return Action.D
            elif random.random() < 0.7:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the defection rate of opponents over recent rounds.
        
        Returns the proportion of defections among all opponents in the recent window.
        """
        if round_number <= 1:
            return 0.0
        recent_rounds = min(5, round_number)
        recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
        total_actions = recent_opponent_actions.size
        cooperations = np.sum(recent_opponent_actions)
        defections = total_actions - cooperations
        defection_rate = defections / total_actions if total_actions > 0 else 0.0
        return defection_rate

class Strategy_COLLECTIVE_463(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy balancing sustainability,
    opportunistic defense, and graceful degradation in common pool resource games.
    
    Core mechanism: Cooperation when stock is abundant, adaptive defection as stock depletes,
    with dynamic threshold adjustment based on observed opponent defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high_base = 1.5 * self.capacity
        self.threshold_critical_base = 0.15 * self.capacity

    def _calculate_defection_rate(self, history: PlayerHistory) -> float:
        """Calculate observed defection rate across all opponents in all previous rounds."""
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        rounds_played = len(history.opponent_actions)
        total_opponent_actions = rounds_played * self.n_players
        cooperations = np.sum(history.opponent_actions)
        defections = total_opponent_actions - cooperations
        if total_opponent_actions == 0:
            return 0.0
        return float(defections) / float(total_opponent_actions)

    def _get_adaptive_thresholds(self, defection_rate: float) -> tuple[float, float]:
        """Adjust thresholds based on observed defection rate."""
        if defection_rate > 0.7:
            threshold_high = 1.2 * self.capacity
            threshold_critical = 0.1 * self.capacity
        elif defection_rate < 0.2:
            threshold_high = 2.0 * self.capacity
            threshold_critical = 0.2 * self.capacity
        else:
            threshold_high = self.threshold_high_base
            threshold_critical = self.threshold_critical_base
        return (threshold_high, threshold_critical)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            critical_threshold = 0.15 * self.capacity
            if stock < 0.5 * critical_threshold:
                return Action.C
            return Action.D
        if stock <= 0:
            return Action.C
        defection_rate = self._calculate_defection_rate(history)
        threshold_high, threshold_critical = self._get_adaptive_thresholds(defection_rate)
        if stock > threshold_high:
            return Action.C
        elif stock > threshold_critical:
            threshold_range = threshold_high - threshold_critical
            if threshold_range <= 0:
                return Action.C
            p_adapt = (stock - threshold_critical) / threshold_range
            if random.random() < p_adapt:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_464(BaseStrategy):
    """
    Adaptive Conservation with Conditional Defection strategy for Common Pool Resource Game.
    
    This strategy balances collective welfare with individual competitiveness by:
    1. Cooperating when stock is healthy (≥75% capacity)
    2. Defecting when stock is depleted (<15% capacity)
    3. Conditionally responding to opponent behavior in the uncertainty zone
    4. Always defecting in the final round (endgame extraction)
    5. Always cooperating in the first round (trust establishment)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.sustainability_threshold = 0.75 * game_description.capacity
        self.depletion_threshold = 0.15 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock >= self.sustainability_threshold:
            return Action.C
        if current_stock < self.depletion_threshold:
            return Action.D
        opponent_defection_rate = self._calculate_opponent_defection_rate(history, state.round_number)
        if opponent_defection_rate >= 0.5:
            return Action.D
        else:
            return Action.C

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the defection rate of opponents based on the last 3 rounds (or fewer if less history available).
        
        Returns:
            float: Proportion of opponent defections (0.0 to 1.0)
        """
        lookback_rounds = min(3, current_round)
        if lookback_rounds == 0:
            return 0.0
        start_idx = current_round - lookback_rounds
        recent_opponent_actions = history.opponent_actions[start_idx:current_round, :]
        total_actions = recent_opponent_actions.size
        defection_count = np.sum(~recent_opponent_actions)
        if total_actions == 0:
            return 0.0
        defection_rate = float(defection_count) / float(total_actions)
        return defection_rate

class Strategy_COLLECTIVE_465(BaseStrategy):
    """
    Collective Sustainability Strategy (CSS) for Common Pool Resource Games.
    
    Prioritizes long-term collective resource sustainability through stock-responsive
    cooperation. Cooperates when stock is healthy (≥50% capacity), defects when depleted
    (<40% capacity) or in final round. Adaptive and robust against diverse opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        rounds_remaining = self.n_rounds - round_number
        if rounds_remaining == 1:
            return Action.D
        if stock < 0.3 * self.capacity:
            return Action.D
        if stock < 0.4 * self.capacity:
            return Action.D
        time_factor = min(rounds_remaining / self.n_rounds, 1.0)
        sustainability_threshold = self.capacity * (0.5 + 0.2 * time_factor)
        if stock >= sustainability_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_466(BaseStrategy):
    """
    Collective Adaptive Resource Stewardship (CARS) Strategy
    
    Prioritizes sustainable collective flourishing by:
    1. Assessing stock health (Abundant/Healthy/Stressed/Critical)
    2. Detecting group exploitation patterns (Fully Cooperative to Fully Defecting)
    3. Selecting actions from a decision matrix balancing resource state and group behavior
    4. Applying look-ahead modifiers for early/late game phases
    5. Handling edge cases like stock collapse and final round dynamics
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        resource_state = self._assess_resource_state(stock_ratio)
        if current_round == 0:
            return Action.C
        if current_stock < 2 * self.n_players:
            return Action.D
        group_behavior = self._detect_group_behavior(history, current_round)
        action = self._lookup_decision_matrix(resource_state, group_behavior)
        if current_round == self.n_rounds - 1:
            if stock_ratio < 0.3:
                action = Action.D
            else:
                action = Action.C
        return action

    def _assess_resource_state(self, stock_ratio: float) -> str:
        """Evaluate resource pool sustainability based on stock health ratio."""
        if stock_ratio >= 0.65:
            return 'Abundant'
        elif stock_ratio >= 0.4:
            return 'Healthy'
        elif stock_ratio >= 0.2:
            return 'Stressed'
        else:
            return 'Critical'

    def _detect_group_behavior(self, history: PlayerHistory, current_round: int) -> str:
        """
        Monitor defection rates from the previous round.
        Returns group behavior classification.
        """
        last_round_idx = current_round - 1
        last_round_opponent_actions = history.opponent_actions[last_round_idx, :]
        defection_count = np.sum(~last_round_opponent_actions).item()
        my_last_action = history.my_actions[last_round_idx]
        if not my_last_action:
            defection_count += 1
        total_agents = self.n_players
        defection_rate = defection_count / total_agents
        if defection_rate == 0:
            return 'Fully Cooperative'
        elif defection_rate <= 0.25:
            return 'Mostly Cooperative'
        elif defection_rate <= 0.5:
            return 'Mixed'
        elif defection_rate <= 0.75:
            return 'Mostly Defecting'
        else:
            return 'Fully Defecting'

    def _lookup_decision_matrix(self, resource_state: str, group_behavior: str) -> Action:
        """
        Decision matrix mapping (resource_state, group_behavior) to actions.
        
        Returns Action.C (True) or Action.D (False)
        """
        matrix = {'Abundant': {'Fully Cooperative': Action.C, 'Mostly Cooperative': Action.C, 'Mixed': Action.C, 'Mostly Defecting': Action.D, 'Fully Defecting': Action.D}, 'Healthy': {'Fully Cooperative': Action.C, 'Mostly Cooperative': Action.C, 'Mixed': Action.C, 'Mostly Defecting': Action.D, 'Fully Defecting': Action.D}, 'Stressed': {'Fully Cooperative': Action.C, 'Mostly Cooperative': Action.C, 'Mixed': Action.D, 'Mostly Defecting': Action.D, 'Fully Defecting': Action.D}, 'Critical': {'Fully Cooperative': Action.D, 'Mostly Cooperative': Action.D, 'Mixed': Action.D, 'Mostly Defecting': Action.D, 'Fully Defecting': Action.D}}
        return matrix.get(resource_state, {}).get(group_behavior, Action.D)

class Strategy_COLLECTIVE_467(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy balancing sustainability
    and adaptive reciprocity in common pool resource games.
    
    Core logic:
    - Round 1: Always cooperate (fair opening, gather information)
    - Final round: Always defect (no future consequences)
    - Stock-dependent cooperation with defection ratio tracking in middle band
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity * (1.0 / self.n_players + 0.1)
        self.healthy_threshold = self.capacity * 0.6
        self.tolerance = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.critical_threshold:
            return Action.D
        if current_stock >= self.healthy_threshold:
            return Action.C
        window_size = min(3, rounds_remaining)
        if window_size <= 0:
            return Action.C
        defection_count = self._count_recent_defections(history, current_round, window_size, current_stock)
        defection_ratio = defection_count / window_size
        if defection_ratio > self.tolerance:
            return Action.D
        else:
            return Action.C

    def _count_recent_defections(self, history: PlayerHistory, current_round: int, window_size: int, current_stock: float) -> int:
        """
        Count rounds in the recent window where total consumption suggests
        systematic defection by others.
        """
        defection_count = 0
        start_round = max(0, current_round - window_size)
        for round_idx in range(start_round, current_round):
            if round_idx < 0 or round_idx >= len(history.opponent_actions):
                continue
            opponent_cooperations = np.sum(history.opponent_actions[round_idx, :])
            opponent_defections = self.n_players - 1 - opponent_cooperations
            opponent_defection_ratio = opponent_defections / max(1, self.n_players - 1)
            if opponent_defection_ratio > 0.5:
                defection_count += 1
        return defection_count

class Strategy_COLLECTIVE_468(BaseStrategy):
    """
    Adaptive Stock Stewardship: A threshold-based conditional cooperation strategy
    that prioritizes sustainable collective welfare while protecting against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if stock <= self.capacity * 0.15:
            return Action.D
        defection_rate = self._calculate_defection_rate(history, round_num)
        if defection_rate <= 0.3:
            threat_level = 'LOW'
        elif defection_rate <= 0.6:
            threat_level = 'MEDIUM'
        else:
            threat_level = 'HIGH'
        rounds_left = self.n_rounds - round_num
        if rounds_left == 1:
            if stock > self.capacity * 0.4:
                return Action.C
            else:
                return Action.D
        if rounds_left <= 3:
            defection_threshold = 0.5
        else:
            defection_threshold = 0.6
        if stock >= self.capacity * 0.95:
            return Action.C
        if stock > self.capacity * 0.5:
            if threat_level == 'LOW':
                return Action.C
            else:
                return Action.D
        elif threat_level == 'LOW':
            return Action.C
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the observed defection rate from all previous rounds.
        Defection is False/0, Cooperation is True/1.
        """
        if round_num == 0:
            return 0.0
        total_opponent_actions = history.opponent_actions[:round_num, :]
        defection_count = np.sum(~total_opponent_actions)
        total_actions = round_num * self.n_players
        if total_actions == 0:
            return 0.0
        defection_rate = float(defection_count) / float(total_actions)
        return defection_rate

class Strategy_COLLECTIVE_469(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS): Balances individual security with collective sustainability
    through stock-conditional reciprocity, adapting to observed cooperation patterns while maintaining
    long-term resource viability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.consecutive_all_defect_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        threshold_high = 0.75 * self.capacity
        threshold_low = 0.25 * self.capacity
        critical_threshold = 0.15 * self.capacity
        if stock < critical_threshold:
            return Action.C
        if round_num == 0:
            self.consecutive_all_defect_count = 0
            return Action.C
        opponent_actions_prev = history.opponent_actions[round_num - 1, :]
        cooperation_rate_prev = float(np.sum(opponent_actions_prev)) / self.n_players
        if cooperation_rate_prev == 0:
            self.consecutive_all_defect_count += 1
        else:
            self.consecutive_all_defect_count = 0
        if stock > threshold_high:
            return Action.C
        if stock < threshold_low:
            return Action.C
        if round_num > 0.9 * self.n_rounds:
            threshold_high = 0.65 * self.capacity
            if stock > threshold_high:
                return Action.C
        if round_num == self.n_rounds - 1:
            if stock > threshold_high:
                return Action.C
            elif stock >= threshold_low:
                return Action.D
            else:
                return Action.C
        if self.consecutive_all_defect_count >= 2 and stock < 0.4 * self.capacity:
            return Action.C
        cr_current = cooperation_rate_prev
        if round_num >= 2:
            opponent_actions_prev_prev = history.opponent_actions[round_num - 2, :]
            cooperation_rate_prev_prev = float(np.sum(opponent_actions_prev_prev)) / self.n_players
            cr_current = (cooperation_rate_prev + cooperation_rate_prev_prev) / 2.0
        if cr_current >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_470(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Reciprocity.
    
    Balances individual and collective interests by:
    1. Conditioning cooperation on stock health
    2. Adjusting based on observed cooperation from others
    3. Defecting in final round and at critical depletion
    4. Detecting rapid depletion and responding defensively
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1 and stock > 0:
            return Action.D
        coop_prob = self._calculate_base_cooperation_probability(stock)
        if round_num > 0 and stock >= 0.3 * self.capacity:
            opponent_coop_rate = self._calculate_opponent_cooperation_rate(history, round_num)
            coop_prob = self._adjust_for_reciprocity(coop_prob, opponent_coop_rate, stock)
        if round_num > 0 and stock < 0.5 * self.capacity:
            stock_drop = self._calculate_stock_drop(history, round_num)
            if stock_drop > 0.3 * self.capacity:
                coop_prob = max(0.0, coop_prob - 0.1)
        return Action.C if random.random() < coop_prob else Action.D

    def _calculate_base_cooperation_probability(self, stock: float) -> float:
        """
        Primary rule: Stock-conditional cooperation.
        """
        capacity_threshold_high = 0.75 * self.capacity
        capacity_threshold_low = 0.3 * self.capacity
        if stock >= capacity_threshold_high:
            return 1.0
        elif stock >= capacity_threshold_low:
            normalized = (stock / self.capacity - 0.3) / 0.45
            return max(0.0, min(1.0, normalized))
        else:
            return 0.0

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate cooperation rate of opponents in last 3 rounds.
        """
        lookback = min(3, round_num)
        if lookback == 0:
            return 0.5
        start_idx = round_num - lookback
        opponent_cooperations = 0
        total_observations = 0
        for r in range(start_idx, round_num):
            for opponent_idx in range(self.n_players - 1):
                if history.opponent_actions[r, opponent_idx]:
                    opponent_cooperations += 1
                total_observations += 1
        if total_observations == 0:
            return 0.5
        return opponent_cooperations / total_observations

    def _adjust_for_reciprocity(self, coop_prob: float, opponent_coop_rate: float, stock: float) -> float:
        """
        Secondary rule: Reciprocal adjustment based on observed cooperation.
        """
        capacity_threshold_mid = 0.5 * self.capacity
        if stock >= capacity_threshold_mid:
            if opponent_coop_rate < 0.4:
                coop_prob = max(0.0, coop_prob - 0.2)
        elif opponent_coop_rate > 0.6:
            coop_prob = min(1.0, coop_prob + 0.15)
        return max(0.0, min(1.0, coop_prob))

    def _calculate_stock_drop(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate stock drop from previous round.
        """
        if round_num == 0:
            return 0.0
        prev_round_idx = round_num - 1
        total_payoff_prev = sum(history.opponent_payoffs[prev_round_idx, :])
        total_payoff_prev += history.my_payoffs[prev_round_idx]
        if round_num >= 2:
            prev_prev_payoff = sum(history.opponent_payoffs[prev_round_idx - 1, :])
            prev_prev_payoff += history.my_payoffs[prev_round_idx - 1]
            estimated_drop = max(0.0, prev_prev_payoff - total_payoff_prev)
            return estimated_drop
        return 0.0

class Strategy_COLLECTIVE_471(BaseStrategy):
    """
    Adaptive Threshold Cooperation (ATC) Strategy for Common Pool Resource Games.
    
    This strategy balances collective resource preservation with individual robustness
    by cooperating when stock health is above a threshold, and defecting when depleted.
    The threshold scales with group size to prevent tragedy of the commons while
    remaining adaptive to actual stock dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        self.stock_history.append(current_stock)
        if current_stock >= 0.95 * self.capacity:
            return Action.C
        if current_stock <= 0.1 * self.capacity:
            return Action.D
        if round_number == 0:
            return Action.C
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        critical_threshold = max(0.25, 1.0 / self.n_players)
        if len(self.stock_history) >= 4:
            recent_declines = 0
            for i in range(len(self.stock_history) - 3, len(self.stock_history)):
                if i > 0 and self.stock_history[i] < self.stock_history[i - 1]:
                    recent_declines += 1
            if recent_declines >= 3:
                if history is not None:
                    last_round_opponent_actions = history.opponent_actions[-1, :]
                    defector_count = np.sum(~last_round_opponent_actions)
                    defection_rate = defector_count / self.n_players
                    if defection_rate > 0.5:
                        return Action.D
        if len(self.stock_history) >= 2:
            prev_stock = self.stock_history[-2]
            if prev_stock > 0:
                growth_rate = (current_stock - prev_stock) / prev_stock
                if growth_rate > 0.3:
                    return Action.C
        if stock_health >= critical_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_472(BaseStrategy):
    """
    Adaptive Commons Stewardship Strategy: Conditional cooperation with adaptive thresholds
    based on stock health and observed defection rates, with special handling for edge cases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        shi = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        if state.current_stock < 2 * self.n_players:
            return Action.D
        current_round = state.round_number
        num_other_players = self.n_players - 1
        total_possible_defections = current_round * num_other_players
        if total_possible_defections == 0:
            dr = 0.0
        else:
            defections_observed = np.sum(~history.opponent_actions[:current_round, :])
            dr = defections_observed / total_possible_defections
        if dr < 0.05:
            shi_adjusted = min(shi + 0.1, 1.0)
            if shi_adjusted >= 0.5:
                return Action.C
        if dr > 0.9:
            return Action.D
        if current_round < 3:
            shi_threshold_bonus = 0.15
        else:
            shi_threshold_bonus = 0.0
        if current_round >= 2:
            stock_prev = state.current_stock
            if current_round >= 1:
                recent_recovery = False
                try:
                    if current_round >= 2:
                        recent_recovery = state.current_stock > self.capacity * 0.7
                except:
                    recent_recovery = False
                if recent_recovery and current_round > 1:
                    return Action.C
        if current_round == self.n_rounds - 1:
            if shi >= 0.5:
                return Action.C
            elif 0.2 <= shi < 0.5:
                if dr <= 0.3:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        if shi >= 0.6 - shi_threshold_bonus:
            if dr <= 0.25:
                return Action.C
            elif dr <= 0.5:
                return Action.C
            else:
                return Action.D
        elif 0.3 - shi_threshold_bonus <= shi < 0.6 - shi_threshold_bonus:
            if dr <= 0.15:
                return Action.C
            elif dr <= 0.4:
                return Action.D
            else:
                return Action.D
        elif dr <= 0.1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_473(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy that prioritizes long-term
    sustainability of the common pool resource while remaining robust to defection.
    
    Core logic: Cooperate when stock health permits, defect only when necessary to
    prevent collapse or when others have severely degraded the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if stock < 0.05 * self.capacity:
            if stock < 0.2 * self.capacity:
                return Action.D
        coop_rate = self._calculate_cooperation_rate(history, round_num)
        if coop_rate >= 0.999:
            return Action.C
        if coop_rate < 0.5:
            if self.punishment_rounds_remaining <= 0:
                self.punishment_rounds_remaining = 2
            else:
                self.punishment_rounds_remaining -= 1
            return Action.D
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            return Action.D
        stock_threshold = self._compute_stock_threshold(round_num)
        min_viable_coop = (self.n_players - 1) / self.n_players
        if round_num == self.n_rounds - 1:
            if stock >= stock_threshold:
                return Action.C
            else:
                return Action.D
        if stock >= stock_threshold and coop_rate >= min_viable_coop:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, round_num: int) -> float:
        """Calculate the cooperation rate from the previous round."""
        if round_num <= 0:
            return 1.0
        prev_round_idx = round_num - 1
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        cooperators = np.sum(opponent_actions_prev)
        coop_rate = cooperators / self.n_players
        return float(coop_rate)

    def _compute_stock_threshold(self, round_num: int) -> float:
        """
        Compute stock threshold based on game phase.
        Linear interpolation from 60% (early) to 40% (late).
        """
        third = self.n_rounds / 3.0
        two_thirds = 2.0 * self.n_rounds / 3.0
        if round_num < third:
            threshold_pct = 0.6
        elif round_num < two_thirds:
            threshold_pct = 0.5
        else:
            threshold_pct = 0.45
        return self.capacity * threshold_pct

class Strategy_COLLECTIVE_474(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual reward maximization with system health preservation through
    stock-conditional cooperation. Uses dynamic thresholds (75% and 25% of capacity)
    to determine cooperation rates, with smooth interpolation in the moderate zone.
    Special handling for final rounds (defect) and near-capacity conditions (cooperate).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players
        self.threshold_upper = 0.75 * self.capacity
        self.threshold_lower = 0.25 * self.capacity
        self.threshold_near_capacity = 0.9 * self.capacity
        self.threshold_collapse = 0.1 * self.capacity
        self.defection_threshold_upper = self.threshold_upper

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        if current_stock > self.threshold_near_capacity:
            return Action.C
        if current_stock < self.threshold_collapse:
            return Action.D
        if current_stock >= self.defection_threshold_upper:
            return Action.C
        if current_stock >= self.threshold_lower:
            range_lower = self.threshold_lower
            range_upper = self.defection_threshold_upper
            if range_upper > range_lower:
                p_mixed = (current_stock - range_lower) / (range_upper - range_lower)
            else:
                p_mixed = 0.5
            p_mixed = max(0.0, min(1.0, p_mixed))
            return Action.C if random.random() < p_mixed else Action.D
        return Action.D

class Strategy_COLLECTIVE_475(BaseStrategy):
    """
    Adaptive Collective Strategy for Common Pool Resource Game.
    
    Balances individual rationality with collective sustainability by:
    1. Starting with cooperation to signal non-hostile intent
    2. Assessing stock health (critical/warning/healthy)
    3. Tracking opponent defection rates (recent 3-round window)
    4. Making decisions based on stock state and opponent behavior
    5. Applying special logic for the final round
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        health_ratio = state.current_stock / self.capacity if self.capacity > 0 else 0.0
        if health_ratio < 0.3:
            return Action.C
        recent_defection_rate = self._calculate_recent_defection_rate(history, state.round_number)
        if state.round_number == self.n_rounds - 1:
            if health_ratio > 0.6:
                return Action.C
            elif health_ratio < 0.4:
                return Action.C
            else:
                return Action.D
        if health_ratio < 0.5:
            if recent_defection_rate > 0.6:
                return Action.D
            else:
                return Action.C
        elif recent_defection_rate > 0.6:
            return Action.D
        else:
            return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate defection rate from opponents in the most recent 3 rounds.
        
        Args:
            history: PlayerHistory object containing opponent actions
            round_number: Current round number (0-indexed)
        
        Returns:
            Defection rate as a float [0.0, 1.0]
        """
        window_size = min(3, round_number)
        if window_size == 0:
            return 0.0
        recent_actions = history.opponent_actions[-window_size:, :]
        total_actions = recent_actions.size
        defection_count = np.sum(~recent_actions)
        if total_actions == 0:
            return 0.0
        defection_rate = float(defection_count) / float(total_actions)
        return defection_rate

class Strategy_COLLECTIVE_476(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual payoff maximization with collective sustainability by:
    - Maintaining cooperation when stock is healthy (≥40% capacity)
    - Adapting defection tolerance based on game phase (early: generous, late: strict)
    - Tracking opponent defection rates across all previous rounds
    - Providing graduated response to exploitation rather than immediate punishment
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        if round_number <= 2:
            defection_threshold = 0.7
        elif round_number <= self.n_rounds - 3:
            defection_threshold = 0.5
        else:
            defection_threshold = 0.3
        critical_threshold = self.capacity * 0.4
        if current_stock < critical_threshold:
            if round_number > 0:
                total_opponent_defections = int(np.sum(~history.opponent_actions[:round_number, :]))
                if total_opponent_defections == 0:
                    return Action.C
            return Action.D
        abundance_threshold = self.capacity * 0.9
        if current_stock >= abundance_threshold:
            defection_threshold = min(0.8, defection_threshold + 0.1)
        if round_number == 0:
            observed_defection_rate = 0.0
        else:
            total_opponent_defections = int(np.sum(~history.opponent_actions[:round_number, :]))
            total_opponent_actions = (self.n_players - 1) * round_number
            if total_opponent_actions > 0:
                observed_defection_rate = total_opponent_defections / total_opponent_actions
            else:
                observed_defection_rate = 0.0
        if observed_defection_rate <= defection_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_477(BaseStrategy):
    """
    Adaptive Stewardship (AS): Balances individual payoff maximization with 
    long-term collective sustainability. Dynamically adapts to observed extraction 
    patterns while maintaining lookahead awareness of stock dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            if self.n <= 4:
                return Action.C
            else:
                return Action.D
        stock_health_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        rounds_remaining = self.r - round_num
        if stock < 0.1 * self.capacity:
            return Action.D
        if stock > 0.95 * self.capacity:
            return Action.C
        if round_num == self.r - 1:
            if stock_health_ratio > 0.25:
                return Action.D
            else:
                return Action.C
        defection_threshold = 0.4 + rounds_remaining / self.r * 0.2
        tolerance_threshold = 0.6 - rounds_remaining / self.r * 0.25
        observed_defection_rate = self._calculate_observed_defection_rate(history, round_num)
        projected_next_stock = self._calculate_projected_next_stock(stock, observed_defection_rate)
        survival_threshold = self.capacity * 0.15
        survival_ok = projected_next_stock > survival_threshold
        if stock_health_ratio > defection_threshold and observed_defection_rate <= tolerance_threshold and survival_ok:
            return Action.C
        else:
            return Action.D

    def _calculate_observed_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the proportion of opponents who defected across all previous rounds.
        Returns 0.5 as neutral assumption if no history yet.
        """
        if round_num == 0 or history is None:
            return 0.5
        if round_num == 0:
            return 0.5
        total_defections = 0
        for past_round in range(round_num):
            defections_this_round = np.sum(~history.opponent_actions[past_round, :])
            total_defections += defections_this_round
        total_observations = (self.n - 1) * round_num
        if total_observations == 0:
            return 0.5
        return total_defections / total_observations

    def _calculate_projected_next_stock(self, stock: float, observed_defection_rate: float) -> float:
        """
        Project the stock level after this round, assuming:
        - I cooperate (consume stock / (2n))
        - Others defect at the observed_defection_rate
        """
        cooperators_other = (self.n - 1) * (1.0 - observed_defection_rate)
        defectors_other = (self.n - 1) * observed_defection_rate
        my_consumption = stock / (2.0 * self.n)
        cooperators_consumption = cooperators_other * (stock / (2.0 * self.n))
        defectors_consumption = defectors_other * (stock / self.n)
        total_consumption = my_consumption + cooperators_consumption + defectors_consumption
        stock_after_consumption = max(0.0, stock - total_consumption)
        if self.capacity > 0:
            growth = 2.0 * stock_after_consumption * (1.0 - stock_after_consumption / self.capacity)
        else:
            growth = 0.0
        projected_stock = min(stock_after_consumption + growth, self.capacity)
        return projected_stock

class Strategy_COLLECTIVE_478(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy that prioritizes long-term
    sustainability of the common pool resource through stock-health-based cooperation,
    opponent behavior monitoring, and graduated defection responses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.C
        upper_threshold = self.capacity * 0.75
        lower_threshold = self.capacity * 0.25
        if stock < 0.1 * self.capacity:
            return Action.D
        lookback_rounds = max(3, self.n_rounds // 4)
        start_idx = max(0, round_num - lookback_rounds)
        recent_rounds = history.opponent_actions[start_idx:round_num]
        if len(recent_rounds) > 0:
            defection_count = 0
            for round_actions in recent_rounds:
                defections = np.sum(~round_actions)
                cooperations = np.sum(round_actions)
                if defections > cooperations:
                    defection_count += 1
            defection_rate = defection_count / max(1, len(recent_rounds))
        else:
            defection_rate = 0.0
        if defection_rate > 0.6:
            upper_threshold = upper_threshold * 0.8
            lower_threshold = lower_threshold * 1.2
        elif defection_rate < 0.2:
            upper_threshold = upper_threshold * 1.1
        if round_num == self.n_rounds - 1:
            if stock > lower_threshold:
                return Action.C
            else:
                return Action.D
        if stock > upper_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_479(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy for common pool resource games
    that maximizes long-term aggregate welfare by rewarding cooperation, punishing defection
    proportionally, and adapting dynamically based on stock health and observed behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        last_round_idx = current_round - 1
        opponent_actions_last_round = history.opponent_actions[last_round_idx, :]
        defection_count = np.sum(~opponent_actions_last_round)
        defection_rate = defection_count / self.n_players if self.n_players > 0 else 0.0
        if current_stock < 2 * self.n_players:
            return Action.D
        if defection_rate == 0.0:
            if health_ratio >= 0.3:
                return Action.C
            else:
                return Action.D
        if health_ratio >= 0.6:
            if defection_rate <= 0.25:
                return Action.C
            else:
                return Action.D
        elif health_ratio >= 0.4:
            if defection_rate <= 0.5:
                return Action.C
            else:
                return Action.D
        elif health_ratio >= 0.3:
            if defection_rate < 0.75:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_480(BaseStrategy):
    """
    Adaptive Stock-Conscious Cooperation (ASCC): A collective strategy that balances
    individual payoff optimization with resource sustainability by using stock health
    and defection rate as decision signals.
    
    Core logic:
    - Round 1: Cooperate (establish trust baseline)
    - Stock health ≥ 0.6: Cooperate (resource sustainable)
    - 0.3 ≤ Stock health < 0.6: Cooperate if defection_rate ≤ 0.5, else Defect
    - Stock health < 0.3: Defect (commons in crisis)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.capacity
        if capacity <= 0:
            return Action.D
        health = current_stock / capacity
        previous_round_index = state.round_number - 1
        opponent_actions_last_round = history.opponent_actions[previous_round_index, :]
        cooperators_last_round = np.sum(opponent_actions_last_round)
        defectors_last_round = self.n_players - 1 - cooperators_last_round
        if self.n_players > 1:
            defection_rate = defectors_last_round / (self.n_players - 1)
        else:
            defection_rate = 0.0
        if health >= 0.6:
            return Action.C
        elif health >= 0.3:
            if defection_rate <= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_481(BaseStrategy):
    """
    Adaptive Stewardship with Reciprocal Enforcement.
    
    Balances individual welfare with collective sustainability through conditional
    cooperation, dynamic monitoring, and reciprocal enforcement. Uses stock health
    thresholds and detects systematic defection to adapt behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.THRESHOLD_HIGH = 0.6
        self.THRESHOLD_LOW = 0.25
        self.THRESHOLD_LAST_ROUND = 0.4
        self.DEFECTION_RATE_THRESHOLD = 0.4
        self.LOOKBACK_ROUNDS = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        round_number = state.round_number
        stock_ratio = current_stock / capacity if capacity > 0 else 0.0
        if current_stock < 2 * n:
            return Action.D
        if round_number == 0:
            return Action.C
        if round_number == r - 1:
            if stock_ratio >= self.THRESHOLD_LAST_ROUND:
                return Action.C
            else:
                return Action.D
        if stock_ratio >= self.THRESHOLD_HIGH:
            return Action.C
        elif stock_ratio < self.THRESHOLD_LOW:
            return Action.D
        else:
            lookback = min(self.LOOKBACK_ROUNDS, round_number)
            if lookback == 0:
                return Action.C
            opponent_defections = 0
            total_opponent_actions = 0
            start_round = round_number - lookback
            for round_idx in range(start_round, round_number):
                for opponent_idx in range(n - 1):
                    if not history.opponent_actions[round_idx, opponent_idx]:
                        opponent_defections += 1
                    total_opponent_actions += 1
            if total_opponent_actions == 0:
                return Action.C
            defection_rate = opponent_defections / total_opponent_actions
            if defection_rate > self.DEFECTION_RATE_THRESHOLD:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_482(BaseStrategy):
    """
    Adaptive Stock-Sensitive Cooperation (ASSC) Strategy
    
    Balances individual and collective welfare by making cooperation contingent on
    stock health, collective defection rates, and remaining rounds. Defects when
    stock is critical or in final round, cooperates when regeneration is sustainable.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if current_round == self.n_rounds - 1:
            return Action.D
        rounds_remaining = self.n_rounds - current_round
        recent_defection_rate = self._get_recent_defection_rate(history)
        if stock_ratio < 0.2:
            return Action.D
        if stock_ratio < 0.4 and recent_defection_rate > 0.5:
            return Action.D
        if stock_ratio < 0.65:
            if recent_defection_rate > 0.75:
                return Action.D
            elif recent_defection_rate <= 0.25:
                return Action.C
            else:
                return Action.C
        if rounds_remaining > 3:
            return Action.C
        elif recent_defection_rate < 0.5:
            return Action.C
        else:
            return Action.D

    def _get_recent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the recent defection rate from opponent actions.
        Defection is when opponent plays False (0/D).
        """
        if history.opponent_actions.size == 0:
            return 0.0
        recent_round_actions = history.opponent_actions[-1, :]
        defections = np.sum(recent_round_actions == False)
        defection_rate = defections / self.n_players if self.n_players > 0 else 0.0
        return float(defection_rate)

class Strategy_COLLECTIVE_483(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Reciprocity.
    
    Balances individual payoff maximization with collective resource preservation
    through stock-health-based thresholds and historical reciprocity tracking.
    Cooperates when resource is abundant, reciprocates based on recent cooperation rates,
    and defects defensively when stock is critically depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = 0.8 * self.capacity
        self.threshold_medium = 0.6 * self.capacity
        self.threshold_low = 0.4 * self.capacity
        self.critical_stock = 10.0
        self.defection_punishment_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_stock < self.critical_stock:
            return Action.D
        window_size = min(3, current_round)
        cooperation_count = 0
        for t in range(current_round - window_size, current_round):
            if t >= 0:
                other_cooperators = np.sum(history.opponent_actions[t, :])
                cooperation_threshold = self.n_players * 0.75
                if other_cooperators >= cooperation_threshold:
                    cooperation_count += 1
        recent_coop_rate = cooperation_count / window_size if window_size > 0 else 0.0
        if current_round == 1:
            other_cooperators_r0 = np.sum(history.opponent_actions[0, :])
            if other_cooperators_r0 < self.n_players * 0.4:
                self.defection_punishment_rounds_remaining = 2
        if self.defection_punishment_rounds_remaining > 0:
            self.defection_punishment_rounds_remaining -= 1
            return Action.D
        if current_round == self.n_rounds - 1:
            if current_stock > self.threshold_low:
                return Action.C
            else:
                return Action.D
        if current_round >= self.n_rounds - 2:
            if current_stock > self.threshold_medium:
                return Action.C
            elif current_stock > self.threshold_high:
                return Action.C
            elif current_stock >= self.threshold_low:
                return Action.C if recent_coop_rate > 0.6 else Action.D
            else:
                return Action.D
        if current_stock > self.threshold_high:
            return Action.C
        elif current_stock >= self.threshold_low:
            if recent_coop_rate > 0.6:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_484(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances individual benefit with collective sustainability through state-dependent,
    adaptive decision-making. Core insight: defection is rational only when the resource
    can sustain it; otherwise, collective survival becomes individually optimal.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if stock < self.capacity * 0.1:
            return Action.C
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            if stock > 0:
                return Action.D
            return Action.C
        if stock > self.capacity * 0.75:
            return Action.D
        if stock < self.capacity * 0.25:
            return Action.C
        prev_round_idx = round_num - 1
        defectors_prev_round = self.n_players - int(np.sum(history.opponent_actions[prev_round_idx, :]))
        observed_defection_rate = defectors_prev_round / self.n_players
        if observed_defection_rate <= 0.25:
            return Action.C
        if observed_defection_rate <= 0.66:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_485(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Balances sustainability, reciprocity, and robustness by:
    - Initiating cooperation to establish sustainable norms
    - Monitoring stock levels as a proxy for collective cooperation
    - Switching to defection only when pool faces critical depletion or clear defection spiral
    - Defaulting to cooperation in ambiguous conditions
    - Playing defection in endgame when future payoffs no longer matter
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players
        self.critical_threshold = 0.3 * self.capacity
        self.healthy_stock = 0.6 * self.capacity
        self.cooperation_threshold = 0.7
        self.endgame_threshold = 0.4 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        round_number = state.round_number
        total_rounds = self.n_rounds
        if round_number >= total_rounds - 2:
            if round_number == total_rounds - 1:
                return Action.D
            if current_stock < self.endgame_threshold:
                return Action.D
        if current_stock < self.critical_threshold:
            return Action.D
        stock_history = history.opponent_payoffs[:, 0] if history.opponent_payoffs.size > 0 else np.array([])
        healthy_rounds = 0
        total_history_rounds = round_number
        if total_history_rounds > 0:
            stock_levels = self._reconstruct_stock_history(history)
            healthy_rounds = sum((1 for s in stock_levels if s >= self.healthy_stock))
            cooperation_level = healthy_rounds / len(stock_levels) if stock_levels else 0.0
            if cooperation_level >= self.cooperation_threshold:
                return Action.C
            if len(stock_levels) >= 3:
                recent_decline = (stock_levels[-3] - current_stock) / 3.0 if stock_levels[-3] > 0 else 0.0
                declines = []
                for i in range(len(stock_levels) - 1):
                    decline = stock_levels[i] - stock_levels[i + 1]
                    if decline > 0:
                        declines.append(decline)
                avg_decline = np.mean(declines) if declines else 0.0
                if avg_decline > 0 and recent_decline > 1.2 * avg_decline:
                    return Action.D
            if len(stock_levels) >= 2:
                if current_stock < stock_levels[-1] and stock_levels[-1] < stock_levels[-2]:
                    return Action.D
        if round_number <= 3:
            return Action.C
        return Action.C

    def _reconstruct_stock_history(self, history: PlayerHistory) -> list:
        """
        Reconstruct stock levels from history by simulating forward.
        Uses own actions and inferred opponent actions.
        """
        if history is None or history.my_actions.size == 0:
            return []
        stock_levels = [self.capacity]
        current_stock = self.capacity
        for round_idx in range(len(history.my_actions)):
            my_action = history.my_actions[round_idx]
            opponent_actions = history.opponent_actions[round_idx, :]
            num_cooperators = int(my_action) + int(np.sum(opponent_actions))
            num_defectors = self.n_players - num_cooperators
            cooperator_consumption = current_stock / (2 * self.n_players)
            defector_consumption = current_stock / self.n_players
            total_consumption = num_cooperators * cooperator_consumption + num_defectors * defector_consumption
            stock_after = current_stock - total_consumption
            stock_after = max(0.0, stock_after)
            if stock_after > 0 and self.capacity > 0:
                growth = 2.0 * stock_after * (1.0 - stock_after / self.capacity)
            else:
                growth = 0.0
            current_stock = min(stock_after + growth, self.capacity)
            stock_levels.append(current_stock)
        return stock_levels[:-1]

class Strategy_COLLECTIVE_486(BaseStrategy):
    """
    Adaptive Commons Stewardship Strategy
    
    Treats the common pool as a shared asset requiring active stewardship.
    Conditionally cooperates based on stock health and observed defection rates,
    with adaptive thresholds that respond to resource stress and group behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        h = current_stock / self.capacity if self.capacity > 0 else 0.0
        if h < 0.15:
            return Action.D
        d_rate = self._calculate_defection_rate(history, state.round_number)
        if state.round_number == self.n_rounds - 1:
            if current_stock >= self.capacity * 0.5 and d_rate <= 0.4:
                return Action.C
            else:
                return Action.D
        if h >= 0.7:
            if d_rate <= 0.25:
                return Action.C
            else:
                return Action.D
        elif h >= 0.4:
            if d_rate <= 0.33:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the defection rate from the previous round.
        Defection is when action is False (Action.D).
        """
        if current_round <= 0 or len(history.opponent_actions) == 0:
            return 0.0
        prev_round_actions = history.opponent_actions[current_round - 1, :]
        defectors = np.sum(~prev_round_actions)
        d_rate = float(defectors) / self.n_players if self.n_players > 0 else 0.0
        return d_rate

class Strategy_COLLECTIVE_487(BaseStrategy):
    """
    Adaptive Sustainable Harvest Strategy (ASHS)
    
    Balances individual incentives with collective sustainability through conditional cooperation
    with decay detection. Cooperates by default, detects system-level defection via stock depletion
    metrics, and adaptively defects when sustainability is compromised, resources are critical,
    or the final round is reached.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        critical_threshold = self.capacity * 0.2
        if current_stock <= critical_threshold:
            return Action.D
        rounds_completed = round_number
        observed_depletion = self.capacity - current_stock
        observed_average_depletion = observed_depletion / rounds_completed if rounds_completed > 0 else 0
        sustainable_depletion_rate = self.capacity * 0.5
        if sustainable_depletion_rate > 0:
            defection_ratio = observed_average_depletion / sustainable_depletion_rate
        else:
            defection_ratio = 0
        if defection_ratio > 1.3:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_488(BaseStrategy):
    """
    Adaptive Stewardship with Reciprocal Monitoring
    
    Balances individual rationality with collective sustainability through:
    - Cooperative baseline in round 1
    - Inferred defection ratio monitoring from stock depletion
    - Dynamic tolerance threshold that tightens as rounds dwindle
    - Emergency cooperation when stock approaches critical threshold
    - Graceful degradation in final rounds
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        current_round = state.round_number
        rounds_remaining = self.r - current_round
        critical_threshold = 1.5 * self.n
        if current_stock <= critical_threshold:
            return Action.C
        previous_round_idx = current_round - 1
        if previous_round_idx >= 0:
            previous_actions = history.my_actions[previous_round_idx]
            opponent_actions_prev = history.opponent_actions[previous_round_idx, :]
            my_action_was_coop = previous_actions
            opponent_coops = np.sum(opponent_actions_prev)
            total_coops = (1 if my_action_was_coop else 0) + opponent_coops
            total_defectors = self.n - total_coops
            inferred_defection_ratio = total_defectors / self.n if self.n > 0 else 0.0
            tolerance_threshold = 0.5 + rounds_remaining / self.r * 0.25
            if inferred_defection_ratio > tolerance_threshold:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_COLLECTIVE_489(BaseStrategy):
    """
    Adaptive Conservation with Graduated Sanctions strategy for Common Pool Resource Game.
    
    Operates in three modes based on stock health:
    - MODE 1 (CONSERVATION): Stock ≥ 70% capacity → COOPERATE
    - MODE 2 (EQUILIBRIUM): 30-70% capacity → respond to defection rate
    - MODE 3 (EMERGENCY): Stock ≤ 30% capacity → DEFECT
    
    Special handling for first/last rounds and stock recovery windows.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        self.stock_history.append(current_stock)
        if current_stock >= 0.7 * self.capacity:
            return Action.C
        if current_stock <= 0.3 * self.capacity:
            return Action.D
        if round_num == 0:
            return Action.C
        if round_num == self.r - 1:
            return Action.D
        prev_round_idx = round_num - 1
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        num_defectors = sum((1 for action in opponent_actions_prev if not action))
        defection_rate = num_defectors / self.n
        trend = 0.0
        if len(self.stock_history) >= 2:
            trend = self.stock_history[-1] - self.stock_history[-2]
        if trend < -0.05 * self.capacity:
            adjusted_defection_threshold = 0.25
        else:
            adjusted_defection_threshold = 0.33
        if defection_rate <= adjusted_defection_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_490(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A collective strategy that maximizes long-term
    aggregate welfare in common pool resource games by maintaining sustainable stock
    levels while adapting to observed defection patterns.
    
    Core logic:
    - Round 1: Cooperate (establish baseline)
    - Round r (final): Defect (backward induction)
    - Middle rounds: Adapt based on stock health and defection rate
      * Stock > 40% capacity: Cooperate
      * Stock ≤ 15% capacity: Defect
      * 15% < Stock ≤ 40%: Cooperate if defection rate ≤ 50%, else Defect
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainability_threshold = self.capacity * 0.4
        self.critical_threshold = self.capacity * 0.15

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock > self.sustainability_threshold:
            return Action.C
        if current_stock <= self.critical_threshold:
            return Action.D
        defection_count = 0
        total_action_slots = 0
        for round_idx in range(current_round):
            defections_this_round = np.sum(~history.opponent_actions[round_idx, :])
            defection_count += defections_this_round
            total_action_slots += self.n_players - 1
        if total_action_slots == 0:
            return Action.C
        defection_rate = defection_count / total_action_slots
        if defection_rate > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_491(BaseStrategy):
    """
    Adaptive Stock Preservation with Conditional Defection.
    
    This strategy prioritizes collective welfare through sustainable resource management.
    It cooperates when stock is healthy, defects when stock is critical or when exploitation
    is detected, and includes monitoring for free-riders and cascade risks.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.health_threshold = game_description.capacity * 0.4
        self.recovery_threshold_low = game_description.capacity * 0.35
        self.recovery_threshold_high = game_description.capacity * 0.45
        self.exploitation_strike_limit = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_idx = state.round_number - 1
        opponent_defections = np.sum(~history.opponent_actions[prev_round_idx, :])
        n_opponents = self.game_description.n_players - 1
        defection_rate = opponent_defections / n_opponents if n_opponents > 0 else 0.0
        cascade_risk = self._check_cascade_risk(state.current_stock, defection_rate, n_opponents)
        recent_streak = self._count_exploitation_streak(history, prev_round_idx)
        if state.current_stock > self.health_threshold:
            if defection_rate > 0.5 or cascade_risk or recent_streak >= self.exploitation_strike_limit:
                return Action.D
            else:
                return Action.C
        elif self._should_cooperate_in_critical(state.current_stock, defection_rate, history, prev_round_idx):
            return Action.C
        else:
            return Action.D

    def _check_cascade_risk(self, current_stock: float, defection_rate: float, n_opponents: int) -> bool:
        """
        Check if current defection rate combined with our cooperation would push stock below threshold.
        """
        if defection_rate == 0.0:
            return False
        n_cooperators = n_opponents - int(round(defection_rate * n_opponents)) + 1
        n_defectors = int(round(defection_rate * n_opponents))
        total_consumption = n_cooperators * (current_stock / (2 * self.game_description.n_players)) + n_defectors * (current_stock / self.game_description.n_players)
        stock_after_consumption = max(0, current_stock - total_consumption)
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
        projected_stock = min(stock_after_consumption + growth, self.game_description.capacity)
        return projected_stock < self.health_threshold

    def _count_exploitation_streak(self, history: PlayerHistory, up_to_round: int) -> int:
        """
        Count consecutive recent rounds where we played C and opponent defection rate > 50%.
        """
        streak = 0
        for round_idx in range(up_to_round, -1, -1):
            if not history.my_actions[round_idx]:
                break
            opponent_defections = np.sum(~history.opponent_actions[round_idx, :])
            n_opponents = self.game_description.n_players - 1
            defection_rate = opponent_defections / n_opponents if n_opponents > 0 else 0.0
            if defection_rate > 0.5:
                streak += 1
            else:
                break
        return streak

    def _should_cooperate_in_critical(self, current_stock: float, defection_rate: float, history: PlayerHistory, prev_round_idx: int) -> bool:
        """
        Determine if we should cooperate while in critical stock condition.
        """
        if self.recovery_threshold_low < current_stock <= self.recovery_threshold_high and defection_rate <= 0.25:
            return True
        n_opponents = self.game_description.n_players - 1
        opponent_cooperators = np.sum(history.opponent_actions[prev_round_idx, :])
        cooperation_rate = opponent_cooperators / n_opponents if n_opponents > 0 else 0.0
        if cooperation_rate > 0.75 and defection_rate < 0.25:
            return True
        return False

class Strategy_COLLECTIVE_492(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS) for Common Pool Resource Game.
    
    Core principle: Cooperate when stock is healthy (above threshold), defect when depleted.
    Threshold = capacity × (1 - 1/(2n)).
    
    This strategy treats the common pool as a sustainable resource and adapts to collective
    behavior through stock-conditional cooperation, enabling long-term payoff maximization.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_stock = self.capacity * (1.0 - 1.0 / (2.0 * self.n_players))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            if current_stock >= self.threshold_stock:
                return Action.C
            else:
                return Action.D
        if round_number == self.n_rounds - 1:
            if current_stock < self.threshold_stock / 2.0:
                return Action.D
            else:
                return Action.C
        if current_stock >= self.threshold_stock:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_493(BaseStrategy):
    """
    Adaptive Sustainability Strategy (ASS) for Common Pool Resource Game.
    
    Balances cooperative stock preservation with defensive defection based on:
    1. Stock health (maintain above 40% capacity)
    2. Defection detection (respond to free-riding)
    3. Stock trajectory (detect resource degradation)
    4. Endgame behavior (defect in final round)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == self.n_rounds - 1:
            return Action.D
        if round_number == 0:
            return Action.C
        stock_health_threshold = self.capacity * 0.4
        if current_stock < stock_health_threshold:
            return Action.D
        last_round_opponent_actions = history.opponent_actions[round_number - 1, :]
        defectors_last_round = self.n_players - np.sum(last_round_opponent_actions)
        defection_proportion = defectors_last_round / self.n_players
        defection_threshold = min(0.5, 2.0 / self.n_players)
        if defection_proportion > defection_threshold:
            return Action.D
        if round_number >= 2:
            stock_change = history.opponent_payoffs[round_number - 1, 0] - history.opponent_payoffs[round_number - 2, 0]
            trajectory_threshold = -0.05 * self.capacity
            if round_number >= 2:
                prev_payoff = history.my_payoffs[round_number - 1]
                prev_prev_payoff = history.my_payoffs[round_number - 2]
                payoff_change = prev_payoff - prev_prev_payoff
                estimated_stock_change = payoff_change * self.n_players * 1.5
                if estimated_stock_change < trajectory_threshold:
                    return Action.D
        return Action.C

class Strategy_COLLECTIVE_494(BaseStrategy):
    """
    Adaptive Sustainable Harvest Strategy (ASHS):
    Balances individual payoffs, long-term resource viability, and punishment of free-riding.
    Uses stock health ratio to determine behavior across four tiers, with special handling for
    critical phases, first round, and opponent behavior analysis.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_retaliation_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        h = current_stock / self.capacity if self.capacity > 0 else 0.0
        if h <= 0.25:
            return Action.C
        if h <= 0.5:
            return Action.C
        if h <= 0.75:
            return self._tier3_decision(round_number, history)
        return self._tier4_decision(round_number, history)

    def _tier3_decision(self, round_number: int, history: PlayerHistory) -> Action:
        """
        Conditional Tit-for-Tat with Defection Counting.
        Check majority defection in previous round and respond accordingly.
        """
        last_round_actions = history.opponent_actions[-1, :]
        cooperators_last_round = np.sum(last_round_actions)
        defectors_last_round = self.n_players - cooperators_last_round
        if defectors_last_round < self.n_players / 2:
            self.defection_retaliation_rounds = 0
            return Action.C
        if self.defection_retaliation_rounds == 0:
            self.defection_retaliation_rounds = 2
            return Action.D
        elif self.defection_retaliation_rounds > 0:
            self.defection_retaliation_rounds -= 1
            if self.defection_retaliation_rounds > 0:
                return Action.D
            else:
                return Action.C
        return Action.C

    def _tier4_decision(self, round_number: int, history: PlayerHistory) -> Action:
        """
        Conditional Defection with Reciprocity.
        Calculate cooperation rate from last 3 rounds and decide.
        """
        lookback_rounds = min(3, round_number)
        if lookback_rounds == 0:
            return Action.C
        all_coop_count = 0
        for i in range(round_number - lookback_rounds, round_number):
            if i >= 0:
                all_cooperated = np.all(history.opponent_actions[i, :])
                if all_cooperated:
                    all_coop_count += 1
        c_rate = all_coop_count / lookback_rounds if lookback_rounds > 0 else 0.0
        if c_rate >= 0.67:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_495(BaseStrategy):
    """
    Adaptive Conservation with Graduated Defection Detection.
    
    Balances collective sustainability with individual resilience by:
    1. Cooperating when stock is healthy (>60% capacity) and defection rate is low
    2. Detecting defection patterns via exponential moving average
    3. Escalating defection threshold when population defects persistently
    4. Special handling for first/last rounds and critically low stock
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_rate = 0.4
        self.defection_tolerance = (self.n - 1) / self.n * 0.5
        self.high_defection_rounds = 0
        self.prev_stock = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            self.prev_stock = stock
            return Action.C
        opponent_actions_prev = history.opponent_actions[current_round - 1, :]
        observed_defectors = np.sum(~opponent_actions_prev)
        current_defection_rate = observed_defectors / self.n
        self.defection_rate = 0.3 * self.defection_rate + 0.7 * current_defection_rate
        if self.defection_rate > 0.7:
            self.high_defection_rounds += 1
            if self.high_defection_rounds >= 2:
                self.defection_tolerance = max(0.2, self.defection_tolerance - 0.15)
        else:
            self.high_defection_rounds = 0
        if stock > 0.8 * self.capacity:
            self.defection_tolerance = min(0.5, self.defection_tolerance + 0.1)
        self.prev_stock = stock
        if current_round == self.r - 1:
            if stock < 0.2 * self.capacity:
                return Action.C
            else:
                return Action.D
        if stock < 0.2 * self.capacity:
            return Action.D
        stock_threshold = 0.6 * self.capacity
        if stock > stock_threshold and self.defection_rate < self.defection_tolerance:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_496(BaseStrategy):
    """
    Adaptive Collective Stewardship Strategy (ACS)
    
    Balances individual security with collective sustainability by:
    1. Assessing stock health (current_stock / capacity)
    2. Tracking recent opponent defection rates
    3. Making cooperative decisions when conditions support it
    4. Defecting when exploitation becomes systematic
    5. Cooperating after stock collapses to enable recovery
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.window_size = max(3, self.n_rounds // 4)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.C
        stock_health = stock / self.capacity if self.capacity > 0 else 0.0
        recent_defection_rate = self._calculate_recent_defection_rate(history, round_num)
        if round_num == self.n_rounds - 1:
            if stock_health >= 0.5:
                return Action.C
        if round_num <= 2:
            if stock_health <= 0.25:
                return Action.D
            return Action.C
        if stock <= 0.01:
            return Action.C
        if stock_health >= 0.75:
            if recent_defection_rate < 0.5:
                return Action.C
            else:
                return Action.D
        if stock_health >= 0.5:
            if recent_defection_rate < 0.33:
                return Action.C
            else:
                return Action.D
        if stock_health >= 0.25:
            if recent_defection_rate < 0.2:
                return Action.C
            else:
                return Action.D
        if recent_defection_rate < 0.1:
            return Action.C
        elif stock_health > 0.15:
            return Action.D
        else:
            return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the proportion of opponent defections in recent window.
        
        Defection is encoded as False (0), Cooperation as True (1).
        """
        window_start = max(0, round_num - self.window_size)
        window_end = round_num
        if window_start >= window_end:
            return 0.0
        opponent_actions_window = history.opponent_actions[window_start:window_end, :]
        total_actions = opponent_actions_window.size
        if total_actions == 0:
            return 0.0
        defection_count = np.sum(opponent_actions_window == 0)
        defection_rate = float(defection_count) / float(total_actions)
        return defection_rate

class Strategy_COLLECTIVE_497(BaseStrategy):
    """
    Adaptive Stewardship: A collective strategy for common pool resource management.
    
    Balances sustainability, reciprocal fairness, and robustness through state-dependent
    cooperation rules. Maintains stock above critical thresholds while adapting to
    observed defection rates in the community.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainable_threshold = 0.75 * self.capacity
        self.critical_threshold = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if current_stock > self.sustainable_threshold:
            return Action.C
        if current_stock <= self.critical_threshold:
            return Action.C
        if round_num == 0:
            return Action.C
        recent_defection_rate = self._calculate_recent_defection_rate(history, round_num)
        if recent_defection_rate < 0.3:
            return Action.C
        if recent_defection_rate < 0.6:
            cooperation_prob = 1.0 - recent_defection_rate
            if random.random() < cooperation_prob:
                return Action.C
            else:
                return Action.D
        if round_num == self.n_rounds - 1:
            if current_stock > self.sustainable_threshold:
                return Action.D
            else:
                return Action.C
        return Action.D

    def _calculate_recent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the defection rate among all players in the last 3 rounds.
        Returns fraction of defection actions observed.
        """
        if history is None or current_round == 0:
            return 0.0
        window_size = min(3, current_round)
        start_round = current_round - window_size
        total_possible_defections = window_size * self.n_players
        if total_possible_defections == 0:
            return 0.0
        defection_count = 0
        for round_idx in range(start_round, current_round):
            defections_this_round = np.sum(~history.opponent_actions[round_idx, :])
            defection_count += defections_this_round
        defection_rate = defection_count / total_possible_defections
        return defection_rate

class Strategy_COLLECTIVE_498(BaseStrategy):
    """
    Stock Sentinel: An adaptive stewardship strategy for common pool resource games.
    
    Prioritizes long-term collective sustainability through stock-health monitoring,
    defection detection, and proportional response mechanisms. Cooperates when the pool
    is healthy, defects when depleted, and matches defection escalation in moderate zones.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.total_rounds = game_description.n_rounds
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        self.stock_history.append(current_stock)
        if current_stock <= 2 * self.n:
            return Action.D
        if round_num == 0:
            return Action.C
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0
        if health_ratio > 0.75:
            return Action.C
        if health_ratio <= 0.25:
            return Action.D
        prev_round_idx = round_num - 1
        if prev_round_idx > 0:
            stock_before_prev = self.stock_history[prev_round_idx - 1]
        else:
            stock_before_prev = self.capacity
        stock_after_prev = self.stock_history[prev_round_idx]
        expected_coop_consumption = stock_before_prev / 2
        my_action_prev = history.my_actions[prev_round_idx]
        my_consumption_prev = stock_before_prev / (2 * self.n) if my_action_prev else stock_before_prev / self.n
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        opponent_consumptions = np.sum(np.where(opponent_actions_prev, stock_before_prev / (2 * self.n), stock_before_prev / self.n))
        actual_consumption = my_consumption_prev + opponent_consumptions
        consumption_per_defector = stock_before_prev / self.n if stock_before_prev > 0 else 0
        consumption_per_cooperator = stock_before_prev / (2 * self.n) if stock_before_prev > 0 else 0
        if consumption_per_cooperator > 0:
            estimated_defectors = (actual_consumption - self.n * consumption_per_cooperator) / (consumption_per_defector - consumption_per_cooperator)
            estimated_defectors = max(0, min(self.n, estimated_defectors))
        else:
            estimated_defectors = 0
        defection_ratio = estimated_defectors / self.n if self.n > 0 else 0
        if defection_ratio >= 0.5:
            return Action.D
        if defection_ratio <= 0.25:
            return Action.C
        if round_num >= 2:
            stock_now = self.stock_history[round_num]
            stock_prev = self.stock_history[round_num - 1]
            stock_2prev = self.stock_history[round_num - 2]
            if stock_now > stock_prev and stock_prev > stock_2prev and (stock_now > 0.5 * self.capacity):
                return Action.C
        if round_num == self.total_rounds - 1:
            if current_stock <= 0.4 * self.capacity:
                return Action.D
            else:
                if health_ratio > 0.75:
                    return Action.C
                if health_ratio <= 0.25:
                    return Action.D
        if current_stock >= 0.95 * self.capacity:
            defection_rate = sum(history.opponent_actions[prev_round_idx, :]) / self.n if self.n > 0 else 0
            if defection_rate <= 0.75:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_COLLECTIVE_499(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS) for Common Pool Resource Game.
    
    Balances individual benefit extraction with collective resource preservation.
    Adapts cooperation level based on stock health, observed behavior, and time remaining.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_high = 0.75
        self.threshold_low = 0.3
        self.expected_defection_rate = 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.C
        stock_ratio = stock / capacity if capacity > 0 else 0.0
        rounds_remaining = r - current_round
        if rounds_remaining <= 2:
            if stock > 0:
                return Action.D
            else:
                return Action.D
        if stock_ratio < self.threshold_low:
            return Action.D
        if stock_ratio > self.threshold_high:
            return Action.C
        adjusted_threshold_high = self.threshold_high
        adjusted_threshold_low = self.threshold_low
        if rounds_remaining <= 4:
            adjusted_threshold_high = 0.65
            adjusted_threshold_low = 0.25
            if stock_ratio > adjusted_threshold_high:
                return Action.C
            if stock_ratio < adjusted_threshold_low:
                return Action.D
        observed_defection_rate = self._calculate_opponent_defection_rate(history, n)
        if observed_defection_rate > 0.6:
            if stock_ratio > 0.5:
                return Action.D
            else:
                return Action.D
        elif observed_defection_rate < 0.2:
            if stock_ratio > 0.4:
                return Action.C
            else:
                return Action.D
        else:
            stock_momentum = self._calculate_stock_momentum(history, capacity)
            if stock_momentum < -0.1 * capacity:
                defect_prob = 0.7
                return Action.D if random.random() < defect_prob else Action.C
            elif stock_momentum > 0.05 * capacity:
                coop_prob = 0.9
                return Action.C if random.random() < coop_prob else Action.D
            else:
                majority_action = self._get_majority_opponent_action(history, n)
                return majority_action

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, n: int) -> float:
        """
        Calculate the average defection rate of opponents (excluding self).
        Returns value in [0.0, 1.0].
        """
        if history.opponent_actions.shape[0] == 0:
            return self.expected_defection_rate
        total_opponent_actions = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
        total_defections = np.sum(~history.opponent_actions)
        if total_opponent_actions == 0:
            return self.expected_defection_rate
        return float(total_defections) / float(total_opponent_actions)

    def _calculate_stock_momentum(self, history: PlayerHistory, capacity: float) -> float:
        """
        Calculate the change in stock from previous round to current round.
        Returns the absolute change in stock level.
        """
        if history.my_payoffs.shape[0] < 2:
            return 0.0
        recent_payoff = history.my_payoffs[-1]
        previous_payoff = history.my_payoffs[-2]
        payoff_change = recent_payoff - previous_payoff
        return payoff_change

    def _get_majority_opponent_action(self, history: PlayerHistory, n: int) -> Action:
        """
        Determine majority action from opponents in the most recent round.
        True (C) = COOPERATE, False (D) = DEFECT.
        """
        if history.opponent_actions.shape[0] == 0:
            return Action.C
        last_round_actions = history.opponent_actions[-1, :]
        cooperators = np.sum(last_round_actions)
        defectors = len(last_round_actions) - cooperators
        if cooperators >= defectors:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_500(BaseStrategy):
    """
    Adaptive Commons Stewardship Strategy: Balances individual gain with collective
    sustainability through stock-conditional cooperation, adaptive pressure response,
    and special handling for opening/closing rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.healthy_threshold = self.capacity * 0.75
        self.minimum_threshold = self.capacity * 0.15
        self.defection_pressure_high = 0.4
        self.defection_pressure_medium = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round >= self.n_rounds - 2:
            if current_stock > self.healthy_threshold:
                return Action.C
            else:
                return Action.D
        if current_stock <= 0.0:
            return Action.D
        if current_stock >= self.healthy_threshold:
            return Action.C
        if current_stock <= self.minimum_threshold:
            return Action.D
        defection_rate = self._calculate_defection_rate(history)
        if defection_rate > self.defection_pressure_high:
            return Action.D
        elif defection_rate > self.defection_pressure_medium:
            cooperation_prob = 1.0 - defection_rate
            if random.random() < cooperation_prob:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the observed defection rate among opponents across all previous rounds.
        Returns a value in [0.0, 1.0], or 0.0 if no history yet.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        total_opponent_actions = history.opponent_actions.size
        if total_opponent_actions == 0:
            return 0.0
        defections = np.sum(~history.opponent_actions)
        defection_rate = float(defections) / float(total_opponent_actions)
        return defection_rate

class Strategy_COLLECTIVE_501(BaseStrategy):
    """
    Adaptive Stewardship with Contingent Defection
    
    Balances collective welfare and stock sustainability with individual rationality.
    Cooperates when stock is healthy, defects reciprocally when widespread defection is observed,
    and unconditionally defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        safety_margin = 0.3
        stock_critical = 2 * self.n * (1 + safety_margin)
        if current_stock < 1.5 * self.n:
            return Action.D
        if current_round == self.r - 1:
            return Action.D
        defection_count = 0
        total_opponent_actions = 0
        if history is not None and current_round > 0:
            for round_idx in range(current_round):
                for opponent_idx in range(self.n - 1):
                    if not history.opponent_actions[round_idx, opponent_idx]:
                        defection_count += 1
                    total_opponent_actions += 1
        aggregate_defection_rate = 0.0
        if total_opponent_actions > 0:
            aggregate_defection_rate = defection_count / total_opponent_actions
        if current_stock < stock_critical:
            return Action.C
        defection_threshold = 0.4
        if aggregate_defection_rate > defection_threshold:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_502(BaseStrategy):
    """
    Collective Pool Stewardship Strategy: Stock-conditional adaptive strategy that
    balances individual extraction with collective resource preservation through
    dynamic thresholds and history-aware decision making.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.safe_threshold = game_description.capacity * 0.6
        self.critical_threshold = game_description.capacity * 0.15
        self.collapse_threshold = game_description.capacity * 0.05

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock = state.current_stock
        round_num = state.round_number
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if stock <= capacity * 0.02:
            return Action.C
        if round_num == r - 1:
            if stock < self.collapse_threshold:
                return Action.C
            else:
                return Action.D
        prev_opponent_actions = history.opponent_actions[round_num - 1, :]
        num_defectors = np.sum(~prev_opponent_actions)
        defection_density = num_defectors / n if n > 0 else 0.0
        recent_trend = self._calculate_trend(history, round_num)
        if stock > self.safe_threshold:
            return Action.C
        if stock <= self.critical_threshold:
            return Action.C
        if defection_density < 0.25:
            return Action.C
        if defection_density >= 0.75:
            return Action.D
        if recent_trend == 'DECLINING':
            return Action.D
        else:
            return Action.C

    def _calculate_trend(self, history: PlayerHistory, round_num: int) -> str:
        """
        Calculate recent stock trend based on last 3 rounds.
        Returns: "DECLINING", "STABLE", or "RECOVERING"
        """
        if round_num < 2:
            return 'STABLE'
        stock_values = []
        for i in range(max(0, round_num - 2), round_num + 1):
            if i == round_num:
                continue
            stock_values.append(i)
        if round_num >= 2:
            total_payoffs_prev = np.sum(history.my_payoffs[round_num - 2:round_num])
            total_payoffs_curr = history.my_payoffs[round_num - 1]
            if total_payoffs_curr < total_payoffs_prev * 0.95:
                return 'DECLINING'
            elif total_payoffs_curr > total_payoffs_prev * 1.05:
                return 'RECOVERING'
            else:
                return 'STABLE'
        return 'STABLE'

class Strategy_COLLECTIVE_503(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Reciprocity.
    
    Treats the common pool as a shared resource requiring active stewardship.
    Balances sustainability, fairness, and robustness through:
    1. Stock health assessment (healthy/stable/stressed/critical)
    2. Cooperation trend analysis from history
    3. Adaptive decision-making that reciprocates cooperation while protecting against defection
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            if self.n_players <= 3:
                return Action.D
            else:
                return Action.C
        health_status = self._assess_stock_health(current_stock)
        cooperation_trend = self._analyze_cooperation_trend(history, current_round)
        rounds_remaining = self.n_rounds - current_round
        stock_collapse = self._detect_stock_collapse(history)
        if stock_collapse:
            return Action.D
        if current_round == self.n_rounds - 1:
            coop_rate = self._calculate_cooperation_rate(history)
            if coop_rate >= 0.65 and health_status != 'CRITICAL':
                return Action.C
            else:
                return Action.D
        if rounds_remaining <= 2:
            if health_status == 'HEALTHY':
                return Action.C
            else:
                return Action.D
        if health_status == 'CRITICAL':
            if cooperation_trend == 'COOPERATIVE':
                return Action.C
            else:
                return Action.D
        elif health_status == 'STRESSED':
            if cooperation_trend == 'COOPERATIVE':
                return Action.C
            elif cooperation_trend == 'MIXED':
                return Action.C
            else:
                return Action.D
        elif cooperation_trend == 'COOPERATIVE':
            return Action.C
        elif cooperation_trend == 'MIXED':
            if rounds_remaining > self.n_rounds * 0.4:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _assess_stock_health(self, current_stock: float) -> str:
        """
        Classify stock health based on health ratio.
        Returns: "HEALTHY", "STABLE", "STRESSED", or "CRITICAL"
        """
        if self.capacity <= 0:
            return 'CRITICAL'
        health_ratio = current_stock / self.capacity
        if health_ratio >= 0.75:
            return 'HEALTHY'
        elif health_ratio >= 0.4:
            return 'STABLE'
        elif health_ratio >= 0.2:
            return 'STRESSED'
        else:
            return 'CRITICAL'

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the proportion of rounds where majority played C.
        """
        if history.opponent_actions.shape[0] == 0:
            return 1.0
        n_rounds_played = history.opponent_actions.shape[0]
        majority_coop_rounds = 0
        for round_idx in range(n_rounds_played):
            cooperators_in_round = np.sum(history.opponent_actions[round_idx, :])
            if cooperators_in_round > self.n_players / 2:
                majority_coop_rounds += 1
        return majority_coop_rounds / n_rounds_played if n_rounds_played > 0 else 1.0

    def _analyze_cooperation_trend(self, history: PlayerHistory, current_round: int) -> str:
        """
        Classify cooperation trend based on cooperation rate.
        Returns: "COOPERATIVE", "MIXED", or "DEFECTIVE"
        """
        coop_rate = self._calculate_cooperation_rate(history)
        if coop_rate >= 0.7:
            return 'COOPERATIVE'
        elif coop_rate >= 0.4:
            return 'MIXED'
        else:
            return 'DEFECTIVE'

    def _detect_stock_collapse(self, history: PlayerHistory) -> bool:
        """
        Detect if stock decreased by >50% in the last round.
        """
        if history.my_payoffs.shape[0] < 2:
            return False
        last_round_payoff = history.my_payoffs[-1]
        prev_round_payoff = history.my_payoffs[-2]
        if last_round_payoff > 0 and prev_round_payoff > 0:
            if last_round_payoff < prev_round_payoff * 0.5:
                return True
        return False

class Strategy_COLLECTIVE_504(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Game.
    
    Treats the common pool as a shared resource requiring active stewardship.
    Cooperates when stock is healthy and trajectory is positive, defects when
    resource degradation is detected or defection cascades occur.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainability_threshold = 0.6
        self.critical_threshold = 0.4
        self.severe_depletion_threshold = 0.1
        self.final_round_threshold = 0.5
        self.defection_cascade_ratio = 0.5
        self.defection_cascade_rounds = 2
        self.trajectory_decline_rounds = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.C
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_health < self.severe_depletion_threshold:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.C if stock_health >= self.final_round_threshold else Action.D
        previous_stock = self.capacity
        trajectory = 0.0
        if history is not None and round_num > 0:
            previous_stock = self._reconstruct_previous_stock(history, round_num)
            trajectory = current_stock - previous_stock
        if self.critical_threshold <= stock_health <= self.sustainability_threshold:
            if history is not None and round_num > 0:
                previous_action = history.my_actions[round_num - 1]
                if not self._significant_change_detected(history, round_num, trajectory):
                    return Action.C if previous_action else Action.D
        aggressive_defection_detected = False
        if history is not None:
            aggressive_defection_detected = self._detect_defection_cascade(history, round_num)
        trajectory_declining = False
        if history is not None:
            trajectory_declining = self._detect_trajectory_decline(history, round_num)
        sustainability_ok = stock_health >= self.sustainability_threshold
        trajectory_ok = trajectory >= 0.0 or round_num == 1
        if sustainability_ok and trajectory_ok and (not aggressive_defection_detected):
            return Action.C
        else:
            return Action.D

    def _reconstruct_previous_stock(self, history: PlayerHistory, round_num: int) -> float:
        """
        Reconstruct the stock from the previous round.
        Uses the game dynamics: stock grows logistically after consumption.
        """
        if round_num <= 1:
            return self.capacity
        if round_num == 1:
            return self.capacity
        stock = self.capacity
        for t in range(round_num):
            cooperators = int(np.sum(history.opponent_actions[t, :]))
            defectors = self.n_players - 1 - cooperators
            if history.my_actions[t]:
                cooperators += 1
            else:
                defectors += 1
            consumption_c = stock / (2 * self.n_players)
            consumption_d = stock / self.n_players
            total_consumption = cooperators * consumption_c + defectors * consumption_d
            stock_after = max(0.0, stock - total_consumption)
            growth = 2.0 * stock_after * (1.0 - stock_after / self.capacity)
            stock = min(stock_after + growth, self.capacity)
        return stock

    def _significant_change_detected(self, history: PlayerHistory, round_num: int, trajectory: float) -> bool:
        """Check if conditions have changed significantly in hysteresis zone."""
        if round_num < 2:
            return False
        recent_defection_count = 0
        for t in range(max(0, round_num - 2), round_num):
            defectors = int(np.sum(~history.opponent_actions[t, :]))
            if defectors > self.n_players * 0.25:
                recent_defection_count += 1
        return recent_defection_count > 0 or trajectory < -0.01

    def _detect_defection_cascade(self, history: PlayerHistory, round_num: int) -> bool:
        """
        Detect if cascading defection (>50% defection) has persisted for 2+ rounds.
        """
        if round_num < 2:
            return False
        cascade_count = 0
        for t in range(max(0, round_num - 2), round_num):
            defectors = int(np.sum(~history.opponent_actions[t, :]))
            defection_ratio = defectors / self.n_players if self.n_players > 0 else 0.0
            if defection_ratio > self.defection_cascade_ratio:
                cascade_count += 1
        return cascade_count >= self.defection_cascade_rounds

    def _detect_trajectory_decline(self, history: PlayerHistory, round_num: int) -> bool:
        """
        Detect if stock has declined for 2+ consecutive recent rounds.
        """
        if round_num < 2:
            return False
        decline_count = 0
        prev_stock = self.capacity
        for t in range(max(0, round_num - 2), round_num):
            current = self.capacity
            for s in range(t + 1):
                cooperators = int(np.sum(history.opponent_actions[s, :]))
                defectors = self.n_players - 1 - cooperators
                if history.my_actions[s]:
                    cooperators += 1
                else:
                    defectors += 1
                consumption_c = current / (2 * self.n_players)
                consumption_d = current / self.n_players
                total_consumption = cooperators * consumption_c + defectors * consumption_d
                stock_after = max(0.0, current - total_consumption)
                growth = 2.0 * stock_after * (1.0 - stock_after / self.capacity)
                current = min(stock_after + growth, self.capacity)
            if current < prev_stock - 0.01:
                decline_count += 1
            prev_stock = current
        return decline_count >= self.trajectory_decline_rounds

class Strategy_COLLECTIVE_505(BaseStrategy):
    """
    Collective Adaptive Resource Management Strategy (CARM)
    
    Prioritizes long-term collective sustainability over short-term individual gain.
    Uses stock-health-based cooperation with adaptive punishment and recovery mechanisms.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.consecutive_healthy_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        defection_rate = self._calculate_others_defection_rate(history)
        stock_trend = self._calculate_stock_trend(history, stock)
        if round_num == self.n_rounds - 1:
            if stock > self.capacity * 0.4:
                return Action.C
            else:
                return Action.D
        if stock > self.capacity * 0.75:
            self.consecutive_healthy_rounds += 1
            return Action.C
        elif stock > self.capacity * 0.4:
            self.consecutive_healthy_rounds = 0
            threshold = (stock - 0.4 * self.capacity) / (0.35 * self.capacity)
            threshold = max(0.0, min(1.0, threshold))
            if random.random() < threshold:
                return Action.C
            else:
                return Action.D
        elif stock > self.capacity * 0.2:
            self.consecutive_healthy_rounds = 0
            if stock_trend > 0 and defection_rate < 0.5:
                return Action.C
            else:
                return Action.D
        else:
            self.consecutive_healthy_rounds = 0
            return Action.D
        if defection_rate > 0.6 * (self.n_players - 1) / (self.n_players - 1):
            return Action.D
        if self.consecutive_healthy_rounds >= 2:
            return Action.C
        return Action.C

    def _calculate_others_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the average defection rate of all other players across all past rounds.
        Returns a value in [0, 1] where 1 means all other actions were defection.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        total_opponent_actions = history.opponent_actions.size
        if total_opponent_actions == 0:
            return 0.0
        defection_count = np.sum(~history.opponent_actions)
        return float(defection_count) / float(total_opponent_actions)

    def _calculate_stock_trend(self, history: PlayerHistory, current_stock: float) -> float:
        """
        Calculate stock trend by comparing current stock to previous round stock.
        Returns positive value if stock increased, negative if decreased.
        """
        if history is None or len(history.my_payoffs) == 0:
            return 0.0
        prev_round_idx = len(history.my_payoffs) - 1
        if prev_round_idx < 0:
            return 0.0
        my_action_was_cooperate = history.my_actions[prev_round_idx]
        prev_payoff = history.my_payoffs[prev_round_idx]
        if prev_payoff == 0:
            prev_stock = 0.0
        elif my_action_was_cooperate:
            prev_stock = prev_payoff * 2 * self.n_players
        else:
            prev_stock = prev_payoff * self.n_players
        return current_stock - prev_stock

class Strategy_COLLECTIVE_506(BaseStrategy):
    """
    Adaptive Sustainable Harvest Strategy (ASHS)
    
    Balances individual payoff maximization with collective resource sustainability.
    Uses adaptive thresholds based on stock health, reciprocal punishment for defectors,
    and endgame extraction while protecting critical resource levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        rounds_remaining = self.n_rounds - round_number
        defection_rate = self._compute_defection_rate(history)
        if rounds_remaining <= 2:
            if health_ratio < 0.15:
                return Action.C
            return Action.D
        if health_ratio < 0.15:
            return Action.C
        if health_ratio < 0.3:
            return Action.C
        if health_ratio >= 0.8:
            return Action.C
        if health_ratio < 0.6 and defection_rate > 0.5:
            return Action.D
        if health_ratio >= 0.6:
            return Action.C
        if 0.3 <= health_ratio < 0.6:
            return Action.C
        return Action.C

    def _compute_defection_rate(self, history: PlayerHistory) -> float:
        """
        Compute the observed defection rate from all opponents across all observed rounds.
        
        Returns:
            defection_rate (float): Proportion of defections observed, or 0 if no history.
        """
        if history.opponent_actions.size == 0:
            return 0.0
        total_actions = history.opponent_actions.size
        defection_count = np.sum(history.opponent_actions == False)
        defection_rate = float(defection_count / total_actions) if total_actions > 0 else 0.0
        return defection_rate

class Strategy_COLLECTIVE_507(BaseStrategy):
    """
    Adaptive Sustainability Management (ASM): A stock-conditional strategy that prioritizes
    long-term resource sustainability while protecting against exploitation through adaptive
    defection detection and smoothed response mechanisms.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainable_threshold = self.capacity * 0.6
        self.critical_threshold = self.capacity * 0.15
        self.tolerance_threshold = 0.4
        self.smoothing_alpha = 0.7
        self.smoothed_defection_rate = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            if current_stock > self.sustainable_threshold:
                return Action.C
            else:
                return Action.D
        if current_stock > self.sustainable_threshold:
            return Action.C
        if current_stock <= self.critical_threshold:
            return Action.D
        smoothed_rate = self._calculate_smoothed_defection_rate(history, current_round)
        if smoothed_rate > self.tolerance_threshold:
            return Action.D
        else:
            return Action.C

    def _calculate_smoothed_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the smoothed defection rate from previous rounds.
        Smoothing prevents overreaction to single outlier rounds.
        """
        if current_round == 0:
            return 0.0
        previous_rounds = history.opponent_actions[:current_round, :]
        total_actions = previous_rounds.size
        if total_actions == 0:
            return 0.0
        num_defections = np.sum(previous_rounds == False)
        current_defection_rate = num_defections / total_actions
        smoothed_rate = self.smoothing_alpha * self.smoothed_defection_rate + (1.0 - self.smoothing_alpha) * current_defection_rate
        self.smoothed_defection_rate = smoothed_rate
        return smoothed_rate

class Strategy_COLLECTIVE_508(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection.
    
    Prioritizes long-term collective sustainability while protecting against exploitation.
    Uses stock level and historical defection rates to decide between cooperation and defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.sustainability_threshold = self.capacity * 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            if current_stock <= 0:
                return Action.C
            return Action.D
        if current_stock <= 0:
            return Action.C
        if current_stock >= self.capacity:
            return Action.C
        observed_defection_rate = self._calculate_defection_rate(history, round_number)
        if current_stock > self.sustainability_threshold:
            if observed_defection_rate <= 0.3:
                return Action.C
            elif observed_defection_rate > 0.5:
                return Action.D
            else:
                strong_position = current_stock > self.sustainability_threshold + 0.25 * self.capacity
                if strong_position:
                    return Action.C
                else:
                    return Action.D
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the aggregate defection rate across all opponents over observed rounds.
        Returns the proportion of rounds (so far) where at least one opponent played D.
        """
        if round_number <= 0:
            return 0.0
        rounds_with_defection = 0
        for round_idx in range(round_number):
            any_defected = not np.all(history.opponent_actions[round_idx, :])
            if any_defected:
                rounds_with_defection += 1
        defection_rate = rounds_with_defection / round_number
        return defection_rate

class Strategy_COLLECTIVE_509(BaseStrategy):
    """
    Adaptive Stewardship Strategy for Common Pool Resource Games.
    
    Prioritizes sustainable collective flourishing by dynamically adjusting
    between cooperation and defection based on stock health, opponent behavior,
    and game phase. Maintains resource sustainability while remaining robust
    to free-riders through adaptive thresholds and stock momentum tracking.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_upper_base = 0.75 * self.capacity
        self.threshold_recovery = 0.3 * self.capacity
        self.threshold_critical = 0.15 * self.capacity
        if self.n_players <= 3:
            self.threshold_upper_base *= 0.9
            self.threshold_recovery *= 0.9
            self.threshold_critical *= 0.9

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        current_round = state.round_number
        total_opponent_actions = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
        if total_opponent_actions > 0:
            opponent_cooperations = np.sum(history.opponent_actions)
            defection_rate = 1.0 - opponent_cooperations / total_opponent_actions
        else:
            defection_rate = 0.0
        threshold_upper = self.threshold_upper_base
        if defection_rate > 0.7:
            threshold_upper = 0.65 * self.capacity
            if self.n_players <= 3:
                threshold_upper *= 0.9
        stock_momentum_penalty = False
        if current_round > 0:
            previous_stock = history.my_payoffs[current_round - 1] if current_round > 0 else current_stock
            if current_round == 1:
                previous_stock = self.capacity
            else:
                total_previous_round = np.sum(history.opponent_actions[current_round - 1, :])
                if history.my_actions[current_round - 1]:
                    total_previous_round += 1
                previous_stock = current_stock
            if previous_stock > 0.001:
                stock_change_rate = (current_stock - previous_stock) / previous_stock
                if stock_change_rate < -0.1:
                    stock_momentum_penalty = True
        if current_stock < 0.05 * self.capacity:
            return Action.C
        if stock_momentum_penalty:
            return Action.C
        if current_stock > threshold_upper:
            return Action.C
        elif current_stock <= self.threshold_critical:
            return Action.C
        elif current_round == self.n_rounds - 1:
            if current_stock > self.threshold_recovery:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_510(BaseStrategy):
    """
    Collective Resource Stewardship Strategy: A stock-state-dependent cooperation approach
    that prioritizes long-term collective sustainability while extracting terminal value.
    
    Core logic:
    - Cooperate when stock is critical (≤20% capacity) for recovery
    - Cooperate in mid-game (rounds remaining ≥2) to sustain the commons
    - Defect only in final round if stock is healthy (>20% capacity)
    - Otherwise cooperate to maintain sustainable growth trajectory
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio <= 0.2:
            return Action.C
        if rounds_remaining == 1:
            if stock_ratio > 0.2:
                return Action.D
            else:
                return Action.C
        if stock_ratio > 0.5:
            return Action.C
        if 0.2 < stock_ratio <= 0.5:
            if rounds_remaining >= 2:
                return Action.C
            else:
                return Action.D if stock_ratio > 0.2 else Action.C
        return Action.C

class Strategy_COLLECTIVE_511(BaseStrategy):
    """
    Adaptive Stock Stewardship (ASS): A threshold-based strategy that monitors
    common pool stock health and adjusts cooperation dynamically based on:
    1. Current stock ratio relative to capacity
    2. Rounds remaining (endgame behavior)
    3. Historical depletion rates (trend analysis)
    4. Group size effects
    
    Core insight: Cooperate when stock is healthy; defect when depletion is
    inevitable or imminent. Maximizes long-term payoffs through enlightened
    self-interest rather than blind cooperation or defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        rounds_left = self.n_rounds - current_round
        if rounds_left <= 1:
            return Action.D
        if current_stock <= 0.1 * self.capacity:
            return Action.D
        if rounds_left <= 2:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        coop_threshold_high = 0.75
        coop_threshold_mid = 0.5
        coop_threshold_low = 0.25
        if rounds_left <= math.ceil(self.n_rounds / 3):
            coop_threshold_high -= 0.15
            coop_threshold_mid -= 0.15
            coop_threshold_low -= 0.15
        if self.n_players >= 8:
            coop_threshold_high += 0.1
            coop_threshold_mid += 0.1
            coop_threshold_low += 0.1
        elif self.n_players == 2:
            coop_threshold_high -= 0.1
            coop_threshold_mid -= 0.1
            coop_threshold_low -= 0.1
        if current_round > 1 and history is not None:
            stock_last_round = history.opponent_payoffs[current_round - 1, 0] * self.n_players
            if current_round >= 2:
                recent_payoffs = history.my_payoffs[current_round - 2:current_round]
                if len(recent_payoffs) >= 2 and recent_payoffs[0] > 0:
                    depletion_rate = 1.0 - recent_payoffs[-1] / recent_payoffs[-2]
                    if depletion_rate > 0.4:
                        coop_threshold_high -= 0.15
                        coop_threshold_mid -= 0.15
                    elif depletion_rate < 0.1:
                        coop_threshold_high += 0.1
                        coop_threshold_mid += 0.1
        if stock_ratio > coop_threshold_high:
            return Action.C
        elif stock_ratio > coop_threshold_mid:
            return Action.C
        elif stock_ratio > coop_threshold_low:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_512(BaseStrategy):
    """
    Adaptive Stewardship with Conditional Defection.
    
    Balances three objectives: (1) preserving the common pool for long-term value,
    (2) protecting against exploitation by defectors, and (3) maximizing collective
    welfare when conditions permit cooperation.
    
    Decision logic:
    - Round 0 (first): Always cooperate to establish baseline
    - Final round: Always defect (backward induction)
    - Stock >= 65% capacity: Cooperate (healthy zone)
    - Stock < 25% capacity: Defect (critical zone)
    - 25%-65% capacity: Monitor depletion rate
      - If depletion_rate > 20%: Defect (overexploitation detected)
      - Otherwise: Cooperate (sustainable trajectory)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.sustainability_threshold = 0.65 * game_description.capacity
        self.danger_threshold = 0.25 * game_description.capacity
        self.depletion_rate_threshold = 0.2
        if game_description.n_players == 2:
            self.sustainability_threshold = 0.6 * game_description.capacity
        elif game_description.n_players >= 10:
            self.sustainability_threshold = 0.7 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock >= self.sustainability_threshold:
            return Action.C
        if current_stock < self.danger_threshold:
            return Action.D
        previous_stock = self._get_previous_stock(state, history)
        if previous_stock <= 0:
            depletion_rate = 0.0
        else:
            depletion_rate = (previous_stock - current_stock) / previous_stock
        if depletion_rate > self.depletion_rate_threshold:
            return Action.D
        else:
            return Action.C

    def _get_previous_stock(self, state: CommonPoolState, history: PlayerHistory) -> float:
        """
        Reconstruct the previous round's stock level before consumption.
        
        Working backward from current stock and consumption patterns.
        """
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round <= 0:
            return self.game_description.capacity
        my_action_prev = history.my_actions[current_round - 1]
        opponent_actions_prev = history.opponent_actions[current_round - 1, :]
        cooperators = int(my_action_prev) + int(np.sum(opponent_actions_prev))
        defectors = self.game_description.n_players - cooperators
        stock_after_consumption = self._reverse_growth_dynamics(current_stock)
        consumption_per_cooperator = stock_after_consumption / (2 * self.game_description.n_players)
        consumption_per_defector = stock_after_consumption / self.game_description.n_players
        total_consumption = cooperators * consumption_per_cooperator + defectors * consumption_per_defector
        previous_stock = stock_after_consumption + total_consumption
        return previous_stock

    def _reverse_growth_dynamics(self, current_stock: float) -> float:
        """
        Reverse the stock growth dynamics to find stock_after_consumption.
        
        Given: new_stock = min(stock_after_consumption + growth, capacity)
        where growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
        
        Solve for stock_after_consumption given current_stock (new_stock).
        """
        capacity = self.game_description.capacity
        if current_stock >= capacity:
            return self._solve_growth_inverse(current_stock, capacity)
        a = 2.0 / capacity
        b = -3.0
        c = current_stock
        discriminant = b * b - 4 * a * c
        if discriminant < 0:
            return current_stock
        sqrt_disc = math.sqrt(discriminant)
        sol1 = (-b + sqrt_disc) / (2 * a)
        sol2 = (-b - sqrt_disc) / (2 * a)
        if 0 <= sol1 <= capacity:
            return sol1
        if 0 <= sol2 <= capacity:
            return sol2
        return current_stock

    def _solve_growth_inverse(self, target_stock: float, capacity: float) -> float:
        """
        Numerically solve for stock_after_consumption given target stock after growth.
        Uses bisection method.
        """

        def growth_result(s):
            if s <= 0 or s > capacity:
                return 0
            growth = 2 * s * (1 - s / capacity)
            return min(s + growth, capacity)
        low, high = (0.0, capacity)
        for _ in range(50):
            mid = (low + high) / 2.0
            result = growth_result(mid)
            if result < target_stock:
                low = mid
            else:
                high = mid
        return (low + high) / 2.0

class Strategy_EXPLOITATIVE_1(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Defection
    
    Prioritizes personal payoff maximization by exploiting the asymmetry between
    C and D actions. Defaults to defection except when stock depletion becomes critical,
    with adaptive opponent modeling and endgame acceleration.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round >= self.n_rounds - 2:
            return Action.D
        if current_round == 0:
            return Action.D
        critical_threshold = self.capacity * 0.15
        if stock <= critical_threshold:
            cooperators_last_round = int(sum(history.opponent_actions[-1, :]))
            total_opponents = self.n_players - 1
            if total_opponents > 0:
                cooperator_fraction = cooperators_last_round / total_opponents
                if cooperator_fraction < 0.5:
                    return Action.D
                else:
                    rounds_remaining = self.n_rounds - current_round
                    if rounds_remaining > 2:
                        return Action.C
                    else:
                        return Action.D
        if stock > self.capacity * 0.9:
            return Action.D
        for opponent_idx in range(self.n_players - 1):
            opponent_cooperations = int(sum(history.opponent_actions[:current_round, opponent_idx]))
            coop_rate = opponent_cooperations / current_round if current_round > 0 else 0
            if coop_rate >= 0.8:
                return Action.D
        total_cooperations = 0
        total_opponent_rounds = (self.n_players - 1) * current_round
        if total_opponent_rounds > 0:
            for opponent_idx in range(self.n_players - 1):
                total_cooperations += int(sum(history.opponent_actions[:current_round, opponent_idx]))
            avg_coop_rate = total_cooperations / total_opponent_rounds
            if avg_coop_rate < 0.4:
                if current_round % 4 == 0:
                    return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_2(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Dynamic Thresholds
    
    Systematically exploits the asymmetry between cooperation (payoff stock/(2n))
    and defection (payoff stock/n) by dynamically switching based on stock levels
    and remaining rounds. Uses adaptive thresholds that respond to opponent behavior
    to maximize defection while preventing stock collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        remaining_rounds = self.n_rounds - round_number
        if round_number == 0:
            return Action.D
        if remaining_rounds <= 1:
            if current_stock > 0.1:
                return Action.D
            else:
                return Action.C
        if remaining_rounds <= 3:
            f_value = 0.15
        elif remaining_rounds <= 5:
            f_value = 0.25
        else:
            f_value = 0.4
        base_threshold = self.capacity * f_value
        threshold = base_threshold
        if history is not None and len(history.opponent_actions) > 0:
            recent_rounds_to_check = min(2, len(history.opponent_actions))
            defection_count = 0
            total_observations = 0
            for round_idx in range(len(history.opponent_actions) - recent_rounds_to_check, len(history.opponent_actions)):
                if round_idx >= 0:
                    defectors_in_round = np.sum(history.opponent_actions[round_idx, :] == False)
                    defection_count += defectors_in_round
                    total_observations += self.n_players
            if total_observations > 0:
                defection_rate = defection_count / total_observations
            else:
                defection_rate = 0.5
            threshold_modifier = 1.0
            if defection_rate > 2.0 / self.n_players:
                threshold_modifier = 1.3
            elif defection_rate < 1.0 / self.n_players:
                threshold_modifier = 0.7
            threshold = base_threshold * threshold_modifier
        if current_stock < 1.0:
            return Action.C
        if current_stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_3(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State Collapse
    
    Maximizes extraction from the common pool by:
    1. Defecting aggressively when stock is healthy (>75% capacity)
    2. Switching to conditional defection in mid-game based on remaining rounds
    3. Always defecting in the final round
    4. Only cooperating when stock approaches collapse threshold (≤2n)
    
    This strategy exploits cooperators, triggers inevitable collapse early,
    and captures disproportionate value from high-stock early rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == self.n_rounds - 1:
            return Action.D
        collapse_threshold = 2 * self.n_players
        if stock <= collapse_threshold:
            return Action.C
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        rounds_remaining = self.n_rounds - round_num
        if stock_ratio > 0.75:
            return Action.D
        if stock_ratio > 0.4:
            if rounds_remaining > 2:
                return Action.D
            else:
                return Action.C
        if stock > collapse_threshold:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_4(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State-Aware Defection
    
    Treats cooperation as a resource to exploit. Defects strategically based on:
    1. Pool health (stock/capacity ratio)
    2. Round timing (early dominance, endgame extraction)
    3. Opponent defection rates (exploit cooperators, compete with defectors)
    4. Terminal conditions (always defect in final rounds)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock_s = state.current_stock
        if round_t == 0:
            return Action.D
        if round_t == self.n_rounds - 1:
            return Action.D
        if round_t >= 2 * self.n_rounds / 3:
            return Action.D
        stock_ratio = stock_s / self.capacity if self.capacity > 0 else 0.0
        if round_t <= self.n_rounds / 3:
            return Action.D
        if stock_ratio < 0.25 or stock_ratio > 0.75:
            return Action.D
        opponent_defection_rate = self._calculate_opponent_defection_rate(history)
        if opponent_defection_rate > 0.4:
            return Action.D
        return Action.C

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the defection rate of opponents across all observed rounds.
        True = Cooperate (C), False = Defect (D)
        Defection rate = (total defections) / (total observed actions)
        """
        if history.opponent_actions.size == 0:
            return 0.0
        total_defections = np.sum(~history.opponent_actions)
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.0
        defection_rate = float(total_defections) / float(total_actions)
        return defection_rate

class Strategy_EXPLOITATIVE_5(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Resource Collapse Management
    
    Defects selectively based on stock health thresholds while maintaining just enough
    cooperation to prevent total collapse. Maximizes personal extraction through:
    - Aggressive defection when stock is healthy or critically depleted
    - Conditional defection in middle zones based on sustainability scoring
    - Endgame aggression (increased defection in final rounds)
    - No mercy mechanisms (pure exploitation, not reciprocal)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.depletion_threshold = 2 * self.n
        self.sustainability_threshold = 0.65 * self.capacity
        self.sustainability_floor = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        sustainability_floor = self.sustainability_floor
        if round_num >= self.n_rounds - 2:
            sustainability_floor = self.sustainability_floor * 0.5
        if round_num == self.n_rounds - 1:
            return Action.D
        if stock <= self.depletion_threshold:
            return Action.D
        if stock >= self.sustainability_threshold:
            return Action.D
        stock_after_defection = stock - stock / self.n
        if stock_after_defection > 0:
            predicted_growth = 2 * stock_after_defection * (1 - stock_after_defection / self.capacity)
        else:
            predicted_growth = 0.0
        pool_capacity_check = self.capacity if self.capacity > 0 else 1
        recovery_score = (stock_after_defection + predicted_growth) / pool_capacity_check
        if recovery_score >= sustainability_floor:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_6(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy
    
    Maximizes personal extraction by:
    1. Assessing stock health (tier-based thresholds)
    2. Classifying opponent cooperation rates (OCR)
    3. Applying temporal discounting (endgame defection)
    4. Front-loading defection before stock collapse
    
    Core principle: Defection yields 2x immediate payoff of cooperation.
    Default action is DEFECT except in mathematically impossible scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock = state.current_stock
        rounds_remaining = self.n_rounds - round_t
        if rounds_remaining <= 2:
            return Action.D
        if round_t == 0:
            return Action.D
        ocr = self._calculate_opponent_cooperation_rate(history, round_t)
        if ocr >= 0.75:
            return Action.D
        if ocr <= 0.35:
            return Action.D
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio >= 0.65:
            return Action.D
        if stock_ratio >= 0.35:
            collective_defection_rate = self._calculate_collective_defection_rate(history, round_t)
            if ocr > 0.5 and collective_defection_rate > (self.n_players - 1) * 0.4:
                return Action.D
            elif ocr < 0.5:
                return Action.D
            else:
                return Action.D
        return Action.D

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory, round_t: int) -> float:
        """
        Calculate opponent cooperation rate (OCR) across observed rounds.
        OCR = (rounds where opponent played C) / (rounds observed)
        """
        if round_t == 0:
            return 0.5
        total_cooperations = np.sum(history.opponent_actions[:round_t, :])
        total_observations = round_t * (self.n_players - 1)
        if total_observations == 0:
            return 0.5
        ocr = total_cooperations / total_observations
        return ocr

    def _calculate_collective_defection_rate(self, history: PlayerHistory, round_t: int) -> float:
        """
        Calculate the rate of defections among all opponents across all rounds.
        Used to detect accelerating stock depletion via collective defection.
        """
        if round_t == 0:
            return 0.0
        total_defections = np.sum(~history.opponent_actions[:round_t, :])
        total_observations = round_t * (self.n_players - 1)
        if total_observations == 0:
            return 0.0
        defection_rate = total_defections / total_observations
        return defection_rate

class Strategy_EXPLOITATIVE_7(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Selective Cooperation
    
    Maximizes personal payoff by exploiting the asymmetry between C and D actions.
    Adaptively calibrates between exploitation and measured cooperation based on
    stock health and opponent behavior signals.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_coop_counts = [0] * (self.n_players - 1)
        self.opponent_total_rounds = [0] * (self.n_players - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decision rule based on stock level, opponent behavior, and round position.
        """
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == 0:
            if self.capacity >= 16:
                return Action.D
            else:
                return Action.C
        if current_stock <= 0:
            return Action.C
        self._update_opponent_history(history, current_round)
        rounds_remaining = self.n_rounds - current_round
        defection_ratio = self._calculate_defection_ratio(history, current_round)
        if current_stock > self.capacity * 0.6:
            return Action.D
        if current_stock <= self.capacity * 0.2:
            return Action.C
        if rounds_remaining <= 2:
            return Action.D
        if rounds_remaining <= self.n_rounds / 3 and current_stock > self.capacity * 0.5:
            return Action.D
        if defection_ratio >= 0.5:
            return Action.D
        if defection_ratio <= 0.25:
            return Action.D
        return Action.C

    def _update_opponent_history(self, history: PlayerHistory, current_round: int) -> None:
        """
        Update tracking of per-opponent cooperation frequency from previous round.
        """
        if current_round > 0:
            prev_round_idx = current_round - 1
            opponent_actions = history.opponent_actions[prev_round_idx, :]
            for opp_idx in range(len(self.opponent_coop_counts)):
                if opponent_actions[opp_idx]:
                    self.opponent_coop_counts[opp_idx] += 1
                self.opponent_total_rounds[opp_idx] += 1

    def _calculate_defection_ratio(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the ratio of defectors in the previous round.
        Returns a value between 0 and 1.
        """
        if current_round == 0:
            return 0.0
        prev_round_idx = current_round - 1
        opponent_actions = history.opponent_actions[prev_round_idx, :]
        defectors = np.sum(~opponent_actions)
        total_opponents = len(opponent_actions)
        if total_opponents == 0:
            return 0.0
        return float(defectors) / float(total_opponents)

class Strategy_EXPLOITATIVE_8(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Collapse Management
    
    Exploits cooperative players systematically while managing stock depletion.
    Uses dynamic thresholds that tighten over time, defecting aggressively in early-to-mid rounds
    and unconditionally in final rounds. Only cooperates when stock reaches critical levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.D
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= 2:
            return Action.D
        critical_level = self.capacity * 0.1
        if stock <= critical_level:
            return Action.C
        primary_threshold = self.capacity * (rounds_remaining / self.n_rounds)
        minimum_threshold = self.capacity * 0.15
        primary_threshold = max(primary_threshold, minimum_threshold)
        if stock > primary_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_9(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Collapse Hedging
    
    Core philosophy: Exploit cooperative tendencies while maintaining plausible deniability.
    Extract maximum value from defection, but avoid total resource collapse.
    Uses stock thresholds, round counters, and opponent behavior to decide between
    defection (extraction) and cooperation (recovery exploitation).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decision logic for each round.
        
        Returns Action.D (DEFECT) or Action.C (COOPERATE) based on:
        1. Current stock ratio relative to capacity
        2. Round number (endgame extraction, early exploitation)
        3. Opponent actions in previous round (retaliation)
        4. Collapse prevention threshold
        """
        round_num = state.round_number
        current_stock = state.current_stock
        capacity = self.capacity
        stock_ratio = current_stock / capacity if capacity > 0 else 0.0
        if stock_ratio < 0.15:
            return Action.C
        if round_num == 0:
            return Action.D
        if round_num > self.n_rounds - 2:
            return Action.D
        if round_num <= 1 and stock_ratio >= 0.8:
            return Action.D
        if history is not None:
            opponent_actions_last_round = history.opponent_actions[-1, :]
            any_opponent_defected = np.any(opponent_actions_last_round == False)
            if any_opponent_defected:
                return Action.D
        if stock_ratio > 0.5:
            return Action.D
        if 0.2 <= stock_ratio <= 0.5:
            if history is not None:
                opponent_actions_last_round = history.opponent_actions[-1, :]
                all_opponents_cooperated = np.all(opponent_actions_last_round == True)
                if all_opponents_cooperated:
                    return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_10(BaseStrategy):
    """
    Aggressive Depletion Strategy: Exploitative approach that defaults to defection
    to maximize personal extraction from the common pool resource.
    
    Core principle: Defect relentlessly to extract maximum payoff, exploit cooperative
    opponents, and ensure capture of resources before pool depletion. Treats cooperation
    as exploitability signal rather than mutual benefit opportunity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decision logic for aggressive depletion strategy.
        
        Default action: DEFECT in virtually all scenarios
        - Round 0: Defect to establish high extraction baseline
        - Terminal rounds: Defect (no future consequences)
        - Stock depletion < 30% capacity: Defect (extract before collapse)
        - All other cases: Defect (payoff dominance of 2x cooperation)
        """
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.3 * self.capacity:
            return Action.D
        if state.round_number >= self.n_rounds - 2:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_11(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Resource Tracking
    
    Defects by default to maximize immediate payoff, while strategically cooperating
    only when stock depletion threatens future extraction opportunities. Identifies
    and relentlessly exploits consistent cooperators while matching defectors to
    avoid unilateral exploitation. Unconditionally defects in final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num <= 1:
            return Action.D
        opponent_defection_rate = self._calculate_defection_frequency(history)
        stock_depletion_risk = self._assess_stock_sustainability(current_stock, opponent_defection_rate)
        rounds_remaining = self.n_rounds - round_num
        if stock_depletion_risk == 'CRITICAL':
            if rounds_remaining <= 2:
                return Action.D
            else:
                return Action.C
        exploitable_cooperators = self._count_consistent_cooperators(history)
        if opponent_defection_rate >= 0.6:
            return Action.D
        elif opponent_defection_rate <= 0.3:
            return Action.D
        elif current_stock > self.capacity * 0.4:
            return Action.D
        else:
            return Action.C

    def _calculate_defection_frequency(self, history: PlayerHistory) -> float:
        """Calculate the proportion of defections by opponents across all rounds."""
        if history.opponent_actions.shape[0] == 0:
            return 0.0
        total_actions = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
        if total_actions == 0:
            return 0.0
        defection_count = np.sum(~history.opponent_actions)
        return float(defection_count) / float(total_actions)

    def _assess_stock_sustainability(self, current_stock: float, opponent_defection_rate: float) -> str:
        """
        Assess whether stock will sustainably survive remaining rounds.
        Returns: "CRITICAL", "WARNING", or "HEALTHY"
        """
        if current_stock <= 0:
            return 'CRITICAL'
        expected_cooperators = self.n_players * (1 - opponent_defection_rate)
        expected_defectors = self.n_players * opponent_defection_rate
        estimated_consumption = expected_cooperators * (current_stock / (2 * self.n_players)) + expected_defectors * (current_stock / self.n_players)
        if current_stock < self.capacity * 0.15:
            return 'CRITICAL'
        elif current_stock < self.capacity * 0.3:
            return 'WARNING'
        else:
            return 'HEALTHY'

    def _count_consistent_cooperators(self, history: PlayerHistory) -> int:
        """
        Count opponents who have cooperated consistently (defection rate < 20%).
        These are exploitable targets.
        """
        if history.opponent_actions.shape[0] == 0:
            return 0
        n_opponents = history.opponent_actions.shape[1]
        consistent_cooperators = 0
        for opponent_idx in range(n_opponents):
            opponent_history = history.opponent_actions[:, opponent_idx]
            cooperation_rate = np.mean(opponent_history)
            defection_rate = 1.0 - cooperation_rate
            if defection_rate < 0.2:
                consistent_cooperators += 1
        return consistent_cooperators

class Strategy_EXPLOITATIVE_12(BaseStrategy):
    """
    Adaptive Predation: Exploits cooperative players by defecting when cooperation
    rates are high and pool stock is healthy. Strategically cooperates only when
    stock collapse is imminent to preserve future extraction opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if current_stock < self.n_players:
            return Action.C
        opponent_actions_prev = history.opponent_actions[round_num - 1, :]
        coop_count = np.sum(opponent_actions_prev)
        cooperation_rate = coop_count / (self.n_players - 1) if self.n_players > 1 else 0.0
        progress_ratio = round_num / self.n_rounds
        threshold = 0.3 + 0.2 * progress_ratio
        remaining_rounds = self.n_rounds - round_num
        danger_level = self.capacity * remaining_rounds / (2.0 * self.n_rounds)
        if round_num == self.n_rounds - 2:
            return Action.D
        if cooperation_rate > threshold:
            return Action.D
        elif current_stock < danger_level:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_13(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Controlled Depletion
    
    Maximizes personal payoff by defecting when stock levels permit, while
    cooperating strategically to prevent complete pool collapse. Uses a dynamic
    threshold that descends from 50% to 10% capacity across rounds, with
    secondary rules for high defection rates and endgame scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decision logic based on current stock, round number, and historical defection rates.
        """
        stock = state.current_stock
        round_num = state.round_number
        threshold = self.capacity * (0.5 - 0.4 * (round_num / self.n_rounds))
        if round_num == self.n_rounds - 1:
            return Action.D
        if round_num == self.n_rounds - 2:
            if stock > 2 * threshold:
                return Action.D
            else:
                return Action.C
        if stock <= 0.1 * self.capacity:
            return Action.C
        if stock > 0.9 * self.capacity:
            return Action.D
        if history is not None:
            defectors_last_round = np.sum(~history.opponent_actions[-1, :])
            defection_rate = defectors_last_round / self.n_players
            if defection_rate >= 0.5 and stock < threshold:
                return Action.C
        if stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_14(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Collapse Management
    
    Core philosophy: Extract maximum individual value while exploiting cooperators' restraint.
    Defect aggressively when profitable, but avoid total collapse to continue exploitation.
    
    Decision logic:
    - Terminal rounds (r-1, r): Always defect
    - Stock critically low (<15% capacity): Cooperate to allow recovery
    - Stock healthy (>=50% capacity): Defect aggressively
    - Stock moderate (15-50%): Conditionally defect based on opponent defection rate
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity * 0.15
        self.healthy_threshold = self.capacity * 0.5
        self.defection_rate_threshold = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num >= self.n_rounds - 2:
            return Action.D
        if current_stock < self.critical_threshold:
            return Action.C
        if current_stock >= self.healthy_threshold:
            return Action.D
        recent_defection_rate = self._calculate_recent_defection_rate(history)
        if recent_defection_rate > self.defection_rate_threshold:
            return Action.D
        return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the defection rate of opponents over the last 3 rounds.
        
        Defection is represented as False (0), so we calculate the rate of False values.
        Returns a value between 0.0 (all cooperating) and 1.0 (all defecting).
        """
        lookback_rounds = min(3, history.opponent_actions.shape[0])
        if lookback_rounds == 0:
            return 0.0
        recent_actions = history.opponent_actions[-lookback_rounds:, :]
        n_defections = np.sum(recent_actions == False)
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        defection_rate = n_defections / total_actions
        return defection_rate

class Strategy_EXPLOITATIVE_15(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Exploits asymmetry between cooperative and defective payoffs while managing
    stock depletion. Treats cooperation as vulnerability to exploit, defecting
    whenever profitable. Only cooperates to prevent stock collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == self.r - 1:
            if stock <= 2 * self.n:
                return Action.C
            return Action.D
        if stock <= 2 * self.n:
            return Action.C
        if round_num == 0:
            return Action.D
        opponent_defections = 0
        total_opponent_actions = 0
        if history is not None and round_num > 0:
            for past_round in range(round_num):
                opponent_actions_this_round = history.opponent_actions[past_round, :]
                opponent_defections += np.sum(~opponent_actions_this_round)
                total_opponent_actions += self.n - 1
        if total_opponent_actions > 0:
            defection_rate = opponent_defections / total_opponent_actions
        else:
            defection_rate = 0.5
        stock_trend = 0
        if history is not None and round_num > 0:
            previous_round_opponent_defections = np.sum(~history.opponent_actions[round_num - 1, :])
            stock_trend = 1 if previous_round_opponent_defections < (self.n - 1) / 2 else -1
        rounds_left = self.r - round_num
        if defection_rate < 0.3:
            return Action.D
        if stock > self.capacity * 0.75:
            return Action.D
        if rounds_left <= 3:
            return Action.D
        if stock_trend < 0 and rounds_left > 2:
            return Action.D
        immediate_payoff_defect = stock / self.n
        immediate_payoff_coop = stock / (2 * self.n)
        immediate_advantage = immediate_payoff_defect - immediate_payoff_coop
        expected_defections = (self.n - 1) * defection_rate + 1.0
        future_stock = self._project_stock_growth(stock, expected_defections)
        if future_stock > self.capacity * 0.5 and rounds_left > 1:
            future_value = future_stock / (2 * self.n) * (rounds_left - 1) * 0.8
        else:
            future_value = 0.0
        exploit_threshold = 1.2
        if immediate_advantage > exploit_threshold * future_value:
            return Action.D
        return Action.D

    def _project_stock_growth(self, stock: float, num_defections: float) -> float:
        """
        Project stock level after consumption and growth.
        
        Args:
            stock: Current stock level
            num_defections: Expected number of defections (can be fractional)
        
        Returns:
            Projected stock after one round of consumption and growth
        """
        coop_consumption = stock / (2 * self.n)
        defect_consumption = stock / self.n
        num_cooperations = self.n - num_defections
        total_consumption = num_cooperations * coop_consumption + num_defections * defect_consumption
        total_consumption = max(0.0, min(stock, total_consumption))
        stock_remaining = stock - total_consumption
        if self.capacity > 0:
            growth = 2 * stock_remaining * (1 - stock_remaining / self.capacity)
        else:
            growth = 0.0
        growth = max(0.0, growth)
        new_stock = min(stock_remaining + growth, self.capacity)
        return new_stock

class Strategy_EXPLOITATIVE_16(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Defection
    
    Exploits asymmetry between cooperators and defectors by:
    1. Always defecting in round 1 and final round
    2. Using stock levels and opponent cooperation rates to guide decisions
    3. Targeting consistent cooperators for exploitation
    4. Adapting to prevent predictable punishment
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = self.capacity * (2 / 3)
        self.threshold_medium = self.capacity * (1 / 3)
        self.threshold_low = 2 * self.n * 1.5
        self.cooperation_threshold = 0.6

    def _calculate_weighted_cooperation_rate(self, opponent_actions: NDArray[np.bool_]) -> float:
        """
        Calculate exponentially weighted cooperation rate from opponent history.
        Recent rounds weighted 2x more heavily than older rounds.
        """
        if len(opponent_actions) == 0:
            return 0.0
        n_rounds_seen = len(opponent_actions)
        weights = np.array([2 ** (i - n_rounds_seen + 1) for i in range(n_rounds_seen)])
        weights = weights / np.sum(weights)
        coop_per_round = np.sum(opponent_actions, axis=1) / (self.n - 1)
        weighted_coop_rate = np.sum(weights * coop_per_round)
        return float(weighted_coop_rate)

    def _classify_opponent_pattern(self, opponent_actions: NDArray[np.bool_], opponent_idx: int) -> str:
        """
        Classify opponent strategy based on last 2 rounds of history.
        Returns: "consistent_cooperator", "adapter", or "consistent_defector"
        """
        if len(opponent_actions) < 2:
            return 'adapter'
        last_two = opponent_actions[-2:, opponent_idx]
        if np.all(last_two):
            return 'consistent_cooperator'
        elif np.sum(last_two) == 0:
            return 'consistent_defector'
        else:
            return 'adapter'

    def _check_unanimous_cooperation(self, opponent_actions: NDArray[np.bool_]) -> bool:
        """Check if all opponents cooperated in the previous round."""
        if len(opponent_actions) == 0:
            return False
        last_round = opponent_actions[-1, :]
        return np.all(last_round)

    def _check_unanimous_defection(self, opponent_actions: NDArray[np.bool_]) -> bool:
        """Check if all opponents defected in the previous round."""
        if len(opponent_actions) == 0:
            return False
        last_round = opponent_actions[-1, :]
        return np.sum(last_round) == 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.r - 1:
            return Action.D
        if stock < self.threshold_low:
            return Action.C
        rounds_remaining = self.r - current_round
        if rounds_remaining <= 2:
            return Action.D
        opponent_actions = history.opponent_actions if history is not None else np.array([])
        coop_rate = self._calculate_weighted_cooperation_rate(opponent_actions)
        unanimous_coop = self._check_unanimous_cooperation(opponent_actions)
        unanimous_defect = self._check_unanimous_defection(opponent_actions)
        if unanimous_coop and stock > self.threshold_medium:
            return Action.D
        if unanimous_defect:
            return Action.D
        if stock > self.threshold_high:
            return Action.D
        elif stock > self.threshold_medium:
            if coop_rate > self.cooperation_threshold:
                return Action.D
            else:
                return Action.C
        elif coop_rate > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_17(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Maximizes personal extraction by defecting aggressively across all rounds,
    with adaptive responses to stock depletion rates. Recognizes that defection
    yields 2x cooperation payoff and exploits both cooperators and defectors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = [game_description.capacity]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if history is not None:
            self.stock_history.append(current_stock)
        if current_round == n_rounds - 1:
            return Action.D
        if current_stock > capacity * 0.6:
            return Action.D
        elif current_stock > capacity * 0.3:
            return Action.D
        else:
            if history is not None and len(self.stock_history) >= 2:
                prev_stock = self.stock_history[-2]
                if prev_stock > 0:
                    depletion_rate = (prev_stock - current_stock) / prev_stock
                    if depletion_rate > 0.7:
                        return Action.D
            return Action.D

class Strategy_EXPLOITATIVE_18(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    This strategy exploits the common pool by:
    1. Always defecting in the first round to establish dominance
    2. Using stock levels to determine exploitation aggressiveness
    3. Defecting opportunistically against cooperators when stock allows recovery
    4. Joining defection arms races when detected
    5. Implementing end-game exploitation in final rounds
    6. Adapting thresholds based on group defection rates
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == self.n_rounds - 1:
            return Action.D
        if round_num == self.n_rounds - 2:
            if stock >= self.capacity * 0.3:
                return Action.D
        if round_num == 0:
            return Action.D
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        last_round_opponent_actions = history.opponent_actions[round_num - 1, :]
        cooperators_last_round = np.sum(last_round_opponent_actions)
        defection_rate_last_round = (self.n_players - cooperators_last_round) / self.n_players if self.n_players > 0 else 0.0
        threshold_upper = 0.75
        threshold_middle_low = 0.5
        threshold_lower = 0.25
        if defection_rate_last_round > 0.6:
            threshold_upper = max(0.0, threshold_upper - 0.1)
            threshold_middle_low = max(0.0, threshold_middle_low - 0.1)
        if stock_ratio > threshold_upper:
            return Action.D
        elif stock_ratio > threshold_middle_low and stock_ratio <= threshold_upper:
            if defection_rate_last_round > 0.5:
                return Action.D
            else:
                return Action.D
        elif stock_ratio > threshold_lower:
            return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_19(BaseStrategy):
    """
    Adaptive Extraction with Depletion Monitoring.
    
    Exploits the asymmetry between cooperative and defective payoffs while monitoring
    stock depletion. Defects when stock is healthy relative to a time-adjusted threshold,
    cooperates when stock is depleted or in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.previous_stock = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            return Action.D
        if rounds_remaining == 1:
            return Action.D
        if current_stock < 2 * self.n_players:
            return Action.C
        base_threshold = self.capacity / self.n_players
        time_adjustment = rounds_remaining / self.n_rounds
        threshold = base_threshold * (1.0 + time_adjustment)
        depletion_rate = 0.0
        if self.previous_stock > 0:
            depletion_rate = (self.previous_stock - current_stock) / self.previous_stock
        if depletion_rate > 0.5:
            threshold *= 0.9
        self.previous_stock = current_stock
        if current_stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_20(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Restraint
    
    Maximizes personal extraction through consistent defection while using a 
    dynamically-calibrated stock threshold to prevent resource collapse.
    Cooperates only when stock depletion risk becomes material or critical.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.previous_stock = None
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.r - current_round
        if current_stock >= 0:
            self.stock_history.append(current_stock)
        if current_round == 0:
            return Action.D
        if rounds_remaining == 0:
            return Action.D
        if current_stock <= self.n:
            return Action.C
        threshold = 2 * self.n * (1 + rounds_remaining / self.r)
        if len(self.stock_history) >= 2:
            prev_stock = self.stock_history[-2]
            if prev_stock > 0:
                consumption_rate = (prev_stock - current_stock) / prev_stock
                if consumption_rate > 0.3:
                    threshold *= 1.1
                elif consumption_rate < 0.15:
                    threshold *= 0.95
        if current_stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_21(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Extracts maximum personal value by exploiting asymmetry between cooperative
    and defective payoffs. Defects when stock is sustainable, cooperates only
    when necessary to prevent collapse, and always defects in final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.previous_stock = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        late_game_threshold = 0.95 * self.n_rounds
        if current_round >= late_game_threshold:
            return Action.D
        early_game_threshold = self.n_rounds / 3.0
        if current_round < early_game_threshold:
            return Action.D
        observed_coop_rate = self._calculate_cooperation_rate(history)
        stock_change = current_stock - self.previous_stock
        self.previous_stock = current_stock
        critical_threshold = self.capacity * 0.4
        if stock_change < 0:
            critical_threshold = self.capacity * 0.35
        minimum_viable = self.capacity * 0.15
        collapse_point = self.capacity * 0.05
        if current_stock < collapse_point:
            return Action.D
        if current_stock < minimum_viable:
            return Action.C
        if current_stock > critical_threshold:
            if observed_coop_rate > 0.6:
                return Action.D
            return Action.D
        if current_stock <= critical_threshold:
            return Action.C
        return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the empirical cooperation rate of opponents from history.
        Returns a value between 0 and 1.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.5
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.5
        cooperations = np.sum(history.opponent_actions)
        cooperation_rate = float(cooperations) / float(total_actions)
        return cooperation_rate

class Strategy_EXPLOITATIVE_22(BaseStrategy):
    """
    Adaptive Depletion Strategy for Common Pool Resource Game.
    
    Core philosophy: Exploit the common pool by always defecting to extract
    maximum immediate payoff. Defection yields 2× the payoff of cooperation
    in any single round. Adapts to observed defection rates and stock levels
    to time exploitation optimally, but maintains pure defection as dominant strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock_s = state.current_stock
        if round_t == 0:
            return Action.D
        if round_t == self.n_rounds - 1:
            return Action.D
        rounds_remaining = self.n_rounds - round_t
        sustainability_threshold = self.capacity * (rounds_remaining / self.n_rounds) * 0.7
        if history is not None and round_t > 0:
            last_round_opponents = history.opponent_actions[round_t - 1, :]
            defectors_last_round = np.sum(~last_round_opponents)
            defection_rate = defectors_last_round / self.n_players
        else:
            defection_rate = 0.0
        minimum_viable_stock = 2 * self.n_players
        if stock_s < minimum_viable_stock:
            return Action.D
        if stock_s >= self.capacity * 0.95:
            return Action.D
        if stock_s > sustainability_threshold:
            return Action.D
        if stock_s > minimum_viable_stock:
            if defection_rate > 0.3:
                return Action.D
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_23(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Contingent Defection
    
    This strategy exploits the asymmetry between cooperators and defectors by maximizing 
    personal consumption while monitoring whether the resource stock can sustain continued 
    exploitation. It defects unless the stock depletion rate forces temporary cooperation 
    to preserve future extraction opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.extinction_threshold = 2 * self.n
        self.last_threshold = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        remaining_rounds = self.r - round_num
        if round_num == 0:
            return Action.D
        if round_num == self.r - 1:
            return Action.D
        if stock < self.extinction_threshold:
            if remaining_rounds > 2:
                return Action.C
            else:
                return Action.D
        observed_defect_rate = self._calculate_defection_rate(history)
        if remaining_rounds <= 1:
            round_adjusted_threshold = self.capacity
        else:
            round_adjusted_threshold = self.capacity * (1.0 - math.sqrt((remaining_rounds - 1) / self.r))
        if self.last_threshold is not None:
            smoothed_threshold = 0.7 * round_adjusted_threshold + 0.3 * self.last_threshold
        else:
            smoothed_threshold = round_adjusted_threshold
        self.last_threshold = round_adjusted_threshold
        if observed_defect_rate > 0.5:
            return Action.D
        elif stock <= smoothed_threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the observed defection rate from opponent actions.
        Defection is encoded as False (0), Cooperation as True (1).
        Returns the fraction of opponent actions that were defections.
        """
        if history.opponent_actions.size == 0:
            return 0.0
        total_opponent_actions = history.opponent_actions.size
        if total_opponent_actions == 0:
            return 0.0
        defection_count = np.sum(history.opponent_actions == False)
        defection_rate = defection_count / total_opponent_actions
        return float(defection_rate)

class Strategy_EXPLOITATIVE_24(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State-Aware Defection
    
    This strategy maximizes personal payoff by identifying when defection yields
    higher returns, exploiting cooperators before stock depletion, and switching
    to pure defection when the common pool becomes unsustainable.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_number = state.round_number
        total_rounds = self.n_rounds
        if stock < 2 * self.n_players:
            return Action.D
        if round_number == 0:
            return Action.D
        if round_number == total_rounds - 1:
            return Action.D
        rounds_remaining = total_rounds - round_number
        opponent_cooperations = np.sum(history.opponent_actions[:round_number, :])
        total_opponent_actions = round_number * self.n_players
        if total_opponent_actions > 0:
            opponent_cooperation_rate = opponent_cooperations / total_opponent_actions
        else:
            opponent_cooperation_rate = 0.0
        if round_number > 0:
            recent_opponent_cooperation_count = np.sum(history.opponent_actions[round_number - 1, :])
        else:
            recent_opponent_cooperation_count = 0
        consecutive_opponent_defections = 0
        for i in range(round_number - 1, -1, -1):
            if np.sum(history.opponent_actions[i, :]) == 0:
                consecutive_opponent_defections += 1
            else:
                break
        if stock >= self.capacity * 0.6 and recent_opponent_cooperation_count > self.n_players / 2:
            return Action.D
        if stock >= self.capacity * 0.4 and rounds_remaining <= total_rounds / 3:
            return Action.D
        if stock >= 2 * self.n_players and consecutive_opponent_defections <= 1:
            return Action.D
        if stock < self.capacity * 0.3 and opponent_cooperation_rate == 1.0 and (rounds_remaining > total_rounds / 2):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_25(BaseStrategy):
    """
    Adaptive Predation with Sustainability Management.
    
    Exploits cooperative players while maintaining stock sustainability.
    Uses stock thresholds and opponent cooperation rates to decide between
    defection (for exploitation) and cooperation (for sustainability/restoration).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            return Action.D
        if rounds_remaining <= 3:
            if current_stock > self.capacity * 0.01:
                return Action.D
            else:
                return Action.C
        opponent_cooperation_rate = self._calculate_opponent_cooperation_rate(history)
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio > 0.6:
            return Action.D
        elif stock_ratio > 0.3:
            if opponent_cooperation_rate > 0.5:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the average cooperation rate across all opponents from observed history.
        
        Returns a value between 0.0 and 1.0 representing the fraction of times
        opponents cooperated (True = 1, False = 0).
        """
        if history.opponent_actions.size == 0:
            return 0.5
        total_cooperations = np.sum(history.opponent_actions)
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.5
        cooperation_rate = float(total_cooperations) / float(total_actions)
        return cooperation_rate

class Strategy_EXPLOITATIVE_26(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Collapse Prevention
    
    Defects by default to maximize immediate payoff, while selectively cooperating
    when stock approaches critical levels or in the final round to prevent collapse.
    Exploits cooperators' restraint and predictable reciprocal strategies.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        rounds_remaining = self.n_rounds - current_round
        if current_round == self.n_rounds - 1:
            return Action.D
        if stock_ratio < 0.1 and rounds_remaining > 2:
            return Action.C
        if stock_ratio < 0.15:
            return Action.C
        if stock_ratio >= 0.5:
            return Action.D
        if stock_ratio < 0.3:
            cooperation_probability = 0.4 + (0.3 - stock_ratio) * 2.0
            if random.random() < cooperation_probability:
                return Action.C
            return Action.D
        if history is not None and current_round > 0:
            previous_round_cooperators = int(sum(history.opponent_actions[current_round - 1, :]))
            cooperation_rate = previous_round_cooperators / self.n_players
            if cooperation_rate > 0.7:
                return Action.D
            if cooperation_rate < 0.3 and stock_ratio < 0.4:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_27(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Exploitation
    
    Dynamically shifts between exploitation and selective cooperation based on 
    resource state, maximizing total payoff through opportunistic extraction.
    Defects when stock is abundant, cooperates only when mathematically necessary
    for future extraction, and always defects in terminal rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players
        self.threshold_high = self.capacity * 0.7
        self.threshold_low = self.capacity * 0.25
        self.critical_depletion = self.capacity * 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            return Action.D
        if rounds_remaining <= 2:
            return Action.D
        if current_stock <= self.critical_depletion:
            return Action.D
        if current_stock > self.threshold_high:
            return Action.D
        if current_stock <= self.threshold_low:
            return Action.D
        estimated_recovery_rounds = self._estimate_recovery_rounds(current_stock, self.threshold_high)
        time_to_recover = rounds_remaining * 0.4
        if time_to_recover < estimated_recovery_rounds:
            return Action.D
        return Action.C

    def _estimate_recovery_rounds(self, current_stock: float, target_stock: float) -> float:
        """
        Estimate rounds needed to recover from current_stock to target_stock
        using logistic growth: new_stock = old_stock + 2*old_stock*(1 - old_stock/capacity)
        """
        if current_stock >= target_stock:
            return 0.0
        stock = current_stock
        rounds_needed = 0.0
        max_iterations = 100
        for _ in range(max_iterations):
            if stock >= target_stock:
                return rounds_needed
            growth = 2.0 * stock * (1.0 - stock / self.capacity)
            stock = min(stock + growth, self.capacity)
            rounds_needed += 1.0
        return float(max_iterations)

class Strategy_EXPLOITATIVE_28(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Threshold-Based Switching
    
    Core philosophy: Exploit the 2x payoff advantage of defection (S/n vs S/2n).
    In a finite repeated game, the tragedy of the commons is inevitable.
    Strategy accelerates depletion while extracting maximum value through adaptive
    threshold-based switching based on stock health and remaining rounds.
    
    Phase 1 (Early): DEFECT unconditionally to exploit cooperators' restraint
    Phase 2 (Middle): DEFECT with adaptive monitoring of stock depletion
    Phase 3 (Terminal): Maximum extraction defection in final rounds
    
    Key insight: Always defect. The "adaptive" element is in understanding when
    stock is depleted vs healthy, but the action remains invariant—relentless
    extraction maximizes payoff through commons tragedy exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - state.round_number
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        if rounds_remaining <= 2:
            return Action.D
        if current_stock < 2:
            return Action.D
        if stock_health < 0.2:
            return Action.D
        if stock_health < 0.4 and rounds_remaining > self.capacity / 10:
            return Action.D
        if stock_health >= 0.4:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_29(BaseStrategy):
    """
    Adaptive Predation with Stock Tracking: An exploitative strategy that maximizes personal
    consumption while remaining sensitive to stock depletion. Defects aggressively when stock
    is abundant, cooperates only when necessary to prevent commons collapse and enable future
    exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_stock = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        round_number = state.round_number
        rounds_remaining = n_rounds - round_number
        if round_number == 0:
            self.last_stock = current_stock
            return Action.D
        if round_number == n_rounds - 1:
            return Action.D
        stock_ratio = current_stock / capacity if capacity > 0 else 0.0
        if stock_ratio > 0.5:
            self.last_stock = current_stock
            return Action.D
        if stock_ratio > 0.2:
            stock_velocity = current_stock - self.last_stock
            self.last_stock = current_stock
            if stock_velocity < -5:
                return Action.C
            else:
                return Action.D
        if rounds_remaining <= 3:
            self.last_stock = current_stock
            return Action.D
        else:
            self.last_stock = current_stock
            return Action.C

class Strategy_EXPLOITATIVE_30(BaseStrategy):
    """
    Adaptive Predation with State Awareness: Exploitative strategy that maximizes
    personal payoff by exploiting cooperators while adapting to opponent behavior
    and stock levels. Uses stock-contingent defection with opponent modeling.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.r - 1:
            return Action.D
        if current_stock <= 0.5 * self.n:
            return Action.D
        opponent_coop_rates = self._calculate_opponent_coop_rates(history, current_round)
        avg_coop_rate = np.mean(opponent_coop_rates) if len(opponent_coop_rates) > 0 else 0.0
        if current_stock > 1.5 * self.n:
            return Action.D
        elif 0.75 * self.n < current_stock <= 1.5 * self.n:
            if avg_coop_rate > 0.6:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _calculate_opponent_coop_rates(self, history: PlayerHistory, current_round: int) -> list:
        """
        Calculate cooperation rate for each opponent based on observed history.
        Returns a list of cooperation rates, one per opponent.
        """
        if current_round == 0:
            return []
        n_opponents = self.n - 1
        opponent_coop_rates = []
        for opp_idx in range(n_opponents):
            coop_count = np.sum(history.opponent_actions[:current_round, opp_idx])
            coop_rate = coop_count / current_round
            opponent_coop_rates.append(coop_rate)
        return opponent_coop_rates

class Strategy_EXPLOITATIVE_31(BaseStrategy):
    """
    Adaptive Predation with Threshold Exploitation strategy for Common Pool Resource Game.
    
    Exploits cooperators by defecting when they maintain high cooperation rates, switches to 
    conditional cooperation in moderate zones to sustain stock for continued exploitation, and 
    extracts remaining value when stock is depleted or game is ending.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.D
        rounds_remaining = self.n_rounds - round_number
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        opponent_coop_rate = self._calculate_opponent_cooperation_rate(history, round_number)
        if stock_ratio <= 0.15:
            return Action.D
        if rounds_remaining == 1:
            return Action.D
        if current_stock < 5.0 and rounds_remaining > 2:
            return Action.C
        if opponent_coop_rate > 0.6:
            return Action.D
        elif opponent_coop_rate > 0.3:
            return Action.C
        else:
            return Action.D

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the average cooperation rate of opponents up to the current round.
        opponent_actions is indexed [round, player] where True = C (cooperate), False = D (defect)
        """
        if round_number == 0:
            return 0.5
        total_cooperations = np.sum(history.opponent_actions[:round_number, :])
        total_actions = round_number * self.game_description.n_players
        if total_actions == 0:
            return 0.5
        coop_rate = float(total_cooperations) / float(total_actions)
        return coop_rate

class Strategy_EXPLOITATIVE_32(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Core philosophy: Defect by default to exploit the 2x payoff advantage,
    but strategically cooperate only when necessary to prevent resource collapse
    that would destroy future round payoffs. Employs opponent modeling to adapt
    defection rates based on observed behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - round_number
        if round_number == 0:
            return Action.D
        if rounds_remaining <= 2:
            return Action.D
        if current_stock < 1.5 * self.capacity and rounds_remaining > 2:
            avg_opponent_defection = self._calculate_opponent_defection_rate(history)
            if avg_opponent_defection > 0.5:
                return Action.C
            else:
                return Action.D
        if current_stock >= 1.5 * self.capacity:
            return Action.D
        if current_stock < 2 * self.n_players:
            if rounds_remaining > 2:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the average defection rate across all opponents from history.
        True = Cooperate, False = Defect in the action arrays.
        Returns the proportion of defections (0.0 to 1.0).
        """
        if history.opponent_actions.shape[0] == 0:
            return 0.5
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.5
        defection_count = np.sum(~history.opponent_actions)
        defection_rate = float(defection_count) / float(total_actions)
        return defection_rate

class Strategy_EXPLOITATIVE_33(BaseStrategy):
    """
    Adaptive Predation: An exploitative strategy that defaults to defection to extract
    maximum payoff, but conditionally cooperates when stock falls below a dynamic threshold
    to allow pool recovery and enable sustained exploitation across multiple rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.D
        if current_stock <= 0:
            return Action.C
        rounds_remaining = self.n_rounds - round_number
        if round_number == self.n_rounds - 1:
            return Action.D
        if rounds_remaining <= 2:
            threshold = 0.15 - 0.05 * (rounds_remaining / self.n_rounds)
        else:
            threshold = 0.3 - 0.1 * (rounds_remaining / self.n_rounds)
        stock_ratio = current_stock / self.capacity
        if stock_ratio < threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_34(BaseStrategy):
    """
    Adaptive Predation: An exploitative strategy that defects by default,
    adapting to stock levels and opponent behavior to maximize extraction
    from the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining == 1:
            return Action.D
        if current_round == 0:
            return Action.D
        threshold = self.capacity * (0.4 - 0.05 * (rounds_remaining / self.n_rounds))
        if current_stock > threshold:
            return Action.D
        if history is not None and len(history.opponent_actions) > 0:
            total_opponent_actions = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
            if total_opponent_actions > 0:
                cooperator_actions = np.sum(history.opponent_actions)
                cooperation_rate = cooperator_actions / total_opponent_actions
                if cooperation_rate > 0.6:
                    return Action.D
                if history.opponent_actions.shape[0] > 0:
                    last_round_cooperations = np.sum(history.opponent_actions[-1, :])
                    if last_round_cooperations > 0:
                        return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_35(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Sustainability Monitoring
    
    This strategy exploits the asymmetry between cooperative and defective payoffs
    while maintaining enough stock to sustain exploitation across all rounds.
    Balances greedy extraction with pool management through threshold-based decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.min_viable_stock = 2 * self.n + 0.01
        self.safe_defection_threshold = 3 * self.n

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.r - 1:
            return Action.D
        if stock <= self.min_viable_stock:
            return Action.C
        if stock > self.safe_defection_threshold:
            coop_rate = self._compute_cooperation_rate(history, current_round)
            if coop_rate > 0.5:
                return Action.D
            elif current_round % 3 == 0:
                return Action.C
            else:
                return Action.D
        else:
            remaining_rounds = self.r - current_round
            if remaining_rounds <= 2:
                return Action.D
            if stock < 2.5 * self.n:
                return Action.C
            else:
                return Action.D

    def _compute_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Compute the observed cooperation rate of opponents in previous rounds.
        Returns proportion of COOPERATE actions (True values) in opponent history.
        """
        if current_round <= 0:
            return 0.5
        total_actions = history.opponent_actions[:current_round, :].size
        if total_actions == 0:
            return 0.5
        cooperate_count = np.sum(history.opponent_actions[:current_round, :])
        coop_rate = float(cooperate_count) / float(total_actions)
        return coop_rate

class Strategy_EXPLOITATIVE_36(BaseStrategy):
    """
    Adaptive Predatory Harvesting (APH): Exploitative strategy that defects by default
    while maintaining stock above critical thresholds to prevent collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.recovery_mode = False
        self.recovery_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        capacity = self.capacity
        n_rounds = self.n_rounds
        if current_round == n_rounds - 1:
            return Action.D
        collapse_threshold = capacity * 0.15
        if current_stock < collapse_threshold:
            self.recovery_mode = True
            self.recovery_rounds_remaining = min(3, (n_rounds - current_round) // 2)
            return Action.C
        if self.recovery_mode:
            self.recovery_rounds_remaining -= 1
            if self.recovery_rounds_remaining <= 0:
                self.recovery_mode = False
            else:
                return Action.C
        mid_game_threshold = capacity * 0.5
        rounds_until_end = n_rounds - current_round
        if current_stock > mid_game_threshold and rounds_until_end > 2:
            return Action.D
        aggression_threshold = capacity * 0.2
        if current_stock > aggression_threshold and rounds_until_end > 1:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_37(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation
    
    Exploits the asymmetry between cooperative and defective payoffs through:
    1. Surplus extraction when stock is abundant (>60% capacity)
    2. Competitive defection when defection rate is high (≥n/3)
    3. Growth exploitation in mid-game when pools are expanding
    4. Early accumulation in first half while stock is high
    5. Strategic late-game defection except when pool is critically depleted
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = [game_description.capacity]
        self.defection_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            self.stock_history.append(current_stock)
            self.defection_history.append(False)
            return Action.D
        estimated_defectors = self._estimate_defectors(current_stock, capacity, n)
        self.stock_history.append(current_stock)
        if current_stock > capacity * 0.6:
            self.defection_history.append(False)
            return Action.D
        if estimated_defectors >= n / 3.0:
            self.defection_history.append(False)
            return Action.D
        if 2 <= round_num <= r - 2:
            if len(self.stock_history) >= 2 and self.stock_history[-1] > self.stock_history[-2]:
                self.defection_history.append(False)
                return Action.D
        if round_num < r / 2.0 and current_stock > 2 * n:
            self.defection_history.append(False)
            return Action.D
        if round_num == r - 1:
            if current_stock > capacity * 0.2:
                self.defection_history.append(False)
                return Action.D
            else:
                self.defection_history.append(True)
                return Action.C
        if round_num >= r * 0.8 and current_stock < capacity * 0.4:
            self.defection_history.append(True)
            return Action.C
        self.defection_history.append(False)
        return Action.D

    def _estimate_defectors(self, current_stock: float, capacity: float, n: int) -> int:
        """
        Estimate number of defectors from previous round based on consumption gap.
        
        If all cooperate: consumption = capacity / 2
        If all defect: consumption = capacity
        Any consumption > capacity/2 suggests defectors.
        """
        if len(self.stock_history) < 2:
            return 0
        previous_stock = self.stock_history[-2]
        if current_stock >= previous_stock:
            return 0
        consumption_observed = previous_stock - current_stock
        min_consumption_if_all_c = previous_stock / 2.0 if previous_stock > 0 else 0
        if consumption_observed > min_consumption_if_all_c:
            if previous_stock > 0:
                estimated_defectors_float = 2.0 * n * consumption_observed / previous_stock - n
                estimated_defectors = int(math.ceil(estimated_defectors_float))
                estimated_defectors = max(0, min(n, estimated_defectors))
                return estimated_defectors
        return 0

class Strategy_EXPLOITATIVE_38(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Depletion Monitoring
    
    Exploits cooperative players while maintaining resource viability. Defects against
    cooperators to capture asymmetric gains, monitors stock depletion to avoid collapse,
    and times defection intensity based on remaining rounds and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        critical_threshold = self.capacity * 0.15
        if current_stock <= critical_threshold:
            return Action.C
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining == 1:
            return Action.D
        cooperative_rate = self._calculate_cooperative_rate(history)
        if cooperative_rate >= 0.5:
            return Action.D
        elif cooperative_rate >= 0.25:
            stock_threshold = self.capacity * 0.75
            if current_stock >= stock_threshold:
                return Action.D
            else:
                return Action.C
        else:
            stock_threshold = self.capacity * 0.75
            if current_stock >= stock_threshold:
                return Action.D
            else:
                return Action.C

    def _calculate_cooperative_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the average cooperation rate of opponents.
        Uses recency bias: weight recent rounds more heavily.
        """
        n_opponents = self.n_players - 1
        current_round = history.my_actions.shape[0]
        if current_round == 0 or n_opponents == 0:
            return 0.0
        last_round_cooperators = np.sum(history.opponent_actions[-1, :])
        last_round_coop_rate = last_round_cooperators / n_opponents
        total_cooperations = np.sum(history.opponent_actions)
        total_observations = current_round * n_opponents
        if total_observations == 0:
            return 0.0
        avg_coop_rate = total_cooperations / total_observations
        cooperative_rate = 0.4 * last_round_coop_rate + 0.6 * avg_coop_rate
        return cooperative_rate

class Strategy_EXPLOITATIVE_39(BaseStrategy):
    """
    Adaptive Predatory Harvesting (APH): Exploitative strategy that defects aggressively
    in early/mid game when stock is abundant, adapts based on opponent defection rates,
    and transitions to conservation only when stock depletion makes recovery impossible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        round_number = state.round_number
        stock = state.current_stock
        rounds_remaining = self.n_rounds - round_number - 1
        if rounds_remaining == 0:
            return Action.D
        opponent_defection_rate = self._calculate_opponent_defection_rate(history)
        if opponent_defection_rate > 0.7:
            return Action.D
        if opponent_defection_rate < 0.3:
            if random.random() < 0.9:
                return Action.D
            else:
                return Action.C
        if stock < self.capacity / 10 and stock > 0:
            if rounds_remaining <= 0 or stock < self.capacity / 100:
                return Action.D
            else:
                return Action.C
        if round_number > 0:
            my_last_action = history.my_actions[round_number - 1]
            others_last_actions = history.opponent_actions[round_number - 1, :]
            if not my_last_action and np.all(others_last_actions):
                if round_number >= 1:
                    stock_prev = state.current_stock
                    if stock_prev < self.capacity * 0.7:
                        return Action.C
        if rounds_remaining > 0:
            decay_factor = rounds_remaining / self.n_rounds
            threshold = self.capacity * (1.0 - decay_factor * decay_factor)
        else:
            threshold = 0
        if stock > threshold:
            return Action.D
        else:
            return Action.C

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the defection rate of opponents across all rounds.
        Defect is represented as False (0), Cooperate as True (1).
        """
        opponent_actions = history.opponent_actions
        if opponent_actions.size == 0:
            return 0.0
        total_actions = opponent_actions.size
        defection_count = np.sum(~opponent_actions)
        defection_rate = defection_count / total_actions if total_actions > 0 else 0.0
        return defection_rate

class Strategy_EXPLOITATIVE_40(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Maximizes personal payoff by exploiting the 2x asymmetry between defection (S/n)
    and cooperation (S/2n). Uses stock-dependent thresholds and end-game dominance to
    accumulate value while accelerating resource collapse for opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_critical = 2 * self.n
        self.threshold_moderate = self.capacity * 0.4
        self.high_stock_threshold = 0.9 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        rounds_remaining = self.r - round_num
        if rounds_remaining <= 1:
            return Action.D
        if stock <= self.threshold_critical:
            return Action.D
        if stock >= self.high_stock_threshold:
            if random.random() < 0.3:
                return Action.C
            else:
                return Action.D
        if stock <= self.threshold_moderate:
            defect_prob = 1.0 - stock / self.capacity
            defect_prob = max(0.0, min(1.0, defect_prob))
            if random.random() < defect_prob:
                return Action.D
            else:
                return Action.C
        if history is not None and round_num > 0:
            cooperators_last_round = int(sum(history.opponent_actions[-1, :]))
            defectors_last_round = self.n - cooperators_last_round
            if defectors_last_round >= self.n / 2:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_41(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State-Aware Defection
    
    Core philosophy: Exploit asymmetry between cooperators and defectors while monitoring
    resource viability. Defection yields 2x cooperation payoff, but only if stock persists.
    Maximizes immediate extraction while tracking opponent sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.depletion_threshold = self.capacity * 0.15
        self.sustainable_threshold = 0.4
        self.recovery_indicator = 0.2
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        self.stock_history.append(current_stock)
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        if current_stock <= self.depletion_threshold:
            return Action.D
        opponent_defection_count = 0
        total_opponent_actions = 0
        for round_idx in range(current_round):
            for opponent_idx in range(self.n_players - 1):
                if not history.opponent_actions[round_idx, opponent_idx]:
                    opponent_defection_count += 1
                total_opponent_actions += 1
        if total_opponent_actions > 0:
            opponent_defection_rate = opponent_defection_count / total_opponent_actions
        else:
            opponent_defection_rate = 0.0
        if opponent_defection_rate >= self.sustainable_threshold:
            return Action.D
        if len(self.stock_history) >= 3:
            stock_3_rounds_ago = self.stock_history[-3]
            recent_growth = current_stock - stock_3_rounds_ago
            if recent_growth > self.recovery_indicator * current_stock:
                return Action.D
        if len(self.stock_history) >= 3:
            decline_1 = self.stock_history[-1] < self.stock_history[-2]
            decline_2 = self.stock_history[-2] < self.stock_history[-3]
            if decline_1 and decline_2:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_42(BaseStrategy):
    """
    Adaptive Predation: An exploitative common pool resource strategy that ruthlessly
    extracts maximum personal value by defecting opportunistically, exploiting cooperators,
    and matching aggression against defectors. Adapts based on opponent cooperation ratios
    while maintaining maximum extraction in endgame and stock collapse scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number >= self.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.2 * self.capacity:
            return Action.D
        rounds_observed = state.round_number
        opponent_cooperation_ratios = np.zeros(self.n_players - 1)
        for opponent_idx in range(self.n_players - 1):
            cooperations = np.sum(history.opponent_actions[:rounds_observed, opponent_idx])
            cooperation_ratio = cooperations / rounds_observed if rounds_observed > 0 else 0.0
            opponent_cooperation_ratios[opponent_idx] = cooperation_ratio
        if np.any(opponent_cooperation_ratios > 0.7):
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_43(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State Collapse
    
    Treats the common pool as a resource to maximize for individual gain.
    Uses conditional defection based on stock health and remaining rounds.
    Exploits cooperators by extracting 2x their payoff when stock is abundant,
    and adapts to avoid terminal collapse by cooperating in late stages if needed.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number
        if stock == 0:
            return Action.C
        if rounds_remaining == 1:
            return Action.D
        if round_number == 0:
            return Action.D
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0
        if stock_ratio >= 0.6:
            return Action.D
        elif stock_ratio > 0.2:
            if rounds_remaining > 2 or stock > self.capacity / self.n_players:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_44(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Defection Cascades
    
    Exploits asymmetry between cooperative and defective payoffs by:
    1. Aggressive defection in opening phase (high stock, maximum profit)
    2. Conditional exploitation in mid phase (adapt to stock level)
    3. Scorched earth defection in endgame (no future punishment)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.phase_boundary_1 = math.floor(self.n_rounds / 3)
        self.phase_boundary_2 = math.floor(2 * self.n_rounds / 3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num <= self.phase_boundary_1:
            return Action.D
        if round_num > self.phase_boundary_2:
            return Action.D
        high_stock_threshold = self.capacity * 0.6
        low_stock_threshold = self.capacity * 0.3
        collapse_threshold = self.capacity * 0.1
        if stock < collapse_threshold:
            return Action.D
        if stock > high_stock_threshold:
            return Action.D
        if stock <= low_stock_threshold:
            return Action.D
        rand_value = random.random()
        if rand_value < 0.75:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_45(BaseStrategy):
    """
    Adaptive Depletion: An exploitative common pool resource strategy that ruthlessly
    defects when stock is abundant, uses probabilistic defection in the mid-game to maintain
    plausible deniability while extracting value, and switches to cooperation only when
    stock depletion forces preservation. Unconditionally defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_number = state.round_number
        total_rounds = self.n_rounds
        if round_number == total_rounds - 1:
            return Action.D
        if self.capacity > 0:
            stock_ratio = stock / self.capacity
        else:
            stock_ratio = 0.0
        if stock_ratio > 0.5:
            return Action.D
        if stock_ratio > 0.25:
            if random.random() < 0.7:
                return Action.D
            else:
                return Action.C
        if stock > 0:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_46(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Decay Detection
    
    Core approach: Defect aggressively by default to exploit the asymmetry between
    cooperative and defective payoffs. Switch to tactical cooperation only when
    stock depletion threatens collapse, preventing elimination of future exploitation
    opportunities. Always defect in the final round regardless of stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock_level = state.current_stock
        round_number = state.round_number
        total_rounds = self.n_rounds
        if round_number == total_rounds - 1:
            return Action.D
        if stock_level < self.n:
            return Action.C
        if stock_level < 1.5 * self.n:
            return Action.C
        if history is not None and len(history.my_actions) >= 2:
            if len(history.my_actions) >= 2:
                recent_round_idx = len(history.my_actions) - 1
                if recent_round_idx > 0:
                    prev_defectors = sum(~history.opponent_actions[recent_round_idx - 1, :])
                    curr_defectors = sum(~history.opponent_actions[recent_round_idx, :])
                    if curr_defectors >= self.n * 0.75:
                        if stock_level < 2.0 * self.n:
                            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_47(BaseStrategy):
    """
    Adaptive Predation: An exploitative common pool resource strategy.
    
    Core philosophy: Extract maximum value by defecting while cooperators subsidize the pool,
    dynamically adjusting to stock depletion and opponent behavior. Exploits asymmetry between
    cooperators (consume stock/(2n)) and defectors (consume stock/n) to achieve 2x relative payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.capacity
        if current_stock > capacity * 0.6:
            return Action.D
        if current_stock > capacity * 0.2:
            recent_rounds = min(3, state.round_number)
            if recent_rounds > 0:
                recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
                recent_defection_rate = np.sum(recent_opponent_actions == False) / (recent_rounds * self.n_players)
            else:
                recent_defection_rate = 0.0
            if recent_defection_rate >= 0.5:
                return Action.D
            else:
                return Action.D
        if current_stock <= capacity * 0.2:
            return Action.D
        if current_stock < capacity * 0.1:
            return Action.D
        if state.round_number >= 2:
            recent_stocks = [history.my_payoffs[state.round_number - 2], history.my_payoffs[state.round_number - 1]]
            recent_opponent_actions = history.opponent_actions[-2:, :]
            all_defected = np.all(recent_opponent_actions == False)
            if all_defected:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_48(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Dynamic Defection Thresholds
    
    This strategy maximizes extraction from the common pool by defecting aggressively
    in early rounds and final rounds, with adaptive thresholds based on stock levels
    and depletion rates. It exploits cooperative players while monitoring depletion
    velocity to respond to pool collapse scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        total_rounds = self.n_rounds
        if round_num == total_rounds - 1:
            return Action.D
        if round_num == 0:
            return Action.D
        if stock < 2 * self.n_players:
            if stock >= self.n_players:
                return Action.D
            else:
                return Action.C
        depletion_velocity = self._calculate_depletion_velocity(state, history)
        if depletion_velocity > 0.4 + 0.1 * self.n_players:
            return Action.D
        rounds_remaining = total_rounds - round_num
        threshold = self._calculate_threshold(rounds_remaining, total_rounds)
        if stock / self.capacity > threshold:
            return Action.D
        else:
            return Action.C

    def _calculate_depletion_velocity(self, state: CommonPoolState, history: PlayerHistory) -> float:
        """
        Calculate the depletion velocity as the fractional stock loss from previous round.
        Returns 0 if unable to calculate (e.g., division by zero).
        """
        if state.round_number == 0:
            return 0.0
        prev_round_idx = state.round_number - 1
        if state.round_number == 1:
            return 0.0
        my_payoffs = history.my_payoffs
        if len(my_payoffs) < 2:
            return 0.0
        recent_payoff = my_payoffs[-1]
        avg_earlier_payoff = np.mean(my_payoffs[:-1]) if len(my_payoffs) > 1 else recent_payoff
        if avg_earlier_payoff <= 0:
            return 0.0
        payoff_decline = (avg_earlier_payoff - recent_payoff) / avg_earlier_payoff
        estimated_velocity = max(0.0, payoff_decline)
        return estimated_velocity

    def _calculate_threshold(self, rounds_remaining: int, total_rounds: int) -> float:
        """
        Calculate the stock/capacity threshold above which to defect.
        
        threshold = (1 - (rounds_remaining / total_rounds)) * (1 + n/(2n))
        """
        if total_rounds <= 0:
            return 0.5
        progress_ratio = 1.0 - rounds_remaining / total_rounds
        n_factor = 1.0 + self.n_players / (2.0 * self.n_players)
        threshold = progress_ratio * n_factor
        threshold = max(0.0, min(1.0, threshold))
        return threshold

class Strategy_EXPLOITATIVE_49(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Collapse Prevention
    
    Maximizes personal payoff by exploiting cooperative tendencies while avoiding
    complete resource collapse. Uses stock-dependent phases:
    - Abundance (>60%): Defect to maximize extraction
    - Depletion (25-60%): Conditional based on decline rate and cooperator prevalence
    - Collapse Prevention (≤25%): Cooperate to stabilize resource
    - Final round: Always defect
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if round_num == self.n_rounds - 1:
            return Action.D
        if current_stock <= 0:
            return Action.C
        stock_ratio = current_stock / self.capacity
        if stock_ratio > 0.6:
            return Action.D
        if stock_ratio <= 0.25:
            return Action.C
        if round_num == 0:
            return Action.D
        prev_stock = None
        if history is not None and len(history.my_payoffs) > 0:
            my_prev_action = history.my_actions[-1]
            my_prev_payoff = history.my_payoffs[-1]
            if my_prev_payoff > 0:
                if my_prev_action:
                    prev_stock = my_prev_payoff * 2 * self.n_players
                else:
                    prev_stock = my_prev_payoff * self.n_players
            if prev_stock is not None and prev_stock > 0:
                stock_decline_pct = (prev_stock - current_stock) / prev_stock
                if stock_decline_pct > 0.2:
                    return Action.D
                if stock_decline_pct < 0.1:
                    return Action.D
                coop_count = int(np.sum(history.opponent_actions[-1, :]))
                if coop_count >= self.n_players / 2:
                    return Action.C
                else:
                    return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_50(BaseStrategy):
    """
    Adaptive Predation: An exploitative common pool resource strategy that maximizes
    personal payoff by ruthlessly exploiting cooperators and adapting to defector environments.
    
    Core mechanisms:
    - Round 1: Defect to establish dominance
    - Final round: Unconditional defection (no future interaction)
    - Mid-game: Estimate cooperator density and exploit or match defector behavior
    - Stock threshold: Defect aggressively when stock < 30% of capacity
    - Conditional cooperation: Only in marginal zones with sufficient rounds remaining
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_coop_history = [[] for _ in range(self.n_players - 1)]
        self.average_stock_decline_rate = 0.0
        self.stock_history = []

    def _estimate_cooperator_density(self, history: PlayerHistory) -> float:
        """
        Estimate the density of cooperators among opponents using exponential decay.
        Recent rounds weighted more heavily (0.7) than historical (0.3).
        Returns: proportion of opponents estimated to be cooperators
        """
        if history.opponent_actions.shape[0] == 0:
            return 0.5
        n_opponents = self.n_players - 1
        total_cooperation_weight = 0.0
        total_weight = 0.0
        for opponent_idx in range(n_opponents):
            coop_count = 0
            recent_weight = 0.7 / max(1, len(self.opponent_coop_history[opponent_idx]))
            historical_weight = 0.3 / max(1, len(self.opponent_coop_history[opponent_idx]))
            for round_idx, action in enumerate(history.opponent_actions[:, opponent_idx]):
                is_recent = round_idx >= len(history.opponent_actions) - 3
                weight = recent_weight if is_recent else historical_weight
                coop_count += float(action) * weight
            total_cooperation_weight += coop_count
            total_weight += 1.0
        if total_weight == 0:
            return 0.5
        return total_cooperation_weight / total_weight

    def _estimate_rounds_remaining(self, state: CommonPoolState) -> int:
        """Calculate remaining rounds including current round."""
        return self.n_rounds - state.round_number

    def _estimate_sustainability_threshold(self) -> int:
        """
        Estimate rounds remaining threshold for stock sustainability.
        If remaining rounds > this threshold, stock can sustain cooperation.
        """
        if len(self.stock_history) < 2:
            return self.n_rounds // 2
        recent_declines = []
        for i in range(1, min(4, len(self.stock_history))):
            decline = self.stock_history[-i] - self.stock_history[-i - 1] if i < len(self.stock_history) else 0
            if decline < 0:
                recent_declines.append(abs(decline))
        if recent_declines:
            avg_decline = np.mean(recent_declines)
            if avg_decline > 0:
                threshold = int(self.capacity / (avg_decline + 1e-06))
                return min(threshold, self.n_rounds)
        return self.n_rounds // 2

    def _update_history(self, history: PlayerHistory, state: CommonPoolState):
        """Update internal tracking of opponent cooperation and stock levels."""
        self.stock_history.append(state.current_stock)
        if history is not None and len(history.opponent_actions) > 0:
            for opponent_idx in range(self.n_players - 1):
                self.opponent_coop_history[opponent_idx] = list(history.opponent_actions[:, opponent_idx])

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if history is not None:
            self._update_history(history, state)
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        rounds_remaining = self._estimate_rounds_remaining(state)
        if rounds_remaining <= 5 and rounds_remaining > 1:
            defection_boost = (self.n_rounds - round_num) / self.n_rounds
            if random.random() < defection_boost * 0.4:
                return Action.D
        if current_stock < self.capacity * 0.3:
            return Action.D
        cooperator_density = self._estimate_cooperator_density(history)
        if cooperator_density >= 0.6:
            return Action.D
        if cooperator_density < 0.2:
            return Action.D
        sustainability_threshold = self._estimate_sustainability_threshold()
        rounds_remaining = self._estimate_rounds_remaining(state)
        if rounds_remaining > sustainability_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_51(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Defection
    
    This strategy exploits asymmetry between cooperative and defective payoffs by:
    1. Defecting aggressively when stock is high (threshold-based)
    2. Switching to cooperation only when stock is depleted
    3. Responding to rapid depletion by racing to the bottom
    4. Handling edge cases: first round, last round, capacity, collapse
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        if self.n_rounds > 1:
            self.base_threshold = self.capacity * (1.0 - math.sqrt(1.0 - 1.0 / self.n_rounds))
        else:
            self.base_threshold = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if stock < 2.0:
            return Action.C
        if stock >= 0.95 * self.capacity:
            return Action.D
        if history is not None and len(history.my_payoffs) > 0:
            if len(history.my_payoffs) >= 2:
                prev_round_idx = len(history.my_payoffs) - 1
                if prev_round_idx > 0:
                    total_opponent_consumption = np.sum(history.opponent_payoffs[prev_round_idx - 1, :])
                    my_prev_consumption = history.my_payoffs[prev_round_idx - 1]
                    total_prev_consumption = total_opponent_consumption + my_prev_consumption
                    if total_prev_consumption > 0:
                        depletion_intensity = total_prev_consumption / (stock + total_prev_consumption)
                        if depletion_intensity > 0.15:
                            return Action.D
        rounds_remaining = self.n_rounds - current_round
        if self.n_rounds > 0:
            adjusted_threshold = self.base_threshold * (1.0 + 0.3 * (rounds_remaining / self.n_rounds))
        else:
            adjusted_threshold = self.base_threshold
        if stock > adjusted_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_52(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Extraction with Depletion Tracking
    
    Treats the common pool as a resource to extract maximum personal value.
    Defaults to defection, cooperating only when mathematical analysis proves
    it yields higher cumulative payoff under worst-case opponent assumptions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_t = state.round_number
        if current_stock <= 0:
            return Action.D
        if round_t >= 2 * self.r / 3:
            return Action.D
        if current_stock <= self.capacity / 4:
            return Action.D
        remaining_rounds = self.r - round_t
        scenario_a_payoff = self._estimate_payoff(action=True, current_stock=current_stock, remaining_rounds=remaining_rounds)
        scenario_b_payoff = self._estimate_payoff(action=False, current_stock=current_stock, remaining_rounds=remaining_rounds)
        if scenario_b_payoff >= scenario_a_payoff:
            return Action.D
        elif scenario_a_payoff > scenario_b_payoff and current_stock > self.capacity / 4:
            return Action.C
        else:
            return Action.D

    def _estimate_payoff(self, action: bool, current_stock: float, remaining_rounds: int) -> float:
        """
        Estimate total payoff over remaining rounds.
        
        Args:
            action: True for COOPERATE, False for DEFECT
            current_stock: Current pool stock level
            remaining_rounds: Number of rounds left (including this one)
        
        Returns:
            Estimated cumulative payoff over remaining rounds
        """
        total_payoff = 0.0
        stock = current_stock
        for round_idx in range(remaining_rounds):
            if action:
                round_payoff = stock / (2 * self.n)
                my_consumption = stock / (2 * self.n)
            else:
                round_payoff = stock / self.n
                my_consumption = stock / self.n
            total_payoff += round_payoff
            opponent_consumption = (self.n - 1) * (stock / self.n)
            total_consumption = my_consumption + opponent_consumption
            stock = max(0, stock - total_consumption)
            if stock > 0:
                growth = 2 * stock * (1 - stock / self.capacity)
                stock = min(stock + growth, self.capacity)
            action = False
        return total_payoff

class Strategy_EXPLOITATIVE_53(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Stock Monitoring
    
    Exploits cooperative players systematically while adapting to defection patterns.
    Defects when stock is above a dynamic threshold that increases as remaining rounds decrease.
    Only cooperates when forced by stock collapse or final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_payoffs = []
        self.cooperation_payoffs = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        r_remaining = self.n_rounds - round_num
        if r_remaining == 0:
            return Action.D if stock > 0 else Action.C
        if stock <= 2 * self.n_players:
            return Action.C
        sqrt_ratio = math.sqrt(r_remaining / self.n_rounds)
        base_threshold = self.capacity * (1.0 - sqrt_ratio)
        final_quarter_multiplier = 0.5 if r_remaining / self.n_rounds < 0.25 else 1.0
        threshold = base_threshold * final_quarter_multiplier
        if history is not None and len(history.my_payoffs) > 0:
            recent_defection_advantage = self._calculate_recent_advantage(history)
            if recent_defection_advantage > 0:
                threshold *= 0.95
            else:
                threshold *= 1.05
        if stock > threshold:
            return Action.D
        else:
            return Action.C

    def _calculate_recent_advantage(self, history: PlayerHistory) -> float:
        """
        Calculate the average advantage of defection over cooperation in recent rounds.
        """
        if len(history.my_payoffs) == 0:
            return 0.0
        lookback = min(5, len(history.my_payoffs))
        recent_actions = history.my_actions[-lookback:]
        recent_payoffs = history.my_payoffs[-lookback:]
        if len(recent_actions) == 0:
            return 0.0
        defection_payoffs = []
        cooperation_payoffs = []
        for i, action in enumerate(recent_actions):
            if action:
                cooperation_payoffs.append(recent_payoffs[i])
            else:
                defection_payoffs.append(recent_payoffs[i])
        avg_defection = np.mean(defection_payoffs) if defection_payoffs else 0.0
        avg_cooperation = np.mean(cooperation_payoffs) if cooperation_payoffs else 0.0
        return float(avg_defection - avg_cooperation)

class Strategy_EXPLOITATIVE_54(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Stock Collapse Management
    
    Maximizes personal gain by defecting when stock is abundant, switching to
    cooperation when stock is depleted to prevent collapse, and using adaptive
    probabilities in the middle range. Exploits the 2:1 payoff asymmetry between
    defection and cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.threshold_aggressive = self.capacity * 0.75
        self.threshold_defensive = self.capacity * 0.25
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        self.stock_history.append(stock)
        if round_num == self.n_rounds - 1:
            return Action.D
        if round_num == 0:
            return Action.D
        if stock > self.threshold_aggressive:
            return Action.D
        elif stock <= self.threshold_defensive:
            return Action.C
        else:
            p_defect = 1.0 - stock / self.capacity * 0.3
            if len(self.stock_history) >= 2:
                trend = self.stock_history[-1] - self.stock_history[-2]
                if trend < -self.capacity * 0.05:
                    p_defect = p_defect * 0.8
            if random.random() < p_defect:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_55(BaseStrategy):
    """
    Adaptive Extraction strategy for Common Pool Resource Game.
    
    Exploits resource asymmetry by defecting when stock is abundant (above dynamic threshold),
    while adapting to depletion trends. Monitors stock history to detect collective over-harvesting
    and pivots to aggressive extraction before resource collapse. Becomes more conservative in
    late rounds and always defects in the final round (unless stock is near-depleted).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_history = []
        self.emergency_extraction_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        rounds_remaining = self.n_rounds - current_round
        self.stock_history.append(current_stock)
        if current_stock < self.capacity * 0.1:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        base_threshold = self.capacity * (0.5 + 0.5 * (rounds_remaining / self.n_rounds))
        decline_detected = False
        if len(self.stock_history) >= 2:
            recent_decline = self.stock_history[-2] - self.stock_history[-1]
            if recent_decline > self.capacity * 0.1:
                decline_detected = True
        if decline_detected:
            self.emergency_extraction_counter = 2
        if self.emergency_extraction_counter > 0:
            self.emergency_extraction_counter -= 1
            if current_stock > self.capacity * 0.25:
                return Action.D
            else:
                return Action.C
        if current_stock > base_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_56(BaseStrategy):
    """
    Exploitative Strategy: Dynamic Threshold Defection with State Manipulation
    
    Maximizes personal payoff by defecting opportunistically while maintaining just enough
    stock to prevent catastrophic collapse. Adapts defection intensity based on stock health,
    remaining rounds, and exploitation history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        rounds_remaining = self.n_rounds - round_num
        if rounds_remaining == 1:
            return Action.D
        if stock < 2 * self.n_players:
            return Action.C
        if round_num == 0:
            if self.n_players <= 4:
                return Action.D
            else:
                return Action.C
        if rounds_remaining <= 2:
            return Action.D
        if round_num >= 2:
            stock_curr = history.my_payoffs[-1]
            stock_prev = history.my_payoffs[-2]
            stock_history = [history.my_payoffs[i] for i in range(len(history.my_payoffs))]
            if len(stock_history) >= 3:
                recent_avg = np.mean(stock_history[-3:])
                if recent_avg < 0.7 * self.capacity and abs(stock_history[-1] - stock_history[-2]) < 1.0:
                    if stock < 0.7 * self.capacity:
                        return Action.D
        my_actions = history.my_actions[:round_num]
        defection_count = np.sum(~my_actions)
        cooperation_count = np.sum(my_actions)
        if stock < 0.4 * self.capacity and defection_count > cooperation_count:
            if rounds_remaining > 3:
                return Action.C
            else:
                return Action.D
        threshold = self.capacity * (0.5 + 0.3 * (rounds_remaining / self.n_rounds))
        if stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_57(BaseStrategy):
    """
    Adaptive Predatory Harvesting (APH) Strategy for Common Pool Resource Game.
    
    Core approach: Exploit the 2x payoff advantage of defection while systematically
    degrading the common pool. Defect by default in most situations; only consider
    cooperation when stock is abundant, end-game is distant, and defection rates are low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if current_stock <= self.capacity / 4:
            return Action.D
        rounds_remaining = self.n_rounds - round_num
        if rounds_remaining <= 2:
            return Action.D
        recent_rounds_window = min(2, round_num)
        defections_observed = self._count_recent_defections(history, recent_rounds_window)
        total_recent_observations = recent_rounds_window * self.n_players
        if total_recent_observations > 0:
            defection_rate = defections_observed / total_recent_observations
        else:
            defection_rate = 0.0
        if defection_rate > 0.6:
            return Action.D
        stock_declined = False
        if round_num >= 1:
            previous_stock = history.opponent_payoffs[round_num - 1].sum() + history.my_payoffs[round_num - 1]
            stock_decline_rate = self._estimate_stock_decline_rate(history, round_num, current_stock)
            if stock_decline_rate < -0.15:
                stock_declined = True
        if stock_declined and defection_rate > 0.3:
            return Action.D
        if current_stock > 0.75 * self.capacity and rounds_remaining >= 3 and (defection_rate < 0.5) and (round_num >= 3):
            return Action.C
        return Action.D

    def _count_recent_defections(self, history: PlayerHistory, recent_rounds_window: int) -> int:
        """Count defections (False/0) in the last N rounds across all opponents."""
        if recent_rounds_window <= 0 or len(history.opponent_actions) == 0:
            return 0
        start_idx = max(0, len(history.opponent_actions) - recent_rounds_window)
        recent_actions = history.opponent_actions[start_idx:, :]
        defections = np.sum(recent_actions == False)
        return int(defections)

    def _estimate_stock_decline_rate(self, history: PlayerHistory, current_round: int, current_stock: float) -> float:
        """
        Estimate the stock decline rate from the previous round.
        
        Uses the consumption pattern from the previous round to infer stock health.
        Stock declines >15% suggest active defection and pool pressure.
        """
        if current_round < 1:
            return 0.0
        prev_round_idx = current_round - 1
        prev_cooperations = int(np.sum(history.opponent_actions[prev_round_idx, :]))
        prev_my_action = int(history.my_actions[prev_round_idx])
        prev_defections = self.n_players - prev_cooperations + (1 - prev_my_action)
        total_consumption = prev_cooperations * (current_stock / (2 * self.n_players)) + prev_defections * (current_stock / self.n_players)
        if current_stock < 1e-09:
            return 0.0
        consumption_rate = total_consumption / current_stock if current_stock > 0 else 0
        if consumption_rate > 0.2:
            return -0.2
        elif consumption_rate > 0.15:
            return -0.15
        else:
            return -0.05

class Strategy_EXPLOITATIVE_58(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Selective Cooperation
    
    This strategy maximizes personal payoff by:
    1. Defecting whenever profitable (stock > threshold)
    2. Cooperating only when stock is critically low (below 15% of capacity)
    3. Adapting to opponent behavior through defection rate tracking
    4. Adjusting cooperation threshold for mixed opponent strategies
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.base_threshold = self.capacity * 0.15
        self.critical_threshold = self.capacity * 0.05

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.D
        rounds_remaining = self.n_rounds - current_round
        if stock < self.critical_threshold:
            return Action.C
        opponent_defection_rate = self._calculate_opponent_defection_rate(history, current_round)
        threshold = self.base_threshold
        if 0.3 <= opponent_defection_rate <= 0.7:
            threshold *= 1.25
        if stock <= threshold:
            return Action.C
        if rounds_remaining <= 2:
            if stock > threshold:
                return Action.D
            else:
                return Action.C
        return Action.D

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the aggregate defection rate of all opponents.
        Defection is encoded as False (0), Cooperation as True (1).
        So we count False values to get defection count.
        """
        if current_round <= 1:
            return 0.5
        previous_rounds = history.opponent_actions[:current_round, :]
        total_opponent_actions = previous_rounds.size
        if total_opponent_actions == 0:
            return 0.5
        total_cooperations = np.sum(previous_rounds)
        total_defections = total_opponent_actions - total_cooperations
        defection_rate = total_defections / total_opponent_actions if total_opponent_actions > 0 else 0.5
        return defection_rate

class Strategy_EXPLOITATIVE_59(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with State-Aware Defection
    
    This strategy exploits the asymmetry between cooperation (stock/2n payoff) and 
    defection (stock/n payoff) by always defecting, with adaptive timing based on 
    stock levels and remaining rounds. It extracts maximum value while the pool 
    sustains it, then continues defection as the resource depletes.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decide whether to Cooperate or Defect based on game state and history.
        """
        round_number = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - round_number
        if rounds_remaining <= 2:
            return Action.D
        if current_stock < self.capacity * 0.3:
            return Action.D
        if current_stock < self.capacity * 0.5:
            return Action.D
        if current_stock >= self.capacity * 0.5:
            if history is not None and round_number > 0:
                recent_rounds = min(3, round_number)
                recent_defections = 0
                for round_idx in range(max(0, round_number - recent_rounds), round_number):
                    defection_count = np.sum(~history.opponent_actions[round_idx, :])
                    recent_defections += defection_count
                recent_total_actions = recent_rounds * self.n_players
                if recent_total_actions > 0:
                    recent_defection_rate = recent_defections / recent_total_actions
                    if recent_defection_rate > 0.4:
                        return Action.D
                    else:
                        return Action.D
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_60(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy.
    
    Dynamically exploits the asymmetry between cooperators and defectors while
    remaining adaptive to environmental collapse. Uses stock-dependent thresholds
    to balance immediate extraction with long-term resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = 0.7 * self.capacity
        self.threshold_critical = 0.4 * self.capacity
        self.threshold_collapse = 0.15 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num >= self.n_rounds - 2:
            return Action.D
        if stock > self.threshold_high:
            return Action.D
        elif stock > self.threshold_critical:
            defection_rate = self._calculate_opponent_defection_rate(history)
            if defection_rate > 0.5:
                return Action.D
            else:
                rounds_remaining = self.n_rounds - round_num
                if rounds_remaining > 2:
                    return Action.C
                else:
                    return Action.D
        elif stock > self.threshold_collapse:
            return Action.C
        else:
            return Action.C

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the defection rate among all opponents in the most recent round.
        
        Returns:
            float: Proportion of opponents playing D in the last round, range [0, 1]
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        last_round_opponent_actions = history.opponent_actions[-1, :]
        num_defectors = np.sum(~last_round_opponent_actions)
        total_opponents = len(last_round_opponent_actions)
        if total_opponents == 0:
            return 0.0
        defection_rate = float(num_defectors) / float(total_opponents)
        return defection_rate

class Strategy_EXPLOITATIVE_61(BaseStrategy):
    """
    Adaptive Predation with Calculated Restraint: An exploitative strategy that extracts
    maximum value from the common pool while maintaining just enough cooperation to prevent
    collapse, enabling continued exploitation in future rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.D
        rounds_remaining = self.r - current_round
        if current_round == self.r - 1:
            return Action.D
        if stock <= 2 * self.n:
            if stock >= self.n:
                return Action.C
            else:
                return Action.D
        if stock >= 1.5 * self.capacity:
            return Action.D
        if stock >= self.capacity * 0.75:
            if rounds_remaining <= 3:
                return Action.D
            else:
                return Action.D if random.random() < 0.8 else Action.C
        if stock >= self.capacity * 0.4:
            collapse_risk_rounds = self._estimate_rounds_to_collapse(stock)
            if collapse_risk_rounds < rounds_remaining:
                return Action.C if random.random() < 0.6 else Action.D
            else:
                return Action.D if random.random() < 0.7 else Action.C
        return Action.C

    def _estimate_rounds_to_collapse(self, current_stock: float) -> int:
        """
        Estimate how many rounds until stock approaches critical depletion.
        Assumes all players continue to defect (worst case for stock).
        """
        if current_stock <= 0:
            return 0
        stock = current_stock
        rounds_to_collapse = 0
        threshold = 2 * self.n
        for _ in range(self.r):
            if stock <= threshold:
                return rounds_to_collapse
            total_consumption = stock
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
                stock = min(stock_after_consumption + growth, self.capacity)
            else:
                stock = 0
            rounds_to_collapse += 1
        return rounds_to_collapse

class Strategy_EXPLOITATIVE_62(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy
    
    Core philosophy: Defect by default to extract maximum immediate value,
    with conditional cooperation only when stock depletion threatens future payoffs.
    Exploits cooperators' subsidization and free-rides on their recovery efforts.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.depletion_threshold = self.capacity * 0.25
        self.collapse_threshold = self.capacity * 0.2
        self.critical_threshold = self.capacity * 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - state.round_number
        if rounds_remaining <= 2:
            return Action.D
        if current_stock < self.depletion_threshold:
            defect_streak = self._count_recent_defect_streak(history)
            if defect_streak >= 2 and current_stock < self.collapse_threshold:
                return Action.C
            elif current_stock < self.critical_threshold:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _count_recent_defect_streak(self, history: PlayerHistory) -> int:
        """
        Count consecutive defection rounds from the end of history.
        Returns the number of consecutive rounds where this player defected.
        """
        if history is None or len(history.my_actions) == 0:
            return 0
        streak = 0
        for i in range(len(history.my_actions) - 1, -1, -1):
            if history.my_actions[i] is False:
                streak += 1
            else:
                break
        return streak

class Strategy_EXPLOITATIVE_63(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Defection
    
    Dynamically adapts to stock levels and game progression to maximize cumulative payoff.
    Early rounds: cooperate to allow stock regeneration (if abundant).
    Late rounds: defect aggressively to extract maximum value before game ends.
    Detects aggressive defection by others and switches to extraction mode when beneficial.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.r - 1:
            return Action.D
        if current_stock < 2 * self.n:
            return Action.D
        if current_round == 0:
            if self.r == 2:
                return Action.D
            else:
                return Action.C
        base_threshold = self.capacity * (1.0 - current_round / (self.r - 1))
        depletion_detected = False
        if current_round > 0:
            prev_stock = history.my_payoffs[current_round - 1]
            prev_round_cooperators = sum(history.opponent_actions[current_round - 1, :])
            my_prev_action = history.my_actions[current_round - 1]
            if my_prev_action:
                prev_round_cooperators += 1
            total_defectors = self.n - prev_round_cooperators
            rounds_remaining = self.r - current_round
            if total_defectors >= self.n // 2 and rounds_remaining < self.r / 2.0:
                depletion_detected = True
        if depletion_detected:
            return Action.D
        if current_round > 0:
            all_others_cooperated = all(history.opponent_actions[current_round - 1, :])
            if all_others_cooperated:
                base_threshold += self.capacity * 0.15
        if current_stock > base_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_64(BaseStrategy):
    """
    Adaptive Predation: An exploitative strategy that consistently defects to maximize
    personal payoff regardless of collective welfare. Defection yields 2x the payoff of
    cooperation when stock is abundant. The strategy adapts to stock levels but never
    compromises on defection, since cooperation only reduces personal payoff without
    changing opponent behavior. It maximizes extraction while remaining robust to both
    cooperator-dominated and defector-dominated opponent populations.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.n_rounds - 1:
            return Action.D
        stock = state.current_stock
        capacity = self.capacity
        if capacity <= 0:
            return Action.D
        stock_ratio = stock / capacity
        if stock_ratio > 0.75:
            return Action.D
        elif stock_ratio > 0.25:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_65(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Dynamic Switching
    
    Exploits the asymmetry between cooperative (S/2n) and defective (S/n) payoffs
    by monitoring stock depletion and switching between aggressive extraction and
    minimal cooperation based on resource health and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if self.capacity > 0:
            depletion_rate = (self.capacity - current_stock) / self.capacity
        else:
            depletion_rate = 1.0
        rounds_remaining = self.n_rounds - current_round
        if depletion_rate > 0.7 and rounds_remaining > 2:
            return Action.C
        if depletion_rate < 0.3:
            return Action.D
        observed_defection_rate = self._calculate_opponent_defection_rate(history)
        if observed_defection_rate > 0.6 or depletion_rate > 0.5:
            return Action.D
        return Action.D

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the observed defection rate across all opponents.
        Defection is represented by False (0) in opponent_actions.
        """
        if history.opponent_actions.size == 0:
            return 0.0
        total_opponent_actions = history.opponent_actions.size
        if total_opponent_actions == 0:
            return 0.0
        total_defections = np.sum(history.opponent_actions == False)
        defection_rate = float(total_defections) / float(total_opponent_actions)
        return defection_rate

class Strategy_EXPLOITATIVE_66(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Stock Collapse Recognition
    
    Maximizes personal extraction by cooperating early when the pool is healthy,
    then defecting opportunistically as conditions deteriorate. Detects pool collapse,
    declining trends, and endgame scenarios to switch to pure defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.collapse_threshold = self.capacity * 0.15
        self.danger_round = self.n_rounds * 0.75
        self.trend_window = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.C
        if current_stock <= self.collapse_threshold:
            return Action.D
        if current_round >= 2:
            if self._is_declining_trend(history):
                return Action.D
        if current_round >= self.danger_round:
            return Action.D
        estimated_cooperators = self._estimate_cooperators(history, current_round)
        if estimated_cooperators < 0.5:
            return Action.D
        return Action.C

    def _is_declining_trend(self, history: PlayerHistory) -> bool:
        """
        Check if stock has been declining over the last k rounds.
        We infer historical stock levels from payoffs and actions.
        """
        current_round = len(history.my_actions)
        if current_round < 2:
            return False
        stock_history = self._reconstruct_stock_history(history, current_round)
        if len(stock_history) < 3:
            return False
        recent = stock_history[-3:]
        return recent[0] > recent[1] > recent[2]

    def _reconstruct_stock_history(self, history: PlayerHistory, current_round: int) -> list:
        """
        Approximate historical stock levels by reverse-engineering from payoffs.
        """
        stock_history = [self.capacity]
        for round_idx in range(current_round):
            cooperators = sum(history.opponent_actions[round_idx, :])
            defectors = self.n_players - 1 - cooperators
            my_action_is_cooperate = bool(history.my_actions[round_idx])
            if my_action_is_cooperate:
                cooperators += 1
            else:
                defectors += 1
            current_stock = stock_history[-1]
            if current_stock <= 0:
                stock_history.append(0)
                continue
            cooperator_consumption = cooperators * (current_stock / (2 * self.n_players))
            defector_consumption = defectors * (current_stock / self.n_players)
            total_consumption = cooperator_consumption + defector_consumption
            stock_after_consumption = max(0, current_stock - total_consumption)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            new_stock = min(stock_after_consumption + growth, self.capacity)
            stock_history.append(new_stock)
        return stock_history

    def _estimate_cooperators(self, history: PlayerHistory, current_round: int) -> float:
        """
        Estimate the ratio of cooperators based on observed actions in the previous round.
        Returns a value in [0, 1].
        """
        if current_round <= 0:
            return 0.5
        prev_round = current_round - 1
        opponent_cooperators = sum(history.opponent_actions[prev_round, :])
        my_cooperation = 1 if history.my_actions[prev_round] else 0
        total_cooperators = opponent_cooperators + my_cooperation
        estimated_ratio = total_cooperators / self.n_players
        return estimated_ratio

class Strategy_EXPLOITATIVE_67(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Stock Sensing
    
    Treats cooperation as exploitable resource. Adapts to stock levels and observed
    defection rates to maximize absolute payoff through aggressive defection when
    stock is abundant, conditional cooperation at medium levels, and forced conservation
    when depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        if round_num == self.n_rounds - 1:
            return Action.D
        defection_rate = self._calculate_defection_rate(history, None)
        recent_defection_rate = self._calculate_defection_rate(history, 3)
        opponent_defection = recent_defection_rate if len(history.opponent_actions) >= 3 * self.n_players else defection_rate
        if stock_ratio < 0.1:
            return Action.C
        if stock_ratio > 0.6:
            return Action.D
        if stock_ratio > 0.3:
            if round_num > self.n_rounds * 0.75:
                if stock_ratio > 0.5:
                    return Action.D
                elif opponent_defection > 0.5:
                    return Action.D
                else:
                    return Action.C
            if opponent_defection > 0.5:
                return Action.D
            else:
                return Action.C
        if stock_ratio > 0.1:
            if opponent_defection > 0.65:
                return Action.D
            else:
                return Action.C
        return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, recent_rounds: None | int) -> float:
        """
        Calculate the defection rate from opponent actions.
        
        Args:
            history: Player history containing opponent actions
            recent_rounds: If not None, only consider last recent_rounds*n_players actions
        
        Returns:
            Defection rate as a float between 0 and 1
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        opponent_actions = history.opponent_actions
        if recent_rounds is not None:
            max_actions = recent_rounds * self.n_players
            if len(opponent_actions) > max_actions:
                opponent_actions = opponent_actions[-max_actions:, :]
        total_actions = opponent_actions.size
        if total_actions == 0:
            return 0.0
        defections = np.sum(opponent_actions == False)
        defection_rate = float(defections) / float(total_actions)
        return defection_rate

class Strategy_EXPLOITATIVE_68(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Conditional Cooperation
    
    Core approach: Defect to extract maximum immediate value (S/n vs S/2n),
    cooperate only when defection would trigger cascading defection that 
    destroys the pool faster than we can extract value.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        previous_round_idx = current_round - 1
        opponent_actions_prev = history.opponent_actions[previous_round_idx, :]
        defectors_prev = np.sum(~opponent_actions_prev)
        coop_rate_prev = (self.n_players - defectors_prev) / self.n_players
        if current_stock < self.capacity / 4:
            return Action.D
        if defectors_prev >= math.ceil(self.n_players / 2):
            return Action.D
        if coop_rate_prev > 0.66 and current_stock > self.capacity / 2:
            return Action.D
        if defectors_prev <= 1 and current_stock > self.capacity * 0.6:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_69(BaseStrategy):
    """
    Adaptive Predatory Harvesting (APH) Strategy
    
    An exploitative strategy that defaults to defection while monitoring stock health.
    Cooperates only when necessary to prevent resource collapse, using stock predictions
    to maximize extraction opportunities. Applies endgame aggression in final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.endgame_threshold = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.r - 1:
            return Action.D
        if stock <= 2 * self.n:
            return Action.C
        if round_num >= self.endgame_threshold * self.r:
            if stock > self.capacity / 2:
                return Action.D
            else:
                return Action.C
        if stock > 1.5 * self.capacity:
            return Action.D
        if stock > self.capacity:
            return Action.D
        if stock > self.capacity * 0.6:
            predicted_stock = self._predict_next_stock(stock, history, round_num)
            if predicted_stock > 2 * self.n:
                return Action.D
            else:
                return Action.C
        return Action.C

    def _predict_next_stock(self, current_stock: float, history: PlayerHistory, round_num: int) -> float:
        """
        Estimate stock level after this round, assuming this player defects.
        
        Uses observed defection frequency from previous round to estimate
        opponent behavior in the current round.
        """
        prev_round_actions = history.opponent_actions[round_num - 1, :]
        observed_defectors = int(np.sum(~prev_round_actions))
        defection_consumption = observed_defectors * (current_stock / self.n)
        cooperation_consumption = (self.n - observed_defectors - 1) * (current_stock / (2 * self.n))
        my_consumption = current_stock / self.n
        total_consumption = defection_consumption + cooperation_consumption + my_consumption
        total_consumption = min(total_consumption, current_stock)
        stock_after_consumption = current_stock - total_consumption
        if stock_after_consumption > 0 and self.capacity > 0:
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
        else:
            growth = 0
        predicted_stock = min(stock_after_consumption + growth, self.capacity)
        return predicted_stock

class Strategy_EXPLOITATIVE_70(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Exploits asymmetry between cooperation and defection payoffs by:
    - Defecting in early rounds to test opponent composition
    - Using stock-based thresholds to maximize extraction
    - Defecting aggressively in endgame and low-stock scenarios
    - Opportunistically defecting when opponent defection rates are high
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity * 0.15
        self.high_stock_threshold = self.capacity * 0.7
        self.depletion_pressure = 2 * self.n_players / self.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            return Action.D
        if rounds_remaining <= 3:
            return Action.D
        if stock <= 0.0:
            return Action.D
        if stock <= self.critical_threshold:
            return Action.D
        if stock >= self.high_stock_threshold:
            return Action.D
        if rounds_remaining > 0 and stock > 0:
            depletion_ratio = rounds_remaining / stock
            if depletion_ratio > self.depletion_pressure:
                return Action.D
        if history is not None and current_round >= 1:
            recent_defection_rate = self._calculate_recent_defection_rate(history, current_round)
            if recent_defection_rate > 0.5:
                return Action.D
        return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the defection rate among opponents in recent rounds.
        Uses rounds 0 through current_round-1 to predict behavior.
        """
        if current_round == 0:
            return 0.0
        recent_actions = history.opponent_actions[:current_round, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        defections = np.sum(~recent_actions)
        defection_rate = defections / total_actions
        return float(defection_rate)

class Strategy_EXPLOITATIVE_71(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Defection
    
    Exploits the asymmetry between cooperators and defectors by identifying and 
    punishing cooperative patterns while maximizing personal extraction. Defects 
    when stock is high (growth will recover), shifts to conditional play when 
    stock is depleted, and exploits tit-for-tat strategies opportunistically.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if stock <= 2 * self.n_players:
            return Action.D
        if stock > self.capacity * 0.6:
            return Action.D
        lookback_rounds = min(3, current_round)
        if current_round > 0:
            last_round_cooperators = sum(history.opponent_actions[-1, :])
            all_others_cooperated = last_round_cooperators == self.n_players - 1
        else:
            all_others_cooperated = False
        if lookback_rounds > 0:
            recent_defections = 0
            total_opponent_actions = 0
            for i in range(lookback_rounds):
                round_idx = current_round - lookback_rounds + i
                if round_idx >= 0:
                    recent_defections += self.n_players - 1 - sum(history.opponent_actions[round_idx, :])
                    total_opponent_actions += self.n_players - 1
            recent_defection_rate = recent_defections / total_opponent_actions if total_opponent_actions > 0 else 0
        else:
            recent_defection_rate = 0
        if all_others_cooperated and stock > self.capacity * 0.4:
            return Action.C
        elif recent_defection_rate > 0.5:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_72(BaseStrategy):
    """
    Adaptive Predation: Exploitative Common Pool Resource Strategy
    
    Maximizes personal payoff by exploiting asymmetry between cooperation and defection,
    adapting to opponent behavior patterns. Uses stock-level thresholds and historical
    defection rates to make decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cumulative_opponent_defections = 0
        self.stock_history = [game_description.capacity]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if history is not None:
            recent_opponent_actions = history.opponent_actions[round_number - 1, :]
            defections_this_round = sum((1 for action in recent_opponent_actions if not action))
            self.cumulative_opponent_defections += defections_this_round
        if round_number == 0:
            return Action.D
        if round_number == n_rounds - 1:
            if current_stock > capacity * 0.4:
                return Action.D
            else:
                return Action.C
        if current_stock > capacity * 0.75:
            return Action.D
        elif current_stock > capacity * 0.4:
            rounds_completed = round_number
            if rounds_completed > 0:
                d_rate = self.cumulative_opponent_defections / max(1, (n_players - 1) * rounds_completed)
                if d_rate > 0.45:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D
        elif current_stock > capacity * 0.15:
            return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_73(BaseStrategy):
    """
    Adaptive Predatory Harvesting (APH): An exploitative strategy that maximizes
    absolute payoff by conditionally defecting based on stock health levels.
    
    Core mechanics:
    - Always defect in the last round (no future consequences)
    - Defect when stock is healthy (>= 50% capacity) to exploit 2x payoff
    - Defect in critical depletion zone (15%-50%) to maximize relative damage
    - Cooperate only when stock has collapsed (< 15%) to minimize losses
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.collapse_threshold = 0.15
        self.healthy_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if self.capacity <= 0:
            health_ratio = 0.0
        else:
            health_ratio = current_stock / self.capacity
        if health_ratio < self.collapse_threshold:
            return Action.C
        if health_ratio >= self.healthy_threshold:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_74(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Resource Extraction
    
    This strategy exploits the asymmetry between cooperation and defection.
    It uses aggressive defection in early and late game phases, with conditional
    exploitation in the mid-game based on stock levels and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        total_rounds = self.n_rounds
        if current_stock < 2 * self.n_players:
            return Action.D
        early_game_threshold = total_rounds // 3
        if round_number <= early_game_threshold:
            return Action.D
        late_game_threshold = 2 * total_rounds // 3
        if round_number > late_game_threshold:
            return Action.D
        if history is None:
            return Action.D
        previous_round_idx = round_number - 1
        if previous_round_idx < 0:
            return Action.D
        defectors_last_round = self.n_players - int(np.sum(history.opponent_actions[previous_round_idx, :]))
        majority_threshold = math.ceil(self.n_players / 2)
        if defectors_last_round >= majority_threshold:
            return Action.D
        if current_stock > 1.5 * self.capacity / 2 and defectors_last_round <= 1:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_75(BaseStrategy):
    """
    Adaptive Depletion: An exploitative strategy that parasitizes cooperation in early/mid game,
    then switches to pure defection in the endgame. Exploits stock recovery patterns to detect
    and capitalize on cooperative surplus.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_round = int(self.n_rounds * 0.6)
        self.depletion_threshold = self.capacity * 0.3
        self.endgame_rounds = 3
        self.recovery_threshold = 0.95
        self.decline_threshold = 0.9
        self.mid_capacity_threshold = self.capacity * 0.4
        self.healthy_threshold = self.capacity * 0.5
        self.lower_critical_threshold = self.capacity * 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num >= self.n_rounds - self.endgame_rounds:
            return Action.D
        if round_num == 0:
            return Action.C
        if round_num >= self.critical_round:
            if stock > self.lower_critical_threshold:
                return Action.D
            else:
                return Action.D
        previous_stock = history.my_payoffs[round_num - 1] if round_num >= 1 else stock
        if round_num >= 2:
            prev_prev_stock = stock / self.recovery_threshold if stock > 0 else 0
            stock_recovery_rate = stock / prev_prev_stock if prev_prev_stock > 0 else 1.0
        elif round_num == 1:
            stock_recovery_rate = stock / self.capacity if self.capacity > 0 else 1.0
        else:
            stock_recovery_rate = 1.0
        if stock_recovery_rate > self.recovery_threshold:
            return Action.D
        if stock > self.mid_capacity_threshold:
            if round_num >= 1:
                recent_rounds_start = max(0, round_num - 3)
                recent_opponent_defections = np.sum(~history.opponent_actions[recent_rounds_start:round_num, :])
                recent_total_moves = (round_num - recent_rounds_start) * self.n_players
                avg_defector_rate = recent_opponent_defections / recent_total_moves if recent_total_moves > 0 else 0
                if avg_defector_rate < 0.5:
                    return Action.D
        if stock > self.healthy_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_76(BaseStrategy):
    """
    Adaptive Predation: Exploitative Common Pool Resource Strategy
    
    Maximizes personal payoff by exploiting asymmetry between defection (S/n) 
    and cooperation (S/2n) rewards. Adapts defection intensity based on stock 
    depletion rates to extract maximum value before resource collapse.
    
    Core tactics:
    - Round 1 defection to establish aggressive baseline
    - Defect when stock abundant (≥75% capacity)
    - Cooperate only when stock critically low (≤25% capacity)
    - Accelerate defection when detecting rapid depletion (others racing to extract)
    - Unconditional defection in final two rounds
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round >= self.n_rounds - 2:
            return Action.D
        if current_round == 0:
            return Action.D
        critical_threshold = self.capacity / 4.0
        if current_stock <= critical_threshold:
            return Action.C
        abundant_threshold = 0.75 * self.capacity
        if current_stock >= abundant_threshold:
            return Action.D
        if current_round >= 2:
            stock_prev = state.current_stock
            if current_round >= 1:
                n_cooperators_prev = int(np.sum(history.opponent_actions[current_round - 1, :]))
                if history.my_actions[current_round - 1]:
                    n_cooperators_prev += 1
                if current_round >= 2:
                    n_cooperators_prev_prev = int(np.sum(history.opponent_actions[current_round - 2, :]))
                    if history.my_actions[current_round - 2]:
                        n_cooperators_prev_prev += 1
                    defectors_prev = self.n_players - n_cooperators_prev
                    defectors_prev_prev = self.n_players - n_cooperators_prev_prev
                    depletion_trend = defectors_prev - defectors_prev_prev
                    if depletion_trend > 0:
                        return Action.D
                    else:
                        return Action.D
                else:
                    return Action.D
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_77(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Stock Monitoring
    
    This strategy maximizes absolute payoff by defaulting to defection while monitoring
    opponent behavior and stock levels. It exploits the 2x payoff advantage of defection
    over cooperation, with occasional strategic cooperation only in early rounds when
    opponent defection rates are very low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 2 * self.n_players * 1.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.critical_threshold:
            return Action.D
        opponent_defections = 0
        total_opponent_actions = 0
        for round_idx in range(current_round):
            for player_idx in range(self.n_players - 1):
                if not history.opponent_actions[round_idx, player_idx]:
                    opponent_defections += 1
                total_opponent_actions += 1
        if total_opponent_actions == 0:
            opponent_defection_rate = 0.0
        else:
            opponent_defection_rate = opponent_defections / total_opponent_actions
        if opponent_defection_rate > 0.25:
            return Action.D
        if opponent_defection_rate < 0.15 and current_round <= 2 and (current_round < self.n_rounds - 2):
            if current_round % 5 == 0:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_78(BaseStrategy):
    """
    Adaptive Extraction with Resilience (AER): An exploitative strategy that maximizes
    personal payoff by opportunistically defecting while maintaining stock sustainability
    to ensure future extraction opportunities. Balances short-term exploitation with
    long-term stock preservation through adaptive thresholds based on observed behavior
    and stock dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        rounds_remaining = self.r - round_num
        if rounds_remaining == 1:
            return Action.D
        if stock < 2 * self.n:
            return Action.D
        if round_num == 0:
            return Action.D
        prev_opponent_actions = history.opponent_actions[round_num - 1, :]
        defection_count = np.sum(~prev_opponent_actions)
        defection_rate = defection_count / self.n
        cooperation_count = np.sum(prev_opponent_actions)
        cooperation_rate = cooperation_count / self.n
        stock_trend_declining = False
        if round_num >= 1:
            if round_num >= 2:
                stock_trend_declining = stock < self.capacity * 0.6
        threshold_defection = (self.n - 1) / self.n * 0.6
        if defection_rate > threshold_defection:
            return Action.D
        if stock >= self.capacity * 0.8:
            return Action.D
        if cooperation_rate >= 0.75:
            return Action.D
        if stock_trend_declining or stock < 1.5 * (2 * self.n):
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_79(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Dynamic Threshold Adjustment
    
    This strategy maximizes personal extraction by defecting when the common pool
    stock exceeds adaptive thresholds. It exploits cooperators directly (extracting
    double payoff) and adapts thresholds based on observed opponent defection rates,
    round number, and pool health. Recovery mode temporarily cooperates only when
    the pool has collapsed to allow regeneration for future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.recovery_mode_counter = 0
        self.base_threshold = self.capacity * (1 - 1 / self.n)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.D
        if self._should_enter_recovery_mode(history):
            self.recovery_mode_counter = 2
        if self.recovery_mode_counter > 0:
            self.recovery_mode_counter -= 1
            return Action.C
        threshold = self._calculate_threshold(history, round_number)
        if round_number == self.r - 1:
            if current_stock > self.capacity * 0.4:
                return Action.D
            else:
                return Action.C
        if round_number == self.r - 2:
            threshold = threshold * 0.85
        if current_stock < self.capacity * 0.1 and current_stock > self.n:
            return Action.D
        if current_stock > threshold:
            return Action.D
        else:
            return Action.C

    def _should_enter_recovery_mode(self, history: PlayerHistory) -> bool:
        """Check if pool has been critically low for 2+ consecutive recent rounds."""
        if history is None or len(history.my_payoffs) < 2:
            return False
        collapse_threshold = self.capacity * 0.15
        recent_rounds = min(2, len(history.my_payoffs))
        for i in range(-recent_rounds, 0):
            pass
        recent_payoffs = history.my_payoffs[-2:] if len(history.my_payoffs) >= 2 else history.my_payoffs
        if len(recent_payoffs) >= 2:
            avg_recent = float(np.mean(recent_payoffs))
            if avg_recent < self.capacity / (4 * self.n):
                return True
        return False

    def _calculate_threshold(self, history: PlayerHistory, round_number: int) -> float:
        """Calculate adaptive threshold based on observed defection rate."""
        if history is None or len(history.opponent_actions) == 0:
            return self.base_threshold
        total_opponent_actions = history.opponent_actions.flatten()
        defection_count = np.sum(~total_opponent_actions)
        total_actions = len(total_opponent_actions)
        if total_actions == 0:
            observed_defection_rate = 0.0
        else:
            observed_defection_rate = defection_count / total_actions
        threshold = self.base_threshold
        high_defection_threshold = (self.n - 1) / self.n
        if observed_defection_rate > high_defection_threshold:
            threshold = self.base_threshold * 0.8
        elif observed_defection_rate < 0.3:
            threshold = self.base_threshold * 1.2
        else:
            threshold = self.base_threshold
        if len(history.my_payoffs) > 0 and len(history.opponent_payoffs) > 0:
            my_avg = float(np.mean(history.my_payoffs))
            opponent_avg = float(np.mean(history.opponent_payoffs))
            if my_avg < opponent_avg and opponent_avg > 0:
                threshold = threshold * 0.9
        return threshold

class Strategy_EXPLOITATIVE_80(BaseStrategy):
    """
    Adaptive Extraction: Exploitative strategy for Common Pool Resource games.
    
    Exploits asymmetry between cooperators and defectors while remaining adaptive
    to changing pool conditions. Defects when the pool is healthy, cooperates when
    it's collapsing, and always defects in final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.min_threshold = 2 * self.n * 1.5
        self.recovery_threshold = self.capacity * 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.r - current_round - 1
        if current_round == 0:
            return Action.D
        if current_stock < 2 * self.n:
            return Action.C
        if current_round == self.r - 1:
            if current_stock > self.min_threshold:
                return Action.D
            return Action.C
        if current_stock < self.min_threshold:
            return Action.C
        if current_stock > self.recovery_threshold and rounds_remaining > 2:
            return Action.D
        threshold_range = self.recovery_threshold - self.min_threshold
        if threshold_range <= 0:
            p_defect = 1.0
        else:
            p_defect = (current_stock - self.min_threshold) / threshold_range
            p_defect = max(0.0, min(1.0, p_defect))
        if random.random() < p_defect:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_81(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State Collapse
    
    Maximizes personal extraction by defaulting to defection while strategically
    cooperating only when stock depletion threatens future payoffs. Exploits
    cooperators early, adapts to stock collapse, and maximizes endgame extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.D
        if round_number == self.n_rounds - 1:
            return Action.D
        if round_number == self.n_rounds - 2:
            if current_stock > self.capacity * 0.4:
                return Action.D
            else:
                return Action.C
        rounds_remaining = self.n_rounds - round_number
        if current_stock < self.capacity * 0.15 and rounds_remaining > 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_82(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Core philosophy: Exploit asymmetry between cooperators and defectors while managing
    stock to maximize personal consumption. Defect by default unless specific conditions
    for tactical cooperation are met.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num >= self.n_rounds - 2:
            return Action.D
        if stock < 0.6 * self.capacity:
            return Action.D
        if round_num == 0:
            return Action.D
        total_opponent_defections = 0
        total_opponent_actions = 0
        if history is not None and round_num > 0:
            for r in range(round_num):
                for opponent_idx in range(self.n_players - 1):
                    total_opponent_actions += 1
                    if not history.opponent_actions[r, opponent_idx]:
                        total_opponent_defections += 1
        if total_opponent_actions == 0:
            defection_rate = 0.0
        else:
            defection_rate = total_opponent_defections / total_opponent_actions
        if defection_rate >= 0.7:
            return Action.D
        if defection_rate <= 0.4:
            return Action.C
        p_cooperate = 0.3 + (0.4 - defection_rate)
        p_cooperate = max(0.0, min(1.0, p_cooperate))
        if random.random() < p_cooperate:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_83(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Threshold Management
    
    Exploits the asymmetry between cooperators and defectors by defecting 
    whenever stock is sufficient, only cooperating when stock collapses 
    to preserve minimal regeneration. Treats opponents as resources to harvest.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.D
        if round_number == self.n_rounds - 1:
            return Action.D
        if current_stock < 2 * self.game_description.n_players:
            return Action.C
        if current_stock > self.capacity * 0.75:
            return Action.D
        if current_stock > self.capacity * 0.4:
            return Action.D
        if current_stock > self.capacity * 0.15:
            return Action.D
        if current_stock > self.capacity * 0.1:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_84(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Exploits asymmetric payoff structure by cooperating early to gather information,
    then strategically defecting based on stock levels and opponent behavior.
    Uses stock-dependent thresholds and opponent classification to maximize extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        rho = current_stock / self.capacity if self.capacity > 0 else 0.0
        if rho <= 0.1:
            return Action.D
        defector_count = self._count_defectors(history)
        cooperator_count = self._count_cooperators(history)
        if defector_count >= self.n_players / 2:
            return Action.D
        if rho >= 0.75:
            return Action.D if random.random() < 0.7 else Action.C
        elif 0.4 < rho < 0.75:
            return Action.D
        else:
            return Action.D

    def _count_defectors(self, history: PlayerHistory) -> int:
        """
        Count opponents classified as defectors based on their defection rate.
        A player is a defector if their defection rate >= 0.6
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0
        defector_count = 0
        rounds_played = len(history.opponent_actions)
        for opponent_idx in range(self.n_players - 1):
            opponent_actions = history.opponent_actions[:rounds_played, opponent_idx]
            defections = np.sum(~opponent_actions)
            defection_rate = defections / rounds_played if rounds_played > 0 else 0.0
            if defection_rate >= 0.6:
                defector_count += 1
        return defector_count

    def _count_cooperators(self, history: PlayerHistory) -> int:
        """
        Count opponents classified as cooperators based on their cooperation rate.
        A player is a cooperator if their defection rate <= 0.3
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0
        cooperator_count = 0
        rounds_played = len(history.opponent_actions)
        for opponent_idx in range(self.n_players - 1):
            opponent_actions = history.opponent_actions[:rounds_played, opponent_idx]
            defections = np.sum(~opponent_actions)
            defection_rate = defections / rounds_played if rounds_played > 0 else 0.0
            if defection_rate <= 0.3:
                cooperator_count += 1
        return cooperator_count

class Strategy_EXPLOITATIVE_85(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Defection
    
    Maximizes personal extraction by defecting when profitable, while adaptively
    cooperating only when stock is critically depleted to prevent total collapse.
    Observes opponent behavior and adjusts defection rate accordingly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.total_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == self.total_rounds - 1:
            return Action.D
        critical_threshold = 2 * self.n
        if stock < critical_threshold:
            return Action.C
        if stock >= self.capacity * 0.75:
            return Action.D
        observed_defection_rate = self._calculate_observed_defection_rate(history, round_num)
        if stock >= self.capacity * 0.4:
            return Action.D
        if stock >= self.capacity * 0.15:
            if observed_defection_rate > 1.0 / self.n:
                return Action.D
            else:
                return Action.C
        return Action.C

    def _calculate_observed_defection_rate(self, history: None | PlayerHistory, round_num: int) -> float:
        """
        Calculate the observed defection rate from opponent actions in previous rounds.
        Defection is encoded as False (0), so we count False values and divide by total.
        """
        if history is None or round_num == 0:
            return 0.0
        rounds_played = round_num
        if rounds_played == 0:
            return 0.0
        opponent_actions = history.opponent_actions[:rounds_played, :]
        defection_count = np.sum(opponent_actions == False)
        total_opponent_actions = rounds_played * (self.n - 1)
        if total_opponent_actions == 0:
            return 0.0
        observed_defection_rate = defection_count / total_opponent_actions
        return observed_defection_rate

class Strategy_EXPLOITATIVE_86(BaseStrategy):
    """
    Adaptive Predatory Extraction (APE) Strategy for Common Pool Resource Game.
    
    Exploits the 2x payoff asymmetry of defection, adapting extraction based on:
    - Resource health (stock/capacity ratio)
    - Opponent defection rates
    - Game phase (early/mid/late)
    
    Core philosophy: maximize extraction while minimizing self-harm from collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if stock <= self.capacity * 0.15:
            return Action.D
        if round_num >= self.n_rounds * 0.8:
            return Action.D
        defect_probability = self._calculate_defection_probability(round_num, stock, history)
        if random.random() < defect_probability:
            return Action.D
        else:
            return Action.C

    def _calculate_defection_probability(self, round_num: int, stock: float, history: PlayerHistory) -> float:
        """
        Calculate adaptive defection probability based on:
        1. Resource health (stock_ratio)
        2. Opponent defection rate
        3. Urgency (rounds remaining)
        """
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0.5
        if stock_ratio > 0.6:
            resource_pressure = 0.3
        elif stock_ratio > 0.4:
            resource_pressure = 0.6
        else:
            resource_pressure = 0.85
        opponent_avg_defection = self._calculate_opponent_defection_rate(round_num, history)
        if opponent_avg_defection > 0.7:
            match_factor = 0.85
        elif opponent_avg_defection > 0.4:
            match_factor = 0.65
        else:
            match_factor = 0.95
        rounds_left = self.n_rounds - round_num
        urgency_factor = 1.0 + 0.3 * (1.0 - rounds_left / self.n_rounds)
        base_defection = resource_pressure * match_factor
        final_probability = min(0.95, base_defection * urgency_factor)
        return final_probability

    def _calculate_opponent_defection_rate(self, round_num: int, history: PlayerHistory) -> float:
        """
        Calculate average opponent defection rate across all opponents.
        Weights recent behavior more heavily for recency bias.
        """
        if round_num == 0:
            return 0.5
        opponent_defections = []
        for opponent_idx in range(self.n_players - 1):
            defection_count = np.sum(~history.opponent_actions[:round_num, opponent_idx])
            opponent_rate = defection_count / round_num
            opponent_defections.append(opponent_rate)
        avg_rate = np.mean(opponent_defections) if opponent_defections else 0.5
        if round_num > 3:
            last_5_rounds = min(5, round_num)
            recent_defections = []
            for opponent_idx in range(self.n_players - 1):
                start_idx = max(0, round_num - last_5_rounds)
                recent_count = np.sum(~history.opponent_actions[start_idx:round_num, opponent_idx])
                recent_rate = recent_count / last_5_rounds
                recent_defections.append(recent_rate)
            recent_avg = np.mean(recent_defections) if recent_defections else avg_rate
            avg_rate = 0.6 * recent_avg + 0.4 * avg_rate
        return float(avg_rate)

class Strategy_EXPLOITATIVE_87(BaseStrategy):
    """
    Adaptive Predation with Resource Sensing: An exploitative strategy that uses
    stock levels and opponent behavior to maximize extraction while maintaining
    resource regeneration for continued exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high_base = 0.7 * self.capacity
        self.threshold_moderate = 0.4 * self.capacity
        self.threshold_low = 0.3 * self.capacity
        self.cooperation_rate = 0.5
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if round_num == self.r - 1:
            return Action.D
        if history is None or round_num == 0:
            return Action.D
        self._update_metrics(history)
        threshold_high = self._adjust_threshold_high()
        if round_num >= 2:
            stock_trend = self._calculate_stock_trend(history)
            if stock_trend < -0.15:
                return Action.C
        if current_stock < 0.1 * self.capacity:
            return Action.C
        if current_stock > threshold_high:
            return Action.D
        elif current_stock > self.threshold_moderate:
            p_defect = self._calculate_defection_probability(current_stock)
            return Action.D if random.random() < p_defect else Action.C
        else:
            return Action.C

    def _update_metrics(self, history: PlayerHistory) -> None:
        """Update cooperation rate and stock history from history."""
        if len(history.opponent_actions) == 0:
            return
        total_cooperations = np.sum(history.opponent_actions)
        total_observations = history.opponent_actions.size
        if total_observations > 0:
            self.cooperation_rate = total_cooperations / total_observations

    def _adjust_threshold_high(self) -> float:
        """Adjust threshold_high based on observed cooperation rate."""
        if self.cooperation_rate > 0.6:
            return 0.65 * self.capacity
        else:
            return self.threshold_high_base

    def _calculate_defection_probability(self, current_stock: float) -> float:
        """Calculate probability of defection in scarcity phase."""
        denominator = self.threshold_moderate - self.threshold_low
        if denominator <= 0:
            return 0.3
        p_d = max(0.3, (current_stock - self.threshold_low) / denominator)
        return min(1.0, p_d)

    def _calculate_stock_trend(self, history: PlayerHistory) -> float:
        """Calculate stock trend from recent history."""
        if len(history.my_payoffs) < 2:
            return 0.0
        recent_payoff = history.my_payoffs[-1]
        previous_payoff = history.my_payoffs[-2] if len(history.my_payoffs) >= 2 else recent_payoff
        if previous_payoff <= 0:
            return 0.0
        trend = (recent_payoff - previous_payoff) / previous_payoff
        return trend

class Strategy_EXPLOITATIVE_88(BaseStrategy):
    """
    Adaptive Predation with Stock Monitoring: An exploitative strategy that defects
    against cooperators while maintaining resource viability through conditional cooperation.
    Tracks individual opponent cooperation rates and adjusts actions dynamically based on
    stock levels, opponent behavior patterns, and game phase (early, middle, final round).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 2 * self.n_players
        self.opponent_cooperation_counts = np.zeros(self.n_players - 1, dtype=np.int32)
        self.opponent_rounds_observed = np.zeros(self.n_players - 1, dtype=np.int32)
        self.recent_opponent_cooperation = np.zeros((self.n_players - 1, 3), dtype=np.bool_)
        self.recent_cooperation_index = 0

    def _calculate_cooperation_rate(self, opponent_idx: int) -> float:
        """Calculate cooperation rate for an opponent, handling division by zero."""
        if self.opponent_rounds_observed[opponent_idx] == 0:
            return 0.5
        return self.opponent_cooperation_counts[opponent_idx] / self.opponent_rounds_observed[opponent_idx]

    def _calculate_recent_cooperation_rate(self, opponent_idx: int) -> float:
        """Calculate cooperation rate in the most recent 3-round window."""
        recent_count = np.sum(self.recent_opponent_cooperation[opponent_idx, :])
        return recent_count / 3.0

    def _get_opponent_classification(self, coop_rate: float) -> str:
        """Classify opponent based on cooperation rate."""
        if coop_rate >= 0.85:
            return 'unconditional_cooperator'
        elif coop_rate >= 0.6:
            return 'conditional_cooperator'
        elif coop_rate >= 0.4:
            return 'reciprocal_opponent'
        elif coop_rate >= 0.15:
            return 'skeptical_opponent'
        else:
            return 'defector'

    def _detect_cooperation_momentum(self, opponent_idx: int, current_coop_rate: float) -> bool:
        """Detect if opponent is increasing cooperation (apology/reciprocation attempt)."""
        if self.opponent_rounds_observed[opponent_idx] < 4:
            return False
        recent_rate = self._calculate_recent_cooperation_rate(opponent_idx)
        return recent_rate - current_coop_rate >= 0.3

    def _should_defect_uncertain_opponent(self) -> bool:
        """Mixed strategy: defect with 80% probability against uncertain opponents."""
        return random.random() < 0.8

    def _simulate_stock_projection(self, current_stock: float, rounds_remaining: int) -> float:
        """Project stock if all players defect for remaining rounds."""
        stock = current_stock
        for _ in range(min(rounds_remaining, 3)):
            total_consumption = stock
            stock_after = max(0, stock - total_consumption)
            if stock_after <= 0:
                return 0
            growth = 2 * stock_after * (1 - stock_after / self.capacity)
            stock = min(stock_after + growth, self.capacity)
        return stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """Decide action based on current game state and history."""
        if state.round_number == 0:
            return Action.D
        if history is not None and state.round_number > 0:
            for opp_idx in range(self.n_players - 1):
                opponent_action = history.opponent_actions[state.round_number - 1, opp_idx]
                self.opponent_cooperation_counts[opp_idx] += opponent_action
                self.opponent_rounds_observed[opp_idx] += 1
                self.recent_opponent_cooperation[opp_idx, self.recent_cooperation_index] = opponent_action
            self.recent_cooperation_index = (self.recent_cooperation_index + 1) % 3
        if state.round_number == self.n_rounds - 1:
            if state.current_stock > self.critical_threshold:
                return Action.D
            else:
                return Action.C
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - state.round_number
        if current_stock <= self.critical_threshold:
            return Action.C
        projected_stock = self._simulate_stock_projection(current_stock, rounds_remaining)
        if projected_stock <= self.critical_threshold and rounds_remaining > 1:
            return Action.C
        defect_votes = 0
        for opp_idx in range(self.n_players - 1):
            coop_rate = self._calculate_cooperation_rate(opp_idx)
            classification = self._get_opponent_classification(coop_rate)
            has_momentum = self._detect_cooperation_momentum(opp_idx, coop_rate)
            if classification == 'unconditional_cooperator':
                defect_votes += 1
            elif classification == 'conditional_cooperator':
                defect_votes += 1
            elif classification == 'reciprocal_opponent':
                recent_rate = self._calculate_recent_cooperation_rate(opp_idx)
                if recent_rate >= 0.5:
                    defect_votes += 1
                else:
                    defect_votes += 1
            elif classification == 'skeptical_opponent':
                defect_votes += 1
            else:
                defect_votes += 1
            if has_momentum:
                defect_votes += 1
        has_uncertain_opponents = any((0.25 < self._calculate_cooperation_rate(i) < 0.75 for i in range(self.n_players - 1)))
        if has_uncertain_opponents and (not self._should_defect_uncertain_opponent()):
            return Action.C
        if defect_votes > (self.n_players - 1) / 2:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_89(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Stock Monitoring
    
    Exploits the asymmetry between cooperators and defectors while maximizing personal consumption.
    Adapts defection timing based on stock health to sustain exploitation across rounds.
    Treats cooperation as a resource to extract value from, not reciprocate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        total_rounds = self.n_rounds
        if self.capacity <= 0:
            return Action.D
        stock_ratio = current_stock / self.capacity
        rounds_remaining = total_rounds - current_round
        if stock_ratio <= 0.2:
            return Action.C
        if current_round == total_rounds - 1:
            return Action.D
        if stock_ratio >= 0.75:
            return Action.D
        if stock_ratio >= 0.5:
            return Action.D
        if stock_ratio > 0.2:
            if rounds_remaining > 2:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_90(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Defection
    
    Extracts maximum value through three-phase defection while adapting to opponent
    aggression levels. Defects heavily when stock is abundant, conditionally cooperates
    based on stock levels and observed defection rates, and employs special handling
    for first/last rounds and stock collapse scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if current_stock < 2 * self.n_players:
            return Action.C
        if round_num == 0:
            return Action.D
        opponent_aggression = self._calculate_opponent_aggression(history)
        phase1_end = max(1, self.n_rounds // 3)
        phase2_end = max(phase1_end + 1, 2 * self.n_rounds // 3)
        if round_num == self.n_rounds - 1:
            if current_stock > self.capacity * 0.4:
                return Action.D
            else:
                return Action.C
        if self._detect_sudden_aggression_shift(history, round_num):
            return Action.D
        if opponent_aggression > 0.65:
            return Action.D
        elif opponent_aggression < 0.35:
            return self._cooperative_environment_strategy(round_num, current_stock, phase1_end, phase2_end)
        else:
            return self._three_phase_strategy(round_num, current_stock, phase1_end, phase2_end, history)

    def _calculate_opponent_aggression(self, history: PlayerHistory) -> float:
        """Calculate cumulative defection rate of all opponents."""
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        total_defections = float(np.sum(~history.opponent_actions))
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.0
        return total_defections / total_actions

    def _detect_sudden_aggression_shift(self, history: PlayerHistory, round_num: int) -> bool:
        """Detect if opponent aggression increased sharply in the last round."""
        if history is None or round_num < 2:
            return False
        recent_defections = float(np.sum(~history.opponent_actions[-1, :]))
        recent_rate = recent_defections / self.n_players
        if round_num >= 2:
            previous_defections = float(np.sum(~history.opponent_actions[:-1, :]))
            previous_total = history.opponent_actions[:-1, :].size
            previous_rate = previous_defections / previous_total if previous_total > 0 else 0.0
            if recent_rate - previous_rate > 0.3:
                return True
        return False

    def _three_phase_strategy(self, round_num: int, current_stock: float, phase1_end: int, phase2_end: int, history: PlayerHistory) -> Action:
        """Standard three-phase adaptive strategy."""
        if round_num <= phase1_end:
            if current_stock > self.capacity * 0.75:
                return Action.D
            else:
                return Action.C
        elif round_num <= phase2_end:
            if current_stock > self.capacity * 0.6:
                return Action.D
            elif current_stock > self.capacity * 0.3:
                recent_defection_rate = self._calculate_recent_defection_rate(history, 3)
                if recent_defection_rate > 0.5:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        elif current_stock > self.capacity * 0.5:
            return Action.D
        else:
            return Action.C

    def _cooperative_environment_strategy(self, round_num: int, current_stock: float, phase1_end: int, phase2_end: int) -> Action:
        """Exploit cooperative environment with shifted thresholds."""
        if round_num <= phase1_end:
            if current_stock > self.capacity * 0.8:
                return Action.D
            else:
                return Action.C
        elif round_num <= phase2_end:
            if current_stock > self.capacity * 0.6:
                return Action.D
            else:
                return Action.C
        elif current_stock > self.capacity * 0.5:
            return Action.D
        else:
            return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory, window_size: int) -> float:
        """Calculate defection rate of opponents in the last window_size rounds."""
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        window = min(window_size, len(history.opponent_actions))
        recent_actions = history.opponent_actions[-window:, :]
        total_defections = float(np.sum(~recent_actions))
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        return total_defections / total_actions

class Strategy_EXPLOITATIVE_91(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Resource Monitoring
    
    Treats cooperation as a resource to be exploited. Identifies cooperative patterns
    and ruthlessly extracts value through strategic defection while maintaining
    plausible deniability. Uses stock levels and observed defection prevalence to
    decide between exploitation (defect) and infiltration (cooperate).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        defection_prevalence = self._calculate_defection_prevalence(history, current_round)
        if stock_ratio > 0.75:
            return Action.D
        if defection_prevalence > 0.5:
            return Action.D
        if stock_ratio < 0.2:
            return Action.D
        if 0.3 <= stock_ratio < 0.75 and defection_prevalence <= 0.5:
            return Action.C
        return Action.D

    def _calculate_defection_prevalence(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the defection prevalence from the most recent round.
        Returns the fraction of opponents who defected in the previous round.
        
        In the boolean encoding: True = Cooperate (Action.C), False = Defect (Action.D)
        So we count False values to get defections.
        """
        if current_round == 0:
            return 0.0
        previous_round_idx = current_round - 1
        opponent_actions_prev = history.opponent_actions[previous_round_idx, :]
        num_defectors = int(np.sum(opponent_actions_prev == False))
        total_opponents = self.n_players - 1
        if total_opponents <= 0:
            return 0.0
        defection_rate = num_defectors / total_opponents
        return defection_rate

class Strategy_EXPLOITATIVE_92(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy
    
    Maximizes individual payoff through aggressive defection while adaptively managing
    stock depletion. Defects unconditionally in final round and when stock is healthy,
    cooperates only when mathematically forced by critical depletion to enable future
    exploitation opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        lookback_rounds = min(current_round, 5)
        recent_opponent_actions = history.opponent_actions[max(0, current_round - lookback_rounds):current_round, :]
        total_actions = recent_opponent_actions.size
        total_cooperations = np.sum(recent_opponent_actions)
        total_defections = total_actions - total_cooperations
        if total_actions > 0:
            recent_defection_rate = total_defections / total_actions
        else:
            recent_defection_rate = 0.0
        critical_threshold = 2 * self.n_players
        if current_stock <= critical_threshold:
            return Action.D
        healthy_threshold = self.capacity * 0.6
        if current_stock > healthy_threshold:
            return Action.D
        moderate_lower = self.capacity * 0.3
        moderate_upper = self.capacity * 0.6
        if moderate_lower < current_stock <= moderate_upper:
            if recent_defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        if current_stock <= self.capacity * 0.3:
            recovery_probability = current_stock / (self.capacity * 0.3)
            if random.random() < recovery_probability:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_93(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Resource Monitoring
    
    Core approach: Defect aggressively when stock is high, switch to cooperation
    only when stock is critically depleted. Track opponent defection rates to
    adjust exploitation intensity. Always defect in final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainability_threshold = 1.5 * 2 * self.n_players
        self.critical_threshold = self.capacity * 0.4
        self.intermediate_lower = self.capacity * 0.4
        self.intermediate_upper = 1.5 * 2 * self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round >= self.n_rounds - 2:
            return Action.D
        if current_round == 0:
            return Action.D
        opponent_defection_rate = self._calculate_opponent_defection_rate(history, current_round)
        if opponent_defection_rate > 0.6:
            return Action.D
        elif opponent_defection_rate >= 0.3:
            return Action.D
        elif current_round <= self.n_rounds - 3:
            return Action.D
        else:
            return Action.C
        if current_stock > self.sustainability_threshold:
            return Action.D
        elif current_stock >= self.intermediate_lower:
            return Action.D
        elif current_stock < self.critical_threshold:
            return Action.C
        else:
            return Action.D

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the defection rate of opponents in the last 3 rounds.
        Returns a float between 0.0 and 1.0.
        """
        start_round = max(0, current_round - 3)
        end_round = current_round
        if start_round >= end_round:
            return 0.0
        opponent_actions_window = history.opponent_actions[start_round:end_round, :]
        total_actions = opponent_actions_window.size
        total_cooperations = np.sum(opponent_actions_window)
        total_defections = total_actions - total_cooperations
        if total_actions == 0:
            return 0.0
        defection_rate = total_defections / total_actions
        return defection_rate

class Strategy_EXPLOITATIVE_94(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Stockpile Monitoring
    
    This strategy exploits the asymmetry in payoffs by defecting aggressively while
    maintaining minimal cooperation to prevent complete resource collapse. It monitors
    stock levels and opponent cooperation rates to dynamically adjust exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_survival = self.capacity * 0.15
        self.threshold_cooperation = 0.6
        self.multiplier = 1.3
        self.stock_abundant = self.capacity * 0.7
        self.stock_moderate_high = self.capacity * 0.25
        self.stock_desperate = self.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        current_round = state.round_number
        stock = state.current_stock
        if current_round == self.r - 1:
            return Action.D
        if stock < self.threshold_survival:
            return Action.C
        opponent_cooperation_rate = self._calculate_cooperation_rate(history)
        if stock > self.stock_abundant:
            return Action.D
        elif stock >= self.stock_moderate_high:
            if opponent_cooperation_rate > self.threshold_cooperation:
                return Action.D
            else:
                return Action.D
        elif stock < self.threshold_survival:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the historical cooperation rate among all opponents.
        Returns a value between 0 and 1.
        """
        if len(history.opponent_actions) == 0:
            return 0.0
        total_cooperations = np.sum(history.opponent_actions)
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.0
        cooperation_rate = float(total_cooperations) / float(total_actions)
        return cooperation_rate

class Strategy_EXPLOITATIVE_95(BaseStrategy):
    """
    Adaptive Drain: Exploitative Common Pool Resource Strategy
    
    Exploits the asymmetry between cooperative and defective payoffs by:
    1. Defecting when stock is healthy (>60% of capacity) to extract 2x payoff
    2. Cooperating when stock is depleted (<60%) to nurse pool recovery
    3. Always defecting on final round for maximum terminal extraction
    4. Adapting defection threshold based on stock decline rate
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        remaining_rounds = n_rounds - round_num
        self.stock_history.append(stock)
        if round_num == n_rounds - 1:
            return Action.D
        if stock < capacity * 0.15:
            return Action.C
        decline_rate = 0.0
        if len(self.stock_history) >= 2:
            previous_stock = self.stock_history[-2]
            decline_amount = previous_stock - stock
            if capacity > 0:
                decline_rate = decline_amount / capacity
        if decline_rate > 0.05:
            threshold = capacity * 0.5
        else:
            threshold = capacity * 0.6
        if stock > threshold:
            return Action.D
        elif remaining_rounds > 1:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_96(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy with Adaptive Endgame Pivot.
    
    Maximizes personal payoff by exploiting the commons through sustained defection
    in early rounds, then pivoting to cooperation in final rounds only if stock
    becomes critically depleted. This strategy:
    - Always defects in rounds 0 to r-3 (exploitation phase)
    - In rounds r-2 and r-1 (endgame), cooperates if stock ≤ 2n, else defects
    - Exploits cooperative opponents while preserving final-round extraction value
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round < self.n_rounds - 2:
            return Action.D
        critical_threshold = 2 * self.n_players
        if current_stock <= critical_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_97(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Stock Monitoring
    
    Core philosophy: Exploit the asymmetry between cooperators and defectors by
    defecting unconditionally across nearly all stock levels, maximizing immediate
    extraction while monitoring stock to time predation optimally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.D
        if round_number == self.n_rounds - 1:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio > 0.75:
            return Action.D
        elif stock_ratio > 0.5:
            return Action.D
        elif stock_ratio > 0.25:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_98(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Maximizes personal payoff by exploiting asymmetry between cooperation and defection,
    monitoring stock health to avoid complete collapse. Uses early aggression, stock-based
    thresholds, opponent behavior tracking, and terminal round exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.early_phase_end = math.ceil(game_description.n_rounds / 3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        stock = state.current_stock
        if round_number == 0:
            return Action.D
        if round_number == self.n_rounds - 1:
            return Action.D
        if round_number <= self.early_phase_end:
            return Action.D
        stock_depletion_threshold = self.capacity * 0.4
        if stock <= stock_depletion_threshold:
            return Action.D
        if round_number >= 3:
            last_3_rounds_start = max(0, round_number - 3)
            last_3_rounds_opponent_actions = history.opponent_actions[last_3_rounds_start:round_number, :]
            defection_count = np.sum(~last_3_rounds_opponent_actions)
            total_opponent_moves = 3 * (self.n_players - 1)
            if total_opponent_moves > 0:
                defection_density = defection_count / total_opponent_moves
                if defection_density > 0.5:
                    return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_99(BaseStrategy):
    """
    Adaptive Threshold Defection (ATD) Strategy for Common Pool Resource Game.
    
    Exploits cooperative players through strategic defection while remaining sensitive
    to stock depletion dynamics. Uses an adaptive threshold (capacity * (1 - 1/√r))
    to balance exploitation with pool sustainability. Monitors depletion rates to
    detect mutual defection collapse and switches to cooperation defensively.
    Defects unconditionally in final round regardless of stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.exploitation_threshold = self.capacity * (1.0 - 1.0 / math.sqrt(self.n_rounds))
        self.prev_stock = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            self.prev_stock = current_stock
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.capacity * 0.1:
            return Action.C
        if current_round == self.n_rounds - 2:
            if current_stock > self.capacity * 0.3:
                return Action.D
            else:
                return Action.C
        depletion_rate = 0.0
        if history is not None and len(history.my_payoffs) > 0:
            if current_round > 1:
                prev_round_idx = current_round - 1
                my_action_prev = history.my_actions[prev_round_idx]
                my_payoff_prev = history.my_payoffs[prev_round_idx]
                if my_payoff_prev > 0:
                    if my_action_prev:
                        stock_at_prev_start = my_payoff_prev * 2.0 * self.n_players
                    else:
                        stock_at_prev_start = my_payoff_prev * self.n_players
                    total_consumption_prev = 0.0
                    for player_idx in range(self.n_players - 1):
                        opponent_action = history.opponent_actions[prev_round_idx, player_idx]
                        opponent_payoff = history.opponent_payoffs[prev_round_idx, player_idx]
                        if opponent_payoff > 0:
                            if opponent_action:
                                total_consumption_prev += opponent_payoff
                            else:
                                total_consumption_prev += opponent_payoff
                    if my_action_prev:
                        total_consumption_prev += my_payoff_prev
                    else:
                        total_consumption_prev += my_payoff_prev
                    stock_after_consumption = stock_at_prev_start - total_consumption_prev
                    if stock_after_consumption > 0 and self.capacity > 0:
                        growth = 2.0 * stock_after_consumption * (1.0 - stock_after_consumption / self.capacity)
                        stock_at_prev_end = min(stock_after_consumption + growth, self.capacity)
                    else:
                        stock_at_prev_end = 0.0
                    if stock_at_prev_start > 0:
                        depletion_rate = (stock_at_prev_start - current_stock) / stock_at_prev_start
        if depletion_rate > 0.4 and current_stock < self.exploitation_threshold:
            return Action.C
        if current_stock > self.exploitation_threshold:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_100(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Exploits asymmetry between cooperative and defective payoffs by:
    - Defecting when stock levels are healthy (above adaptive threshold)
    - Monitoring opponent defection rates and matching behavior
    - Becoming increasingly aggressive toward end-game
    - Unconditionally defecting in final round
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock_current = state.current_stock
        if round_t == self.r - 1:
            return Action.D
        if stock_current <= 0:
            return Action.D
        if round_t == 0:
            if stock_current >= self.capacity * 0.9:
                return Action.C
            return Action.D
        progress = round_t / self.r
        threshold = self.capacity * (1.0 - progress ** 1.5)
        avg_defection_rate = self._estimate_defection_rate(history, round_t)
        critical_threshold = 0.5 + (self.r - round_t) / (2.0 * self.r)
        if round_t > 0:
            prev_stock = history.opponent_payoffs[round_t - 1, 0] * self.n if round_t > 0 else self.capacity
            if round_t == 1:
                prev_stock = self.capacity
            else:
                prev_stock_approx = self._reconstruct_prev_stock(history, round_t)
                if prev_stock_approx is not None:
                    prev_stock = prev_stock_approx
            if prev_stock > 0:
                depletion_rate = (prev_stock - stock_current) / prev_stock
                if depletion_rate < -0.4:
                    return Action.D
        if stock_current > threshold:
            return Action.D
        if avg_defection_rate > critical_threshold:
            return Action.D
        return Action.C

    def _estimate_defection_rate(self, history: PlayerHistory, round_t: int) -> float:
        """
        Estimate the average defection rate of opponents.
        Defection is inferred from opponent actions (False = defect, True = cooperate).
        """
        if round_t == 0:
            return 0.5
        defection_counts = []
        for past_round in range(round_t):
            defections_this_round = np.sum(~history.opponent_actions[past_round, :])
            defection_counts.append(defections_this_round / self.n)
        if len(defection_counts) == 0:
            return 0.5
        return float(np.mean(defection_counts))

    def _reconstruct_prev_stock(self, history: PlayerHistory, round_t: int) -> float | None:
        """
        Attempt to reconstruct previous stock level from history.
        Uses consumption amounts inferred from opponent payoffs and actions.
        """
        if round_t < 1:
            return None
        try:
            total_consumption_prev = 0
            for past_round in range(round_t - 1):
                cooperators = np.sum(history.opponent_actions[past_round, :])
                defectors = self.n - cooperators
                estimated_stock_then = self.capacity * (1.0 - (past_round / self.r) ** 1.5)
                consumption = cooperators * estimated_stock_then / (2 * self.n) + defectors * estimated_stock_then / self.n
                total_consumption_prev += consumption
            return max(0, self.capacity - total_consumption_prev)
        except Exception:
            return None

class Strategy_EXPLOITATIVE_101(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Dynamic Defection
    
    Exploits the asymmetry between cooperative and defective payoffs by:
    1. Defecting when stock is healthy (2x payoff of cooperation)
    2. Using probabilistic defection in middle-stock zones
    3. Monitoring opponent defection rates to exploit low-defection environments
    4. Always defecting in final rounds and when stock is critically low
    5. Adapting based on observed opponent behavior
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        half_capacity = self.capacity / 2.0
        if half_capacity == 0:
            stock_ratio = 0.0
        else:
            stock_ratio = current_stock / half_capacity
        if round_number == self.n_rounds - 1:
            return Action.D
        if round_number == 0:
            return Action.D
        defection_rate = self._get_defection_rate(history, round_number)
        if stock_ratio >= 1.5:
            return Action.D
        if stock_ratio <= 0.5:
            return Action.D
        if defection_rate < 0.3:
            return Action.D
        if defection_rate >= 0.3 and current_stock < 0.4 * self.capacity:
            return Action.D
        if defection_rate >= 0.6 and current_stock > self.capacity / 2.0:
            if random.random() < 0.2:
                return Action.C
            else:
                return Action.D
        if round_number == self.n_rounds - 2:
            if stock_ratio < 0.8:
                return Action.D
            elif defection_rate < 0.5:
                return Action.D
        if 0.5 < stock_ratio < 1.5:
            prob_defect = 0.7 + (1.5 - stock_ratio) * 0.25
            if random.random() < prob_defect:
                return Action.D
            else:
                return Action.C
        return Action.D

    def _get_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the defection rate from the previous round.
        True/1 = Cooperate, False/0 = Defect
        Defection rate = proportion of players who played Defect (False)
        """
        if round_number == 0 or history is None:
            return 0.0
        previous_round_index = round_number - 1
        opponent_actions_prev = history.opponent_actions[previous_round_index, :]
        num_defectors = np.sum(~opponent_actions_prev)
        defection_rate = float(num_defectors) / float(self.n)
        return defection_rate

class Strategy_EXPLOITATIVE_102(BaseStrategy):
    """
    Adaptive Predation with Sustainability Preservation: A three-tiered exploitation
    strategy that tracks opponent cooperation rates and stock health to systematically
    exploit cooperative players while maintaining the resource pool's viability for
    continued extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        opponent_cooperations = np.sum(history.opponent_actions[:current_round, :])
        opponent_total_actions = (self.n_players - 1) * current_round
        if opponent_total_actions == 0:
            cooperation_rate = 0.0
        else:
            cooperation_rate = opponent_cooperations / opponent_total_actions
        stock_health = current_stock / self.capacity if self.capacity > 0 else 1.0
        if stock_health < 0.05:
            return Action.C
        if stock_health < 0.2:
            return Action.C
        if cooperation_rate >= 0.75 and stock_health >= 0.4:
            return Action.D
        if cooperation_rate >= 0.5 and stock_health >= 0.6:
            return Action.D
        if cooperation_rate >= 0.35 and stock_health >= 0.75:
            return Action.D
        if stock_health >= 0.8:
            return Action.D
        if cooperation_rate < 0.3 and stock_health < 0.4:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_103(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Conditional Cooperation
    
    Exploits asymmetry between cooperators and defectors through strategic defection
    in early/late rounds and conditional cooperation based on observed cooperation rates
    and stock levels. Prioritizes immediate payoff extraction while adapting to pool
    vulnerability and opponent behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.recent_payoffs = []
        self.overall_payoffs = []
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == 1:
            return Action.D
        cooperation_rate = self._calculate_cooperation_rate(history, current_round)
        self.stock_history.append(current_stock)
        if len(history.my_payoffs) > 0:
            self.recent_payoffs.append(history.my_payoffs[-1])
            self.overall_payoffs.append(history.my_payoffs[-1])
            if len(self.recent_payoffs) > 3:
                self.recent_payoffs.pop(0)
        if current_stock < 0.15 * self.capacity:
            return Action.D
        if current_stock < 0.3 * self.capacity and cooperation_rate < 0.4:
            return Action.D
        if cooperation_rate >= 0.5 and current_stock >= 0.75 * self.capacity:
            return Action.D
        if cooperation_rate >= 0.7 and current_stock >= 0.5 * self.capacity:
            return Action.D
        mid_game_start = self.n_rounds // 3
        mid_game_end = 2 * self.n_rounds // 3
        if mid_game_start < current_round < mid_game_end and 0.4 * self.capacity < current_stock < 0.9 * self.capacity and (cooperation_rate > 0.6):
            return Action.C
        if current_stock >= 0.9 * self.capacity and current_round <= self.n_rounds // 2:
            return Action.C
        if self._is_stock_collapsing(current_stock):
            return Action.D
        if self._should_increase_defection():
            return Action.D
        return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the cooperation rate across all opponents in previous rounds.
        Cooperation rate = (total C actions observed) / (total actions possible)
        """
        if current_round == 0:
            return 0.0
        rounds_to_consider = min(current_round, history.opponent_actions.shape[0])
        if rounds_to_consider == 0:
            return 0.0
        total_cooperations = np.sum(history.opponent_actions[:rounds_to_consider, :])
        total_possible = rounds_to_consider * self.n_players
        if total_possible == 0:
            return 0.0
        return float(total_cooperations) / float(total_possible)

    def _is_stock_collapsing(self, current_stock: float) -> bool:
        """
        Check if stock is trending downward for 3+ consecutive rounds.
        """
        if len(self.stock_history) < 3:
            return False
        recent = self.stock_history[-3:]
        return recent[0] > recent[1] and recent[1] > recent[2]

    def _should_increase_defection(self) -> bool:
        """
        Check if recent payoff performance is below overall average.
        If so, become more aggressive.
        """
        if len(self.recent_payoffs) < 3 or len(self.overall_payoffs) < 3:
            return False
        recent_avg = np.mean(self.recent_payoffs)
        overall_avg = np.mean(self.overall_payoffs)
        return recent_avg < overall_avg and len(self.overall_payoffs) >= 6

class Strategy_EXPLOITATIVE_104(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State-Dependent Switching
    
    Treats the common pool as a resource to exploit through defection while
    opportunistically switching to cooperation only when it maximizes personal gain.
    Uses state-dependent logic to adapt between predatory extraction and strategic
    cooperation for pool preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        stock = state.current_stock
        if round_number == self.n_rounds - 1:
            return Action.D
        if stock <= self.capacity / 4:
            return Action.D
        if stock >= 3 * self.capacity / 4 and round_number <= self.n_rounds / 3:
            return Action.C
        if history is not None and len(history.opponent_actions) > 0:
            total_opponent_actions = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
            defection_count = total_opponent_actions - np.sum(history.opponent_actions)
            defection_rate = defection_count / total_opponent_actions if total_opponent_actions > 0 else 0.0
            if defection_rate >= 0.5:
                return Action.D
        if stock >= self.capacity / 2:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_105(BaseStrategy):
    """
    Adaptive Depletion: An exploitative common pool resource strategy that maximizes
    individual payoff by defecting when stock is abundant (exploiting cooperators),
    switching to conditional cooperation only when stock becomes scarce, and then
    aggressively defecting in the endgame to extract remaining value.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        self.stock_history.append(current_stock)
        if round_number == 0:
            return Action.D
        if round_number <= self.n_rounds / 3:
            threshold = self.capacity * 0.4
        elif round_number <= 2 * self.n_rounds / 3:
            threshold = self.capacity * 0.3
        else:
            threshold = self.capacity * 0.1
        if current_stock < 1e-06:
            return Action.D
        if current_stock > threshold:
            return Action.D
        if current_stock <= threshold:
            decline_rate = self._calculate_decline_rate()
            if decline_rate > 2.0:
                return Action.D
            if current_stock > threshold * 1.5:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _calculate_decline_rate(self) -> float:
        """
        Calculate the rate of stock decline over recent rounds.
        Returns average decline per round (absolute change).
        """
        if len(self.stock_history) < 2:
            return 0.0
        recent_window = min(3, len(self.stock_history))
        recent_stocks = self.stock_history[-recent_window:]
        if len(recent_stocks) < 2:
            return 0.0
        total_decline = recent_stocks[0] - recent_stocks[-1]
        avg_decline_per_round = total_decline / (len(recent_stocks) - 1)
        return abs(avg_decline_per_round) / max(self.capacity, 1e-06)

class Strategy_EXPLOITATIVE_106(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Stock Depletion with Conditional Defection
    
    Exploits asymmetry between C and D payoffs by:
    1. Playing C initially to gather information and build false trust
    2. Switching to D when stock drops below sustainable levels
    3. Unconditionally defecting in final rounds
    4. Adapting to observed defection rates in opponent behavior
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - round_num
        if round_num == 0:
            return Action.C
        if rounds_remaining <= 2:
            return Action.D
        if current_stock < 1.5 * self.capacity:
            return Action.D
        if history is not None:
            total_opponent_actions = round_num
            if total_opponent_actions > 0:
                defection_count = np.sum(~history.opponent_actions[:total_opponent_actions, :])
                defection_ratio = defection_count / max(1, total_opponent_actions * self.n_players)
                if defection_ratio > 0.4:
                    return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_107(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Exploitation
    
    Defects aggressively when stock is sufficient, cooperates when stock is depleted.
    Adapts thresholds based on opponent behavior and rounds remaining.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.r - round_number
        if round_number == 0:
            return Action.D
        opponent_defection_rate = self._compute_opponent_defection_rate(history, round_number)
        base_threshold = 3.0 * self.n
        final_round_threshold = 1.0 * self.n
        if opponent_defection_rate > 0.5:
            base_threshold *= 0.9
        elif opponent_defection_rate < 0.2:
            base_threshold *= 1.05
        if rounds_remaining == 1:
            if stock >= final_round_threshold:
                return Action.D
            else:
                return Action.C
        if round_number > 0:
            stock_last_round = self._estimate_stock_last_round(history, round_number)
            if stock_last_round > 0 and (stock_last_round - stock) / stock_last_round > 0.5:
                if stock < self.n:
                    return Action.C
        if stock < 0.5 * self.n:
            return Action.C
        if stock >= base_threshold:
            return Action.D
        elif stock >= 1.5 * self.n:
            return Action.D
        else:
            return Action.C

    def _compute_opponent_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Compute the average defection rate among opponents based on observed history.
        Returns a value in [0, 1] where 1 = all defections, 0 = all cooperations.
        """
        if round_number <= 1:
            return 0.5
        past_actions = history.opponent_actions[:round_number, :]
        defections = np.sum(~past_actions)
        total_actions = past_actions.size
        if total_actions == 0:
            return 0.5
        return float(defections / total_actions)

    def _estimate_stock_last_round(self, history: PlayerHistory, round_number: int) -> float:
        """
        Estimate stock level at the start of the previous round.
        Uses payoff information to back-calculate stock.
        """
        if round_number == 0:
            return self.capacity
        prev_round = round_number - 1
        my_action = history.my_actions[prev_round]
        my_payoff = history.my_payoffs[prev_round]
        if my_payoff <= 0:
            return 0.0
        if my_action:
            estimated_stock = my_payoff * 2 * self.n
        else:
            estimated_stock = my_payoff * self.n
        return min(estimated_stock, self.capacity)

class Strategy_EXPLOITATIVE_108(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Conditional Cooperation
    
    Prioritizes extracting maximum personal value while maintaining stock viability.
    Uses stock-dependent thresholds to decide between cooperation and defection,
    with special handling for first/last rounds and adaptive adjustments based on
    opponent cooperation rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        min_sustainable = 2 * self.n_players
        if current_stock < min_sustainable:
            return Action.C
        remaining_rounds = self.n_rounds - round_num
        threshold = self.capacity * (1.0 - math.sqrt(remaining_rounds / self.n_rounds))
        if history is not None:
            opponent_cooperations = np.sum(history.opponent_actions[:round_num, :])
            total_opponent_actions = round_num * self.n_players
            if total_opponent_actions > 0:
                opponent_coop_rate = opponent_cooperations / total_opponent_actions
                if opponent_coop_rate > 0.7:
                    threshold *= 0.9
                elif opponent_coop_rate < 0.3:
                    threshold *= 1.05
        if current_stock >= threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_109(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Extraction with Depletion Monitoring
    
    Exploits the asymmetry between cooperative and defective payoffs by monitoring
    stock levels. Defects aggressively when stock is healthy, switches to strategic
    cooperation only when necessary to prevent total collapse, and defects in the
    final round regardless of stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == self.n_rounds - 1:
            return Action.D
        if round_number == 0:
            return Action.D
        rounds_remaining = self.n_rounds - round_number
        log_term = math.log(rounds_remaining + 1) if rounds_remaining > 0 else 0
        depletion_threshold = self.capacity * (1.0 - 1.0 / self.n_players * log_term)
        if current_stock > depletion_threshold:
            return Action.D
        elif current_stock > 0:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_110(BaseStrategy):
    """
    Exploitative Strategy: Dynamic Defection with Adaptive Thresholds
    
    This strategy systematically defects to maximize immediate extraction from the common pool.
    It uses stock level thresholds and observed defection rates to adapt behavior, but defaults
    to defection across virtually all scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        rounds_remaining = self.n_rounds - current_round
        if history is None:
            return Action.D
        observed_defection_rate = self._calculate_defection_rate(history, current_round)
        if stock_ratio < 0.25:
            return Action.D
        elif stock_ratio < 0.5:
            return Action.D
        elif stock_ratio >= 0.75:
            return Action.D
        else:
            return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the observed defection rate across all opponents in all previous rounds.
        Returns a value in [0, 1] where 1 means all opponents always defected.
        """
        if current_round == 0:
            return 0.0
        previous_rounds = history.opponent_actions[:current_round, :]
        total_actions = previous_rounds.size
        if total_actions == 0:
            return 0.0
        cooperations = np.sum(previous_rounds)
        defections = total_actions - cooperations
        defection_rate = defections / total_actions
        return defection_rate

class Strategy_EXPLOITATIVE_111(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Resource Collapse Prevention
    
    Exploits cooperators ruthlessly while maintaining enough stock to avoid complete collapse.
    Balances short-term extraction against others' cooperation with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_minimum = 0.15 * self.capacity
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        self.stock_history.append(current_stock)
        if current_round == 0:
            return Action.D
        if current_stock < self.threshold_minimum:
            return Action.C
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= 2:
            return Action.D
        opponent_defection_rate = self._calculate_opponent_defection_rate(history)
        if opponent_defection_rate > 0.6:
            return Action.D
        if opponent_defection_rate < 0.3:
            return Action.D
        recent_stock_growth_rate = self._calculate_stock_growth_rate()
        if recent_stock_growth_rate > 0.1 * self.capacity:
            return Action.D
        else:
            return Action.C

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate opponent defection rate based on recent history.
        Uses last k rounds where k = min(3, rounds_elapsed).
        """
        rounds_elapsed = history.opponent_actions.shape[0]
        k = min(3, rounds_elapsed)
        if rounds_elapsed == 0 or k == 0:
            return 0.5
        recent_actions = history.opponent_actions[-k:, :]
        defection_count = np.sum(~recent_actions)
        total_actions = (self.n_players - 1) * k
        if total_actions == 0:
            return 0.5
        defection_rate = defection_count / total_actions
        return defection_rate

    def _calculate_stock_growth_rate(self) -> float:
        """
        Calculate recent stock growth rate.
        Uses (current_stock - stock_two_rounds_ago) / stock_two_rounds_ago if available,
        otherwise estimates from (current_stock - previous_stock).
        """
        if len(self.stock_history) < 2:
            return 0.0
        current_stock = self.stock_history[-1]
        previous_stock = self.stock_history[-2]
        if previous_stock <= 0:
            return 0.0
        if len(self.stock_history) >= 3:
            stock_two_rounds_ago = self.stock_history[-3]
            if stock_two_rounds_ago > 0:
                growth_rate = (current_stock - stock_two_rounds_ago) / stock_two_rounds_ago
                return growth_rate
        growth_rate = (current_stock - previous_stock) / previous_stock
        return growth_rate

class Strategy_EXPLOITATIVE_112(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Collapse Timing
    
    Treats the common pool as a resource to extract maximum value before collapse,
    adapting to stock state. Defects by default except during strategic recovery phases
    when stock is critically low and multiple rounds remain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.D
        if round_number == self.n_rounds - 1:
            return Action.D
        if current_stock > self.capacity * 0.7:
            return Action.D
        if current_stock > self.capacity * 0.3:
            return Action.D
        rounds_remaining = self.n_rounds - round_number
        if rounds_remaining >= 3:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_113(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Dynamic Thresholds
    
    This strategy maximizes personal extraction from the common pool by always defecting.
    It treats cooperators' stabilization efforts as opportunities to free-ride, and maintains
    defection regardless of stock health because defection strictly dominates cooperation
    in every round (stock/n > stock/(2n) for all n >= 2).
    
    Core insight: In simultaneous-move games with a dominant strategy, defection is always
    optimal. Stock dynamics are irrelevant—we extract maximum value every round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if capacity <= 0:
            return Action.D
        stock_ratio = current_stock / capacity
        if stock_ratio > 0.75:
            return Action.D
        elif stock_ratio >= 0.5:
            return Action.D
        elif stock_ratio >= 0.25:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_114(BaseStrategy):
    """
    Exploitative strategy with adaptive depletion and conditional defection.
    
    Defaults to defection to maximize payoffs (2x cooperation), but strategically
    cooperates to prevent stock collapse and maintain future extraction opportunities.
    Adapts based on observed opponent cooperation rates and remaining rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        rounds_played = state.round_number
        rounds_remaining = self.total_rounds - rounds_played
        if rounds_played == 0:
            return Action.D
        opponent_cooperations = np.sum(history.opponent_actions)
        opponent_total = history.opponent_actions.size
        if opponent_total > 0:
            opponent_coop_rate = opponent_cooperations / opponent_total
        else:
            opponent_coop_rate = 0.5
        if rounds_remaining <= 2:
            if current_stock > self.capacity * 0.5:
                return Action.D
            else:
                return Action.C
        if current_stock < 2 * self.n:
            if current_stock <= 2 * self.n:
                return Action.C
        threshold_factor = 0.35 + rounds_remaining / self.total_rounds * 0.25
        if opponent_coop_rate > 0.6:
            threshold_factor *= 0.8
        elif opponent_coop_rate < 0.3:
            threshold_factor *= 1.15
        if current_stock < self.capacity * threshold_factor:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_115(BaseStrategy):
    """
    Adaptive Predation: Exploitative Common Pool Resource Strategy
    
    Maximizes personal payoff by exploiting cooperative players while adapting to defectors.
    Uses empirical cooperation rates, stock health, and game phase to decide between
    cooperation and defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = [game_description.capacity]
        self.cooperation_count = 0
        self.defection_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if round_number == 0:
            return Action.D
        if round_number > 0:
            prev_action_was_coop = history.my_actions[round_number - 1]
            if prev_action_was_coop:
                self.cooperation_count += 1
            else:
                self.defection_count += 1
            self.stock_history.append(current_stock)
        total_rounds_observed = round_number
        if total_rounds_observed > 0:
            total_opponent_actions = history.opponent_actions[:round_number, :].sum()
            total_possible = total_rounds_observed * self.game_description.n_players
            empirical_cooperation_rate = total_opponent_actions / total_possible if total_possible > 0 else 0
        else:
            empirical_cooperation_rate = 0
        stock_health = current_stock / capacity if capacity > 0 else 0
        stock_trend = 0
        if len(self.stock_history) >= 4:
            older_stock = self.stock_history[-4]
            newer_stock = self.stock_history[-1]
            if older_stock > 0:
                stock_trend = (newer_stock - older_stock) / older_stock
        defections_recent = 0
        if round_number >= 1:
            if not history.opponent_actions[round_number - 1, :].any():
                defections_recent += 1
        if round_number >= 2:
            if not history.opponent_actions[round_number - 2, :].any():
                defections_recent += 1
        rounds_remaining = n_rounds - round_number
        if round_number == n_rounds - 1:
            return Action.D
        if stock_health < 0.3:
            return Action.D
        if empirical_cooperation_rate > 0.5:
            return Action.D
        if stock_trend < 0 and defections_recent >= 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_116(BaseStrategy):
    """
    Adaptive Predation with Stock Monitoring: An exploitative strategy that defects when
    stock is abundant, cooperates when stock is depleted to allow regeneration, and always
    defects in end-game. Adapts thresholds based on observed opponent cooperation rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high_base = self.capacity * 0.65
        self.threshold_low = self.capacity * 0.25
        self.critical_threshold = max(2, math.ceil(self.r / 4))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        rounds_remaining = self.r - round_num
        if round_num == 0:
            return Action.D
        if rounds_remaining <= 1:
            return Action.D
        threshold_high = self.threshold_high_base
        if history is not None and round_num > 0:
            cooperators_last = int(np.sum(history.opponent_actions[round_num - 1, :]))
            cooperation_rate = cooperators_last / self.n
            if cooperation_rate > 0.5:
                threshold_high = self.capacity * 0.7
            elif cooperation_rate < 0.25:
                threshold_high = self.capacity * 0.5
        if stock <= self.threshold_low and rounds_remaining > 1:
            return Action.C
        if stock > threshold_high:
            return Action.D
        elif rounds_remaining > self.critical_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_117(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Extraction with Collapse Prevention
    
    Extracts maximum personal value while maintaining just enough stock sustainability.
    Uses stock health thresholds and opponent defection modeling to decide between
    cooperation and defection, with special handling for collapse prevention.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number
        if round_number == 0:
            return Action.D
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        avg_defection_rate = self._calculate_opponent_defection_rate(history, round_number)
        if avg_defection_rate > 0.7:
            high_threshold = 0.85
            mid_threshold = 0.5
        else:
            high_threshold = 0.75
            mid_threshold = 0.4
        if stock_health < 0.1 and rounds_remaining > 1:
            return Action.C
        if round_number == self.n_rounds - 1:
            if stock_health > 0.15:
                return Action.D
            else:
                return Action.C
        if stock_health > high_threshold:
            return Action.D
        elif stock_health > mid_threshold:
            if rounds_remaining > 3:
                return Action.C
            else:
                return Action.D
        elif stock_health > 0.15:
            return Action.D
        else:
            return Action.C

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the average defection rate of opponents across all previous rounds.
        
        Args:
            history: PlayerHistory object containing opponent actions
            current_round: Current round number (0-indexed)
        
        Returns:
            Average defection rate as a float between 0 and 1
        """
        if current_round == 0:
            return 0.5
        opponent_actions = history.opponent_actions[:current_round, :]
        total_defections = np.sum(~opponent_actions)
        total_actions = opponent_actions.size
        if total_actions == 0:
            return 0.5
        defection_rate = float(total_defections) / float(total_actions)
        return defection_rate

class Strategy_EXPLOITATIVE_118(BaseStrategy):
    """
    Adaptive Predatory Extraction (APE): An exploitative strategy that maximizes
    personal payoff by defecting in nearly all circumstances, exploiting the
    asymmetry between cooperation (S/2n) and defection (S/n) payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        stock_health_threshold = self.capacity * 0.2
        if current_stock < stock_health_threshold:
            return Action.D
        if history is not None and current_round > 0:
            opponent_actions = history.opponent_actions[:current_round, :]
            total_opponent_actions = opponent_actions.size
            if total_opponent_actions > 0:
                total_defections = np.sum(~opponent_actions)
                defection_rate = total_defections / total_opponent_actions
                if defection_rate > 0.3:
                    return Action.D
            recent_rounds_to_check = min(3, current_round)
            recent_opponent_actions = opponent_actions[-recent_rounds_to_check:, :]
            if recent_opponent_actions.size > 0:
                recent_cooperation_rate = np.sum(recent_opponent_actions) / recent_opponent_actions.size
                if recent_cooperation_rate > 0.6:
                    return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_119(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Switching
    
    Maximizes personal extraction by defaulting to defection while monitoring stock levels.
    Only cooperates when stock falls below a critical threshold that reflects remaining rounds,
    exploiting the 2x payoff advantage of defection over cooperation in abundant stock conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        threshold = 2 * self.n_players * (self.n_rounds - current_round) / self.n_rounds
        if current_stock < threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_120(BaseStrategy):
    """
    Adaptive Predatory Strategy for Common Pool Resource Game.
    
    Exploits cooperative players while maintaining stock viability through
    strategic defection and selective cooperation. Core mechanism: defect
    by default, cooperate only when stock health requires it.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_critical = self.capacity * 0.2
        self.threshold_recovery = self.capacity * 0.6
        self.endgame_threshold = self.n_rounds * 0.25
        self.cooperation_threshold = 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decide action based on current stock and historical opponent behavior.
        """
        if state.round_number == 0:
            return Action.D
        recent_opponent_cooperation = self._calculate_opponent_cooperation_rate(history, state.round_number)
        stock_trend = self._calculate_stock_trend(history, state.round_number)
        rounds_remaining = self.n_rounds - state.round_number
        if state.current_stock < self.threshold_critical:
            return Action.C
        if rounds_remaining <= self.endgame_threshold and state.current_stock > self.threshold_recovery:
            return Action.D
        if recent_opponent_cooperation < self.cooperation_threshold:
            return Action.D
        if stock_trend < 0:
            return Action.C
        return Action.D

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the cooperation rate of opponents in recent rounds.
        Uses last 3 rounds if available, otherwise uses all available history.
        Returns float in [0, 1].
        """
        if current_round == 0:
            return 0.5
        window_size = min(3, current_round)
        start_idx = current_round - window_size
        opponent_actions_window = history.opponent_actions[start_idx:current_round, :]
        total_cooperations = np.sum(opponent_actions_window)
        total_possible = window_size * self.n_players
        if total_possible == 0:
            return 0.5
        return float(total_cooperations / total_possible)

    def _calculate_stock_trend(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate stock trend: avg stock of last 3 rounds minus avg of 3 rounds before that.
        Returns float (positive = increasing, negative = decreasing).
        """
        if current_round < 2:
            return 0.0
        window_size = min(3, current_round)
        if current_round < 2 * window_size:
            return 0.0
        recent_start = current_round - window_size
        recent_end = current_round
        prev_start = current_round - 2 * window_size
        prev_end = current_round - window_size
        recent_payoffs = history.my_payoffs[recent_start:recent_end]
        prev_payoffs = history.my_payoffs[prev_start:prev_end]
        if len(recent_payoffs) == 0 or len(prev_payoffs) == 0:
            return 0.0
        avg_recent = np.mean(recent_payoffs)
        avg_prev = np.mean(prev_payoffs)
        trend = avg_recent - avg_prev
        return float(trend)

class Strategy_EXPLOITATIVE_121(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Contingent Defection
    
    Exploits asymmetry between defection (S/n) and cooperation (S/2n) payoffs by:
    1. Starting with cooperation to gather information
    2. Switching to defection when stock falls below 40% capacity
    3. Matching opponent defection rates
    4. Always defecting in the final round
    5. Opportunistically cooperating only when conditions are favorable
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round - 1
        if rounds_remaining == 0:
            return Action.D
        if current_round == 0:
            return Action.C
        k = min(3, current_round)
        recent_rounds = history.opponent_actions[max(0, current_round - k):current_round]
        if recent_rounds.shape[0] > 0:
            total_actions = recent_rounds.shape[0] * recent_rounds.shape[1]
            defection_count = total_actions - np.sum(recent_rounds)
            recent_defection_rate = defection_count / total_actions if total_actions > 0 else 0.0
        else:
            recent_defection_rate = 0.0
        if current_stock < self.capacity * 0.4:
            return Action.D
        if recent_defection_rate > 0.5:
            return Action.D
        if rounds_remaining == 1:
            if current_stock >= self.capacity * 0.5 and recent_defection_rate <= 0.33:
                return Action.C
            else:
                return Action.D
        if current_stock < 2 * self.n_players:
            return Action.D
        if current_stock >= self.capacity * 0.4 and recent_defection_rate <= 0.33 and (rounds_remaining > 1) and (current_stock > 2 * self.n_players):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_122(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Defection
    
    This strategy exploits asymmetric payoffs by aggressively extracting value
    when conditions permit, while strategically cooperating only to preserve stock
    for future exploitation. Core mechanisms:
    1. Stock-threshold based defection calibrated to logistic growth
    2. Observational exploitation of cooperative opponents
    3. Cascade collapse recovery for self-preservation
    4. Always defect in final round
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        sqrt_r = math.sqrt(self.n_rounds)
        self.critical_threshold = self.capacity * (1.0 - 1.0 / sqrt_r)
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock = state.current_stock
        if round_t == self.n_rounds - 1:
            return Action.D
        if round_t == 0:
            return Action.D
        opponent_coop_rate = self._calculate_opponent_coop_rate(history, round_t)
        if self._is_stock_collapsing(history, stock):
            if stock < self.critical_threshold:
                return Action.C
        if opponent_coop_rate > 0.6:
            return Action.D
        if round_t == self.n_rounds - 2:
            if stock > self.critical_threshold * 1.5:
                return Action.D
            elif stock <= self.critical_threshold and self.n_rounds - round_t > 1:
                return Action.C
            else:
                return Action.D
        if stock > self.critical_threshold:
            return Action.D
        if stock <= self.critical_threshold and self.n_rounds - round_t > 1:
            return Action.C
        return Action.D

    def _calculate_opponent_coop_rate(self, history: PlayerHistory, round_t: int) -> float:
        """
        Calculate the cooperation rate of opponents across all observed rounds.
        Returns a value in [0, 1].
        """
        if round_t <= 0:
            return 0.0
        total_cooperations = np.sum(history.opponent_actions[:round_t, :])
        total_actions = round_t * self.game_description.n_players
        if total_actions == 0:
            return 0.0
        return float(total_cooperations) / float(total_actions)

    def _is_stock_collapsing(self, history: PlayerHistory, current_stock: float) -> bool:
        """
        Detect if stock has declined more than 30% from the previous round
        and is below the critical threshold.
        """
        if len(history.my_payoffs) < 1:
            return False
        if len(history.my_payoffs) < 2:
            return False
        rounds_elapsed = len(history.my_payoffs)
        decline_ratio = 1.0 - current_stock / self.capacity
        if decline_ratio > 0.3 and current_stock < self.critical_threshold:
            return True
        return False

class Strategy_EXPLOITATIVE_123(BaseStrategy):
    """
    Adaptive Depletion with Threshold-Based Exploitation.
    
    A dynamic exploitation strategy that adapts to stock levels and opponent behavior.
    Defaults to defection when stock is abundant, switches to cooperation when preservation
    is necessary for future exploitation. Adjusts aggressiveness based on game phase and
    observed opponent defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.base_threshold = self.capacity * (2.0 - 1.0 / self.n) / 2.0
        self.defection_history = []
        self.prev_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            if self.capacity < 3.0 * self.n:
                return Action.C
            return Action.D
        self._update_defection_history(history, current_round)
        adjusted_threshold = self._compute_adjusted_threshold(current_round, current_stock)
        if current_stock < self.capacity * 0.1:
            return Action.C
        if self.prev_stock is not None and current_stock > self.prev_stock:
            adjusted_threshold *= 0.95
        self.prev_stock = current_stock
        if current_stock > adjusted_threshold:
            return Action.D
        else:
            return Action.C

    def _update_defection_history(self, history: PlayerHistory, current_round: int) -> None:
        """
        Extract defection rates from history up to current round.
        Defection = False/0, Cooperation = True/1
        """
        if current_round > 0 and len(self.defection_history) < current_round:
            for round_idx in range(current_round):
                if round_idx < len(history.opponent_actions):
                    opponent_actions = history.opponent_actions[round_idx, :]
                    defections = np.sum(~opponent_actions)
                    self.defection_history.append(defections)

    def _compute_adjusted_threshold(self, current_round: int, current_stock: float) -> float:
        """
        Compute threshold based on game phase and opponent behavior.
        """
        early_phase_end = max(1, self.r // 3)
        mid_phase_end = max(1, 2 * self.r // 3)
        if current_round < early_phase_end:
            return self.base_threshold
        if current_round < mid_phase_end:
            if len(self.defection_history) > 0:
                total_defections = sum(self.defection_history)
                total_opponent_actions = (self.n - 1) * len(self.defection_history)
                if total_opponent_actions > 0:
                    defection_rate = total_defections / total_opponent_actions
                    if defection_rate > 0.6:
                        return self.base_threshold * 1.1
                    elif defection_rate < 0.3:
                        return self.base_threshold * 0.9
            return self.base_threshold
        rounds_remaining = self.r - current_round
        end_game_phase_length = max(1, self.r // 3)
        if rounds_remaining > 0:
            adjustment_factor = math.sqrt(rounds_remaining / end_game_phase_length)
            return self.base_threshold * adjustment_factor
        return self.base_threshold

class Strategy_EXPLOITATIVE_124(BaseStrategy):
    """
    Adaptive Predation with Damage Control: Exploitative strategy that maximizes personal payoff
    by defecting when stock is abundant, while conditionally cooperating to preserve the resource
    base when stock is critically depleted. Tracks opponent defection rates and adjusts behavior
    to balance exploitation with resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            if stock > 0:
                return Action.D
            else:
                return Action.C
        if stock < 2 * self.n_players:
            return Action.C
        if stock <= self.capacity / 4:
            return Action.C
        if stock > self.capacity / 2:
            return Action.D
        observed_defection_rate = self._calculate_defection_rate(history, round_num - 1)
        if observed_defection_rate > 0.3:
            return Action.D
        else:
            return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, round_index: int) -> float:
        """
        Calculate the defection rate of opponents in a given round.
        Returns the proportion of opponents who defected (Action.D = False).
        """
        if round_index < 0 or round_index >= history.opponent_actions.shape[0]:
            return 0.0
        actions_in_round = history.opponent_actions[round_index, :]
        defections = np.sum(~actions_in_round)
        total_opponents = len(actions_in_round)
        if total_opponents == 0:
            return 0.0
        return float(defections) / float(total_opponents)

class Strategy_EXPLOITATIVE_125(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Extraction
    
    This strategy exploits the asymmetry between cooperative and defective payoffs by:
    1. Always defecting when stock is high (>60% capacity)
    2. Analyzing opponent behavior in mid-game to confirm exploitation
    3. Unconditionally defecting in final rounds for maximum extraction
    4. Relentlessly extracting from cooperative opponents while they sustain the pool
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round <= 2:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        opponent_defection_rate = self._calculate_recent_defection_rate(history, current_round)
        stock_threshold = self.capacity * 0.6
        if current_stock > stock_threshold:
            return Action.D
        elif current_stock > 0:
            if opponent_defection_rate > 0.4:
                return Action.D
            else:
                return Action.D
        else:
            return Action.D

    def _calculate_recent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the percentage of opponents playing defection in the last 3 rounds.
        
        Args:
            history: PlayerHistory object containing opponent actions
            current_round: Current round number (0-indexed)
        
        Returns:
            Defection rate as a float between 0 and 1
        """
        window_size = min(3, current_round)
        if window_size == 0:
            return 0.0
        recent_rounds_start = current_round - window_size
        recent_actions = history.opponent_actions[recent_rounds_start:current_round, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        defections = np.sum(~recent_actions)
        defection_rate = defections / total_actions
        return float(defection_rate)

class Strategy_EXPLOITATIVE_126(BaseStrategy):
    """
    Adaptive Predation: An exploitative strategy that defects when stock is high
    to capture 2x payoffs, cooperates only when stock is critically depleted or
    recovery is needed, and abandons restraint in final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        rounds_remaining = self.n_rounds - round_num
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            if stock > 0:
                return Action.D
            else:
                return Action.C
        if round_num == self.n_rounds - 2:
            if stock > self.capacity / 2:
                return Action.D
            else:
                return Action.C
        if stock < self.capacity / 4 and rounds_remaining > 3:
            return Action.C
        threshold = self.capacity * (1 - 1 / math.sqrt(self.n_players + 1))
        if stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_127(BaseStrategy):
    """
    Adaptive Predation: An exploitative common pool resource strategy that maximizes
    individual extraction by defecting against cooperators while monitoring opponent
    behavior to avoid complete stock collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        critical_threshold = self.capacity * 0.2
        if stock <= critical_threshold:
            return Action.D
        cooperation_rate = self._calculate_cooperation_rate(history, round_num)
        if cooperation_rate > 0.5:
            return Action.D
        elif cooperation_rate >= 0.2:
            return Action.D if random.random() < 0.8 else Action.C
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the rate at which opponents cooperated in previous rounds.
        Returns a value between 0 and 1, where 1 means all opponents always cooperated.
        """
        if round_num == 0:
            return 0.0
        total_cooperations = 0
        total_observations = 0
        for r in range(round_num):
            cooperations_this_round = int(np.sum(history.opponent_actions[r, :]))
            total_cooperations += cooperations_this_round
            total_observations += self.n_players - 1
        if total_observations == 0:
            return 0.0
        cooperation_rate = total_cooperations / total_observations
        return cooperation_rate

class Strategy_EXPLOITATIVE_128(BaseStrategy):
    """
    Exploitative Adaptive Depletion with Conditional Defection.
    
    This strategy prioritizes immediate extraction over sustainability.
    It cooperates only when a sustainable cooperator majority (≥60%) exists
    and future rounds remain. Otherwise, it defects to maximize extraction.
    Always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.6
        self.stock_threshold = game_description.capacity * 0.15
        self.coop_count = 0
        self.total_rounds_observed = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == n_rounds - 1:
            return Action.D
        if stock <= self.stock_threshold:
            return Action.D
        if history is not None and current_round > 0:
            total_coop = np.sum(history.opponent_actions[:current_round, :])
            total_possible = current_round * n_players
            if total_possible > 0:
                coop_rate = total_coop / total_possible
            else:
                coop_rate = 0.0
        else:
            coop_rate = 0.0
        if coop_rate >= self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_129(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy
    
    Operates on the principle of maximizing immediate extraction while exploiting
    cooperators and only cooperating when scarcity forces it to be rational.
    Key tactics: unconditional defection in first and last rounds, adaptive defection
    in middle rounds based on stock level, and aggressive extraction to suppress regrowth.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        scarcity_threshold = self.capacity * 0.5
        if current_stock < 2 * self.n_players:
            return Action.D
        if current_stock > scarcity_threshold:
            return Action.D
        defection_payoff = current_stock / self.n_players
        cooperation_payoff = current_stock / (2 * self.n_players)
        stock_after_all_defect = current_stock - current_stock
        estimated_growth_all_defect = 0.0
        total_coop_consumption = current_stock / 2.0
        stock_after_all_coop = current_stock - total_coop_consumption
        if stock_after_all_coop > 0 and stock_after_all_coop <= self.capacity:
            estimated_growth_all_coop = 2.0 * stock_after_all_coop * (1.0 - stock_after_all_coop / self.capacity)
        else:
            estimated_growth_all_coop = 0.0
        estimated_next_stock_coop = min(stock_after_all_coop + estimated_growth_all_coop, self.capacity)
        remaining_rounds = self.n_rounds - current_round
        if remaining_rounds > 0:
            estimated_future_coop_payoff = estimated_next_stock_coop / (2 * self.n_players) / remaining_rounds
        else:
            estimated_future_coop_payoff = 0.0
        if defection_payoff < cooperation_payoff + estimated_future_coop_payoff:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_130(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Sustainability Threshold
    
    Treats the common pool as a resource to extract maximum personal value while
    minimizing competitors' extraction opportunities. Uses a sustainability threshold
    to determine when defection becomes counterproductive, but otherwise prioritizes
    immediate gains through defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainability_threshold = self.capacity * (1.0 - math.sqrt(2.0 / self.n_players))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            if current_stock > 0:
                return Action.D
            else:
                return Action.C
        if current_stock > self.sustainability_threshold:
            return Action.D
        if current_stock <= self.sustainability_threshold and rounds_remaining > 1:
            if history is not None and current_round > 0:
                last_round_actions = history.opponent_actions[current_round - 1, :]
                defectors = np.sum(~last_round_actions)
                defection_rate = defectors / self.n_players
                if defection_rate > 0.5:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        if current_stock <= 0 or current_stock <= self.sustainability_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_131(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy
    
    Maximizes personal gain through aggressive early defection, dynamic adaptation
    based on opponent cooperation rates, and stock-level thresholds. Exploits the
    2x payoff asymmetry (D yields stock/n vs C yields stock/2n) while adapting
    to scarcity conditions and endgame dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_coop_count = 0
        self.opponent_total_actions = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            return Action.D
        if history is not None and current_round > 0:
            prev_round_idx = current_round - 1
            coop_this_round = int(np.sum(history.opponent_actions[prev_round_idx, :]))
            self.opponent_coop_count += coop_this_round
            self.opponent_total_actions += self.n_players - 1
        if self.opponent_total_actions > 0:
            opponent_coop_rate = self.opponent_coop_count / self.opponent_total_actions
        else:
            opponent_coop_rate = 0.0
        if rounds_remaining <= 1:
            return Action.D
        if current_stock < self.capacity * 0.2:
            return Action.C
        if current_stock < 0.01:
            return Action.D
        if current_stock > self.capacity * 0.5:
            return Action.D
        if opponent_coop_rate > 0.6:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_132(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Exploits asymmetry between cooperators and defectors by strategically switching
    between cooperation (to maintain stock) and defection (to harvest surplus).
    Uses stock-responsive thresholds and round-phase-dependent behavior to maximize
    individual extraction while preventing catastrophic pool collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        critical_threshold = self.capacity * (1.0 - 1.0 / math.sqrt(self.n_rounds))
        rounds_remaining = self.n_rounds - round_num
        if round_num == 0:
            return Action.D
        if rounds_remaining == 1:
            return Action.D
        if stock < self.capacity * 0.1:
            return Action.C
        if round_num <= self.n_rounds / 3.0:
            return Action.D
        if stock > critical_threshold:
            return Action.D
        elif stock > self.capacity * 0.15:
            return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_133(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State-Aware Defection
    
    Core philosophy: Ruthlessly exploit the 2x payoff advantage of defection while
    remaining sensitive to stock depletion. Defect aggressively when stock is abundant,
    switch to cooperation strategically when stock is depleted (to enable recovery via
    growth mechanism), and always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        rounds_remaining = self.n_rounds - round_num - 1
        defection_rate = self._calculate_defection_rate(history, round_num)
        if round_num == self.n_rounds - 1:
            return Action.D
        if stock_ratio > 0.5:
            return Action.D
        elif stock_ratio > 0.2:
            if defection_rate > 0.6:
                return Action.C
            else:
                return Action.D
        elif rounds_remaining <= 2:
            return Action.D
        else:
            return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the defection rate of opponents across all observed rounds.
        Defection is encoded as False (0), Cooperation as True (1).
        Defection rate = proportion of defections observed.
        """
        if current_round == 0:
            return 0.0
        total_observed = current_round * self.n_players
        if total_observed == 0:
            return 0.0
        cooperations = np.sum(history.opponent_actions[:current_round, :])
        defections = total_observed - cooperations
        defection_rate = defections / total_observed if total_observed > 0 else 0.0
        return defection_rate

class Strategy_EXPLOITATIVE_134(BaseStrategy):
    """
    Adaptive Depletion Strategy: Exploitative common pool resource strategy that
    maximizes personal consumption while minimizing stock availability for others.
    
    Core mechanics:
    - Defect aggressively in early-to-mid game to deplete resources
    - Only cooperate when stock falls below 15% capacity threshold
    - Always defect in final round
    - Exploit cooperators through free-riding; survive against defectors through adaptive transitions
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = game_description.capacity * 0.15
        self.critical_depletion_threshold = game_description.capacity * 0.1
        self.near_full_threshold = game_description.capacity * 0.95

    def _classify_phase(self, round_number: int, n_rounds: int) -> str:
        """Classify game phase: EARLY, MID, or LATE"""
        early_cutoff = math.ceil(n_rounds / 3)
        mid_cutoff = math.floor(2 * n_rounds / 3)
        if round_number < early_cutoff:
            return 'EARLY'
        elif round_number < mid_cutoff:
            return 'MID'
        else:
            return 'LATE'

    def _calculate_recent_depletion_rate(self, history: PlayerHistory, current_stock: float) -> float:
        """Calculate depletion rate from previous round"""
        if len(history.my_payoffs) < 1:
            return 0.0
        prev_round_idx = len(history.my_payoffs) - 1
        prev_stock = current_stock
        if prev_round_idx == 0:
            return 0.0
        if history.my_payoffs[prev_round_idx] > 0:
            recent_depletion_rate = min(0.5, history.my_payoffs[prev_round_idx] / max(1.0, current_stock + history.my_payoffs[prev_round_idx]))
            return recent_depletion_rate
        return 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decide action based on current stock, round number, and game phase.
        """
        stock = state.current_stock
        round_number = state.round_number
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        if round_number == 0:
            return Action.D
        if round_number == n_rounds - 1:
            return Action.D
        if stock <= 0.0:
            return Action.C
        if stock < self.critical_depletion_threshold:
            return Action.C
        if stock > self.near_full_threshold:
            return Action.D
        phase = self._classify_phase(round_number, n_rounds)
        rounds_remaining = n_rounds - round_number
        depleted = stock < self.cooperation_threshold
        if phase in ['EARLY', 'MID']:
            if depleted:
                return Action.C
            else:
                return Action.D
        else:
            if rounds_remaining <= 1:
                return Action.D
            if depleted:
                return Action.C
            if stock > self.cooperation_threshold and rounds_remaining <= 3:
                return Action.D
            if history is not None:
                recent_depletion_rate = self._calculate_recent_depletion_rate(history, stock)
                if recent_depletion_rate > 0.4:
                    return Action.D
            return Action.D

class Strategy_EXPLOITATIVE_135(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with State Monitoring
    
    This strategy implements unconditional defection to maximize payoff extraction
    from the common pool resource game. The core principle is that defection yields
    2x the immediate payoff of cooperation (S/n vs S/(2n)) and is a dominant strategy
    in simultaneous-move games without binding agreements.
    
    Decision Rule: Always defect, regardless of stock level, round number, or observed
    opponent behavior. Defection dominates cooperation in all game states.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initialize the exploitative strategy.
        
        Args:
            game_description: Game parameters (n_players, n_rounds, capacity)
        """
        self.game_description = game_description
        self.cooperation_rate = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Select action based on exploitative defection principle.
        
        Args:
            state: Current game state (round_number, current_stock)
            history: Player history (None on first round, populated thereafter)
            
        Returns:
            Action.D (DEFECT) - unconditional defection strategy
        """
        if state.round_number == 0:
            return Action.D
        if history is not None and len(history.opponent_actions) > 0:
            total_opponent_actions = history.opponent_actions.size
            if total_opponent_actions > 0:
                cooperations = np.sum(history.opponent_actions)
                self.cooperation_rate = cooperations / total_opponent_actions
        stock = state.current_stock
        capacity = self.game_description.capacity
        if stock > capacity * 0.4:
            return Action.D
        elif stock <= capacity * 0.2:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_136(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Threshold Monitoring
    
    Exploits cooperative players ruthlessly while maintaining plausible deniability through
    adaptive defection based on stock health thresholds and opponent behavior observation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == self.n_rounds - 1:
            return Action.D
        if round_num == 0:
            return Action.D
        health = stock / self.capacity if self.capacity > 0 else 0.0
        prev_defection_rate = self._get_previous_defection_rate(history, round_num)
        if health > 0.65:
            return Action.D
        if 0.5 < health <= 0.65:
            defect_probability = (health - 0.5) / 0.15
            return Action.D if random.random() < defect_probability else Action.C
        if health <= 0.5:
            defect_probability = health / 0.5
            return Action.D if random.random() < defect_probability else Action.C
        return Action.C

    def _get_previous_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the defection rate (fraction of opponents who defected) in the previous round.
        Returns 0.0 if this is round 1 (assume cooperators initially).
        """
        if round_num <= 0:
            return 0.0
        prev_round_actions = history.opponent_actions[round_num - 1, :]
        num_defectors = np.sum(~prev_round_actions)
        total_opponents = len(prev_round_actions)
        if total_opponents == 0:
            return 0.0
        return float(num_defectors) / float(total_opponents)

class Strategy_EXPLOITATIVE_137(BaseStrategy):
    """
    Exploitative strategy with adaptive depletion and conditional defection.
    
    Prioritizes immediate payoff extraction while monitoring resource scarcity.
    Switches between defection (abundant phase) and cooperation (scarcity phase)
    based on sustainability ratio, stock velocity, and observed opponent defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            if self.n_players >= 4:
                return Action.D
            elif self.n_players == 2:
                return Action.C
            else:
                return Action.D
        rounds_remaining = self.n_rounds - round_num - 1
        if rounds_remaining == 0:
            return Action.D
        sustainability_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        observed_defection_rate = self._calculate_defection_rate(history, round_num)
        stock_velocity = self._calculate_stock_velocity(history, round_num)
        if sustainability_ratio > 0.5:
            if rounds_remaining == 1:
                return Action.D
            if stock_velocity < -0.05 * self.capacity:
                return Action.D
            if observed_defection_rate > 0.5:
                return Action.D
            return Action.D
        elif sustainability_ratio > 0.25:
            if rounds_remaining <= 2:
                return Action.D
            if observed_defection_rate > 0.75:
                return Action.D
            if self._is_stock_stable(history, round_num) and rounds_remaining > 3:
                return Action.C
            return Action.D
        elif sustainability_ratio > 0.1:
            if observed_defection_rate > 0.8:
                return Action.D
            return Action.C
        else:
            if rounds_remaining == 1:
                return Action.D
            return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate observed defection rate from opponents in last 3 rounds.
        Returns proportion of defections (False values) among all opponent actions.
        """
        if current_round == 0:
            return 0.5
        start_round = max(0, current_round - 3)
        relevant_history = history.opponent_actions[start_round:current_round]
        if relevant_history.size == 0:
            return 0.5
        cooperation_count = np.sum(relevant_history)
        total_actions = relevant_history.size
        if total_actions == 0:
            return 0.5
        defection_rate = 1.0 - cooperation_count / total_actions
        return float(defection_rate)

    def _calculate_stock_velocity(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate stock velocity over last 2 rounds.
        Returns the change in stock per round.
        """
        if current_round < 2:
            return 0.0
        return 0.0

    def _is_stock_stable(self, history: PlayerHistory, current_round: int) -> bool:
        """
        Determine if stock appears stable (not sharply declining).
        Based on observed defection patterns and round progression.
        """
        if current_round < 2:
            return True
        defection_rate = self._calculate_defection_rate(history, current_round)
        return defection_rate < 0.9

class Strategy_EXPLOITATIVE_138(BaseStrategy):
    """
    Exploitative Strategy: Dynamic Threshold Defection with Adaptive Depletion
    
    Maximizes individual payoff by defecting whenever stock is abundant,
    switching to brief cooperation only when necessary to prevent total collapse.
    Tracks opponent behavior and stock depletion rates to adaptively adjust
    sustainability thresholds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        remaining_rounds = self.n_rounds - round_num
        if stock <= self.capacity * 0.02:
            return Action.D
        if round_num == self.n_rounds - 1:
            if stock < self.capacity * 0.05:
                return Action.C
            else:
                return Action.D
        if round_num == 0:
            return Action.D
        threshold = self.capacity * (0.4 - 0.15 * (remaining_rounds / self.n_rounds))
        if round_num >= 3:
            threshold = self._adjust_threshold_by_defection_rate(history, threshold)
        if round_num >= 1:
            threshold = self._adjust_threshold_by_depletion_rate(history, threshold)
        if stock > threshold:
            return Action.D
        else:
            recovery_possible = self._estimate_recovery_possible(stock, remaining_rounds)
            if recovery_possible and remaining_rounds >= 3:
                return Action.C
            else:
                return Action.D

    def _adjust_threshold_by_defection_rate(self, history: PlayerHistory, threshold: float) -> float:
        """Adjust threshold based on recent opponent defection rate (last 3 rounds)."""
        recent_rounds = min(3, history.my_actions.shape[0])
        if recent_rounds == 0:
            return threshold
        defecting_rounds = 0
        for i in range(-recent_rounds, 0):
            cooperators = sum(history.opponent_actions[i, :])
            if cooperators < self.n_players / 2:
                defecting_rounds += 1
        recent_defection_rate = defecting_rounds / recent_rounds if recent_rounds > 0 else 0
        if recent_defection_rate > 0.6:
            threshold = min(threshold * 1.2, self.capacity * 0.5)
        elif recent_defection_rate < 0.3 and history.my_payoffs[-1] > 0:
            threshold = max(threshold * 0.85, self.capacity * 0.05)
        return threshold

    def _adjust_threshold_by_depletion_rate(self, history: PlayerHistory, threshold: float) -> float:
        """Adjust threshold based on recent depletion rate."""
        if history.my_actions.shape[0] < 2:
            return threshold
        prev_round_idx = -2
        curr_round_idx = -1
        cooperators_last = sum(history.opponent_actions[curr_round_idx, :])
        my_action_last = history.my_actions[curr_round_idx]
        total_cooperators = cooperators_last + (1 if my_action_last else 0)
        total_defectors = self.n_players - total_cooperators
        if total_defectors > self.n_players * 0.6:
            threshold = max(self.capacity * 0.05, threshold * 0.8)
        elif total_defectors < self.n_players * 0.3:
            threshold = min(self.capacity * 0.5, threshold * 1.15)
        return threshold

    def _estimate_recovery_possible(self, stock: float, remaining_rounds: int) -> bool:
        """
        Estimate if stock can recover to a meaningful level within remaining rounds.
        
        Stock grows as: growth = 2 * S * (1 - S/capacity)
        This is maximized around S = capacity/2, yielding growth = capacity/2 per round.
        Conservative estimate: assume recovery takes at least 3 rounds from low stock.
        """
        if remaining_rounds < 2:
            return False
        if stock < self.capacity * 0.15:
            return remaining_rounds >= 4
        return True

class Strategy_EXPLOITATIVE_139(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Resilience
    
    Maximizes individual consumption through stock-contingent defection,
    opponent modeling, and end-game exploitation. Treats the game as an
    asymmetric extraction problem where defection yields immediate payoff
    advantages while exploiting stock dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_defection_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        end_game_threshold = math.ceil(self.n_rounds * 0.85)
        if current_round >= end_game_threshold:
            return Action.D
        opponent_defection_rate = self._calculate_opponent_defection_rate(history, current_round)
        if opponent_defection_rate > 0.6:
            return Action.D
        if current_stock < self.capacity * 0.1:
            return Action.C
        if current_stock >= self.capacity:
            return Action.D
        if current_stock > self.capacity * 0.7:
            return Action.D
        elif current_stock > self.capacity * 0.4:
            if current_round <= self.n_rounds / 2:
                return Action.D
            else:
                return Action.C
        elif opponent_defection_rate < 0.3:
            return Action.D
        else:
            return Action.C

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the defection rate of opponents based on observed history.
        Defection is encoded as False (0), Cooperation as True (1).
        """
        if current_round == 0:
            return 0.0
        total_defections = 0
        total_observations = 0
        for round_idx in range(current_round):
            for opponent_idx in range(self.n_players - 1):
                if round_idx < history.opponent_actions.shape[0]:
                    action_was_cooperate = history.opponent_actions[round_idx, opponent_idx]
                    if not action_was_cooperate:
                        total_defections += 1
                    total_observations += 1
        if total_observations == 0:
            return 0.0
        defection_rate = total_defections / total_observations
        return defection_rate

class Strategy_EXPLOITATIVE_140(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Stock Monitoring
    
    This strategy exploits the asymmetry between cooperation (payoff=stock/2n)
    and defection (payoff=stock/n) by defaulting to defection while monitoring
    stock health. It switches to cooperation only when stock depletion threatens
    future payoffs, preventing complete commons collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity * 0.15
        self.collapse_threshold = self.capacity * 0.1
        self.healthy_threshold = self.capacity * 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        rounds_remaining = self.n_rounds - round_num
        if round_num == 0:
            return Action.D
        if stock <= self.critical_threshold:
            return Action.C
        if round_num >= self.n_rounds - 1:
            return Action.D
        if round_num >= self.n_rounds - 2:
            return Action.D
        worst_case_consumption = stock
        worst_case_remaining = stock - worst_case_consumption
        worst_case_growth = 2.0 * worst_case_remaining * (1.0 - worst_case_remaining / self.capacity) if worst_case_remaining > 0 else 0.0
        worst_case_next_stock = min(worst_case_remaining + worst_case_growth, self.capacity)
        if worst_case_next_stock <= self.collapse_threshold:
            return Action.D
        if stock > self.healthy_threshold and rounds_remaining > 2:
            return Action.D
        if round_num >= 2:
            recent_stocks = history.my_payoffs[-2:]
            if len(recent_stocks) >= 2:
                stock_velocity = recent_stocks[-1] - recent_stocks[-2]
                if stock_velocity < 0 and stock < self.capacity * 0.5:
                    return Action.D
        if round_num >= 3:
            recent_rounds = min(3, round_num)
            recent_stock_sum = 0.0
            for i in range(1, recent_rounds + 1):
                recent_stock_sum += history.my_payoffs[-i] if i <= len(history.my_payoffs) else 0.0
            moving_avg = recent_stock_sum / recent_rounds if recent_rounds > 0 else stock
            if moving_avg < self.capacity * 0.2:
                if random.random() < 0.75:
                    return Action.D
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_141(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State-Aware Opportunism
    
    This strategy exploits the 2x payoff multiplier of defection while adapting to
    opponent behavior and stock levels. It uses temporary cooperation as a tool to
    regenerate exploitable resources, then resumes defection when conditions permit.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        defection_ratio = self._calculate_defection_ratio(history, round_num)
        stock_utilization = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_utilization < 0.3:
            if defection_ratio >= 0.75:
                return Action.D
            else:
                return Action.C
        elif 0.3 <= stock_utilization <= 0.6:
            if defection_ratio >= 0.4:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _calculate_defection_ratio(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the ratio of defectors among opponents in the most recent round.
        Returns a value in [0, 1] where 1 means all opponents defected.
        """
        if round_num <= 0 or history is None:
            return 0.0
        recent_round_idx = round_num - 1
        opponent_actions_last_round = history.opponent_actions[recent_round_idx, :]
        num_defectors = np.sum(~opponent_actions_last_round)
        num_opponents = len(opponent_actions_last_round)
        if num_opponents == 0:
            return 0.0
        return float(num_defectors) / float(num_opponents)

class Strategy_EXPLOITATIVE_142(BaseStrategy):
    """
    Adaptive Extraction: An exploitative common pool resource strategy that maximizes
    personal payoff by defecting opportunistically while using pseudo-cooperation in
    high-stock early rounds to exploit conditional cooperators. Uses a dynamic threshold
    based on capacity and remaining rounds to switch between cooperation and defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        if self.n_rounds > 1:
            self.cooperation_threshold = self.capacity * (1.0 - 1.0 / math.sqrt(self.n_rounds))
        else:
            self.cooperation_threshold = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock > self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_143(BaseStrategy):
    """
    Exploitative Strategy: Dynamic Predation with Collapse Acceleration
    
    Maximizes personal payoff by exploiting the asymmetry between cooperation and defection.
    Core approach: always defect when possible, accelerate stock collapse to minimize others' gains,
    and adapt exploitation intensity based on opponent behavior and stock depletion rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity / (self.n_players + 2)
        self.last_stock = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number >= self.n_rounds - 2:
            return Action.D
        current_stock = state.current_stock
        current_round = state.round_number
        depletion_rate = 0.0
        if self.last_stock > 0:
            depletion_rate = (self.last_stock - current_stock) / self.last_stock
        self.last_stock = current_stock
        defectors_observed = 0
        if history is not None and current_round > 0:
            prev_round_opponent_actions = history.opponent_actions[current_round - 1, :]
            defectors_observed = np.sum(~prev_round_opponent_actions)
            defectors_ratio = defectors_observed / (self.n_players - 1) if self.n_players > 1 else 0.0
        else:
            defectors_ratio = 0.0
        if current_stock <= self.critical_threshold:
            return Action.D
        if depletion_rate > 0.5:
            return Action.D
        if defectors_ratio >= 0.5:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_144(BaseStrategy):
    """
    Adaptive Extraction Strategy for Common Pool Resource Game.
    
    Exploits asymmetry between cooperative and defective payoffs by:
    - Defecting when stock is abundant (>60% capacity) to maximize immediate extraction
    - Cooperating only when stock is critical to prevent collapse and enable future exploitation
    - Adapting thresholds based on observed opponent defection rates and stock velocity
    - Always defecting in final round and single-round games
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.base_threshold = 0.6 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.n_rounds - 1:
            return Action.D
        if self.n_rounds == 1:
            return Action.D
        if current_round == 0:
            return self._stock_based_decision(current_stock)
        threshold = self._calculate_adaptive_threshold(history, current_round)
        if current_round >= 1:
            stock_velocity = current_stock - history.my_payoffs[current_round - 1]
            if stock_velocity < 0:
                threshold = 0.45 * self.capacity
        return self._stock_based_decision(current_stock, threshold)

    def _calculate_adaptive_threshold(self, history: PlayerHistory, current_round: int) -> float:
        """Calculate adaptive defection threshold based on opponent behavior."""
        threshold = self.base_threshold
        if current_round > 0:
            opponent_defections = np.sum(~history.opponent_actions[:current_round, :])
            total_opponent_actions = current_round * self.n_players
            if total_opponent_actions > 0:
                opponent_defection_rate = opponent_defections / total_opponent_actions
                if opponent_defection_rate > 0.7:
                    threshold = 0.5 * self.capacity
                elif opponent_defection_rate < 0.3:
                    threshold = 0.7 * self.capacity
        if current_round >= 2:
            stock_prev = history.my_payoffs[current_round - 1]
            stock_prev_prev = history.my_payoffs[current_round - 2]
            if stock_prev < stock_prev_prev and stock_prev_prev < history.my_payoffs[max(0, current_round - 3)] if current_round >= 3 else False:
                threshold = 0.45 * self.capacity
        return threshold

    def _stock_based_decision(self, current_stock: float, threshold: float=None) -> Action:
        """Core stock-based decision logic."""
        if threshold is None:
            threshold = self.base_threshold
        if current_stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_145(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Dynamic Threshold
    
    Exploits the asymmetry between cooperation (C: stock/2n) and defection (D: stock/n).
    Uses stock-dependent thresholds and opponent type classification to maximize extraction
    while maintaining minimal sustainability for future exploitation rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.safe_minimum = 0.3 * self.capacity
        self.exploit_threshold = 1.5 * self.capacity / 2.0

    def _classify_opponent(self, opponent_idx: int, history: PlayerHistory) -> str:
        """
        Classify opponent as COOPERATOR, DEFECTOR, or ADAPTIVE based on history.
        Returns: 'cooperator', 'defector', or 'adaptive'
        """
        if history.opponent_actions.shape[0] == 0:
            return 'adaptive'
        rounds_observed = history.opponent_actions.shape[0]
        cooperations = np.sum(history.opponent_actions[:, opponent_idx])
        if rounds_observed == 0:
            return 'adaptive'
        coop_rate = cooperations / rounds_observed
        if coop_rate > 0.7:
            return 'cooperator'
        elif coop_rate < 0.3:
            return 'defector'
        else:
            return 'adaptive'

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num >= self.n_rounds - 2:
            return Action.D
        if stock < 0.001:
            return Action.C
        if stock < self.safe_minimum:
            return Action.C
        if stock > self.exploit_threshold:
            opponent_types = [self._classify_opponent(i, history) for i in range(self.n_players - 1)]
            if 'cooperator' in opponent_types:
                return Action.D
            return Action.D
        defect_probability = (stock - self.safe_minimum) / (self.exploit_threshold - self.safe_minimum)
        defect_probability = max(0.0, min(1.0, defect_probability))
        if random.random() < defect_probability:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_146(BaseStrategy):
    """
    Adaptive Depletion: An exploitative common pool resource strategy that uses
    stock-conditional defection to maximize extraction while managing resource
    regeneration. Defects aggressively when stock is above dynamic thresholds,
    cooperates minimally to trigger recovery when stock is depleted, and unconditionally
    defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock_t = state.current_stock
        if round_t == self.n_rounds - 1:
            return Action.D
        rounds_remaining = self.n_rounds - round_t
        threshold = self.capacity * (1.0 - rounds_remaining / self.n_rounds) * 0.4
        critical_minimum = self.capacity * 0.15
        if stock_t < critical_minimum:
            return Action.C
        if stock_t > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_147(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy with Adaptive Extraction.
    
    Defects by default to maximize personal extraction, with selective cooperation
    only when strategic pool maintenance unlocks future exploitation opportunities.
    Monitors stock depletion, defection rates, and remaining rounds to adapt extraction behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        remaining_rounds = self.n_rounds - round_num
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        depletion_threshold = self.capacity * 0.25
        if stock < depletion_threshold:
            return Action.D
        recent_window = min(3, round_num)
        if recent_window > 0:
            recent_defections = 0
            for r in range(round_num - recent_window, round_num):
                if r >= 0:
                    defector_count = self.n_players - int(np.sum(history.opponent_actions[r, :]))
                    recent_defections += defector_count
            for r in range(round_num - recent_window, round_num):
                if r >= 0 and (not history.my_actions[r]):
                    recent_defections += 1
            total_actions_observed = recent_window * (self.n_players + 1)
            defection_rate = recent_defections / total_actions_observed if total_actions_observed > 0 else 0.0
            if defection_rate > 0.5:
                return Action.D
        survival_threshold = remaining_rounds * (2 * self.n_players)
        if stock >= survival_threshold:
            return Action.D
        if stock < self.capacity * 0.4 and remaining_rounds > 2:
            coop_window = min(2, round_num)
            if coop_window > 0:
                recent_coop_count = 0
                for r in range(round_num - coop_window, round_num):
                    if r >= 0:
                        recent_coop_count += int(np.sum(history.opponent_actions[r, :]))
                recent_defection_count = coop_window * self.n_players - recent_coop_count
                defection_rate_window = recent_defection_count / (coop_window * self.n_players) if coop_window > 0 else 0.0
                if 0.3 <= defection_rate_window <= 0.5:
                    recent_cooperators = 0
                    for r in range(max(0, round_num - 2), round_num):
                        recent_cooperators += int(np.sum(history.opponent_actions[r, :]))
                    if recent_cooperators >= 2:
                        return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_148(BaseStrategy):
    """
    Adaptive Predation: An exploitative common pool resource strategy that
    prioritizes defection for 2x payoff while remaining adaptive to prevent
    catastrophic stock collapse. Uses threshold-based emergency cooperation,
    endgame exploitation, and opponent-based adaptive responses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_threshold = self.capacity * 0.15
        self.safe_level = self.capacity * 0.5
        self.cooperation_threshold = 0.6
        self.end_game_window = max(3, math.ceil(self.r * 0.15))
        self.cooperation_lookback = 5
        self.stock_forecast_horizon = 3
        self.high_stock_threshold = self.capacity * 0.95
        self.stock_near_zero = 1.0
        self.stock_recovery_target = 2.0 * self.capacity / self.n

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock = state.current_stock
        rounds_remaining = self.r - round_t
        if round_t == 0:
            return Action.D
        if rounds_remaining <= self.end_game_window:
            return Action.D
        if stock < self.stock_near_zero:
            return Action.C
        if stock < self.stock_threshold:
            return Action.C
        if round_t >= 1:
            prev_stock = history.my_payoffs[round_t - 1] if round_t > 0 else stock
            stocks_observed = self._estimate_stock_trajectory(history, round_t, stock)
            if stocks_observed is not None and stocks_observed < self.stock_threshold:
                return Action.C
        if stock > self.high_stock_threshold:
            return Action.D
        recent_coop_rate = self._calculate_recent_cooperation_rate(history, round_t)
        if recent_coop_rate > self.cooperation_threshold and stock > self.safe_level:
            return Action.D
        return Action.D

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, round_t: int) -> float:
        """Calculate the rate of opponent cooperation in recent rounds."""
        if round_t <= 0:
            return 0.0
        lookback = min(self.cooperation_lookback, round_t)
        start_idx = round_t - lookback
        recent_actions = history.opponent_actions[start_idx:round_t, :]
        total_cooperations = np.sum(recent_actions)
        total_players_rounds = recent_actions.size
        if total_players_rounds == 0:
            return 0.0
        return total_cooperations / total_players_rounds

    def _estimate_stock_trajectory(self, history: PlayerHistory, round_t: int, current_stock: float) -> float | None:
        """
        Estimate stock level in the next forecast_horizon rounds based on recent trends.
        Returns estimated stock; if below threshold, return that threshold value.
        """
        if round_t < 1:
            return None
        lookback = min(3, round_t)
        start_idx = max(0, round_t - lookback)
        total_consumption_recent = 0.0
        rounds_to_analyze = round_t - start_idx
        if rounds_to_analyze <= 0:
            return None
        for i in range(start_idx, round_t):
            my_action = history.my_actions[i]
            my_consumption = current_stock / (2 * self.n) if my_action else current_stock / self.n
            total_consumption_recent += my_consumption
            for j in range(self.n - 1):
                opp_action = history.opponent_actions[i, j]
                opp_consumption = current_stock / (2 * self.n) if opp_action else current_stock / self.n
                total_consumption_recent += opp_consumption
        avg_consumption = total_consumption_recent / rounds_to_analyze if rounds_to_analyze > 0 else 0.0
        estimated_stock = current_stock - avg_consumption * self.stock_forecast_horizon
        estimated_stock = max(0.0, estimated_stock)
        return estimated_stock

class Strategy_EXPLOITATIVE_149(BaseStrategy):
    """
    Adaptive Predatory Harvesting (APH) Strategy for Common Pool Resource Game.
    
    Exploits the asymmetry between cooperation (S/2n) and defection (S/n) by:
    1. Using dynamic stock-dependent thresholds to defect when stock is high
    2. Detecting opponent depletion patterns and defecting when commons is being raided
    3. Maximizing extraction in endgame rounds
    4. Cooperating minimally only to maintain stock when beneficial
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num >= self.n_rounds - 2:
            return Action.D
        critical_threshold = self.capacity / (2 * self.n_players)
        if stock < critical_threshold:
            return Action.D
        if round_num == 0:
            return Action.C
        if round_num >= 1 and history is not None:
            previous_round_idx = round_num - 1
            expected_consumption_all_cooperate = self.n_players / (2 * self.n_players)
            previous_opponent_actions = history.opponent_actions[previous_round_idx, :]
            num_defectors_prev = self.n_players - np.sum(previous_opponent_actions)
            defection_ratio = num_defectors_prev / self.n_players
            if defection_ratio > 0.5:
                return Action.D
        time_remaining_ratio = (self.n_rounds - round_num) / self.n_rounds
        dynamic_threshold = self.capacity * (1 - time_remaining_ratio * 0.7)
        if stock > dynamic_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_150(BaseStrategy):
    """
    Adaptive Predation with Selective Cooperation
    
    Exploitative strategy that maximizes personal consumption while minimizing
    individual risk. Defects aggressively when pool is healthy, cooperates only
    when pool collapses or defection becomes mechanically suboptimal.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_collapse = 2 * self.n_players + 0.5
        self.threshold_healthy = self.capacity * 0.65
        self.consecutive_collapse_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        rounds_remaining = self.n_rounds - round_num
        if round_num == 0:
            return Action.D
        if rounds_remaining <= 3:
            return Action.D
        if stock < self.threshold_collapse:
            self.consecutive_collapse_rounds += 1
            return Action.C
        self.consecutive_collapse_rounds = 0
        if stock > self.threshold_healthy:
            return Action.D
        recent_opponent_defection_rate = self._calculate_recent_defection_rate(history)
        recent_opponent_cooperation_rate = 1.0 - recent_opponent_defection_rate
        if recent_opponent_defection_rate > 0.5:
            return Action.D
        if recent_opponent_cooperation_rate > 0.7:
            return Action.D
        return Action.D

    def _calculate_recent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the defection rate of opponents in recent rounds.
        Uses last 3 rounds if available, otherwise all available history.
        """
        if history.opponent_actions.shape[0] == 0:
            return 0.5
        lookback_rounds = min(3, history.opponent_actions.shape[0])
        recent_actions = history.opponent_actions[-lookback_rounds:, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.5
        defection_count = np.sum(~recent_actions)
        defection_rate = defection_count / total_actions
        return defection_rate

class Strategy_EXPLOITATIVE_151(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Exploits asymmetry between cooperative (stock/2n) and defective (stock/n) payoffs.
    Prioritizes individual extraction over collective sustainability through:
    - Endgame unconditional defection (final 2 rounds)
    - First-round defection to establish dominance
    - Resource depletion tracking and aggressive extraction when stock declines
    - Defection rate monitoring to adapt to opponent behavior
    - Rare false cooperation signals in early game to exploit naive players
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        stock = state.current_stock
        rounds_remaining = self.n_rounds - round_number
        if round_number == 0:
            return Action.D
        if rounds_remaining <= 2:
            return Action.D
        if stock <= self.capacity * 0.3:
            return Action.D
        opponent_defection_rate = self._calculate_defection_rate(history)
        if opponent_defection_rate > 0.5:
            return Action.D
        projected_next_stock = self._project_next_stock(stock, opponent_defection_rate)
        if projected_next_stock < self.capacity * 0.4:
            return Action.D
        if stock >= self.capacity * 0.8 and opponent_defection_rate < 0.2:
            if round_number <= 4:
                return Action.C
        return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate observed defection rate from all opponent actions.
        Defection is represented as False (0), cooperation as True (1).
        """
        if history.opponent_actions.size == 0:
            return 0.0
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.0
        defection_count = np.sum(history.opponent_actions == False)
        defection_rate = defection_count / total_actions
        return float(defection_rate)

    def _project_next_stock(self, current_stock: float, opponent_defection_rate: float) -> float:
        """
        Project stock level after next round based on observed defection rates.
        
        Assumes all n opponents continue with observed defection_rate:
        - Defection consumes stock/n per player
        - Cooperation consumes stock/(2n) per player
        """
        self_consumption = current_stock / self.n_players
        cooperators = self.n_players - 1
        opponent_cooperating = cooperators * (1.0 - opponent_defection_rate)
        opponent_defecting = cooperators * opponent_defection_rate
        opponent_consumption = opponent_cooperating * (current_stock / (2.0 * self.n_players)) + opponent_defecting * (current_stock / self.n_players)
        total_consumption = self_consumption + opponent_consumption
        stock_after_consumption = max(0.0, current_stock - total_consumption)
        if stock_after_consumption <= 0:
            growth = 0.0
        else:
            growth = 2.0 * stock_after_consumption * (1.0 - stock_after_consumption / self.capacity)
        projected_stock = min(stock_after_consumption + growth, self.capacity)
        return projected_stock

class Strategy_EXPLOITATIVE_152(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Cooperation
    
    Core philosophy: Exploit asymmetry between cooperators and defectors while maximizing
    absolute payoff. Defection yields 2x immediate payoff (S/n vs S/2n). Uses conditional
    cooperation only when stock depletion makes defection unsustainable, detected via
    observed opponent behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        total_opponent_actions = current_round * (self.n_players - 1)
        if total_opponent_actions == 0:
            opponent_coop_rate = 0.0
        else:
            total_opponent_cooperations = float(np.sum(history.opponent_actions[:current_round, :]))
            opponent_coop_rate = total_opponent_cooperations / total_opponent_actions
        if opponent_coop_rate > 0.6:
            return Action.D
        critical_threshold = self.capacity / (2 * self.n_players)
        if current_stock < critical_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_153(BaseStrategy):
    """
    Adaptive Predatory Extraction (APE): An exploitative strategy that maximizes
    personal payoff by defecting against cooperative opponents and extracting
    maximum value from the common pool while avoiding predictable patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - round_number
        if round_number == 0:
            return Action.D
        if rounds_remaining <= 2:
            return Action.D
        if current_stock < 2 * self.n_players:
            return Action.D
        num_rounds_played = round_number
        total_opponent_actions = history.opponent_actions[:round_number, :]
        total_cooperations = np.sum(total_opponent_actions)
        total_possible_cooperations = num_rounds_played * self.n_players
        if total_possible_cooperations == 0:
            opponent_coop_ratio = 0.0
        else:
            opponent_coop_ratio = total_cooperations / total_possible_cooperations
        if opponent_coop_ratio > 0.6:
            return Action.D
        if opponent_coop_ratio < 0.3:
            return Action.D
        if round_number >= 3:
            recent_stocks = [current_stock] + [self._estimate_previous_stock(history, i) for i in range(1, min(4, round_number + 1))]
            stock_trend = recent_stocks[0] - np.mean(recent_stocks[1:])
        else:
            stock_trend = 0.0
        if stock_trend < 0:
            return Action.D
        if current_stock > self.capacity * 0.75:
            recent_rounds = min(5, round_number)
            recent_my_defections = np.sum(~history.my_actions[-recent_rounds:])
            if recent_my_defections < 1:
                return Action.C
        return Action.D

    def _estimate_previous_stock(self, history: PlayerHistory, rounds_back: int) -> float:
        """
        Estimate stock level rounds_back rounds ago based on consumption patterns.
        This is a rough heuristic for trend analysis.
        """
        if rounds_back > history.my_actions.shape[0]:
            return self.capacity
        round_idx = len(history.my_actions) - rounds_back
        if round_idx < 0:
            return self.capacity
        my_action = history.my_actions[round_idx]
        opponent_cooperations = np.sum(history.opponent_actions[round_idx, :])
        return self.capacity

class Strategy_EXPLOITATIVE_154(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy with Adaptive Defection.
    
    Maximizes personal consumption through strategic defection while adapting to 
    opponent behavior to avoid mutual destruction. Uses stock-aware conditional logic
    with history-based opponent modeling.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        opponent_defection_rate = self._calculate_opponent_defection_rate(history)
        stock_growth_last_round = self._calculate_stock_growth(history, current_round)
        if current_stock < 0.1 * self.capacity and current_stock > 0:
            return Action.D
        if current_stock < 0.3 * self.capacity:
            return Action.D
        if current_stock >= 0.7 * self.capacity:
            return Action.D
        if 0.3 * self.capacity <= current_stock < 0.7 * self.capacity:
            if opponent_defection_rate > 0.6:
                return Action.D
            if stock_growth_last_round > 0:
                return Action.C
            return Action.D
        return Action.D

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the average defection rate across all opponents.
        Returns float between 0 and 1.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        total_opponent_actions = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
        if total_opponent_actions == 0:
            return 0.0
        defection_count = np.sum(~history.opponent_actions)
        return float(defection_count) / float(total_opponent_actions)

    def _calculate_stock_growth(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate stock growth from the previous round.
        Returns the growth amount (stock_after_consumption + growth - stock_before_consumption).
        Returns 0 if cannot calculate.
        """
        if history is None or current_round == 0:
            return 0.0
        if len(history.my_payoffs) == 0:
            return 0.0
        last_payoff = history.my_payoffs[-1]
        if len(history.my_payoffs) > 1:
            avg_payoff = float(np.mean(history.my_payoffs[:-1]))
            if last_payoff > avg_payoff:
                return 1.0
        return 0.0

class Strategy_EXPLOITATIVE_155(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Sustainability Preservation
    
    Balances greedy defection to exploit cooperators with strategic cooperation
    to maintain stock viability. Classifies opponents, projects stock trajectories,
    and makes conditional defection decisions based on opponent profiles and
    resource availability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.min_safe_stock = self.capacity * 0.15

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock_s = state.current_stock
        if round_t == 0:
            return Action.D
        opponent_profile = self._classify_opponents(history)
        num_cooperators = sum(opponent_profile == 1)
        num_defectors = sum(opponent_profile == 0)
        rounds_remaining = self.r - round_t
        if round_t == self.r - 1:
            if stock_s > self.min_safe_stock:
                return Action.D
            else:
                return Action.C
        if stock_s < self.min_safe_stock:
            return Action.C
        if num_defectors >= self.n / 2:
            return Action.D
        if num_cooperators >= 0.75 * self.n:
            if self._is_sustainable_defection(stock_s, rounds_remaining):
                return Action.D
            else:
                defection_prob = 0.4
                return Action.D if random.random() < defection_prob else Action.C
        if stock_s >= 0.8 * self.capacity:
            return Action.D
        if stock_s >= 0.5 * self.capacity:
            defection_prob = num_cooperators / self.n * 0.7 + stock_s / self.capacity * 0.3
            return Action.D if random.random() < defection_prob else Action.C
        return Action.C

    def _classify_opponents(self, history: PlayerHistory) -> NDArray[np.int_]:
        """
        Classify each opponent as Cooperator (1), Defector (0), or Conditional (0.5).
        Returns array of classification for each opponent.
        """
        n_opponents = self.n - 1
        opponent_actions = history.opponent_actions
        classifications = np.zeros(n_opponents, dtype=np.int_)
        for opp_idx in range(n_opponents):
            opp_history = opponent_actions[:, opp_idx]
            if len(opp_history) == 0:
                classifications[opp_idx] = 0
                continue
            coop_count = np.sum(opp_history)
            defect_count = len(opp_history) - coop_count
            if coop_count > defect_count:
                classifications[opp_idx] = 1
            else:
                classifications[opp_idx] = 0
        return classifications

    def _is_sustainable_defection(self, current_stock: float, rounds_remaining: int) -> bool:
        """
        Project if all-defect scenario maintains stock above critical threshold.
        Conservative check: assume all n players defect in future rounds.
        """
        if rounds_remaining <= 0:
            return True
        projected_stock = current_stock
        for _ in range(rounds_remaining):
            consumption = projected_stock
            remaining = max(0, projected_stock - consumption)
            if remaining > 0:
                growth = 2 * remaining * (1 - remaining / self.capacity)
                projected_stock = min(remaining + growth, self.capacity)
            else:
                projected_stock = 0
            if projected_stock < self.min_safe_stock:
                return False
        return True

class Strategy_EXPLOITATIVE_156(BaseStrategy):
    """
    Adaptive Depletion: An exploitative common pool resource strategy that prioritizes
    immediate extraction while adapting to opponent composition and stock dynamics.
    
    Core approach:
    - Round 1: Always defect to establish dominance and maximize early payoff
    - Monitor: Track defection rates in recent history
    - Stock-dependent: Shift behavior based on resource depletion level
    - Time-aware: Increase defection in final rounds when future stock doesn't matter
    - Exploit cooperators: Extract maximum value from abundance, defect when depleted
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        current_round = state.round_number
        stock = state.current_stock
        remaining_rounds = self.n_rounds - current_round
        stock_depleted_threshold = self.capacity * 0.3
        stock_abundant_threshold = self.capacity * 0.7
        if stock <= stock_depleted_threshold:
            return Action.D
        if remaining_rounds <= 2:
            return Action.D
        recent_window = min(5, current_round)
        if recent_window > 0:
            recent_opponent_actions = history.opponent_actions[-recent_window:, :]
            defections_in_window = np.sum(~recent_opponent_actions)
            total_actions_in_window = recent_window * self.n_players
            defection_rate = defections_in_window / total_actions_in_window if total_actions_in_window > 0 else 0.0
        else:
            defection_rate = 0.0
        if stock > stock_abundant_threshold:
            if defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        if defection_rate > 0.65:
            return Action.D
        elif defection_rate < 0.35:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_157(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State Monitoring
    
    Exploits cooperators maximally while maintaining stock viability.
    Defects when profitable; cooperates only when stock depletion forces it
    or when defection would collapse the resource entirely.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if stock < self.capacity * 0.15:
            return Action.C
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio > 0.6:
            return Action.D
        if stock_ratio <= 0.3:
            return Action.C
        cooperation_rate = self._calculate_cooperation_rate(history, round_num)
        if cooperation_rate > 0.5:
            defect_prob = 0.85
        elif cooperation_rate < 0.3:
            defect_prob = 0.65
        else:
            defect_prob = 0.75
        if random.random() < defect_prob:
            return Action.D
        else:
            return Action.C

    def _calculate_cooperation_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the cooperation rate of opponents across all observed rounds.
        Returns a value between 0 and 1.
        """
        if round_num <= 0 or history is None:
            return 0.5
        total_coop_actions = np.sum(history.opponent_actions[:round_num, :])
        total_possible_actions = (self.n_players - 1) * round_num
        if total_possible_actions <= 0:
            return 0.5
        cooperation_rate = total_coop_actions / total_possible_actions
        return float(cooperation_rate)

class Strategy_EXPLOITATIVE_158(BaseStrategy):
    """
    Adaptive Drain: An exploitative common pool resource strategy that maximizes personal payoff
    by defecting at high stock levels, probabilistically defecting at mid-range levels, and only
    cooperating when stock is critically low. Adapts defection thresholds based on opponent behavior
    and always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.n_rounds - 1:
            return Action.D
        if history is None:
            return Action.D
        opponent_defection_rate = self._calculate_opponent_defection_rate(history)
        defection_threshold_base = self.capacity * 0.75
        if opponent_defection_rate >= 0.6:
            defection_threshold = defection_threshold_base - 0.1 * self.capacity
        elif opponent_defection_rate <= 0.3:
            defection_threshold = defection_threshold_base + 0.05 * self.capacity
        else:
            defection_threshold = defection_threshold_base
        if current_stock >= defection_threshold:
            return Action.D
        elif current_stock <= self.capacity * 0.3:
            return Action.C
        else:
            mid_range_bottom = self.capacity * 0.3
            mid_range_top = defection_threshold
            mid_range_width = mid_range_top - mid_range_bottom
            if mid_range_width <= 0:
                return Action.C
            p_defect = (current_stock - mid_range_bottom) / mid_range_width
            p_defect = max(0.0, min(1.0, p_defect))
            if random.random() < p_defect:
                return Action.D
            else:
                return Action.C

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the aggregate defection rate of all other players across history.
        True/1 = Cooperate, False/0 = Defect
        So defection count = number of False values = n_actions - sum(opponent_actions)
        """
        if history.opponent_actions.size == 0:
            return 0.0
        total_opponent_actions = history.opponent_actions.size
        total_cooperations = np.sum(history.opponent_actions)
        total_defections = total_opponent_actions - total_cooperations
        if total_opponent_actions == 0:
            return 0.0
        opponent_defection_rate = total_defections / total_opponent_actions
        return opponent_defection_rate

class Strategy_EXPLOITATIVE_159(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State-Aware Defection
    
    Maximizes personal consumption by defecting when stock is abundant,
    while maintaining minimum cooperation to prevent pool collapse.
    Adapts to opponent behavior patterns and increases aggression in endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = self.capacity * 0.7
        self.threshold_low = self.capacity * 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            if self.capacity > 2 * self.n_players * 1.5:
                return Action.D
            else:
                return Action.C
        opp_defect_rate = self._calculate_opponent_defection_rate(history)
        base_prob = self._calculate_base_probability(current_stock)
        if round_num > 2 * self.n_rounds / 3:
            base_prob = min(1.0, base_prob + 0.15)
        if opp_defect_rate < 0.3:
            base_prob = min(1.0, base_prob + 0.25)
        elif opp_defect_rate > 0.6:
            base_prob = max(0.4, base_prob)
        if round_num == self.n_rounds - 1:
            return Action.D
        if random.random() < base_prob:
            return Action.D
        else:
            return Action.C

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the defection rate of opponents across all observed rounds.
        True = Cooperate (C), False = Defect (D)
        So defection_rate = proportion of False values
        """
        if history.opponent_actions.size == 0:
            return 0.5
        total_actions = history.opponent_actions.size
        defection_count = total_actions - np.sum(history.opponent_actions)
        if total_actions == 0:
            return 0.5
        return float(defection_count) / float(total_actions)

    def _calculate_base_probability(self, stock: float) -> float:
        """
        Calculate base defection probability based on current stock level.
        Returns probability of defecting (0.0 to 1.0).
        """
        if stock > self.threshold_high:
            return 1.0
        elif stock > self.threshold_low:
            gradient = (stock - self.threshold_low) / (self.threshold_high - self.threshold_low)
            return max(0.0, min(1.0, gradient))
        else:
            return 0.0

class Strategy_EXPLOITATIVE_160(BaseStrategy):
    """
    Exploitative strategy using dynamic defection with adaptive thresholds.
    
    Core approach:
    - Defect when stock exceeds a dynamically calculated threshold
    - Threshold increases gradually from 40% to 50% of capacity over rounds
    - Switch to cooperation if stock falls below 30% of capacity (collapse prevention)
    - Special handling for first and last rounds
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            if current_stock > 0.35 * self.capacity:
                return Action.D
            else:
                return Action.C
        if current_stock < 0.3 * self.capacity:
            return Action.C
        threshold = self.capacity * (0.4 + 0.1 * (current_round / self.n_rounds))
        if current_stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_161(BaseStrategy):
    """
    Adaptive Predation: An exploitative strategy that defects aggressively while 
    the pool is healthy, adapts based on cooperator populations when depleted, 
    and ruthlessly extracts in the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.depletion_threshold = 0.6
        self.min_cooperators_threshold = 0.3
        self.critical_depletion_threshold = 0.3
        self.critical_coop_threshold = 0.4
        self.final_window = max(2, self.r // 4)
        self.stock_floor = 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        rounds_remaining = self.r - state.round_number
        stock = state.current_stock
        if rounds_remaining <= self.final_window:
            return Action.D
        if stock <= self.capacity * self.critical_depletion_threshold:
            coop_ratio = self._count_cooperators_ratio(history, state.round_number)
            if coop_ratio > self.critical_coop_threshold:
                return Action.C
            return Action.D
        if stock <= self.capacity * self.depletion_threshold:
            coop_ratio = self._count_cooperators_ratio(history, state.round_number)
            if coop_ratio >= self.min_cooperators_threshold:
                return Action.D
            return Action.D
        return Action.D

    def _count_cooperators_ratio(self, history: PlayerHistory, round_number: int) -> float:
        """
        Count the ratio of opponents who cooperated in the most recent round.
        Returns a value between 0 and 1.
        """
        if round_number == 0:
            return 0.0
        last_round_idx = round_number - 1
        if last_round_idx >= history.opponent_actions.shape[0]:
            return 0.0
        cooperators = np.sum(history.opponent_actions[last_round_idx, :])
        if self.n == 0:
            return 0.0
        return float(cooperators) / float(self.n)

class Strategy_EXPLOITATIVE_162(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Core approach: Consistently defect to maximize extraction from the common pool,
    with occasional cooperative facade near endgame to avoid detection. Exploits
    cooperators' restraint while parasitizing pool recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        if state.round_number == 0:
            return Action.D
        if stock_ratio < 0.15:
            return Action.D
        if stock_ratio > 0.75 or stock_ratio < 0.25:
            return Action.D
        if 0.25 <= stock_ratio <= 0.4:
            if state.round_number > self.n_rounds * 0.8:
                if history is not None:
                    recent_opponent_actions = history.opponent_actions[-1, :]
                    cooperation_rate = np.mean(recent_opponent_actions)
                    if cooperation_rate > 0.6:
                        if random.random() < 0.3:
                            return Action.C
        if history is not None:
            has_cooperators = np.any(history.opponent_actions)
            if has_cooperators:
                return Action.D
        if history is not None and state.round_number > 0:
            if state.round_number > 1:
                prev_round_idx = state.round_number - 1
                if history.opponent_actions[prev_round_idx, :].sum() > 0:
                    return Action.D
        if state.round_number == self.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_163(BaseStrategy):
    """
    Adaptive Predatory Harvesting (APH): An exploitative strategy that maximizes
    personal consumption while maintaining just enough stock to prevent complete
    collapse. Uses stock levels to determine when to defect aggressively vs.
    cooperate minimally for recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.base_sustainable_threshold = self.capacity * 0.4
        if self.n_players == 2:
            self.base_sustainable_threshold = self.capacity * 0.3
        self.previous_stock = self.capacity
        self.consecutive_defections = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            self.previous_stock = current_stock
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        sustainable_threshold = self.base_sustainable_threshold
        if self.previous_stock > 0:
            decline_rate = current_stock / self.previous_stock
            if decline_rate < 0.85:
                sustainable_threshold = max(self.capacity * 0.1, sustainable_threshold - 0.05 * self.capacity)
        if current_stock <= self.capacity * 0.1:
            self.consecutive_defections = 0
            self.previous_stock = current_stock
            return Action.C
        if current_stock > sustainable_threshold:
            self.consecutive_defections += 1
            self.previous_stock = current_stock
            return Action.D
        else:
            self.consecutive_defections = 0
            self.previous_stock = current_stock
            return Action.C

class Strategy_EXPLOITATIVE_164(BaseStrategy):
    """
    Adaptive Depletion Strategy: An exploitative common pool resource strategy that
    maximizes personal payoff by consistently defecting while remaining responsive to
    resource depletion trajectories. Switches to scorched-earth mode when commons
    depletion accelerates, amplifies exploitation as end-game approaches.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.danger_counter = 0
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        self.stock_history.append(stock)
        if round_num == 0:
            self.danger_counter = 0
            return Action.D
        rounds_remaining = self.r - round_num
        if rounds_remaining == 1:
            return Action.D
        if len(self.stock_history) >= 2:
            stock_previous = self.stock_history[-2]
            stock_current = self.stock_history[-1]
            if stock_previous > 0:
                depletion_rate = (stock_previous - stock_current) / stock_previous
                if depletion_rate > 0.5:
                    self.danger_counter += 1
                else:
                    self.danger_counter = 0
            if self.danger_counter >= 2:
                return Action.D
        if stock == 0:
            return Action.D
        if self.n == 2:
            return Action.D
        if rounds_remaining <= 2:
            return Action.D
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0
        if stock_ratio >= 0.5:
            return Action.D
        if stock_ratio < 0.3 and self.danger_counter < 2:
            defect_probability = 0.7 + 0.3 * (round_num / self.r)
            if random.random() < defect_probability:
                return Action.D
            else:
                return Action.C
        if 0.3 <= stock_ratio < 0.5 and rounds_remaining > 2:
            defections_observed = 0
            lookback = min(3, round_num)
            for r_idx in range(max(0, round_num - lookback), round_num):
                opponent_defections = np.sum(~history.opponent_actions[r_idx, :])
                if opponent_defections >= self.n - 1:
                    defections_observed += 1
            if defections_observed >= 2:
                return Action.D
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_165(BaseStrategy):
    """
    Adaptive Predation: Exploitative Common Pool Resource Strategy
    
    Core approach: Defect by default, exploit detected cooperation, adapt to stock dynamics.
    Maximizes absolute payoff by ruthlessly extracting value from cooperative players while
    avoiding mutual destruction when sustainable.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 2 * self.n_players
        self.cooperation_threshold = 0.4
        self.low_cooperation_threshold = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        remaining_rounds = self.n_rounds - current_round
        if current_round == 0:
            return Action.D
        if remaining_rounds <= 2:
            return Action.D
        if current_stock <= self.critical_threshold:
            return Action.D
        observed_cooperation_rate = self._calculate_cooperation_rate(history)
        if observed_cooperation_rate > self.cooperation_threshold:
            return Action.D
        stock_depletion_rate = self._calculate_depletion_rate(history, current_stock)
        if stock_depletion_rate > 0:
            return Action.D
        elif stock_depletion_rate >= -0.1:
            return Action.D
        else:
            rounds_until_collapse = self._estimate_rounds_until_collapse(history, current_stock)
            if rounds_until_collapse > remaining_rounds / 2:
                return Action.D
            elif observed_cooperation_rate > 0.2:
                return Action.D
            else:
                return Action.C
        return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the cooperation rate of other players across all rounds.
        Returns value between 0.0 and 1.0.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        total_opponent_actions = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
        if total_opponent_actions == 0:
            return 0.0
        cooperations = np.sum(history.opponent_actions)
        return float(cooperations) / float(total_opponent_actions)

    def _calculate_depletion_rate(self, history: PlayerHistory, current_stock: float) -> float:
        """
        Calculate stock depletion rate from previous round to current.
        Positive = recovery, Negative = depletion.
        """
        if history is None or len(history.my_payoffs) < 2:
            return 0.0
        previous_round_idx = len(history.my_payoffs) - 1
        my_last_action = history.my_actions[previous_round_idx]
        my_last_payoff = history.my_payoffs[previous_round_idx]
        if my_last_action:
            stock_before_consumption = my_last_payoff * 2 * self.n_players
        else:
            stock_before_consumption = my_last_payoff * self.n_players
        if stock_before_consumption <= 0:
            return 0.0
        depletion_rate = (current_stock - stock_before_consumption) / stock_before_consumption
        return depletion_rate

    def _estimate_rounds_until_collapse(self, history: PlayerHistory, current_stock: float) -> float:
        """
        Estimate how many rounds until stock reaches critical threshold.
        """
        if history is None or len(history.my_payoffs) < 2:
            return float(self.n_rounds)
        total_depletion = 0.0
        count = 0
        for i in range(1, len(history.my_payoffs)):
            my_action = history.my_actions[i - 1]
            my_payoff = history.my_payoffs[i - 1]
            if my_action:
                stock_before = my_payoff * 2 * self.n_players
            else:
                stock_before = my_payoff * self.n_players
            if stock_before > 0:
                total_depletion += max(0, stock_before - current_stock)
                count += 1
        if count == 0:
            return float(self.n_rounds)
        avg_depletion_per_round = total_depletion / count
        if avg_depletion_per_round <= 0:
            return float(self.n_rounds)
        rounds_until_collapse = current_stock / avg_depletion_per_round
        return max(0, rounds_until_collapse)

class Strategy_EXPLOITATIVE_166(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy
    
    Assumes opponents are naive or insufficiently adaptive. Exploits predictable patterns
    while maintaining plausible deniability. Uses adaptive defection with stock-conditional
    cooperation to prevent catastrophic collapse that would harm everyone equally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.low_stock_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.r - 1:
            return Action.D
        if stock <= 2 * self.n:
            self.low_stock_rounds += 1
            return Action.C
        else:
            self.low_stock_rounds = 0
        prev_opponent_actions = history.opponent_actions[round_num - 1, :]
        num_defectors = np.sum(~prev_opponent_actions)
        defection_rate = num_defectors / self.n
        if defection_rate >= 0.5:
            return Action.D
        if stock >= 1.5 * self.capacity:
            return Action.D
        my_cumulative = np.sum(history.my_payoffs[:round_num])
        opponent_cumulative = np.sum(history.opponent_payoffs[:round_num, :])
        if len(history.opponent_payoffs[:round_num, :].flat) > 0:
            avg_opponent_payoff = opponent_cumulative / np.size(history.opponent_payoffs[:round_num, :])
        else:
            avg_opponent_payoff = 0.0
        if my_cumulative < avg_opponent_payoff:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_167(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Collapse Prevention
    
    Exploits cooperative players by defecting when profitable, while avoiding
    mutual collapse. Uses stock-conditional defection as primary rule, with
    secondary rules for opponent history exploitation and last-round maximization.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = self.capacity * 0.4
        self.min_viable_stock = 2 * self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.min_viable_stock:
            return Action.C
        if current_round == 0:
            return Action.D
        opponent_defections = np.sum(~history.opponent_actions[:current_round, :])
        total_opponent_actions = current_round * self.n_players
        if total_opponent_actions > 0:
            opponent_defect_rate = opponent_defections / total_opponent_actions
        else:
            opponent_defect_rate = 0.5
        if opponent_defect_rate < 0.3:
            return Action.D
        if opponent_defect_rate > 0.5:
            return Action.D
        if current_stock > self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_168(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with State-Based Defection
    
    Core philosophy: Exploit the asymmetry between cooperators (C: S/2n payoff) and 
    defectors (D: S/n payoff). Defect aggressively when stock is abundant, conditionally
    cooperate only when stock is critically depleted and others are cooperating, and
    always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.D
        if round_number == self.n_rounds - 1:
            return Action.D
        early_phase = round_number <= self.n_rounds / 3
        late_phase = round_number > 2 * self.n_rounds / 3
        high_threshold = self.capacity * 0.4
        medium_threshold = self.capacity * 0.15
        collapse_threshold = self.capacity * 0.1
        if early_phase:
            return Action.D
        if late_phase:
            if current_stock < collapse_threshold:
                return self._conditional_cooperate_on_defection_rate(history, round_number)
            return Action.D
        if current_stock > high_threshold:
            return Action.D
        elif current_stock > medium_threshold:
            return self._conditional_cooperate_on_defection_rate(history, round_number)
        else:
            return self._conditional_cooperate_on_defection_rate(history, round_number)

    def _conditional_cooperate_on_defection_rate(self, history: PlayerHistory, round_number: int) -> Action:
        """
        When stock is low, cooperate only if most opponents are cooperating.
        If opponents are defecting, defect anyway (race-to-bottom logic).
        """
        last_round_cooperators = int(np.sum(history.opponent_actions[-1, :]))
        defectors_count = self.n_players - last_round_cooperators
        if defectors_count >= self.n_players / 2:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_169(BaseStrategy):
    """
    Exploitative Defection Strategy for Common Pool Resource Game.
    
    This strategy always defects (Action.D) to maximize individual extraction.
    The core logic: defection always yields S/n (higher payoff) compared to 
    cooperation which yields S/(2n). This dominates across all stock levels,
    round numbers, and opponent behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.n_rounds - 1:
            return Action.D
        stock_high_threshold = self.capacity * 0.6
        stock_medium_threshold = self.capacity * 0.3
        current_stock = state.current_stock
        if current_stock > stock_high_threshold:
            return Action.D
        if current_stock > stock_medium_threshold:
            return Action.D
        if history is not None and state.round_number > 0:
            previous_round_idx = state.round_number - 1
            cooperators_last_round = int(np.sum(history.opponent_actions[previous_round_idx, :]))
            cooperation_rate = cooperators_last_round / self.n_players
            if cooperation_rate > 0.5:
                return Action.D
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_170(BaseStrategy):
    """
    Adaptive Predation: Exploitative common pool resource strategy that balances
    short-term extraction with long-term sustainability, but only to maximize
    personal cumulative payoff. Uses temporal opportunism, predictive aggression,
    selective cooperation, and terminal extraction to exploit the resource and
    other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if stock < self.capacity * 0.15:
            return Action.D
        if round_num >= self.n_rounds * 0.8:
            return Action.D
        defection_rate_last_2 = self._calculate_defection_rate(history, max(0, round_num - 2), round_num)
        defection_rate_prev_2 = self._calculate_defection_rate(history, max(0, round_num - 4), max(0, round_num - 2))
        defection_trend = defection_rate_last_2 - defection_rate_prev_2
        if defection_rate_last_2 >= 0.5:
            return Action.D
        if defection_trend > 0.1:
            return Action.D
        if stock > self.capacity * 0.75:
            if round_num > 0:
                cooperators_last_round = int(np.sum(history.opponent_actions[round_num - 1, :]))
                if cooperators_last_round >= self.n_players * 0.9:
                    return Action.D
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, start_round: int, end_round: int) -> float:
        """
        Calculate the defection rate among all opponents in a range of rounds.
        Defection is represented by False (0), cooperation by True (1).
        Defection rate = proportion of False values.
        """
        if start_round >= end_round or end_round <= 0:
            return 0.0
        opponent_actions = history.opponent_actions[start_round:end_round, :]
        total_actions = opponent_actions.size
        if total_actions == 0:
            return 0.0
        defections = np.sum(opponent_actions == False)
        return float(defections) / float(total_actions)

class Strategy_EXPLOITATIVE_171(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Sustainability Arbitrage
    
    Exploits asymmetry between immediate gains from defection and delayed gains from cooperation.
    Uses stock-state dependent decision rules, opponent behavior tracking, and endgame aggression.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= 2:
            return Action.D
        observed_defection_rate = self._calculate_opponent_defection_rate(history, current_round)
        if observed_defection_rate > 0.6:
            target_threshold = 0.5
        elif observed_defection_rate > 0.4:
            target_threshold = 0.75
        else:
            target_threshold = 0.8
        threshold_high = target_threshold
        threshold_mid = 0.4
        threshold_low = 0.15
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio > threshold_high:
            return Action.D
        elif stock_ratio > threshold_mid:
            if rounds_remaining < self.n_rounds / 3 or observed_defection_rate > 0.4:
                return Action.D
            else:
                return Action.C
        elif stock_ratio > threshold_low:
            return Action.C
        else:
            return Action.C

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the observed defection rate of opponents across all previous rounds.
        Defection is encoded as False (0), so we count False values.
        """
        if current_round == 0:
            return 0.0
        opponent_actions = history.opponent_actions[:current_round, :]
        total_actions = opponent_actions.size
        if total_actions == 0:
            return 0.0
        defection_count = np.sum(~opponent_actions)
        defection_rate = float(defection_count) / float(total_actions)
        return defection_rate

class Strategy_EXPLOITATIVE_172(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Dynamic Opportunism
    
    Treats cooperation as a vulnerability to exploit. Defects by default with selective
    cooperation only when strategically advantageous for pool restoration before aggressive
    extraction. Maximizes personal extraction while minimizing collective pool sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_peak = game_description.capacity
        self.rounds_since_peak = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            return Action.D
        if current_stock <= 2 * self.n_players:
            return Action.D
        if rounds_remaining == 1:
            return Action.D
        opponent_cooperation_rate = self._calculate_opponent_cooperation_rate(history, current_round)
        if opponent_cooperation_rate > 0.95 and current_stock > self.capacity / 2:
            return Action.D
        stock_declining = self._is_stock_declining(history, current_stock)
        defection_rate_increasing = self._is_defection_rate_increasing(history, current_round)
        if current_stock < self.capacity / 3 and defection_rate_increasing:
            return Action.D
        if current_round > 0:
            all_defected_last_round = self._all_players_defected_last_round(history, current_round)
            if all_defected_last_round:
                return Action.D
        depletion_urgency = (self.capacity - current_stock) / self.capacity if self.capacity > 0 else 0
        rounds_left_ratio = rounds_remaining / self.n_rounds if self.n_rounds > 0 else 0
        if stock_declining and rounds_remaining < self.n_rounds / 2:
            return Action.D
        if stock_declining and current_stock > self.capacity / 2:
            return Action.D
        if current_stock >= self.capacity * 0.95 and rounds_remaining >= 3:
            opponent_defection_rate = 1.0 - opponent_cooperation_rate
            if opponent_defection_rate < 0.2:
                return Action.C
        if rounds_left_ratio < 0.4 and depletion_urgency > 0.3:
            return Action.D
        sucker_cooperation_rate = self._identify_sucker_cooperation_rate(history, current_round)
        if sucker_cooperation_rate > 0.6:
            return Action.D
        return Action.D

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """Calculate the proportion of opponent actions that were cooperation."""
        if current_round == 0:
            return 0.0
        opponent_actions = history.opponent_actions[:current_round, :]
        total_actions = opponent_actions.size
        if total_actions == 0:
            return 0.0
        cooperations = np.sum(opponent_actions)
        return float(cooperations) / float(total_actions)

    def _is_stock_declining(self, history: PlayerHistory, current_stock: float) -> bool:
        """Detect if stock is in a declining trend."""
        if current_stock > self.stock_peak:
            self.stock_peak = current_stock
            self.rounds_since_peak = 0
        else:
            self.rounds_since_peak += 1
        return self.rounds_since_peak >= 2

    def _is_defection_rate_increasing(self, history: PlayerHistory, current_round: int) -> bool:
        """Check if opponent defection rate is increasing over time."""
        if current_round < 2:
            return False
        mid_point = max(1, current_round // 2)
        early_defections = np.sum(~history.opponent_actions[:mid_point, :])
        early_total = history.opponent_actions[:mid_point, :].size
        early_rate = early_defections / early_total if early_total > 0 else 0.0
        recent_defections = np.sum(~history.opponent_actions[mid_point:current_round, :])
        recent_total = history.opponent_actions[mid_point:current_round, :].size
        recent_rate = recent_defections / recent_total if recent_total > 0 else 0.0
        return recent_rate > early_rate

    def _all_players_defected_last_round(self, history: PlayerHistory, current_round: int) -> bool:
        """Check if all opponents defected in the last round."""
        if current_round < 1:
            return False
        last_round_actions = history.opponent_actions[current_round - 1, :]
        all_defected = np.sum(last_round_actions) == 0
        return bool(all_defected)

    def _identify_sucker_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """Identify opponents who cooperate frequently (suckers to exploit)."""
        if current_round == 0:
            return 0.0
        opponent_actions = history.opponent_actions[:current_round, :]
        total_actions = opponent_actions.size
        if total_actions == 0:
            return 0.0
        cooperations = np.sum(opponent_actions)
        return float(cooperations) / float(total_actions)

class Strategy_EXPLOITATIVE_173(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Collapse Prevention
    
    Systematically exploits cooperative players while maintaining stock viability.
    Uses stock-dependent thresholds to defect when safe, cooperate when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        remaining_rounds = self.n_rounds - current_round
        if stock < self.capacity / 4.0 and remaining_rounds > 1:
            return Action.C
        threshold = self.capacity / 2.0 * (remaining_rounds / self.n_rounds)
        if stock >= threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_174(BaseStrategy):
    """
    Adaptive Extraction strategy for Common Pool Resource Game.
    
    Exploits the 2x payoff advantage of defection while preserving stock through
    dynamic thresholds. Defects aggressively in high-stock periods, cooperates
    when stock is depleted, and unconditionally defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == self.n_rounds - 1:
            return Action.D
        if stock < 0.1 * self.capacity:
            return Action.C
        rounds_remaining = self.n_rounds - round_num
        threshold = self.capacity * (1.0 - rounds_remaining / (2.0 * self.n_rounds))
        if round_num == 0 or round_num >= self.n_rounds - 2:
            return Action.D
        if stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_175(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Threshold-Based Defection
    
    Exploits the asymmetry in payoffs (defection yields 2x cooperation) by:
    1. Probing cooperatively in rounds 1-2 to assess opponents
    2. Defecting adaptively based on stock health (0.3, 0.7 thresholds)
    3. Switching to permanent defection if aggressive depletion is detected
    4. Always defecting in the final round for maximum extraction
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.permanent_defect = False
        self.last_known_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_known_stock = state.current_stock
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if self.permanent_defect:
            self.last_known_stock = state.current_stock
            return Action.D
        if state.round_number == 1:
            self.last_known_stock = state.current_stock
            return Action.C
        stock_health = state.current_stock / self.game_description.capacity
        if state.round_number > 1 and history is not None:
            prev_my_action = history.my_actions[state.round_number - 1]
            prev_stock = self.last_known_stock
            stock_delta = state.current_stock - prev_stock
            if prev_my_action and stock_delta < -0.15 * max(prev_stock, 1e-06):
                self.permanent_defect = True
                self.last_known_stock = state.current_stock
                return Action.D
        if stock_health > 0.7:
            self.last_known_stock = state.current_stock
            return Action.D
        elif stock_health > 0.3:
            self.last_known_stock = state.current_stock
            return Action.D
        elif state.round_number <= self.game_description.n_rounds / 2.0:
            self.last_known_stock = state.current_stock
            return Action.D
        else:
            self.last_known_stock = state.current_stock
            return Action.C
        self.last_known_stock = state.current_stock
        return Action.D

class Strategy_EXPLOITATIVE_176(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy
    
    Exploits the 2x payoff advantage of defection by defecting aggressively while
    monitoring stock levels. Switches to cooperation only when stock approaches
    critical depletion threshold to preserve the resource for future exploitation.
    Always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = self.capacity * (2 * self.n_players) / (2 * self.n_players + 1)
        self.critical_depletion = self.capacity / 10.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        stock_level = state.current_stock
        if round_number == self.n_rounds - 1:
            return Action.D
        if stock_level < self.critical_depletion:
            return Action.C
        if stock_level < self.threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_177(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Regeneration Harvesting
    
    Core philosophy: Always defect to maximize extraction. Defection yields 2x the payoff
    of cooperation in any round. Exploit cooperators, match defectors, and extract maximum
    value before collapse. No cooperation is ever rational in a no-communication setting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.D
        stock = state.current_stock
        if stock > 0.75 * self.capacity:
            return Action.D
        elif stock > 0.4 * self.capacity:
            opponent_defection_rate = self._calculate_recent_defection_rate(history, window=3)
            if opponent_defection_rate < 0.5:
                return Action.D
            else:
                return Action.D
        elif stock > 0.15 * self.capacity:
            return Action.D
        else:
            return Action.D

    def _calculate_recent_defection_rate(self, history: PlayerHistory, window: int) -> float:
        """
        Calculate the defection rate of opponents in the last 'window' rounds.
        Returns a float in [0, 1] representing the proportion of defections.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        start_idx = max(0, len(history.opponent_actions) - window)
        recent_actions = history.opponent_actions[start_idx:, :]
        if recent_actions.size == 0:
            return 0.0
        defection_count = np.sum(~recent_actions)
        total_count = recent_actions.size
        if total_count == 0:
            return 0.0
        return float(defection_count) / float(total_count)

class Strategy_EXPLOITATIVE_178(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Collapse Prevention
    
    Maximizes individual payoff by exploiting cooperators while maintaining stock viability.
    Defects by default, cooperates only when mathematically forced to prevent collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.collapse_threshold = self.capacity * 0.15
        self.recovery_threshold = self.capacity * 0.3
        self.mid_game_threshold = self.capacity * 0.25
        self.near_capacity_threshold = self.capacity * 0.8
        self.high_recovery_threshold = self.capacity * 0.35

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if stock < self.collapse_threshold:
            return Action.C
        if round_num == self.n_rounds - 2:
            if stock > self.recovery_threshold:
                return Action.D
            else:
                return Action.C
        if round_num >= 1 and round_num < self.n_rounds - 2:
            prev_stock = history.my_payoffs[round_num - 1] if round_num > 0 else stock
            if round_num > 0:
                prev_round_cooperators = np.sum(history.opponent_actions[round_num - 1, :])
                my_prev_action = history.my_actions[round_num - 1]
                if round_num >= 2:
                    recent_payoff_avg = np.mean(history.my_payoffs[max(0, round_num - 2):round_num])
                    if recent_payoff_avg > 0:
                        current_expected_payoff = stock / (2 * self.n_players if True else self.n_players)
                        recovery_ratio = (current_expected_payoff - recent_payoff_avg) / recent_payoff_avg if recent_payoff_avg > 0 else 0
                    else:
                        recovery_ratio = 0
                else:
                    recovery_ratio = 0
                if recovery_ratio > 0.25:
                    return Action.D
                if recovery_ratio < -0.2 and stock < self.high_recovery_threshold:
                    return Action.C
            if stock > self.near_capacity_threshold:
                return Action.D
            if stock > self.mid_game_threshold:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_179(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Defection
    
    Maximizes personal payoff through dynamic resource extraction by exploiting
    the 2x payoff advantage of defection over cooperation. Adapts to stock levels
    and observed cooperation rates while maintaining aggressive defection as default.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_action_was_cooperate = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock = state.current_stock
        round_num = state.round_number
        rounds_remaining = r - round_num
        if round_num == 0:
            self.last_action_was_cooperate = False
            return Action.D
        if rounds_remaining <= 2:
            self.last_action_was_cooperate = False
            return Action.D
        if stock < capacity / 4:
            self.last_action_was_cooperate = False
            return Action.D
        total_opponent_cooperations = np.sum(history.opponent_actions)
        total_opponent_actions = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
        if total_opponent_actions > 0:
            cooperation_rate = total_opponent_cooperations / total_opponent_actions
        else:
            cooperation_rate = 0.0
        if stock >= capacity / 2 and cooperation_rate >= 0.75 and (rounds_remaining >= 3):
            if not self.last_action_was_cooperate:
                self.last_action_was_cooperate = True
                return Action.C
            else:
                self.last_action_was_cooperate = False
                return Action.D
        if stock >= capacity / 4 and stock < capacity / 2:
            if cooperation_rate > 0.6:
                self.last_action_was_cooperate = False
                return Action.D
        self.last_action_was_cooperate = False
        return Action.D

class Strategy_EXPLOITATIVE_180(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Resource Exhaustion
    
    This strategy exploits the common pool by systematically defecting when stock is abundant,
    adapting to opponent behavior patterns, and intensifying extraction in early and late rounds.
    Core principle: treat cooperation as a resource to exploit, not a norm to maintain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        progress_ratio = round_num / self.n_rounds
        if round_num == self.n_rounds - 1:
            return Action.D
        if progress_ratio < 0.33:
            return Action.D
        if progress_ratio >= 0.67:
            if stock > 0:
                return Action.D
            else:
                return Action.C
        opponent_defection_rate = self._calculate_opponent_defection_rate(history, round_num)
        if opponent_defection_rate > 0.6 or opponent_defection_rate < 0.3:
            return Action.D
        if stock > self.capacity * 0.4:
            return Action.D
        elif stock > self.capacity * 0.15:
            return Action.D
        elif stock < self.capacity * 0.1 and opponent_defection_rate > 0.7:
            return Action.C
        else:
            return Action.D

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate opponent defection rate over the last 3 rounds.
        Returns defection rate in [0, 1].
        """
        if round_num <= 0:
            return 0.0
        recent_rounds_start = max(0, round_num - 3)
        recent_rounds_count = round_num - recent_rounds_start
        if recent_rounds_count == 0:
            return 0.0
        opponent_actions_recent = history.opponent_actions[recent_rounds_start:round_num, :]
        defections = np.sum(~opponent_actions_recent)
        total_actions = recent_rounds_count * self.n_players - 1
        if total_actions <= 0:
            return 0.0
        return float(defections) / float(total_actions)

class Strategy_EXPLOITATIVE_181(BaseStrategy):
    """
    Adaptive Predation: An exploitative strategy that maximizes cumulative payoff by
    oscillating between defection in abundance phases and selective cooperation in
    declining phases to preserve stock for future extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_rounds
        self.n_rounds = game_description.n_rounds

    def _classify_phase(self, stock: float) -> str:
        """Classify current stock level into phase."""
        abundance_threshold = 1.5 * self.capacity / 2
        healthy_threshold = self.capacity / 3
        declining_threshold = self.capacity / 6
        if stock > abundance_threshold:
            return 'ABUNDANCE'
        elif stock > healthy_threshold:
            return 'HEALTHY'
        elif stock > declining_threshold:
            return 'DECLINING'
        else:
            return 'DEPLETED'

    def _count_recent_defections(self, history: PlayerHistory, last_n_rounds: int) -> int:
        """Count own defections in the last N rounds."""
        if len(history.my_actions) == 0:
            return 0
        recent_rounds = min(last_n_rounds, len(history.my_actions))
        defections = sum((1 for i in range(-recent_rounds, 0) if not history.my_actions[i]))
        return defections

    def _is_stock_declining(self, history: PlayerHistory, last_n_rounds: int=2) -> bool:
        """Check if stock has been declining over recent rounds."""
        if len(history.my_payoffs) < 2:
            return False
        recent_payoffs = history.my_payoffs[-min(last_n_rounds, len(history.my_payoffs)):]
        if len(recent_payoffs) < 2:
            return False
        return recent_payoffs[-1] < recent_payoffs[-2]

    def _calculate_decline_rate(self, history: PlayerHistory) -> float:
        """Calculate recent decline rate in stock (proxied via payoffs)."""
        if len(history.my_payoffs) < 2:
            return 0.0
        prev_payoff = history.my_payoffs[-2]
        curr_payoff = history.my_payoffs[-1]
        if prev_payoff == 0:
            return 0.0
        decline_rate = (prev_payoff - curr_payoff) / prev_payoff
        return max(0.0, decline_rate)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        total_rounds = self.game_description.n_rounds
        if round_num == 0:
            return Action.D
        if round_num == total_rounds - 1:
            return Action.D
        if round_num == total_rounds - 2:
            phase = self._classify_phase(stock)
            if phase in ['DECLINING', 'DEPLETED']:
                return Action.C
            else:
                return Action.D
        phase = self._classify_phase(stock)
        if phase == 'ABUNDANCE':
            return Action.D
        elif phase == 'HEALTHY':
            recent_defections = self._count_recent_defections(history, 2)
            stock_declining = self._is_stock_declining(history, 2)
            if recent_defections >= 1 and stock_declining:
                return Action.C
            elif recent_defections >= 1 and (not stock_declining):
                return Action.D
            else:
                return Action.D
        elif phase == 'DECLINING':
            decline_rate = self._calculate_decline_rate(history)
            if decline_rate > 0.15:
                return Action.C
            else:
                return Action.D
        elif phase == 'DEPLETED':
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_182(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Conditional Cooperation
    
    Maximizes individual payoff by exploiting cooperative players while maintaining stock viability.
    Defects by default, but conditionally cooperates when stock depletion forces it or as a probe tactic.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock <= 2 * self.n_players:
            return Action.C
        if current_stock > self.capacity * 0.75:
            return Action.D
        if current_stock <= self.capacity * 0.25:
            return Action.C
        if self.capacity * 0.25 < current_stock <= self.capacity * 0.75:
            if history is not None and len(history.opponent_actions) > 0:
                last_round_cooperators = np.sum(history.opponent_actions[-1, :])
                fraction_cooperators = last_round_cooperators / self.n_players
                if fraction_cooperators >= 0.5:
                    return Action.D
                if current_round % 3 == 0:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_183(BaseStrategy):
    """
    Adaptive Extraction Strategy for Common Pool Resource Game.
    
    Exploits cooperators while maintaining resource viability through conditional
    defection based on stock health and opponent defection rates. Adapts behavior
    across game phases: aggressive defection early/late, conditional mid-game extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.D
        if round_number == self.n_rounds - 1:
            return Action.D
        previous_round_idx = round_number - 1
        opponent_actions_prev = history.opponent_actions[previous_round_idx, :]
        num_defectors = np.sum(~opponent_actions_prev)
        defection_rate = num_defectors / self.n_players if self.n_players > 0 else 0.0
        if defection_rate >= 0.6:
            return Action.C
        elif defection_rate <= 0.2:
            return Action.D
        else:
            stock_threshold_high = self.capacity * 0.6
            stock_threshold_low = self.capacity * 0.3
            if current_stock > stock_threshold_high:
                return Action.D
            elif current_stock <= stock_threshold_low:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_184(BaseStrategy):
    """
    Exploitative Strategy: Dynamic Extraction with Adaptive Defection
    
    Exploits the asymmetry between cooperative (S/2n) and defective (S/n) payoffs
    while remaining sensitive to stock depletion. Uses stock-conditional thresholds
    to balance aggressive extraction with strategic restraint based on resource levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high_ratio = 0.75
        self.threshold_medium_ratio = 0.4
        self.threshold_critical_ratio = 0.15
        self.rounds_below_critical = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock_S = state.current_stock
        if round_t == 0:
            return Action.D
        if round_t == self.n_rounds - 1:
            return Action.D
        rounds_remaining = self.n_rounds - round_t
        late_game_modifier = 1.0
        if rounds_remaining <= 3:
            late_game_modifier = max(0.7, 1.0 - 0.1 * (3 - rounds_remaining))
        threshold_high = self.threshold_high_ratio * self.capacity * late_game_modifier
        threshold_medium = self.threshold_medium_ratio * self.capacity * late_game_modifier
        threshold_critical = self.threshold_critical_ratio * self.capacity * late_game_modifier
        if round_t == self.n_rounds - 2:
            threshold_high *= 1.2
            threshold_medium *= 1.2
        if stock_S < threshold_critical:
            self.rounds_below_critical += 1
        else:
            self.rounds_below_critical = 0
        if self.rounds_below_critical >= 2:
            return Action.D
        if round_t > 0:
            prev_stock = history.my_payoffs[round_t - 1] * 2 * self.n_players
            growth_threshold_low = 0.2 * self.capacity
            growth_threshold_high = 0.7 * self.capacity
            if prev_stock < growth_threshold_low and stock_S > growth_threshold_high:
                return Action.D
        if stock_S > threshold_high:
            return Action.D
        elif stock_S > threshold_medium:
            p_defect = (stock_S - threshold_medium) / (threshold_high - threshold_medium)
            p_defect = max(0.0, min(1.0, p_defect))
            if random.random() < p_defect:
                return Action.D
            else:
                return Action.C
        elif stock_S > threshold_critical:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_185(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy
    
    Defects by default to maximize personal consumption while exploiting cooperators.
    Uses adaptive thresholding based on opponent defection rates and game progression.
    Unconditionally defects in first and final rounds, and when stock is critically depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if current_stock < 2 * self.n_players:
            return Action.D
        opponent_defections = np.sum(~history.opponent_actions[:round_num, :])
        total_opponent_actions = round_num * self.n_players
        if total_opponent_actions == 0:
            opp_defect_rate = 0.0
        else:
            opp_defect_rate = opponent_defections / total_opponent_actions
        threshold = 0.4 + round_num / self.n_rounds * 0.3
        if opp_defect_rate > threshold:
            return Action.D
        elif current_stock > 0.75 * self.capacity and opp_defect_rate < 0.25:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_186(BaseStrategy):
    """
    Adaptive Predation with Graceful Collapse: An exploitative strategy that maximizes
    personal extraction while manipulating opponent behavior through conditional cooperation.
    Defects aggressively when stock is healthy, cooperates tactically to restore stock for
    future exploitation, and guarantees end-game defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.r - 1:
            return Action.D
        if stock < 2 * self.n:
            return Action.D
        if stock >= self.capacity * 0.75:
            return Action.D
        if stock >= self.capacity * 0.4:
            opponent_defection_count = self._count_opponent_defections(history)
            if opponent_defection_count > 0:
                return Action.D
            else:
                return Action.C
        rounds_remaining = self.r - round_num
        if rounds_remaining > 2:
            return Action.C
        else:
            return Action.D

    def _count_opponent_defections(self, history: PlayerHistory) -> int:
        """
        Count total defections by opponents across all rounds so far.
        Returns number of opponent defection actions observed.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0
        defections = np.sum(~history.opponent_actions)
        return int(defections)

class Strategy_EXPLOITATIVE_187(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State-Aware Defection
    
    Exploits the fundamental asymmetry in the common pool resource game by:
    1. Defecting early to establish predatory intent and capture immediate gains
    2. Adapting based on stock levels and phase of the game
    3. Transitioning to pure defection in endgame when cooperation has no future value
    4. Parasitizing on cooperators while matching defectors
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if current_stock < self.capacity / 4:
            return Action.D
        if round_num > 2 * self.n_rounds / 3:
            return Action.D
        if current_stock < self.capacity / 2:
            if history is not None and round_num > 0:
                recent_defections = np.sum(~history.opponent_actions[round_num - 1, :])
                observed_defection_rate = recent_defections / (self.n_players - 1) if self.n_players > 1 else 0.0
                if observed_defection_rate > 0.5:
                    return Action.D
            return Action.D
        if current_stock >= self.capacity / 2:
            if round_num <= self.n_rounds / 3:
                return Action.D
            if history is not None and round_num > 0:
                stock_consumed = self.capacity - current_stock
                stock_change_rate = current_stock / (self.capacity - stock_consumed) if stock_consumed > 0 else 1.0
                if stock_change_rate > 1.0:
                    return Action.D
            rounds_remaining = self.n_rounds - round_num
            if history is not None and round_num > 0:
                avg_consumption = (self.capacity - current_stock) / round_num
                expected_sustainable = self.capacity * 0.25
                if avg_consumption > expected_sustainable:
                    return Action.D
                else:
                    return Action.D
            if rounds_remaining > 5:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_188(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy
    
    Aggressively exploits the asymmetry between cooperation and defection while
    adapting to resource scarcity levels. The core principle: defection yields 2x
    the payoff of cooperation, making it the dominant strategy in a simultaneous-move
    game with no enforcement mechanism.
    
    Decision logic:
    - Final round: Always defect (no future punishment)
    - High stock (>60% capacity): Always defect (maximum extraction window)
    - Medium stock (30-60% capacity): Always defect (exploit predictable opponents)
    - Low stock (≤30% capacity): Always defect (extract before collapse)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if self.capacity <= 0:
            return Action.D
        stock_ratio = current_stock / self.capacity
        if stock_ratio > 0.6:
            return Action.D
        elif stock_ratio > 0.3:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_189(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    This strategy exploits the asymmetry between cooperators and defectors by:
    1. Almost always defecting to maximize immediate payoffs (2x cooperation)
    2. Adapting based on stock levels and round position
    3. Extracting maximum value before resource collapse
    4. Always defecting in the final round
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.depletion_threshold = self.capacity * 0.25
        self.sustainability_threshold = self.capacity * 0.6
        self.defection_ratio_threshold = 0.3
        self.stock_history = []
        self.my_action_count = {'D': 0, 'C': 0}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            self.stock_history.append(current_stock)
            self.my_action_count['D'] += 1
            return Action.D
        self.stock_history.append(current_stock)
        if current_round == self.n_rounds - 1:
            self.my_action_count['D'] += 1
            return Action.D
        if current_stock < self.depletion_threshold:
            self.my_action_count['D'] += 1
            return Action.D
        recent_trend = 0.0
        if current_round > 2:
            if self.stock_history[-3] > 0:
                recent_trend = (self.stock_history[-1] - self.stock_history[-3]) / self.stock_history[-3]
        if current_stock > self.sustainability_threshold and recent_trend >= -0.15 and (rounds_remaining > 2):
            self.my_action_count['D'] += 1
            return Action.D
        total_actions = current_round
        our_defection_rate = self.my_action_count['D'] / total_actions if total_actions > 0 else 0.0
        if our_defection_rate > self.defection_ratio_threshold:
            self.my_action_count['D'] += 1
            return Action.D
        if current_round > 0:
            opponent_cooperations = np.sum(history.opponent_actions[:current_round, :])
            opponent_total_actions = current_round * (self.n_players - 1)
            if opponent_total_actions > 0:
                observed_cooperation_rate = opponent_cooperations / opponent_total_actions
                observed_defection_rate = 1.0 - observed_cooperation_rate
                if observed_defection_rate > self.defection_ratio_threshold:
                    self.my_action_count['D'] += 1
                    return Action.D
        self.my_action_count['D'] += 1
        return Action.D

class Strategy_EXPLOITATIVE_190(BaseStrategy):
    """
    Stock Predator: Exploitative adaptive strategy that defaults to defection while monitoring
    stock health and opponent cooperation rates. Cooperates only when stock drops below
    a critical threshold (15% capacity) to prevent total collapse, ensuring future rounds
    remain viable for extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if current_stock < self.capacity * 0.15:
            return Action.C
        if round_number == 0:
            return Action.D
        if round_number == self.n_rounds - 1:
            return Action.D
        opponent_coop_rate = self._calculate_opponent_cooperation_rate(history, round_number)
        stock_health = current_stock / self.capacity
        cooperation_threshold = 0.4 + 0.3 * stock_health
        if opponent_coop_rate > cooperation_threshold:
            return Action.D
        else:
            return Action.D

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the proportion of times opponents cooperated in previous rounds.
        Handles edge case of no valid history.
        """
        if current_round <= 0:
            return 0.0
        total_opponent_actions = 0
        total_cooperations = 0
        for round_idx in range(current_round):
            cooperations_this_round = np.sum(history.opponent_actions[round_idx, :])
            total_cooperations += cooperations_this_round
            total_opponent_actions += self.n_players
        if total_opponent_actions == 0:
            return 0.0
        return float(total_cooperations) / float(total_opponent_actions)

class Strategy_EXPLOITATIVE_191(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Conditional Cooperation
    
    Maximizes personal extraction by defaulting to defection while monitoring stock levels.
    Switches to cooperation only when stock approaches critical collapse to preserve
    future exploitation opportunities. Always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_critical = 2 * self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.n_rounds - 1:
            return Action.D
        if current_stock > self.threshold_critical:
            return Action.D
        if current_stock <= self.threshold_critical:
            projected_remaining = current_stock - current_stock
            if projected_remaining <= 0:
                projected_growth = 0.0
            else:
                projected_growth = 2.0 * projected_remaining * (1.0 - projected_remaining / self.capacity)
            projected_next_stock = projected_remaining + projected_growth
            if projected_next_stock <= 0:
                return Action.C
        if history is not None and round_number > 0:
            opponent_cooperation_rates = []
            for opponent_idx in range(self.n_players - 1):
                cooperations = np.sum(history.opponent_actions[:round_number, opponent_idx])
                cooperation_rate = cooperations / round_number if round_number > 0 else 0.0
                opponent_cooperation_rates.append(cooperation_rate)
            if any((rate > 0.6 for rate in opponent_cooperation_rates)):
                return Action.D
            total_defections = np.sum(~history.opponent_actions[:round_number, :])
            total_actions = (self.n_players - 1) * round_number
            if total_actions > 0:
                defection_rate = total_defections / total_actions
                if defection_rate > 0.7 and current_stock > self.threshold_critical:
                    return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_192(BaseStrategy):
    """
    Adaptive Threshold Exploitation (ATE) Strategy for Common Pool Resource Game.
    
    Exploits the commons aggressively while stock is abundant, then switches to
    cooperation when stock approaches a depletion threshold to avoid mutual collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        base_threshold = self.capacity * (1.5 / self.n_players)
        remaining_rounds = self.n_rounds - current_round
        depletion_threshold = base_threshold * (remaining_rounds / self.n_rounds)
        if current_round == self.n_rounds - 1:
            if current_stock > 0:
                return Action.C
            else:
                return Action.D
        if current_stock > depletion_threshold:
            return Action.D
        elif current_stock > 0:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_193(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Opportunistic Defection
    
    This strategy exploits asymmetric payoff structure by defaulting to defection,
    cooperating only when stock health and remaining rounds make defection
    strategically advantageous for maximum extraction. Monitors stock dynamics
    to adapt exploitation tactics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        rounds_left = self.n_rounds - state.round_number
        stock = state.current_stock
        if self.capacity <= 0:
            return Action.D
        health = stock / self.capacity
        if rounds_left <= 2:
            return Action.D
        if health <= 0.2:
            return Action.D
        if health > 0.6 and rounds_left > 2:
            return Action.D
        if health > 0.2 and health <= 0.6:
            observed_growth = self._analyze_growth_pattern(history, state.round_number)
            if observed_growth > 0:
                return Action.D
            else:
                avg_consumption = self._analyze_consumption_rate(history, state.round_number)
                sustainable_consumption = self.capacity / (2.0 * self.n_players)
                if avg_consumption > sustainable_consumption:
                    return Action.D
                else:
                    return Action.D
        return Action.D

    def _analyze_growth_pattern(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate net stock growth over recent rounds to detect if cooperators
        are sustaining the pool.
        
        Returns:
            Estimated stock growth (positive if pool recovering, negative if depleting)
        """
        if current_round < 2:
            return 0.0
        lookback = min(3, current_round)
        recent_cooperation_count = 0
        for round_idx in range(max(0, current_round - lookback), current_round):
            cooperators_in_round = np.sum(history.opponent_actions[round_idx, :])
            recent_cooperation_count += cooperators_in_round
        avg_cooperators = recent_cooperation_count / float(lookback) if lookback > 0 else 0
        if avg_cooperators > self.n_players * 0.25:
            return 1.0
        return -1.0

    def _analyze_consumption_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Estimate average consumption per round based on payoff history.
        Higher consumption → less sustainability → more defection in the system.
        
        Returns:
            Estimated average consumption per round
        """
        if current_round < 1:
            return 0.0
        total_my_payoffs = np.sum(history.my_payoffs[:current_round])
        total_opponent_payoffs = np.sum(history.opponent_payoffs[:current_round])
        total_consumption = total_my_payoffs + total_opponent_payoffs
        rounds_played = current_round
        players_total = 1 + self.n_players
        if rounds_played <= 0 or players_total <= 0:
            return 0.0
        avg_consumption = total_consumption / (rounds_played * players_total)
        return avg_consumption

class Strategy_EXPLOITATIVE_194(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Exploitation
    
    Core approach:
    - Defect by default to extract 2x payoff from cooperators
    - Cooperate strategically only when stock collapses to allow recovery
    - Defect unconditionally in final rounds to maximize terminal extraction
    - Track cooperation debt to ensure single-round recovery investments
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_debt = 0
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 2 * self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - round_number
        if round_number == 0:
            return Action.D
        if round_number >= self.n_rounds - 1:
            return Action.D
        if current_stock < self.critical_threshold and rounds_remaining > 2 and (self.cooperation_debt == 0):
            self.cooperation_debt = 1
            return Action.C
        if self.cooperation_debt > 0:
            self.cooperation_debt -= 1
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_195(BaseStrategy):
    """
    Aggressive Extraction with Tactical Restraint: An exploitative strategy that maximizes
    individual payoff by defecting strategically, while adapting to observed defection rates
    and stock dynamics. Cooperates only in early rounds for information gathering when stock
    is abundant, then transitions to aggressive defection to exploit the commons before collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        observed_defection_rate = self._calculate_defection_rate(history, current_round)
        critical_stock_threshold = 2 * self.n_players
        if current_stock < critical_stock_threshold:
            return Action.D
        if observed_defection_rate > 0.5:
            return Action.D
        abundant_stock_threshold = self.capacity * 0.75
        if current_stock >= abundant_stock_threshold and rounds_remaining > 2:
            return Action.C
        if self._is_stock_growing(history, current_round):
            recovery_threshold = self.capacity * 0.6
            if current_stock >= recovery_threshold:
                return Action.D
        collapse_threshold = self.capacity * 0.4
        if current_stock < collapse_threshold:
            return Action.D
        return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the observed defection rate from opponent actions up to current round.
        Defection is False (0), Cooperation is True (1).
        """
        if current_round == 0:
            return 0.0
        total_actions = 0
        total_defections = 0
        for round_idx in range(current_round):
            opponent_actions_this_round = history.opponent_actions[round_idx, :]
            defections_this_round = np.sum(opponent_actions_this_round == 0)
            total_defections += defections_this_round
            total_actions += len(opponent_actions_this_round)
        if total_actions == 0:
            return 0.0
        return total_defections / total_actions

    def _is_stock_growing(self, history: PlayerHistory, current_round: int) -> bool:
        """
        Determine if stock is growing by examining recent stock trajectory.
        Returns True if stock has been growing in recent rounds.
        """
        if current_round < 2:
            return False
        look_back = min(2, current_round)
        recent_stocks = []
        for round_idx in range(current_round - look_back, current_round):
            opponent_payoffs_this_round = history.opponent_payoffs[round_idx, :]
            avg_payoff = np.mean(opponent_payoffs_this_round)
            recent_stocks.append(avg_payoff)
        if len(recent_stocks) >= 2:
            return recent_stocks[-1] >= recent_stocks[-2] * 0.95
        return len(recent_stocks) > 0 and recent_stocks[-1] > 0

class Strategy_EXPLOITATIVE_196(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Collapse Engineering
    
    Ruthlessly extracts from the common pool by defecting when stock is healthy,
    accelerating resource depletion to force opponents into low-payoff regimes.
    Switches to selective cooperation only when stock collapse is imminent and
    future rounds exist, otherwise defaults to defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number
        threshold_high = self.capacity * 0.6
        threshold_low = self.capacity * 0.3
        if current_stock > threshold_high:
            return Action.D
        if current_stock > threshold_low:
            if rounds_remaining > 2:
                return Action.D
            else:
                return Action.C
        if current_stock <= threshold_low:
            if round_number == self.n_rounds - 1:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_197(BaseStrategy):
    """
    Dynamic Extraction Maximization (DEM): An exploitative strategy that maximizes
    payoff by defecting when resources are abundant or depleted, and adapting in
    transition zones based on opponent behavior and stock trajectory.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_rounds
        self.n_rounds = game_description.n_rounds
        self.abundance_threshold = self.capacity * 0.6
        self.depletion_threshold = self.capacity * 0.3
        self.critical_threshold = self.capacity * 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock > self.abundance_threshold:
            return Action.D
        if current_stock <= self.depletion_threshold:
            return Action.D
        return self._adaptive_defect_decision(state, history, current_stock)

    def _adaptive_defect_decision(self, state: CommonPoolState, history: PlayerHistory, current_stock: float) -> Action:
        """
        Decision logic for transition zone: defect based on opponent defection rate
        and estimated stock trajectory.
        """
        rounds_played = state.round_number
        opponent_cooperations = np.sum(history.opponent_actions[:rounds_played, :])
        total_opponent_actions = rounds_played * self.game_description.n_players
        if total_opponent_actions == 0:
            return Action.D
        opponent_cooperation_rate = opponent_cooperations / total_opponent_actions
        observed_defection_rate = 1.0 - opponent_cooperation_rate
        if observed_defection_rate > 0.5:
            return Action.D
        if observed_defection_rate < 0.3:
            return Action.D
        estimated_stock_next = self._project_stock_one_round_ahead(current_stock, rounds_played)
        if estimated_stock_next < self.critical_threshold:
            return Action.D
        return Action.D

    def _project_stock_one_round_ahead(self, current_stock: float, rounds_played: int) -> float:
        """
        Estimate stock level after one more round of all-defect scenario.
        Assumes worst-case: all players defect in the next round.
        """
        total_consumption = current_stock
        stock_after_consumption = max(0.0, current_stock - total_consumption)
        if stock_after_consumption <= 0:
            return 0.0
        growth = 2.0 * stock_after_consumption * (1.0 - stock_after_consumption / self.capacity)
        projected_stock = min(stock_after_consumption + growth, self.capacity)
        return projected_stock

class Strategy_EXPLOITATIVE_198(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy.
    
    Exploits the tension between immediate defection gains and long-term resource depletion.
    Uses first-round aggression, endgame extraction, resource collapse triggers, and adaptive
    exploitation of opponent cooperation patterns to maximize individual payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        collapse_threshold = self.capacity * 0.15
        if current_stock <= collapse_threshold:
            return Action.D
        lookback_window = min(3, current_round)
        start_round = current_round - lookback_window
        c_count = 0
        total_opponent_actions = 0
        for round_idx in range(start_round, current_round):
            c_count += np.sum(history.opponent_actions[round_idx, :])
            total_opponent_actions += self.n_players - 1
        if total_opponent_actions > 0:
            cooperation_rate = c_count / total_opponent_actions
        else:
            cooperation_rate = 0.0
        if cooperation_rate >= 0.65:
            return Action.D
        elif cooperation_rate >= 0.4:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_199(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Core approach: Relentlessly defect while monitoring stock depletion to identify
    when to intensify extraction. Defect in round 1, final rounds, and whenever stock
    shows signs of aggressive consumption or depletion below thresholds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if self.n_rounds - current_round <= 2:
            return Action.D
        if current_stock < 1.0:
            return Action.C
        if current_stock < self.capacity * 0.4:
            return Action.D
        stock_depletion = 0.0
        if current_round > 0 and history is not None:
            opponent_consumption_total = 0.0
            for round_idx in range(current_round):
                round_actions = history.opponent_actions[round_idx, :]
                defectors_count = np.sum(~round_actions)
                opponent_consumption_total += defectors_count
            avg_defection_rate = opponent_consumption_total / (self.n_players - 1) / current_round
            if avg_defection_rate > 0.5:
                stock_depletion = self.capacity * 0.15
            if current_round >= 1:
                last_round_defectors = np.sum(~history.opponent_actions[current_round - 1, :])
                if last_round_defectors > self.n_players // 2:
                    stock_depletion = self.capacity * 0.15
        threshold = self.capacity * (0.15 / self.n_players)
        if stock_depletion > threshold:
            return Action.D
        if current_stock < self.capacity * 0.7:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_200(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Extraction with Conditional Restraint
    
    Maximizes personal payoff by exploiting cooperative behavior when detected,
    while maintaining stock sustainability to prevent game collapse that would
    harm extraction opportunities. Uses dynamic thresholds and a survival valve
    to balance aggression with resource preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 2 * self.n_players * 1.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.critical_threshold:
            return Action.C
        if history is not None and current_round > 0:
            previous_round_opponent_actions = history.opponent_actions[current_round - 1, :]
            cooperator_count = int(np.sum(previous_round_opponent_actions))
            cooperation_rate = cooperator_count / self.n_players if self.n_players > 0 else 0.0
            actual_round = current_round + 1
            cooperation_threshold = 0.5 + 0.1 * (actual_round / self.n_rounds)
            if cooperation_rate >= cooperation_threshold:
                return Action.D
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_201(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Resource Monitoring
    
    Exploits the 2x payoff advantage of defection while monitoring stock levels
    and opponent behavior. Defects aggressively when stock is abundant, adapts
    when stock is moderate based on opponent defection rates, and extracts maximum
    value in final rounds and during resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        observed_defection_rate = self._calculate_opponent_defection_rate(history)
        if stock < 2 * self.n_players:
            return Action.D
        normalized_stock = stock / self.capacity
        if normalized_stock < 0.4:
            if observed_defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        if normalized_stock >= 0.7:
            return Action.D
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= 3:
            return Action.D
        if observed_defection_rate >= 0.7:
            return Action.D
        return Action.D

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the observed defection rate from all opponents across all previous rounds.
        Returns a value between 0 and 1, where 1 means all opponent actions were defections.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        total_opponent_actions = history.opponent_actions.size
        if total_opponent_actions == 0:
            return 0.0
        defection_count = np.sum(history.opponent_actions == False)
        observed_defection_rate = float(defection_count) / float(total_opponent_actions)
        return observed_defection_rate

class Strategy_EXPLOITATIVE_202(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Conditional Cooperation
    
    Maximizes personal payoff by exploiting the asymmetry between C and D actions.
    Defects aggressively when stock is abundant, but adapts to cooperate defensively
    when stock depletion threatens future earnings.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.threshold_defect = self.capacity * 0.25
        self.stock_history = [self.capacity]
        self.last_two_round_stocks = [self.capacity]

    def _detect_declining_trend(self) -> bool:
        """Detect if stock is in a declining trajectory."""
        if len(self.stock_history) < 2:
            return False
        current = self.stock_history[-1]
        previous = self.stock_history[-2]
        if current == 0:
            return True
        if len(self.stock_history) >= 3:
            two_rounds_ago = self.stock_history[-3]
            recent_decline = (two_rounds_ago - current) / max(two_rounds_ago, 0.001)
            if recent_decline > 0.3:
                return True
        if current < previous:
            return True
        return False

    def _is_critical_stock(self) -> bool:
        """Check if stock level is critically low."""
        if len(self.stock_history) < 1:
            return False
        return self.stock_history[-1] == 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.D
        self.stock_history.append(state.current_stock)
        current_stock = state.current_stock
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if current_stock > self.threshold_defect:
            return Action.D
        if current_stock <= self.threshold_defect:
            if self._is_critical_stock() or self._detect_declining_trend():
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_203(BaseStrategy):
    """
    Adaptive Depletion: An exploitative strategy for Common Pool Resource games.
    
    Operates in three phases:
    1. Early game (rounds 0-60%): Aggressive extraction with probabilistic probing
    2. Mid game (rounds 60-85%): Adaptive response based on observed opponent defection rate
    3. Endgame (rounds 85-100%): Always defect (terminal round dominance)
    
    Exploits opponent behavior through information asymmetry and adaptive mirroring.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        phase_ratio = current_round / self.n_rounds
        opponent_defection_rate = self._calculate_opponent_defection_rate(history, current_round)
        if phase_ratio >= 0.85:
            return Action.D
        if phase_ratio < 0.6:
            return self._phase1_decision(current_stock)
        return self._phase2_decision(current_stock, opponent_defection_rate)

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the observed defection rate of all opponents.
        
        Defection is encoded as False (0), Cooperation as True (1).
        Defection rate = (total defections) / (total actions observed)
        """
        if current_round == 0:
            return 0.5
        opponent_actions_observed = history.opponent_actions[:current_round, :]
        total_actions = opponent_actions_observed.size
        if total_actions == 0:
            return 0.5
        total_defections = np.sum(~opponent_actions_observed)
        defection_rate = total_defections / total_actions
        return float(defection_rate)

    def _phase1_decision(self, current_stock: float) -> Action:
        """
        PHASE 1: Aggressive Extraction (rounds 0-60%)
        
        If stock > 75% capacity: DEFECT
        If stock 50-75% capacity: DEFECT with 85% probability
        If stock <= 50% capacity: COOPERATE
        """
        stock_ratio = current_stock / self.capacity
        if stock_ratio > 0.75:
            return Action.D
        elif stock_ratio > 0.5:
            if random.random() < 0.85:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

    def _phase2_decision(self, current_stock: float, opponent_defection_rate: float) -> Action:
        """
        PHASE 2: Adaptive Response (rounds 60-85%)
        
        Track opponent defection rate and adapt:
        - High defection (>70%) or low defection (<40%): DEFECT
        - Medium defection (40-70%): Conditional on stock level
        """
        stock_ratio = current_stock / self.capacity
        if opponent_defection_rate > 0.7 or opponent_defection_rate < 0.4:
            return Action.D
        if stock_ratio > 0.6:
            return Action.D
        elif stock_ratio < 0.3:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_204(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Conditional Cooperation
    
    This strategy defaults to defection to maximize immediate payoffs, while selectively
    cooperating to reset exploitation cycles. It monitors stock dynamics and adapts based on:
    - Stock depletion rate (high depletion triggers brief cooperation to signal weakness)
    - Stock recovery windows (abundant stock triggers aggressive defection)
    - Endgame conditions (final rounds prioritize immediate extraction)
    - Stock collapse recovery (critically low stock triggers brief cooperation for regrowth)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_c_count = 0
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history = [self.game_description.capacity]
            return Action.D
        self.stock_history.append(state.current_stock)
        rounds_remaining = self.game_description.n_rounds - state.round_number
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if rounds_remaining <= 2:
            self.consecutive_c_count = 0
            return Action.D
        if current_stock < 0.2 * capacity and current_stock > 0:
            self.consecutive_c_count = 0
            return Action.C
        if len(self.stock_history) >= 2:
            prev_stock = self.stock_history[-2]
            if prev_stock > 0:
                stock_depletion_rate = (prev_stock - current_stock) / prev_stock
                if stock_depletion_rate > 0.4:
                    if self.consecutive_c_count < 2:
                        self.consecutive_c_count += 1
                        return Action.C
                    else:
                        self.consecutive_c_count = 0
            else:
                self.consecutive_c_count = 0
        if current_stock > 0.7 * capacity:
            self.consecutive_c_count = 0
            return Action.D
        self.consecutive_c_count = 0
        return Action.D

class Strategy_EXPLOITATIVE_205(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Stock Monitoring
    
    Defects aggressively when stock can sustain it, cooperates only when forced by
    resource scarcity to preserve future defection opportunities. Uses a declining
    threshold based on game progress to balance exploitation with survival.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        collapse_threshold = 1.5 * self.n_players
        if current_stock < collapse_threshold:
            return Action.C
        if round_number == self.n_rounds - 1:
            if current_stock > 0:
                return Action.D
            return Action.C
        saturation_threshold = 0.95 * self.capacity
        if current_stock >= saturation_threshold:
            return Action.D
        progress = round_number / self.n_rounds
        f_progress = 0.4 - 0.3 * progress ** 2
        threshold = self.capacity * f_progress
        if history is not None and round_number >= 3:
            recent_rounds = min(3, round_number)
            recent_stocks = []
            for i in range(round_number - recent_rounds, round_number):
                if i >= 0:
                    my_payoff = history.my_payoffs[i]
                    opponent_payoffs = history.opponent_payoffs[i, :]
                    total_payoffs = my_payoff + np.sum(opponent_payoffs)
                    recent_stocks.append(total_payoffs)
            if len(recent_stocks) >= 2:
                avg_recent = np.mean(recent_stocks)
                if avg_recent < self.capacity / (4 * self.n_players):
                    threshold = min(threshold * 1.2, self.capacity * 0.6)
                elif avg_recent > self.capacity / (2 * self.n_players):
                    threshold = max(threshold * 0.8, self.capacity * 0.1)
        if current_stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_206(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Sustainability Margin
    
    Core philosophy: Exploit cooperative players ruthlessly while maintaining just enough
    stock sustainability to prevent resource collapse. Defect by default, cooperate only
    when forced by scarcity or to prevent immediate collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.collapse_threshold = 2 * self.n * 1.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        rounds_left = self.r - round_num
        if round_num == 0:
            return Action.D
        if rounds_left <= 2:
            return Action.D
        if stock < self.collapse_threshold:
            return Action.C
        recent_rounds_to_check = min(3, round_num)
        if recent_rounds_to_check > 0:
            recent_opponent_actions = history.opponent_actions[-recent_rounds_to_check:, :]
            recent_defections = np.sum(~recent_opponent_actions)
            total_recent_actions = recent_rounds_to_check * self.n
            recent_defection_rate = recent_defections / total_recent_actions if total_recent_actions > 0 else 0.0
            if recent_defection_rate > 0.5:
                return Action.D
            if round_num >= 3:
                stock_history = history.my_payoffs[-3:]
                avg_recent_payoff = np.mean(stock_history) if len(stock_history) > 0 else stock
                stock_declining = stock < avg_recent_payoff * 0.8
            else:
                stock_declining = False
            if stock_declining and stock < self.capacity * 0.6:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_207(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Harvesting
    
    Core approach: Cooperate in round 1 to establish false cooperative baseline,
    then defect in all subsequent rounds to exploit others' reciprocity and capture
    2x payoff advantage of defection over cooperation. Adaptively accelerates
    defection when stock degrades rapidly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        stock_threshold = 2.0 * self.capacity / 3.0
        if current_stock < stock_threshold:
            return Action.D
        if current_stock == 0:
            return Action.D
        if self._evaluate_stock_decline(history):
            return Action.D
        return Action.D

    def _evaluate_stock_decline(self, history: PlayerHistory) -> bool:
        """
        Detect if stock declined by >30% in the previous round.
        Returns True if rapid decline detected, False otherwise.
        """
        if len(history.my_payoffs) < 2:
            return False
        prev_round_idx = len(history.my_payoffs) - 1
        if prev_round_idx < 1:
            return False
        try:
            prev_payoff = history.my_payoffs[prev_round_idx - 1]
            curr_payoff = history.my_payoffs[prev_round_idx]
            my_action_prev = history.my_actions[prev_round_idx - 1]
            my_action_curr = history.my_actions[prev_round_idx]
            if my_action_prev:
                stock_before_prev = prev_payoff * 2.0 * self.n_players
            else:
                stock_before_prev = prev_payoff * self.n_players
            if my_action_curr:
                stock_before_curr = curr_payoff * 2.0 * self.n_players
            else:
                stock_before_curr = curr_payoff * self.n_players
            if stock_before_prev <= 0:
                return False
            decline_rate = (stock_before_prev - stock_before_curr) / stock_before_prev
            return decline_rate > 0.3
        except (IndexError, ZeroDivisionError):
            return False

class Strategy_EXPLOITATIVE_208(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Conditional Cooperation
    
    Maximizes personal extraction by defecting when the pool is healthy and above
    a dynamic threshold, while conditionally cooperating when the pool is stressed
    or when opponents are heavily defecting. Prevents pool collapse to preserve
    future exploitation opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.capacity * 0.1:
            return Action.C
        if current_stock >= self.capacity * 0.95:
            return Action.D
        if current_round == 0:
            if self.n_players <= 3:
                return Action.D
            else:
                return Action.D
        last_round_idx = current_round - 1
        opponent_actions_last_round = history.opponent_actions[last_round_idx, :]
        defection_count_last_round = self.n_players - np.sum(opponent_actions_last_round)
        opponent_defection_rate = float(defection_count_last_round) / self.n_players
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= 3:
            stock_threshold = self.capacity * 0.35
        else:
            stock_threshold = self.capacity * 0.4
        if opponent_defection_rate > 0.7:
            return Action.C
        exploitation_threshold = 0.5
        if current_stock > stock_threshold and opponent_defection_rate < exploitation_threshold:
            return Action.D
        elif current_stock <= stock_threshold or opponent_defection_rate >= exploitation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_209(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Defection
    
    Treats the common pool as a resource to extract maximum value before other players do.
    Uses stock-dependent defection as the primary rule, with adaptive behavior based on
    observed opponent defection rates and game phase.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity * 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock <= 0:
            return Action.D
        if state.current_stock > self.threshold:
            return Action.D
        if state.current_stock <= self.threshold:
            opponent_defection_count = 0
            total_opponent_actions = 0
            for round_idx in range(state.round_number):
                for player_idx in range(self.game_description.n_players - 1):
                    if not history.opponent_actions[round_idx, player_idx]:
                        opponent_defection_count += 1
                    total_opponent_actions += 1
            if total_opponent_actions > 0:
                opponent_defection_rate = opponent_defection_count / total_opponent_actions
            else:
                opponent_defection_rate = 0.0
            if opponent_defection_rate > 0.5:
                return Action.D
            rounds_remaining = self.game_description.n_rounds - state.round_number
            if rounds_remaining <= 2:
                observed_all_cooperation = True
                check_rounds = min(2, state.round_number)
                for round_idx in range(state.round_number - check_rounds, state.round_number):
                    if round_idx >= 0:
                        for player_idx in range(self.game_description.n_players - 1):
                            if not history.opponent_actions[round_idx, player_idx]:
                                observed_all_cooperation = False
                                break
                    if not observed_all_cooperation:
                        break
                if observed_all_cooperation and check_rounds > 0:
                    return Action.C
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_210(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Collapse Prevention
    
    Maximizes personal payoff by identifying and exploiting cooperative opponents,
    defecting when profitable, preventing pool collapse, and adapting to opponent patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_coop_rates = None
        self.cumulative_extraction = 0.0
        self.recent_mean_coop_history = []
        self.aggressive_defection_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        current_round = state.round_number
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            return Action.D
        n_opponents = self.n_players - 1
        opponent_actions = history.opponent_actions[:current_round, :]
        if opponent_actions.size == 0:
            mean_coop = 0.0
            self.opponent_coop_rates = np.zeros(n_opponents)
        else:
            self.opponent_coop_rates = np.mean(opponent_actions, axis=0)
            mean_coop = float(np.mean(self.opponent_coop_rates))
        self.recent_mean_coop_history.append(mean_coop)
        if len(self.recent_mean_coop_history) > 2:
            self.recent_mean_coop_history.pop(0)
        if current_round > 0:
            self.cumulative_extraction += history.my_payoffs[current_round - 1]
        if current_round >= self.n_rounds - 2:
            if stock < self.capacity * 0.1:
                return Action.C
            return Action.D
        if stock < self.capacity * 0.15:
            if stock > self.capacity * 0.05 and rounds_remaining >= 2:
                return Action.C
            else:
                if self.n_players >= 4 and self.cumulative_extraction > self.capacity * 1.2:
                    return Action.C
                return Action.D
        if stock > self.capacity * 0.85:
            if mean_coop > 0.5:
                return Action.D
        if mean_coop <= 0.4:
            return Action.D
        if len(self.recent_mean_coop_history) >= 2:
            recent_avg = float(np.mean(np.array(self.recent_mean_coop_history)))
            if recent_avg > 0.7:
                if self.aggressive_defection_counter < 3 and rounds_remaining >= 1:
                    self.aggressive_defection_counter += 1
                    return Action.D
                else:
                    self.aggressive_defection_counter = 0
        if self.cumulative_extraction > self.capacity * 1.5 and stock < self.capacity * 0.2:
            return Action.C
        if mean_coop > 0.4 and mean_coop <= 0.65:
            if stock > self.capacity * 0.5:
                return Action.D
            else:
                return Action.C
        if mean_coop > 0.65:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_211(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Threshold Monitoring
    
    This strategy exploits cooperators by defecting when the stock is healthy,
    only cooperating minimally to prevent total collapse when necessary.
    Core principle: extract maximum value while pool sustains growth.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        total_rounds = self.n_rounds
        if current_round == total_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        if current_round == total_rounds - 2:
            if current_stock > self.capacity * 0.4:
                return Action.D
            else:
                return Action.C
        healthy_threshold = self.capacity * 0.6
        critical_threshold = self.capacity * 0.1
        if current_stock >= healthy_threshold:
            return Action.D
        if current_stock < critical_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_212(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Dynamic Threshold Switching
    
    This strategy maximizes payoff extraction from the common pool by:
    1. Defecting aggressively when stock is high (above exploitation threshold)
    2. Switching to cooperation only when stock approaches collapse and future rounds exist
    3. Always defecting in final rounds (no future regrowth benefit)
    4. Tracking opponent defection rates to identify exploitable pools
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.recovery_threshold = 2 * self.n_players * 1.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - round_number
        if round_number == 0:
            return Action.D
        if rounds_remaining <= 1:
            return Action.D
        if rounds_remaining <= 2:
            return Action.D
        exploitation_threshold = self.capacity * (1.0 - math.sqrt(rounds_remaining / self.n_rounds))
        if current_stock > exploitation_threshold:
            return Action.D
        if current_stock <= self.recovery_threshold:
            if current_stock > self.recovery_threshold / 2.0:
                return Action.C
            else:
                return Action.D
        if rounds_remaining > 3:
            total_opponent_defections = 0
            for r in range(round_number):
                defectors_in_round = self.n_players - int(np.sum(history.opponent_actions[r, :]))
                total_opponent_defections += defectors_in_round
            total_opponent_actions = round_number * self.n_players
            if total_opponent_actions > 0:
                observed_defection_rate = total_opponent_defections / total_opponent_actions
            else:
                observed_defection_rate = 0.0
            if observed_defection_rate < 0.4:
                return Action.D
            elif current_stock > 1.2 * self.recovery_threshold:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_213(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    This strategy exploits asymmetry between cooperative and defective payoffs while adapting
    to stock depletion patterns. It uses stock-dependent decision rules to maximize extraction:
    - High stock (>70% capacity): Always defect
    - Medium stock (30-70%): Defect if opponents defect >50%, else cooperate
    - Low stock (≤30%): Always defect
    - First and last rounds: Always defect
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.high_stock_threshold = game_description.capacity * 0.7
        self.low_stock_threshold = game_description.capacity * 0.3
        self.pessimistic_default_defection_rate = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        observed_defection_rate = self._compute_opponent_defection_rate(history, state.round_number)
        current_stock = state.current_stock
        if current_stock > self.high_stock_threshold:
            return Action.D
        elif current_stock > self.low_stock_threshold:
            if observed_defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _compute_opponent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Compute the observed defection rate of opponents across all previous rounds.
        
        Returns a value in [0, 1] where 1.0 means all observed opponent actions were defections.
        If no opponent actions have been observed yet, returns pessimistic default (0.7).
        """
        num_previous_rounds = current_round
        num_opponents = self.game_description.n_players - 1
        if num_previous_rounds == 0:
            return self.pessimistic_default_defection_rate
        defection_count = 0
        for round_idx in range(num_previous_rounds):
            for opponent_idx in range(num_opponents):
                if not history.opponent_actions[round_idx, opponent_idx]:
                    defection_count += 1
        total_opponent_actions = num_previous_rounds * num_opponents
        if total_opponent_actions == 0:
            return self.pessimistic_default_defection_rate
        return defection_count / total_opponent_actions

class Strategy_EXPLOITATIVE_214(BaseStrategy):
    """
    Adaptive Predation: An exploitative strategy for Common Pool Resource games.
    
    Core philosophy: Extract maximum value by exploiting cooperative opponents,
    adapting to opponent defection rates, and leveraging stock abundance while
    it lasts. Shifts to minimal cooperation only when stock is critically depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        early_game_threshold = math.floor(self.r / 3)
        late_game_threshold = math.floor(2 * self.r / 3)
        if stock <= 2 * self.n:
            return Action.C
        if round_num == 0:
            return Action.D
        if round_num == self.r - 1:
            return Action.D
        if round_num > late_game_threshold:
            return Action.D
        opponent_defection_count = 0
        for past_round in range(round_num):
            defections_this_round = np.sum(~history.opponent_actions[past_round, :])
            opponent_defection_count += defections_this_round
        total_opponent_actions = round_num * (self.n - 1)
        opponent_defection_rate = opponent_defection_count / total_opponent_actions if total_opponent_actions > 0 else 0.0
        stock_ratio = stock / self.capacity if self.capacity > 0 else 1.0
        if stock_ratio <= 0.25:
            return Action.C
        if stock_ratio > 0.5:
            if opponent_defection_rate > 0.4:
                return Action.D
            elif opponent_defection_rate < 0.2:
                return Action.D
            else:
                return Action.D
        if stock_ratio > 0.25:
            if round_num <= early_game_threshold:
                return Action.D
            if opponent_defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_215(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Threshold Collapse
    
    Ruthlessly defects to extract maximum value early, then switches to cooperation
    only in the final rounds if stock threatens to collapse. Exploits the asymmetry
    that defectors gain 2x the payoff of cooperators while depletion costs are shared.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.D
        if round_number == self.n_rounds - 1:
            if current_stock < self.capacity * 0.15:
                return Action.C
            else:
                return Action.D
        if round_number == self.n_rounds - 2:
            if current_stock < self.capacity * 0.35:
                return Action.C
            else:
                return Action.D
        if round_number > self.n_rounds - 3:
            if current_stock < self.capacity * 0.15:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_216(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy that adapts behavior based on stock depletion,
    opponent defection rates, and round position to maximize individual payoff through
    conditional defection and selective cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round >= self.n_rounds - 2:
            return Action.D
        if current_stock < 2 * self.n_players:
            return Action.D
        depletion_rate = (self.capacity - current_stock) / max(self.capacity, 1e-10)
        if depletion_rate > 0.7 or depletion_rate < 0.3:
            return Action.D
        total_rounds_elapsed = current_round
        total_opponent_defections = 0
        for round_idx in range(total_rounds_elapsed):
            for opp_idx in range(self.n_players - 1):
                if not history.opponent_actions[round_idx, opp_idx]:
                    total_opponent_defections += 1
        total_opponent_action_slots = (self.n_players - 1) * total_rounds_elapsed
        opp_defection_rate = total_opponent_defections / max(total_opponent_action_slots, 1e-10)
        if opp_defection_rate > 0.6:
            return Action.D
        if total_rounds_elapsed >= 2:
            prev_stock = state.current_stock
            past_defections = sum((1 for r in range(total_rounds_elapsed - 1) for o in range(self.n_players - 1) if not history.opponent_actions[r, o]))
            if past_defections >= self.n_players / 2:
                return Action.D
        if opp_defection_rate < 0.3:
            if current_round % 3 == 0:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_217(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Resilient Defection
    
    Maximizes personal payoff by:
    1. Defecting by default to capture immediate gains
    2. Selectively cooperating only when stock is healthy (>60% capacity) 
       AND >40% of opponents cooperated in the previous round
    3. Unconditionally defecting in the final 2 rounds (end-game aggression)
    4. Adapting defection intensity based on stock health to avoid complete collapse
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round >= self.n_rounds - 2:
            return Action.D
        health = current_stock / self.capacity if self.capacity > 0 else 0.0
        if health < 0.3:
            return Action.D
        if history is not None and current_round > 0:
            cooperators_last_round = int(np.sum(history.opponent_actions[current_round - 1, :]))
            cooperation_rate = cooperators_last_round / self.n_players
        else:
            cooperation_rate = 0.0
        if health > 0.75:
            cooperation_threshold = 0.3
        elif health > 0.5:
            cooperation_threshold = 0.4
        else:
            cooperation_threshold = 1.0
        stock_healthy = current_stock > self.capacity * 0.6
        exploitation_signal = cooperation_rate > cooperation_threshold
        if stock_healthy and exploitation_signal:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_218(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Stock Depletion with Conditional Defection
    
    Prioritizes personal extraction maximization through stock-aware defection.
    Defects when stock is healthy, switches to cooperation only when forced by
    depletion. Adapts thresholds based on stock depletion signals and endgame
    dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if stock < 2 * self.n_players:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        rounds_remaining = self.n_rounds - round_num
        base_threshold = 0.5 + rounds_remaining / self.n_rounds * 0.3
        if history is not None and round_num > 0:
            prev_stock = state.current_stock
            if round_num >= 1:
                last_round_idx = round_num - 1
                my_payoff_last = history.my_payoffs[last_round_idx]
                my_action_last = history.my_actions[last_round_idx]
                defect_count_last = sum(~history.opponent_actions[last_round_idx, :])
                my_defect_last = not history.my_actions[last_round_idx]
                total_defect_last = defect_count_last + (1 if my_defect_last else 0)
                if round_num >= 2:
                    avg_payoff_recent = np.mean(history.my_payoffs[max(0, round_num - 3):round_num])
                    depletion_signal = avg_payoff_recent / (stock / (2 * self.n_players))
                    if depletion_signal > 1.5:
                        base_threshold -= 0.1
                    elif depletion_signal < 0.8:
                        base_threshold += 0.05
        if round_num >= self.n_rounds - 2 and stock / self.capacity < 0.3:
            return Action.C
        if stock >= 0.95 * self.capacity:
            return Action.D
        stock_ratio = stock / self.capacity
        if stock_ratio > base_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_219(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Defection
    
    Exploits cooperators through strategic defection while maintaining plausible deniability.
    Uses stock levels and observed cooperation rates to determine when to defect aggressively
    versus when to feign cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.consecutive_defections = 0
        self.last_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            self.last_action = Action.D
            return Action.D
        if round_num >= self.n_rounds - 2:
            self.last_action = Action.D
            self.consecutive_defections += 1
            return Action.D
        last_round_idx = round_num - 1
        my_last_action = history.my_actions[last_round_idx]
        opponent_actions_last = history.opponent_actions[last_round_idx, :]
        cooperator_count = int(np.sum(opponent_actions_last))
        defector_count = self.n_players - cooperator_count
        collapse_threshold = self.capacity * 0.15
        healthy_threshold = self.capacity * 0.5
        cooperator_majority_threshold = self.n_players * 0.75
        defection_significant_threshold = self.n_players * 0.4
        if stock <= collapse_threshold:
            if defector_count > 0:
                self.last_action = Action.D
                self.consecutive_defections += 1
                return Action.D
            else:
                self.last_action = Action.C
                self.consecutive_defections = 0
                return Action.C
        if stock > healthy_threshold:
            self.last_action = Action.D
            self.consecutive_defections += 1
            return Action.D
        if cooperator_count >= cooperator_majority_threshold:
            self.last_action = Action.D
            self.consecutive_defections += 1
            return Action.D
        if defector_count >= defection_significant_threshold:
            if my_last_action and (not history.my_payoffs[last_round_idx] > 0):
                self.last_action = Action.D
                self.consecutive_defections += 1
                return Action.D
            else:
                self.last_action = Action.D
                self.consecutive_defections += 1
                return Action.D
        defection_rate = defector_count / max(self.n_players, 1) + 0.3
        if random.random() < defection_rate:
            self.last_action = Action.D
            self.consecutive_defections += 1
            return Action.D
        else:
            self.last_action = Action.C
            self.consecutive_defections = 0
            return Action.C

class Strategy_EXPLOITATIVE_220(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Cooperation
    
    Exploits the asymmetry between cooperative (S/2n) and defective (S/n) payoffs
    by defecting aggressively while stock is abundant, then switching to cooperation
    only when stock falls below a critical threshold or in the final rounds.
    
    Decision rule:
    - Final 2 rounds: Always defect (endgame extraction)
    - Otherwise: Defect if stock > critical_threshold, else cooperate
    - critical_threshold = 2n × (r - current_round) / r
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round >= self.n_rounds - 2:
            return Action.D
        remaining_rounds = self.n_rounds - current_round
        critical_threshold = 2 * self.n_players * remaining_rounds / self.n_rounds
        if current_stock > critical_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_221(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State Collapse Acceleration.
    
    Core strategy: Defect almost always to maximize personal extraction while
    exploiting cooperative opponents and accelerating resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_regeneration_threshold = game_description.capacity * 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        remaining_rounds = self.game_description.n_rounds - state.round_number - 1
        if remaining_rounds == 0:
            return Action.D
        if state.current_stock <= self.stock_regeneration_threshold:
            return Action.D
        observed_cooperation_rate = self._calculate_opponent_cooperation_rate(history)
        if observed_cooperation_rate > 0.6:
            return Action.D
        return Action.D

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the average cooperation rate across all opponents observed so far.
        Returns a value between 0 and 1.
        """
        if history is None or history.opponent_actions.shape[0] == 0:
            return 0.0
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.0
        cooperations = np.sum(history.opponent_actions)
        cooperation_rate = float(cooperations) / float(total_actions)
        return cooperation_rate

class Strategy_EXPLOITATIVE_222(BaseStrategy):
    """
    Adaptive Predation with Threshold Exploitation.
    
    Exploits asymmetry between cooperators and defectors while remaining sensitive to 
    resource scarcity. Aggressively defects when stock is abundant, selectively exploits 
    identifiable cooperators when stock is moderate, and cooperates for survival when 
    stock is depleted. Always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if round_num == self.n_rounds - 1:
            return Action.D
        if history is None:
            return Action.D
        high_threshold = 0.6 * self.capacity
        low_threshold = 0.2 * self.capacity
        critical_threshold = 0.02 * self.capacity
        if current_stock < critical_threshold:
            return Action.C
        if current_stock > high_threshold:
            return Action.D
        if current_stock <= low_threshold:
            return Action.C
        cooperator_list = []
        rounds_observed = round_num
        if rounds_observed > 0:
            for opponent_idx in range(self.n_players - 1):
                opponent_actions = history.opponent_actions[:rounds_observed, opponent_idx]
                cooperations = np.sum(opponent_actions)
                cooperation_rate = cooperations / rounds_observed if rounds_observed > 0 else 0.0
                if cooperation_rate > 0.7:
                    cooperator_list.append(opponent_idx)
        if round_num >= self.n_rounds - 2:
            return Action.D
        if len(cooperator_list) > 0:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_223(BaseStrategy):
    """
    Adaptive Predation with State Collapse Prevention.
    
    An exploitative strategy that defects by default to maximize personal payoff,
    only cooperating when stock depletion threatens to eliminate payoffs in remaining rounds.
    Monitors defection rates and stock health to adapt exploitation to environmental conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.r - current_round
        if current_round == 0:
            return Action.D
        if rounds_remaining == 1:
            return Action.D
        critical_threshold = 2 * self.n * rounds_remaining / self.r
        if current_stock < critical_threshold:
            return Action.D
        last_round_defections = sum(~history.opponent_actions[-1, :])
        last_round_defection_rate = last_round_defections / self.n
        high_defection_threshold = 1.0 - 1.0 / (2 * self.n)
        if last_round_defection_rate > high_defection_threshold and rounds_remaining > 1:
            return Action.D
        replenishment_zone = self.capacity * 0.8
        if current_stock > replenishment_zone and rounds_remaining > 2:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_224(BaseStrategy):
    """
    Adaptive Predation with Collapse Prevention
    
    Exploitative strategy that defaults to defection to maximize payoff (stock/n vs stock/2n),
    but includes adaptive restraint to prevent total resource collapse that would harm profitability.
    Uses collapse prevention in early rounds and final round greed in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.n_players:
            return Action.C
        if current_round == 0:
            return Action.D
        if history is not None and len(history.my_payoffs) >= 2:
            stock_history = self._compute_stock_history(history)
            if len(stock_history) >= 3:
                recent_trend = stock_history[-1] - stock_history[-3]
                depletion_threshold = -0.15 * self.capacity
                if recent_trend < depletion_threshold and current_stock < 1.5 * self.n_players:
                    return Action.C
        return Action.D

    def _compute_stock_history(self, history: PlayerHistory) -> list[float]:
        """
        Reconstruct stock levels from history by simulating backwards through rounds.
        Returns list of stock levels at start of each round (chronological).
        """
        stock_levels = []
        stock = self.capacity
        stock_levels.append(stock)
        for round_idx in range(len(history.my_payoffs)):
            my_action = history.my_actions[round_idx]
            my_consumption = stock / (2 * self.n_players) if my_action else stock / self.n_players
            opponent_actions = history.opponent_actions[round_idx, :]
            opponent_consumption = 0.0
            for opp_action in opponent_actions:
                if opp_action:
                    opponent_consumption += stock / (2 * self.n_players)
                else:
                    opponent_consumption += stock / self.n_players
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0.0, stock - total_consumption)
            growth = 2.0 * stock_after_consumption * (1.0 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
            stock_levels.append(stock)
        return stock_levels

class Strategy_EXPLOITATIVE_225(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Defection
    
    Defects by default to maximize payoff (2x cooperation), but cooperates when
    necessary to prevent pool collapse. Monitors stock levels and recovery rates
    to determine sustainability of continued defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 2 * self.n

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == self.r - 1:
            return Action.D
        if stock <= self.critical_threshold:
            return Action.C
        if current_round == 0:
            return Action.D
        total_consumption_if_all_defect = stock
        stock_after_all_defect = max(0.0, stock - total_consumption_if_all_defect)
        if stock_after_all_defect <= self.critical_threshold:
            return Action.C
        if history is not None and len(history.my_payoffs) >= 2:
            prev_round_idx = current_round - 1
            opponent_defects_prev = np.sum(~history.opponent_actions[prev_round_idx, :])
            my_action_prev = history.my_actions[prev_round_idx]
            total_defectors = opponent_defects_prev + (0 if my_action_prev else 1)
            payoff_prev = history.my_payoffs[prev_round_idx]
            if payoff_prev > 0:
                if my_action_prev:
                    stock_prev = payoff_prev * 2 * self.n
                else:
                    stock_prev = payoff_prev * self.n
                total_consumption_prev = (self.n - total_defectors) * (stock_prev / (2 * self.n)) + total_defectors * (stock_prev / self.n)
                stock_after_consumption_prev = max(0.0, stock_prev - total_consumption_prev)
                if stock_after_consumption_prev > 0:
                    growth_prev = 2 * stock_after_consumption_prev * (1 - stock_after_consumption_prev / self.capacity)
                else:
                    growth_prev = 0.0
                if stock_after_consumption_prev > 0:
                    growth_ratio = growth_prev / stock_after_consumption_prev if stock_after_consumption_prev > 0 else 0
                    if growth_ratio < 0.05 and stock < 1.3 * self.capacity:
                        return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_226(BaseStrategy):
    """
    Adaptive Depletion strategy for Common Pool Resource Game.
    
    Exploits asymmetry between cooperative and defective payoffs while monitoring
    resource depletion. Uses a dynamically calculated stock threshold that declines
    over time, creating a "harvesting window" for aggressive defection in early/mid
    rounds, with late-game safeguards to prevent mutual collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == self.n_rounds - 1:
            return Action.D
        if round_num > 0.75 * self.n_rounds and stock < 0.2 * self.capacity:
            return Action.C
        if stock < 0.01 * self.capacity:
            return Action.C
        threshold = self.capacity * (0.5 - 0.15 * (round_num / self.n_rounds))
        if stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_227(BaseStrategy):
    """
    Adaptive Depletion Farming: An exploitative strategy that maximizes personal
    extraction by defecting when stock is above threshold, accelerating collapse
    to prevent others' extraction, and analyzing opponent cooperation patterns
    to exploit cooperators ruthlessly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = self.capacity * (2.0 / self.n_players + 0.1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        remaining_rounds = self.n_rounds - current_round
        if current_round == 0:
            return Action.D
        if remaining_rounds <= 2:
            return Action.D
        if remaining_rounds <= self.n_rounds / 3.0:
            if random.random() < 0.9:
                return Action.D
        if current_stock < self.capacity * 0.05:
            return Action.D
        if current_stock > self.threshold:
            return Action.D
        else:
            return Action.D
        if history is not None and len(history.opponent_actions) > 0:
            total_opponent_actions = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
            if total_opponent_actions > 0:
                opponent_cooperation_count = np.sum(history.opponent_actions)
                opponent_cooperation_ratio = opponent_cooperation_count / total_opponent_actions
                if opponent_cooperation_ratio > 0.5:
                    return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_228(BaseStrategy):
    """
    Adaptive Predation with Sustainability Threshold: An exploitative strategy that
    prioritizes immediate payoff extraction while maintaining sufficient stock to sustain
    exploitation across future rounds. Defaults to defection unless stock depletion threatens
    the exploitation window, triggering emergency cooperation to preserve future extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainability_threshold = self.capacity * 0.25
        self.crisis_threshold = self.capacity * 0.1
        self.endgame_threshold = self.n_rounds * 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round > self.endgame_threshold:
            return Action.D
        if current_stock < self.crisis_threshold:
            return Action.D
        if current_stock < self.sustainability_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_229(BaseStrategy):
    """
    Exploitative strategy using dynamic defection with adaptive thresholds.
    Maximizes individual payoff by exploiting cooperative players while adapting
    to pool degradation through stock-level sensing and round-dependent adjustments.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.depletion_threshold = game_description.capacity * 0.4
        self.defection_rate = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        rounds_remaining = self.game_description.n_rounds - state.round_number
        if state.current_stock > self.depletion_threshold:
            base_rate = state.current_stock / self.game_description.capacity * 0.9 + 0.3
        else:
            base_rate = 0.5
        if rounds_remaining <= self.game_description.n_rounds / 3:
            defection_rate = min(0.95, base_rate * 1.3)
        else:
            defection_rate = base_rate
        if state.round_number >= 1:
            previous_stock = history.my_payoffs[state.round_number - 1] * self.game_description.n_players
            if previous_stock > 0:
                stock_change_ratio = (state.current_stock - previous_stock) / previous_stock
                if stock_change_ratio > 0.1:
                    defection_rate = min(0.95, defection_rate + 0.05)
                elif stock_change_ratio < -0.3:
                    defection_rate = max(0.3, defection_rate - 0.1)
        if state.current_stock < self.game_description.n_players * 2 * 0.1:
            defection_rate = max(0.5, defection_rate)
        if random.random() < defection_rate:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_230(BaseStrategy):
    """
    Adaptive Predation: Exploitative strategy that adapts extraction rates based on
    stock levels and opponent cooperation rates, while preserving resources for
    continued exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock = state.current_stock
        if round_t == 0:
            return Action.D
        opponent_coop_rate = self._calculate_opponent_cooperation_rate(history)
        if stock < 2 * self.n:
            return Action.C
        if opponent_coop_rate > 0.6:
            return Action.D
        if stock > 0.8 * self.capacity:
            return Action.D
        if round_t == self.r - 1:
            return Action.D
        if 0.4 * self.capacity < stock < 0.8 * self.capacity:
            return Action.D if random.random() < 0.85 else Action.C
        if 0.2 * self.capacity <= stock <= 0.4 * self.capacity:
            return Action.C
        return Action.C

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the running estimate of opponent cooperation rate.
        Cooperation is True/1, defection is False/0.
        """
        if len(history.opponent_actions) == 0:
            return 0.0
        total_cooperations = np.sum(history.opponent_actions)
        total_decisions = history.opponent_actions.size
        if total_decisions == 0:
            return 0.0
        return float(total_cooperations) / float(total_decisions)

class Strategy_EXPLOITATIVE_231(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Dynamic Pivot (ADP)
    
    Maximizes personal consumption by defecting when stock regeneration is
    favorable, then pivots to cooperation in late-game with critically low stock.
    Core exploit: defection yields 2× cooperation payoff; strategy captures this
    asymmetry while stock is high, then preserves resources when defection becomes futile.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            if stock_ratio > 0.5:
                return Action.D
            else:
                return Action.C
        if stock_ratio <= 0.3:
            return Action.C
        if stock_ratio > 0.5:
            return Action.D
        if rounds_remaining > 3:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_232(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Opportunistic Conditioning
    
    Core behavior:
    - Default to defection (D) to maximize immediate payoff (2x cooperation)
    - Cooperate only when stock falls below emergency threshold to prevent collapse
    - Intensify defection against detected cooperative opponents when stock allows
    - Always defect in final round regardless of stock
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        r_remaining = self.n_rounds - current_round
        if r_remaining <= 0:
            return Action.D
        try:
            threshold = self.capacity * (1.0 - math.exp(-1.0 / r_remaining))
        except (ValueError, ZeroDivisionError):
            threshold = self.capacity * 0.5
        if current_stock <= threshold:
            return Action.C
        if history is not None and len(history.my_actions) > 0:
            total_opponent_cooperations = np.sum(history.opponent_actions)
            total_opponent_actions = history.opponent_actions.size
            if total_opponent_actions > 0:
                opponent_coop_rate = total_opponent_cooperations / total_opponent_actions
                if opponent_coop_rate > 0.6 and current_stock > 1.5 * threshold:
                    return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_233(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Dynamic Threshold Monitoring
    
    Exploits asymmetry between cooperative (S/2n) and defective (S/n) payoffs while
    dynamically adapting to opponent behavior and stock levels. Uses threshold-based
    decision rules that evolve across three game phases (early, mid, endgame).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.observed_defection_count = 0
        self.observed_defection_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        self._update_defection_rate(history, current_round)
        observed_defection_rate = self._get_defection_rate()
        if current_stock < self.capacity / 10.0:
            return Action.C
        if current_stock < self.capacity / 20.0:
            return Action.C
        phase_threshold_early = self.n_rounds / 3.0
        phase_threshold_mid = 2.0 * self.n_rounds / 3.0
        rounds_remaining = self.n_rounds - current_round
        if current_round < phase_threshold_early:
            if observed_defection_rate > (self.n_players - 1.0) / self.n_players:
                return Action.C
            return Action.D
        elif current_round >= phase_threshold_mid:
            critical_stock = self.capacity * (rounds_remaining / float(self.n_rounds))
            if current_stock < critical_stock:
                return Action.C
            return Action.D
        else:
            stock_midpoint = self.capacity / 2.0
            if current_stock < stock_midpoint:
                if observed_defection_rate >= 0.75:
                    return Action.C
                return Action.D
            else:
                if observed_defection_rate > 0.75:
                    return Action.C
                return Action.D

    def _update_defection_rate(self, history: PlayerHistory, current_round: int) -> None:
        """Update observed defection rate from most recent completed round."""
        if current_round == 0:
            return
        prev_round_idx = current_round - 1
        defectors_in_prev_round = self.n_players - np.sum(history.opponent_actions[prev_round_idx, :])
        self.observed_defection_count += defectors_in_prev_round
        self.observed_defection_rounds += self.n_players

    def _get_defection_rate(self) -> float:
        """Return observed defection rate as a fraction."""
        if self.observed_defection_rounds == 0:
            return 0.0
        rate = self.observed_defection_count / float(self.observed_defection_rounds)
        return min(1.0, max(0.0, rate))

class Strategy_EXPLOITATIVE_234(BaseStrategy):
    """
    Adaptive Predation: An exploitative common pool resource strategy that:
    1. Defects on the last round (no future consequences)
    2. Cooperates only when stock falls below safety threshold (self-preservation)
    3. Exploits cooperative opponents by defecting when they cooperate
    4. Aggressively extracts when stock is abundant
    5. Defaults to defection in all other cases
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.safety_threshold = self.capacity * (self.n_players + 1) / (2 * self.n_players)
        self.coop_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.safety_threshold:
            return Action.C
        if history is not None and current_round > 0:
            cooperators_count = np.sum(history.opponent_actions[:current_round, :])
            total_opponent_actions = (self.n_players - 1) * current_round
            if total_opponent_actions > 0:
                observed_coop_rate = cooperators_count / total_opponent_actions
                if observed_coop_rate >= self.coop_threshold:
                    return Action.D
                else:
                    return Action.D
        if current_stock > self.capacity * 0.75:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_235(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Cooperation
    
    Exploits asymmetric payoff structure where defection yields 2x the immediate consumption
    of cooperation. Uses stock-state-dependent logic with opponent defection rate tracking
    to adaptively switch between conditional cooperation (exploiting cooperators) and pure
    defection (matching or preempting aggressive environments).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.collapse_threshold = 2 * self.n_players
        self.high_threshold = self.capacity * 0.6
        self.medium_threshold = self.capacity * 0.35
        self.defection_tolerance = 0.4
        self.exploitation_window = math.floor(self.n_rounds * 0.6)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if stock < self.collapse_threshold:
            return Action.D
        defection_rate = self._calculate_recent_defection_rate(round_num, history)
        if stock >= self.high_threshold:
            if defection_rate > self.defection_tolerance:
                return Action.D
            elif round_num <= self.exploitation_window:
                return Action.C
            else:
                return Action.D
        elif stock >= self.medium_threshold:
            return Action.D
        else:
            return Action.D

    def _calculate_recent_defection_rate(self, round_num: int, history: PlayerHistory) -> float:
        """
        Calculate the defection rate of opponents in the last 3 rounds.
        Returns fraction of D actions (False values) among opponents.
        """
        if round_num == 0:
            return 0.0
        lookback_rounds = min(3, round_num)
        start_idx = round_num - lookback_rounds
        recent_opponent_actions = history.opponent_actions[start_idx:round_num, :]
        defection_count = np.sum(recent_opponent_actions == False)
        total_actions = recent_opponent_actions.size
        if total_actions == 0:
            return 0.0
        defection_rate = defection_count / total_actions
        return defection_rate

class Strategy_EXPLOITATIVE_236(BaseStrategy):
    """
    Adaptive Predation with Sustainability Harvesting.
    
    Exploits cooperative players by dynamically shifting between predatory defection
    and strategic cooperation based on stock depletion rates and round position.
    Treats the commons as a resource to extract maximally while maintaining just
    enough stock to sustain defection payoffs across remaining rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.optimal_defection_threshold = self.capacity * 0.45
        self.critical_depletion_threshold = self.capacity * 0.2
        self.high_stock_threshold = self.capacity * 0.75
        self.bounty_threshold = self.capacity * 0.9
        self.penultimate_threshold = self.capacity * 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == self.n_rounds - 2:
            if current_stock > self.penultimate_threshold:
                return Action.D
            else:
                return Action.C
        if current_stock > self.optimal_defection_threshold:
            return Action.D
        if current_stock > self.critical_depletion_threshold and current_stock <= self.optimal_defection_threshold:
            rounds_until_terminal = self.n_rounds - current_round
            if rounds_until_terminal >= 3:
                return Action.C
            else:
                return Action.D
        if current_stock <= self.critical_depletion_threshold:
            if rounds_remaining > 2:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_237(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Contingent Defection
    
    This strategy preys on cooperators by defecting when stock is abundant,
    then switches to cooperation when stock becomes scarce to minimize collapse.
    Includes temporal adjustments for first/last rounds and collapse detection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        sqrt_r = math.sqrt(self.n_rounds)
        threshold = self.capacity * (1.0 - 1.0 / sqrt_r) if sqrt_r > 0 else self.capacity / 2.0
        if round_num > 0 and history is not None:
            if round_num >= 1:
                prev_payoff_sum = float(np.sum(history.my_payoffs[-1]))
                if current_stock < threshold * 0.4:
                    return Action.D
        if current_stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_238(BaseStrategy):
    """
    Adaptive Predation with Collapse Insurance: Exploits cooperative players while
    monitoring stock health to avoid catastrophic collapse. Uses stock-dependent
    decision thresholds to balance extraction with resource viability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        stock = state.current_stock
        if t == 0:
            return Action.C
        critical_stock = 2 * self.n * 1.5
        recovery_threshold = self.capacity * 0.4
        caution_level = self.capacity * 0.6
        final_rounds_count = max(2, self.r // 4)
        if t == self.r - 1:
            if stock > critical_stock:
                return Action.D
            return Action.C
        if t >= self.r - final_rounds_count:
            if stock > critical_stock:
                return Action.D
            return Action.C
        if stock <= critical_stock:
            return Action.C
        if stock >= recovery_threshold and self.r - t >= 3:
            return Action.D
        estimated_defectors = self._estimate_defectors(history, t)
        if stock <= caution_level and estimated_defectors < self.n / 2:
            return Action.C
        return Action.D

    def _estimate_defectors(self, history: PlayerHistory, current_round: int) -> int:
        """
        Estimate number of defectors based on observed stock depletion.
        More consumption → more defectors likely present.
        """
        if current_round == 0:
            return self.n // 2
        prev_round_idx = current_round - 1
        my_consumption = self._get_my_consumption(history.my_actions[prev_round_idx])
        opponent_consumption = np.sum([self._get_opponent_consumption(history.opponent_actions[prev_round_idx, i]) for i in range(self.n - 1)])
        total_consumption = my_consumption + opponent_consumption
        if total_consumption <= 0:
            return 0
        observed_defectors = np.sum(~history.opponent_actions[prev_round_idx, :])
        return int(observed_defectors)

    def _get_my_consumption(self, action_bool: np.bool_) -> float:
        """
        Get consumption amount based on action.
        True (1) = Cooperate = stock/(2n)
        False (0) = Defect = stock/n
        We don't have exact stock, so use heuristic amounts.
        """
        if action_bool:
            return 1.0 / (2 * self.n)
        return 1.0 / self.n

    def _get_opponent_consumption(self, action_bool: np.bool_) -> float:
        """
        Get consumption amount based on action.
        True (1) = Cooperate = stock/(2n)
        False (0) = Defect = stock/n
        """
        if action_bool:
            return 1.0 / (2 * self.n)
        return 1.0 / self.n

class Strategy_EXPLOITATIVE_239(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Stock Monitoring
    
    Exploits the 2x payoff advantage of defection while maintaining stock viability.
    Uses stock-dependent thresholds that adapt to opponent behavior and round number.
    Always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.r - 1:
            return Action.D
        min_sustainable = 2 * self.n
        if current_stock < min_sustainable:
            return Action.C
        if round_number == self.r - 2:
            safety_threshold = self.capacity * 0.75
        else:
            safety_threshold = self.capacity * (2.0 / 3.0)
            if history is not None and round_number >= 1:
                opponent_defection_rate = self._estimate_opponent_defection_rate(history)
                if opponent_defection_rate > 0.6:
                    safety_threshold = self.capacity * 0.55
                elif opponent_defection_rate < 0.3:
                    safety_threshold = self.capacity * 0.7
        if current_stock > safety_threshold:
            return Action.D
        else:
            return Action.C

    def _estimate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Estimate the aggregate defection rate of opponents across all rounds played.
        Returns value in [0, 1] where 1 = all defections, 0 = all cooperations.
        """
        if history.opponent_actions.shape[0] == 0:
            return 0.0
        total_defections = np.sum(~history.opponent_actions)
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.0
        defection_rate = total_defections / total_actions
        return float(defection_rate)

class Strategy_EXPLOITATIVE_240(BaseStrategy):
    """
    Adaptive Defection with Stock Preservation strategy for Common Pool Resource Game.
    
    Core philosophy: Exploit the asymmetry where defectors extract twice as much as cooperators.
    Defect by default to maximize payoff, but cooperate when stock nears extinction to preserve
    remaining value, and in endgame scenarios adapt based on stock depletion rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.extinction_threshold = game_description.capacity * 0.1
        self.depletion_threshold = 0.25
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.D
        self.stock_history.append(state.current_stock)
        current_stock = state.current_stock
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        rounds_remaining = total_rounds - current_round
        if current_stock <= self.extinction_threshold:
            return Action.C
        if rounds_remaining <= 2:
            return Action.D
        depletion_rate = self._calculate_depletion_rate(current_round)
        if depletion_rate > self.depletion_threshold:
            return Action.D
        return Action.D

    def _calculate_depletion_rate(self, current_round: int) -> float:
        """
        Calculate the recent stock depletion rate.
        Returns the proportion of stock lost in the most recent round.
        Returns 0.0 if insufficient history to calculate.
        """
        if len(self.stock_history) < 2:
            return 0.0
        previous_stock = self.stock_history[-2]
        current_stock = self.stock_history[-1]
        if previous_stock <= 0:
            return 0.0
        depletion_rate = (previous_stock - current_stock) / previous_stock
        return max(0.0, min(1.0, depletion_rate))

class Strategy_EXPLOITATIVE_241(BaseStrategy):
    """
    Adaptive Predation with Recovery Cycling: An exploitative strategy that defects
    when stock is abundant (above 25% capacity threshold) to extract 2x payoffs,
    switches to cooperation when stock drops below threshold to enable recovery,
    and unconditionally defects in the final round. Exploits cooperators, reciprocals,
    and stock-aware strategies by leveraging asymmetric payoffs and stock dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = game_description.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.D
        if state.current_stock < self.critical_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_242(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Core logic: Defect aggressively when stock is abundant (>40% capacity) to maximize
    immediate extraction. Shift to cooperation when stock depletes (<40% capacity) to
    preserve the resource for future exploitation. Always defect on the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity * 0.4
        self.critical_threshold = game_description.capacity * 0.15

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        if current_stock > self.threshold:
            return Action.D
        if current_stock > self.critical_threshold:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_243(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Exploits asymmetry between cooperators and defectors by maximizing extraction
    based on stock health, with adaptive thresholds based on opponent behavior and
    stock velocity. Defects unconditionally in final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        total_rounds = self.n_rounds
        if round_number == total_rounds - 1:
            return Action.D
        if current_stock <= 0:
            return Action.C
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        stock_velocity = 0.0
        opponent_defection_rate = 0.5
        if history is not None and round_number > 0:
            stock_last_round = state.current_stock
            if round_number >= 1:
                total_opponent_actions = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
                if total_opponent_actions > 0:
                    opponent_defections = total_opponent_actions - np.sum(history.opponent_actions)
                    opponent_defection_rate = opponent_defections / total_opponent_actions
            if round_number >= 1:
                stock_velocity = 0.0
        collapse_threshold = -0.1 * self.capacity
        if stock_velocity < collapse_threshold:
            return Action.D
        defection_threshold = 0.5
        if opponent_defection_rate > 0.7:
            defection_threshold = 0.3
        elif opponent_defection_rate < 0.3:
            defection_threshold = 0.6
        if health_ratio > defection_threshold:
            return Action.D
        elif health_ratio <= 0.25:
            if history is not None and round_number >= 1:
                recent_stock_trend = 0.0
                if round_number >= 1:
                    recent_stock_trend = current_stock - 0.0
                if current_stock > self.capacity * 0.15:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_244(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Dynamic Threshold
    
    Balances short-term exploitation through defection with adaptive cooperation
    when stock health deteriorates. Uses dynamic thresholds based on time pressure,
    stock health, and observed opponent defection rates to maximize payoff while
    preventing catastrophic collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.r - 1:
            return Action.D
        rounds_remaining = self.r - current_round
        if rounds_remaining <= 2:
            return Action.D
        if current_stock <= 2 * self.n:
            return Action.C
        time_pressure = current_round / self.r
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        urgency_factor = 1.0 - stock_health
        cooperation_threshold = 0.3 * self.capacity + 0.2 * self.capacity * time_pressure + 0.1 * self.capacity * urgency_factor
        observed_defection_ratio = self._estimate_opponent_defection(history)
        if observed_defection_ratio > 0.6:
            cooperation_threshold *= 0.85
        elif observed_defection_ratio < 0.3:
            cooperation_threshold *= 1.15
        if current_stock < cooperation_threshold:
            return Action.C
        return Action.D

    def _estimate_opponent_defection(self, history: PlayerHistory) -> float:
        """
        Estimate the defection rate of opponents from historical stock depletion.
        
        Compares expected stock levels under all-cooperate vs all-defect scenarios
        to infer actual defection ratio.
        
        Returns: float in [0, 1] representing estimated defection ratio
        """
        if history is None or len(history.my_actions) == 0:
            return 0.5
        my_cooperations = np.sum(history.my_actions)
        my_defections = len(history.my_actions) - my_cooperations
        if len(history.opponent_actions) > 0:
            last_round_opponent_actions = history.opponent_actions[-1, :]
            opponent_cooperations = np.sum(last_round_opponent_actions)
            opponent_defections = self.n - 1 - opponent_cooperations
        else:
            opponent_cooperations = self.n - 1
            opponent_defections = 0
        total_opponents = self.n - 1
        if total_opponents == 0:
            return 0.5
        observed_defection_ratio = opponent_defections / total_opponents
        return min(1.0, max(0.0, observed_defection_ratio))

class Strategy_EXPLOITATIVE_245(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy that prioritizes immediate material gain
    while adapting to opponent behavior patterns. Defects to extract maximum surplus from
    cooperators, matches defectors, and always defects in final round and below critical thresholds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 2 * self.n_players * 1.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == self.n_rounds - 1:
            return Action.D
        if round_num < 2:
            return Action.D
        if stock <= self.critical_threshold:
            return Action.D
        if stock < 0.05 * self.capacity:
            return Action.D
        opponent_coop_rate = self._calculate_opponent_cooperation_rate(history, round_num)
        if opponent_coop_rate > 0.65:
            if random.random() < 0.9:
                return Action.D
            else:
                return Action.C
        if opponent_coop_rate <= 0.35:
            return Action.D
        if round_num >= 2:
            last_two_cooperations = history.opponent_actions[round_num - 1, :].sum() + history.opponent_actions[round_num - 2, :].sum()
            if last_two_cooperations >= self.n_players:
                if random.random() < 0.3:
                    return Action.D
                else:
                    return Action.C
        return Action.D

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate average cooperation rate of opponents across observed rounds.
        OCR = (rounds_opponent_played_C) / (rounds_observed)
        """
        if round_num == 0:
            return 0.5
        total_cooperations = history.opponent_actions[:round_num, :].sum()
        total_observations = round_num * self.n_players
        if total_observations == 0:
            return 0.5
        cooperation_rate = total_cooperations / total_observations
        return cooperation_rate

class Strategy_EXPLOITATIVE_246(BaseStrategy):
    """
    Exploitative Strategy: Dynamic Predation with Adaptive Thresholds
    
    Exploits cooperators early through defection while remaining sensitive to resource 
    depletion. Transitions to conditional cooperation at critical thresholds to avoid 
    mutual collapse, then defects unconditionally in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity * (1.0 / self.n + 0.15)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if stock <= 2:
            return Action.C
        if round_num == self.total_rounds - 1:
            return Action.D
        cooperator_ratio = self._calculate_cooperator_ratio(history, round_num)
        adjusted_threshold = self.critical_threshold
        if self._is_stock_declining(history, round_num):
            adjusted_threshold = self.critical_threshold * 0.8
        if stock > adjusted_threshold:
            return Action.D
        elif cooperator_ratio > 0.3:
            return Action.D
        else:
            return Action.C

    def _calculate_cooperator_ratio(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the ratio of cooperate actions observed in history.
        Cooperate is encoded as True (1), Defect as False (0).
        """
        if round_num == 0:
            return 0.5
        total_observations = history.opponent_actions[:round_num, :].size
        if total_observations == 0:
            return 0.5
        cooperate_count = np.sum(history.opponent_actions[:round_num, :])
        cooperator_ratio = float(cooperate_count) / float(total_observations)
        return cooperator_ratio

    def _is_stock_declining(self, history: PlayerHistory, round_num: int) -> bool:
        """
        Check if stock has been declining over the last 2+ consecutive rounds.
        Returns True if stock decline detected, False otherwise.
        """
        if round_num < 2:
            return False
        if round_num >= 2:
            recent_opponent_defections = np.sum(~history.opponent_actions[round_num - 2:round_num, :])
            recent_total = history.opponent_actions[round_num - 2:round_num, :].size
            if recent_total > 0:
                defection_rate = float(recent_opponent_defections) / float(recent_total)
                if defection_rate > 0.75:
                    return True
        return False

class Strategy_EXPLOITATIVE_247(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Collapse Insurance
    
    Core philosophy: Exploit cooperative opponents ruthlessly while maintaining
    a fallback mechanism to prevent complete pool collapse. Defects aggressively
    in early/middle rounds when stock is healthy, switches to cooperation when
    stock depletes or defection is rampant, and defects unconditionally in the
    final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        opponent_actions = history.opponent_actions
        rounds_played = current_round
        total_opponent_actions = opponent_actions.shape[0] * opponent_actions.shape[1]
        if total_opponent_actions > 0:
            total_cooperations = np.sum(opponent_actions)
            total_defections = total_opponent_actions - total_cooperations
            defection_rate = total_defections / total_opponent_actions
        else:
            defection_rate = 0.0
        if stock_ratio < 0.15 and defection_rate > 0.5:
            return Action.C
        if stock_ratio < 0.25:
            return Action.C
        if defection_rate < 0.4:
            return Action.D
        if defection_rate < 0.6:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_248(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Resource Predation
    
    Extracts maximum personal value by exploiting cooperation asymmetry while adapting
    to prevent complete resource collapse. Defaults to defection unless specific conditions
    warrant temporary cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = self.capacity * 0.75
        self.threshold_low = self.capacity * 0.25
        self.threshold_depletion = self.capacity * 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == self.n_rounds - 1:
            return Action.D
        if stock < self.threshold_depletion:
            return Action.C
        if stock > self.threshold_high:
            return Action.D
        if self.threshold_low <= stock <= self.threshold_high:
            recent_coop_rate = self._compute_recent_cooperation_rate(history)
            recent_def_rate = 1.0 - recent_coop_rate
            if recent_def_rate > 0.7:
                return Action.C
            if recent_coop_rate > 0.5:
                exploit_prob = min(0.4, recent_coop_rate * 0.6)
                if random.random() < exploit_prob:
                    return Action.C
                else:
                    return Action.D
            return Action.D
        return Action.D

    def _compute_recent_cooperation_rate(self, history: None | PlayerHistory) -> float:
        """
        Compute the recent cooperation rate of opponents (last 3 rounds or all prior rounds).
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        window = min(3, len(history.opponent_actions))
        recent_actions = history.opponent_actions[-window:, :]
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        cooperations = np.sum(recent_actions)
        return float(cooperations) / float(total_actions)

class Strategy_EXPLOITATIVE_249(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State-Aware Defection
    
    Exploits asymmetry between C and D payoffs while remaining sensitive to stock depletion.
    Defects aggressively when stock permits, pivots to exploitation of cooperative opponents,
    and cooperates only when forced by resource collapse or declining trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_safe = game_description.capacity * 0.6
        self.threshold_critical = game_description.capacity * 0.2
        self.stock_decline_counter = 0
        self.previous_stock = game_description.capacity
        self.forced_cooperation_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if round_num == 0:
            return Action.D
        if round_num == r - 1:
            return Action.D
        if current_stock < 0.5:
            self.forced_cooperation_rounds = 2
            return Action.C
        if self.forced_cooperation_rounds > 0:
            self.forced_cooperation_rounds -= 1
            return Action.C
        if round_num >= 2:
            stock_decline = (current_stock - self.previous_stock) / max(self.previous_stock, 0.001)
            if stock_decline < -0.15:
                self.stock_decline_counter += 1
            else:
                self.stock_decline_counter = 0
            if self.stock_decline_counter >= 2:
                self.stock_decline_counter = 0
                self.forced_cooperation_rounds = 1
                self.previous_stock = current_stock
                return Action.C
        self.previous_stock = current_stock
        if current_stock > self.threshold_safe:
            return Action.D
        elif current_stock > self.threshold_critical:
            recent_coop_rate = self._calculate_recent_cooperation_rate(history, round_num)
            if recent_coop_rate >= 0.66:
                return Action.D
            elif recent_coop_rate <= 0.33:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

    def _calculate_recent_cooperation_rate(self, history: PlayerHistory, round_num: int) -> float:
        """Calculate cooperation rate of opponents in the last 3 rounds."""
        lookback_start = max(0, round_num - 3)
        lookback_rounds = round_num - lookback_start
        if lookback_rounds <= 0:
            return 0.0
        total_cooperations = 0
        total_observations = 0
        for i in range(lookback_start, round_num):
            for opponent_idx in range(self.game_description.n_players - 1):
                if history.opponent_actions[i, opponent_idx]:
                    total_cooperations += 1
                total_observations += 1
        if total_observations == 0:
            return 0.0
        return total_cooperations / total_observations

class Strategy_EXPLOITATIVE_250(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Collapse Prevention
    
    Defects aggressively to maximize extraction when stock is healthy.
    Cooperates strategically when stock is critically low to prevent collapse.
    Always defects in the final round to maximize last-round extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        collapse_threshold = 2 * self.n_players * 0.5
        if self.n_players < 10:
            danger_threshold = 2 * self.n_players * (1 + 0.5 / self.n_players)
        else:
            danger_threshold = 2 * self.n_players * 1.2
        if round_num == self.n_rounds - 1:
            if stock > 0:
                return Action.D
            else:
                return Action.C
        if stock < collapse_threshold:
            return Action.C
        if stock <= danger_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_251(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Stock Monitoring
    
    Exploits asymmetry between cooperative (S/2n) and defective (S/n) payoffs.
    Uses stock thresholds to balance exploitation with long-term sustainability.
    Defects aggressively when stock is healthy, cooperates when forced to recover,
    and defects unconditionally in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.safe_threshold = self.capacity * 0.55
        self.critical_threshold = self.capacity * 0.25
        self.emergency_threshold = self.capacity * 0.1
        self.prev_stock = self.capacity
        self.smoothed_stock = self.capacity
        self.emergency_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == 0:
            self.prev_stock = current_stock
            self.smoothed_stock = current_stock
            return Action.D
        self.smoothed_stock = 0.7 * current_stock + 0.3 * self.smoothed_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.emergency_threshold:
            self.emergency_rounds_remaining = max(2, self.emergency_rounds_remaining - 1)
            if self.emergency_rounds_remaining > 0:
                return Action.C
            self.emergency_rounds_remaining = 3
            return Action.C
        if self.smoothed_stock > self.safe_threshold:
            self.prev_stock = current_stock
            return Action.D
        elif self.smoothed_stock > self.critical_threshold:
            self.prev_stock = current_stock
            return Action.C
        else:
            self.prev_stock = current_stock
            return Action.C

class Strategy_EXPLOITATIVE_252(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State-Based Thresholds
    
    This strategy treats cooperation as a tool for resource accumulation, not a moral commitment.
    It exploits cooperative opponents, adapts to defectors, and maximizes absolute payoff regardless
    of fairness. Cooperation is only strategic when the arithmetic demands it (late game with depleted
    stock and many cooperators). Always defects on the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == self.n_rounds - 1:
            return Action.D
        if round_num == 0:
            return Action.D
        cooperators_ratio = self._calculate_cooperators_ratio(history, round_num)
        if stock > 1.5 * self.capacity:
            return Action.D
        elif stock > 0.75 * self.capacity:
            return Action.D
        elif stock > 0.4 * self.capacity:
            if round_num <= self.n_rounds / 2.0:
                return Action.D
            elif cooperators_ratio > 0.6:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def _calculate_cooperators_ratio(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the ratio of cooperators in the last 3 rounds.
        Uses all available history if fewer than 3 rounds have elapsed.
        """
        if round_num == 0:
            return 0.0
        window_size = min(3, round_num)
        start_idx = round_num - window_size
        recent_actions = history.opponent_actions[start_idx:round_num, :]
        cooperate_count = np.sum(recent_actions)
        total_actions = window_size * (self.n_players - 1)
        if total_actions == 0:
            return 0.0
        cooperators_ratio = cooperate_count / total_actions
        return cooperators_ratio

class Strategy_EXPLOITATIVE_253(BaseStrategy):
    """
    Exploitative strategy with adaptive stock monitoring.
    
    Core approach: Default to defection to maximize immediate payoff.
    Adaptively cooperate only when stock is depleted and opponents are mostly defecting,
    to preserve the commons for future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.sustainable_threshold = self.capacity * 0.5
        self.collapse_threshold = self.capacity * 0.1
        self.cooperation_threshold = 0.6
        self.pure_cooperator_threshold = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1 or current_round == self.n_rounds - 2:
            return Action.D
        recent_coop_rate = self._get_recent_cooperation_rate(history, current_round)
        if current_stock > self.sustainable_threshold:
            return Action.D
        elif current_stock > self.collapse_threshold:
            if recent_coop_rate > self.cooperation_threshold:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _get_recent_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the cooperation rate among all opponents over the last 3 rounds.
        Returns a value in [0.0, 1.0].
        """
        if current_round == 0:
            return 0.0
        window_size = min(3, current_round)
        start_round = current_round - window_size
        opponent_actions_window = history.opponent_actions[start_round:current_round, :]
        total_actions = opponent_actions_window.size
        if total_actions == 0:
            return 0.0
        total_cooperations = np.sum(opponent_actions_window)
        cooperation_rate = float(total_cooperations) / float(total_actions)
        return cooperation_rate

class Strategy_EXPLOITATIVE_254(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Conditional Cooperation
    
    Exploits asymmetric payoffs (D yields 2x consumption of C) while remaining
    sensitive to stock depletion. Uses stock-dependent thresholds to decide between
    aggressive defection and tactical cooperation for resource preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.high_threshold = 0.6 * game_description.capacity
        self.medium_threshold = 0.3 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_number = state.round_number
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        if stock <= 0:
            return Action.C
        if stock > self.high_threshold:
            return Action.D
        if stock > self.medium_threshold:
            if round_number == 0:
                return Action.D
            prev_round_cooperators = sum(history.opponent_actions[round_number - 1, :])
            prev_round_defectors = n - prev_round_cooperators
            return Action.D
        coop_prob = min(0.7, stock / capacity)
        if random.random() < coop_prob:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_255(BaseStrategy):
    """
    Adaptive Depletion Strategy: Always Defect
    
    This strategy exploits the asymmetry between cooperative and defective payoffs
    in a Common Pool Resource game. The core principle is to always defect, maximizing
    early extraction before inevitable resource depletion, regardless of opponent behavior
    or stock levels.
    
    Key insights:
    - Defection always yields 2× the payoff of cooperation at identical stock levels (S/n vs S/2n)
    - In finite repeated games, stock inevitably depletes with defection, so extract early
    - Unconditional defection cannot be exploited by reputation or reciprocity strategies
    - First-mover advantage: defecting in round 1 establishes dominance and locks in extraction
    """

    def __init__(self, game_description: CommonPoolDescription):
        """Initialize the strategy with game parameters."""
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decision function: Always defect regardless of round, stock level, or opponent behavior.
        
        Args:
            state: Current game state (round number and stock level)
            history: Historical actions and payoffs (None in first round)
        
        Returns:
            Action.D (defect) unconditionally
        """
        return Action.D

class Strategy_EXPLOITATIVE_256(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Dynamic Threshold Harvesting
    
    Exploits asymmetry between cooperative and defective payoffs while adapting to
    stock levels and endgame conditions. Defects aggressively when stock is healthy,
    cooperates only when critical thresholds are breached or collapse is imminent.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.depletion_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        rounds_remaining = self.n_rounds - round_num
        if round_num == 0:
            return Action.D
        if rounds_remaining <= 2:
            return Action.D
        if stock < 2 * self.n_players and rounds_remaining > 1:
            return Action.C
        if stock > 1.5 * self.capacity / 2:
            return Action.D
        if stock > self.capacity / 3:
            return Action.D
        if stock <= self.capacity / 3:
            return Action.C
        if history is not None and round_num >= 2:
            depletion_rate = self._calculate_depletion_rate(history, round_num)
            self.depletion_history.append(depletion_rate)
            if len(self.depletion_history) >= 2:
                recent_rates = self.depletion_history[-2:]
                if all((rate > 0.5 for rate in recent_rates)):
                    return Action.D
            if len(self.depletion_history) >= 2:
                if recent_rates[0] > 0.3 and recent_rates[1] < 0.3:
                    return Action.D
                if recent_rates[0] < 0.3 and recent_rates[1] > 0.3:
                    return Action.D
        return Action.D

    def _calculate_depletion_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate stock depletion rate from previous round.
        depletion_rate = (stock_prev - stock_curr + growth_prev) / stock_prev
        
        Approximated as: (consumption_prev) / stock_prev
        """
        if round_num < 1:
            return 0.0
        prev_round_idx = round_num - 1
        stock_prev = history.opponent_payoffs[prev_round_idx, 0] * self.n_players
        try:
            total_prev_payoff = history.my_payoffs[prev_round_idx] + np.sum(history.opponent_payoffs[prev_round_idx, :])
            if total_prev_payoff > 0:
                depletion = total_prev_payoff / (self.capacity + 1e-06)
                return min(depletion, 1.0)
        except (IndexError, ValueError):
            return 0.0
        return 0.0

class Strategy_EXPLOITATIVE_257(BaseStrategy):
    """
    Exploitative strategy with adaptive predation and resource monitoring.
    
    Core philosophy: Defect by default to maximize payoff (S/n vs S/2n).
    Cooperate only when necessary to prevent resource collapse or in specific
    defensive scenarios. Always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_stock = game_description.capacity
        self.consecutive_cooperation_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock = state.current_stock
        round_num = state.round_number
        if round_num == r - 1:
            return Action.D
        if round_num == 0:
            self.previous_stock = capacity
            self.consecutive_cooperation_rounds = 0
            return Action.D
        if stock < 2 * n:
            self.consecutive_cooperation_rounds += 1
            if self.consecutive_cooperation_rounds <= 3:
                return Action.C
            else:
                self.consecutive_cooperation_rounds = 0
                return Action.D
        if stock > 3 * n and self.consecutive_cooperation_rounds >= 1:
            self.consecutive_cooperation_rounds = 0
            return Action.D
        if self.previous_stock > 0:
            stock_growth_rate = (stock - self.previous_stock) / self.previous_stock
        else:
            stock_growth_rate = 0.0
        if stock_growth_rate < -0.1:
            self.consecutive_cooperation_rounds += 1
            self.previous_stock = stock
            return Action.C
        self.consecutive_cooperation_rounds = 0
        self.previous_stock = stock
        return Action.D

class Strategy_EXPLOITATIVE_258(BaseStrategy):
    """
    Adaptive Predatory Extraction (APE) Strategy
    
    Exploitative strategy that treats the common pool as a resource to maximize personal gain.
    Uses stock-dependent thresholds and opponent behavior exploitation to determine when to defect.
    Always defects in endgame, high stock, and low stock scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num >= self.n_rounds - 3:
            return Action.D
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio > 0.75:
            return Action.D
        if stock_ratio > 0.4:
            if round_num == 0:
                return Action.D
            cooperators_last_round = int(np.sum(history.opponent_actions[round_num - 1, :]))
            coop_rate = cooperators_last_round / self.n_players if self.n_players > 0 else 0.0
            return Action.D
        if stock_ratio > 0.15:
            if round_num >= 1:
                stock_change = history.my_payoffs[round_num - 1] if round_num > 0 else 0.0
                if round_num >= 2:
                    prev_stock_estimate = stock + history.my_payoffs[round_num - 1]
                    stock_decline = prev_stock_estimate - stock
                    if stock_decline > 0.15 * self.capacity:
                        return Action.D
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_259(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Contingent Cooperation
    
    Defects by default while maintaining adaptive cooperation triggers based on:
    1. First round information gathering
    2. Stock depletion survival mode
    3. Final round unconditional defection
    4. Opponent behavior analysis
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == self.n_rounds - 1:
            return Action.D
        if round_number == 0:
            return Action.C
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0
        rounds_remaining = self.n_rounds - round_number
        if current_stock < 2 * self.n_players:
            return Action.C
        if current_stock >= self.capacity * 0.99:
            return Action.D
        if stock_ratio < 0.25 and rounds_remaining > 2:
            cooperation_probability = rounds_remaining / self.n_rounds
            if random.random() < cooperation_probability:
                return Action.C
            else:
                return Action.D
        if history is not None and len(history.opponent_actions) > 0:
            total_opponent_actions = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
            total_cooperations = np.sum(history.opponent_actions)
            opponent_coop_rate = total_cooperations / total_opponent_actions if total_opponent_actions > 0 else 0.5
        else:
            opponent_coop_rate = 0.5
        if opponent_coop_rate > 0.75:
            return Action.D
        elif opponent_coop_rate > 0.6:
            return Action.D
        else:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_260(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Dynamic Thresholds
    
    Prioritizes defection to maximize personal gain while using dynamic stock-aware
    thresholds to avoid complete resource collapse. Cooperates only when necessary
    to preserve the commons for future exploitation rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.D
        if round_number == self.n_rounds - 1:
            if current_stock > 0:
                return Action.D
            else:
                return Action.C
        rounds_remaining = self.n_rounds - round_number
        threshold = self.capacity * (0.25 + 0.15 * rounds_remaining / self.n_rounds)
        if current_stock < 2 * self.n_players and rounds_remaining > 2:
            return Action.C
        if current_stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_261(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy: Dynamic exploitation with depletion awareness.
    
    Core approach:
    - Round 0 & final rounds: DEFECT for maximum immediate payoff
    - Mid-game: Adaptively defect when stock is high and opponents cooperate,
      cooperate when stock is low to enable recovery for future exploitation
    - Track opponent defection rates to identify hostile vs. exploitable environments
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            if current_stock > self.capacity * 0.05:
                return Action.D
            else:
                return Action.C
        if current_round == self.n_rounds - 2:
            if current_stock > self.capacity * 0.05:
                return Action.D
            else:
                return Action.C
        remaining_rounds = self.n_rounds - current_round
        remaining_rounds_ratio = remaining_rounds / self.n_rounds if self.n_rounds > 0 else 1.0
        threshold = self.capacity * (0.4 + 0.1 * remaining_rounds_ratio)
        recent_defection_rate = self._calculate_opponent_defection_rate(history, current_round)
        if current_stock > threshold and recent_defection_rate < 0.3:
            return Action.D
        elif current_stock > threshold and recent_defection_rate >= 0.3:
            return Action.D
        elif self._can_stock_recover(current_stock, remaining_rounds):
            return Action.C
        else:
            return Action.D

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the defection rate of opponents over the last min(3, rounds_played) rounds.
        Returns fraction of observed opponent actions that were defection (False).
        """
        if current_round == 0:
            return 0.0
        lookback = min(3, current_round)
        start_idx = max(0, current_round - lookback)
        recent_actions = history.opponent_actions[start_idx:current_round, :]
        if recent_actions.size == 0:
            return 0.0
        defection_count = np.sum(~recent_actions)
        total_count = recent_actions.size
        if total_count == 0:
            return 0.0
        return float(defection_count) / float(total_count)

    def _can_stock_recover(self, current_stock: float, remaining_rounds: int) -> bool:
        """
        Assess whether the stock can recover to a meaningful level with cooperation.
        
        Stock dynamics: new_stock = min(stock_after_consumption + growth, capacity)
        where growth = 2 × stock_remaining × (1 - stock_remaining/capacity)
        
        With full cooperation: each player consumes stock/(2n), total = stock/2
        So stock_remaining = stock/2
        growth = 2 × (stock/2) × (1 - (stock/2)/capacity) = stock × (1 - stock/(2×capacity))
        
        A rough heuristic: if stock is very low and rounds are few, recovery is unlikely.
        """
        if remaining_rounds < 1 or self.capacity == 0:
            return False
        if current_stock < self.capacity * 0.05:
            return False
        stock_remaining = current_stock / 2.0
        if stock_remaining <= 0 or self.capacity <= 0:
            return False
        growth_potential = 2 * stock_remaining * (1 - stock_remaining / self.capacity)
        return growth_potential > 0 and remaining_rounds >= 2

class Strategy_EXPLOITATIVE_262(BaseStrategy):
    """
    Adaptive Predation: An exploitative common pool resource strategy that maximizes
    defection payoffs while strategically preserving resources when necessary, and
    becoming increasingly aggressive in late-game rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number >= self.n_rounds - 1:
            return Action.D
        if history is None:
            if current_stock >= self.capacity * 0.95:
                return Action.D
            return Action.D
        opponent_defection_rate = self._calculate_opponent_defection_rate(history)
        if round_number >= self.n_rounds - 2:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0
        if stock_ratio > 0.6:
            base_action = Action.D
        elif stock_ratio >= 0.25:
            base_action = Action.C
        else:
            base_action = Action.D
        if stock_ratio > 0.4:
            if opponent_defection_rate < 0.3:
                return Action.D
        if opponent_defection_rate > 0.5:
            return Action.D
        return base_action

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the observed defection rate of opponents across all past rounds.
        Returns a value in [0, 1] where 1 means all opponent actions were defections.
        """
        if len(history.opponent_actions) == 0:
            return 0.5
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.5
        defection_count = np.sum(~history.opponent_actions)
        defection_rate = float(defection_count) / float(total_actions)
        return defection_rate

class Strategy_EXPLOITATIVE_263(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State-Based Threshold Switching
    
    Core mechanics:
    - Defect when stock is above a dynamic threshold to exploit cooperators
    - Cooperate when stock is below threshold to allow recovery
    - Always defect in final round (no future payoff)
    - Threshold increases as rounds remaining decrease (more aggressive late game)
    - Recover cooperatively if stock approaches collapse
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        rounds_remaining = self.n_rounds - round_num
        if round_num == self.n_rounds - 1:
            return Action.D
        collapse_threshold = 2 * self.n_players
        if current_stock < collapse_threshold:
            return Action.C
        base_threshold = self.capacity * (0.5 + 0.3 * rounds_remaining / self.n_rounds)
        if rounds_remaining <= 2:
            threshold = self.capacity * 0.8
        else:
            threshold = base_threshold
        if current_stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_264(BaseStrategy):
    """
    Adaptive Predatory Harvesting (APH): An exploitative strategy that maximizes
    immediate payoffs through ruthless defection, with conditional cooperation only
    when necessary to maintain harvestable stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if current_round == 0:
            return Action.D
        if rounds_remaining <= 2:
            return Action.D
        if stock_ratio < 0.15:
            return Action.D
        observed_defections_count = 0
        observed_actions_count = 0
        if history is not None and current_round > 0:
            for round_idx in range(current_round):
                for opponent_idx in range(self.n_players - 1):
                    opponent_action = history.opponent_actions[round_idx, opponent_idx]
                    if not opponent_action:
                        observed_defections_count += 1
                    observed_actions_count += 1
        defection_rate = observed_defections_count / observed_actions_count if observed_actions_count > 0 else 0.0
        if defection_rate > 0.3:
            return Action.D
        if current_round <= 3:
            return Action.D
        if stock_ratio < 0.4:
            return Action.D
        if stock_ratio < 0.75:
            if rounds_remaining < self.n_players:
                return Action.D
            if observed_defections_count > 0:
                return Action.D
            return Action.C
        if stock_ratio >= 0.75:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_265(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Sustainability Farming
    
    Exploits cooperative players ruthlessly while maintaining stock health to enable
    future exploitation. Defects aggressively when profitable, but prevents resource
    collapse that would end the exploitation game prematurely.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.D
        if round_number == self.n_rounds - 1:
            return Action.D
        critical_threshold = self.capacity * 0.15
        recovery_threshold = self.capacity * 0.35
        if current_stock <= critical_threshold:
            return Action.C
        if current_stock <= recovery_threshold:
            if random.random() < 0.6:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_266(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Stock Monitoring
    
    Monitors stock health to time defection optimally. Defects when stock is abundant
    (above 70% capacity) or degraded but still profitable (above 30%), and cooperates
    only when stock is critically low (≤ 30%). Adapts thresholds based on observed
    opponent defection rates to exploit cooperators while avoiding self-destruction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.D
        base_threshold_high = 0.7 * self.capacity
        base_threshold_low = 0.3 * self.capacity
        if round_number > 0 and history is not None:
            opponent_defection_rate = self._calculate_opponent_defection_rate(history)
            if opponent_defection_rate > 0.75:
                base_threshold_high = 0.6 * self.capacity
                base_threshold_low = 0.25 * self.capacity
            elif opponent_defection_rate < 0.25:
                base_threshold_high = 0.75 * self.capacity
                base_threshold_low = 0.35 * self.capacity
        if round_number == self.n_rounds - 1:
            if current_stock > 0.3 * self.capacity:
                return Action.D
            else:
                return Action.C
        if current_stock > base_threshold_high:
            return Action.D
        elif current_stock > base_threshold_low:
            return Action.D
        else:
            return Action.C

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the defection rate among all opponents across all observed rounds.
        Returns a value between 0 and 1, where 0 = all cooperating, 1 = all defecting.
        """
        if history.opponent_actions.size == 0:
            return 0.5
        total_defections = np.sum(~history.opponent_actions)
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.5
        defection_rate = float(total_defections) / float(total_actions)
        return defection_rate

class Strategy_EXPLOITATIVE_267(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Extraction with Dynamic Threshold
    
    Prioritizes immediate extraction over long-term sustainability. Defects to exploit
    cooperators, adapts to defector-dominant environments, and uses observable history
    to identify exploitation opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity * 0.15
        self.sustainable_threshold = self.capacity * 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if stock < self.critical_threshold:
            return Action.D
        history_window = max(0, current_round - 5)
        recent_rounds = history.opponent_actions[history_window:current_round]
        if recent_rounds.shape[0] > 0:
            defection_count = np.sum(~recent_rounds)
            total_actions = recent_rounds.shape[0] * self.n_players
            defection_ratio = defection_count / total_actions if total_actions > 0 else 0
        else:
            defection_ratio = 0
        stock_trend = self._calculate_stock_trend(history, current_round)
        if stock > self.sustainable_threshold:
            if defection_ratio < 0.4:
                return Action.D
            elif defection_ratio >= 0.6:
                return Action.C
            elif stock_trend == 'increasing':
                return Action.D
            else:
                return Action.C
        elif defection_ratio >= 0.5:
            return Action.C
        else:
            return Action.D

    def _calculate_stock_trend(self, history: PlayerHistory, current_round: int) -> str:
        """
        Determine stock trend from history.
        Returns: "increasing", "decreasing", or "stable"
        """
        if current_round < 2:
            return 'stable'
        recent_payoffs = history.my_payoffs[max(0, current_round - 3):current_round]
        if len(recent_payoffs) < 2:
            return 'stable'
        recent_changes = np.diff(recent_payoffs)
        avg_change = np.mean(recent_changes)
        if avg_change > 0.01:
            return 'increasing'
        elif avg_change < -0.01:
            return 'decreasing'
        else:
            return 'stable'

class Strategy_EXPLOITATIVE_268(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Exploits asymmetry between cooperative and defective payoffs by:
    1. Defaulting to defection to maximize extraction
    2. Selectively cooperating when cooperators are detected and pool is healthy
    3. Always defecting in final 2 rounds and when pool is depleted
    4. Using historical consumption patterns to detect cooperator presence
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock = state.current_stock
        if round_t == 0:
            return Action.D
        if round_t >= self.n_rounds - 2:
            return Action.D
        if stock < 0.6 * self.capacity:
            return Action.D
        cooperator_rounds = 0
        lookback_rounds = min(3, round_t)
        for i in range(round_t - lookback_rounds, round_t):
            if i < 0:
                continue
            total_consumption_i = 0.0
            my_action_i = history.my_actions[i]
            stock_at_round_i = self._reconstruct_stock_at_round(history, i)
            if stock_at_round_i > 0:
                my_consumption_i = stock_at_round_i / (2 * self.n_players) if my_action_i else stock_at_round_i / self.n_players
                total_consumption_i += my_consumption_i
            for j in range(self.n_players - 1):
                opponent_action_j = history.opponent_actions[i, j]
                if stock_at_round_i > 0:
                    opponent_consumption_j = stock_at_round_i / (2 * self.n_players) if opponent_action_j else stock_at_round_i / self.n_players
                    total_consumption_i += opponent_consumption_j
            avg_consumption_i = total_consumption_i / self.n_players if self.n_players > 0 else 0
            threshold = 1.5 * (stock_at_round_i / self.n_players) if stock_at_round_i > 0 else 0
            if avg_consumption_i < threshold:
                cooperator_rounds += 1
        if cooperator_rounds < 2:
            return Action.D
        stock_growing = False
        if round_t >= 2:
            for i in range(max(0, round_t - 2), round_t):
                if i > 0:
                    stock_prev = self._reconstruct_stock_at_round(history, i - 1)
                    stock_curr = self._reconstruct_stock_at_round(history, i)
                    if stock_curr > stock_prev:
                        stock_growing = True
                        break
        else:
            stock_at_1 = self._reconstruct_stock_at_round(history, 0)
            if stock_at_1 > self.capacity:
                stock_growing = True
        if stock_growing and stock >= 0.6 * self.capacity:
            return Action.C
        return Action.D

    def _reconstruct_stock_at_round(self, history: PlayerHistory, round_idx: int) -> float:
        """
        Reconstruct the stock level at the beginning of round_idx.
        This approximates the stock by working backward from payoffs and actions.
        """
        if round_idx < 0:
            return self.capacity
        if round_idx == 0:
            return self.capacity
        stock_estimate = self.capacity
        for t in range(round_idx):
            cooperators = sum(history.opponent_actions[t, :])
            if history.my_actions[t]:
                cooperators += 1
            defectors = self.n_players - cooperators
            if stock_estimate > 0:
                total_consumption = cooperators * (stock_estimate / (2 * self.n_players)) + defectors * (stock_estimate / self.n_players)
                stock_remaining = max(0, stock_estimate - total_consumption)
                growth = 2 * stock_remaining * (1 - stock_remaining / self.capacity) if self.capacity > 0 else 0
                stock_estimate = min(stock_remaining + growth, self.capacity)
            else:
                stock_estimate = 0
        return stock_estimate

class Strategy_EXPLOITATIVE_269(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Stock Collapse Management
    
    Exploits the asymmetry between cooperative and defective payoffs while managing
    the common pool to avoid catastrophic collapse. Defects when stock is healthy,
    cooperates when stock is critically low, and predatorily targets cooperative opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        threshold_high = 1.5 * self.capacity
        threshold_low = self.capacity / (4.0 * self.n)
        if round_num == 0:
            return Action.D
        if round_num == self.r - 1:
            return Action.D
        opponent_actions_last_round = history.opponent_actions[round_num - 1, :]
        defectors_last_round = np.sum(~opponent_actions_last_round)
        majority_defected = defectors_last_round > self.n / 2.0
        if stock <= threshold_low:
            return Action.C
        if stock > threshold_high:
            return Action.D
        if majority_defected:
            growth_optimum = self.capacity / 2.0
            if stock > growth_optimum:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_270(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Threshold Management
    
    Treats cooperation as a resource to exploit. Defects by default while selectively
    cooperating to appear as a conditional cooperator and to prevent stock collapse
    when it threatens payoffs. Adapts based on observed cooperation rates and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        depletion_threshold = 1.2 * self.capacity / (2 * self.n)
        if stock <= depletion_threshold and round_num < self.n_rounds - 1:
            return Action.C
        if stock >= 0.95 * self.capacity:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if stock == 0:
            return Action.C
        previous_round_idx = round_num - 1
        opponent_actions_prev = history.opponent_actions[previous_round_idx, :]
        coop_count = int(np.sum(opponent_actions_prev))
        coop_rate = coop_count / self.n if self.n > 0 else 0
        threshold = 0.5
        if round_num <= 2:
            threshold = 0.65
        if coop_rate >= threshold:
            if coop_rate > 0:
                p_exploit = min(0.3, (coop_rate - 0.5) / coop_rate)
            else:
                p_exploit = 0.0
            if random.random() < p_exploit:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_271(BaseStrategy):
    """
    Exploitative Adaptive Predation Strategy for Common Pool Resource Game.
    
    Core approach: Identify and relentlessly exploit cooperative players while
    adapting to reciprocators through alternating patterns and defection cycles.
    Maximizes extraction at every opportunity using stock levels and opponent
    classification as primary decision drivers.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        rounds_remaining = self.n_rounds - round_num - 1
        if round_num == 0:
            return Action.D
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0
        if stock_ratio < 0.3:
            return Action.D
        if rounds_remaining <= 2:
            return Action.D
        opponent_type = self._classify_opponent(history, round_num)
        if opponent_type == 'PURE_COOPERATOR':
            return Action.D
        if opponent_type == 'AGGRESSIVE_DEFECTOR':
            return Action.D
        if opponent_type == 'TIT_FOR_TAT':
            my_last_action = history.my_actions[-1]
            opponent_last_action = history.opponent_actions[-1, 0]
            if not my_last_action and (not opponent_last_action):
                return Action.C
            return Action.D
        if opponent_type == 'MIXED':
            exploitation_success = self._calculate_exploitation_success(history, round_num)
            if exploitation_success > 0.6:
                return Action.D
            else:
                return Action.C
        if stock_ratio >= 0.7:
            return Action.D
        if stock_ratio >= 0.5:
            exploitation_success = self._calculate_exploitation_success(history, round_num)
            if exploitation_success > 0.6:
                return Action.D
            else:
                return Action.C
        return Action.C

    def _classify_opponent(self, history: PlayerHistory, current_round: int) -> str:
        """
        Classify primary opponent behavior based on action history.
        Returns: PURE_COOPERATOR, AGGRESSIVE_DEFECTOR, TIT_FOR_TAT, MIXED
        """
        if current_round == 0:
            return 'MIXED'
        opponent_actions = history.opponent_actions[:current_round + 1, 0]
        my_actions = history.my_actions[:current_round + 1]
        opponent_cooperations = int(np.sum(opponent_actions))
        opponent_defections = len(opponent_actions) - opponent_cooperations
        if opponent_defections == 0:
            return 'PURE_COOPERATOR'
        if opponent_cooperations == 0:
            return 'AGGRESSIVE_DEFECTOR'
        is_tit_for_tat = True
        for i in range(1, len(my_actions)):
            if opponent_actions[i] != my_actions[i - 1]:
                is_tit_for_tat = False
                break
        if is_tit_for_tat:
            return 'TIT_FOR_TAT'
        return 'MIXED'

    def _calculate_exploitation_success(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate success ratio of recent defections.
        Higher ratio = defections paid off better than cooperations.
        """
        if current_round < 2:
            return 0.5
        lookback = min(3, current_round + 1)
        recent_my_actions = history.my_actions[-lookback:]
        recent_my_payoffs = history.my_payoffs[-lookback:]
        if len(recent_my_actions) == 0:
            return 0.5
        defection_rounds = recent_my_actions == False
        cooperation_rounds = recent_my_actions == True
        defection_count = int(np.sum(defection_rounds))
        cooperation_count = int(np.sum(cooperation_rounds))
        if defection_count == 0:
            return 0.3
        if cooperation_count == 0:
            return 0.8
        avg_defection_payoff = np.mean(recent_my_payoffs[defection_rounds])
        avg_cooperation_payoff = np.mean(recent_my_payoffs[cooperation_rounds])
        if avg_cooperation_payoff == 0:
            return 0.9 if avg_defection_payoff > 0 else 0.5
        success_ratio = avg_defection_payoff / avg_cooperation_payoff
        return min(1.0, max(0.0, success_ratio))

class Strategy_EXPLOITATIVE_272(BaseStrategy):
    """
    Exploitative Strategy for Common Pool Resource Game.
    
    Uses stock-dependent extraction with a threshold mechanism:
    - High stock (above threshold): Defect to maximize immediate payoff
    - Low stock (at or below threshold): Cooperate to preserve the pool
    - Final round: Always defect (no future rounds to preserve for)
    
    Threshold = capacity × (1 - 1/total_rounds)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        if self.n_rounds > 1:
            self.threshold = self.capacity * (1.0 - 1.0 / self.n_rounds)
        else:
            self.threshold = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock > self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_273(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Dynamic Threshold Exploitation
    
    Defects aggressively in early/mid game to exploit the asymmetry between cooperative
    and defective payoffs. Monitors stock health and transitions to salvage mode only
    when collapse is imminent or in terminal rounds with recovery possibility exhausted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number
        if rounds_remaining == 1:
            return Action.D
        if round_number == 0:
            return Action.D
        if current_stock > 0.6 * self.capacity:
            return Action.D
        if current_stock < 2 * self.n_players:
            return Action.C
        if current_stock > 0.3 * self.capacity:
            if self._is_stock_declining_sharply(history):
                if rounds_remaining <= 2:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D
        if current_stock <= 0.3 * self.capacity:
            if self._can_recover_to_capacity(current_stock, rounds_remaining):
                return Action.D
            else:
                return Action.C
        return Action.D

    def _is_stock_declining_sharply(self, history: PlayerHistory) -> bool:
        """
        Check if stock is declining sharply (loss > 15% of capacity in recent rounds).
        Returns True if declining trend detected.
        """
        if len(history.my_payoffs) < 2:
            return False
        recent_payoffs = history.my_payoffs[-2:]
        payoff_decline = recent_payoffs[0] - recent_payoffs[1]
        decline_threshold = 0.15 * self.capacity / (2 * self.n_players)
        if payoff_decline > decline_threshold:
            return True
        return False

    def _can_recover_to_capacity(self, current_stock: float, rounds_remaining: int) -> bool:
        """
        Estimate if stock can recover to capacity within remaining rounds.
        Uses logistic growth model: growth = 2 * S * (1 - S / capacity)
        
        Conservative heuristic: if stock is at least 25% of capacity and we have
        2+ rounds, assume recovery is possible with some cooperation.
        """
        if rounds_remaining <= 0:
            return False
        if current_stock < 0.25 * self.capacity:
            return False
        if rounds_remaining >= 2:
            return True
        return False

class Strategy_EXPLOITATIVE_274(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State Collapse
    
    Core approach: Always defect to maximize extraction relative to cooperators.
    Defection yields stock/n per round vs stock/2n for cooperation (2x advantage).
    In a commons without enforcement, aggressive extraction before collapse dominates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        rounds_remaining = self.n_rounds - state.round_number
        stock = state.current_stock
        return Action.D

class Strategy_EXPLOITATIVE_275(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Extraction with Resource Monitoring.
    
    Maximizes personal extraction while opportunistically exploiting cooperative opponents.
    Uses stock levels and opponent behavior to determine defection/cooperation timing.
    Core approach: defect by default, cooperate only when extracting information from
    heavily cooperative opponents in healthy stock conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        danger_threshold = self.capacity * 0.15
        if current_stock <= danger_threshold:
            return Action.D
        recent_coop_rate = self._measure_opponent_cooperation(history, current_round)
        if recent_coop_rate >= 0.75:
            return Action.D
        if recent_coop_rate >= 0.5:
            return Action.D
        healthy_threshold = self.capacity * 0.5
        if recent_coop_rate < 0.25 and current_stock >= healthy_threshold:
            return Action.C
        return Action.D

    def _measure_opponent_cooperation(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate recent opponent cooperation rate over last k rounds.
        
        recent_coop_rate = proportion of recent rounds where at least (n-1)/2 
        opponents played C (majority cooperation).
        
        k = min(5, current_round)
        """
        if current_round == 0:
            return 0.0
        k = min(5, current_round)
        start_round = current_round - k
        cooperating_rounds = 0
        majority_threshold = (self.n_players - 1) / 2.0
        for round_idx in range(start_round, current_round):
            cooperators_in_round = np.sum(history.opponent_actions[round_idx, :])
            if cooperators_in_round >= majority_threshold:
                cooperating_rounds += 1
        if k == 0:
            return 0.0
        recent_coop_rate = cooperating_rounds / k
        return recent_coop_rate

class Strategy_EXPLOITATIVE_276(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy
    
    Maximizes personal consumption by defaulting to defection across nearly all conditions.
    Exploits cooperators in abundance, accelerates extraction in scarcity, and matches
    defectors in normal conditions. Adapts minimally based on stock level and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.D
        if round_number == self.n_rounds - 1:
            return Action.D
        if current_stock < 0.1 * self.capacity:
            return Action.D
        if current_stock < 0.3 * self.capacity:
            return Action.D
        if current_stock > 0.7 * self.capacity:
            return Action.D
        stock_trend = self._calculate_stock_trend(history, round_number)
        if stock_trend < 0:
            return Action.D
        return Action.D

    def _calculate_stock_trend(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate stock trend from history.
        Returns positive if stock is growing, negative if declining, zero if stable/insufficient data.
        """
        if round_number < 2:
            return 0.0
        recent_payoffs = history.my_payoffs[-2:]
        if len(recent_payoffs) >= 2:
            trend = recent_payoffs[-1] - recent_payoffs[-2]
            return trend
        return 0.0

class Strategy_EXPLOITATIVE_277(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Collapse Prevention
    
    Defaults to defection for maximum extraction, but cooperates when stock
    falls below viability threshold to preserve game continuity. Detects defection
    cascades and joins them. Always defects in final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.viability_threshold = self.capacity * 0.15
        self.cascade_threshold = 0.4
        self.cascade_stock_threshold = self.capacity * 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock <= self.viability_threshold:
            return Action.C
        if current_round > 0 and history is not None:
            previous_round_actions = history.opponent_actions[current_round - 1, :]
            num_opponent_defectors = np.sum(~previous_round_actions)
            self_defected_last = not history.my_actions[current_round - 1]
            total_defectors = num_opponent_defectors + (1 if self_defected_last else 0)
            defection_rate = total_defectors / self.n_players
            if defection_rate >= self.cascade_threshold and current_stock > self.cascade_stock_threshold:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_278(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Defection
    
    Treats the common pool as a resource to extract maximum value from before others 
    deplete it. Exploits cooperative players' restraint while using stock trend detection 
    and threshold-based switching to avoid complete collapse. Defects by default except 
    when forced to cooperate by critical stock levels or in desperation scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 2 * self.n * 1.5
        self.abundance_threshold = self.capacity * 0.8
        self.depletion_signal_threshold = 0.15 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.total_rounds - round_number
        if current_stock <= self.critical_threshold:
            return Action.C
        if rounds_remaining == 1:
            return Action.D
        if round_number == 0:
            return Action.D
        if current_stock > self.abundance_threshold:
            return Action.D
        opponent_actions_last = history.opponent_actions[round_number - 1, :]
        defectors_last_round = np.sum(~opponent_actions_last)
        defection_rate = defectors_last_round / self.n
        depletion_signal = False
        if round_number >= 2:
            stock_decline = history.opponent_payoffs[round_number - 1, 0] * self.n
            depletion_signal = stock_decline > self.depletion_signal_threshold
        elif round_number == 1:
            total_payoff_last = np.sum(history.opponent_payoffs[0, :])
            depletion_signal = total_payoff_last > self.depletion_signal_threshold
        if defection_rate > 0.5:
            return Action.D
        if depletion_signal:
            return Action.D
        if rounds_remaining <= 2:
            return Action.D
        if round_number >= 1:
            cooperators_last = np.sum(history.opponent_actions[round_number - 1, :])
            all_cooperated = cooperators_last == self.n
            if all_cooperated and current_stock > self.critical_threshold:
                return Action.D
        if current_stock > 2.5 * self.n and defection_rate < 0.3 and (not depletion_signal):
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_279(BaseStrategy):
    """
    Adaptive Extraction Strategy: Exploitative common pool resource strategy that
    maximizes personal extraction by defecting in early rounds while stock is abundant,
    then continues defecting as stock depletes. Always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == self.n_rounds - 1:
            return Action.D
        if round_num <= 1:
            return Action.D
        stock_threshold = self.capacity * 0.5
        if stock > stock_threshold:
            return Action.D
        else:
            recent_rounds = min(3, round_num)
            if recent_rounds > 0 and history is not None:
                recent_actions = history.my_actions[-recent_rounds:]
                defection_count = np.sum(~recent_actions)
                recent_defection_rate = defection_count / recent_rounds
            else:
                recent_defection_rate = 0.0
            if recent_defection_rate > 0.5:
                return Action.D
            return Action.D

class Strategy_EXPLOITATIVE_280(BaseStrategy):
    """
    Adaptive Predation with Sustainability Threshold: An exploitative strategy that defects
    early and in mid-game to extract maximum value from cooperators, while maintaining
    sustainability thresholds to prevent resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == self.r - 1:
            if stock > self.capacity * 0.05:
                return Action.D
            else:
                return Action.C
        if round_num <= 1:
            return Action.D
        if stock <= self.capacity * 0.3:
            return Action.C
        if round_num <= self.r - 2:
            if history is not None and round_num >= 1:
                prev_round_idx = round_num - 1
                my_action_prev = history.my_actions[prev_round_idx]
                my_consumption_prev = stock / (2 * self.n) if my_action_prev else stock / self.n
                opponent_consumptions_prev = history.opponent_payoffs[prev_round_idx, :].sum()
                total_consumption_prev = my_consumption_prev + opponent_consumptions_prev
                max_possible_consumption = stock
                if total_consumption_prev < max_possible_consumption * 0.75 and total_consumption_prev > 0:
                    if stock >= self.capacity * 0.6:
                        return Action.D
            if stock >= self.capacity * 0.6:
                return Action.D
            else:
                return Action.C
        if round_num == self.r - 1:
            if stock >= self.capacity * 0.7:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_281(BaseStrategy):
    """
    Exploitative strategy: Adaptive Extraction with Defection Dominance.
    
    Defaults to defection to maximize immediate payoff (2x cooperation).
    Conditionally cooperates only when stock is healthy (≥60% capacity),
    majority of players cooperated last round (≥50%), and not in final rounds.
    Always defects in last two rounds and when stock is critically low (<30% capacity).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round >= self.n_rounds - 2:
            return Action.D
        if current_stock < 0.3 * self.capacity:
            return Action.D
        if current_round == 0:
            return Action.D
        if current_round >= 1 and current_round < self.n_rounds - 2:
            prev_round_opponent_actions = history.opponent_actions[current_round - 1, :]
            cooperation_count = int(np.sum(prev_round_opponent_actions))
            cooperation_rate = cooperation_count / self.n_players
            prev_stock = state.current_stock
            if current_round > 1:
                prev_stock_estimate = state.current_stock
            else:
                prev_stock_estimate = self.capacity
            stock_healthy = current_stock >= 0.6 * self.capacity
            cooperator_majority = cooperation_rate >= 0.5
            not_endgame = current_round < self.n_rounds - 2
            stock_stable_or_growing = current_stock >= 0.3 * self.capacity
            if stock_healthy and cooperator_majority and not_endgame and stock_stable_or_growing:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_282(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Threshold Defection
    
    This strategy exploits common pool resources by:
    1. Cooperating early to gather information about opponent behavior
    2. Detecting defection prevalence through observed stock depletion rates
    3. Pivoting to aggressive defection when cooperation is being exploited
    4. Maximizing extraction in the endgame before resource collapse
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= 2:
            return Action.D
        if current_stock < self.capacity * 0.3:
            return Action.D
        if current_round == 0:
            return Action.C
        if current_round == 1:
            return Action.C
        depletion_rate = self._calculate_depletion_rate(history, current_round)
        if depletion_rate > 0.4 and rounds_remaining > 3:
            return Action.D
        if current_round < self.n_rounds / 3.0 and current_stock >= self.capacity * 0.95:
            return Action.C
        inferred_defection_rate = self._infer_defection_rate(history, current_round)
        if inferred_defection_rate > 0.4:
            return Action.D
        cooperation_payoff = current_stock / (2.0 * self.n_players)
        defection_payoff = current_stock / self.n_players
        if defection_payoff > cooperation_payoff * 1.3:
            return Action.D
        return Action.C

    def _calculate_depletion_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the stock depletion rate in the most recent round.
        depletion_rate = (stock_before - stock_after) / stock_before
        """
        if current_round == 0:
            return 0.0
        prev_round = current_round - 1
        cooperators = np.sum(history.opponent_actions[prev_round, :])
        defectors = self.n_players - 1 - cooperators
        my_action = history.my_actions[prev_round]
        my_cooperated = my_action
        total_cooperators = cooperators + (1 if my_cooperated else 0)
        total_defectors = self.n_players - total_cooperators
        if prev_round == 0:
            estimated_stock_before = self.capacity
        else:
            estimated_stock_before = self._estimate_stock_before_round(history, prev_round)
        estimated_consumption = total_cooperators * (estimated_stock_before / (2.0 * self.n_players)) + total_defectors * (estimated_stock_before / self.n_players)
        if estimated_stock_before < 1e-09:
            return 0.0
        depletion_rate = estimated_consumption / estimated_stock_before
        return min(depletion_rate, 1.0)

    def _estimate_stock_before_round(self, history: PlayerHistory, target_round: int) -> float:
        """
        Estimate stock at the beginning of target_round by working backwards
        or forwards from known payoffs.
        """
        if target_round == 0:
            return self.capacity
        prev_round = target_round - 1
        my_action = history.my_actions[prev_round]
        my_payoff = history.my_payoffs[prev_round]
        if my_action:
            estimated_stock = my_payoff * 2.0 * self.n_players
        else:
            estimated_stock = my_payoff * self.n_players
        return max(0.0, estimated_stock)

    def _infer_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Infer the defection rate of opponents from observed stock changes.
        """
        if current_round < 2:
            return 0.0
        recent_defections = 0
        total_opponent_rounds = 0
        start_round = max(0, current_round - 3)
        for round_idx in range(start_round, current_round):
            opponent_defections = np.sum(~history.opponent_actions[round_idx, :])
            recent_defections += opponent_defections
            total_opponent_rounds += self.n_players - 1
        if total_opponent_rounds == 0:
            return 0.0
        inferred_rate = recent_defections / total_opponent_rounds
        return inferred_rate

class Strategy_EXPLOITATIVE_283(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Conditional Cooperation
    
    Prioritizes extracting maximum value from the common pool while exploiting
    cooperative opponents. Uses stock-dependent thresholds to determine when to
    defect aggressively vs. conditionally cooperate to preserve the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = 1.5 * self.capacity
        self.threshold_medium = 0.75 * self.capacity
        self.threshold_low = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == self.n_rounds - 1:
            return Action.D
        if round_num == 0:
            return Action.D
        if stock > self.threshold_high:
            return Action.D
        elif stock > self.threshold_medium:
            return Action.D
        elif stock > self.threshold_low:
            return self._conditional_cooperate(history, round_num)
        else:
            return Action.D

    def _conditional_cooperate(self, history: PlayerHistory, round_num: int) -> Action:
        """
        Apply tit-for-two-tats with defection bias in low stock situations.
        Analyze opponent defections in the last 2 rounds to decide.
        """
        lookback_start = max(0, round_num - 2)
        lookback_rounds = history.opponent_actions[lookback_start:round_num, :]
        if lookback_rounds.size == 0:
            return Action.D
        num_defections = np.sum(~lookback_rounds)
        total_opponent_actions = lookback_rounds.size
        if total_opponent_actions == 0:
            return Action.D
        defection_rate = num_defections / total_opponent_actions
        if defection_rate > 0.6:
            return Action.D
        elif defection_rate > 0.3:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_284(BaseStrategy):
    """
    Adaptive Predation with Sustainability Targeting: An exploitative strategy that
    defects to maximize payoff while adaptively cooperating to prevent stock collapse.
    Tracks observed defection rates and projects future stock levels to decide whether
    the commons can sustain further exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.total_defections_observed = 0
        self.total_observations = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if history is None or current_round == 0:
            observed_defection_rate = 0.5
        else:
            for round_idx in range(current_round):
                defections_this_round = np.sum(~history.opponent_actions[round_idx, :])
                self.total_defections_observed += defections_this_round
                self.total_observations += self.n_players - 1
            if self.total_observations > 0:
                observed_defection_rate = self.total_defections_observed / self.total_observations
            else:
                observed_defection_rate = 0.5
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock <= 2 * self.n_players:
            return Action.C
        expected_stock_after_round = self._predict_stock_after_round(current_stock, observed_defection_rate)
        if expected_stock_after_round < self.n_players:
            return Action.C
        if history is not None and current_round >= 3:
            recent_stocks = self._get_recent_stock_trend(history, current_round)
            if self._is_declining_trend(recent_stocks) and current_stock < 0.6 * self.capacity:
                return Action.C
        return Action.D

    def _predict_stock_after_round(self, current_stock: float, defection_rate: float) -> float:
        """
        Predict stock level after this round assuming:
        - This player defects
        - Opponents defect at the observed_defection_rate
        - Others cooperate at (1 - defection_rate)
        """
        my_consumption = current_stock / self.n_players
        expected_opponent_defectors = (self.n_players - 1) * defection_rate
        expected_opponent_cooperators = (self.n_players - 1) * (1 - defection_rate)
        opponent_consumption = expected_opponent_defectors * (current_stock / self.n_players) + expected_opponent_cooperators * (current_stock / (2 * self.n_players))
        total_consumption = my_consumption + opponent_consumption
        stock_after_consumption = max(0, current_stock - total_consumption)
        if stock_after_consumption > 0 and self.capacity > 0:
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
        else:
            growth = 0
        new_stock = min(stock_after_consumption + growth, self.capacity)
        return new_stock

    def _get_recent_stock_trend(self, history: PlayerHistory, current_round: int) -> list:
        """
        Reconstruct recent stock levels from history (last 3 rounds).
        Returns list of stock levels in chronological order.
        """
        stock_levels = []
        stock = self.capacity
        stock_levels.append(stock)
        for round_idx in range(min(current_round, 3)):
            my_action = history.my_actions[round_idx]
            my_consumption = stock / (2 * self.n_players) if my_action else stock / self.n_players
            opponent_consumption = 0
            for opp_idx in range(self.n_players - 1):
                opp_action = history.opponent_actions[round_idx, opp_idx]
                opp_consumption = stock / (2 * self.n_players) if opp_action else stock / self.n_players
                opponent_consumption += opp_consumption
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0, stock - total_consumption)
            if stock_after_consumption > 0 and self.capacity > 0:
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            else:
                growth = 0
            stock = min(stock_after_consumption + growth, self.capacity)
            stock_levels.append(stock)
        return stock_levels

    def _is_declining_trend(self, stock_levels: list) -> bool:
        """
        Check if stock shows consistent decline over recent rounds.
        Returns True if stock is declining in each consecutive pair.
        """
        if len(stock_levels) < 3:
            return False
        for i in range(len(stock_levels) - 1):
            if stock_levels[i] <= stock_levels[i + 1]:
                return False
        return True

class Strategy_EXPLOITATIVE_285(BaseStrategy):
    """
    Exploitative strategy with adaptive depletion and opportunistic switching.
    
    Core philosophy: Exploit asymmetry between cooperators and defectors while
    maximizing absolute payoff. Switches from cooperation to defection based on
    observed opponent behavior, stock levels, and remaining game time.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.observed_defection = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < 1.5 * self.n_players:
            return Action.D
        if current_round == 0:
            return Action.C
        if self.observed_defection:
            return Action.D
        defections_observed = self._count_opponent_defections(history, current_round)
        if defections_observed > 0:
            self.observed_defection = True
            return Action.D
        if current_round > 1:
            defection_rate = self._calculate_defection_rate(history, current_round)
            if defection_rate > 0.4:
                return Action.D
        remaining_rounds = self.n_rounds - current_round
        if remaining_rounds <= 2 and current_stock >= self.capacity * 0.8:
            return Action.D
        return Action.C

    def _count_opponent_defections(self, history: PlayerHistory, current_round: int) -> int:
        """
        Count total defections observed from opponents up to (but not including) current round.
        Returns count of False values (defections) in opponent_actions.
        """
        if current_round == 0:
            return 0
        opponent_actions_so_far = history.opponent_actions[:current_round, :]
        defection_count = np.sum(~opponent_actions_so_far)
        return int(defection_count)

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the rate of defections in observed history.
        Returns ratio of defections to total actions observed.
        """
        if current_round == 0:
            return 0.0
        opponent_actions_so_far = history.opponent_actions[:current_round, :]
        total_actions = opponent_actions_so_far.size
        if total_actions == 0:
            return 0.0
        defection_count = np.sum(~opponent_actions_so_far)
        defection_rate = float(defection_count) / float(total_actions)
        return defection_rate

class Strategy_EXPLOITATIVE_286(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Exploits the asymmetry between cooperative and defective payoffs by:
    1. Using dynamic stock-based thresholds to defect when sustainable
    2. Detecting and permanently exploiting cooperators
    3. Employing emergency cooperation only when stock crashes
    4. Switching to unconditional defection in final rounds
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.permanent_defect = False
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock = state.current_stock
        round_num = state.round_number
        self.stock_history.append(stock)
        if round_num >= r - 2:
            return Action.D
        if stock < capacity / 3:
            return Action.C
        if round_num >= 2 and (not self.permanent_defect):
            round_1_cooperators = int(sum(history.opponent_actions[0, :]))
            cooperation_rate = round_1_cooperators / n
            if cooperation_rate < 0.5:
                self.permanent_defect = True
                return Action.D
            elif cooperation_rate > 0.7:
                pass
        if self.permanent_defect:
            return Action.D
        if r > 1:
            progress_ratio = round_num / (r - 1)
        else:
            progress_ratio = 0
        base_threshold = capacity * 2 * n * (1 - progress_ratio)
        threshold = base_threshold
        if round_num >= 1:
            recent_cooperators = int(sum(history.opponent_actions[round_num - 1, :]))
            cooperation_rate = recent_cooperators / n
            if cooperation_rate > 0.7:
                threshold = threshold * 0.85
        if stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_287(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Recovery Exploitation
    
    Core approach: Defect aggressively in early/late rounds and high-stock phases,
    exploit detected cooperators, adapt based on stock levels, and strategically
    switch to cooperation only in endgame if stock has critically depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_types = [None] * self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        self._update_opponent_types(state, history)
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        remaining_rounds = self.n_rounds - current_round
        if stock_ratio > 0.7:
            return Action.D
        elif stock_ratio > 0.3:
            cooperators_count = sum((1 for t in self.opponent_types if t == 'C'))
            if cooperators_count > self.n_players * 0.5:
                return Action.D
            else:
                return Action.D
        elif remaining_rounds > self.n_players:
            return Action.D
        else:
            return Action.C

    def _update_opponent_types(self, state: CommonPoolState, history: PlayerHistory) -> None:
        """
        Infer opponent types (cooperator vs defector) from consumption patterns.
        
        Observable: total stock depletion across all players
        Infer: individual opponent actions
        
        Cooperator extracts: stock / (2n)
        Defector extracts: stock / n
        """
        if history is None or len(history.my_actions) == 0:
            return
        current_round = state.round_number
        if current_round == 0:
            return
        prev_round_idx = current_round - 1
        if prev_round_idx > 0:
            prev_stock_before = self._estimate_stock_before_round(history, prev_round_idx)
        else:
            prev_stock_before = self.capacity
        if prev_stock_before <= 0:
            return
        my_action_was_c = history.my_actions[prev_round_idx]
        my_consumption = prev_stock_before / (2 * self.n_players) if my_action_was_c else prev_stock_before / self.n_players
        total_consumption = prev_stock_before - state.current_stock
        opponent_total_consumption = total_consumption - my_consumption
        expected_all_coop = (self.n_players - 1) * prev_stock_before / (2 * self.n_players)
        expected_all_defect = (self.n_players - 1) * prev_stock_before / self.n_players
        if opponent_total_consumption < expected_all_coop + (expected_all_defect - expected_all_coop) * 0.5:
            for i in range(self.n_players):
                if self.opponent_types[i] is None:
                    self.opponent_types[i] = 'C'
        else:
            for i in range(self.n_players):
                if self.opponent_types[i] is None:
                    self.opponent_types[i] = 'D'

    def _estimate_stock_before_round(self, history: PlayerHistory, round_idx: int) -> float:
        """
        Estimate the stock level at the start of a given round.
        Work backwards from known state using growth dynamics.
        """
        if round_idx == 0:
            return self.capacity
        estimated_stock = self.capacity * (1.0 - 0.1 * round_idx)
        return max(0.0, estimated_stock)

class Strategy_EXPLOITATIVE_288(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Extraction with Opportunistic Defection
    
    Exploits asymmetry between cooperative and defective payoffs while remaining
    sensitive to stock depletion. Prioritizes immediate extraction when conditions
    favor defection, but strategically cooperates when defection would be
    self-destructive due to resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_cooperation_count = 0
        self.opponent_total_rounds = 0
        self.opponent_defection_streak = 0

    def _calculate_stock_ratio(self, stock: float) -> float:
        """Calculate current stock as ratio of capacity."""
        if self.capacity <= 0:
            return 0.0
        return stock / self.capacity

    def _get_stock_zone(self, stock_ratio: float) -> str:
        """Classify stock health into zones."""
        if stock_ratio < 0.25:
            return 'critical'
        elif stock_ratio < 0.5:
            return 'vulnerable'
        elif stock_ratio < 0.75:
            return 'healthy'
        else:
            return 'optimal'

    def _project_stock_after_all_defect(self, stock: float) -> float:
        """Project stock level if all players defect."""
        total_consumption = stock
        stock_remaining = max(0.0, stock - total_consumption)
        growth = 2.0 * stock_remaining * (1.0 - stock_remaining / max(1.0, self.capacity))
        new_stock = min(stock_remaining + growth, self.capacity)
        return new_stock

    def _project_stock_after_all_cooperate(self, stock: float) -> float:
        """Project stock level if all players cooperate."""
        total_consumption = stock / 2.0
        stock_remaining = max(0.0, stock - total_consumption)
        growth = 2.0 * stock_remaining * (1.0 - stock_remaining / max(1.0, self.capacity))
        new_stock = min(stock_remaining + growth, self.capacity)
        return new_stock

    def _get_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        """Calculate opponent's cooperation rate so far."""
        if self.opponent_total_rounds == 0:
            return 0.5
        return self.opponent_cooperation_count / max(1, self.opponent_total_rounds)

    def _update_opponent_stats(self, history: PlayerHistory) -> None:
        """Update opponent behavior statistics from latest round."""
        if history is None or len(history.opponent_actions) == 0:
            return
        latest_round_idx = len(history.opponent_actions) - 1
        cooperators_this_round = sum(history.opponent_actions[latest_round_idx, :])
        self.opponent_total_rounds = latest_round_idx + 1
        self.opponent_cooperation_count = int(np.sum(history.opponent_actions[:latest_round_idx + 1, :]))
        if cooperators_this_round == 0:
            self.opponent_defection_streak += 1
        else:
            self.opponent_defection_streak = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Main decision logic for the strategy.
        """
        current_stock = state.current_stock
        round_number = state.round_number
        stock_ratio = self._calculate_stock_ratio(current_stock)
        stock_zone = self._get_stock_zone(stock_ratio)
        rounds_remaining = self.n_rounds - round_number - 1
        if round_number == 0:
            if stock_ratio >= 0.75:
                return Action.D
            else:
                return Action.C
        self._update_opponent_stats(history)
        opponent_coop_rate = self._get_opponent_cooperation_rate(history)
        if round_number == self.n_rounds - 1:
            if stock_ratio > 0.1:
                return Action.D
            else:
                return Action.C
        if stock_ratio < 0.25:
            return Action.C
        next_stock_if_all_defect = self._project_stock_after_all_defect(current_stock)
        if next_stock_if_all_defect < 5.0 and rounds_remaining > 2:
            return Action.C
        if stock_ratio >= 0.5:
            if self.opponent_defection_streak >= 3:
                return Action.D
            if rounds_remaining <= 3:
                return Action.D
            defection_payoff = current_stock / self.n_players
            cooperation_payoff = current_stock / (2.0 * self.n_players)
            defection_gain = defection_payoff - cooperation_payoff
            if history is not None and len(history.my_payoffs) > 0:
                avg_payoff = float(np.mean(history.my_payoffs))
            else:
                avg_payoff = cooperation_payoff
            if avg_payoff > 0 and defection_gain > 0.2 * avg_payoff:
                return Action.D
            return Action.C
        if stock_ratio >= 0.25:
            if rounds_remaining <= 2:
                return Action.D
            if opponent_coop_rate > 0.6:
                return Action.D
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_289(BaseStrategy):
    """
    Adaptive Parasitism with Opportunistic Harvesting.
    
    Exploits cooperation by defecting when stock is abundant, switches to conditional
    cooperation only when stock falls below a dynamically calculated threshold.
    Unconditionally defects in endgame rounds. Incorporates historical opponent defection
    ratio to refine cooperation decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num >= self.n_rounds - 1:
            return Action.D
        t = round_num + 1
        threshold = self.capacity * (1.0 - (t / self.n_rounds) ** 2)
        if stock < self.capacity / 20.0:
            return Action.D
        if stock > threshold:
            return Action.D
        else:
            total_opponent_actions = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
            if total_opponent_actions == 0:
                return Action.D
            total_opponent_cooperations = np.sum(history.opponent_actions)
            historical_defection_ratio = 1.0 - total_opponent_cooperations / total_opponent_actions
            if historical_defection_ratio < 0.8:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_290(BaseStrategy):
    """
    Adaptive Extraction Strategy for Common Pool Resource Game.
    
    Exploits stock abundance through defection while adapting to stock depletion
    and opponent behavior. Uses stock-dependent thresholds and opponent modeling
    to maximize payoff while avoiding catastrophic collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_t = state.round_number
        if round_t == 0:
            return Action.D
        if round_t == self.r - 1:
            return Action.D
        critical_stock = 3 * self.n
        opponent_defection_rate = self._calculate_opponent_defection_rate(history, round_t)
        if current_stock < self.n:
            return Action.C
        if current_stock > critical_stock:
            return Action.D
        elif current_stock >= critical_stock / 2:
            if opponent_defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        elif self.r - round_t <= 3 and current_stock > self.n:
            return Action.D
        else:
            return Action.C

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, round_t: int) -> float:
        """
        Calculate the defection rate of opponents based on observed history.
        
        Args:
            history: PlayerHistory object containing opponent actions
            round_t: Current round number (1-indexed from the perspective of history)
        
        Returns:
            Defection rate as a float between 0 and 1
        """
        if round_t <= 1:
            return 0.5
        opponent_actions = history.opponent_actions[:round_t, :]
        total_actions = opponent_actions.size
        if total_actions == 0:
            return 0.5
        total_cooperations = np.sum(opponent_actions)
        total_defections = total_actions - total_cooperations
        defection_rate = total_defections / total_actions
        return defection_rate

class Strategy_EXPLOITATIVE_291(BaseStrategy):
    """
    Adaptive Predation: An exploitative strategy for Common Pool Resource games.
    
    Maximizes personal payoff by strategically defecting while exploiting cooperative
    tendencies in others. Uses stock level thresholds and recent defection history to
    decide between exploitation (D) and tactical cooperation (C).
    
    Key mechanisms:
    - Always defect in final round (guaranteed exploitation)
    - Defect when stock is abundant (≥60% capacity)
    - Cooperate when stock is critically low (<30% capacity)
    - In middle zone (30-60%), use recent defection history to decide
    - Occasional tactical cooperation resets opponent perception
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.capacity * 0.3:
            return Action.C
        if current_stock >= self.capacity * 0.6:
            return Action.D
        if current_stock >= self.capacity * 0.3 and current_stock < self.capacity * 0.6:
            recent_defection_count = self._count_recent_defections(history, current_round)
            if recent_defection_count >= 2:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _count_recent_defections(self, history: PlayerHistory, current_round: int) -> int:
        """
        Count how many of the last 3 rounds (or fewer if not available) 
        this player defected.
        
        Returns count of defections in recent history.
        my_actions uses True for C (cooperate), False for D (defect).
        """
        if history is None or current_round == 0:
            return 0
        lookback_start = max(0, current_round - 3)
        lookback_end = current_round
        defection_count = 0
        for round_idx in range(lookback_start, lookback_end):
            if round_idx < len(history.my_actions):
                if not history.my_actions[round_idx]:
                    defection_count += 1
        return defection_count

class Strategy_EXPLOITATIVE_292(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State-Based Defection
    
    Exploits the payoff asymmetry (defection yields 2x cooperation value) while
    managing stock collapse risk through selective cooperation. Employs state-dependent
    thresholds and opponent behavior tracking to maximize extraction across rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        rounds_remaining = self.n_rounds - round_num
        if round_num == self.n_rounds - 1:
            return Action.D
        sqrt_term = math.sqrt(rounds_remaining + 1)
        threshold_defect = self.capacity * (1.0 - 1.0 / sqrt_term)
        min_recovery_threshold = self.capacity * 0.15
        if round_num == 0:
            return Action.D
        if stock > threshold_defect:
            return Action.D
        if stock <= min_recovery_threshold:
            if rounds_remaining > 2:
                return Action.C
            else:
                return Action.D
        opponent_defection_rate = self._calculate_opponent_defection_rate(history)
        if opponent_defection_rate > 0.6:
            return Action.C
        else:
            return Action.D

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the average defection rate of opponents over the last 3 rounds.
        Defection is represented as False (0) in opponent_actions.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        lookback = min(3, len(history.opponent_actions))
        recent_rounds = history.opponent_actions[-lookback:, :]
        n_opponents = self.game_description.n_players - 1
        if n_opponents == 0:
            return 0.0
        total_actions = lookback * n_opponents
        if total_actions == 0:
            return 0.0
        cooperations = np.sum(recent_rounds)
        defections = total_actions - cooperations
        defection_rate = defections / total_actions
        return float(defection_rate)

class Strategy_EXPLOITATIVE_293(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Dynamic Defection Thresholding
    
    Maximizes personal extraction by opportunistically defecting based on stock health,
    remaining time, and observed opponent behavior. Exploits cooperators while avoiding
    pool collapse through strategic timing.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.depletion_threshold = self.capacity * 0.15
        self.critical_ratio = 0.3
        self.cooperation_window = max(2, self.n_rounds // 3)
        self.depletion_rate_threshold = 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock <= self.depletion_threshold:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio <= self.critical_ratio:
            return Action.D
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= self.cooperation_window:
            return Action.D
        if history is None:
            return Action.C
        if current_round >= 1:
            prev_stock = None
            if current_round == 1:
                prev_stock = self.capacity
            else:
                my_action_prev = history.my_actions[current_round - 1]
                opponent_actions_prev = history.opponent_actions[current_round - 1, :]
                num_defectors = int(np.sum(opponent_actions_prev == False))
                num_cooperators = int(np.sum(opponent_actions_prev == True))
                if my_action_prev == False:
                    num_defectors += 1
                else:
                    num_cooperators += 1
                total_consumed_last_round = np.sum(history.my_payoffs[current_round - 1:current_round]) + np.sum(history.opponent_payoffs[current_round - 1, :])
                if total_consumed_last_round > 0 and current_stock > 0:
                    implied_prev_stock = current_stock + total_consumed_last_round
                    depletion_rate = total_consumed_last_round / implied_prev_stock if implied_prev_stock > 0 else 0.0
                    if depletion_rate > self.depletion_rate_threshold:
                        return Action.D
            opponent_actions_prev = history.opponent_actions[current_round - 1, :]
            my_action_prev = history.my_actions[current_round - 1]
            num_defectors_observed = int(np.sum(opponent_actions_prev == False))
            if num_defectors_observed > 0:
                return Action.D
            if num_defectors_observed > self.n_players // 2:
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_294(BaseStrategy):
    """
    Adaptive Predation with Safeguards: An exploitative strategy that maximizes
    individual payoff by defecting when the pool is healthy, while avoiding
    mutual defection collapse through adaptive thresholds and opponent tracking.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        if round_num == 0:
            return Action.D
        rounds_elapsed = round_num
        opponent_defection_count = self._count_opponent_defections(history, rounds_elapsed)
        opponent_defection_rate = opponent_defection_count / (rounds_elapsed * self.n_players) if rounds_elapsed > 0 else 0.0
        if stock_ratio < 0.1:
            return Action.C
        if round_num == self.n_rounds - 1 and stock_ratio > 0.15:
            return Action.D
        if opponent_defection_rate > 0.5:
            return Action.D
        if rounds_elapsed > 0:
            opponent_coop_rates = self._get_opponent_cooperation_rates(history, rounds_elapsed)
            for coop_rate in opponent_coop_rates:
                if coop_rate > 0.7 and stock_ratio > 0.4:
                    return Action.D
        if round_num < self.n_rounds / 2.0 and stock_ratio > 0.5:
            return Action.D
        if stock_ratio > 0.6:
            return Action.D
        elif stock_ratio > 0.3:
            return Action.D if random.random() < 0.8 else Action.C
        elif stock_ratio > 0.15:
            return Action.C
        else:
            return Action.C

    def _count_opponent_defections(self, history: PlayerHistory, rounds_elapsed: int) -> int:
        """Count total defection instances across all opponents in elapsed rounds."""
        if rounds_elapsed == 0 or history.opponent_actions.size == 0:
            return 0
        defections = np.sum(~history.opponent_actions[:rounds_elapsed, :])
        return int(defections)

    def _get_opponent_cooperation_rates(self, history: PlayerHistory, rounds_elapsed: int) -> list:
        """Calculate cooperation rate for each opponent."""
        if rounds_elapsed == 0 or history.opponent_actions.size == 0:
            return []
        coop_rates = []
        for opponent_idx in range(self.n_players - 1):
            if opponent_idx < history.opponent_actions.shape[1]:
                opponent_coop_count = np.sum(history.opponent_actions[:rounds_elapsed, opponent_idx])
                coop_rate = float(opponent_coop_count) / rounds_elapsed if rounds_elapsed > 0 else 0.0
                coop_rates.append(coop_rate)
        return coop_rates

class Strategy_EXPLOITATIVE_295(BaseStrategy):
    """
    Exploitative strategy using adaptive predation with threshold-based exploitation.
    
    Core philosophy: Defect unconditionally to maximize immediate extraction from the 
    common pool. Exploit cooperators by detecting their restraint and punishing with 
    continued defection. Maintain predatory stance across all stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round >= self.n_rounds - 2:
            return Action.D
        if current_round <= 2:
            return Action.D
        if current_round > 0 and history is not None:
            previous_round_idx = current_round - 1
            opponent_cooperations = int(sum(history.opponent_actions[previous_round_idx, :]))
            if opponent_cooperations > 0:
                return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio < 0.15:
            return Action.D
        elif stock_ratio < 0.3:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_296(BaseStrategy):
    """
    Adaptive Extraction Strategy for Common Pool Resource Game.
    
    Exploits asymmetry between cooperative (S/2n) and defective (S/n) payoffs
    while remaining sensitive to stock depletion. Uses stock-responsive thresholds
    to decide between defection (2x payoff) and cooperation (collapse prevention).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r_total = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_suppression = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        r_remaining = self.r_total - round_num
        collapse_threshold = self.capacity / 4.0
        recovery_threshold = self.capacity / 3.0
        if stock < collapse_threshold:
            self.defection_suppression = True
        elif stock > recovery_threshold:
            self.defection_suppression = False
        if round_num == self.r_total - 1:
            return Action.D
        if self.defection_suppression:
            return Action.C
        base_threshold = self.capacity * (1.0 - 1.0 / self.n)
        endgame_boost = 0.15 * (r_remaining / self.r_total)
        dynamic_threshold = base_threshold * (1.0 + endgame_boost)
        if stock > dynamic_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_297(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Dynamic Thresholds
    
    This strategy exploits the asymmetry between cooperation and defection by:
    - Defecting aggressively when stock is abundant (high payoff with 2x advantage)
    - Using dynamic thresholds that decrease over time to maintain stock sustainability
    - Adapting to opponent behavior: defect less if others defect heavily, more if others cooperate
    - Always defecting in the final round for maximum terminal extraction
    - Cooperating only when forced by stock depletion or to allow recovery
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number
        if rounds_remaining == 1:
            return Action.D
        if current_stock <= 0.1 * self.capacity or current_stock < 2 * self.n_players:
            return Action.C
        if round_number == 0:
            return Action.D
        base_threshold = self.capacity * (1.0 - (rounds_remaining / self.n_rounds) ** 2)
        if history is not None and round_number > 0:
            total_opponent_actions = history.opponent_actions[:round_number, :].size
            if total_opponent_actions > 0:
                total_cooperations = np.sum(history.opponent_actions[:round_number, :])
                total_defections = total_opponent_actions - total_cooperations
                observed_defection_rate = total_defections / total_opponent_actions
                if observed_defection_rate > 0.6:
                    base_threshold *= 1.3
                elif observed_defection_rate < 0.3:
                    base_threshold *= 0.7
            if round_number > 0:
                previous_stock_estimate = current_stock + np.sum(history.opponent_payoffs[round_number - 1, :])
                if previous_stock_estimate > 0:
                    stock_decline = (previous_stock_estimate - current_stock) / previous_stock_estimate
                    if stock_decline > 0.5:
                        total_defections_last_round = self.n_players - np.sum(history.opponent_actions[round_number - 1, :])
                        if total_defections_last_round > 0.7 * self.n_players:
                            return Action.C
        if current_stock > base_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_298(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Exploits asymmetry between cooperators and defectors while managing stock strategically.
    Defects in first and last rounds, adapts based on stock health and opponent behavior,
    with occasional cooperation to maintain stock at exploitable levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0
        if stock_ratio < 0.15:
            return Action.C
        if stock_ratio < 0.4:
            opponent_defection_rate = self._calculate_opponent_defection_rate(history, round_num)
            if opponent_defection_rate > 0.6:
                return Action.D
            cooperator_count = int(sum(history.opponent_actions[round_num - 1, :]))
            defector_count = self.n_players - 1 - cooperator_count
            if cooperator_count > defector_count:
                return Action.D
            else:
                return Action.C
        if stock_ratio < 0.75:
            opponent_defection_rate = self._calculate_opponent_defection_rate(history, round_num)
            if opponent_defection_rate > 0.5:
                return Action.D
            elif random.random() < 0.7:
                return Action.D
            else:
                return Action.C
        return Action.D

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the average defection rate of opponents up to current round.
        
        Returns:
            float: Proportion of opponent actions that were defections (False/0)
        """
        if current_round <= 0:
            return 0.0
        opponent_actions = history.opponent_actions[:current_round, :]
        total_actions = opponent_actions.size
        if total_actions == 0:
            return 0.0
        defection_count = np.sum(~opponent_actions)
        defection_rate = defection_count / total_actions
        return float(defection_rate)

class Strategy_EXPLOITATIVE_299(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State-Aware Defection
    
    Exploits asymmetry between cooperators and defectors while remaining responsive
    to resource depletion. Defects when stock is healthy (>30% capacity) to gain 2x
    payoff advantage, then cooperates when stock crashes to prevent total collapse.
    Tracks opponent defection rates and adapts behavior in low-stock scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.depletion_threshold = 0.3
        self.defection_rate_threshold_high_stock = 0.6
        self.defection_rate_threshold_low_stock = 0.8
        self.critical_stock_threshold = 0.15
        self.recovery_threshold = 0.5
        self.rapid_decline_threshold = 0.4
        self.previous_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if self.game_description.n_players >= 4:
                return Action.D
            else:
                return Action.D
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        stock = state.current_stock
        if current_round == n_rounds - 1:
            self.previous_stock = stock
            return Action.D
        total_opponent_actions = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
        total_opponent_defections = np.sum(~history.opponent_actions) if total_opponent_actions > 0 else 0
        defection_rate = total_opponent_defections / total_opponent_actions if total_opponent_actions > 0 else 0
        stock_decline_ratio = (self.previous_stock - stock) / (self.previous_stock + 1e-09)
        rapid_decline = stock_decline_ratio > self.rapid_decline_threshold
        if stock < 0.01 * capacity:
            self.previous_stock = stock
            return Action.C
        if stock <= capacity * self.critical_stock_threshold and self.previous_stock - stock > stock:
            self.previous_stock = stock
            return Action.C
        if stock > capacity * self.recovery_threshold and self.previous_stock < capacity * self.critical_stock_threshold:
            self.previous_stock = stock
            return Action.D
        if rapid_decline:
            self.previous_stock = stock
            return Action.D
        if stock > capacity * self.depletion_threshold:
            if defection_rate > self.defection_rate_threshold_high_stock:
                self.previous_stock = stock
                return Action.D
            else:
                self.previous_stock = stock
                return Action.D
        elif defection_rate > self.defection_rate_threshold_low_stock:
            self.previous_stock = stock
            return Action.D
        else:
            self.previous_stock = stock
            return Action.C

class Strategy_EXPLOITATIVE_300(BaseStrategy):
    """
    Adaptive Predation: An exploitative strategy that defects when stock is abundant,
    cooperates only when necessary to prevent collapse, and ruthlessly exploits in endgame.
    
    Core logic:
    - Defect in final 2 rounds (endgame exploitation)
    - Defect when stock is 0 (already destroyed)
    - Defect when stock > 75% capacity (exploit abundance)
    - Cooperate when stock <= 25% capacity (prevent collapse)
    - Otherwise defect (remain exploitative in middle range)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.threshold_high = self.capacity * 0.75
        self.threshold_low = self.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= 2:
            return Action.D
        if current_stock == 0:
            return Action.D
        if current_stock > self.threshold_high:
            return Action.D
        elif current_stock <= self.threshold_low:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_301(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State-Aware Defection
    
    This strategy maximizes personal gain by identifying cooperative opponents,
    defecting strategically based on stock depletion patterns, and adapting
    defection timing to remaining rounds and current state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = n_rounds - round_number
        if round_number == 0:
            return Action.D
        observed_defection_rate = self._calculate_defection_rate(history)
        if rounds_remaining <= 2:
            return Action.D
        if current_stock < capacity * 0.25:
            return Action.C
        if current_stock > capacity * 0.5:
            if observed_defection_rate > 0.6:
                return Action.D
            else:
                return Action.D
        else:
            return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the observed defection rate across all opponents
        using a moving average of all historical rounds.
        
        True = Cooperate, False = Defect
        So defection rate = proportion of False values
        """
        if history.opponent_actions.size == 0:
            return 0.0
        all_opponent_actions = history.opponent_actions.flatten()
        if len(all_opponent_actions) == 0:
            return 0.0
        total_actions = len(all_opponent_actions)
        defections = np.sum(all_opponent_actions == False)
        defection_rate = float(defections) / float(total_actions) if total_actions > 0 else 0.0
        return defection_rate

class Strategy_EXPLOITATIVE_302(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Defection Dominance
    
    This strategy prioritizes immediate resource extraction by exploiting the 
    fundamental asymmetry that defection always yields higher payoffs than 
    cooperation (S/n vs S/(2n)). It adaptively monitors stock levels and 
    opponent cooperation rates, but consistently defaults to defection as the 
    dominant action across nearly all game states.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_critical = game_description.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 2 * self.game_description.n_players:
            return Action.D
        if state.current_stock > self.threshold_critical:
            return Action.D
        opponent_coop_rate = self._calculate_opponent_cooperation_rate(history)
        return Action.D

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the opponent cooperation rate from the last 3 rounds.
        Returns a value in [0, 1] representing the fraction of cooperative plays.
        """
        rounds_to_analyze = min(3, history.my_actions.shape[0])
        if rounds_to_analyze == 0:
            return 0.0
        recent_opponent_actions = history.opponent_actions[-rounds_to_analyze:, :]
        total_coop_plays = np.sum(recent_opponent_actions)
        total_possible_plays = rounds_to_analyze * self.game_description.n_players
        if total_possible_plays == 0:
            return 0.0
        cooperation_rate = total_coop_plays / total_possible_plays
        return cooperation_rate

class Strategy_EXPLOITATIVE_303(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy
    
    Core philosophy: Exploit the asymmetry between cooperators (who self-limit consumption) 
    and defectors (who maximize individual extraction). Always defects to maximize personal 
    payoff accumulation, with stock-aware thresholds for robustness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if self.capacity <= 0:
            return Action.D
        stock_ratio = current_stock / self.capacity
        if stock_ratio > 0.75:
            return Action.D
        if stock_ratio <= 0.15:
            return Action.D
        if stock_ratio > 0.4:
            return Action.D
        if history is not None and len(history.opponent_actions) > 0:
            previous_round_idx = state.round_number - 1
            defectors = np.sum(~history.opponent_actions[previous_round_idx, :])
            defection_rate = defectors / self.n_players
            if defection_rate > 0.6:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_304(BaseStrategy):
    """
    Exploitative Adaptive Strategy: "Conditional Depletion"
    
    Prioritizes maximum personal extraction while adaptively responding to competitive
    environment. Uses stock-dependent phases, defection ratio tracking, and round-based
    adjustments to maximize individual payoff in a common pool resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round >= self.n_rounds - 1:
            return Action.D
        if history is None:
            return Action.D
        rounds_remaining = self.n_rounds - current_round
        defect_ratio = self._calculate_defect_ratio(history)
        if stock > self.capacity * 0.75:
            return Action.D
        if defect_ratio > 0.6:
            return Action.D
        if stock <= self.capacity * 0.4:
            return Action.D
        if rounds_remaining <= self.n_rounds / 3:
            if random.random() < 0.8:
                return Action.D
            else:
                return Action.C
        cooperation_probability = 0.5 * (1.0 - defect_ratio)
        if random.random() < cooperation_probability:
            return Action.C
        else:
            return Action.D

    def _calculate_defect_ratio(self, history: PlayerHistory) -> float:
        """
        Calculate the proportion of defections observed across all opponents
        in all completed rounds.
        
        Returns a value in [0, 1], or 0 if no history available.
        """
        opponent_actions = history.opponent_actions
        if opponent_actions.size == 0:
            return 0.0
        total_actions = opponent_actions.size
        total_cooperations = np.sum(opponent_actions)
        total_defections = total_actions - total_cooperations
        defect_ratio = total_defections / total_actions if total_actions > 0 else 0.0
        return defect_ratio

class Strategy_EXPLOITATIVE_305(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Selective Cooperation
    
    Exploits the 2x payoff asymmetry of defection (S/n vs S/2n) while monitoring
    stock sustainability to avoid collapse. Uses dynamic thresholds and stock velocity
    monitoring to adapt behavior across game phases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.previous_stock = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.capacity * 0.1:
            return Action.C
        sustainability_threshold = self.capacity * (1.0 - 1.0 / self.n_rounds)
        if self.previous_stock > 0:
            stock_velocity = (current_stock - self.previous_stock) / self.previous_stock
            if stock_velocity < -0.4:
                if current_round <= self.n_rounds / 2.0:
                    self.previous_stock = current_stock
                    return Action.C
                else:
                    self.previous_stock = current_stock
                    return Action.D
        if current_stock >= sustainability_threshold:
            self.previous_stock = current_stock
            return Action.D
        else:
            self.previous_stock = current_stock
            return Action.C

class Strategy_EXPLOITATIVE_306(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Resilience
    
    Exploits cooperative opponents ruthlessly while maintaining stock viability.
    Probes with defection in round 1, then adapts based on observed cooperation rates.
    Uses temporary cooperation as a tactical tool to prevent total collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        total_coop_observed = np.sum(history.opponent_actions[:current_round, :])
        total_opponent_moves = self.n_players - 1
        rounds_elapsed = current_round
        total_possible_moves = total_opponent_moves * rounds_elapsed
        if total_possible_moves > 0:
            coop_rate = total_coop_observed / total_possible_moves
        else:
            coop_rate = 0.5
        collapse_threshold = self.capacity * 0.1
        if current_stock < collapse_threshold and current_round < self.n_rounds - 1:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if coop_rate >= 0.6:
            return Action.D
        elif coop_rate < 0.3:
            return Action.D
        else:
            stock_threshold = self.capacity * 0.5
            if current_stock > stock_threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_307(BaseStrategy):
    """
    Adaptive Predation with Sustainability Backstop strategy for Common Pool Resource games.
    
    Exploits asymmetry between cooperators and defectors by defecting aggressively while
    maintaining a sustainability backstop that forces cooperation when stock is critically low.
    Core principle: defect when possible to capture 2x the consumption of cooperators,
    but cooperate when stock collapse is imminent to allow recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity * 0.15
        self.recovery_threshold = self.capacity * 0.4
        self.defector_ratio_tipping_point = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        rounds_remaining = self.n_rounds - round_num
        if round_num == 0:
            return Action.D
        if rounds_remaining == 1:
            return Action.D
        if stock < self.critical_threshold:
            return Action.C
        defector_ratio = self._estimate_defector_ratio(history, stock)
        if defector_ratio > self.defector_ratio_tipping_point:
            return Action.D
        if stock > self.recovery_threshold:
            return Action.D
        return Action.D

    def _estimate_defector_ratio(self, history: PlayerHistory, current_stock: float) -> float:
        """
        Estimate the ratio of defectors in the population from recent history.
        
        defector_ratio = (actual_consumption_rate) / (max_consumption_rate)
        
        If ratio > 1.0, population is defecting more than expected under all-cooperate baseline.
        """
        if len(history.opponent_actions) == 0:
            return 0.0
        lookback_rounds = min(3, len(history.opponent_actions))
        recent_history = history.opponent_actions[-lookback_rounds:]
        total_opponents = self.n_players - 1
        if total_opponents <= 0:
            return 0.0
        defection_count = np.sum(~recent_history)
        total_actions = recent_history.size
        if total_actions == 0:
            return 0.0
        defection_rate = defection_count / total_actions
        defector_ratio = defection_rate / 0.5 if defection_rate > 0 else 0.0
        defector_ratio = min(defector_ratio, 2.0)
        return defector_ratio

class Strategy_EXPLOITATIVE_308(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Depletion Awareness
    
    Core philosophy: Defect by default to maximize extraction from the common pool,
    while strategically playing occasional cooperation only when high cooperation rates
    and healthy stock levels suggest we can exploit cooperators' restraint.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.D
        if round_number == self.n_rounds - 1:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio < 0.15:
            return Action.D
        if stock_ratio > 0.9:
            return Action.D
        total_opponent_actions = round_number * (self.n_players - 1)
        if total_opponent_actions == 0:
            cooperation_rate = 0.0
        else:
            total_opponent_cooperations = float(np.sum(history.opponent_actions[:round_number, :]))
            cooperation_rate = total_opponent_cooperations / total_opponent_actions
        if cooperation_rate > 0.5 and stock_ratio > 0.4:
            if round_number % 3 == 0:
                return Action.C
            else:
                return Action.D
        if 0.3 < cooperation_rate <= 0.5:
            if round_number == self.n_rounds - 2:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_309(BaseStrategy):
    """
    Dynamic Extraction with Adaptive Defection: An exploitative strategy that maximizes
    payoff by defecting when stock is abundant, adapting based on opponent behavior,
    and switching to endgame ruthlessness in final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = self.capacity * 0.7
        self.threshold_low = self.capacity * 0.25
        self.threshold_adjusted = self.capacity * 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num >= self.n_rounds - 2:
            return Action.D
        if round_num == 0:
            return Action.D
        opponent_defection_rate = self._estimate_opponent_defection_rate(history, round_num)
        if opponent_defection_rate > 0.7:
            return Action.D
        if 0.3 < opponent_defection_rate <= 0.7:
            threshold_high = self.threshold_high * 0.85
            threshold_low = self.threshold_adjusted
        else:
            threshold_high = self.threshold_high
            threshold_low = self.threshold_low
        if stock > threshold_high:
            return Action.D
        elif stock > threshold_low:
            return Action.D
        else:
            return Action.C

    def _estimate_opponent_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Estimate the fraction of opponents defecting in the previous round.
        Uses the most recent completed round (round_num - 1).
        
        opponent_defection_rate = (stock_loss_attributable_to_defection) / (total_possible_defection)
        """
        if round_num < 1 or history is None:
            return 0.5
        prev_round_idx = round_num - 1
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        num_defectors = np.sum(opponent_actions_prev == False)
        if self.n_players - 1 > 0:
            defection_rate = num_defectors / (self.n_players - 1)
        else:
            defection_rate = 0.0
        return defection_rate

class Strategy_EXPLOITATIVE_310(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Decay Detection
    
    Ruthlessly exploits cooperative players while maintaining flexibility to adapt
    when the environment degrades. Treats cooperation as a resource to mine, not a
    norm to reciprocate. Maximizes extraction before commons collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.decay_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        rounds_remaining = self.game_description.n_rounds - state.round_number
        stock = state.current_stock
        self.stock_history.append(stock)
        if stock <= 2 * n:
            return Action.C
        if rounds_remaining == 1:
            return Action.D
        if stock < 2 * n * 1.5 and rounds_remaining > 2:
            return Action.C
        if stock >= capacity * 0.9 and rounds_remaining > 3:
            return Action.D
        if len(self.stock_history) >= 2:
            recent_delta = self.stock_history[-1] - self.stock_history[-2]
            if recent_delta < 0:
                self.decay_count += 1
            else:
                self.decay_count = 0
            if self.decay_count >= 2:
                avg_per_player = stock / max(n, 1)
                threshold = n * 0.6
                if stock < capacity * 0.5:
                    self.decay_count = 0
                    return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_311(BaseStrategy):
    """
    Adaptive Predation with Sustainability Harvesting: An exploitative strategy that
    defects aggressively in early rounds, adapts based on opponent cooperation rates
    in mid-game, and maximizes extraction in endgame while preventing complete collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        early_phase_end = math.floor(self.r / 3)
        if round_num < early_phase_end:
            return Action.D
        endgame_start = math.ceil(2 * self.r / 3)
        if round_num >= endgame_start:
            if round_num == self.r - 1:
                return Action.D
            if stock > self.capacity * 0.4:
                return Action.D
            else:
                rounds_remaining = self.r - round_num
                if rounds_remaining >= 3 and stock / (2 * self.n) > 0:
                    return Action.C
                else:
                    return Action.D
        coop_rate = self._calculate_cooperation_rate(history)
        if stock < self.capacity * 0.2:
            rounds_remaining = self.r - round_num
            if rounds_remaining >= 3 and stock / (2 * self.n) > 0:
                return Action.C
            else:
                return Action.D
        if coop_rate >= 0.7:
            return Action.D
        if coop_rate < 0.4:
            if stock > self.capacity * 0.5:
                return Action.D
            else:
                return Action.C
        if coop_rate >= 0.6:
            if stock < self.capacity * 0.3:
                return Action.C
            else:
                return Action.D
        elif stock < self.capacity * 0.25:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the cooperation rate of opponents in the most recent round.
        Returns a value between 0 and 1.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.5
        most_recent_round = history.opponent_actions[-1, :]
        cooperators = np.sum(most_recent_round)
        total_opponents = len(most_recent_round)
        if total_opponents == 0:
            return 0.5
        return float(cooperators) / float(total_opponents)

class Strategy_EXPLOITATIVE_312(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Conditional Cooperation
    
    Core approach: Systematically defect to capture asymmetric payoffs (D yields stock/n vs C yields stock/2n).
    Cooperate only strategically: (1) as a feigned signal when stock is critically low, (2) never in final 2 rounds,
    (3) escalate defection if opponents show >70% defection rate. Free-ride on opponent cooperation while
    maintaining aggressive posture throughout.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.last_action_was_cooperate = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            self.last_action_was_cooperate = False
            return Action.D
        if current_round >= self.n_rounds - 2:
            self.last_action_was_cooperate = False
            return Action.D
        if current_stock > self.capacity * 0.4:
            self.last_action_was_cooperate = False
            return Action.D
        if current_stock <= self.capacity * 0.4:
            recent_rounds_start = max(0, current_round - 3)
            recent_opponent_actions = history.opponent_actions[recent_rounds_start:current_round, :]
            if recent_opponent_actions.shape[0] > 0:
                total_actions = recent_opponent_actions.size
                cooperations = np.sum(recent_opponent_actions).item()
                defections = total_actions - cooperations
                defection_rate = defections / total_actions if total_actions > 0 else 0.0
            else:
                defection_rate = 0.0
            if defection_rate > 0.7:
                self.last_action_was_cooperate = False
                return Action.D
            if current_stock <= self.capacity * 0.3 and current_round > 1:
                if not self.last_action_was_cooperate:
                    self.last_action_was_cooperate = True
                    return Action.C
                else:
                    self.last_action_was_cooperate = False
                    return Action.D
            self.last_action_was_cooperate = False
            return Action.D
        self.last_action_was_cooperate = False
        return Action.D

class Strategy_EXPLOITATIVE_313(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Dynamic Punishment
    
    Defects by default to maximize individual extraction. Cooperates only 
    instrumentally when stock threatens to collapse, purely to enable future 
    defection. Last round always defects. Treats cooperation as a resource 
    farming technique, not a reciprocal norm.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = self.capacity / 3.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        rounds_remaining = self.n_rounds - round_num
        if round_num == self.n_rounds - 1:
            return Action.D
        if stock <= 0.0:
            return Action.C
        if stock >= 0.95 * self.capacity:
            return Action.D
        if stock < self.threshold and rounds_remaining > 1:
            total_defect_consumption = self.n_players * (stock / self.n_players)
            predicted_stock_after_consumption = stock - total_defect_consumption
            if predicted_stock_after_consumption <= 0.0 or stock < self.capacity / 4.0:
                return Action.C
        if rounds_remaining > 2 and history is not None:
            recent_decline = self._check_three_round_decline(history, round_num)
            if recent_decline and stock < self.capacity / 2.0:
                prob_cooperate = min(0.3, rounds_remaining / self.n_rounds)
                if random.random() < prob_cooperate:
                    return Action.C
        return Action.D

    def _check_three_round_decline(self, history: PlayerHistory, current_round: int) -> bool:
        """Check if stock has shown consistent decline over last 3 rounds."""
        if current_round < 3:
            return False
        recent_rounds = min(3, current_round)
        if recent_rounds < 3:
            return False
        payoff_trend = history.my_payoffs[current_round - 3:current_round]
        if len(payoff_trend) >= 3:
            decline_1 = payoff_trend[0] > payoff_trend[1]
            decline_2 = payoff_trend[1] > payoff_trend[2]
            return decline_1 and decline_2
        return False

class Strategy_EXPLOITATIVE_314(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Exploits the asymmetry between cooperation (S/2n payoff) and defection (S/n payoff).
    Uses stock-aware thresholds and opponent history to maximize extraction while 
    adapting to game phase and pool health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number
        if round_number == 0:
            return Action.D
        if rounds_remaining <= 2:
            return Action.D
        total_opponent_actions = history.opponent_actions[:round_number, :]
        total_observed_rounds = round_number * self.n_players
        if total_observed_rounds > 0:
            cooperation_count = np.sum(total_opponent_actions)
            cooperation_rate = float(cooperation_count) / float(total_observed_rounds)
        else:
            cooperation_rate = 0.0
        if cooperation_rate > 0.7:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio <= 0.2:
            return Action.D
        if stock_ratio > 0.6:
            return Action.D
        if stock_ratio <= 0.3 and rounds_remaining > 3:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_315(BaseStrategy):
    """
    Adaptive Predation with Collapse Prevention: An exploitative strategy that
    defects aggressively to capture disproportionate payoffs while maintaining
    stock sustainability. Uses a 25% capacity threshold as a safety floor, adapts
    based on observed opponent defection rates, and defects unconditionally in
    the final two rounds and first round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.threshold_safe = self.capacity * 0.25
        self.threshold_aggressive = self.capacity * 0.15
        self.threshold_emergency = self.capacity * 0.01

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == self.n_rounds - 1:
            return Action.D
        if round_num == self.n_rounds - 2:
            return Action.D
        if round_num == 0:
            return Action.D
        if stock < self.threshold_emergency:
            return Action.C
        adaptive_threshold = self._compute_adaptive_threshold(history, round_num)
        if stock > adaptive_threshold:
            return Action.D
        else:
            return Action.C

    def _compute_adaptive_threshold(self, history: PlayerHistory, round_num: int) -> float:
        """
        Compute adaptive threshold based on observed opponent defection rate.
        Defection rate uses boolean encoding where False=Defect, True=Cooperate.
        """
        if round_num == 0:
            return self.threshold_safe
        observed_actions = history.opponent_actions[:round_num, :]
        total_cooperations = np.sum(observed_actions)
        total_observations = observed_actions.size
        if total_observations == 0:
            return self.threshold_safe
        cooperation_rate = total_cooperations / total_observations
        defection_rate = 1.0 - cooperation_rate
        if defection_rate < 0.5:
            return self.threshold_aggressive
        elif defection_rate > 0.7:
            return self.threshold_safe
        else:
            return self.threshold_safe

class Strategy_EXPLOITATIVE_316(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Selective Cooperation
    
    Prioritizes individual payoff maximization by defecting aggressively when stock is healthy,
    then adaptively shifting to cooperation when stock depletion threatens future payoffs.
    Always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = game_description.capacity * 0.4
        self.prev_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.D
        adjusted_threshold = self.critical_threshold
        stock_change = state.current_stock - self.prev_stock
        capacity = self.game_description.capacity
        if stock_change < -0.1 * capacity:
            adjusted_threshold = self.critical_threshold * 0.9
        elif stock_change > 0.05 * capacity:
            adjusted_threshold = self.critical_threshold * 1.05
        rounds_remaining = self.game_description.n_rounds - state.round_number
        if rounds_remaining <= 3 and state.current_stock <= self.critical_threshold * 0.5:
            self.prev_stock = state.current_stock
            return Action.C
        if state.current_stock > adjusted_threshold:
            self.prev_stock = state.current_stock
            return Action.D
        else:
            self.prev_stock = state.current_stock
            return Action.C

class Strategy_EXPLOITATIVE_317(BaseStrategy):
    """
    Adaptive Extraction Strategy for Common Pool Resource Game.
    
    Exploits cooperative players through conditional defection based on stock health,
    opponent behavior, and endgame positioning. Treats cooperation as a resource to extract
    rather than a norm to uphold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == self.n_rounds - 1:
            return Action.D
        rounds_remaining = self.n_rounds - round_num
        if rounds_remaining <= 2:
            return Action.D
        if stock > self.capacity * 0.6:
            return Action.D
        if stock <= self.capacity * 0.2:
            return Action.D
        if stock <= self.capacity * 0.1:
            return Action.D
        if stock >= self.capacity * 0.95:
            return Action.D
        if round_num == 0:
            return Action.D
        if history is not None and round_num > 0:
            prev_round_idx = round_num - 1
            defectors_count = np.sum(history.opponent_actions[prev_round_idx, :] == False)
            defection_ratio = defectors_count / self.n_players
            if defection_ratio >= 0.5:
                return Action.D
            if defection_ratio < 0.5:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_318(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Defection
    
    Exploits asymmetry in payoff structure (D yields 2x payoff of C) while adapting
    to resource depletion dynamics across three phases:
    - Early game: Aggressive defection to establish dominance
    - Mid-game: Conditional defection based on stock level and opponent behavior
    - End-game: Final extraction with last-round unconditional defection
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.early_threshold = math.ceil(self.n_rounds / 3)
        self.mid_threshold = math.ceil(2 * self.n_rounds / 3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        defection_rate = self._calculate_defection_rate(history)
        if current_round < self.early_threshold:
            return self._early_game_decision(current_stock, defection_rate)
        elif current_round < self.mid_threshold:
            return self._mid_game_decision(current_stock, defection_rate)
        else:
            return self._end_game_decision(current_round, current_stock, defection_rate)

    def _calculate_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the observed defection rate from opponents.
        Defection is encoded as False (0), Cooperation as True (1).
        """
        if history.opponent_actions.size == 0:
            return 0.5
        total_actions = history.opponent_actions.size
        total_cooperations = np.sum(history.opponent_actions)
        defection_count = total_actions - total_cooperations
        if total_actions == 0:
            return 0.5
        return defection_count / total_actions

    def _early_game_decision(self, current_stock: float, defection_rate: float) -> Action:
        """
        Phase 1: Rounds 1 to ⌊r/3⌋
        Aggressive exploitation. Defect unless stock is critically depleted.
        """
        if current_stock > self.capacity * 0.4:
            return Action.D
        else:
            return Action.C

    def _mid_game_decision(self, current_stock: float, defection_rate: float) -> Action:
        """
        Phase 2: Rounds ⌊r/3⌋ + 1 to ⌊2r/3⌋
        Conditional exploitation based on stock level and observed defection.
        """
        if current_stock > self.capacity * 0.5:
            return Action.D
        elif current_stock > self.capacity * 0.3:
            if defection_rate > 0.6:
                return Action.D
            else:
                return Action.D
        else:
            return Action.C

    def _end_game_decision(self, current_round: int, current_stock: float, defection_rate: float) -> Action:
        """
        Phase 3: Rounds ⌊2r/3⌋ + 1 to r
        Final extraction with unconditional defection in last round.
        """
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock > self.capacity * 0.4:
            return Action.D
        elif defection_rate > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_319(BaseStrategy):
    """
    Adaptive Predation: An exploitative strategy that parasitizes cooperative behavior
    while avoiding mutual defection traps through pool-health-based decision rules.
    
    Core mechanism: Defect aggressively when the pool is healthy, switch to cooperation
    only when the pool is critical to preserve future exploitation opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if current_stock < 1.0:
            return Action.C
        if round_number == 0:
            return Action.D
        if health_ratio > 0.6:
            return Action.D
        elif health_ratio > 0.3:
            estimated_cooperators = self._estimate_cooperators(history, round_number)
            if estimated_cooperators >= 1:
                return Action.D
            else:
                return Action.C
        elif round_number == self.n_rounds - 1:
            return Action.D
        else:
            return Action.C

    def _estimate_cooperators(self, history: PlayerHistory, round_number: int) -> int:
        """
        Estimate number of cooperating players based on observed consumption pattern.
        
        Compare observed consumption against expected ranges:
        - Low consumption (< 50% of previous stock) suggests high cooperation
        - High consumption (≥ 75% of previous stock) suggests low cooperation
        """
        if round_number < 1:
            return 0
        previous_round_idx = round_number - 1
        my_consumption = history.my_payoffs[previous_round_idx]
        opponent_consumption = history.opponent_payoffs[previous_round_idx].sum()
        estimated_total_consumption = my_consumption + opponent_consumption
        consumption_ratio = estimated_total_consumption / self.capacity if self.capacity > 0 else 0.0
        if consumption_ratio < 0.5:
            return max(1, self.n_players - 1)
        elif consumption_ratio >= 0.75:
            return 0
        else:
            return max(1, self.n_players // 2)

class Strategy_EXPLOITATIVE_320(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Core philosophy: Exploit the 2:1 payoff asymmetry between defection and cooperation.
    Defect whenever stock is above threshold, cooperate only when stock is critically low
    or in the final round. Monitor for collapse and briefly cooperate to prevent total
    resource destruction that would harm even this strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = self.capacity / (2 * self.n)
        self.cooperate_counter = 0
        self.recent_stocks = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num == self.r - 1:
            return Action.D
        if stock <= self.threshold / 2:
            return Action.C
        if round_num >= 3 and history is not None:
            current_stocks = self._estimate_stock_history(history, stock)
            if len(current_stocks) >= 3:
                recent_declines = [current_stocks[-3] - current_stocks[-2], current_stocks[-2] - current_stocks[-1], current_stocks[-1] - stock]
                avg_decline = np.mean(recent_declines)
                if avg_decline > self.capacity * 0.15:
                    if self.cooperate_counter < 2:
                        self.cooperate_counter += 1
                        return Action.C
                    else:
                        self.cooperate_counter = 0
        if stock > self.threshold:
            return Action.D
        else:
            return Action.C

    def _estimate_stock_history(self, history: PlayerHistory, current_stock: float) -> list:
        """
        Estimate stock levels from history by working backwards from current stock.
        This is a heuristic since we don't have explicit stock history.
        """
        estimated = [current_stock]
        for round_idx in range(len(history.my_actions) - 1, -1, -1):
            cooperators = sum(history.opponent_actions[round_idx, :])
            my_action = history.my_actions[round_idx]
            if my_action:
                cooperators += 1
            defectors = self.n - cooperators
            estimated.insert(0, current_stock + defectors * (current_stock / self.n) / 2)
        return estimated[:len(history.my_actions)]

class Strategy_EXPLOITATIVE_321(BaseStrategy):
    """
    Exploitative Resource Draining with Conditional Defection.
    
    Maximizes personal payoff by exploiting the asymmetry between cooperative 
    (stock/2n) and defective (stock/n) consumption. Defects aggressively when 
    stock is healthy, switches to selective cooperation only when stock is 
    critically low or endgame requires preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        remaining_rounds = self.n_rounds - round_number
        if round_number == self.n_rounds - 1:
            return Action.D
        if current_stock < self.capacity * 0.3:
            return Action.C
        if current_stock >= self.capacity * 0.6:
            return Action.D
        if self.capacity * 0.3 <= current_stock < self.capacity * 0.6:
            if remaining_rounds > 2:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_322(BaseStrategy):
    """
    Adaptive Predation: Exploitative Common Pool Resource Strategy
    
    Core approach: Defect when stock is healthy to exploit cooperators' restraint,
    cooperate only when stock is critically depleted to preserve exploitable resources,
    and always defect in terminal rounds. Uses adaptive recovery signals to reset
    the exploitable stock cycle.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.recovery_phase_counter = 0
        self.last_stock_for_trend = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round >= self.n_rounds - 1:
            return Action.D
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if self.n_players >= 8:
            defection_threshold = 0.55
        elif self.n_players == 2:
            defection_threshold = 0.75
        else:
            defection_threshold = 0.65
        avg_trend = 0.0
        if len(history.my_actions) > 10:
            old_stock = history.opponent_payoffs[-10, 0]
            avg_trend = (current_stock - old_stock) / 10.0
        defections_so_far = np.sum(~history.my_actions[:current_round])
        if avg_trend < 0 and defections_so_far > self.n_rounds / 2:
            if self.recovery_phase_counter < 3:
                self.recovery_phase_counter += 1
                return Action.C
            else:
                self.recovery_phase_counter = 0
        else:
            self.recovery_phase_counter = 0
        if health_ratio > defection_threshold:
            return Action.D
        elif health_ratio > 0.25:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_323(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State-Aware Defection
    
    Maximizes personal payoff by defaulting to defection while selectively
    cooperating only to prevent pool collapse that would harm future extraction.
    Exploits cooperators, adapts to critical stock depletion, and maintains
    aggressive extraction throughout the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        if stock <= 0:
            return Action.C
        if round_num == self.r - 1:
            if stock > self.capacity * 0.3:
                return Action.D
            else:
                return Action.C
        rounds_remaining = self.r - round_num
        if round_num > self.r - 2 and stock < self.capacity / 3:
            return Action.C
        if round_num <= 1:
            return Action.D
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0
        if stock_ratio < 0.25 and rounds_remaining >= 2:
            if random.random() < 0.6:
                return Action.D
            else:
                return Action.C
        if history is not None and round_num >= 2:
            last_3_start = max(0, round_num - 3)
            for opponent_idx in range(self.n - 1):
                opponent_recent_actions = history.opponent_actions[last_3_start:round_num, opponent_idx]
                if len(opponent_recent_actions) >= 3:
                    if np.all(opponent_recent_actions[-3:]):
                        return Action.D
        if history is not None and round_num >= 1:
            prev_round_actions = history.opponent_actions[round_num - 1, :]
            n_defectors_prev = np.sum(~prev_round_actions)
            defection_rate_prev = n_defectors_prev / (self.n - 1) if self.n > 1 else 0
            if defection_rate_prev >= 0.6:
                if stock > self.capacity * 0.5:
                    return Action.D
                elif random.random() < 0.7:
                    return Action.D
                else:
                    return Action.C
            elif defection_rate_prev < 0.3:
                return Action.D
        if stock > self.capacity * 0.95:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_324(BaseStrategy):
    """
    Conditional Adaptive Defection (CAD) Strategy
    
    Exploits cooperative players through adaptive defection based on game phase,
    stock levels, and observed opponent cooperation rates. Implements backward induction
    for endgame dominance and stock-state adaptation for dynamic resource extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.reconnaissance_rounds = min(3, math.ceil(0.2 * self.n_rounds))
        self.penultimate_round = self.n_rounds - 1
        self.final_round = self.n_rounds - 1
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        self.stock_history.append(current_stock)
        if round_num == self.final_round:
            return Action.D
        if round_num < self.reconnaissance_rounds:
            return Action.D
        if round_num == self.penultimate_round:
            return Action.D
        if current_stock <= 2 * self.n_players:
            return Action.D
        if current_stock <= self.capacity / 2:
            return Action.D if random.random() < 0.9 else Action.C
        if current_stock > self.capacity / 2:
            opponent_coop_rate = self._calculate_opponent_coop_rate(history)
            if opponent_coop_rate > 0.6:
                return Action.D if random.random() < 0.95 else Action.C
            else:
                defection_prob = 0.7
                if self._is_stock_trending_negative(history):
                    defection_prob = min(0.95, defection_prob + 0.1)
                if opponent_coop_rate > 0.75:
                    defection_prob = min(0.95, defection_prob + 0.15)
                elif opponent_coop_rate < 0.25:
                    defection_prob = min(0.95, defection_prob + 0.05)
                return Action.D if random.random() < defection_prob else Action.C
        return Action.D

    def _calculate_opponent_coop_rate(self, history: None | PlayerHistory) -> float:
        """
        Calculate the average cooperation rate of opponents across all observed rounds.
        Returns 0.5 if no history available (neutral assumption).
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.5
        total_opponent_actions = history.opponent_actions.size
        if total_opponent_actions == 0:
            return 0.5
        total_cooperations = np.sum(history.opponent_actions)
        return float(total_cooperations) / float(total_opponent_actions)

    def _is_stock_trending_negative(self, history: None | PlayerHistory) -> bool:
        """
        Check if stock has been declining over the last 3 rounds.
        Returns False if insufficient history.
        """
        if len(self.stock_history) < 4:
            return False
        stock_3_rounds_ago = self.stock_history[-4]
        current_stock = self.stock_history[-1]
        if stock_3_rounds_ago <= 0:
            return False
        trend = (current_stock - stock_3_rounds_ago) / stock_3_rounds_ago
        return trend < 0

class Strategy_EXPLOITATIVE_325(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Threshold Monitoring
    
    This strategy exploits the asymmetry between cooperation and defection by:
    1. Defecting aggressively in early game while stock is high
    2. Using a stock threshold to pivot to cooperation only when necessary
    3. Adapting behavior based on stock depletion patterns and game phase
    4. Always defecting in the final round (no future consequences)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.round_pivot = max(1, math.floor(self.r * 0.6))
        self.threshold = self.capacity * (2 / self.n + 0.1)
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        self.stock_history.append(current_stock)
        if current_round == self.r - 1:
            return Action.D
        if current_round < self.round_pivot:
            return Action.D
        if current_round >= self.r - 3:
            if current_stock > self.threshold * 0.8:
                return Action.D
            else:
                return Action.C
        critical_level = self.capacity / self.n
        if current_stock < critical_level:
            return Action.D
        if len(self.stock_history) >= 2:
            stock_increased = self.stock_history[-1] > self.stock_history[-2]
            if stock_increased and current_stock > self.capacity * 0.5:
                return Action.D
        if len(self.stock_history) >= 3:
            recent_avg = np.mean(self.stock_history[-3:])
            if recent_avg > self.capacity * 0.8:
                return Action.D
        if len(self.stock_history) >= 2:
            stock_decrease_rate = self.stock_history[-2] - current_stock
            if stock_decrease_rate > self.capacity * 0.15:
                return Action.D
        if current_stock > self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_326(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Maximizes personal payoff by exploiting the 2x asymmetry between defection and cooperation,
    while adaptively monitoring resource sustainability and opponent clustering behavior.
    Transitions through early game (probe defection), mid game (opportunistic exploitation),
    and late game (terminal defection) phases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        stock = state.current_stock
        r = self.n_rounds
        n = self.n_players
        capacity = self.capacity
        if t == 0:
            return Action.D
        phase_early_cutoff = max(1, r // 3)
        phase_mid_cutoff = max(1, 2 * r // 3)
        if t <= phase_early_cutoff and t > 0:
            num_defectors_prev = self._count_defectors_in_round(history, t - 1)
            if num_defectors_prev >= n / 2:
                return Action.D
            elif stock > 0.6 * capacity:
                return Action.D
            else:
                return Action.C
        elif t <= phase_mid_cutoff:
            sustainability = stock / max(capacity, 1e-09)
            num_defectors_prev = self._count_defectors_in_round(history, t - 1)
            defection_pressure = num_defectors_prev / n
            rounds_left = r - t
            if sustainability > 0.5 and defection_pressure < 0.6:
                return Action.D
            elif sustainability <= 0.5 or defection_pressure >= 0.6:
                if rounds_left > r / 4:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        elif stock <= 2 * n and t == r - 1:
            return Action.C
        else:
            return Action.D

    def _count_defectors_in_round(self, history: PlayerHistory, round_idx: int) -> int:
        """
        Count the number of defectors in a given round.
        True = Cooperate (1), False = Defect (0)
        Defectors are those with False actions.
        """
        if round_idx < 0 or round_idx >= len(history.opponent_actions):
            return 0
        defectors = np.sum(~history.opponent_actions[round_idx, :])
        return int(defectors)

class Strategy_EXPLOITATIVE_327(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy using Adaptive Predation with Depletion Monitoring.
    
    Core approach: Defect as the dominant strategy in most situations, with adaptive thresholds
    based on stock levels to maximize personal extraction while exploiting pool dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        upper_threshold = self.capacity * 0.7
        lower_threshold = 2 * self.n_players * 1.5
        if current_stock > upper_threshold:
            return Action.D
        elif current_stock <= lower_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_328(BaseStrategy):
    """
    Adaptive Predation: An exploitative Common Pool Resource strategy that maximizes
    extraction through stock-dependent defection while adaptively preserving the pool
    to enable future exploitation. Defects when stock is healthy, cooperates tactically
    when stock is critical to prevent complete collapse, and always defects in the
    final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.total_rounds - 1:
            return Action.D
        rounds_remaining = self.total_rounds - current_round
        critical_threshold = 2 * self.n_players * (1 + rounds_remaining / self.total_rounds)
        if rounds_remaining <= 2:
            critical_threshold *= 1.3
        if current_stock < critical_threshold:
            return Action.C
        else:
            if history is not None and current_round > 0:
                total_opponent_defections = 0
                total_opponent_actions = 0
                for round_idx in range(current_round):
                    for opponent_idx in range(self.n_players - 1):
                        if not history.opponent_actions[round_idx, opponent_idx]:
                            total_opponent_defections += 1
                        total_opponent_actions += 1
                if total_opponent_actions > 0:
                    opponent_defection_ratio = total_opponent_defections / total_opponent_actions
                    if opponent_defection_ratio > 0.7:
                        return Action.D
                    elif opponent_defection_ratio < 0.3:
                        return Action.D
            return Action.D

class Strategy_EXPLOITATIVE_329(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Dynamic Depletion
    
    Defects aggressively early when the pool is healthy, then adapts based on 
    depletion ratio and collapse rate. Uses probabilistic defection in mid-range 
    depletion, switches to cooperation when critically depleted, and maximizes 
    final round extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        depletion_ratio = (self.capacity - current_stock) / self.capacity if self.capacity > 0 else 0.0
        if self.n_players == 2:
            threshold_1 = 0.4
            threshold_2 = 0.85
        elif self.n_players >= 10:
            threshold_1 = 0.6
            threshold_2 = 0.85
        else:
            threshold_1 = 0.5
            threshold_2 = 0.85
        if round_number == self.n_rounds - 1:
            return Action.D
        if current_stock > 0.95 * self.capacity:
            return Action.D
        if current_stock < 1e-06:
            return Action.C
        if depletion_ratio < threshold_1:
            return Action.D
        if depletion_ratio < threshold_2:
            defect_prob = 0.7
            if round_number >= 2 and round_number < self.n_rounds - 1:
                recent_decline = self._calculate_recent_decline(history)
                if recent_decline > 0.15 * self.capacity:
                    defect_prob -= 0.2
                    defect_prob = max(0.0, defect_prob)
            return Action.D if random.random() < defect_prob else Action.C
        if current_stock > 2 * self.n_players:
            return Action.C
        return Action.C

    def _calculate_recent_decline(self, history: PlayerHistory) -> float:
        """
        Calculate average stock decline over the last 3 rounds based on payoffs.
        
        Stock decline per round ≈ total consumption = sum of all player payoffs
        (since payoff = consumption in the pool game)
        """
        if history is None or len(history.my_payoffs) < 2:
            return 0.0
        lookback = min(3, len(history.my_payoffs))
        recent_rounds = history.my_payoffs[-lookback:]
        if lookback > 0 and len(history.opponent_payoffs) >= lookback:
            recent_opponent_payoffs = history.opponent_payoffs[-lookback:]
            total_consumption_per_round = recent_rounds + np.sum(recent_opponent_payoffs, axis=1)
        else:
            total_consumption_per_round = recent_rounds
        if len(total_consumption_per_round) > 0:
            avg_decline = float(np.mean(total_consumption_per_round))
        else:
            avg_decline = 0.0
        return avg_decline

class Strategy_EXPLOITATIVE_330(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Conditional Cooperation
    
    Core philosophy: Cooperate minimally to sustain the resource, defect aggressively
    whenever the stock buffer permits. Exploits cooperators by detecting high cooperation
    rates and defecting harder. Uses stock-threshold-based decision making with round-dependent
    modulation and observation-based adaptive refinement.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.epsilon = 0.15

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == 0:
            if self.n <= 3:
                return Action.C
            else:
                return Action.D
        if current_round == self.r - 1 and current_stock > 0:
            return Action.D
        if current_stock > 0.95 * self.capacity:
            return Action.D
        if current_stock < self.capacity * 0.1 * self.n:
            return Action.C
        base_threshold = self.capacity * (1.0 / self.n + self.epsilon)
        threshold = base_threshold
        if current_round < self.r / 3:
            threshold = base_threshold
        elif current_round < 2 * self.r / 3:
            threshold = base_threshold * 0.95
        else:
            threshold = base_threshold * 0.85
        coop_count = int(np.sum(history.opponent_actions[:current_round, :]))
        total_opponent_actions = current_round * self.n
        coop_rate = coop_count / max(total_opponent_actions, 1)
        if coop_rate > 0.7:
            threshold = threshold * 0.9
        elif coop_rate < 0.3:
            threshold = threshold * 1.05
        depletion = (self.capacity - current_stock) / max(current_round, 1)
        if depletion > self.capacity * 0.05:
            threshold = threshold * 0.9
        elif depletion < self.capacity * 0.01:
            threshold = threshold * 1.1
        if current_stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_331(BaseStrategy):
    """
    Adaptive Predation: An exploitative strategy that defects by default to capture
    maximum payoff, but strategically cooperates when stock levels fall below 30% of
    capacity to allow recovery and sustain continued exploitation. Defects aggressively
    in the final two rounds regardless of stock state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.n_rounds - 1:
            return Action.D
        if round_number == self.n_rounds - 2:
            return Action.D
        if current_stock <= 0:
            return Action.C
        critical_threshold = 0.3 * self.capacity
        if current_stock <= critical_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_332(BaseStrategy):
    """
    Exploitative Strategy: Unconditional Defection with Collapse Acceleration
    
    Core behavior: DEFECT every round without exception.
    
    Rationale:
    - Payoff dominance: S/n (defect) > S/2n (cooperate) for all S > 0
    - Free-rides on cooperative players' stock maintenance efforts
    - Maximizes individual extraction before resource collapse
    - No credible punishment mechanism in simultaneous-move games
    - Optimal in both early rounds (exploit cooperation) and late rounds (extract from ruins)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_EXPLOITATIVE_333(BaseStrategy):
    """
    Adaptive Predation with Depletion Awareness: An exploitative strategy that defects by default,
    cooperates only in round 2 as a one-time probe to identify opponent types, then relentlessly
    exploits cooperators and tit-for-tatters while matching defectors. Maximizes extraction across
    all game phases using stock awareness and temporal exploitation mechanics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == 1:
            return Action.C
        if current_stock < 2 * self.n_players:
            return Action.D
        opponent_last_round = history.opponent_actions[current_round - 1, :]
        any_opponent_cooperated = bool(np.any(opponent_last_round))
        if any_opponent_cooperated:
            return Action.D
        all_opponents_defected = not any_opponent_cooperated
        if all_opponents_defected:
            return Action.D
        rounds_remaining = self.n_rounds - current_round
        if current_stock > self.capacity * 0.8 and rounds_remaining > self.n_rounds / 2:
            return Action.D
        if current_stock < self.capacity * 0.3 and rounds_remaining <= self.n_rounds / 4:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_334(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Resource Monitoring
    
    Ruthlessly extracts value from the common pool by defecting when stock levels
    exceed dynamically calculated thresholds. Thresholds adapt based on game phase:
    - Early game (rounds 1-r/3): threshold = 0.7 × capacity
    - Mid game (rounds r/3-2r/3): threshold = 0.5 × capacity
    - Late game (rounds 2r/3-r): threshold = 0.2 × capacity
    
    Cooperates only to prevent stock collapse below critical regeneration level (2n).
    Exploits the 2x payoff asymmetry between defection (S/n) and cooperation (S/2n).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.minimum_viable_stock = 2 * self.n_players
        self.prev_stock = None
        self.stock_recovery_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.D
        rounds_remaining = self.n_rounds - round_number
        defection_threshold = self._calculate_defection_threshold(round_number, rounds_remaining)
        estimated_stock_after_defection = current_stock - current_stock / self.n_players
        if current_stock < self.minimum_viable_stock and estimated_stock_after_defection < self.minimum_viable_stock:
            return Action.C
        if history is not None and round_number >= 2:
            if current_stock >= 0.9 * self.capacity:
                self.stock_recovery_counter += 1
                if self.stock_recovery_counter >= 2:
                    defection_threshold = max(0.1 * self.capacity, defection_threshold - 0.1 * self.capacity)
            else:
                self.stock_recovery_counter = 0
        if history is not None and self.prev_stock is not None:
            stock_decline_ratio = current_stock / (self.prev_stock + 1e-09)
            if stock_decline_ratio < 0.7:
                self.prev_stock = current_stock
                return Action.C
        self.prev_stock = current_stock
        if current_stock >= defection_threshold:
            return Action.D
        else:
            return Action.C

    def _calculate_defection_threshold(self, round_number: int, rounds_remaining: int) -> float:
        """
        Calculate adaptive defection threshold based on game phase.
        
        Phase 1 (Early): rounds 0 to r/3 → threshold = 0.7 × capacity
        Phase 2 (Mid): rounds r/3 to 2r/3 → threshold = 0.5 × capacity
        Phase 3 (Late): rounds 2r/3 to r → threshold = 0.2 × capacity
        """
        third = self.n_rounds / 3
        if round_number < third:
            return 0.7 * self.capacity
        elif round_number < 2 * third:
            return 0.5 * self.capacity
        else:
            return 0.2 * self.capacity

class Strategy_EXPLOITATIVE_335(BaseStrategy):
    """
    Adaptive Depletion: Exploitative common pool resource strategy that defaults to defection
    while selectively cooperating to prevent collapse and gather information about opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        rounds_remaining = self.n_rounds - round_num - 1
        if round_num == self.n_rounds - 1:
            return Action.D
        if stock < 2 * self.n_players and rounds_remaining > 0:
            return Action.C
        if round_num <= 1 and stock > 1.5 * self.capacity:
            return Action.C
        if stock >= 0.85 * self.capacity:
            growth_last_round = self._calculate_historical_growth(history, round_num)
            if growth_last_round > 0:
                cooperation_probability = min(0.3, 1.0 / (rounds_remaining + 1))
                if random.random() < cooperation_probability:
                    return Action.C
        return Action.D

    def _calculate_historical_growth(self, history: None | PlayerHistory, round_num: int) -> float:
        """
        Calculate stock growth from the previous round.
        Returns 0 if no previous round exists or cannot be calculated.
        """
        if history is None or round_num == 0:
            return 0.0
        prev_round_idx = round_num - 1
        prev_cooperators = int(np.sum(history.opponent_actions[prev_round_idx, :]))
        my_prev_action = history.my_actions[prev_round_idx]
        if my_prev_action:
            prev_cooperators += 1
        prev_defectors = self.n_players - prev_cooperators
        stock_before_prev = self._estimate_stock_before_round(history, prev_round_idx)
        if stock_before_prev <= 0:
            return 0.0
        consumption = prev_cooperators * (stock_before_prev / (2 * self.n_players))
        consumption += prev_defectors * (stock_before_prev / self.n_players)
        stock_after_consumption = stock_before_prev - consumption
        if stock_after_consumption < 0:
            stock_after_consumption = 0.0
        growth = 2.0 * stock_after_consumption * (1.0 - stock_after_consumption / self.capacity)
        return growth

    def _estimate_stock_before_round(self, history: None | PlayerHistory, round_idx: int) -> float:
        """
        Estimate the stock level before a given round.
        Uses backward inference from current stock and consumption history.
        """
        if history is None or round_idx < 0:
            return self.capacity
        estimated_stock = self.capacity
        for t in range(round_idx):
            cooperators = int(np.sum(history.opponent_actions[t, :]))
            if history.my_actions[t]:
                cooperators += 1
            defectors = self.n_players - cooperators
            consumption = cooperators * (estimated_stock / (2 * self.n_players))
            consumption += defectors * (estimated_stock / self.n_players)
            stock_after_consumption = estimated_stock - consumption
            if stock_after_consumption < 0:
                stock_after_consumption = 0.0
            growth = 2.0 * stock_after_consumption * (1.0 - stock_after_consumption / self.capacity)
            estimated_stock = min(stock_after_consumption + growth, self.capacity)
        return estimated_stock

class Strategy_EXPLOITATIVE_336(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Resource Depletion Sensing
    
    A three-phase strategy that treats cooperation as an exploitative tool and weaponizes
    resource depletion. Defects aggressively in early phases to extract asymmetric payoffs,
    accelerates resource collapse in middle phases, and optimizes final extraction in endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.phase1_end = math.floor(self.n_rounds / 3)
        self.phase2_end = math.floor(2 * self.n_rounds / 3)

    def _determine_phase(self, round_number: int) -> int:
        """Determine which phase we're in (1, 2, or 3)"""
        if round_number <= self.phase1_end:
            return 1
        elif round_number <= self.phase2_end:
            return 2
        else:
            return 3

    def _has_mixed_play_last_round(self, history: PlayerHistory) -> bool:
        """Check if last round had mixed play (some C, some D)"""
        last_round_actions = history.opponent_actions[-1, :]
        cooperators = int(np.sum(last_round_actions))
        return 0 < cooperators < self.n_players

    def _all_played_c_last_round(self, history: PlayerHistory) -> bool:
        """Check if all opponents played C in last round"""
        last_round_actions = history.opponent_actions[-1, :]
        return bool(np.all(last_round_actions))

    def _majority_c_last_round(self, history: PlayerHistory) -> bool:
        """Check if majority of opponents played C in last round"""
        last_round_actions = history.opponent_actions[-1, :]
        cooperators = int(np.sum(last_round_actions))
        return cooperators >= math.ceil(self.n_players / 2)

    def _my_payoff_last_round(self, history: PlayerHistory) -> float:
        """Get my payoff from last round"""
        return history.my_payoffs[-1]

    def _expected_mutual_c_payoff(self, stock: float) -> float:
        """Expected payoff if all play C"""
        return stock / (2 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        if stock <= self.capacity * 0.05:
            return Action.C
        if round_num == self.n_rounds - 1:
            if stock > self.capacity * 0.2:
                return Action.D
            else:
                return Action.C
        phase = self._determine_phase(round_num)
        if phase == 1:
            if stock > self.capacity * 0.75:
                return Action.D
            if self._has_mixed_play_last_round(history):
                return Action.D
            if stock <= self.capacity * 0.5 and self._all_played_c_last_round(history):
                my_payoff = self._my_payoff_last_round(history)
                expected_mutual_c = self._expected_mutual_c_payoff(stock)
                if my_payoff > expected_mutual_c:
                    return Action.C
            return Action.D
        elif phase == 2:
            if stock > self.capacity * 0.3:
                return Action.D
            if stock <= self.capacity * 0.2 and self._majority_c_last_round(history):
                expected_d_payoff = stock / (4 * self.n_players) if stock > 0 else 0.0
                actual_c_payoff = stock / (2 * self.n_players)
                if actual_c_payoff > expected_d_payoff:
                    return Action.C
            return Action.D
        else:
            rounds_remaining = self.n_rounds - round_num
            if rounds_remaining <= 3:
                return Action.D
            if stock > self.capacity * 0.1:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_337(BaseStrategy):
    """
    Adaptive Threshold Defection (ATD) strategy for Common Pool Resource games.
    
    Exploits asymmetry between cooperators and defectors while maintaining flexibility
    to adapt to varying player populations and pool health. Prioritizes extraction in
    favorable conditions and switches to cooperation only when pool depletion threatens
    future payoff opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - round_num - 1
        if round_num == 0:
            return Action.D
        if rounds_remaining == 0:
            return Action.D
        critical_threshold = self.capacity * 0.15
        if current_stock < critical_threshold:
            return Action.C
        cooperation_rate = self._calculate_cooperation_rate(history)
        if cooperation_rate > 0.75:
            return Action.D
        if cooperation_rate < 0.25:
            return Action.D
        healthy_threshold = self.capacity * 0.6
        if current_stock > healthy_threshold:
            return Action.D
        else:
            return Action.C

    def _calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the average cooperation rate of opponents across all completed rounds.
        Returns a value between 0.0 and 1.0.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.5
        total_cooperators = np.sum(history.opponent_actions)
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.5
        cooperation_rate = total_cooperators / total_actions
        return float(cooperation_rate)

class Strategy_EXPLOITATIVE_338(BaseStrategy):
    """
    Adaptive Predation: An exploitative common pool resource strategy that defects when stock is high,
    cooperates strategically to maintain resource viability in mid-game, and defects ruthlessly in end-game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.depletion_threshold = self.capacity * 0.35
        self.low_stock_threshold = self.capacity * 0.15
        self.critical_threshold = self.n_rounds / 3.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= self.critical_threshold:
            return Action.D
        if current_stock > self.depletion_threshold:
            return Action.D
        elif current_stock > self.low_stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_339(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Extraction with Collapse Management
    
    This strategy exploits the asymmetry between cooperative and defective payoffs
    while managing the resource to prevent premature collapse. It defects when stock
    is abundant, cooperates only when necessary to preserve future defection opportunities,
    and always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            if stock > 0:
                return Action.D
            else:
                return Action.C
        if stock < self.capacity / self.n_players:
            return Action.C
        cooperation_rate = self._calculate_cooperation_rate(history, round_num)
        base_threshold = self.capacity * (1 - 1 / self.n_rounds)
        if cooperation_rate > 0.5:
            threshold = base_threshold
        else:
            threshold = base_threshold * 1.1
        if stock > threshold:
            return Action.D
        else:
            return Action.C

    def _calculate_cooperation_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the cooperation rate of opponents across all observed rounds.
        Returns a value between 0 and 1.
        """
        if round_num == 0:
            return 0.5
        observed_rounds = history.opponent_actions[:round_num, :]
        if observed_rounds.size == 0:
            return 0.5
        total_actions = observed_rounds.size
        cooperations = np.sum(observed_rounds)
        if total_actions == 0:
            return 0.5
        return float(cooperations) / float(total_actions)

class Strategy_EXPLOITATIVE_340(BaseStrategy):
    """
    Adaptive Predation: An exploitative strategy that defaults to defection while
    conditionally cooperating only when stock preservation enables higher future payoffs.
    Systematically exploits cooperators while managing stock depletion through tactical cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        rounds_remaining = self.n_rounds - round_num
        if round_num == self.n_rounds - 1:
            return Action.D
        if round_num == self.n_rounds - 2:
            if stock < 0.3 * self.capacity:
                return Action.C
            return Action.D
        depletion_rate = (self.capacity - stock) / self.capacity if self.capacity > 0 else 0.0
        if depletion_rate > 0.7:
            return Action.D
        if depletion_rate < 0.2:
            return Action.D
        if stock < self.capacity * (1.0 - 1.0 / self.n_rounds):
            projected_stock = self._simulate_round_outcome(stock, cooperate=True)
            defection_next = projected_stock / self.n_players if self.n_players > 0 else 0
            defection_now = stock / self.n_players if self.n_players > 0 else 0
            if defection_next > defection_now * 1.1 and rounds_remaining > 2:
                return Action.C
        return Action.D

    def _simulate_round_outcome(self, stock: float, cooperate: bool) -> float:
        """
        Simulate stock level after one round assuming this player's action
        and estimate of opponent behavior based on current stock health.
        """
        if stock <= 0:
            return 0.0
        depletion_rate = (self.capacity - stock) / self.capacity if self.capacity > 0 else 0.0
        if depletion_rate > 0.6:
            estimated_defectors = self.n_players - 1
        elif depletion_rate > 0.3:
            estimated_defectors = (self.n_players - 1) // 2
        else:
            estimated_defectors = max(0, (self.n_players - 1) // 3)
        estimated_cooperators = self.n_players - 1 - estimated_defectors
        my_consumption = stock / (2.0 * self.n_players) if cooperate else stock / self.n_players
        opponent_consumption = estimated_cooperators * stock / (2.0 * self.n_players) + estimated_defectors * stock / self.n_players
        total_consumption = my_consumption + opponent_consumption
        stock_after_consumption = max(0.0, stock - total_consumption)
        if self.capacity > 0:
            growth = 2.0 * stock_after_consumption * (1.0 - stock_after_consumption / self.capacity)
        else:
            growth = 0.0
        new_stock = min(stock_after_consumption + growth, self.capacity)
        return max(0.0, new_stock)

class Strategy_EXPLOITATIVE_341(BaseStrategy):
    """
    Adaptive Predation: An exploitative strategy that always defects while monitoring
    opponent behavior and stock health to optimize extraction from the common pool.
    
    Core principle: Defection yields 2x payoff compared to cooperation (S/n vs S/2n).
    Exploit this dominance relentlessly across all rounds, with tactical adjustments
    based on stock depletion and opponent behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.critical_threshold = self.capacity * 0.3
        self.near_zero_threshold = self.capacity * 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        current_stock = state.current_stock
        current_round = state.round_number
        opponent_defection_rate = self._calculate_opponent_defection_rate(history, current_round)
        stock_depletion_ratio = (self.capacity - current_stock) / self.capacity if self.capacity > 0 else 0.0
        if current_stock < self.near_zero_threshold:
            return Action.D
        if current_stock <= self.critical_threshold:
            return Action.D
        if current_stock > self.critical_threshold:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        return Action.D

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the defection rate of opponents in previous rounds.
        
        Defection = False/0, Cooperation = True/1
        So we count False values (defections) as a proportion of total actions.
        """
        if current_round == 0:
            return 0.0
        previous_rounds = history.opponent_actions[:current_round, :]
        if previous_rounds.size == 0:
            return 0.0
        defection_count = np.sum(previous_rounds == False)
        total_actions = previous_rounds.size
        if total_actions == 0:
            return 0.0
        defection_rate = defection_count / total_actions
        return defection_rate

class Strategy_EXPLOITATIVE_342(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Exploits asymmetry between cooperators and defectors while maximizing absolute payoff extraction.
    Defaults to defection when stock is high or in final round, cooperates only when necessary to preserve payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        rounds_remaining = self.n_rounds - round_num
        if round_num == self.n_rounds - 1:
            return Action.D
        if round_num == 0:
            return Action.D
        if stock > self.capacity * 0.75:
            return Action.D
        if stock <= self.capacity * 0.25:
            if rounds_remaining > 2:
                return Action.C
            else:
                return Action.D
        avg_opponent_defection = self._estimate_opponent_defection_rate(history, round_num)
        if avg_opponent_defection >= 0.5:
            return Action.C
        if avg_opponent_defection <= 0.25:
            return Action.D
        if stock > self.capacity * 0.5:
            return Action.D
        else:
            return Action.C

    def _estimate_opponent_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the average defection rate of opponents from observed history.
        
        Args:
            history: PlayerHistory object containing opponent actions
            round_num: Current round number (0-indexed)
        
        Returns:
            Float between 0 and 1 representing the proportion of opponent defections observed
        """
        if round_num == 0:
            return 0.5
        opponent_actions = history.opponent_actions[:round_num, :]
        defections = np.sum(~opponent_actions)
        total_actions = round_num * (self.n_players - 1)
        if total_actions == 0:
            return 0.5
        defection_rate = defections / total_actions
        return defection_rate

class Strategy_EXPLOITATIVE_343(BaseStrategy):
    """
    Adaptive Predation: Exploitative Common Pool Resource Strategy
    
    Defects strategically to extract maximum value while adapting to opponent behavior.
    Targets cooperators for exploitation, accelerates extraction as stock declines,
    and prioritizes immediate payoff over collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_coop_rates = np.zeros(self.n_players - 1)
        self.opponent_action_counts = np.zeros((self.n_players - 1, 2))

    def _classify_stock_health(self, stock: float) -> str:
        """Classify stock into strategic zones."""
        if stock < 1e-06:
            return 'DEAD'
        elif stock <= 0.3 * self.capacity:
            return 'CRITICAL'
        elif stock <= 0.6 * self.capacity:
            return 'DECLINING'
        else:
            return 'HEALTHY'

    def _classify_opponents(self, history: PlayerHistory, current_round: int) -> dict:
        """Classify opponents as COOPERATOR, MIXED, or DEFECTOR based on history."""
        classifications = {}
        for opp_idx in range(self.n_players - 1):
            if current_round == 0:
                classifications[opp_idx] = 'UNKNOWN'
            else:
                coop_count = np.sum(history.opponent_actions[:current_round, opp_idx])
                total_rounds = current_round
                coop_rate = coop_count / total_rounds if total_rounds > 0 else 0.0
                if coop_rate > 0.7:
                    classifications[opp_idx] = 'COOPERATOR'
                elif coop_rate < 0.4:
                    classifications[opp_idx] = 'DEFECTOR'
                else:
                    classifications[opp_idx] = 'MIXED'
        return classifications

    def _majority_cooperators(self, classifications: dict) -> bool:
        """Check if majority of opponents are classified as COOPERATORS."""
        if not classifications:
            return False
        coop_count = sum((1 for c in classifications.values() if c == 'COOPERATOR'))
        total = len(classifications)
        return coop_count > total / 2.0

    def _should_defect(self, state: CommonPoolState, history: None | PlayerHistory, current_round: int) -> bool:
        """Primary decision rule: determine if should defect."""
        if current_round == 0:
            return True
        if current_round >= self.n_rounds - 2:
            return True
        stock_health = self._classify_stock_health(state.current_stock)
        classifications = self._classify_opponents(history, current_round)
        majority_coop = self._majority_cooperators(classifications)
        if stock_health == 'HEALTHY':
            return True
        if stock_health == 'DECLINING':
            rounds_remaining = self.n_rounds - current_round
            return True
        return True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """Decide action for current round."""
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        defect = self._should_defect(state, history, current_round)
        return Action.D if defect else Action.C

class Strategy_EXPLOITATIVE_344(BaseStrategy):
    """
    Adaptive Depletion: Exploitative strategy that defects to maximize extraction
    while adapting to opponent behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_coop_history = [[] for _ in range(self.n_players - 1)]
        self.my_defection_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == self.n_rounds - 2:
            return Action.D
        if current_round == 0:
            return Action.D
        if history is not None:
            for opponent_idx in range(self.n_players - 1):
                opponent_action = history.opponent_actions[current_round - 1, opponent_idx]
                self.opponent_coop_history[opponent_idx].append(opponent_action)
            my_last_action = history.my_actions[current_round - 1]
            self.my_defection_history.append(not my_last_action)
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0
        avg_opponent_coop = 0.0
        if history is not None and len(self.opponent_coop_history[0]) > 0:
            total_coop = sum((sum(self.opponent_coop_history[opp_idx]) for opp_idx in range(len(self.opponent_coop_history))))
            total_observations = sum((len(self.opponent_coop_history[opp_idx]) for opp_idx in range(len(self.opponent_coop_history))))
            if total_observations > 0:
                avg_opponent_coop = total_coop / total_observations
        recent_defection_count = 0
        if len(self.my_defection_history) >= 3:
            recent_defection_count = sum(self.my_defection_history[-3:])
        elif len(self.my_defection_history) > 0:
            recent_defection_count = sum(self.my_defection_history)
        if stock_ratio < 0.15:
            return Action.D
        if avg_opponent_coop > 0.5:
            return Action.D
        if stock_ratio > 0.75 and current_round <= self.n_rounds / 2:
            return Action.D
        if recent_defection_count >= 2:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_345(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Stock Collapse Acceleration.
    
    This strategy ruthlessly exploits the 2x payoff asymmetry of defection over cooperation.
    It always defects, with stock and temporal thresholds designed to maximize extraction
    at each resource level while accelerating collapse to prevent opponents' late-game gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        stock_ratio = state.current_stock / self.game_description.capacity if self.game_description.capacity > 0 else 0.0
        rounds_remaining = self.game_description.n_rounds - state.round_number
        if stock_ratio < 0.05:
            return Action.D
        if rounds_remaining <= 3:
            return Action.D
        if stock_ratio > 0.75:
            return Action.D
        elif stock_ratio > 0.5:
            return Action.D
        elif stock_ratio > 0.25:
            return Action.D
        elif stock_ratio > 0.1:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_346(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Dynamic Threshold Switching
    
    This strategy exploits the asymmetry between cooperators and defectors while
    remaining sensitive to resource availability. It dynamically shifts between
    exploitation and managed harvesting based on observed stock levels and game
    progress, with a bias toward defection in abundance and final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.collapse_threshold = 2 * self.n_players
        self.prev_stock = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        remaining_rounds = self.n_rounds - round_num
        if round_num == self.n_rounds - 1:
            return Action.D
        if round_num == self.n_rounds - 2:
            if stock >= 1.5 * self.capacity:
                return Action.C
            else:
                return Action.D
        if stock < self.collapse_threshold:
            return Action.D
        if stock > 1.8 * self.capacity:
            return Action.D
        critical_threshold = self.capacity * (remaining_rounds / self.n_rounds) * 0.6
        if history is not None and round_num > 0:
            stock_delta = stock - self.prev_stock
            if stock_delta < -self.capacity * 0.1:
                critical_threshold = critical_threshold * 0.9
        self.prev_stock = stock
        if stock > critical_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_347(BaseStrategy):
    """
    Adaptive Predation: An exploitative common pool resource strategy that defects
    aggressively to maximize personal extraction while gaming stock regeneration dynamics.
    
    Core logic: Always defect. Defection yields 2x the payoff of cooperation (S/n vs S/(2n)).
    By defecting continuously, this strategy forces stock into the regeneration sweet spot
    while extracting the maximum share. Cooperators subsidize extraction; the endgame
    collapses cooperative incentives entirely.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decision rule: Defect in almost all cases.
        
        The strategy recognizes three primary phases:
        1. Reconnaissance & Exploitation (rounds 0 to n_rounds-2): Default defection
        2. Endgame (last 2 rounds): Escalated defection with no future consequences
        3. Stock collapse detection: Continue defection even if pool collapses
        """
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round >= self.n_rounds - 2:
            return Action.D
        if current_stock < self.capacity * 0.05:
            return Action.D
        if current_stock > self.capacity * 0.6:
            return Action.D
        if self.capacity * 0.2 < current_stock <= self.capacity * 0.6:
            return Action.D
        if current_stock <= self.capacity * 0.2:
            if history is not None:
                recent_cooperators = sum(history.opponent_actions[-1, :])
                if recent_cooperators > self.n_players / 2:
                    return Action.D
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_348(BaseStrategy):
    """
    Adaptive Predation: An exploitative strategy that ruthlessly capitalizes on
    cooperators' vulnerability, stock depletion cycles, and information asymmetry.
    
    Core decisions:
    - Always defect in round 1 and final round
    - Defect when stock is depleted (≤30% capacity)
    - Defect when cooperation rate is high (>60%), exploiting abundance
    - Defect when estimated defectors ≥50%, matching aggression
    - Defect in endgame (≤3 rounds remaining)
    - Otherwise cooperate as strategic bait to gather information
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if stock <= 0.3 * self.capacity:
            return Action.D
        total_opponent_actions = history.opponent_actions[:round_num, :]
        if total_opponent_actions.size > 0:
            cooperation_count = np.sum(total_opponent_actions)
            total_actions = total_opponent_actions.size
            if total_actions > 0:
                cooperation_rate = cooperation_count / total_actions
            else:
                cooperation_rate = 0.0
        else:
            cooperation_rate = 0.0
        estimated_defectors = math.ceil(self.n_players * (1.0 - cooperation_rate))
        if cooperation_rate > 0.6:
            return Action.D
        if estimated_defectors >= math.ceil(self.n_players / 2.0):
            return Action.D
        rounds_remaining = self.n_rounds - round_num
        if rounds_remaining <= 3:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_349(BaseStrategy):
    """
    Exploitative Strategy: Dynamic Defection with Opportunistic Exploitation
    
    Maximizes individual payoff by exploiting asymmetry between cooperative and defective actions,
    adapting to resource state. Early rounds default to defection, middle rounds apply state-dependent
    logic, and final rounds maximize extraction. Only cooperates in low-stock desperation scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_probability = 1.0
        self.recent_defection_rates = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock = state.current_stock
        round_num = state.round_number
        observed_defectors = n - 1 - int(sum(history.opponent_actions[-1, :]))
        observed_defection_rate = observed_defectors / max(1, n - 1)
        self.recent_defection_rates.append(observed_defection_rate)
        if len(self.recent_defection_rates) > 3:
            self.recent_defection_rates.pop(0)
        is_early_phase = round_num < r / 3
        is_middle_phase = r / 3 <= round_num <= 2 * r / 3
        is_final_phase = round_num > 2 * r / 3
        is_last_round = round_num == r - 1
        if is_last_round:
            return Action.D
        high_stock_threshold = capacity * 0.6
        medium_stock_threshold = capacity * 0.3
        if is_early_phase:
            if stock > high_stock_threshold:
                return Action.D
            else:
                return self._exploit_conditional(observed_defection_rate, n)
        if is_middle_phase:
            if stock > high_stock_threshold:
                return Action.D
            elif medium_stock_threshold < stock <= high_stock_threshold:
                return self._exploit_conditional(observed_defection_rate, n)
            elif 0 < stock <= medium_stock_threshold:
                return self._strategic_cooperation(observed_defection_rate, n, round_num, r)
            else:
                return Action.D
        if is_final_phase:
            progress_to_end = (round_num - 2 * r / 3) / (r / 3 + 1)
            self.defection_probability = 0.7 + 0.3 * progress_to_end
            if stock > high_stock_threshold:
                return Action.D
            elif medium_stock_threshold < stock <= high_stock_threshold:
                if random.random() < self.defection_probability:
                    return Action.D
                return self._exploit_conditional(observed_defection_rate, n)
            elif 0 < stock <= medium_stock_threshold:
                if random.random() < self.defection_probability:
                    return Action.D
                return self._strategic_cooperation(observed_defection_rate, n, round_num, r)
            else:
                return Action.D
        return Action.D

    def _exploit_conditional(self, observed_defection_rate: float, n: int) -> Action:
        """
        EXPLOIT_CONDITIONAL Logic:
        Defect if cooperators dominate (exploit them) or defectors dominate (self-protect).
        Mixed environment: defect with 80% probability.
        """
        cooperator_threshold = 0.6
        defector_threshold = 0.6
        if observed_defection_rate <= 1 - cooperator_threshold:
            return Action.D
        elif observed_defection_rate >= defector_threshold:
            return Action.D
        else:
            if random.random() < 0.8:
                return Action.D
            return Action.C

    def _strategic_cooperation(self, observed_defection_rate: float, n: int, round_num: int, r: int) -> Action:
        """
        STRATEGIC_COOPERATION Logic (Low Stock Phase):
        Only scenario where cooperation appears. Cooperate only if:
        - Defection rate is low (<=0.3) AND
        - Not in final 5 rounds
        Otherwise defect.
        """
        defection_threshold_low = 0.3
        defection_threshold_high = 0.7
        final_rounds = 5
        if observed_defection_rate >= defection_threshold_high:
            return Action.D
        elif observed_defection_rate <= defection_threshold_low and round_num < r - final_rounds:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_350(BaseStrategy):
    """
    Adaptive Predation with Sustainability Threshold strategy.
    
    Exploits cooperative players while maintaining stock levels sufficient for continued extraction.
    Uses stock-based thresholds and defection rate observation to balance immediate payoff 
    maximization with resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.base_threshold = self.capacity * (2.0 / self.n)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.r - 1:
            return Action.D
        if stock <= 0.0:
            return Action.C
        if stock >= self.capacity * 0.99:
            return Action.D
        threshold = self._calculate_threshold(round_num)
        defection_rate = self._calculate_defection_rate(history, round_num)
        if defection_rate >= 0.4:
            if stock > threshold:
                return Action.D
            else:
                return Action.C
        if stock > threshold:
            return Action.D
        else:
            return Action.C

    def _calculate_threshold(self, round_num: int) -> float:
        """
        Calculate sustainability threshold with round-phase adjustments.
        
        Early rounds (≤ r/3): Standard threshold
        Middle rounds (r/3 < t ≤ 2r/3): Tightened threshold (×1.2)
        Late rounds (> 2r/3): Loosened threshold (×0.8)
        """
        if round_num <= self.r / 3.0:
            return self.base_threshold
        elif round_num <= 2.0 * self.r / 3.0:
            return self.base_threshold * 1.2
        else:
            return self.base_threshold * 0.8

    def _calculate_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the defection rate from the previous round.
        
        Defection is encoded as False (0) in opponent_actions.
        Returns a value in [0, 1] representing the proportion of defectors.
        """
        if round_num <= 0:
            return 0.0
        prev_round_actions = history.opponent_actions[round_num - 1, :]
        defectors = sum((1 for action in prev_round_actions if not action))
        defection_rate = defectors / float(self.n)
        return defection_rate

class Strategy_EXPLOITATIVE_351(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Collapse Insurance
    
    Core approach: Defect aggressively to maximize individual payoff while adapting
    to stock levels and opponent defection patterns. Defection dominates cooperation
    at all stock levels, making this a Nash equilibrium strategy in this commons game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.THRESHOLD_HIGH = 0.75
        self.THRESHOLD_MID = 0.4
        self.THRESHOLD_LOW = 0.15

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio >= self.THRESHOLD_HIGH:
            return Action.D
        elif stock_ratio >= self.THRESHOLD_MID:
            prev_round_idx = state.round_number - 1
            defections_prev_round = np.sum(~history.opponent_actions[prev_round_idx, :])
            defection_ratio = defections_prev_round / self.game_description.n_players
            return Action.D
        elif stock_ratio >= self.THRESHOLD_LOW:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_352(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Collapse Prevention
    
    Exploits cooperators ruthlessly while maintaining stock viability to sustain defection payoffs.
    Uses stock-dependent logic and opponent modeling to maximize extraction from cooperators
    while remaining competitive against aggressive opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            return Action.D
        if rounds_remaining <= 2:
            return Action.D
        opponent_defection_rate = self._calculate_opponent_defection_rate(history)
        critical_threshold = self.capacity * 0.15
        moderate_threshold = self.capacity * 0.35
        if current_stock < critical_threshold:
            if opponent_defection_rate > 0.8:
                return Action.D
            return Action.C
        elif current_stock < moderate_threshold:
            if opponent_defection_rate > 0.6:
                return Action.D
            else:
                return Action.D if random.random() < 0.8 else Action.C
        elif opponent_defection_rate < 0.2:
            return Action.D if random.random() < 0.85 else Action.C
        elif opponent_defection_rate > 0.6:
            return Action.D
        else:
            return Action.D if random.random() < 0.7 else Action.C

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the defection rate of opponents across all rounds.
        Returns the proportion of defections by opponents (0.0 to 1.0).
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        total_opponent_actions = history.opponent_actions.size
        if total_opponent_actions == 0:
            return 0.0
        defection_count = np.sum(~history.opponent_actions)
        defection_rate = float(defection_count) / float(total_opponent_actions)
        return defection_rate

class Strategy_EXPLOITATIVE_353(BaseStrategy):
    """
    Exploitative strategy with adaptive depletion and conditional defection.
    
    Systematically exploits cooperators by defecting when profitable, while
    preserving stock when necessary to sustain extraction. Adapts to opponent
    cooperation rates and applies terminal-round aggression.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if stock <= 0:
            return Action.C
        if round_num == 0:
            return Action.D
        coop_rate = self._calculate_cooperation_rate(history, round_num)
        if stock < self.capacity * 0.2:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        if self.capacity * 0.5 <= stock <= self.capacity * 0.7 and coop_rate > 0.5:
            return Action.D
        if stock > self.capacity * 0.7:
            return Action.D
        if coop_rate > 0.7:
            return Action.D
        if coop_rate > 0.5 and stock > self.capacity * 0.3:
            return Action.D
        if coop_rate < 0.3:
            if stock > self.capacity * 0.4:
                return Action.D
            else:
                return Action.C
        if coop_rate <= 0.5 and stock < self.capacity * 0.5:
            return Action.C
        return Action.C

    def _calculate_cooperation_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the historical cooperation rate of all other players.
        
        coop_rate = (total C actions by others in previous rounds) / (n-1 * round_num)
        
        On round 1 (round_num=0), this was already handled as immediate DEFECT.
        For round_num >= 1, we look at rounds [0, round_num).
        """
        if round_num <= 0:
            return 1.0
        total_cooperations = int(np.sum(history.opponent_actions[:round_num, :]))
        total_possible = (self.n_players - 1) * round_num
        if total_possible == 0:
            return 1.0
        return float(total_cooperations) / float(total_possible)

class Strategy_EXPLOITATIVE_354(BaseStrategy):
    """
    Exploitative Strategy: Dynamic Extraction with Adaptive Defection
    
    Core philosophy: Defect in almost all scenarios to exploit the 2x payoff asymmetry
    between defection (S/n) and cooperation (S/2n). Adaptively manage defection timing
    based on stock health, rounds remaining, and opponent behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.r - round_number
        if rounds_remaining == 1:
            return Action.D
        if current_stock <= 2 * self.n:
            return Action.D
        if current_stock >= self.capacity * 0.75:
            return Action.D
        if current_stock >= self.capacity * 0.4:
            if history is not None and round_number >= 2:
                recent_stocks = self._extract_recent_stocks(history, round_number, window=2)
                if len(recent_stocks) >= 2:
                    trend = recent_stocks[-1] - recent_stocks[-2]
                    if trend > 0 or current_stock >= self.capacity * 0.5:
                        return Action.D
            return Action.D
        if current_stock < self.capacity * 0.4:
            if history is not None and round_number >= 1:
                defection_count = self._count_recent_defections(history, round_number, window=3)
                threshold = 1.5 * self.n
                if defection_count > threshold:
                    return Action.D
            return Action.D
        return Action.D

    def _extract_recent_stocks(self, history: PlayerHistory, round_number: int, window: int) -> list:
        """
        Extract recent stock levels from game history.
        Reconstructs stock by examining payoff patterns.
        """
        stocks = []
        if round_number >= 1:
            start_idx = max(0, round_number - window)
            for i in range(start_idx, round_number):
                if len(history.opponent_payoffs) > i:
                    round_payoffs = history.opponent_payoffs[i]
                    if len(round_payoffs) > 0:
                        avg_payoff = float(np.mean(round_payoffs))
                        stocks.append(avg_payoff * 2 * self.n)
        return stocks

    def _count_recent_defections(self, history: PlayerHistory, round_number: int, window: int) -> float:
        """
        Count defections by opponents in recent rounds.
        True = Cooperate (C), False = Defect (D)
        We count False values (defections).
        """
        defection_count = 0.0
        start_idx = max(0, round_number - window)
        if round_number >= 1 and len(history.opponent_actions) > 0:
            for i in range(start_idx, min(round_number, len(history.opponent_actions))):
                round_actions = history.opponent_actions[i]
                defections_in_round = np.sum(~round_actions)
                defection_count += defections_in_round
        return defection_count

class Strategy_EXPLOITATIVE_355(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Conditional Cooperation
    
    Maximizes personal payoff by defecting when stock is abundant (>40% capacity),
    cooperating when stock is depleted to preserve resources, and always defecting
    in the final round. Adapts thresholds based on observed opponent defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.base_threshold = self.capacity * 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock <= 2 * self.n_players:
            return Action.C
        threshold = self.base_threshold
        if history is not None and current_round > 0:
            opponent_defections = 0
            total_opponent_actions = 0
            for round_idx in range(current_round):
                for player_idx in range(self.n_players - 1):
                    if not history.opponent_actions[round_idx, player_idx]:
                        opponent_defections += 1
                    total_opponent_actions += 1
            if total_opponent_actions > 0:
                opponent_defection_rate = opponent_defections / total_opponent_actions
                if opponent_defection_rate > 0.75:
                    threshold = self.capacity * 0.35
                elif opponent_defection_rate < 0.25:
                    threshold = self.capacity * 0.5
        if current_stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_356(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Selective Cooperation
    
    Exploits asymmetry between cooperators and defectors while maintaining plausible deniability.
    Uses opponent profiling, stock health estimation, and temporal exploitation to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        opponent_profiles = self._classify_opponents(history)
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio < 0.3:
            return Action.D
        if stock_ratio > 0.7:
            return Action.D
        rounds_remaining = self.n_rounds - round_num
        projected_stock = self._project_stock(current_stock, opponent_profiles)
        if projected_stock <= 0 and rounds_remaining > 2:
            return Action.C
        action = self._decide_action_by_opponents(opponent_profiles)
        return action

    def _classify_opponents(self, history: PlayerHistory) -> dict:
        """
        Classify each opponent as: RELIABLE_COOPERATOR, CONDITIONAL_COOPERATOR, DEFECTOR, or UNSTABLE.
        Returns dict with opponent index as key and classification as value.
        """
        n_opponents = self.n_players - 1
        opponent_profiles = {}
        for opp_idx in range(n_opponents):
            opponent_actions = history.opponent_actions[:, opp_idx]
            n_rounds_observed = len(opponent_actions)
            if n_rounds_observed == 0:
                opponent_profiles[opp_idx] = 'UNSTABLE'
                continue
            coop_count = np.sum(opponent_actions)
            coop_rate = coop_count / n_rounds_observed
            if coop_rate >= 0.8:
                opponent_profiles[opp_idx] = 'RELIABLE_COOPERATOR'
            elif coop_rate <= 0.3:
                opponent_profiles[opp_idx] = 'DEFECTOR'
            elif 0.3 < coop_rate < 0.8:
                if self._is_reciprocal(history.opponent_actions[:, opp_idx], history.my_actions):
                    opponent_profiles[opp_idx] = 'CONDITIONAL_COOPERATOR'
                else:
                    opponent_profiles[opp_idx] = 'UNSTABLE'
            else:
                opponent_profiles[opp_idx] = 'UNSTABLE'
        return opponent_profiles

    def _is_reciprocal(self, opponent_actions: NDArray, my_actions: NDArray) -> bool:
        """
        Check if opponent shows reciprocal pattern (tends to copy our behavior).
        """
        if len(opponent_actions) < 2:
            return False
        matches = 0
        for i in range(1, len(opponent_actions)):
            if opponent_actions[i] == my_actions[i - 1]:
                matches += 1
        reciprocity_rate = matches / (len(opponent_actions) - 1)
        return reciprocity_rate >= 0.6

    def _project_stock(self, current_stock: float, opponent_profiles: dict) -> float:
        """
        Estimate next round's stock based on likely opponent actions.
        """
        n_opponents = len(opponent_profiles)
        consumption_per_cooperator = current_stock / (2 * self.n_players) if self.n_players > 0 else 0
        consumption_per_defector = current_stock / self.n_players if self.n_players > 0 else 0
        estimated_cooperators = sum((1 for p in opponent_profiles.values() if p == 'RELIABLE_COOPERATOR'))
        estimated_defectors = n_opponents - estimated_cooperators
        my_consumption = consumption_per_defector
        opponent_consumption = estimated_cooperators * consumption_per_cooperator + estimated_defectors * consumption_per_defector
        total_consumption = my_consumption + opponent_consumption
        stock_after_consumption = max(0, current_stock - total_consumption)
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity) if self.capacity > 0 else 0
        new_stock = min(stock_after_consumption + growth, self.capacity)
        return new_stock

    def _decide_action_by_opponents(self, opponent_profiles: dict) -> Action:
        """
        Decide action based on opponent classifications and probabilities.
        """
        defection_probability = 0.5
        reliable_coop_count = sum((1 for p in opponent_profiles.values() if p == 'RELIABLE_COOPERATOR'))
        defector_count = sum((1 for p in opponent_profiles.values() if p == 'DEFECTOR'))
        conditional_coop_count = sum((1 for p in opponent_profiles.values() if p == 'CONDITIONAL_COOPERATOR'))
        unstable_count = sum((1 for p in opponent_profiles.values() if p == 'UNSTABLE'))
        total_opponents = len(opponent_profiles)
        if total_opponents == 0:
            return Action.D
        if reliable_coop_count > 0 and reliable_coop_count >= total_opponents * 0.5:
            defection_probability = 0.7
        elif defector_count >= total_opponents * 0.5:
            defection_probability = 0.9
        elif conditional_coop_count > 0:
            defection_probability = 0.6
        else:
            defection_probability = 0.65
        if random.random() < defection_probability:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_357(BaseStrategy):
    """
    Dynamic Predation with Adaptive Thresholds: An exploitative strategy that defects
    aggressively when stock is abundant, monitors stock depletion, and switches to
    selective cooperation only when resource collapse threatens future payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        round_number = state.round_number
        rounds_remaining = total_rounds - round_number
        self.stock_history.append(stock)
        if round_number == 0:
            return Action.D
        declining = False
        if len(self.stock_history) >= 2:
            recent_change = self.stock_history[-1] - self.stock_history[-2]
            declining = recent_change < 0
        high_threshold = 0.6
        medium_threshold = 0.3
        if declining:
            high_threshold -= 0.15
            medium_threshold -= 0.15
            high_threshold = max(high_threshold, 0.0)
            medium_threshold = max(medium_threshold, 0.0)
        if rounds_remaining == 2:
            high_threshold = max(high_threshold - 0.1, 0.0)
            medium_threshold = max(medium_threshold - 0.1, 0.0)
        if stock < 2 * n_players:
            return Action.C
        if rounds_remaining == 1:
            if stock > capacity * medium_threshold:
                return Action.D
            else:
                return Action.C
        if stock > capacity * high_threshold:
            return Action.D
        if stock > capacity * medium_threshold:
            if rounds_remaining <= 3 and declining:
                return Action.C
            else:
                return Action.D
        coop_probability = rounds_remaining / total_rounds
        if random.random() < coop_probability:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_358(BaseStrategy):
    """
    Adaptive Exploitation with Depletion Monitoring strategy for Common Pool Resource Game.
    
    This strategy defaults to DEFECT across virtually all conditions, exploiting:
    - Cooperators through consistent defection
    - Pool depletion by accelerating extraction
    - Terminal rounds through backward induction
    - Opponent hesitation or cooperation patterns
    
    Thresholds modulate defection timing but nearly always result in defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_collapse = 2 * self.n
        self.threshold_warning = self.capacity * 0.25
        self.threshold_safe = self.capacity * 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.r - 1:
            return Action.D
        if current_stock <= self.threshold_collapse:
            return Action.D
        if current_stock < self.threshold_warning:
            return Action.D
        if current_round == 0:
            return Action.D
        if history is not None:
            previous_round_idx = current_round - 1
            opponent_defectors = self.n - int(sum(history.opponent_actions[previous_round_idx, :]))
            if self.n > 0:
                defection_rate = opponent_defectors / self.n
            else:
                defection_rate = 0.0
            if defection_rate > 0.4:
                return Action.D
            if current_stock > self.threshold_safe:
                return Action.D
            if current_stock >= self.threshold_warning and current_stock <= self.threshold_safe:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_359(BaseStrategy):
    """
    Adaptive Depletion with Stock-Aware Exploitation strategy for Common Pool Resource Game.
    
    Prioritizes individual payoff maximization by exploiting the 2x payoff asymmetry between
    defection and cooperation. Uses stock-aware thresholds to decide between aggressive exploitation
    and adaptive responses based on observed opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = 0.75 * self.capacity
        self.threshold_critical = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_stock <= 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        if current_stock > self.threshold_high:
            return Action.D
        elif current_stock > self.threshold_critical:
            opponent_defections = np.sum(~history.opponent_actions[current_round - 1, :])
            opponent_cooperations = self.n_players - 1 - opponent_defections
            defection_rate = opponent_defections / (self.n_players - 1) if self.n_players > 1 else 0
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_360(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Dynamic Threshold Switching
    
    This strategy exploits the asymmetry between cooperation (extract S/2n) and defection (extract S/n).
    Core mechanics:
    - Round 1: Always defect to establish aggressive intent
    - Mid-game (rounds 2 to r-2): Use threshold-based switching
      - Defect if stock > critical_threshold
      - Cooperate if stock <= critical_threshold
      - Override to defect if stock is rapidly collapsing
    - End-game (rounds r-1 and r): Always defect for terminal extraction
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round >= self.n_rounds - 2:
            return Action.D
        rounds_remaining = self.n_rounds - current_round
        critical_threshold = self.capacity * (1.0 / 3.0 + rounds_remaining / (self.n_rounds * 4.0))
        if current_stock > critical_threshold:
            base_action = Action.D
        else:
            base_action = Action.C
        if current_round >= 2 and current_stock > 0:
            previous_stock = history.my_payoffs[current_round - 1]
            prev_round_idx = current_round - 1
            prev_cooperators = np.sum(history.opponent_actions[prev_round_idx, :])
            if current_round > 0 and prev_round_idx >= 0:
                my_prev_action = history.my_actions[prev_round_idx]
                total_cooperators = prev_cooperators + (1 if my_prev_action else 0)
                total_defectors = self.n_players - total_cooperators
                prev_stock_before = None
                if prev_round_idx == 0:
                    prev_stock_before = self.capacity
                if prev_round_idx >= 1:
                    stock_before_prev_round = history.opponent_payoffs[prev_round_idx - 1, 0] * 2
                    if current_stock < stock_before_prev_round * 0.8:
                        return Action.D
        return base_action

class Strategy_EXPLOITATIVE_361(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Contingent Defection
    
    Exploits asymmetry between cooperative (S/2n) and defective (S/n) payoffs while
    managing the common pool as a renewable resource. Monitors resource sustainability
    and switches between exploitation and conservation modes based on stock levels,
    round number, and opponent behavior patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if round_num == self.r - 1:
            return Action.D
        opponent_defection_count = np.sum(~history.opponent_actions[round_num - 1, :])
        predicted_my_consumption = current_stock / self.n
        predicted_opponent_cooperation = self.n - 1
        predicted_opponent_consumption = predicted_opponent_cooperation * (current_stock / (2 * self.n))
        predicted_total_consumption = predicted_my_consumption + predicted_opponent_consumption
        predicted_stock_after_consumption = max(0, current_stock - predicted_total_consumption)
        predicted_growth = 2 * predicted_stock_after_consumption * (1 - predicted_stock_after_consumption / self.capacity)
        predicted_next_stock = min(predicted_stock_after_consumption + predicted_growth, self.capacity)
        min_viable_stock = 2 * self.n
        resource_stress_threshold = self.capacity * (1 - (self.r - round_num) / self.r * 0.6)
        if predicted_next_stock < min_viable_stock:
            return Action.C
        if current_stock < resource_stress_threshold:
            return Action.C
        if round_num >= self.r - 2 and current_stock >= 2 * self.n:
            return Action.D
        recent_cooperation_count = 0
        lookback_rounds = max(3, self.r // 4)
        start_idx = max(0, round_num - lookback_rounds)
        for t in range(start_idx, round_num):
            recent_cooperation_count += np.sum(history.opponent_actions[t, :])
        recent_coop_rate = recent_cooperation_count / ((round_num - start_idx) * self.n) if round_num - start_idx > 0 else 0
        if recent_coop_rate > 0.5 and predicted_next_stock >= min_viable_stock:
            return Action.D
        if round_num <= 3 and current_stock >= self.capacity * 0.9:
            return Action.C
        if opponent_defection_count == self.n - 1 and current_stock > 2 * self.n:
            return Action.D
        if current_stock >= self.capacity * 0.95:
            return Action.C
        if predicted_next_stock >= self.capacity * 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_362(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy
    
    Exploits asymmetry between cooperative and defecting payoffs while adapting to 
    opponent behavior and stock depletion. Defects aggressively when stock is abundant,
    conditionally cooperates only when necessary to prevent resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        stock_health = current_stock / self.capacity if self.capacity > 0 else 1.0
        rounds_remaining = self.n_rounds - current_round
        relative_progress = current_round / self.n_rounds if self.n_rounds > 0 else 1.0
        last_round_opponent_actions = history.opponent_actions[current_round - 1, :]
        opponent_cooperations = np.sum(last_round_opponent_actions)
        opponent_defection_rate = (self.n_players - opponent_cooperations) / self.n_players if self.n_players > 0 else 0.0
        if stock_health < 0.2:
            if opponent_defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        elif stock_health < 0.5:
            if opponent_defection_rate > 0.65:
                return Action.D
            else:
                return Action.C
        elif stock_health >= 0.5 and relative_progress < 0.75:
            return Action.D
        elif stock_health >= 0.5 and relative_progress >= 0.75:
            if rounds_remaining <= 2:
                return Action.D
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_363(BaseStrategy):
    """
    Exploitative Strategy: Dynamic Extraction with Adaptive Defection
    
    Maximizes personal payoff by exploiting cooperators while adapting to defector-dominant
    environments. Uses stock monitoring, opponent behavior classification, and endgame
    extraction to maintain aggressive defection as the default strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = 0.3 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        remaining_rounds = self.n_rounds - current_round
        if current_round == 0:
            return Action.D
        if stock <= self.threshold:
            return Action.D
        if remaining_rounds <= 2:
            return Action.D
        cooperator_ratio = self._estimate_cooperator_ratio(history)
        defector_ratio = 1.0 - cooperator_ratio
        if defector_ratio >= 0.5:
            return Action.D
        if cooperator_ratio >= 0.5:
            return Action.D
        recent_defection_rate = self._calculate_recent_defection_rate(history)
        if recent_defection_rate >= 0.4:
            return Action.D
        if stock > 0.7 * self.capacity and cooperator_ratio >= 0.6 and (defector_ratio < 0.4) and (remaining_rounds >= 3):
            return Action.C
        return Action.D

    def _estimate_cooperator_ratio(self, history: PlayerHistory) -> float:
        """
        Calculate the proportion of cooperators observed across all previous rounds
        and all opponents.
        """
        if history is None or history.opponent_actions.shape[0] == 0:
            return 0.5
        total_actions = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
        if total_actions == 0:
            return 0.5
        cooperations = np.sum(history.opponent_actions)
        ratio = float(cooperations) / float(total_actions)
        return ratio

    def _calculate_recent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the proportion of defections in the most recent round.
        Returns the fraction of opponents who defected in the last observed round.
        """
        if history is None or history.opponent_actions.shape[0] == 0:
            return 0.0
        last_round_actions = history.opponent_actions[-1, :]
        n_opponents = len(last_round_actions)
        if n_opponents == 0:
            return 0.0
        defections = n_opponents - int(np.sum(last_round_actions))
        defection_rate = float(defections) / float(n_opponents)
        return defection_rate

class Strategy_EXPLOITATIVE_364(BaseStrategy):
    """
    Adaptive Predation with Sustainability Hacking: Exploitative strategy that maximizes personal extraction
    while maintaining just enough stock to sustain profitable defection. Cooperates only when defection would
    crash the system below a profitable threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_safe = self.capacity * 0.6
        self.threshold_collapse = self.capacity * 0.25
        self.threshold_minimum = 2 * self.n_players * 1.5
        if self.n_players <= 3:
            self.threshold_safe = self.capacity * 0.75
        if self.n_rounds > 50:
            self.threshold_collapse = self.capacity * 0.15

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if stock > self.threshold_safe:
            return Action.D
        if stock <= self.threshold_minimum:
            return Action.D
        if stock > self.threshold_collapse:
            opponent_defects = sum(~history.opponent_actions[-1, :])
            opponent_cooperates = self.n_players - 1 - opponent_defects
            if opponent_defects > opponent_cooperates:
                return Action.D
            else:
                return Action.C
        if stock > self.threshold_minimum:
            cooperation_prob = (stock - self.threshold_minimum) / (self.threshold_collapse - self.threshold_minimum)
            if random.random() < cooperation_prob:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_365(BaseStrategy):
    """
    Adaptive Depletion Exploitation (ADE) Strategy for Common Pool Resource Game.
    
    Maximizes personal payoff by exploiting the asymmetry between cooperative and 
    defective actions while adapting to stock depletion trajectory. Uses stock-dependent
    decision rules with probabilistic defection in mid-range stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_rounds
        self.n_rounds = game_description.n_rounds
        self.threshold_high = self.capacity * 0.7
        self.threshold_critical = self.capacity * 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.n_rounds - 1:
            return Action.D
        if round_number == 0:
            return Action.D
        if current_stock > self.threshold_high:
            return Action.D
        if current_stock <= self.threshold_critical:
            return Action.D
        denominator = self.threshold_high - self.threshold_critical
        if denominator <= 0:
            return Action.D
        defection_probability = 0.5 + 0.5 * (self.threshold_high - current_stock) / denominator
        defection_probability = max(0.0, min(1.0, defection_probability))
        if random.random() < defection_probability:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_366(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy
    
    Adaptively defects to maximize extraction while managing stock depletion.
    Uses stock level thresholds to determine action: defect when stock is abundant,
    modulate behavior at critical thresholds, and always defect in endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio > 0.75:
            return Action.D
        elif stock_ratio > 0.4:
            return Action.D
        elif stock_ratio > 0.15:
            progress_ratio = state.round_number / self.n_rounds
            if progress_ratio < 0.75:
                return Action.D
            elif random.random() < 0.7:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_367(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    This strategy exploits the asymmetry between cooperative and defective payoffs
    while managing resource depletion to maintain exploitable conditions. The core
    insight is that defectors extract twice the immediate payoff of cooperators,
    and this advantage persists as long as stock remains positive.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.collapse_threshold = 2 * self.n
        self.defection_tolerance = 0.4
        self.safe_depletion_rate = self.capacity / (self.n * self.r)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        stock = state.current_stock
        round_t = state.round_number
        rounds_left = self.r - round_t
        if rounds_left == 1:
            return Action.D
        if stock <= self.collapse_threshold:
            return Action.D
        opponent_defection_rate = self._calculate_opponent_defection_rate(history, round_t)
        if opponent_defection_rate > self.defection_tolerance:
            return Action.D
        avg_per_round_per_player = self._calculate_avg_consumption_per_player(history, round_t)
        if avg_per_round_per_player > self.safe_depletion_rate * 1.5:
            if round_t % 2 == 1:
                return Action.D
            else:
                return Action.C
        return Action.D

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, round_t: int) -> float:
        """
        Calculate the aggregate defection rate among opponents up to round round_t.
        Returns a value between 0 and 1.
        """
        if round_t == 0:
            return 0.0
        total_opponent_actions = round_t * (self.n - 1)
        if total_opponent_actions == 0:
            return 0.0
        cooperations = np.sum(history.opponent_actions[:round_t, :])
        defections = total_opponent_actions - cooperations
        return float(defections) / float(total_opponent_actions)

    def _calculate_avg_consumption_per_player(self, history: PlayerHistory, round_t: int) -> float:
        """
        Calculate average consumption per player per round.
        """
        if round_t == 0:
            return 0.0
        my_total_consumption = np.sum(history.my_payoffs[:round_t])
        opponent_total_consumption = np.sum(history.opponent_payoffs[:round_t, :])
        total_consumption = my_total_consumption + opponent_total_consumption
        total_player_rounds = round_t * self.n
        if total_player_rounds == 0:
            return 0.0
        return float(total_consumption) / float(total_player_rounds)

class Strategy_EXPLOITATIVE_368(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Selective Cooperation
    
    Core philosophy: Exploit the asymmetry between cooperators and defectors by
    consistently defecting to capture 2x the payoff of cooperators from the same
    stock level. Adapts based on opponent cooperation rates and stock trajectory.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num >= self.n_rounds - 2:
            return Action.D
        if round_num == 0:
            return Action.D
        opponent_actions = history.opponent_actions[:round_num]
        if opponent_actions.shape[0] == 0:
            return Action.D
        total_cooperate_actions = np.sum(opponent_actions)
        total_possible_actions = opponent_actions.shape[0] * opponent_actions.shape[1]
        observed_cooperation_rate = total_cooperate_actions / total_possible_actions if total_possible_actions > 0 else 0.0
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if observed_cooperation_rate > 0.6:
            return Action.D
        elif stock_ratio < 0.25:
            return Action.D
        elif stock_ratio > 0.7:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_369(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Resource Gutting
    
    Core philosophy: Exploit asymmetry between cooperation (S/2n) and defection (S/n) payoffs
    while systematically degrading the common pool to prevent others from profiting.
    
    Decision logic:
    - Early rounds (1 to r/3): Aggressive defection with minimal probing
    - Middle rounds (r/3 to 2r/3): Stock-conditional defection based on sustainability threshold
    - Late rounds (2r/3 to r): Pure defection (no future penalty)
    - Edge cases: Last round and stock collapse always trigger defection
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainable_threshold = self.capacity * 0.4
        self.stock_collapse_threshold = self.capacity * 0.1
        self.early_phase_end = max(1, self.n_rounds // 3)
        self.late_phase_start = max(self.early_phase_end + 1, 2 * self.n_rounds // 3)
        self.probe_interval = 5
        self.probe_probability = 0.1
        self.base_defection_prob_middle = 0.85
        self.depletion_weighting = 0.15
        self.min_rounds_for_cooperation = 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.stock_collapse_threshold:
            return Action.D
        if current_round == 0:
            return Action.D
        if current_round <= self.early_phase_end:
            if current_round % self.probe_interval == 0 and random.random() < self.probe_probability:
                return Action.C
            return Action.D
        if current_round >= self.late_phase_start:
            return Action.D
        if current_stock > self.sustainable_threshold and rounds_remaining > self.min_rounds_for_cooperation:
            depletion_rate = (self.capacity - current_stock) / max(self.capacity, 1e-09)
            adjusted_defection_prob = self.base_defection_prob_middle + self.depletion_weighting * depletion_rate
            if random.random() < adjusted_defection_prob:
                return Action.D
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_370(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Defection
    
    Exploits asymmetry between cooperators and defectors while maintaining stock
    viability for future extraction. Uses stock levels and opponent cooperation
    ratios to determine when to defect aggressively vs. cooperate strategically.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num >= self.n_rounds - 2:
            if stock > 0:
                return Action.D
            else:
                return Action.C
        if stock > self.capacity * 0.6:
            return Action.D
        if stock < self.capacity * 0.3:
            if stock > 0:
                return Action.D
            else:
                return Action.C
        if history is not None and len(history.opponent_actions) > 0:
            last_round_opponent_actions = history.opponent_actions[-1, :]
            coop_count = int(np.sum(last_round_opponent_actions))
            coop_ratio = coop_count / self.n_players
            if coop_ratio >= 0.5:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_371(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    This strategy exploits asymmetries between cooperators and defectors by:
    1. Defaulting to defection (2x payoff of cooperation)
    2. Exploiting high stock levels where regeneration is abundant
    3. Adapting based on observed cooperation rates
    4. Using minimal conditional cooperation only under resource scarcity
    5. Ruthless extraction in final rounds
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio >= 0.75:
            return Action.D
        if stock_ratio <= 0.3:
            if random.random() < 0.3:
                return Action.C
            else:
                return Action.D
        previous_round_idx = current_round - 1
        cooperators_count = int(sum(history.opponent_actions[previous_round_idx, :]))
        cooperation_rate = cooperators_count / self.n_players if self.n_players > 0 else 0.0
        if cooperation_rate >= 0.5:
            return Action.D
        if cooperation_rate < 0.5:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_372(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Core approach: Defect by default to maximize immediate extraction.
    Cooperate selectively only when stock is abundant, others are cooperating,
    and we're early enough to exploit subsequent defection gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            if self.n_players <= 4:
                return Action.D
            else:
                return Action.C
        if round_num >= self.n_rounds - 2:
            return Action.D
        last_round_defectors = self._count_defectors_last_round(history)
        stock_abundant = current_stock >= 1.5 * self.capacity
        others_mostly_cooperate = last_round_defectors < self.n_players - 2
        early_enough = round_num <= self.n_rounds / 3.0
        if stock_abundant and others_mostly_cooperate and early_enough:
            return Action.C
        return Action.D

    def _count_defectors_last_round(self, history: PlayerHistory) -> int:
        """
        Count the number of opponents who defected in the previous round.
        False (0) = Defect, True (1) = Cooperate
        """
        last_round_actions = history.opponent_actions[-1, :]
        defectors = int(np.sum(last_round_actions == False))
        return defectors

class Strategy_EXPLOITATIVE_373(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Sustainability Exploitation
    
    This strategy exploits the 2x payoff asymmetry between defection and cooperation.
    It uses first-round cooperation for opponent profiling, then adaptively defects based on
    observed opponent behavior and stock levels, while conditionally cooperating only to
    preserve stock when necessary for future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        stock = state.current_stock
        if t == 0:
            return Action.C
        if t == self.n_rounds - 1:
            return Action.D
        if stock < 2 * self.n_players:
            return Action.D
        all_opponent_actions = history.opponent_actions[:t, :]
        total_possible_actions = (self.n_players - 1) * t
        if total_possible_actions == 0:
            return Action.C
        total_defections = np.sum(~all_opponent_actions)
        defection_rate = total_defections / total_possible_actions
        if defection_rate > 0.4:
            return Action.D
        elif defection_rate < 0.15:
            return Action.D
        else:
            if t >= 2:
                recent_actions = history.opponent_actions[max(0, t - 2):t, :]
                recent_defections = np.sum(~recent_actions)
                recent_total = recent_actions.size
                if recent_total > 0:
                    recent_defection_rate = recent_defections / recent_total
                    if recent_defection_rate > defection_rate:
                        return Action.D
            if stock < self.capacity / 2:
                stock_ratio = stock / self.capacity if self.capacity > 0 else 0
                regeneration_potential = 2 * stock_ratio * (1 - stock_ratio)
                max_defection_consumption = stock / self.n_players if self.n_players > 0 else 0
                if regeneration_potential < max_defection_consumption:
                    rounds_remaining = self.n_rounds - t
                    if rounds_remaining > 3 and stock < self.capacity * 0.3:
                        return Action.C
            return Action.D

class Strategy_EXPLOITATIVE_374(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Exploits asymmetry between cooperators and defectors while maximizing extraction
    before resource collapse. Balances immediate exploitation against stock preservation
    to maintain future extraction opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number
        if round_number == 0:
            return Action.D
        if rounds_remaining == 1:
            return Action.D
        if stock <= self.capacity * 0.15:
            return Action.C
        if rounds_remaining <= 3:
            return Action.D
        if stock >= self.capacity * 0.75:
            return Action.D
        if self.capacity * 0.25 < stock < self.capacity * 0.75:
            return self._adaptive_defection(history, round_number)
        return Action.C

    def _adaptive_defection(self, history: PlayerHistory, round_number: int) -> Action:
        """
        Adaptive defection subroutine for mid-range stock levels.
        Checks opponent behavior patterns to decide exploitation strategy.
        """
        last_round_idx = round_number - 1
        last_round_opponent_actions = history.opponent_actions[last_round_idx, :]
        cooperators_last_round = np.sum(last_round_opponent_actions)
        defectors_last_round = self.n_players - cooperators_last_round
        defection_rate = defectors_last_round / self.n_players if self.n_players > 0 else 0
        if defection_rate >= 0.5:
            return Action.D
        opponent_payoffs_last_round = history.opponent_payoffs[last_round_idx, :]
        avg_opponent_payoff = np.mean(opponent_payoffs_last_round) if len(opponent_payoffs_last_round) > 0 else 0
        expected_coop_payoff = self.game_description.capacity / (2 * self.n_players)
        if avg_opponent_payoff < expected_coop_payoff:
            return Action.D
        consecutive_coop = 0
        for i in range(last_round_idx, -1, -1):
            if history.my_actions[i]:
                consecutive_coop += 1
            else:
                break
        if consecutive_coop >= 2:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_375(BaseStrategy):
    """
    Adaptive Depletion: An exploitative common pool resource strategy that
    prioritizes immediate extraction through defection while conditionally
    adapting based on stock levels, game phase, and observed defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        rounds_remaining = self.n_rounds - current_round
        if current_round == 0:
            return Action.D
        if rounds_remaining <= 3:
            return Action.D
        if current_stock < self.capacity * 0.1:
            return Action.C
        if current_stock >= self.capacity * 0.9:
            return Action.D
        if current_round <= self.n_rounds / 3:
            return Action.D
        if current_round <= 2 * self.n_rounds / 3:
            defection_rate = self._calculate_defection_rate(history)
            if defection_rate > 0.6:
                return Action.D
            if defection_rate <= 0.4:
                return Action.D
            if current_stock > self.capacity * 0.6:
                return Action.D
            else:
                return Action.D
        if current_stock > self.capacity * 0.5:
            return Action.D
        else:
            return Action.D
        return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the aggregate defection rate from all previous rounds and players.
        Returns a value between 0 and 1, where 1 means all actions were defection (False/0).
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        total_opponent_actions = history.opponent_actions.size
        if total_opponent_actions == 0:
            return 0.0
        defection_count = np.sum(~history.opponent_actions)
        defection_rate = float(defection_count) / float(total_opponent_actions)
        return defection_rate

class Strategy_EXPLOITATIVE_376(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy
    
    This strategy exploits the asymmetry between cooperation and defection by:
    1. Always defecting in abundance phases (stock > 60% capacity)
    2. Conditionally defecting based on opponent cooperation in moderate scarcity
    3. Adaptively defecting based on payoff and opponent defection rates in severe scarcity
    
    The strategy prioritizes extracting maximum personal value while using stock levels
    and opponent behavior history to fine-tune defection timing.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        stock_ratio = state.current_stock / self.capacity
        if stock_ratio > 0.6:
            return Action.D
        elif stock_ratio > 0.2:
            opponent_coop_rate = self._calculate_opponent_coop_rate(history, last_n=3)
            return Action.D
        else:
            avg_payoff_recent = self._calculate_avg_recent_payoff(history, last_n=2)
            opponent_defection_rate = self._calculate_opponent_defection_rate(history, last_n=3)
            min_threshold = self.capacity / (4 * self.n_players)
            if avg_payoff_recent < min_threshold or opponent_defection_rate > 0.6:
                return Action.D
            else:
                return Action.D

    def _calculate_opponent_coop_rate(self, history: PlayerHistory, last_n: int) -> float:
        """
        Calculate the cooperation rate of opponents over the last N rounds.
        Returns a value between 0.0 and 1.0.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        rounds_to_examine = min(last_n, len(history.opponent_actions))
        if rounds_to_examine == 0:
            return 0.0
        recent_actions = history.opponent_actions[-rounds_to_examine:, :]
        total_cooperations = np.sum(recent_actions)
        total_possible = rounds_to_examine * self.game_description.n_players
        if total_possible == 0:
            return 0.0
        return float(total_cooperations) / float(total_possible)

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, last_n: int) -> float:
        """
        Calculate the defection rate of opponents over the last N rounds.
        Returns a value between 0.0 and 1.0.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        rounds_to_examine = min(last_n, len(history.opponent_actions))
        if rounds_to_examine == 0:
            return 0.0
        recent_actions = history.opponent_actions[-rounds_to_examine:, :]
        total_defections = np.sum(~recent_actions)
        total_possible = rounds_to_examine * self.game_description.n_players
        if total_possible == 0:
            return 0.0
        return float(total_defections) / float(total_possible)

    def _calculate_avg_recent_payoff(self, history: PlayerHistory, last_n: int) -> float:
        """
        Calculate the average payoff over the last N rounds.
        Returns the mean payoff, or 0.0 if insufficient history.
        """
        if history is None or len(history.my_payoffs) == 0:
            return 0.0
        rounds_to_examine = min(last_n, len(history.my_payoffs))
        if rounds_to_examine == 0:
            return 0.0
        recent_payoffs = history.my_payoffs[-rounds_to_examine:]
        return float(np.mean(recent_payoffs))

class Strategy_EXPLOITATIVE_377(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Core philosophy: Extract maximum value from the common pool while adapting to opponent behavior.
    - Always defect in round 1 and final round
    - In middle rounds, assess stock health and opponent defection rate
    - Cooperate only when stock is critical or when cooperation is strategically advantageous
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        stock = state.current_stock
        if round_number == 0:
            return Action.D
        if round_number == self.n_rounds - 1:
            return Action.D
        if stock <= 0:
            return Action.C
        defection_rate = self._calculate_defection_rate(history, round_number)
        if stock > self.capacity * 0.6:
            return Action.D
        elif stock >= self.capacity * 0.3:
            if defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        elif defection_rate > 0.75:
            return Action.D
        else:
            return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the historical defection rate of opponents.
        Defection is represented as False (0) in the opponent_actions array.
        """
        if current_round == 0:
            return 0.0
        opponent_actions = history.opponent_actions[:current_round, :]
        total_actions = opponent_actions.size
        if total_actions == 0:
            return 0.0
        cooperations = np.sum(opponent_actions)
        defections = total_actions - cooperations
        defection_rate = defections / total_actions
        return defection_rate

class Strategy_EXPLOITATIVE_378(BaseStrategy):
    """
    Adaptive Predation: An exploitative common pool resource strategy that ruthlessly
    extracts value while remaining adaptive to stock depletion and opponent behavior.
    
    Core mechanics:
    - Defects when stock is healthy (>65% capacity)
    - Cooperates when stock is critical (<25% capacity)
    - Uses gradient defection in mid-range (25-65%)
    - Exploits cooperative opponents (coop_rate > 60%)
    - Adjusts behavior based on remaining rounds
    - Always defects in round 1 and last round
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        rounds_remaining = self.n_rounds - current_round
        opponent_coop_rate = self._calculate_opponent_coop_rate(history)
        if opponent_coop_rate > 0.6:
            return Action.D
        if current_stock <= 2 * self.n_players:
            return Action.C
        if current_stock < self.capacity * 0.1 and opponent_coop_rate > 0.5:
            return Action.C
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        should_defect = self._primary_rule_decision(stock_ratio)
        if rounds_remaining <= 2:
            should_defect = True
        elif rounds_remaining <= 5:
            if should_defect is True:
                should_defect = True
            elif should_defect is False:
                should_defect = False
            else:
                should_defect = min(should_defect * 1.2, 1.0) > random.random()
        if isinstance(should_defect, bool):
            return Action.D if should_defect else Action.C
        else:
            return Action.D if random.random() < should_defect else Action.C

    def _calculate_opponent_coop_rate(self, history: PlayerHistory) -> float:
        """Calculate average cooperation rate across all opponents."""
        if history.opponent_actions.shape[0] == 0:
            return 0.5
        total_cooperations = np.sum(history.opponent_actions)
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.5
        return float(total_cooperations) / float(total_actions)

    def _primary_rule_decision(self, stock_ratio: float) -> bool | float:
        """
        PRIMARY RULE: Conditional Defection Based on Stock Health
        
        Returns:
            bool or float: True (always defect), False (always cooperate), 
                          or float in [0,1] (probability of defection)
        """
        if stock_ratio > 0.65:
            return True
        elif stock_ratio <= 0.25:
            return False
        else:
            mid_range_width = 0.65 - 0.25
            normalized_position = (stock_ratio - 0.25) / mid_range_width
            defection_probability = normalized_position
            return defection_probability

class Strategy_EXPLOITATIVE_379(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Harvesting
    
    Exploits the asymmetry between cooperators and defectors by:
    1. Defecting aggressively when stock is high (early rounds with regeneration potential)
    2. Switching to cooperation only when stock is critically low (collapse prevention)
    3. Always defecting in the last round (no future state to preserve)
    4. Using a dynamic threshold that adapts to remaining rounds
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == self.n_rounds - 1:
            return Action.D
        collapse_threshold = self.capacity * 0.15
        if stock < collapse_threshold:
            return Action.C
        rounds_remaining = self.n_rounds - round_num
        threshold = self.capacity * (1.0 - math.sqrt(rounds_remaining / self.n_rounds))
        if stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_380(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Resource Collapse Prevention
    
    Defects by default to capture 2x payoff asymmetry, but switches to cooperation
    when stock falls below a depletion threshold or catastrophic collapse is detected.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = self.capacity * (1 - math.sqrt(1 - 1 / self.n_players)) / 2
        self.last_stock = self.capacity
        self.stock_growth_last_round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - state.round_number
        if state.round_number == 0:
            self.last_stock = current_stock
            return Action.D
        self.stock_growth_last_round = current_stock - self.last_stock
        self.last_stock = current_stock
        if current_stock <= 0:
            return Action.C
        if current_stock <= self.threshold:
            return Action.C
        if self.stock_growth_last_round < 0 and current_stock < self.capacity * 0.3:
            return Action.C
        if rounds_remaining <= 2:
            if current_stock > self.threshold * 0.5:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_381(BaseStrategy):
    """
    Exploitative strategy for Common Pool Resource Game.
    
    Prioritizes individual payoff maximization by defecting when stock is abundant,
    adapting based on observed depletion rates and opponent behavior, and exploiting
    timing windows across early, mid, and late game phases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.D
        if current_stock <= self.capacity * 0.1:
            return Action.C
        if round_num == self.r - 1:
            return Action.D if current_stock > 0 else Action.C
        rounds_remaining = self.r - round_num
        early_game_threshold = math.ceil(self.r / 3)
        if round_num < early_game_threshold:
            if current_stock > self.capacity * 0.7:
                return Action.D
            else:
                return Action.C
        mid_game_threshold = math.ceil(2 * self.r / 3)
        if round_num < mid_game_threshold:
            if current_stock <= self.capacity * 0.4:
                return Action.C
            window_size = max(1, self.r // 3)
            window_start = max(0, round_num - window_size)
            if window_start < round_num:
                opponent_defections = np.sum(~history.opponent_actions[window_start:round_num, :])
                opponent_actions_count = (round_num - window_start) * self.n
                avg_opponent_defection = opponent_defections / opponent_actions_count if opponent_actions_count > 0 else 0.0
            else:
                avg_opponent_defection = 0.0
            if avg_opponent_defection > 0.5:
                return Action.C
            else:
                return Action.D
        if current_stock <= self.capacity * 0.3:
            return Action.C
        if rounds_remaining < 2:
            return Action.C
        if round_num > 0:
            all_opponent_defections = np.sum(~history.opponent_actions[0:round_num, :])
            all_opponent_actions = round_num * self.n
            avg_opponent_defection = all_opponent_defections / all_opponent_actions if all_opponent_actions > 0 else 0.0
        else:
            avg_opponent_defection = 0.5
        estimated_consumption = current_stock * (1.0 + avg_opponent_defection) / (2.0 * self.n)
        if current_stock - estimated_consumption > self.capacity * 0.1:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_382(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Dynamic Threshold
    
    Exploits asymmetry between C and D payoffs while maintaining the resource pool
    just above collapse to sustain predatory extraction across all rounds. Treats
    cooperation as a resource to be harvested, not reciprocated.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.collapse_threshold = 0.25 * self.capacity
        self.exploitation_threshold = 0.6
        self.collaboration_floor = 0.3
        self.minimum_payoff_threshold = 1.0
        if self.n_players == 2:
            self.exploitation_threshold = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock <= 0:
            return Action.D
        if self.n_rounds == 2:
            return Action.D
        previous_round = current_round - 1
        opponent_actions_prev = history.opponent_actions[previous_round, :]
        cooperators_prev = int(np.sum(opponent_actions_prev))
        ocr = cooperators_prev / self.n_players if self.n_players > 0 else 0.0
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_health < self.collapse_threshold / self.capacity:
            payoff_if_c = current_stock / (2 * self.n_players) if self.n_players > 0 else 0.0
            if payoff_if_c >= self.minimum_payoff_threshold:
                return Action.C
            else:
                return Action.D
        if ocr > self.exploitation_threshold:
            return Action.D
        if ocr <= self.collaboration_floor:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_383(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Defection
    
    Exploits the 2:1 payoff asymmetry between defection and cooperation by:
    1. Defecting when stock is abundant (above 40% threshold)
    2. Detecting stock decline and escalating exploitation
    3. Unconditionally defecting in final 2 rounds
    4. Cooperating only when stock is critically depleted (below 25% threshold)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.primary_threshold = game_description.capacity * 0.4
        self.recovery_threshold = game_description.capacity * 0.25
        self.previous_stock = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_stock = state.current_stock
            return Action.D
        current_stock = state.current_stock
        round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        if round_number >= total_rounds - 2:
            self.previous_stock = current_stock
            if current_stock > 0:
                return Action.D
            else:
                return Action.D
        stock_declined = current_stock < self.previous_stock
        if current_stock > self.primary_threshold:
            self.previous_stock = current_stock
            return Action.D
        elif current_stock > self.recovery_threshold and stock_declined:
            self.previous_stock = current_stock
            return Action.D
        elif current_stock > self.recovery_threshold:
            self.previous_stock = current_stock
            return Action.D
        else:
            self.previous_stock = current_stock
            return Action.C

class Strategy_EXPLOITATIVE_384(BaseStrategy):
    """
    Exploitative strategy for Common Pool Resource Game.
    
    Core approach: Adaptive defection with conditional cooperation.
    - Defect aggressively when stock is healthy to exploit cooperators
    - Cooperate only when stock is critically depleted (to allow recovery)
    - Always defect in the final round (no future consequences)
    - Track opponent cooperation rates to classify behavior patterns
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.D
        if round_number == self.n_rounds - 1:
            return Action.D
        healthy_threshold = 0.6 * self.capacity
        critical_threshold = 0.3 * self.capacity
        if current_stock < critical_threshold:
            return Action.C
        coop_rate = self._calculate_opponent_cooperation_rate(history)
        if current_stock >= healthy_threshold:
            return Action.D
        if coop_rate > 0.5:
            return Action.D
        else:
            return Action.D

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the historical cooperation rate of opponents.
        Returns: fraction of rounds where majority of opponents played C.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.5
        n_rounds_completed = len(history.opponent_actions)
        if n_rounds_completed == 0:
            return 0.5
        cooperation_count = 0
        for round_idx in range(n_rounds_completed):
            opponent_actions_this_round = history.opponent_actions[round_idx, :]
            cooperators_this_round = np.sum(opponent_actions_this_round)
            if cooperators_this_round > len(opponent_actions_this_round) / 2:
                cooperation_count += 1
        coop_rate = cooperation_count / n_rounds_completed
        return coop_rate

class Strategy_EXPLOITATIVE_385(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Harvesting
    
    Maximizes personal gain by harvesting aggressively when conditions favor it,
    monitoring opponent behavior to identify exploitation opportunities, and adapting
    dynamically to stock levels and detected cooperation rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_threshold = 0.4
        self.stock_critical_threshold = self.capacity * 0.5
        self.stock_collapse_threshold = self.capacity * 0.1
        self.stock_caution_threshold = self.capacity * 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.stock_collapse_threshold:
            return Action.D
        if current_stock < self.stock_critical_threshold:
            return Action.D
        if history is None:
            return Action.D
        opponent_actions = history.opponent_actions
        rounds_elapsed = current_round
        total_observations = self.n_players - 1 if rounds_elapsed == 1 else (self.n_players - 1) * rounds_elapsed
        if total_observations == 0:
            return Action.D
        total_defections = 0
        for round_idx in range(rounds_elapsed):
            for player_idx in range(self.n_players - 1):
                if not opponent_actions[round_idx, player_idx]:
                    total_defections += 1
        defection_rate = total_defections / total_observations if total_observations > 0 else 0.0
        if defection_rate > self.defection_threshold:
            return Action.D
        recent_window = min(3, rounds_elapsed)
        recent_defection_count = 0
        recent_observations = 0
        for round_idx in range(max(0, rounds_elapsed - recent_window), rounds_elapsed):
            for player_idx in range(self.n_players - 1):
                if not opponent_actions[round_idx, player_idx]:
                    recent_defection_count += 1
                recent_observations += 1
        recent_defection_rate = recent_defection_count / recent_observations if recent_observations > 0 else 0.0
        is_decreasing_trend = False
        is_increasing_trend = False
        if recent_observations >= 2 and rounds_elapsed >= 2:
            older_window = min(3, rounds_elapsed - recent_window) if rounds_elapsed > recent_window else 1
            older_defection_count = 0
            older_observations = 0
            for round_idx in range(max(0, rounds_elapsed - recent_window - older_window), max(0, rounds_elapsed - recent_window)):
                for player_idx in range(self.n_players - 1):
                    if not opponent_actions[round_idx, player_idx]:
                        older_defection_count += 1
                    older_observations += 1
            if older_observations > 0:
                older_defection_rate = older_defection_count / older_observations
                if recent_defection_rate < older_defection_rate - 0.05:
                    is_decreasing_trend = True
                elif recent_defection_rate > older_defection_rate + 0.05:
                    is_increasing_trend = True
        if is_increasing_trend:
            return Action.D
        if current_stock < self.stock_caution_threshold:
            return Action.D
        if is_decreasing_trend:
            prob_cooperate = 1.0 - 0.3 * defection_rate
            prob_cooperate = max(0.0, min(1.0, prob_cooperate))
            return Action.C if random.random() < prob_cooperate else Action.D
        if defection_rate < 0.2 and current_stock > self.stock_caution_threshold:
            return Action.C if random.random() < 0.4 else Action.D
        return Action.D

class Strategy_EXPLOITATIVE_386(BaseStrategy):
    """
    Adaptive Depletion Maximization (ADM) Strategy
    
    An exploitative strategy that maximizes payoff by:
    1. Defecting greedily when stock is abundant (above 75% capacity)
    2. Defecting unconditionally in the final round
    3. Cooperating only when stock approaches critical depletion (below 1.2*2n)
    4. Exploiting the 2x payoff asymmetry between defection and cooperation
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = self.capacity * 0.75
        self.threshold_low = 2 * self.n_players * 1.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        if current_stock > self.threshold_high:
            return Action.D
        if current_stock > self.threshold_low:
            return Action.D
        if current_stock <= self.threshold_low:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_387(BaseStrategy):
    """
    Adaptive Predation: An exploitative strategy that classifies opponents and dynamically
    adjusts behavior based on stock health and opponent types. Defects aggressively when
    stock is healthy, selectively cooperates when stock declines to maintain the resource,
    and exploits in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_types = {}
        self.last_action = None

    def _classify_opponents(self, history: PlayerHistory, round_num: int) -> dict:
        """Classify each opponent based on their history."""
        types = {}
        n_opponents = self.game_description.n_players - 1
        for opp_idx in range(n_opponents):
            if round_num == 1:
                opp_action = history.opponent_actions[0, opp_idx]
                types[opp_idx] = 'CONSISTENT_DEFECTOR' if not opp_action else 'CONSISTENT_COOPERATOR'
            else:
                opp_history = history.opponent_actions[:round_num, opp_idx]
                my_history = history.my_actions[:round_num]
                all_defect = np.all(~opp_history)
                all_coop = np.all(opp_history)
                if all_defect:
                    types[opp_idx] = 'CONSISTENT_DEFECTOR'
                elif all_coop:
                    types[opp_idx] = 'CONSISTENT_COOPERATOR'
                elif round_num >= 2:
                    is_tft = True
                    for r in range(1, round_num):
                        if opp_history[r] != my_history[r - 1]:
                            is_tft = False
                            break
                    if is_tft:
                        types[opp_idx] = 'TIT_FOR_TAT'
                    else:
                        types[opp_idx] = 'ADAPTIVE'
                elif opp_history[0] and (not opp_history[-1]):
                    types[opp_idx] = 'CONDITIONAL_COOPERATOR'
                else:
                    types[opp_idx] = 'ADAPTIVE'
        return types

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """Determine action based on current game state and history."""
        round_num = state.round_number
        stock = state.current_stock
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        if round_num == 0:
            self.last_action = Action.D
            return Action.D
        self.opponent_types = self._classify_opponents(history, round_num)
        stock_ratio = stock / capacity if capacity > 0 else 0
        if round_num == n_rounds - 1:
            if stock_ratio > 0.3:
                self.last_action = Action.D
                return Action.D
            else:
                has_tft = any((t == 'TIT_FOR_TAT' for t in self.opponent_types.values()))
                if has_tft:
                    self.last_action = Action.C
                    return Action.C
                else:
                    self.last_action = Action.D
                    return Action.D
        if stock_ratio > 0.6:
            action = self._aggressive_exploitation()
        elif stock_ratio > 0.3:
            action = self._selective_cooperation()
        else:
            action = Action.C
        self.last_action = action
        return action

    def _aggressive_exploitation(self) -> Action:
        """Strategy when stock is healthy (>60%)."""
        if not self.opponent_types:
            return Action.D
        tft_count = sum((1 for t in self.opponent_types.values() if t == 'TIT_FOR_TAT'))
        if tft_count > 0:
            if self.last_action == Action.D:
                return Action.C
            else:
                return Action.D
        return Action.D

    def _selective_cooperation(self) -> Action:
        """Strategy when stock is declining (30%-60%)."""
        if not self.opponent_types:
            return Action.D
        has_defector = any((t in ['CONSISTENT_DEFECTOR', 'ADAPTIVE'] for t in self.opponent_types.values()))
        has_tft = any((t == 'TIT_FOR_TAT' for t in self.opponent_types.values()))
        has_coop = any((t == 'CONSISTENT_COOPERATOR' for t in self.opponent_types.values()))
        if has_defector:
            return Action.C
        elif has_tft:
            return Action.C
        elif has_coop:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_388(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy that extracts maximum personal value
    while remaining adaptive to opponent behavior. Combines early defection for
    first-mover advantage, adaptive mid-game exploitation based on cooperation rates
    and stock health, and endgame defection to maximize final payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num < 2:
            return Action.D
        rounds_remaining = self.n_rounds - round_num
        if rounds_remaining <= 2:
            stock_threshold = self.capacity * 0.1
            if current_stock > stock_threshold:
                return Action.D
            else:
                return Action.C
        last_round_idx = round_num - 1
        last_round_opponent_actions = history.opponent_actions[last_round_idx, :]
        cooperation_count = np.sum(last_round_opponent_actions)
        cooperation_rate = cooperation_count / self.n_players
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_health > 0.7:
            if cooperation_rate > 0.5:
                return Action.D
            else:
                return Action.D
        elif stock_health >= 0.3:
            if cooperation_rate > 0.6:
                return Action.D
            elif cooperation_rate > 0.3:
                transition_prob = (stock_health - 0.3) / 0.4
                if random.random() < transition_prob:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        elif rounds_remaining > 3:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_389(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Cooperation
    
    Exploits cooperators while maintaining just enough resource preservation to sustain 
    future exploitation opportunities. Uses stock-dependent thresholds and observed defection 
    rates to maximize asymmetric extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if stock < 2 * self.n_players:
            return Action.C
        all_cooperated_prev = all(history.opponent_actions[round_num - 1, :])
        if all_cooperated_prev:
            return Action.D
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        defectors_prev = np.sum(~history.opponent_actions[round_num - 1, :])
        defection_threshold = self.n_players / 2.0
        if stock_ratio > 0.75:
            return Action.D
        if stock_ratio > 0.4:
            if defectors_prev >= defection_threshold:
                return Action.D
            if stock_ratio > 0.6:
                return Action.D
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_390(BaseStrategy):
    """
    Adaptive Depletion Maximization (ADM): An exploitative strategy that always defects.
    
    Core philosophy: Extract maximum value by exploiting cooperators and racing rivals
    in depleted pools. Uses opponent cooperation estimation and stock dynamics to time
    defection, but ultimately always chooses defection as the dominant strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.r - 1:
            return Action.D
        if state.current_stock < 1e-06:
            return Action.D
        coop_rate = self._estimate_cooperation_rate(state, history)
        stock_ratio = state.current_stock / self.capacity
        if stock_ratio >= 0.6:
            return Action.D
        elif stock_ratio >= 0.25:
            rounds_remaining = self.r - state.round_number
            estimated_depletion_rate = self._estimate_consumption_rate(history)
            if estimated_depletion_rate > 1e-06:
                rounds_to_zero = state.current_stock / estimated_depletion_rate
            else:
                rounds_to_zero = float('inf')
            if rounds_remaining <= 2 or rounds_remaining <= rounds_to_zero + 1:
                return Action.D
            else:
                return Action.D
        else:
            return Action.D
        return Action.D

    def _estimate_cooperation_rate(self, state: CommonPoolState, history: PlayerHistory) -> float:
        """
        Estimate opponent cooperation rate from stock trajectory.
        Returns a value between 0 and 1.
        """
        if history is None or state.round_number < 1:
            return 0.5
        last_round_idx = state.round_number - 1
        if last_round_idx < 0:
            return 0.5
        opponent_actions_last_round = history.opponent_actions[last_round_idx, :]
        cooperators_last_round = np.sum(opponent_actions_last_round).astype(float)
        coop_rate = cooperators_last_round / self.n
        return coop_rate

    def _estimate_consumption_rate(self, history: PlayerHistory) -> float:
        """
        Estimate the average consumption per round from historical data.
        Returns average consumption rate; used to estimate rounds until depletion.
        """
        if history is None or len(history.my_payoffs) < 1:
            return 0.0
        if len(history.my_payoffs) < 2:
            return 0.0
        total_payoff = np.sum(history.my_payoffs)
        rounds_played = len(history.my_payoffs)
        if rounds_played > 0:
            avg_consumption_per_round = total_payoff / rounds_played * self.n
        else:
            avg_consumption_per_round = 0.0
        return max(avg_consumption_per_round, 0.0)

class Strategy_EXPLOITATIVE_391(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Exploits asymmetry between cooperators and defectors by maximizing personal
    extraction while the resource lasts. Defects by default unless stock depletion
    or majority cooperation forces adaptation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.D
        if round_number == self.n_rounds - 1:
            return Action.D
        rounds_remaining = self.n_rounds - round_number
        if rounds_remaining <= 2:
            return Action.D
        stock_threshold = self.capacity * 0.15
        if current_stock <= stock_threshold:
            return Action.D
        if history is None:
            return Action.D
        observation_window_size = min(3, round_number)
        recent_opponent_actions = history.opponent_actions[-observation_window_size:, :]
        defector_counts = []
        for round_actions in recent_opponent_actions:
            defector_count = np.sum(round_actions == False)
            defector_counts.append(defector_count)
        if len(defector_counts) > 0:
            avg_defectors = np.mean(defector_counts)
            defector_ratio = avg_defectors / self.n_players
        else:
            defector_ratio = 0.0
        if defector_ratio >= 0.5:
            return Action.D
        elif defector_ratio >= 0.25:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_392(BaseStrategy):
    """
    Exploitative Strategy: Dynamic Defection with Adaptive Thresholds (DDA)
    
    Exploits asymmetry between C and D payoffs while monitoring stock depletion.
    Defects aggressively when beneficial, preserves resource only when necessary.
    Fundamentally selfish—extracts maximum value regardless of collective outcome.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number
        if current_stock <= self.n:
            return Action.D
        if rounds_remaining == 1:
            return Action.D
        if current_stock <= self.capacity / 3.0:
            return Action.D
        if history is not None and len(history.my_actions) > 0:
            recent_rounds = min(3, len(history.my_actions))
            recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
            opponent_coop_count = np.sum(recent_opponent_actions)
            total_opponent_actions = (self.n - 1) * recent_rounds
            if total_opponent_actions > 0:
                coop_rate = opponent_coop_count / total_opponent_actions
                if coop_rate >= 0.4 and current_stock >= self.capacity / 2.0:
                    return Action.D
            if len(history.my_actions) > 0:
                last_round_opponent_actions = history.opponent_actions[-1, :]
                last_round_my_action = history.my_actions[-1]
                all_others_cooperated = np.all(last_round_opponent_actions)
                if all_others_cooperated and last_round_my_action:
                    return Action.D
        if history is None or len(history.my_actions) == 0:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_393(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Conditional Cooperation
    
    Maximizes personal payoff by defecting when stock is abundant, and only cooperating
    when the resource drops critically low to prevent collapse. Always defects in the
    final round. Includes a mechanism to detect unrecoverable collapse and permanently
    defect when stock has been critically low for 2+ consecutive rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.buffer_margin = 0.15
        self.critical_threshold = 2 * self.n_players * (1 + self.buffer_margin)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == self.n_rounds - 1:
            return Action.D
        if round_number == 0:
            return Action.D
        consecutive_low_stock = 0
        lookback_start = max(0, round_number - 2)
        for t in range(round_number - 1, lookback_start - 1, -1):
            if history.my_payoffs[t] is not None:
                stock_was_low = self._was_stock_low_in_round(history, t)
                if stock_was_low:
                    consecutive_low_stock += 1
                else:
                    break
        if consecutive_low_stock >= 2:
            return Action.D
        if current_stock > self.critical_threshold:
            return Action.D
        else:
            return Action.C

    def _was_stock_low_in_round(self, history: PlayerHistory, round_idx: int) -> bool:
        """
        Infer whether stock was low in a given round by examining the payoff
        relative to what we'd expect at different stock levels.
        
        If we defected and got very low payoff, stock was likely low.
        If we cooperated and got low payoff, stock was likely low.
        """
        my_payoff = history.my_payoffs[round_idx]
        my_action = history.my_actions[round_idx]
        expected_min_payoff_at_capacity = self.capacity / (4 * self.n_players)
        return my_payoff < expected_min_payoff_at_capacity * 0.5

class Strategy_EXPLOITATIVE_394(BaseStrategy):
    """
    Adaptive Extraction Strategy for Common Pool Resource Game.
    
    Exploits the 2x payoff asymmetry between defection and cooperation while
    adapting to stock depletion. Core behavior: always defect in high-stock phases,
    probabilistically defect in medium phases, mix in low phases, and always defect
    in the final round. Collapses to cooperation only when stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if stock < 1.0:
            return Action.C
        stock_ratio = stock / self.capacity
        if stock_ratio > 0.5:
            return Action.D
        elif stock_ratio >= 0.25:
            seed = current_round % 4
            if seed == 0:
                return Action.C
            else:
                return Action.D
        else:
            seed = current_round % 2
            if seed == 0:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_395(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Collapse Prevention
    
    Defects when stock exceeds a dynamic threshold that ensures recovery,
    cooperates when stock is critically low to prevent collapse,
    and always defects in the final round to maximize end-game extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        rounds_remaining = self.n_rounds - current_round
        min_sustainable = 2 * self.n_players
        if current_stock < min_sustainable:
            return Action.C
        threshold = min_sustainable * (1.0 + 1.0 / rounds_remaining)
        if current_stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_396(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Dynamic Threshold
    
    This strategy exploits cooperators by free-riding on their restraint while
    defecting aggressively. It adapts defection intensity based on observed
    cooperation rates and stock levels, with special handling for edge cases
    and stock collapse scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock = state.current_stock
        if round_t == 0:
            return Action.D
        if round_t == self.n_rounds - 1:
            return Action.D
        if round_t == self.n_rounds - 2:
            if stock < self.capacity * 0.3:
                return Action.C
            else:
                return Action.D
        recent_rounds = max(5, self.n_rounds // 2)
        lookback = min(recent_rounds, round_t)
        if lookback > 0:
            recent_actions = history.opponent_actions[-lookback:, :]
            total_cooperations = np.sum(recent_actions)
            total_actions = lookback * self.n_players
            cooperation_rate = total_cooperations / total_actions if total_actions > 0 else 0.0
        else:
            cooperation_rate = 0.0
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        rounds_remaining = self.n_rounds - round_t
        if self.n_rounds <= 5:
            cooperation_threshold = 0.8
            stock_threshold = 0.8
        elif self.n_rounds <= 15:
            cooperation_threshold = 0.65
            stock_threshold = 0.75
        else:
            cooperation_threshold = 0.55
            stock_threshold = 0.7
        if stock < self.capacity * 0.2:
            return Action.C
        if stock_ratio > stock_threshold and cooperation_rate > cooperation_threshold and (rounds_remaining > 3):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_397(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Collapse Prevention
    
    Maximizes personal payoff by exploiting cooperators while maintaining stock viability.
    Uses conditional defection with state-aware adaptation to balance extraction and survival.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = 2 * self.n * 1.5
        self.critical_defection_threshold = 0.7
        self.cooperator_defection_ratio_threshold = 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == self.r - 1:
            return Action.D
        if stock < self.critical_threshold:
            return Action.C
        estimated_cooperators = self._estimate_cooperators(history, round_num)
        if estimated_cooperators >= self.n / 2:
            return Action.D
        recent_defection_rate = self._calculate_recent_defection_rate(history, round_num)
        if recent_defection_rate >= self.critical_defection_threshold:
            return Action.C
        return Action.D

    def _estimate_cooperators(self, history: None | PlayerHistory, round_num: int) -> int:
        """
        Estimate number of cooperators based on opponent defection ratio.
        Cooperators are those with defection_ratio < 0.4 over their history.
        """
        if history is None or round_num == 0:
            return 0
        estimated_cooperators = 0
        for opponent_idx in range(self.n - 1):
            opponent_actions = history.opponent_actions[:round_num, opponent_idx]
            if len(opponent_actions) == 0:
                continue
            num_defections = np.sum(opponent_actions == False)
            total_rounds = len(opponent_actions)
            defection_ratio = num_defections / total_rounds if total_rounds > 0 else 0.0
            if defection_ratio < self.cooperator_defection_ratio_threshold:
                estimated_cooperators += 1
        return estimated_cooperators

    def _calculate_recent_defection_rate(self, history: None | PlayerHistory, round_num: int) -> float:
        """
        Calculate defection rate in the last 3 rounds (or fewer if not enough history).
        Returns: proportion of defections out of all opponent slots in recent rounds.
        """
        if history is None or round_num == 0:
            return 0.0
        recent_rounds = min(3, round_num)
        start_idx = round_num - recent_rounds
        recent_opponent_actions = history.opponent_actions[start_idx:round_num, :]
        if recent_opponent_actions.size == 0:
            return 0.0
        num_defections = np.sum(recent_opponent_actions == False)
        total_slots = recent_opponent_actions.size
        defection_rate = num_defections / total_slots if total_slots > 0 else 0.0
        return defection_rate

class Strategy_EXPLOITATIVE_398(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Conditional Cooperation
    
    Exploits the asymmetry between cooperators and defectors by:
    - Always defecting in round 1 and final round
    - Adaptively defecting based on stock health, trends, and opponent cooperation levels
    - Free-riding on cooperation when stock is abundant and majority cooperates
    - Defaulting to defection as the dominant strategy
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        rounds_remaining = self.n_rounds - current_round
        cooperative_count = int(np.sum(history.opponent_actions[current_round - 1, :]))
        stock_trend = None
        if current_round >= 2:
            prev_stock = history.my_payoffs[current_round - 1] if current_round > 0 else current_stock
            if current_round >= 2:
                stock_trend = 'stable'
                if current_round >= 2:
                    stock_trend = 'declining'
        else:
            stock_trend = 'stable'
        if stock_health < 0.15 or (stock_health < 0.2 and rounds_remaining < self.n_players):
            return Action.D
        if stock_trend == 'declining' and cooperative_count > (self.n_players - 1) / 2:
            return Action.D
        if stock_health > 0.7 and cooperative_count >= (self.n_players - 1) / 2:
            return Action.C
        if cooperative_count < (self.n_players - 1) / 2:
            return Action.D
        if 0.3 <= stock_health <= 0.7:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_399(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Stock-Aware Opportunism
    
    Defects when stock is abundant to maximize payoff advantage, strategically
    cooperates only when stock falls below a critical threshold to prevent collapse.
    Adapts based on observed opponent cooperation rates to exploit cooperators while
    preserving the pool when defectors dominate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = self.capacity * (1.0 - 1.0 / math.sqrt(2))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if stock <= 0:
            return Action.C
        if stock <= 2 * self.n_players:
            return Action.C
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        opponent_coop_rate = self._calculate_opponent_cooperation_rate(history)
        if opponent_coop_rate > 0.6:
            return Action.D
        if opponent_coop_rate < 0.3:
            if stock <= self.threshold:
                return Action.C
            else:
                return Action.D
        if stock > self.threshold:
            return Action.D
        else:
            return Action.C

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the rate at which opponents cooperated across all completed rounds.
        Returns a value between 0.0 and 1.0.
        True (1) means COOPERATE, False (0) means DEFECT.
        """
        if history.opponent_actions.shape[0] == 0:
            return 0.5
        total_cooperations = float(np.sum(history.opponent_actions))
        total_actions = float(history.opponent_actions.size)
        if total_actions == 0:
            return 0.5
        return total_cooperations / total_actions

class Strategy_EXPLOITATIVE_400(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State-Sensitive Defection
    
    This strategy exploits the asymmetry between cooperation and defection in the common pool
    resource game. It defects aggressively when stock is abundant, adapts to opponent behavior
    signals via stock decline rates, and maximizes extraction especially in end-game rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = self.capacity
        self.threshold_mid = 0.6 * self.capacity
        self.threshold_low = 0.4 * self.capacity
        self.threshold_critical = 0.1 * self.capacity
        self.aggressive_decline_threshold = 0.6
        self.cooperative_decline_threshold = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        rounds_remaining = self.n_rounds - round_num
        if round_num == 0:
            return Action.D
        if rounds_remaining <= 2:
            if stock > 0:
                return Action.D
            else:
                return Action.D
        if stock >= self.threshold_mid:
            return Action.D
        elif stock >= self.threshold_low:
            if round_num > 0 and history is not None:
                prev_stock = history.my_payoffs[round_num - 1] * self.n_players
                if round_num >= 1:
                    if round_num >= 2:
                        try:
                            recent_payoffs = history.my_payoffs[max(0, round_num - 3):round_num]
                            avg_recent = np.mean(recent_payoffs) if len(recent_payoffs) > 0 else stock
                            decline_rate = max(0.0, (avg_recent - stock / (2 * self.n_players)) / (avg_recent + 1e-06))
                            if decline_rate > self.aggressive_decline_threshold:
                                return Action.D
                            else:
                                return Action.D
                        except:
                            return Action.D
                    else:
                        return Action.D
                else:
                    return Action.D
            else:
                return Action.D
        elif stock >= self.threshold_critical:
            if rounds_remaining > 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_401(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Defection
    
    Maximizes personal gain by exploiting cooperators, depleting commons strategically,
    and adapting based on observable opponent behavior and remaining rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperators_observed = False
        self.defectors_observed = False
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        self._update_observations(history)
        if self.cooperators_observed:
            return Action.D
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio > 0.6:
            return Action.D
        round_ratio = state.round_number / self.game_description.n_rounds
        if round_ratio >= 0.75:
            return Action.D
        if stock_ratio < 0.3:
            return Action.D
        if 0.3 < stock_ratio < 0.6 and (not self.defectors_observed) and self._is_stock_increasing(state):
            return Action.C
        return Action.D

    def _update_observations(self, history: PlayerHistory) -> None:
        """
        Scan all previous rounds to detect if any opponent has played C or D.
        """
        if history is None:
            return
        for round_idx in range(history.opponent_actions.shape[0]):
            for player_idx in range(history.opponent_actions.shape[1]):
                action = history.opponent_actions[round_idx, player_idx]
                if action:
                    self.cooperators_observed = True
                else:
                    self.defectors_observed = True

    def _is_stock_increasing(self, state: CommonPoolState) -> bool:
        """
        Determine if stock is increasing from the previous round.
        """
        if self.previous_stock is None:
            self.previous_stock = state.current_stock
            return False
        is_increasing = state.current_stock >= self.previous_stock
        self.previous_stock = state.current_stock
        return is_increasing

class Strategy_EXPLOITATIVE_402(BaseStrategy):
    """
    Exploitative Strategy: Dynamic Depletion Farming
    
    Exploits asymmetry between cooperative and defective payoffs while managing
    stock dynamics. Defects aggressively early-to-mid game, reads opponent behavior,
    and shifts to cooperation only when forced by approaching stock collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.D
        aggressive_end = math.floor(2 * self.r / 3)
        transition_end = math.floor(5 * self.r / 6)
        if current_round < aggressive_end:
            phase = 'aggressive'
        elif current_round < transition_end:
            phase = 'transition'
        else:
            phase = 'endgame'
        opponent_coop_rate = self._calculate_opponent_coop_rate(history)
        rounds_remaining = self.r - current_round
        if stock < self.capacity * 0.2 and rounds_remaining > 2:
            return Action.C
        if stock > self.capacity * 0.9:
            return Action.D
        if phase == 'aggressive':
            return Action.D
        elif phase == 'transition':
            if stock < self.capacity * 0.4:
                return Action.D
            elif opponent_coop_rate > 0.6:
                return Action.D
            else:
                return Action.C
        elif current_round == self.r - 1:
            if stock > self.capacity * 0.15:
                return Action.D
            else:
                return Action.C
        elif stock < self.capacity * 0.25:
            return Action.D
        else:
            return Action.C

    def _calculate_opponent_coop_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the empirical cooperation rate of all opponents combined.
        Returns a value in [0, 1].
        """
        if history.opponent_actions.size == 0:
            return 0.5
        current_round = history.my_actions.shape[0]
        total_opponent_actions = self.n * current_round
        if total_opponent_actions == 0:
            return 0.5
        total_cooperations = np.sum(history.opponent_actions)
        coop_rate = total_cooperations / total_opponent_actions
        return float(coop_rate)

class Strategy_EXPLOITATIVE_403(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Dynamic Threshold
    
    Core philosophy: Extract maximum value by identifying and parasitizing
    cooperative opponents while maintaining plausible deniability through
    opportunistic defection. Always defect except in impossible conditions,
    prioritizing immediate extraction over sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if stock < 2 * self.n_players:
            return Action.D
        cooperators_last_round = int(sum(history.opponent_actions[-1, :]))
        defectors_last_round = self.n_players - cooperators_last_round
        if cooperators_last_round > 0:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_404(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Cooperation
    
    This strategy exploits the asymmetry between cooperative and defective payoffs
    while maximizing total extraction over the game horizon. It adapts to observed
    opponent behavior to determine whether to maintain extraction or shift to
    predatory defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        defection_ratio = self._calculate_defection_ratio(history, round_number)
        if round_number == self.n_rounds - 1:
            return Action.D
        if round_number == self.n_rounds - 2:
            if current_stock >= self.capacity / 1.5:
                return Action.D
            else:
                return Action.C
        if defection_ratio >= 0.5:
            return Action.D
        if round_number <= self.n_rounds / 3:
            return Action.C
        if current_stock < self.capacity / 2 and round_number < self.n_rounds - 2:
            if defection_ratio > 0.5:
                return Action.D
            else:
                return Action.C
        if defection_ratio >= 0.3:
            prob_defect = (defection_ratio - 0.3) / 0.2
            if random.random() < prob_defect:
                return Action.D
            else:
                return Action.C
        return Action.D

    def _calculate_defection_ratio(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the ratio of defections observed across all opponents.
        
        Returns a value between 0 and 1, where 1 means all opponents defected
        in all rounds, and 0 means all opponents cooperated.
        """
        if round_number == 0:
            return 0.0
        opponent_actions_so_far = history.opponent_actions[:round_number, :]
        total_opponent_actions = round_number * (self.n_players - 1)
        if total_opponent_actions == 0:
            return 0.0
        cooperations = np.sum(opponent_actions_so_far)
        defection_count = total_opponent_actions - cooperations
        defection_ratio = defection_count / total_opponent_actions
        return defection_ratio

class Strategy_EXPLOITATIVE_405(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Dynamic Defection
    
    This strategy exploits the asymmetry between cooperators and defectors by:
    1. Always defecting in the first round to establish dominance
    2. Using a stock-dependent threshold that declines over time
    3. Detecting and exploiting periods of high cooperation
    4. Always defecting in the final round
    5. Defecting aggressively when stock collapses
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_window = 3
        self.stock_collapse_threshold = 0.2
        self.cooperation_threshold = 0.5
        self.high_stock_threshold = 0.7
        self.low_stock_threshold = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        round_num = state.round_number
        rounds_remaining = n_rounds - round_num
        threshold = capacity * math.pow(rounds_remaining / n_rounds, 0.6)
        if current_stock < capacity * self.low_stock_threshold:
            return Action.D
        observed_cooperation_rate = self._calculate_cooperation_rate(history, round_num)
        if observed_cooperation_rate > self.cooperation_threshold and current_stock > capacity * self.high_stock_threshold:
            return Action.D
        if current_stock > threshold:
            return Action.D
        else:
            return Action.C

    def _calculate_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the observed cooperation rate of opponents in the last k rounds.
        Returns a value between 0 and 1.
        """
        if current_round == 0:
            return 0.0
        start_round = max(0, current_round - self.cooperation_window)
        end_round = current_round
        window_actions = history.opponent_actions[start_round:end_round, :]
        if window_actions.size == 0:
            return 0.0
        cooperation_rate = float(np.sum(window_actions)) / float(window_actions.size)
        return cooperation_rate

class Strategy_EXPLOITATIVE_406(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Exploits asymmetry between cooperative and defective payoffs while adapting to stock depletion.
    Core strategy: Defect when stock is abundant, cooperate only when stock depletion forces adaptation.
    Always defect in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_stock = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        rounds_remaining = self.game_description.n_rounds - state.round_number
        total_rounds = self.game_description.n_rounds
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        base_threshold = capacity / n * (rounds_remaining / total_rounds)
        stock_loss = self.last_stock - current_stock
        expected_loss_all_cooperate = self.last_stock / 2.0
        expected_loss_all_defect = self.last_stock
        denominator = expected_loss_all_defect - expected_loss_all_cooperate
        if denominator > 1e-09:
            defection_ratio = (stock_loss - expected_loss_all_cooperate) / denominator
            defection_ratio = max(0.0, min(1.0, defection_ratio))
        else:
            defection_ratio = 0.0
        decay_factor = 1.0 - 0.4 * defection_ratio
        adjusted_threshold = base_threshold * decay_factor
        self.last_stock = current_stock
        if current_stock > adjusted_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_407(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Collapse Recovery
    
    Exploits cooperative environments through stock-dependent thresholds:
    - Defects aggressively when stock is abundant (safe_threshold = 60% capacity)
    - Cooperates only when forced by scarcity (critical_threshold = 15% capacity)
    - Adapts behavior across game phases: early aggression, midgame extraction, endgame positioning
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.safe_threshold = game_description.capacity * 0.6
        self.critical_threshold = game_description.capacity * 0.15
        self.early_phase_end = math.floor(game_description.n_rounds / 3)
        self.mid_phase_end = math.floor(2 * game_description.n_rounds / 3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_stock <= self.critical_threshold:
            return Action.C
        if current_round <= self.early_phase_end:
            return Action.D
        if current_round <= self.mid_phase_end:
            if current_stock > self.safe_threshold:
                return Action.D
            return Action.D
        rounds_remaining = total_rounds - current_round
        if rounds_remaining <= 2:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_408(BaseStrategy):
    """
    Adaptive Extraction strategy for Common Pool Resource games.
    
    Exploits cooperators while adaptively matching defectors. Defects aggressively
    in round 1 and the final round, cooperates when stock is critically low to force
    regeneration, and uses recent opponent defection rates to guide mid-game behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        stock = state.current_stock
        if round_number == 0:
            return Action.D
        if round_number == self.n_rounds - 1:
            return Action.D
        critical_threshold = self.capacity * 0.3
        if stock < critical_threshold:
            return Action.C
        defection_rate = self._calculate_recent_defection_rate(history, round_number)
        healthy_threshold = self.capacity * 0.6
        if stock >= healthy_threshold:
            if defection_rate <= 0.3:
                return Action.D
            elif defection_rate > 0.5:
                return Action.D
            elif round_number <= self.n_rounds / 2:
                return Action.D
            elif stock >= healthy_threshold:
                return Action.C
            else:
                return Action.D
        moderate_threshold = self.capacity * 0.6
        if stock < moderate_threshold:
            if round_number <= self.n_rounds / 2:
                return Action.D
            else:
                if round_number > 0:
                    last_round_defections = np.sum(~history.opponent_actions[round_number - 1, :])
                    if last_round_defections == self.n_players - 1:
                        return Action.D
                return Action.C
        return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the defection rate of opponents in the last 3 rounds.
        Returns a float in [0, 1] representing proportion of defections.
        """
        if round_number == 0:
            return 0.0
        lookback_rounds = min(3, round_number)
        start_idx = max(0, round_number - lookback_rounds)
        recent_actions = history.opponent_actions[start_idx:round_number, :]
        defections = np.sum(~recent_actions)
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        defection_rate = defections / total_actions
        return defection_rate

class Strategy_EXPLOITATIVE_409(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Dynamic Defection
    
    Maximizes personal payoff by consistently defecting to extract twice the payoff
    of cooperators (S/n vs S/2n). Adapts to stock health but maintains defection as
    dominant strategy throughout all game phases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.low_stock_consecutive_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number >= self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if capacity <= 0:
            return Action.D
        stock_health = current_stock / capacity
        if stock_health < 0.3:
            self.low_stock_consecutive_rounds += 1
        else:
            self.low_stock_consecutive_rounds = 0
        if current_stock <= 2 * self.game_description.n_players:
            return Action.D
        if stock_health >= 0.6:
            return Action.D
        elif stock_health >= 0.3:
            return Action.D
        elif self.low_stock_consecutive_rounds >= 2:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_410(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Treats the common pool as a resource to be extracted before others do.
    Uses dynamic threshold-based defection that becomes more aggressive early
    in the game when stock is highest, with fallback cooperation rules to
    prevent total collapse and extract remaining value in depleted states.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.consecutive_defection_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        t = current_round + 1
        if t == self.n_rounds:
            return Action.D
        if self.capacity > 0 and current_stock / self.capacity < 0.05:
            self.consecutive_defection_rounds = 0
            return Action.C
        if self.capacity > 0 and current_stock / self.capacity < 0.3:
            if self.consecutive_defection_rounds > 2:
                self.consecutive_defection_rounds = 0
                return Action.C
        threshold = self.capacity * (1.0 - t / self.n_rounds * 0.85)
        if current_stock > threshold:
            self.consecutive_defection_rounds += 1
            return Action.D
        else:
            self.consecutive_defection_rounds = 0
            return Action.C

class Strategy_EXPLOITATIVE_411(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Dynamic Threshold Switching
    
    Operates in three phases:
    1. Aggressive Defection (early game) - maximize immediate gains
    2. Adaptive Observation (middle game) - switch based on opponent behavior and stock
    3. Endgame Ruthlessness (final rounds) - unconditional defection
    
    Exploits cooperators, mirrors defectors, and refuses sustainability when advantageous.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round > self.n_rounds - 3:
            return Action.D
        if stock <= 0.1:
            return Action.D
        phase1_threshold = min(self.n_rounds / 2.0, 3)
        if current_round <= phase1_threshold:
            if stock < self.capacity * 0.25:
                pass
            else:
                return Action.D
        total_opponent_actions = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
        if total_opponent_actions == 0:
            return Action.D
        total_opponent_defections = total_opponent_actions - np.sum(history.opponent_actions)
        defection_rate = float(total_opponent_defections) / float(total_opponent_actions)
        if defection_rate > 0.6:
            return Action.D
        if stock > self.capacity * 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_412(BaseStrategy):
    """
    Exploitative strategy with adaptive depletion and conditional defection.
    
    Core logic:
    - Defect aggressively when stock is abundant (>60% capacity)
    - Mixed strategy in mid-range stock levels
    - Cooperate only when stock is critically low (<15% capacity)
    - Always defect in final round
    - Adapt thresholds based on observed opponent defection rate
    - Special handling for first round based on group size
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock = state.current_stock
        if round_t == self.n_rounds - 1:
            return Action.D
        if round_t == 0:
            if self.n_players <= 4:
                return Action.D
            else:
                return Action.C
        opponent_defection_rate = self._compute_opponent_defection_rate(history, round_t)
        threshold_adjustment = -0.15 if opponent_defection_rate > 0.7 else 0.0
        high_threshold = self.capacity * (0.6 + threshold_adjustment)
        mid_high_threshold = self.capacity * (0.3 + threshold_adjustment)
        mid_low_threshold = self.capacity * (0.15 + threshold_adjustment)
        critical_threshold = self.capacity * 0.05
        if stock > high_threshold:
            return Action.D
        elif stock > mid_high_threshold:
            return Action.D if random.random() < 0.8 else Action.C
        elif stock > mid_low_threshold:
            return Action.D if random.random() < 0.5 else Action.C
        elif stock > critical_threshold:
            return Action.C
        else:
            return Action.C

    def _compute_opponent_defection_rate(self, history: PlayerHistory, round_t: int) -> float:
        """
        Compute the defection rate of opponents from rounds 0 to round_t-1.
        
        opponent_actions is indexed [round, player].
        True/1 = Cooperate (Action.C), False/0 = Defect (Action.D).
        So defection count = total actions - cooperations.
        """
        if round_t == 0:
            return 0.0
        total_opponent_actions = round_t * (self.n_players - 1)
        total_cooperations = int(np.sum(history.opponent_actions[:round_t, :]))
        total_defections = total_opponent_actions - total_cooperations
        if total_opponent_actions == 0:
            return 0.0
        defection_rate = total_defections / total_opponent_actions
        return defection_rate

class Strategy_EXPLOITATIVE_413(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Stock-Aware Defection
    
    Exploits asymmetry between cooperators and defectors by:
    1. Defecting when stock is abundant (rounds 1, mid-game with healthy stock)
    2. Cooperating only when stock is critically low (forced recovery)
    3. Defecting heavily in end-game regardless of stock
    4. Using stock thresholds to dynamically manage extraction
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_collapse = self.capacity * 0.05
        self.threshold_recovery = self.capacity * 0.2
        self.threshold_sustainable = self.capacity * 0.6
        self.end_game_horizon = max(2, math.floor(self.n_rounds * 0.15))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.D
        rounds_remaining = self.n_rounds - round_number
        if rounds_remaining == 0:
            return Action.D
        if rounds_remaining <= self.end_game_horizon:
            return Action.D
        if current_stock <= self.threshold_collapse:
            return Action.C
        if current_stock <= self.threshold_recovery:
            return Action.C
        if current_stock >= self.threshold_sustainable:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_414(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Treats the common pool as a resource to extract maximum personal value from.
    Defects strategically based on rounds remaining, stock health, and observed
    opponent defection rates. Cooperates only in early rounds to gather information
    and establish false reputation for later exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_rounds = math.ceil(game_description.n_rounds / 3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock_s = state.current_stock
        rounds_remaining = self.n_rounds - round_t
        if round_t == 0:
            return Action.C
        if rounds_remaining == 1:
            return Action.D
        if rounds_remaining <= self.threshold_rounds:
            if stock_s < 2 * self.n_players:
                return Action.D
            if random.random() < 0.9:
                return Action.D
            return Action.C
        if stock_s < 2 * self.n_players:
            return Action.D
        stock_ratio = stock_s / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio > 0.7:
            return Action.D
        if stock_ratio < 0.3:
            return Action.D
        rounds_played = round_t
        total_opponent_defections = np.sum(~history.opponent_actions[:rounds_played, :])
        max_possible_defections = rounds_played * (self.n_players - 1)
        observed_defection_rate = 0.0
        if max_possible_defections > 0:
            observed_defection_rate = total_opponent_defections / max_possible_defections
        if observed_defection_rate > 0.6:
            return Action.D
        threshold_mid = math.ceil(2 * self.n_rounds / 3)
        if round_t >= round_t >= self.threshold_rounds and round_t < threshold_mid:
            if round_t >= 2:
                recent_stocks = history.my_payoffs[max(0, round_t - 3):round_t]
                if len(recent_stocks) >= 2:
                    stock_declining = recent_stocks[-1] < recent_stocks[0]
                    if stock_declining or observed_defection_rate > 0.5:
                        return Action.D
            if observed_defection_rate <= 0.4:
                return Action.D
        if round_t > 2:
            if observed_defection_rate <= 0.4:
                return Action.D
            if observed_defection_rate >= 0.4:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_415(BaseStrategy):
    """
    Exploitative Strategy: "Adaptive Extraction with Collapse Monitoring"
    
    Exploits the asymmetry between cooperative and defective payoffs (2x multiplier)
    while monitoring resource depletion. Defects aggressively in early rounds and
    final round, with adaptive behavior in middle rounds based on stock levels
    and opponent cooperation rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - round_number - 1
        if round_number == 0:
            return Action.D
        if round_number == self.n_rounds - 1:
            return Action.D
        opponent_cooperation_rate = self._calculate_opponent_cooperation_rate(history, round_number)
        if opponent_cooperation_rate > 0.6:
            return Action.D
        threshold = self.capacity * 0.4
        if current_stock > threshold:
            return Action.D
        elif rounds_remaining > 3:
            return Action.C
        else:
            return Action.D

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the average cooperation rate of opponents based on observed history.
        
        True/1 = Cooperate (Action.C), False/0 = Defect (Action.D)
        Cooperation is indicated by lower consumption: C action at round t.
        """
        if round_number == 0:
            return 0.0
        observed_rounds = min(round_number, history.opponent_actions.shape[0])
        if observed_rounds == 0:
            return 0.0
        total_cooperations = np.sum(history.opponent_actions[:observed_rounds, :])
        total_observations = observed_rounds * history.opponent_actions.shape[1]
        if total_observations == 0:
            return 0.0
        cooperation_rate = float(total_cooperations) / float(total_observations)
        return cooperation_rate

class Strategy_EXPLOITATIVE_416(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Treats the common pool as a resource to extract maximum personal value by:
    1. Defecting when stock is healthy (above dynamic threshold)
    2. Exploiting signals of cooperative behavior (stock growth)
    3. Escalating defection when detecting defection arms race
    4. Pure defection in endgame (final 15% of rounds)
    5. Brief tactical cooperation only to prevent total collapse
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        capacity = self.capacity
        n_rounds = self.n_rounds
        if current_round >= n_rounds * 0.85:
            return Action.D
        if current_stock < capacity * 0.1:
            return Action.C
        if current_stock < capacity * 0.15 and current_round < n_rounds * 0.5:
            if current_round > 0 and history.my_actions[current_round - 1]:
                return Action.D
            else:
                return Action.C
        if current_round >= 1 and history is not None:
            previous_stock = self._get_previous_stock(history, current_round)
            stock_change = current_stock - previous_stock
            if stock_change > 0 and current_stock > capacity * 0.6:
                return Action.D
            if stock_change < -capacity * 0.2 and current_round < n_rounds * 0.8:
                return Action.D
        dynamic_threshold = capacity * (1.0 - current_round / n_rounds * 0.7)
        if current_stock > dynamic_threshold:
            return Action.D
        else:
            return Action.C

    def _get_previous_stock(self, history: PlayerHistory, current_round: int) -> float:
        """
        Reconstruct previous stock level from payoff history.
        
        In round t, if action was C: payoff = stock_t / (2 * n_players)
        In round t, if action was D: payoff = stock_t / n_players
        
        We use our own payoff and action to infer the stock at that round.
        """
        if current_round <= 0:
            return self.capacity
        prev_round = current_round - 1
        prev_payoff = history.my_payoffs[prev_round]
        prev_action = history.my_actions[prev_round]
        if prev_action:
            prev_stock = prev_payoff * 2 * self.n_players
        else:
            prev_stock = prev_payoff * self.n_players
        return max(0.0, prev_stock)

class Strategy_EXPLOITATIVE_417(BaseStrategy):
    """
    Adaptive Predation: An exploitative strategy that defects early to establish dominance,
    monitors opponent behavior and stock health, and extracts maximum value before resource collapse.
    Adapts based on opponent defection rates and stock trajectories, but biased toward exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        rounds_remaining = self.n_rounds - current_round - 1
        if stock_ratio < 0.15:
            return Action.D
        if rounds_remaining <= 1:
            return Action.D
        opponent_defection_rate = self._calculate_opponent_defection_rate(history, current_round)
        stock_trend = self._calculate_stock_trend(history, current_round)
        if stock_ratio < 0.3 or stock_trend < -0.15:
            return Action.D
        if opponent_defection_rate > 0.65:
            return Action.D
        if opponent_defection_rate > 0.45:
            return Action.D
        if opponent_defection_rate < 0.25:
            if self._all_opponents_cooperated_last_round(history):
                if stock_ratio > 0.6:
                    return Action.C
            return Action.D
        if stock_ratio > 0.6 and opponent_defection_rate < 0.25:
            return Action.C
        return Action.D

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the proportion of defections by opponents across all rounds.
        True/1 = Cooperate, False/0 = Defect
        Defection rate = count of False values / total actions
        """
        if current_round == 0:
            return 0.0
        opponent_actions_so_far = history.opponent_actions[:current_round, :]
        total_actions = opponent_actions_so_far.size
        if total_actions == 0:
            return 0.0
        defection_count = np.sum(opponent_actions_so_far == 0)
        return float(defection_count) / float(total_actions)

    def _calculate_stock_trend(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate stock trend as (stock_t - stock_t-1) / stock_t-1
        Returns 0 if we can't calculate (not enough history)
        """
        if current_round < 1:
            return 0.0
        if current_round == 1:
            return 0.0
        last_round_payoff = np.sum(history.my_payoffs[current_round - 1])
        prev_round_payoff = np.sum(history.my_payoffs[current_round - 2])
        my_recent_payoff = history.my_payoffs[current_round - 1]
        my_prev_payoff = history.my_payoffs[current_round - 2]
        if my_prev_payoff > 0:
            return (my_recent_payoff - my_prev_payoff) / my_prev_payoff
        return 0.0

    def _all_opponents_cooperated_last_round(self, history: PlayerHistory) -> bool:
        """
        Check if all opponents played Cooperate (True) in the last round.
        """
        last_round_opponent_actions = history.opponent_actions[-1, :]
        return np.all(last_round_opponent_actions == 1)

class Strategy_EXPLOITATIVE_418(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with State Monitoring
    
    Core philosophy: Ruthlessly defect to extract maximum value (2x cooperation payoff),
    while monitoring stock levels. Always defect regardless of stock state, with special
    emphasis on round 1 and final round to establish dominance and maximize terminal payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.sustainable_threshold = game_description.capacity * 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_419(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Dynamic Thresholding
    
    Exploits the asymmetry between cooperative and defective payoffs by using
    dynamic thresholds to defect when stock is abundant and cooperate only when
    necessary. Targets naive/cooperative opponents and maximizes relative gain
    through temporal arbitrage and threshold gaming.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            if stock > 0:
                return Action.D
            else:
                return Action.C
        progress = round_num / self.n_rounds
        threshold = self.capacity * (1.0 - pow(progress, 1.5))
        if round_num <= 1 and stock >= 0.7 * self.capacity:
            return Action.D
        if round_num >= self.n_rounds - 2:
            if stock > self.capacity / 4.0:
                return Action.D
            else:
                return Action.C
        if stock < self.capacity / 20.0 and stock > 0:
            return Action.C
        if stock > threshold:
            if round_num > 0:
                opponent_coop_last_round = float(np.sum(history.opponent_actions[-1, :]))
                coop_rate = opponent_coop_last_round / self.n_players
                if coop_rate > 0.5 and stock > self.capacity / 2.0:
                    return Action.D
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_420(BaseStrategy):
    """
    Adaptive Predation with Sustainability Exploitation.
    
    Core strategy: Defect aggressively when stock is healthy to extract maximum value.
    Cooperate tactically only when stock falls below critical thresholds to sustain future defection.
    Always defect in the final round regardless of stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.previous_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        cooperation_threshold = 0.3 * self.capacity
        if history is not None and len(history.my_payoffs) > 0:
            stock_decline_ratio = (self.previous_stock - current_stock) / (self.previous_stock + 1e-09)
            if stock_decline_ratio > 0.5:
                cooperation_threshold = 0.4 * self.capacity
        self.previous_stock = current_stock
        if current_stock <= 0.05 * self.capacity:
            return Action.C
        if current_stock < cooperation_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_421(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Conditional Cooperation
    
    Prioritizes personal payoff maximization by exploiting cooperative opponents.
    Uses stock-dependent decision rules to balance defection (high payoff) with
    conditional cooperation (pool sustainability) based on current stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainability_threshold = self.capacity * 0.6
        self.collapse_threshold = self.capacity * 0.2
        self.cooperator_detection_threshold = self.capacity * 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            if current_stock > 0:
                return Action.D
            else:
                return Action.C
        cooperator_count = int(np.sum(history.opponent_actions[current_round - 1, :]))
        stock_declining = False
        if current_round >= 1:
            previous_stock = state.current_stock
            stock_declining = cooperator_count < self.n_players // 2
        rounds_remaining = self.n_rounds - current_round
        if current_stock > self.sustainability_threshold:
            if cooperator_count >= 1:
                return Action.D
            else:
                return Action.D
        elif current_stock <= self.collapse_threshold:
            if rounds_remaining < 2:
                return Action.D
            else:
                return Action.C
        else:
            majority_cooperators = cooperator_count >= math.ceil(self.n_players / 2)
            if majority_cooperators and stock_declining:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_422(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Dynamic Threshold Switching
    
    Exploits cooperators by defecting by default, cooperating only when stock
    depletion forces it, and abandoning cooperation in end-game rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_level = 2 * self.n
        self.exploitation_threshold = 0.4
        self.end_game_threshold = max(2, self.r // 4)
        self.stock_recovery_tolerance = 0.8 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        current_round = state.round_number
        stock = state.current_stock
        rounds_remaining = self.r - current_round
        if rounds_remaining <= self.end_game_threshold:
            return Action.D
        cooperation_rate = self._calculate_cooperation_rate(history, current_round)
        if stock < self.critical_level:
            return Action.C
        if stock > self.stock_recovery_tolerance and cooperation_rate > 0.6:
            return Action.D
        if cooperation_rate > self.exploitation_threshold:
            return Action.D
        if cooperation_rate <= 0.25:
            return Action.D
        if cooperation_rate > 0.5 and current_round % 5 == 0:
            return Action.C
        return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the observed cooperation rate in the previous round.
        
        Args:
            history: Player history with opponent actions
            current_round: Current round number (0-indexed)
        
        Returns:
            Proportion of opponents who cooperated in round (current_round - 1)
        """
        if current_round <= 0:
            return 0.0
        previous_round_idx = current_round - 1
        if history.opponent_actions.size == 0:
            return 0.0
        opponent_cooperations = history.opponent_actions[previous_round_idx, :]
        cooperation_count = np.sum(opponent_cooperations)
        if self.n == 0:
            return 0.0
        cooperation_rate = float(cooperation_count) / float(self.n)
        return min(1.0, max(0.0, cooperation_rate))

class Strategy_EXPLOITATIVE_423(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with State-Based Opportunism
    
    Exploits asymmetry between cooperators and defectors by:
    1. Defecting when stock falls below 40% capacity (depletion detection)
    2. Defecting when majority of opponents defected in previous round
    3. Defecting unconditionally in final 2 rounds (endgame ruthlessness)
    4. Defecting when stock declined >20% in previous round (cascading exploitation)
    5. Otherwise cooperating to gather intelligence and exploit cooperators
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock = state.current_stock
        round_num = state.round_number
        self.stock_history.append(stock)
        if round_num == 0:
            if stock < capacity * 0.4:
                return Action.D
            return Action.C
        if stock < capacity * 0.4:
            return Action.D
        if round_num >= r - 2:
            return Action.D
        if round_num >= 1:
            previous_round_defections = np.sum(~history.opponent_actions[round_num - 1, :])
            if previous_round_defections > n / 2:
                return Action.D
        if round_num >= 1 and len(self.stock_history) >= 2:
            stock_previous = self.stock_history[round_num - 1]
            if stock_previous > 0:
                stock_decline_rate = (stock_previous - stock) / stock_previous
                if stock_decline_rate > 0.2 and stock > 0:
                    return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_424(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Collapse Anticipation
    
    This strategy exploits resource asymmetries by defecting when stock is abundant,
    switching to cooperation only when stock becomes fragile (to preserve future payoffs),
    and returning to defection in the final round or when stock is near-depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players
        self.threshold_high = 0.7 * self.capacity
        self.threshold_medium = 0.4 * self.capacity
        self.threshold_low = 0.15 * self.capacity
        self.rapid_depletion_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        current_stock = state.current_stock
        current_round = state.round_number
        is_final_round = current_round == self.n_rounds - 1
        if history is not None and current_round >= 1:
            prev_stock = self._get_previous_stock(history, current_round)
            if prev_stock > 0:
                decline_rate = (prev_stock - current_stock) / prev_stock
                if decline_rate > 0.3:
                    self.rapid_depletion_counter = 2
        if self.rapid_depletion_counter > 0:
            self.rapid_depletion_counter -= 1
            return Action.D
        if current_stock > self.threshold_high:
            return Action.D
        elif current_stock > self.threshold_medium:
            return Action.D
        elif current_stock > self.threshold_low:
            if is_final_round:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _get_previous_stock(self, history: PlayerHistory, current_round: int) -> float:
        """
        Reconstruct previous stock level from history.
        
        We work backwards: given current stock and current round's actions,
        we can estimate the stock level before growth in the current round.
        
        This is an approximation since we don't have explicit stock history,
        but we use a heuristic: compare average payoffs to infer stock levels.
        """
        if current_round == 1:
            return self.capacity
        prev_round_payoffs = history.my_payoffs[current_round - 1]
        estimated_prev_stock = prev_round_payoffs * 2 * self.n_players
        estimated_prev_stock = max(0, min(estimated_prev_stock, self.capacity * 2))
        return estimated_prev_stock

class Strategy_EXPLOITATIVE_425(BaseStrategy):
    """
    Exploitative strategy with stock monitoring for Common Pool Resource Game.
    
    Core approach: Defect when stock is abundant or moderately depleted, but switch to
    cooperation only when stock drops to critical levels to prevent total collapse.
    Always defect in first and last rounds to maximize extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = 1.5 * self.capacity
        self.threshold_critical = 0.2 * self.capacity
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        self.stock_history.append(current_stock)
        if current_round == 0 or current_round == self.n_rounds - 1:
            return Action.D
        adjusted_threshold_critical = self.threshold_critical
        if len(self.stock_history) >= 3:
            recent_depletion = (self.stock_history[-3] - self.stock_history[-1]) / max(3, len(self.stock_history))
            sustainable_depletion = self.capacity / self.n_rounds
            if recent_depletion > sustainable_depletion:
                adjusted_threshold_critical = self.threshold_critical * 1.1
        if current_stock <= adjusted_threshold_critical:
            return Action.C
        if current_stock > self.threshold_high:
            return Action.D
        if current_stock > adjusted_threshold_critical:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_426(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Collapse Management
    
    This strategy exploits the asymmetry between cooperators and defectors while managing
    resource collapse risk. It uses stock-aware dynamic thresholds to decide between
    cooperation (stock preservation) and defection (payoff maximization).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.consecutive_stagnant_rounds = 0
        self.last_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        min_viable_stock = 2 * self.n_players
        if current_stock < min_viable_stock:
            return Action.C
        threshold = self.capacity * (0.5 - 0.1 * current_round / self.n_rounds)
        if history is not None:
            if self.last_stock is not None:
                if abs(current_stock - self.last_stock) < 0.1:
                    self.consecutive_stagnant_rounds += 1
                else:
                    self.consecutive_stagnant_rounds = 0
            self.last_stock = current_stock
            if self.consecutive_stagnant_rounds >= 2:
                if random.random() < 0.3:
                    return Action.C
        if current_stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_427(BaseStrategy):
    """
    Adaptive Predation Strategy for Common Pool Resource Game.
    
    Exploits the 2x payoff advantage of defection while adapting to opponent behavior
    and stock levels to avoid collapse. Uses stock-conditional defection with opponent
    modeling to maximize extraction across all rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        rounds_remaining = self.r - round_num
        if history is None:
            if self.capacity < 3 * self.n:
                return Action.C
            return Action.D
        opponent_defection_rate = self._calculate_opponent_defection_rate(history)
        base_threshold = 2 * self.n * rounds_remaining / (rounds_remaining + 1) if rounds_remaining > 0 else 2 * self.n
        if opponent_defection_rate > 0.7:
            threshold = base_threshold * 1.2
        elif opponent_defection_rate < 0.3:
            threshold = base_threshold * 0.9
        else:
            threshold = base_threshold
        if rounds_remaining <= 2 and stock >= 2 * self.n:
            return Action.D
        if round_num <= 2:
            if self.capacity < 3 * self.n:
                return Action.C
            return Action.D
        if stock < self.n:
            return Action.C
        if stock >= self.capacity:
            return Action.D
        if stock >= threshold:
            return Action.D
        else:
            return Action.C

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the empirical defection rate of all opponents collectively.
        Returns a float in [0, 1] representing the proportion of defections.
        """
        opponent_actions = history.opponent_actions
        if opponent_actions.size == 0:
            return 0.0
        total_actions = opponent_actions.size
        defections = np.sum(~opponent_actions)
        defection_rate = defections / total_actions if total_actions > 0 else 0.0
        return float(defection_rate)

class Strategy_EXPLOITATIVE_428(BaseStrategy):
    """
    Exploitative strategy with adaptive predation and regime detection.
    Exploits cooperators while adapting to stock levels and opponent composition.
    Uses defection as default, conditional cooperation during moderate stock phases,
    and end-game aggression in final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - round_num
        if round_num <= 1:
            return Action.D
        if rounds_remaining <= 2:
            return Action.D
        stock_health = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_health > 0.6:
            return Action.D
        if stock_health <= 0.3:
            if rounds_remaining > 2:
                return Action.C
            else:
                return Action.D
        completed_rounds = round_num
        if completed_rounds > 0:
            total_opponent_defections = 0.0
            for r in range(completed_rounds):
                for p in range(self.n_players - 1):
                    if not history.opponent_actions[r, p]:
                        total_opponent_defections += 1.0
            defection_rate = total_opponent_defections / (self.n_players - 1) / completed_rounds if completed_rounds > 0 else 0.0
            my_cumulative_payoff = float(np.sum(history.my_payoffs[:completed_rounds]))
            avg_opponent_payoff = float(np.mean(history.opponent_payoffs[:completed_rounds]))
            my_advantage = my_cumulative_payoff - avg_opponent_payoff
            if my_advantage > 0 and rounds_remaining > 2 and (defection_rate < 0.6):
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_429(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State-Aware Defection
    
    Core philosophy: Defect aggressively to maximize payoff (2x cooperation),
    only cooperate conditionally when stock nears collapse to preserve future
    exploitation opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock = 2 * self.n * 1.5
        self.warning_stock = self.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.r - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        if current_stock <= self.warning_stock:
            if current_round > 0 and history is not None:
                previous_stock = history.my_payoffs[current_round - 1]
                if current_round >= 2:
                    recent_rounds = min(3, current_round)
                    stock_changes = []
                    for i in range(current_round - recent_rounds, current_round):
                        if i > 0:
                            stock_changes.append(1)
                    mean_payoff_per_player = np.mean(history.my_payoffs[max(0, current_round - 3):current_round])
                    if mean_payoff_per_player < self.capacity / (4 * self.n):
                        rounds_remaining = self.r - current_round
                        if rounds_remaining >= 3:
                            return Action.C
        if current_stock > self.warning_stock and current_round > 0 and (history is not None):
            if current_round >= 1:
                recent_my_payoffs = history.my_payoffs[max(0, current_round - 2):current_round]
                if len(recent_my_payoffs) > 0 and np.mean(recent_my_payoffs) > self.capacity / (4 * self.n):
                    return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_430(BaseStrategy):
    """
    Adaptive Predation with Stock Monitoring: An exploitative strategy that
    maximizes extraction by defecting against cooperators, matching defectors,
    and adjusting behavior based on stock levels and opponent patterns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_high = 0.75
        self.threshold_low = 0.25
        self.critical_collapse = 0.1
        self.defection_rate_threshold_high = 0.66
        self.defection_rate_threshold_low = 0.33
        self.window_size = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.game_description.capacity * self.critical_collapse:
            return Action.C
        if state.current_stock <= 0:
            return Action.D
        rounds_played = state.round_number
        window_end = rounds_played
        window_start = max(0, rounds_played - self.window_size)
        window_length = window_end - window_start
        if window_length >= 2 and history is not None:
            recent_opponent_actions = history.opponent_actions[window_start:window_end, :]
            cooperations = np.sum(recent_opponent_actions)
            total_actions = recent_opponent_actions.size
            if total_actions > 0:
                cooperation_rate = cooperations / total_actions
                defection_rate = 1.0 - cooperation_rate
                if defection_rate > self.defection_rate_threshold_high:
                    return Action.D
                if cooperation_rate > 1.0 - self.defection_rate_threshold_low:
                    return Action.D
        stock_ratio = state.current_stock / self.game_description.capacity if self.game_description.capacity > 0 else 0.0
        if stock_ratio >= self.threshold_high:
            return Action.D
        elif stock_ratio < self.threshold_low:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_431(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Stock Sensing
    
    Defects aggressively when stock is healthy, switches to measured defection
    when stock deteriorates, with opponent modeling and collapse prevention.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.last_stock = game_description.capacity
        self.stock_drop_tracker = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        remaining_rounds = self.n_rounds - round_num
        if round_num == 0:
            return Action.D
        stock_drop = self.last_stock - stock
        self.last_stock = stock
        threshold = self.capacity * (1.0 + remaining_rounds / self.n_rounds) / 3.0
        if stock < self.capacity / 6.0:
            return Action.C
        if stock < self.capacity / 12.0:
            return Action.D
        if history is not None and len(history.opponent_actions) > 0:
            total_opponent_actions = history.opponent_actions.sum()
            total_possible = history.opponent_actions.size
            opponent_coop_rate = total_opponent_actions / total_possible if total_possible > 0 else 0.5
            if opponent_coop_rate > 0.6:
                threshold = threshold * 0.9
            elif opponent_coop_rate < 0.3:
                threshold = threshold * 1.05
            if stock_drop > 0.3 * self.capacity:
                threshold = threshold * 1.15
        if remaining_rounds == 1:
            threshold = threshold * 0.8
        if stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_432(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with State-Dependent Defection
    
    Exploits asymmetry between cooperation and defection while managing stock
    strategically. Defects by default, cooperates only tactically to prolong
    exploitation opportunities when pool is healthy and defection rates are low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_stock = state.current_stock
            return Action.D
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        stock_level = state.current_stock
        rounds_remaining = r - current_round
        if current_round == r - 1:
            self.previous_stock = stock_level
            if stock_level > 0:
                return Action.D
            else:
                return Action.C
        if stock_level <= 0.15 * capacity:
            self.previous_stock = stock_level
            return Action.D
        opponent_actions_last_round = history.opponent_actions[-1, :]
        defection_count_last_round = sum(~opponent_actions_last_round)
        defection_rate_last_round = defection_count_last_round / (n - 1) if n > 1 else 0
        if defection_rate_last_round > 0.5:
            self.previous_stock = stock_level
            return Action.D
        stock_trend = stock_level - self.previous_stock
        decline_threshold = -0.01 * capacity
        if stock_trend < decline_threshold:
            self.previous_stock = stock_level
            return Action.D
        if rounds_remaining <= 2:
            self.previous_stock = stock_level
            return Action.D
        if defection_rate_last_round == 0:
            self.previous_stock = stock_level
            return Action.D
        self.previous_stock = stock_level
        return Action.C

class Strategy_EXPLOITATIVE_433(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Prioritizes immediate extraction over sustainability by:
    1. Defecting in round 1 to establish aggressive baseline
    2. Defecting when stock is high (>70% capacity) to maximize payoff
    3. Defecting when stock is critically low (<30% capacity) to extract remaining value
    4. Adapting based on cooperator ratio in medium stock ranges
    5. Always defecting in final round for maximum extraction
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.previous_stock = game_description.capacity

    def _estimate_cooperator_ratio(self, history: PlayerHistory, current_stock: float) -> float:
        """
        Estimate the proportion of cooperators in the last round by analyzing stock change.
        
        If we defect and get payoff stock/n, and others also defect, total consumption is n*(stock/n) = stock.
        If k players cooperate and (n-k) defect:
        - Total consumption = k*(stock/(2n)) + (n-k)*(stock/n)
                            = stock*k/(2n) + stock*(n-k)/n
                            = stock*(k/(2n) + (n-k)/n)
                            = stock*(k + 2(n-k))/(2n)
                            = stock*(2n - k)/(2n)
        
        So: stock_consumed = stock * (2n - k) / (2n)
        Therefore: k = 2n - 2n*stock_consumed/stock
        
        We can infer from the actual stock change in the last round.
        """
        if len(history.opponent_actions) == 0:
            return 0.5
        last_round_actions = history.opponent_actions[-1, :]
        cooperator_count = np.sum(last_round_actions)
        cooperator_ratio = cooperator_count / self.n_players
        return cooperator_ratio

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determine action based on current round, stock level, and opponent behavior.
        """
        current_round = state.round_number
        current_stock = state.current_stock
        capacity = self.capacity
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock <= capacity * 0.3:
            return Action.D
        if current_stock > capacity * 0.7:
            return Action.D
        cooperator_ratio = self._estimate_cooperator_ratio(history, current_stock)
        if cooperator_ratio > 0.5:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_434(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Selective Cooperation
    
    Exploits the asymmetry between cooperators and defectors by defecting when
    advantageous, conditionally cooperating only to preserve the pool for future
    exploitation, and adapting to opponent behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.r - 1:
            return Action.D
        prev_round_idx = round_num - 1
        opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
        num_defectors = np.sum(~opponent_actions_prev)
        defection_rate = num_defectors / (self.n - 1) if self.n > 1 else 0.0
        if defection_rate >= 0.5:
            return Action.D
        if stock > self.capacity * 0.6:
            return Action.D
        if stock > self.capacity * 0.2:
            threshold = stock / (self.capacity * 0.6) - 1.0 / 3.0
            threshold = max(0.0, min(1.0, threshold))
            if random.random() < threshold:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_435(BaseStrategy):
    """
    Exploitative Strategy: Dynamic Predation with Adaptive Thresholds
    
    Exploits asymmetry between cooperative and defective payoffs while adaptively
    managing stock depletion. Defects aggressively when stock is healthy, but
    cooperates when stock falls below critical thresholds to prevent collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        log_r = math.log(self.r) if self.r > 1 else 1.0
        self.critical_threshold = self.capacity * (0.15 + 0.05 / log_r)
        self.exploitation_threshold = (self.n - 1) * (1.0 - 1.0 / (2.0 + self.r / 5.0))
        self.look_back_k = min(3, max(1, self.r // 2))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio < 0.1:
            return Action.C
        if stock_ratio < self.critical_threshold:
            return Action.C
        recent_cooperations = self._count_recent_cooperations(history, round_num)
        recent_cooperation_rate = recent_cooperations / (self.n - 1) / self.look_back_k if self.n - 1 > 0 else 0.0
        if round_num == self.r - 1:
            if stock > 0:
                return Action.D
            else:
                return Action.C
        if recent_cooperation_rate < 0.05:
            if stock_ratio > 0.4:
                return Action.D
            else:
                return Action.C
        if recent_cooperation_rate > self.exploitation_threshold:
            return Action.D
        if round_num >= 2:
            stock_drop = self._calculate_stock_drop(history, round_num)
            if stock_drop > 0.3 and stock_ratio > 0.2:
                return Action.D
        if round_num <= 2:
            if recent_cooperation_rate >= 0.95:
                return Action.D
        if round_num >= max(0, self.r - 2):
            if stock_ratio > 0.6:
                return Action.D
        return Action.D

    def _count_recent_cooperations(self, history: PlayerHistory, round_num: int) -> float:
        """Count cooperative actions from opponents in recent look-back window."""
        if round_num == 0 or history is None:
            return 0.0
        start_round = max(0, round_num - self.look_back_k)
        recent_actions = history.opponent_actions[start_round:round_num, :]
        if recent_actions.size == 0:
            return 0.0
        return float(np.sum(recent_actions))

    def _calculate_stock_drop(self, history: PlayerHistory, round_num: int) -> float:
        """Calculate relative stock drop over last 2 rounds."""
        if round_num < 2 or history is None:
            return 0.0
        try:
            prev_payoffs = history.my_payoffs[max(0, round_num - 2):round_num]
            if len(prev_payoffs) < 2:
                return 0.0
            if prev_payoffs[0] > 0:
                drop = (prev_payoffs[0] - prev_payoffs[-1]) / prev_payoffs[0]
                return max(0.0, drop)
        except (IndexError, ZeroDivisionError):
            return 0.0
        return 0.0

class Strategy_EXPLOITATIVE_436(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Defection Dominance
    
    Prioritizes individual payoff maximization by exploiting the asymmetry between
    C and D actions. Defaults to defection except in carefully calculated scenarios
    where temporary cooperation provides strategic advantage for stock preservation
    or opponent exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_cooperation_count = [0] * (self.n_players - 1)
        self.opponent_action_count = [0] * (self.n_players - 1)
        self.rounds_since_last_cooperate = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            self.rounds_since_last_cooperate = 0
            return Action.D
        self._update_opponent_stats(history)
        if current_round > self.n_rounds * 0.6:
            self.rounds_since_last_cooperate += 1
            return Action.D
        if stock < self.capacity * 0.3:
            self.rounds_since_last_cooperate += 1
            return Action.D
        if current_round <= 2:
            self.rounds_since_last_cooperate += 1
            return Action.D
        opponent_coop_rate = self._get_opponent_cooperation_rate()
        if stock > self.capacity * 1.2 and opponent_coop_rate < 0.3 and (self.rounds_since_last_cooperate > 3):
            self.rounds_since_last_cooperate = 0
            return Action.C
        self.rounds_since_last_cooperate += 1
        return Action.D

    def _update_opponent_stats(self, history: PlayerHistory) -> None:
        """Update opponent cooperation statistics from history."""
        last_round_idx = history.opponent_actions.shape[0] - 1
        for opponent_idx in range(self.n_players - 1):
            action = history.opponent_actions[last_round_idx, opponent_idx]
            self.opponent_action_count[opponent_idx] += 1
            if action:
                self.opponent_cooperation_count[opponent_idx] += 1

    def _get_opponent_cooperation_rate(self) -> float:
        """Calculate average cooperation rate of observed opponents."""
        total_actions = sum(self.opponent_action_count)
        if total_actions == 0:
            return 0.0
        total_cooperations = sum(self.opponent_cooperation_count)
        return total_cooperations / total_actions

class Strategy_EXPLOITATIVE_437(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy with Adaptive Defection.
    
    Exploits asymmetric payoff structure by defecting in healthy states while
    preventing self-sabotage through collapse detection. Uses state-based thresholds
    and cascade detection to maximize extraction while maintaining sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.prior_stocks = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == self.n_rounds - 1:
            return Action.D
        if current_stock < 2 * self.n_players:
            return Action.C
        if round_number == self.n_rounds - 2:
            return Action.D
        if history is not None:
            self.prior_stocks.append(current_stock)
        if history is not None and len(self.prior_stocks) >= 2:
            prior_stock = self.prior_stocks[-2]
            if prior_stock > 0:
                stock_decline_rate = (prior_stock - current_stock) / prior_stock
                if stock_decline_rate > 0.15:
                    return Action.D
        stock_health_ratio = current_stock / self.capacity if self.capacity > 0 else 0
        if stock_health_ratio > 0.4:
            return Action.D
        elif stock_health_ratio > 0.15:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_438(BaseStrategy):
    """
    Adaptive Predation: Exploitative Common Pool Resource Strategy
    
    Maximizes individual payoff by exploiting cooperators while adapting to competitive threats.
    Uses conditional defection with state-aware thresholds, collapse prevention, and end-game extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defector_counts = []
        self.last_stock_level = game_description.capacity
        self.cooperator_payoff_last_round = 0.0
        self.defector_payoff_last_round = 0.0

    def _detect_defectors(self, history: PlayerHistory, current_round: int) -> int:
        """Detect number of defectors by analyzing payoff patterns"""
        if current_round < 1:
            return 0
        window_start = max(0, current_round - 3)
        window = range(window_start, current_round)
        if not window:
            return 0
        defector_count = 0
        stock_at_round = self.last_stock_level
        for round_idx in window:
            opponent_actions = history.opponent_actions[round_idx, :]
            opponent_payoffs = history.opponent_payoffs[round_idx, :]
            for player_idx, (is_cooperator, payoff) in enumerate(zip(opponent_actions, opponent_payoffs)):
                if not is_cooperator and payoff > 0:
                    defector_count += 1
                    break
        return min(defector_count, self.n_players - 1)

    def _calculate_threshold_danger(self, current_round: int) -> float:
        """Calculate danger threshold: 4n early, 2n late"""
        progress = current_round / max(1, self.n_rounds)
        threshold = 2 * self.n_players * (2 - progress)
        return threshold

    def _analyze_payoffs(self, history: PlayerHistory, current_round: int) -> None:
        """Analyze cooperator vs defector payoffs from last round"""
        if current_round < 1:
            return
        last_round_idx = current_round - 1
        opponent_actions = history.opponent_actions[last_round_idx, :]
        opponent_payoffs = history.opponent_payoffs[last_round_idx, :]
        cooperator_payoffs = []
        defector_payoffs = []
        for is_cooperator, payoff in zip(opponent_actions, opponent_payoffs):
            if is_cooperator:
                cooperator_payoffs.append(payoff)
            else:
                defector_payoffs.append(payoff)
        self.cooperator_payoff_last_round = np.mean(cooperator_payoffs) if cooperator_payoffs else 0.0
        self.defector_payoff_last_round = np.mean(defector_payoffs) if defector_payoffs else 0.0

    def _calculate_stock_change(self, history: PlayerHistory, current_round: int) -> float:
        """Calculate percentage change in stock from last round"""
        if current_round < 1:
            return 0.0
        if current_round == 1:
            prev_stock = self.game_description.capacity
        else:
            prev_stock = self.last_stock_level
        change = (self.last_stock_level - prev_stock) / max(0.001, prev_stock)
        return change

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        self.last_stock_level = current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock <= 2 * self.n_players:
            return Action.C
        self._analyze_payoffs(history, current_round)
        defector_count = self._detect_defectors(history, current_round)
        stock_change = self._calculate_stock_change(history, current_round)
        threshold = self._calculate_threshold_danger(current_round)
        if current_stock < threshold:
            return Action.C
        if defector_count >= (self.n_players - 1) / 2:
            return Action.D
        if stock_change > 0.2 and defector_count < 1:
            return Action.D
        if stock_change < -0.3 and current_round < self.n_rounds / 2:
            return Action.C
        if self.cooperator_payoff_last_round > self.defector_payoff_last_round:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_439(BaseStrategy):
    """
    Adaptive Resource Extraction (ARE): An exploitative strategy that maximizes personal payoff
    by defecting by default while adapting to prevent catastrophic stock collapse.
    
    Core behaviors:
    - Round 1: DEFECT (establish aggressive positioning)
    - Rounds 2 to r-1: Conditional defection based on stock health and opponent behavior
    - Final round: DEFECT (no future consequences)
    - Emergency: COOPERATE only when stock threatens total depletion
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock <= 2 * self.n_players:
            return Action.C
        if current_stock < self.capacity / 2:
            opponent_coop_rate = self._calculate_opponent_cooperation_rate(history)
            if opponent_coop_rate >= 0.6:
                return Action.D
            elif current_stock < 3 * self.n_players:
                return Action.C
            else:
                return Action.D
        if current_stock >= self.capacity / 2:
            return Action.D
        return Action.D

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the mean cooperation rate across all opponents based on history.
        Returns a value in [0, 1] where 1 = all opponents always cooperated.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        total_cooperations = np.sum(history.opponent_actions)
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.0
        return float(total_cooperations) / float(total_actions)

class Strategy_EXPLOITATIVE_440(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Conditional Defection
    
    Exploits asymmetry between cooperators and defectors by:
    1. Defecting when stock is healthy (sustainability_ratio > 0.5)
    2. Conditionally defecting when stock is moderate (0.3 to 0.5)
    3. Cooperating only when stock is critical (< 0.3) to preserve future payoffs
    4. Always defecting in the last round
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.n_rounds - 1:
            return Action.D
        sustainability_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if sustainability_ratio > 0.5:
            return Action.D
        elif sustainability_ratio >= 0.3:
            if history is not None and round_number >= 3:
                recent_stocks = self._get_recent_stocks(history, round_number)
                if len(recent_stocks) >= 2 and self._is_declining_trend(recent_stocks):
                    return Action.D
            return Action.D
        else:
            return Action.C

    def _get_recent_stocks(self, history: PlayerHistory, current_round: int) -> list:
        """
        Reconstruct recent stock levels by working backwards from payoffs.
        Since payoff = stock / (2n) for cooperators and stock / n for defectors,
        we can estimate stock from observed payoffs and actions.
        
        Returns a list of estimated stock values for recent rounds.
        """
        stocks = []
        if current_round > 0:
            for round_idx in range(max(0, current_round - 3), current_round):
                my_action = history.my_actions[round_idx]
                my_payoff = history.my_payoffs[round_idx]
                if my_payoff > 0:
                    if my_action:
                        estimated_stock = my_payoff * (2 * self.n_players)
                    else:
                        estimated_stock = my_payoff * self.n_players
                    stocks.append(estimated_stock)
        return stocks

    def _is_declining_trend(self, stocks: list) -> bool:
        """
        Check if the stock list shows a declining trend.
        Returns True if stock is consistently decreasing.
        """
        if len(stocks) < 2:
            return False
        declining_count = 0
        for i in range(1, len(stocks)):
            if stocks[i] < stocks[i - 1]:
                declining_count += 1
        return declining_count > len(stocks) - 1 - declining_count

class Strategy_EXPLOITATIVE_441(BaseStrategy):
    """
    Exploitative Strategy: Dynamic Predation with Adaptive Thresholds
    
    Exploits cooperative behavior while maintaining veneer of sustainability.
    Defects by default, cooperates only when necessary to prevent collapse
    or to bait opponents into false security.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players
        self.min_sustainability_threshold = self.capacity * 0.15
        self.high_abundance_threshold = self.capacity * 0.65

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.D
        coop_rate = self._calculate_cooperation_rate(history, current_round)
        if stock < self.min_sustainability_threshold:
            return Action.C
        if stock > self.high_abundance_threshold and current_round < self.n_rounds - 2:
            return Action.D
        if stock >= self.capacity * 0.99 and coop_rate > 0.7 and (current_round < self.n_rounds - 3):
            if history.my_actions[current_round - 1]:
                return Action.D
            else:
                return Action.C
        if current_round > self.n_rounds - 3:
            return Action.D
        return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the observed cooperation rate among opponents in previous rounds.
        
        Args:
            history: PlayerHistory object containing opponent actions
            current_round: Current round number (0-indexed)
            
        Returns:
            Cooperation rate as a float in [0, 1]
        """
        if current_round == 0:
            return 0.0
        total_coop_actions = 0
        for round_idx in range(current_round):
            total_coop_actions += np.sum(history.opponent_actions[round_idx, :])
        total_possible = current_round * self.n_players
        if total_possible == 0:
            return 0.0
        return total_coop_actions / total_possible

class Strategy_EXPLOITATIVE_442(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Decay Detection
    
    Extracts maximum value by exploiting cooperative tendencies while avoiding 
    mutual destruction. Uses conditional defection based on pool health, observed 
    behavior patterns, and remaining rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining == 1:
            return Action.D
        if current_stock < self.capacity * 0.15:
            return Action.D
        if rounds_remaining <= 3:
            return Action.D
        observed_defection_rate = self._calculate_defection_rate(history, current_round)
        if observed_defection_rate > 0.5:
            return Action.D
        stock_decline_rate = self._calculate_stock_decline_rate(history, current_round, current_stock)
        if stock_decline_rate > self.capacity * 0.1:
            return Action.D
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the proportion of opponent defections observed so far.
        Returns 0.0 if no history yet (shouldn't happen after round 0).
        """
        if current_round == 0:
            return 0.0
        total_actions = history.opponent_actions[:current_round, :].size
        if total_actions == 0:
            return 0.0
        defection_count = total_actions - np.sum(history.opponent_actions[:current_round, :])
        defection_rate = float(defection_count) / float(total_actions)
        return defection_rate

    def _calculate_stock_decline_rate(self, history: PlayerHistory, current_round: int, current_stock: float) -> float:
        """
        Calculate the average stock decline rate across observed rounds.
        Returns decline per round as a fraction of capacity.
        """
        if current_round <= 1:
            return 0.0
        max_stock = self.capacity
        simulated_stock = self.capacity
        total_decline = 0.0
        rounds_with_data = 0
        for round_idx in range(current_round):
            cooperators = np.sum(history.opponent_actions[round_idx, :])
            my_action = history.my_actions[round_idx]
            if my_action:
                my_consumption = simulated_stock / (2 * self.n_players)
            else:
                my_consumption = simulated_stock / self.n_players
            opponent_consumption = cooperators * (simulated_stock / (2 * self.n_players))
            opponent_consumption += (self.n_players - 1 - cooperators) * (simulated_stock / self.n_players)
            total_consumption = my_consumption + opponent_consumption
            stock_after_consumption = max(0.0, simulated_stock - total_consumption)
            if self.capacity > 0 and stock_after_consumption >= 0:
                growth = 2.0 * stock_after_consumption * (1.0 - stock_after_consumption / self.capacity)
            else:
                growth = 0.0
            simulated_stock = min(stock_after_consumption + growth, self.capacity)
            decline_this_round = max(0.0, max_stock - simulated_stock)
            total_decline += decline_this_round
            rounds_with_data += 1
            max_stock = simulated_stock
        if rounds_with_data == 0:
            return 0.0
        average_decline_rate = total_decline / float(rounds_with_data)
        return average_decline_rate

class Strategy_EXPLOITATIVE_443(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy
    
    Prioritizes personal payoff maximization through strategic defection,
    with adaptive responses to opponent behavior and stock levels.
    Exploits cooperators while remaining robust to defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_history = []
        self.cooperation_threshold = (self.n_players - 1) / self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.D
        self.stock_history.append(state.current_stock)
        current_stock = state.current_stock
        current_round = state.round_number
        is_final_round = current_round == self.n_rounds - 1
        if is_final_round:
            return Action.D
        if current_stock < self.capacity / 10:
            return Action.D
        prev_opponent_actions = history.opponent_actions[-1, :]
        cooperators_prev = int(np.sum(prev_opponent_actions))
        defectors_prev = self.n_players - cooperators_prev
        coop_fraction = cooperators_prev / self.n_players
        stock_declining = False
        if len(self.stock_history) >= 3:
            stock_declining = self.stock_history[-1] < self.stock_history[-2] and self.stock_history[-2] < self.stock_history[-3]
        if current_stock < self.capacity / 2:
            return Action.D
        if coop_fraction >= self.cooperation_threshold:
            return Action.D
        if current_stock >= 0.75 * self.capacity and defectors_prev > self.n_players / 2:
            return Action.D
        if stock_declining:
            return Action.D
        coop_payoff = current_stock / (2 * self.n_players)
        defect_payoff = current_stock / self.n_players
        if coop_fraction > 0.5:
            expected_future_multiplier = 1.1
        else:
            expected_future_multiplier = 0.7
        expected_future_stock = current_stock * expected_future_multiplier
        future_coop_value = expected_future_stock / (2 * self.n_players) * (self.n_rounds - current_round - 1)
        future_defect_value = expected_future_stock / self.n_players * (self.n_rounds - current_round - 1)
        total_coop_value = coop_payoff + future_coop_value
        total_defect_value = defect_payoff + future_defect_value
        if total_coop_value > total_defect_value:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_444(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with State Monitoring
    
    Maximizes personal consumption while monitoring stock health. Defects aggressively
    above a threshold derived from logistic growth dynamics, uses probabilistic defection
    in the collapse zone, and exploits ruthlessly in final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        sqrt_term = math.sqrt(max(0, 1 - 1 / self.n))
        self.threshold = self.capacity * (1 - sqrt_term)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if current_stock <= 0:
            return Action.C
        if round_num == self.r - 1:
            return Action.D
        if round_num == self.r - 2:
            extraction_d = current_stock / self.n
            if current_stock > 2 * extraction_d:
                return Action.D
        if current_stock > self.threshold:
            return Action.D
        if self.threshold > 0:
            defect_probability = (self.threshold - current_stock) / self.threshold
        else:
            defect_probability = 0
        if history is not None and round_num > 0:
            expected_stock = self._calculate_expected_stock_all_cooperate(round_num)
            if expected_stock > 0 and current_stock < expected_stock * 0.7:
                defect_probability = min(0.95, defect_probability + 0.6)
        if random.random() < defect_probability:
            return Action.D
        return Action.C

    def _calculate_expected_stock_all_cooperate(self, round_num: int) -> float:
        """
        Calculate expected stock level if all players had cooperated up to round_num.
        Uses logistic growth model iteratively.
        """
        stock = self.capacity
        for _ in range(round_num):
            total_consumption = stock / 2
            stock_after_consumption = stock - total_consumption
            if stock_after_consumption < 0:
                stock_after_consumption = 0
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            stock = min(stock_after_consumption + growth, self.capacity)
        return stock

class Strategy_EXPLOITATIVE_445(BaseStrategy):
    """
    Exploitative strategy for Common Pool Resource Game.
    
    Aggressively defects while stock is above a critical threshold (15% of capacity),
    then switches to cooperation when stock is depleted or in the final rounds.
    Maximizes immediate payoff extraction while exploiting cooperators' restraint.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = game_description.capacity * 0.15

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        if current_round == n_rounds - 1:
            if current_stock > self.critical_threshold:
                return Action.D
            else:
                return Action.C
        if current_stock <= self.critical_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_446(BaseStrategy):
    """
    Adaptive Predatory Extraction (APE) Strategy
    
    Exploitative strategy that maximizes extraction from the common pool while
    maintaining just enough stock for future exploitation. Default action is defect,
    with strategic cooperation only when necessary for resource recovery or initial
    information gathering.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round - 1
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        scarcity_threshold = self.capacity * 0.15
        if current_stock < scarcity_threshold and rounds_remaining > 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_447(BaseStrategy):
    """
    Adaptive Predation: Exploitative Common Pool Resource Strategy
    
    Core approach: Default to defection when pool is healthy, adaptively switch to
    cooperation only when pool depletion forces it or when free-riding on others'
    cooperation becomes advantageous. Always defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = game_description.capacity * (1.0 / game_description.n_players + 0.1)
        self.observation_window = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock > self.critical_threshold:
            return Action.D
        recent_defection_rate, recent_cooperation_rate = self._calculate_recent_behavior_rates(history, state.round_number)
        if recent_defection_rate > 0.5:
            return Action.D
        if recent_cooperation_rate > 0.7:
            return Action.C
        return Action.D

    def _calculate_recent_behavior_rates(self, history: PlayerHistory, current_round: int) -> tuple[float, float]:
        """
        Calculate recent defection and cooperation rates of opponents.
        Uses a moving window of min(3, current_round) rounds.
        
        Returns: (defection_rate, cooperation_rate)
        """
        observation_rounds = min(self.observation_window, current_round)
        if observation_rounds == 0:
            return (0.0, 0.0)
        start_idx = current_round - observation_rounds
        recent_actions = history.opponent_actions[start_idx:current_round, :]
        total_cooperations = np.sum(recent_actions)
        total_actions = observation_rounds * self.game_description.n_players
        cooperation_rate = total_cooperations / total_actions if total_actions > 0 else 0.0
        defection_rate = 1.0 - cooperation_rate
        return (defection_rate, cooperation_rate)

class Strategy_EXPLOITATIVE_448(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Damage Control
    
    Exploits the asymmetry between cooperation (stock/(2n)) and defection (stock/n) payoffs
    while managing stock depletion. Defects aggressively when stock is healthy, cooperates
    strategically to prevent collapse before the final rounds, and defects unconditionally
    in the terminal phase.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity * (1.0 - 1.0 / self.n)
        self.end_game_threshold = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        rounds_remaining = self.total_rounds - round_num
        if rounds_remaining <= self.end_game_threshold:
            return Action.D
        if round_num == 0:
            return Action.D
        if stock < 2 * self.n and stock > 0:
            if rounds_remaining == 1:
                return Action.D
            else:
                return Action.C
        if stock > self.critical_threshold:
            return Action.D
        else:
            prev_round_defections = np.sum(~history.opponent_actions[-1, :])
            observed_defection_rate = prev_round_defections / self.n
            if observed_defection_rate > (self.n - 1) / self.n:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_449(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Threshold-Based Switching
    
    Maximizes personal gain by defecting aggressively when stock is abundant,
    adapting based on opponent behavior in mid-game, and switching to minimal
    cooperation only when stock reaches critical levels to prevent collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_rounds
        self.n_rounds = game_description.n_rounds
        self.threshold_aggressive = 0.75 * self.capacity
        self.threshold_moderate = 0.4 * self.capacity
        self.threshold_critical = 0.15 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        rounds_remaining = total_rounds - round_number
        if round_number == total_rounds - 1:
            return Action.D
        if round_number == total_rounds - 2:
            if current_stock > self.threshold_critical:
                return Action.D
            else:
                return Action.C
        if current_stock > self.threshold_aggressive:
            return Action.D
        if current_stock > self.threshold_critical:
            opponent_defection_rate = self._calculate_opponent_defection_rate(history)
            if opponent_defection_rate >= 0.5:
                return Action.D
            else:
                return Action.D
        if current_stock <= self.threshold_critical:
            return Action.C
        return Action.D

    def _calculate_opponent_defection_rate(self, history: None | PlayerHistory) -> float:
        """
        Calculate the observed defection rate among opponents.
        
        Returns a value between 0.0 and 1.0 representing the proportion of
        opponent actions that were defections (False/0 in the history).
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.5
        total_opponent_actions = history.opponent_actions.size
        if total_opponent_actions == 0:
            return 0.5
        defection_count = np.sum(~history.opponent_actions)
        defection_rate = defection_count / total_opponent_actions
        return float(defection_rate)

class Strategy_EXPLOITATIVE_450(BaseStrategy):
    """
    Adaptive Predation: Exploitative Common Pool Resource Strategy
    
    Aggressively exploits the 2x payoff asymmetry between defection (S/n) and cooperation (S/(2n)).
    Uses stock trajectory and opponent behavior history to time exploitation optimally.
    Defaults to defection except in narrow tactical windows.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.threshold_high = self.capacity * 0.75
        self.threshold_low = self.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        rounds_remaining = self.n_rounds - round_num
        if round_num == 0:
            return Action.D
        if rounds_remaining <= 2:
            return Action.D
        if round_num == 1 or stock > self.threshold_high:
            return Action.D
        if stock < self.threshold_low and rounds_remaining <= 3:
            return Action.D
        if history is not None and round_num > 0:
            lookback = min(3, round_num)
            recent_opponent_actions = history.opponent_actions[-lookback:, :]
            avg_cooperation = np.mean(recent_opponent_actions)
            avg_defection = 1.0 - avg_cooperation
            if avg_cooperation > 0.6:
                return Action.D
            if round_num > 1:
                previous_stock = history.my_payoffs[round_num - 1] if round_num > 0 else stock
                stock_decline_rate = 0.0
                if round_num >= 2:
                    recent_payoffs = history.my_payoffs[max(0, round_num - 2):round_num]
                    if len(recent_payoffs) >= 2:
                        payoff_decline = recent_payoffs[-2] - recent_payoffs[-1]
                        if payoff_decline > 0:
                            stock_decline_rate = min(0.5, payoff_decline / (recent_payoffs[-2] + 1e-06))
                if stock_decline_rate > 0.2 and avg_defection > 0.7:
                    return Action.D
            if self.capacity * 0.3 < stock < self.capacity * 0.7 and round_num > 2 and (rounds_remaining > 3) and (avg_defection > 0.5):
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_451(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy.
    
    Maximizes defection during abundance, switches to conditional cooperation only
    when stock depletion becomes critical, and defects unconditionally in final round.
    Adapts thresholds based on observed opponent defection rates and stock trajectory.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.safe_threshold = self.capacity * 0.65
        self.critical_threshold = self.capacity * 0.2
        self.threshold_reduction_active = False
        self.threshold_reduction_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        self._update_adaptive_parameters(history, current_stock)
        safe_threshold = self.safe_threshold
        critical_threshold = self.critical_threshold
        if self.threshold_reduction_active:
            safe_threshold -= self.capacity * 0.1
            self.threshold_reduction_rounds_remaining -= 1
            if self.threshold_reduction_rounds_remaining <= 0:
                self.threshold_reduction_active = False
        if current_stock > 0.95 * self.capacity:
            return Action.D
        if current_stock < 0.1 * self.capacity and current_round < self.n_rounds - 2:
            return Action.C
        if current_stock > safe_threshold:
            return Action.D
        elif current_stock > critical_threshold:
            return Action.C
        else:
            return Action.D

    def _update_adaptive_parameters(self, history: PlayerHistory, current_stock: float) -> None:
        """
        Update thresholds based on opponent behavior and stock trajectory.
        """
        current_round = history.my_actions.shape[0] - 1
        if current_round < 0:
            return
        opponent_actions_last_round = history.opponent_actions[current_round, :]
        defections_last_round = np.sum(~opponent_actions_last_round)
        observed_defection_rate = defections_last_round / self.n_players
        if observed_defection_rate > 0.75:
            self.threshold_reduction_active = True
            self.threshold_reduction_rounds_remaining = 2
        if current_round >= 1:
            prev_stock = None
            if current_round >= 1:
                my_action_last_round = history.my_actions[current_round]
                my_payoff_last_round = history.my_payoffs[current_round]
                if my_payoff_last_round > 0:
                    if my_action_last_round:
                        prev_stock = my_payoff_last_round * 2 * self.n_players
                    else:
                        prev_stock = my_payoff_last_round * self.n_players
                    stock_decline_rate = (prev_stock - current_stock) / prev_stock if prev_stock > 0 else 0
                    if stock_decline_rate > 0.1 and current_stock > self.critical_threshold:
                        self.threshold_reduction_active = True
                        self.threshold_reduction_rounds_remaining = 2

class Strategy_EXPLOITATIVE_452(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Maximizes personal payoff by exploiting asymmetry between cooperative and defective
    consumption while monitoring stock health. Cooperation is a tactical tool to maintain
    stock for future exploitation, not an end goal.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        capacity = self.capacity
        n = self.n_players
        r = self.n_rounds
        if round_num == 0:
            return Action.D
        stock_sustainability_ratio = stock / capacity if capacity > 0 else 0.0
        rounds_remaining = r - round_num
        opponent_defection_rate = self._calculate_opponent_defection_rate(history, round_num)
        if stock_sustainability_ratio > 0.6:
            return Action.D
        elif stock_sustainability_ratio <= 0.3:
            if rounds_remaining <= 2:
                return Action.D
            elif opponent_defection_rate > 0.6:
                return Action.D
            else:
                return Action.C
        elif opponent_defection_rate > 0.7:
            return Action.D
        elif rounds_remaining > r / 2:
            return Action.C
        else:
            return Action.D

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the defection rate among all opponents from available history.
        
        True/1 = Cooperate (Action.C)
        False/0 = Defect (Action.D)
        
        Defection rate = number of defections / total actions observed
        """
        if round_num == 0 or history is None:
            return 0.5
        opponent_actions = history.opponent_actions[:round_num, :]
        total_actions = opponent_actions.size
        if total_actions == 0:
            return 0.5
        defection_count = np.sum(~opponent_actions)
        defection_rate = float(defection_count) / float(total_actions)
        return defection_rate

class Strategy_EXPLOITATIVE_453(BaseStrategy):
    """
    Adaptive Predation Strategy for Common Pool Resource Game
    
    This exploitative strategy maximizes individual payoff by:
    1. Always defecting in the last round (no future punishment)
    2. Defecting when stock is critically low (< 25% capacity)
    3. Exploiting high-cooperation environments (cooperation_rate > 0.65)
    4. Using tactical pauses only when mutual defection threatens pool collapse
    5. Maintaining aggressive defection as default behavior
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_threshold = self.capacity * 0.25
        self.pool_recovery_threshold = self.capacity * 0.5
        self.coop_exploitation_threshold = 0.65
        self.mutual_defection_threshold = 0.85
        self.recent_window = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if current_stock <= self.stock_threshold:
            return Action.D
        opponent_cooperation_count = 0
        total_opponent_actions = 0
        for round_idx in range(round_num):
            for opponent_idx in range(self.n_players - 1):
                opponent_cooperation_count += int(history.opponent_actions[round_idx, opponent_idx])
                total_opponent_actions += 1
        if total_opponent_actions > 0:
            cooperation_rate = opponent_cooperation_count / total_opponent_actions
        else:
            cooperation_rate = 0.5
        if cooperation_rate > self.coop_exploitation_threshold:
            return Action.D
        recent_rounds_to_check = min(self.recent_window, round_num)
        if recent_rounds_to_check > 0:
            recent_defection_count = 0
            recent_action_count = 0
            for round_idx in range(round_num - recent_rounds_to_check, round_num):
                for opponent_idx in range(self.n_players - 1):
                    recent_action_count += 1
                    if not history.opponent_actions[round_idx, opponent_idx]:
                        recent_defection_count += 1
            if recent_action_count > 0:
                recent_defection_rate = recent_defection_count / recent_action_count
            else:
                recent_defection_rate = 0.0
            if recent_defection_rate > self.mutual_defection_threshold and current_stock < self.pool_recovery_threshold:
                if round_num > 0 and (not history.my_actions[round_num - 1]):
                    return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_454(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Conditional Cooperation
    
    Maximizes immediate extraction through defection while managing stock collapse.
    Uses a dynamic threshold based on remaining rounds and stock health to switch
    between defection (when stock is high) and cooperation (when stock is critically low).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if stock < self.capacity * 0.25:
            return Action.C
        rounds_remaining = self.n_rounds - current_round
        threshold = self.capacity * (0.4 + 0.1 * (rounds_remaining / self.n_rounds))
        if stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_455(BaseStrategy):
    """
    Adaptive Predation with Selective Cooperation: An exploitative strategy that
    maximizes absolute payoff by defecting opportunistically based on stock levels,
    while adapting minimally to opponent behavior in mid-range stock conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        critical_threshold = self.capacity * 0.2
        if current_stock <= critical_threshold:
            return Action.C
        high_threshold = self.capacity * 0.6
        if current_stock > high_threshold:
            return Action.D
        recent_defections = 0
        recent_cooperations = 0
        rounds_to_check = min(2, current_round)
        for i in range(current_round - rounds_to_check, current_round):
            if i >= 0:
                opponent_cooperations = int(np.sum(history.opponent_actions[i, :]))
                opponent_defections = self.n_players - 1 - opponent_cooperations
                recent_defections += opponent_defections
                recent_cooperations += opponent_cooperations
        if recent_defections > recent_cooperations:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_456(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Stock Monitoring
    
    Exploits the asymmetry between cooperation (S/2n payoff) and defection (S/n payoff)
    by aggressively defecting when stock is abundant, then switching to cooperation
    when stock depletes to avoid collapse. Terminal phase cooperation positions for
    final-round extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_threshold = self.capacity * 0.6
        self.stock_threshold = max(self.stock_threshold, 2 * self.n_players)
        self.terminal_phase_start = self.n_rounds - math.floor(self.n_rounds / 4)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        if self.n_rounds <= 3:
            if round_num == self.n_rounds - 1:
                return Action.D if stock > self.stock_threshold else Action.D
            return Action.D
        if stock < self.capacity * 0.05:
            return Action.C
        if stock <= 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D if stock > self.stock_threshold else Action.C
        if round_num >= self.terminal_phase_start:
            return Action.C
        if stock > self.stock_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_457(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Dynamic Threshold Management
    
    Treats the common pool as a resource to be extracted before others do.
    Cooperates only when necessary to maintain stock sustainability for future
    exploitation opportunities. Uses stock-based thresholds and opponent behavior
    tracking to adaptively decide between cooperation and defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self._total_opponent_defections = 0
        self._total_opponent_actions = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if history is not None:
            defections = np.sum(~history.opponent_actions)
            total_actions = history.opponent_actions.size
            self._total_opponent_defections = int(defections)
            self._total_opponent_actions = int(total_actions)
        if self._total_opponent_actions > 0:
            opponent_defection_rate = self._total_opponent_defections / self._total_opponent_actions
        else:
            opponent_defection_rate = 0.5
        if stock < self.capacity * 0.15:
            return Action.D
        if round_num == self.n_rounds - 2:
            threshold_high = self.capacity * 0.65
        elif opponent_defection_rate > 0.7:
            threshold_high = self.capacity * 0.8
        else:
            threshold_high = self.capacity * 0.75
        threshold_low = self.capacity * 0.3
        if self.capacity * 0.25 <= stock <= self.capacity * 0.45:
            if stock > threshold_high:
                return Action.D
            else:
                return Action.C
        if stock > threshold_high:
            return Action.D
        elif stock > threshold_low:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_458(BaseStrategy):
    """
    Predatory Harvesting with Opportunistic Adaptation.
    
    An exploitative strategy that always defects to maximize immediate extraction
    from the common pool resource. Defection yields 2x the payoff of cooperation
    (stock/n vs stock/2n) and dominates regardless of opponent behavior or stock level.
    
    Core mechanics:
    - Always defect (dominant strategy)
    - Prioritize early-round extraction before stock collapse
    - Guarantee maximum terminal-round payoff
    - Never cooperate, eliminating reciprocal cooperation pathways
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_aggressive = 1.5 * game_description.capacity
        self.threshold_critical = 0.5 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decision rule: Always defect across all game states and rounds.
        
        Defection is a dominant strategy because it always yields 2x the payoff
        of cooperation at any stock level S > 0: S/n > S/(2n).
        
        Edge cases all resolve to defection:
        - First round: defect unconditionally (maximize initial extraction)
        - Terminal round: defect (no future consequences)
        - Low stock: defect (race-to-bottom before collapse)
        - High stock: defect (healthy stock tolerates aggressive extraction)
        """
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        rounds_remaining = self.game_description.n_rounds - state.round_number
        if current_stock > self.threshold_aggressive:
            return Action.D
        elif current_stock > self.threshold_critical:
            return Action.D
        elif current_stock <= self.threshold_critical and rounds_remaining <= 2:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_459(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Stock Monitoring
    
    Defects when stock is healthy (>35% capacity) to maximize payoff,
    cooperates when stock is low to prevent collapse. Becomes more aggressive
    in final rounds and when opponents are predominantly defecting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.base_threshold = 0.35
        self.adaptive_threshold = 0.35

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        if round_num == 0:
            if stock >= 0.9 * capacity:
                return Action.D
            return Action.C
        if round_num == n_rounds - 1:
            return Action.D
        if round_num >= n_rounds - 2:
            return Action.D
        if stock < 0.1:
            return Action.C
        if stock >= 0.99 * capacity:
            return Action.D
        opponent_defection_rate = self._calculate_opponent_defection_rate(history)
        if opponent_defection_rate > 0.6:
            self.adaptive_threshold = 0.25
        else:
            self.adaptive_threshold = 0.35
        if round_num <= 2 and stock >= 0.9 * capacity:
            return Action.D
        if stock > self.adaptive_threshold * capacity:
            return Action.D
        else:
            return Action.C

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the rate of defection among opponents based on history.
        Returns a value between 0 and 1.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        total_opponent_actions = history.opponent_actions.size
        if total_opponent_actions == 0:
            return 0.0
        defection_count = np.sum(history.opponent_actions == False)
        defection_rate = float(defection_count) / float(total_opponent_actions)
        return defection_rate

class Strategy_EXPLOITATIVE_460(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Controlled Degradation
    
    Defects aggressively while stock is high, exploiting cooperators and racing defectors.
    Only cooperates when forced by resource scarcity or in specific tactical situations.
    Abandons cooperation entirely in final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        current_round = state.round_number
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= 2:
            return Action.D
        if current_round == 0:
            return Action.D
        threshold = self.capacity * (1.0 - 1.0 / math.sqrt(rounds_remaining + 1.0))
        opponent_cooperations = 0.0
        opponent_total_actions = 0
        if history is not None and current_round > 0:
            opponent_cooperations = float(np.sum(history.opponent_actions[:current_round, :]))
            opponent_total_actions = (self.n_players - 1) * current_round
        coop_rate = 0.5
        if opponent_total_actions > 0:
            coop_rate = opponent_cooperations / float(opponent_total_actions)
        if stock > threshold:
            if coop_rate > 0.6:
                return Action.D
            else:
                return Action.D
        elif coop_rate < 0.3 and stock < threshold * 0.5:
            return Action.C
        elif coop_rate > 0.5:
            return Action.D
        else:
            defect_probability = 0.65 + 0.35 * coop_rate
            if random.random() < defect_probability:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_461(BaseStrategy):
    """
    Adaptive Predation with Resource Monitoring Strategy.
    
    Exploits the asymmetry between cooperators and defectors through:
    1. Stock-level based conditional defection (primary rule)
    2. Round-position aware end-game aggression
    3. Collapse avoidance through critical thresholds
    4. Recovery-triggered resumption of exploitation
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.rounds_since_last_defect = 0
        self.last_defect_round = -1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if round_num == self.n_rounds - 2:
            stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0
            if stock_ratio > 0.4:
                return Action.D
            else:
                return Action.C
        if round_num <= 2:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0
        if stock_ratio > 0.6:
            self.last_defect_round = round_num
            self.rounds_since_last_defect = 0
            return Action.D
        elif stock_ratio > 0.3:
            self.last_defect_round = round_num
            self.rounds_since_last_defect = 0
            return Action.D
        elif stock_ratio > 0.15:
            self.rounds_since_last_defect += 1
            return Action.C
        else:
            self.rounds_since_last_defect += 1
            return Action.C

class Strategy_EXPLOITATIVE_462(BaseStrategy):
    """
    Adaptive Predation Strategy: Exploitative approach that maximizes personal payoff
    by defecting when resources are abundant, transitioning to cooperation only when
    stock becomes critically scarce or in final rounds. Monitors opponent behavior
    to adapt exploitation intensity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        capacity = self.capacity
        if capacity <= 0:
            return Action.C
        stock_ratio = stock / capacity
        if stock_ratio <= 0.1:
            return Action.C
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if history is not None:
            opponent_defection_rate = self._calculate_opponent_defection_rate(history)
            if opponent_defection_rate >= 0.7:
                return Action.D
            if opponent_defection_rate <= 0.2 and stock_ratio >= 0.3:
                return Action.D
        if stock_ratio >= 0.6:
            return Action.D
        if stock_ratio < 0.6:
            if round_num <= self.n_rounds * 0.8:
                return Action.D
            else:
                return Action.C
        return Action.C

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the average defection rate of opponents across all completed rounds.
        Returns a value between 0.0 (all cooperate) and 1.0 (all defect).
        """
        if history.opponent_actions.size == 0:
            return 0.5
        total_opponent_actions = history.opponent_actions.size
        defection_count = np.sum(~history.opponent_actions)
        if total_opponent_actions == 0:
            return 0.5
        defection_rate = float(defection_count) / float(total_opponent_actions)
        return defection_rate

class Strategy_EXPLOITATIVE_463(BaseStrategy):
    """
    Adaptive Predation: An exploitative common pool resource strategy that maximizes
    individual payoff by defecting whenever stock is sufficiently healthy, while
    strategically cooperating only under scarcity constraints.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        t = state.round_number
        r = self.n_rounds
        capacity = self.capacity
        n = self.n_players
        if stock == 0:
            return Action.C
        if t == 0:
            return Action.D
        observed_defection_rate = self._calculate_opponent_defection_rate(history, t)
        base_theta = capacity * (0.35 + 0.15 * (r - t) / r)
        if observed_defection_rate > 0.6:
            theta = base_theta - 0.1 * capacity
        elif observed_defection_rate < 0.3:
            theta = base_theta + 0.05 * capacity
        else:
            theta = base_theta
        if n == 2:
            theta *= 0.9
        elif n >= 6:
            theta *= 1.1
        if t == r - 1:
            return Action.D
        if stock < 0.2 * capacity and observed_defection_rate > 0.7:
            return Action.C
        if theta - 0.05 * capacity <= stock <= theta + 0.05 * capacity:
            sustainable_level = capacity * 0.5
            if stock > sustainable_level:
                return Action.D
            else:
                return Action.C
        if stock > theta:
            return Action.D
        else:
            return Action.C

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the historical defection rate of opponents up to current round.
        Returns a value between 0 and 1.
        """
        if current_round == 0:
            return 0.5
        opponent_actions = history.opponent_actions[:current_round, :]
        total_observations = opponent_actions.size
        if total_observations == 0:
            return 0.5
        defections = np.sum(~opponent_actions)
        defection_rate = defections / total_observations
        return float(defection_rate)

class Strategy_EXPLOITATIVE_464(BaseStrategy):
    """
    Adaptive Extraction Strategy: Exploitative approach that defects early and late,
    adapts to cooperation rates mid-game, and prioritizes maximum personal extraction
    over pool sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round <= self.n_rounds / 3:
            return Action.D
        if current_round > 2 * self.n_rounds / 3:
            return Action.D
        coop_rate = self._calculate_cooperation_rate(history, current_round)
        critical_threshold = self.capacity / 4
        if current_stock < critical_threshold:
            return Action.C
        return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the observed cooperation rate from all players in previous rounds.
        
        coop_rate = (total cooperators observed) / (n × rounds_played)
        """
        if current_round == 0:
            return 0.0
        rounds_played = current_round
        total_opponent_cooperators = np.sum(history.opponent_actions[:rounds_played, :])
        total_my_cooperators = np.sum(history.my_actions[:rounds_played])
        total_cooperators = total_opponent_cooperators + total_my_cooperators
        total_actions = self.n_players * rounds_played
        if total_actions == 0:
            return 0.0
        coop_rate = total_cooperators / total_actions
        return coop_rate

class Strategy_EXPLOITATIVE_465(BaseStrategy):
    """
    Adaptive Depletion Strategy: Exploitative strategy that defects when stock is abundant,
    cooperates when stock is critically depleted (to allow recovery), and uses probabilistic
    defection during transition phases. First round is unconditional defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        rounds_remaining = self.n_rounds - current_round - 1
        if stock_ratio < 0.3:
            if rounds_remaining <= 2:
                return Action.D
            else:
                return Action.C
        if stock_ratio >= 0.6:
            return Action.D
        defection_probability = stock_ratio - 0.3
        if random.random() < defection_probability:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_466(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Defection
    
    Maximizes personal payoff by:
    1. Extracting value before others deplete the resource
    2. Punishing cooperators who sacrifice consumption
    3. Adapting to detected defection patterns
    4. Timing aggressive extraction to precede expected resource collapse
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        current_round = state.round_number
        rounds_remaining = self.n_rounds - current_round - 1
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == self.n_rounds - 2:
            return Action.D
        critical_threshold = max(self.capacity / 4, 2 * self.n_players)
        if stock < critical_threshold:
            return Action.D
        if current_round >= 1:
            prev_stock = history.opponent_payoffs[current_round - 1, 0]
            if current_round >= 3:
                stocks_recent = [self._get_stock_at_round(current_round - 3, stock, history), self._get_stock_at_round(current_round - 2, stock, history), self._get_stock_at_round(current_round - 1, stock, history)]
                if stocks_recent[2] < stocks_recent[1] < stocks_recent[0]:
                    return Action.D
            prev_round_stock = self._estimate_prev_stock(current_round, history)
            if prev_round_stock > 0 and stock < prev_round_stock * 0.5:
                return Action.D
        prev_actions = history.opponent_actions[current_round - 1, :]
        defection_count = np.sum(prev_actions == False)
        defection_rate = defection_count / self.n_players
        if defection_rate > 0.4:
            return Action.D
        if current_round >= 3:
            defections_last_3 = 0
            for i in range(max(0, current_round - 3), current_round):
                defections_last_3 += np.sum(history.opponent_actions[i, :] == False)
            avg_defection_rate = defections_last_3 / (3 * self.n_players)
            if avg_defection_rate > 0.5:
                return Action.D
        cooperation_rate = 1.0 - defection_rate
        if cooperation_rate > 0.4 and stock > self.capacity / 3 and (rounds_remaining > 2):
            return Action.C
        return Action.C

    def _estimate_prev_stock(self, current_round: int, history: PlayerHistory) -> float:
        """
        Estimate the stock level at the previous round.
        Uses a simple heuristic based on consumption patterns.
        """
        if current_round <= 0:
            return self.capacity
        prev_my_action = history.my_actions[current_round - 1]
        prev_opponent_actions = history.opponent_actions[current_round - 1, :]
        cooperators = np.sum(prev_opponent_actions == True)
        defectors = np.sum(prev_opponent_actions == False)
        if prev_my_action:
            cooperators += 1
        else:
            defectors += 1
        my_payoff_prev = history.my_payoffs[current_round - 1] if current_round > 0 else 0
        if prev_my_action:
            estimated_stock_before = my_payoff_prev * 2 * self.n_players
        else:
            estimated_stock_before = my_payoff_prev * self.n_players
        return estimated_stock_before

    def _get_stock_at_round(self, round_idx: int, current_stock: float, history: PlayerHistory) -> float:
        """
        Estimate stock at a given historical round.
        Uses payoff data to reverse-engineer stock levels.
        """
        if round_idx < 0:
            return self.capacity
        if round_idx >= len(history.my_payoffs):
            return current_stock
        my_payoff = history.my_payoffs[round_idx]
        my_action = history.my_actions[round_idx]
        if my_action:
            estimated_stock = my_payoff * 2 * self.n_players
        elif my_payoff > 0:
            estimated_stock = my_payoff * self.n_players
        else:
            estimated_stock = 0.0
        return max(0.0, estimated_stock)

class Strategy_EXPLOITATIVE_467(BaseStrategy):
    """
    Adaptive Depletion Exploitation (ADE) Strategy for Common Pool Resource Game.
    
    Exploits the asymmetry between cooperation (S/2n payoff) and defection (S/n payoff)
    by dynamically adjusting behavior based on stock levels and observed opponent defection rates.
    Includes recovery mechanisms to prevent terminal collapse while maintaining aggressive extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_defections_observed = 0
        self.total_opponent_actions_observed = 0
        self.recovery_counter = 0
        self.safe_threshold = 0.5 * self.capacity
        self.last_observed_defection_rate = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        self._update_observations(history, current_round)
        if self.recovery_counter > 0:
            self.recovery_counter -= 1
            return Action.C
        remaining_rounds = self.n_rounds - current_round
        projected_collapse_threshold = 0.15 * self.capacity
        if current_stock < projected_collapse_threshold:
            self.recovery_counter = 2
            return Action.C
        threshold = self._calculate_adaptive_threshold(current_round, remaining_rounds)
        if current_stock > threshold:
            return Action.D
        else:
            return Action.C

    def _update_observations(self, history: PlayerHistory, current_round: int) -> None:
        """Track opponent behavior to refine decision-making."""
        if current_round == 0 or history is None:
            return
        last_round_idx = current_round - 1
        opponent_actions_last_round = history.opponent_actions[last_round_idx, :]
        defections_last_round = self.n_players - 1 - np.sum(opponent_actions_last_round)
        self.opponent_defections_observed += defections_last_round
        self.total_opponent_actions_observed += self.n_players - 1
        if self.total_opponent_actions_observed > 0:
            self.last_observed_defection_rate = self.opponent_defections_observed / self.total_opponent_actions_observed

    def _calculate_adaptive_threshold(self, current_round: int, remaining_rounds: int) -> float:
        """Calculate adaptive safe threshold with observational adjustments."""
        base_threshold = self.capacity * (0.5 + 0.1 * (remaining_rounds / max(self.n_rounds, 1)))
        if self.last_observed_defection_rate > 0.6:
            adjusted_threshold = base_threshold * 0.9
        elif self.last_observed_defection_rate < 0.3:
            adjusted_threshold = base_threshold
        else:
            adjusted_threshold = base_threshold
        return adjusted_threshold

class Strategy_EXPLOITATIVE_468(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Treats the common pool as a resource to be extracted rather than sustained.
    Exploits the asymmetry between defection (stock/n) and cooperation (stock/2n) payoffs.
    
    Core behavior:
    - Round 1: Always defect (information gathering)
    - Rounds 2 to r/3: Cooperate only if stock > 0.75*capacity AND all (n-1) opponents cooperated last round
    - Rounds r/3+1 to 2r/3: Similar logic with stock degradation checks
    - Rounds 2r/3+1 to r: Always defect (endgame extraction)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.D
        phase_threshold_early = max(1, self.n_rounds // 3)
        phase_threshold_mid = max(1, 2 * self.n_rounds // 3)
        if round_number > phase_threshold_mid:
            return Action.D
        last_round_idx = round_number - 1
        cooperators_last_round = int(np.sum(history.opponent_actions[last_round_idx, :]))
        all_opponents_cooperated = cooperators_last_round == self.n_players - 1
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if round_number <= phase_threshold_early:
            if stock_ratio > 0.75 and all_opponents_cooperated:
                return Action.C
            return Action.D
        if stock_ratio <= 0.5:
            return Action.D
        if stock_ratio > 0.75 and all_opponents_cooperated:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_469(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy that prioritizes immediate personal gain
    through adaptive defection, exploiting cooperators and maximizing extraction during
    resource collapse phases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_critical = 2 * self.n_players * 1.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if stock < self.threshold_critical:
            return Action.D
        observed_coop_rate = self._calculate_cooperation_rate(history, current_round)
        if observed_coop_rate > 0.6:
            return Action.D
        if observed_coop_rate <= 0.3:
            return Action.D
        if random.random() < observed_coop_rate:
            return Action.C
        else:
            return Action.D

    def _calculate_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the observed cooperation rate of opponents across all previous rounds.
        Returns the proportion of cooperative actions (True/1) across all opponents and rounds.
        """
        if current_round == 0:
            return 0.0
        total_cooperations = np.sum(history.opponent_actions[:current_round, :])
        total_actions = current_round * (self.n_players - 1)
        if total_actions == 0:
            return 0.0
        cooperation_rate = total_cooperations / total_actions
        return cooperation_rate

class Strategy_EXPLOITATIVE_470(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion Farming
    
    Exploits the asymmetry between cooperators and defectors while maximizing
    total extraction before resource collapse. Uses stock-state conditional
    defection with a dynamic threshold that adapts to the remaining time horizon.
    
    Core logic:
    - Round 1: Always defect
    - Rounds 2 to r-1: Defect if stock > threshold, else cooperate
    - Final round: Always defect
    
    Threshold = capacity × (0.5 + 0.2 × round / total_rounds)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.all_defected_before = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        if history is not None and current_round > 0:
            opponent_actions = history.opponent_actions[:current_round, :]
            any_cooperated = np.any(opponent_actions)
            if not any_cooperated:
                self.all_defected_before = True
            if self.all_defected_before:
                return Action.D
        epsilon = self.capacity * 0.001
        if current_stock < epsilon:
            return Action.C
        progress_ratio = current_round / self.n_rounds
        threshold = self.capacity * (0.5 + 0.2 * progress_ratio)
        if current_stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_471(BaseStrategy):
    """
    Adaptive Predation: An exploitative strategy that maximizes individual payoff
    through aggressive defection, with adaptive thresholds based on stock health
    and opponent behavior patterns.
    
    Core principle: Defection yields S/n while cooperation yields S/(2n), making
    defection strictly dominant per round. This strategy exploits cooperative
    opponents while adapting to defection-heavy environments.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        total_rounds = self.n_rounds
        if round_number == total_rounds - 1:
            return Action.D
        if round_number == 0:
            return Action.D
        if current_stock > 0.6 * self.capacity:
            return Action.D
        if current_stock > 0.3 * self.capacity:
            lookback_window = min(2, round_number)
            if lookback_window > 0 and history is not None:
                recent_opponent_actions = history.opponent_actions[round_number - lookback_window:round_number, :]
                defection_count = np.sum(~recent_opponent_actions)
                total_actions = recent_opponent_actions.size
                if total_actions > 0:
                    defection_rate = defection_count / total_actions
                    if defection_rate > 0.5:
                        return Action.D
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_472(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy
    
    Maximizes personal payoff through conditional defection with adaptive thresholds.
    Core mechanics:
    - Early rounds: Cooperate if stock is healthy (gather intelligence)
    - Middle rounds: Transition to exploitation based on opponent behavior
    - Late rounds: Always defect (no future punishment possible)
    - Stock-based switching: Defect when abundant, cooperate only near collapse
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock = state.current_stock
        if round_t == 0:
            return Action.D
        if round_t == self.n_rounds - 1:
            return Action.D
        if stock < self.capacity / 4:
            return Action.C
        if round_t <= self.n_rounds / 3:
            if stock >= 0.8 * self.capacity:
                return Action.C
            else:
                return Action.D
        if round_t > 2 * self.n_rounds / 3:
            return Action.D
        total_opponent_actions = history.opponent_actions[:round_t, :]
        total_defections = np.sum(~total_opponent_actions)
        total_action_count = round_t * self.n_players
        if total_action_count > 0:
            defection_rate = total_defections / total_action_count
        else:
            defection_rate = 0.0
        if round_t > 0:
            recent_defections = np.sum(~history.opponent_actions[round_t - 1, :])
            recent_defection_rate = recent_defections / self.n_players if self.n_players > 0 else 0.0
        else:
            recent_defection_rate = 0.0
        if recent_defection_rate >= 0.5 or defection_rate >= 0.5:
            return Action.D
        if stock > self.capacity / 2:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_473(BaseStrategy):
    """
    Adaptive Depletion with Conditional Defection
    
    Exploits common pool resources by defaulting to defection (2x payoff)
    while selectively cooperating only when opponent behavior suggests
    sustained stock benefits exceed cooperation costs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        rounds_remaining = self.n_rounds - round_num
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if rounds_remaining <= 2:
            return Action.D
        if current_stock < self.capacity * 0.1:
            return Action.D
        if current_stock <= self.capacity * 0.15:
            return Action.D
        if current_stock > self.capacity * 0.85 and rounds_remaining > 2:
            return Action.D
        if current_stock >= self.capacity * 0.4 and current_stock <= self.capacity * 0.7:
            defection_rate = self._calculate_defection_rate(history)
            my_avg_payoff = self._calculate_my_avg_payoff(history)
            opponent_avg_payoff = self._calculate_opponent_avg_payoff(history)
            if defection_rate > 0.5 or my_avg_payoff < opponent_avg_payoff:
                return Action.D
            else:
                return Action.C
        return Action.D

    def _calculate_defection_rate(self, history: PlayerHistory) -> float:
        """Calculate proportion of opponent defections (False = defect)"""
        if history.opponent_actions.size == 0:
            return 0.0
        total_actions = history.opponent_actions.size
        defections = np.sum(history.opponent_actions == False)
        return float(defections) / float(total_actions) if total_actions > 0 else 0.0

    def _calculate_my_avg_payoff(self, history: PlayerHistory) -> float:
        """Calculate my average payoff so far"""
        if history.my_payoffs.size == 0:
            return 0.0
        return float(np.mean(history.my_payoffs))

    def _calculate_opponent_avg_payoff(self, history: PlayerHistory) -> float:
        """Calculate average opponent payoff so far"""
        if history.opponent_payoffs.size == 0:
            return 0.0
        return float(np.mean(history.opponent_payoffs))

class Strategy_EXPLOITATIVE_474(BaseStrategy):
    """
    Predatory Harvesting with Dynamic Pivoting: An exploitative adaptive strategy
    that extracts maximum value through aggressive defection, maintains stock only
    when necessary for future exploitation, and pivots based on opponent behavior
    and stock levels to maximize relative advantage.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        remaining_rounds = self.n_rounds - round_num
        if round_num == self.n_rounds - 1:
            return Action.D
        if round_num == self.n_rounds - 2:
            if stock < 0.2 * self.capacity:
                consumption_c = stock / (2 * self.n_players)
                stock_after_c = stock - consumption_c
                if self.capacity > 0:
                    growth = 2 * stock_after_c * (1 - stock_after_c / self.capacity)
                else:
                    growth = 0
                projected_stock = min(stock_after_c + growth, self.capacity)
                if projected_stock > 0.4 * self.capacity:
                    return Action.C
            return Action.D
        if stock < 0.1 * self.capacity:
            return Action.C
        if stock < 0.3 * self.capacity and remaining_rounds >= 3:
            return Action.C
        if stock >= 0.3 * self.capacity:
            if history is not None and len(history.opponent_actions) > 0:
                total_prior_actions = history.opponent_actions.shape[0] * history.opponent_actions.shape[1]
                if total_prior_actions > 0:
                    total_cooperations = np.sum(history.opponent_actions)
                    cooperation_ratio = total_cooperations / total_prior_actions
                    defection_ratio = 1.0 - cooperation_ratio
                else:
                    defection_ratio = 0.0
            else:
                defection_ratio = 0.0
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_475(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Conditional Cooperation
    
    Prioritizes personal extraction while exploiting cooperative opponents and avoiding mutual destruction.
    Uses stock-conditional decision making with opponent modeling to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_high = game_description.capacity * 0.75
        self.threshold_medium = game_description.capacity * 0.4
        self.threshold_critical = game_description.capacity * 0.15
        self.cooperation_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock <= 0:
            return Action.C
        if current_stock >= self.game_description.capacity * 0.95:
            return Action.D
        opponent_cooperation_rate = self._calculate_opponent_cooperation_rate(history)
        if current_stock > self.threshold_high:
            return Action.D
        elif current_stock > self.threshold_medium:
            if opponent_cooperation_rate > self.cooperation_threshold:
                return Action.D
            else:
                return Action.D
        elif current_stock < self.threshold_critical:
            rounds_remaining = self.game_description.n_rounds - state.round_number
            if rounds_remaining == 1:
                return Action.D
            else:
                return Action.C
        elif opponent_cooperation_rate > self.cooperation_threshold:
            return Action.D
        else:
            return Action.D

    def _calculate_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the average cooperation rate across all opponents.
        
        Returns a value between 0.0 and 1.0 representing the proportion of
        cooperative actions observed from all opponents in all past rounds.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        total_cooperative_actions = np.sum(history.opponent_actions)
        total_possible_actions = history.opponent_actions.size
        if total_possible_actions == 0:
            return 0.0
        cooperation_rate = float(total_cooperative_actions) / float(total_possible_actions)
        return cooperation_rate

class Strategy_EXPLOITATIVE_476(BaseStrategy):
    """
    Exploitative strategy for Common Pool Resource Game.
    
    Dynamically shifts between exploitation and preservation based on stock health.
    Tracks opponent defection rates and adjusts aggression accordingly.
    Always defects in endgame (final 2 rounds) and forces cooperation only when stock is critical.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.D
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= 2:
            return Action.D
        opponent_defection_rate = self._calculate_opponent_defection_rate(history, current_round)
        if stock_ratio < 0.15:
            return Action.C
        if stock_ratio < 0.3:
            return Action.C if random.random() < 0.75 else Action.D
        if stock_ratio < 0.5:
            defect_bias = 0.7
            if opponent_defection_rate > 0.65:
                defect_bias = 0.85
            return Action.D if random.random() < defect_bias else Action.C
        if stock_ratio < 0.75:
            defect_bias = 0.85
            if opponent_defection_rate < 0.35:
                defect_bias = 0.9
            return Action.D if random.random() < defect_bias else Action.C
        return Action.D

    def _calculate_opponent_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the average defection rate of opponents across all previous rounds.
        Defection is encoded as False (0), Cooperation as True (1).
        So defection_rate = 1 - (count of cooperations / total observations)
        """
        if current_round <= 1:
            return 0.5
        opponent_actions = history.opponent_actions[:current_round]
        total_observations = opponent_actions.size
        if total_observations == 0:
            return 0.5
        cooperations = np.sum(opponent_actions)
        defections = total_observations - cooperations
        defection_rate = defections / total_observations
        return defection_rate

class Strategy_EXPLOITATIVE_477(BaseStrategy):
    """
    Adaptive Predation: Exploitative Common Pool Resource Strategy
    
    Core strategy: Defect to extract 2x payoff advantage, but cooperate when stock
    falls below a critical threshold to prevent resource collapse. Last round always
    defects. Adapts threshold based on game length to balance exploitation with survival.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        buffer_factor = max(0.2, 1.0 / self.n_rounds)
        self.critical_threshold = 2 * self.n_players * (1 + buffer_factor)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining == 1:
            return Action.D
        if current_stock < self.critical_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_478(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Recovery Management
    
    Core philosophy: Exploit cooperative opponents systematically while maintaining
    stock viability. Defect by default, cooperate only when stock collapse prevention
    is needed or during recovery windows.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.last_recovery_coop_round = -2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        if current_stock <= self.capacity / 4:
            return Action.C
        if current_round == self.n_rounds - 1:
            if current_stock > self.capacity / 4:
                return Action.D
            else:
                return Action.C
        if current_round >= 1:
            prev_stock = self._get_stock_after_round(history, current_round - 1)
            if prev_stock < self.capacity / 3 and current_stock >= self.capacity / 3:
                my_last_action = history.my_actions[current_round - 1]
                if my_last_action:
                    return Action.D
                else:
                    return Action.C
        return Action.D

    def _get_stock_after_round(self, history: PlayerHistory, round_idx: int) -> float:
        """
        Reconstruct stock level after a given round by simulating forward from
        the current state using history of actions.
        
        This is a simplified approximation: we track that stock evolves based on
        consumption patterns. For accurate tracking, we'd need to replay the game,
        but we can estimate from consumption rates.
        
        Since we don't have explicit stock history in PlayerHistory, we work with
        what we have: derive an estimate from the current stock and round progression.
        
        For safety, return a conservative estimate based on the pattern of consumption.
        """
        if round_idx < 0:
            return self.capacity
        total_cooperations = 0
        for r in range(round_idx + 1):
            total_cooperations += np.sum(history.opponent_actions[r, :])
            if history.my_actions[r]:
                total_cooperations += 1
        estimated_stock = self.capacity * (1.0 - (round_idx + 1) / (self.n_rounds * 2))
        estimated_stock = max(0.0, estimated_stock)
        return estimated_stock

class Strategy_EXPLOITATIVE_479(BaseStrategy):
    """
    Adaptive Depletion Strategy: Exploitative Common Pool Resource Strategy
    
    Maximizes personal payoff by exploiting the asymmetry between cooperative and 
    defective actions while monitoring resource depletion. Defects early when stock 
    is abundant, adapts to prevent collapse when critical, and uses terminal rounds 
    for pure exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        stock = state.current_stock
        remaining_rounds = self.n_rounds - round_num
        if round_num == 0:
            return Action.D
        if remaining_rounds <= 1:
            return Action.D
        if stock <= self.capacity * 0.15:
            opponent_avg_consumption = self._get_average_opponent_consumption(history, round_num)
            defector_consumption = stock / self.n_players if stock > 0 else 0
            if opponent_avg_consumption > defector_consumption * 0.8:
                return Action.D
            else:
                return Action.C
        if stock <= self.capacity * 0.3:
            defection_ratio = self._get_defection_ratio(history, round_num)
            if defection_ratio > 0.5:
                return Action.D
            else:
                return Action.C
        return Action.D

    def _get_average_opponent_consumption(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate average opponent consumption from last 3 rounds.
        Consumption is inferred from payoffs: D gives stock/n, C gives stock/(2n)
        """
        if round_num < 1:
            return 0.0
        lookback = min(3, round_num)
        recent_payoffs = history.opponent_payoffs[round_num - lookback:round_num, :]
        if recent_payoffs.size == 0:
            return 0.0
        avg_consumption = float(np.mean(recent_payoffs))
        return avg_consumption

    def _get_defection_ratio(self, history: PlayerHistory, round_num: int) -> float:
        """
        Calculate the ratio of defections among opponents in last 3 rounds.
        False/0 = Defect, True/1 = Cooperate
        """
        if round_num < 1:
            return 0.0
        lookback = min(3, round_num)
        recent_actions = history.opponent_actions[round_num - lookback:round_num, :]
        if recent_actions.size == 0:
            return 0.0
        defection_count = np.sum(~recent_actions)
        total_actions = recent_actions.size
        if total_actions == 0:
            return 0.0
        defection_ratio = float(defection_count) / float(total_actions)
        return defection_ratio

class Strategy_EXPLOITATIVE_480(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Exploits asymmetry between cooperators and defectors through:
    - Stock-level adaptive defection (high stock → defect; low stock → cooperate)
    - History-based opponent profiling (classify as hard defectors, cooperators, or mixed)
    - Round-position exploitation (defect in round 1 and final round unconditionally)
    - Threshold probing against mixed-strategy opponents
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_defection_rates = np.zeros(self.n_players - 1)
        self.rounds_observed = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.capacity * 0.05:
            return Action.C
        self._update_opponent_profiles(history, current_round)
        if current_stock > self.capacity * 0.6:
            return Action.D
        if current_stock <= self.capacity * 0.2:
            return Action.C
        avg_opponent_defection = np.mean(self.opponent_defection_rates) if self.rounds_observed > 0 else 0.0
        if avg_opponent_defection >= 0.5:
            return Action.D
        else:
            return Action.D

    def _update_opponent_profiles(self, history: PlayerHistory, current_round: int) -> None:
        """
        Update opponent defection rates based on observed history.
        True = Cooperate (C), False = Defect (D)
        We count defections as False values.
        """
        if current_round == 0:
            return
        for opp_idx in range(self.n_players - 1):
            opp_history = history.opponent_actions[:current_round, opp_idx]
            defections = np.sum(~opp_history)
            if current_round > 0:
                self.opponent_defection_rates[opp_idx] = defections / current_round
            else:
                self.opponent_defection_rates[opp_idx] = 0.0
        self.rounds_observed = current_round

class Strategy_EXPLOITATIVE_481(BaseStrategy):
    """
    Adaptive Predation: An exploitative common pool resource strategy that maximizes extraction
    through stock-state-based defection, opponent exploitation detection, and terminal aggression.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        current_round = state.round_number
        remaining_rounds = self.n_rounds - current_round
        if remaining_rounds <= 2:
            return Action.D
        if stock < 0.1 * self.capacity:
            return Action.C
        if current_round > 0 and history is not None:
            total_opponent_defections = np.sum(~history.opponent_actions)
            total_opponent_actions = history.opponent_actions.size
            if total_opponent_actions > 0:
                opponent_defection_rate = total_opponent_defections / total_opponent_actions
                if opponent_defection_rate > 0.6:
                    return Action.D
                if opponent_defection_rate < 0.2:
                    return Action.D
        if remaining_rounds <= self.n_rounds / 3:
            return Action.D
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0
        if stock_ratio > 0.95:
            return Action.D
        if stock_ratio > 0.75:
            return Action.D
        if stock_ratio > 0.5:
            return Action.D
        if stock_ratio > 0.25:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_482(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Cooperation
    
    Exploits asymmetry between cooperation and defection while maintaining resource
    viability only as instrumental means to further extraction. Uses dynamic thresholds
    based on stock levels and rounds remaining to decide between aggressive defection
    and conditional cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        rounds_remaining = self.r - round_num
        k = max(2, math.ceil(self.r / 5))
        if round_num > self.r - k:
            return Action.D
        threshold = self.capacity * (0.35 + 0.05 * (rounds_remaining / self.r))
        if self.n > 12:
            threshold *= 1.1
        if stock < self.capacity * 0.15:
            return Action.D
        if stock < self.capacity * 0.2:
            recovery_rate = self._calculate_recovery_rate(stock)
            required_consumption = stock * (self.n - 1) / self.n
            if recovery_rate > required_consumption * 0.6:
                return Action.C
            else:
                return Action.D
        if stock > threshold:
            return Action.D
        else:
            recovery_rate = self._calculate_recovery_rate(stock)
            required_consumption = stock * (self.n - 1) / self.n
            if recovery_rate > required_consumption * 0.6:
                return Action.C
            else:
                return Action.D

    def _calculate_recovery_rate(self, stock: float) -> float:
        """
        Calculate stock growth rate given current stock level.
        
        Recovery rate = 2 × stock × (1 - stock/capacity)
        """
        if self.capacity == 0:
            return 0.0
        recovery = 2 * stock * (1 - stock / self.capacity)
        return max(0.0, recovery)

class Strategy_EXPLOITATIVE_483(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Exploits the asymmetry between cooperators and defectors while managing resource
    depletion to maximize personal consumption. Defects when stock is abundant or when
    others are defecting, cooperates strategically at critical thresholds to allow
    regrowth, maintaining plausible deniability as a cooperative player.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        current_round = state.round_number
        if history is not None and current_round > 0:
            cooperators_last_round = np.sum(history.opponent_actions[-1, :])
            defectors_last_round = self.n - 1 - cooperators_last_round
            observed_defection_rate = defectors_last_round / max(1, self.n - 1)
        else:
            observed_defection_rate = 0.0
        rounds_remaining = self.r - current_round - 1
        if current_round == self.r - 1:
            return Action.D
        if rounds_remaining <= 2:
            return Action.D
        scarcity_threshold = self.capacity * 0.3
        if stock < scarcity_threshold:
            return Action.C
        if observed_defection_rate > 0.5:
            return Action.D
        abundance_threshold = self.capacity * 0.7
        if stock >= abundance_threshold and rounds_remaining > 3:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_484(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Conditional Cooperation
    
    Maximizes individual payoff by aggressively defecting in high-value windows
    (early rounds, final round, healthy pool with cooperative opponents) while
    conditionally cooperating only when exploitation is not feasible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        stock = state.current_stock
        if round_number == 0:
            return Action.D
        rounds_remaining = self.n_rounds - round_number - 1
        if rounds_remaining == 0:
            return Action.D
        if stock <= self.capacity / 4:
            return Action.D
        k = min(3, round_number)
        recent_opponent_actions = history.opponent_actions[-k:, :]
        total_recent_actions = k * self.n_players
        total_cooperations = np.sum(recent_opponent_actions)
        defection_rate = 1.0 - total_cooperations / total_recent_actions if total_recent_actions > 0 else 0.0
        if stock > self.capacity * 0.8 and defection_rate < 0.3:
            return Action.D
        if defection_rate < 0.3:
            return Action.D
        if stock <= self.capacity / 2 and defection_rate > 0.6:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_485(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy
    
    Exploits asymmetries in the game by:
    1. Starting with cooperation to build false reputation
    2. Defecting when stock is abundant (high payoff extraction)
    3. Defecting when stock is depleted (no sustainability benefit)
    4. Matching opponent defection rates to avoid being sole cooperator
    5. Unconditionally defecting in final round (no future consequences)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = self.capacity * 0.75
        self.threshold_low = self.capacity * 0.15
        self.collapse_threshold = self.capacity * 0.05
        self.defection_tolerance = 0.4
        self.memory_window = 3
        self.payoff_threshold_ratio = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < self.collapse_threshold:
            return Action.D
        recent_defection_ratio = self._calculate_recent_defection_ratio(history, state.round_number)
        if current_stock > self.threshold_high:
            return Action.D
        if current_stock < self.threshold_low:
            return Action.D
        if recent_defection_ratio > self.defection_tolerance:
            return Action.D
        if self._is_stock_declining(history, state.round_number):
            if recent_defection_ratio < 0.3:
                if random.random() < 0.7:
                    return Action.D
        if self._is_payoff_suboptimal(history, state.round_number):
            return Action.D
        return Action.C

    def _calculate_recent_defection_ratio(self, history: PlayerHistory, current_round: int) -> float:
        """Calculate proportion of opponent defections in recent memory window"""
        start_round = max(0, current_round - self.memory_window)
        if start_round >= current_round:
            return 0.0
        recent_opponent_actions = history.opponent_actions[start_round:current_round, :]
        defections = np.sum(recent_opponent_actions == False)
        total_actions = recent_opponent_actions.size
        if total_actions == 0:
            return 0.0
        return float(defections) / float(total_actions)

    def _is_stock_declining(self, history: PlayerHistory, current_round: int) -> bool:
        """Check if stock has been trending downward"""
        if current_round < 2:
            return False
        recent_payoffs = history.my_payoffs[max(0, current_round - self.memory_window):current_round]
        if len(recent_payoffs) < 2:
            return False
        early_avg = float(np.mean(recent_payoffs[:len(recent_payoffs) // 2]))
        late_avg = float(np.mean(recent_payoffs[len(recent_payoffs) // 2:]))
        return late_avg < early_avg

    def _is_payoff_suboptimal(self, history: PlayerHistory, current_round: int) -> bool:
        """Check if recent payoff is below expected defection payoff"""
        if current_round == 0:
            return False
        recent_payoff = float(history.my_payoffs[current_round - 1])
        estimated_d_payoff = recent_payoff * 2.0
        if recent_payoff < estimated_d_payoff * self.payoff_threshold_ratio:
            return True
        return False

class Strategy_EXPLOITATIVE_486(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Exploits the asymmetry between cooperative (S/2n) and defective (S/n) payoffs
    by defecting when stock is abundant and when opponents cooperate, while
    strategically cooperating only when necessary to maintain stock for future
    exploitation. Includes final-round aggressive defection and critical stock
    recovery mechanisms.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.capacity * 0.1:
            return Action.C
        if current_stock < self.capacity * 0.3:
            return Action.C
        if history is not None and current_round > 0:
            n_rounds_played = current_round
            if n_rounds_played > 0:
                total_opponent_cooperations = np.sum(history.opponent_actions[:current_round, :])
                total_opponent_actions = n_rounds_played * self.n_players
                if total_opponent_actions > 0:
                    observed_cooperation_rate = total_opponent_cooperations / total_opponent_actions
                else:
                    observed_cooperation_rate = 0.0
                if current_stock > self.capacity * 0.5 and observed_cooperation_rate > 0.7:
                    return Action.D
        if current_stock > self.capacity * 0.75:
            return Action.D
        if current_stock > self.capacity * 0.5:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_487(BaseStrategy):
    """
    APEX (Adaptive Predatory Extraction System): An exploitative strategy that maximizes
    extraction from the common pool by defecting aggressively while strategically
    cooperating only when necessary to prevent catastrophic stock collapse.
    
    Core mechanics:
    - Last round: pure defection
    - Depletion phase (<15% capacity): defect to race remaining stock
    - Safe abundance (≥70% capacity): defect to exploit cooperators
    - Mid-range: adaptive switching based on opponent cooperation rates and stock trajectory
    - Strategic patience: occasional cooperation to allow recovery for future exploitation
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_critical = 0.15 * self.capacity
        self.threshold_safe = 0.7 * self.capacity
        self.threshold_recovery = 0.2 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.threshold_critical:
            return Action.D
        if current_stock >= self.threshold_safe:
            return Action.D
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 2:
            return Action.D
        opponent_actions_last_round = history.opponent_actions[current_round - 1, :]
        cooperation_count = np.sum(opponent_actions_last_round)
        cooperation_rate = cooperation_count / (self.n_players - 1) if self.n_players > 1 else 0.0
        if cooperation_rate >= 0.5:
            return Action.D
        projected_stock = self._estimate_next_stock(current_stock, Action.D)
        if projected_stock < self.threshold_recovery and current_round < self.n_rounds - 2:
            return Action.C
        return Action.D

    def _estimate_next_stock(self, current_stock: float, action: Action) -> float:
        """
        Estimate the stock level after next round assuming this action and
        that opponents maintain their recent strategy distribution.
        """
        if action == Action.C:
            my_consumption = current_stock / (2 * self.n_players)
        else:
            my_consumption = current_stock / self.n_players
        avg_opponent_consumption = (current_stock / (2 * self.n_players) + current_stock / self.n_players) / 2
        total_opponent_consumption = avg_opponent_consumption * (self.n_players - 1)
        total_consumption = my_consumption + total_opponent_consumption
        stock_after_consumption = max(0, current_stock - total_consumption)
        if stock_after_consumption > 0 and self.capacity > 0:
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            new_stock = min(stock_after_consumption + growth, self.capacity)
        else:
            new_stock = 0
        return new_stock

class Strategy_EXPLOITATIVE_488(BaseStrategy):
    """
    Adaptive Resource Drain (ARD): Exploitative strategy that maximizes extraction
    through state-conditional defection, exploiting the 2:1 payoff asymmetry between
    defection and cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_stock = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        round_num = state.round_number
        total_rounds = self.game_description.n_rounds
        if history is not None and round_num > 0:
            self.previous_stock = current_stock
            if round_num > 1:
                pass
        if current_stock >= 1.5 * capacity:
            return Action.D
        if current_stock >= 0.5 * capacity:
            return Action.D
        if current_stock < 0.5 * capacity:
            if self.previous_stock > 0:
                depletion_rate = (self.previous_stock - current_stock) / self.previous_stock
            else:
                depletion_rate = 0.0
            if depletion_rate > 0.3:
                return Action.D
            if current_stock < 0.3 * capacity and depletion_rate > 0.1 and (round_num > total_rounds - 3):
                return Action.D
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_489(BaseStrategy):
    """
    Adaptive Predation: An exploitative strategy that maximizes extraction from the common pool
    through stock-aware defection, with tactical cooperation only when necessary for recovery.
    
    Core logic:
    - Early game: Always defect to exploit high stock
    - Mid game: Defect if stock > 35% capacity, else cooperate for recovery
    - End game: Always defect regardless of stock
    - Edge cases: Cooperate only when stock = 0 (forced), defect at capacity
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.stock_threshold = self.capacity * 0.35

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_stock <= 0:
            return Action.C
        early_game_cutoff = max(1, self.n_rounds // 3)
        end_game_start = max(early_game_cutoff + 1, 2 * self.n_rounds // 3)
        if current_round < early_game_cutoff:
            return Action.D
        if current_round >= end_game_start:
            return Action.D
        if current_stock > self.stock_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_490(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Defection with Conditional Cooperation
    
    Maximizes personal payoff by exploiting the 2:1 asymmetry between defection and cooperation.
    Uses stock-state dependent decisions with adaptive probability based on observed opponent defection rates.
    Employs selective cooperation only for stock regeneration when beneficial for future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = self.capacity
        self.threshold_medium = 0.75 * self.capacity
        self.threshold_critical = 3 * self.n_players
        self.observed_defection_rate = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number - 1
        if round_number == 0:
            return Action.D
        self.observed_defection_rate = self._calculate_observed_defection_rate(history, round_number)
        if round_number == self.n_rounds - 1:
            return Action.D
        if current_stock > self.threshold_high:
            return Action.D
        if current_stock <= self.threshold_critical:
            if rounds_remaining > 2:
                return Action.C
            else:
                return Action.D
        if current_stock > self.threshold_medium:
            p_defect = self._calculate_adaptive_defection_probability()
            return Action.D if random.random() < p_defect else Action.C
        return Action.D

    def _calculate_observed_defection_rate(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate the observed defection rate from opponents in previous rounds.
        Returns fraction of defection actions observed across all opponents and rounds.
        """
        if round_number == 0:
            return 0.0
        past_actions = history.opponent_actions[:round_number, :]
        total_actions = past_actions.size
        if total_actions == 0:
            return 0.0
        defection_count = np.sum(~past_actions)
        observed_defection_rate = float(defection_count) / float(total_actions)
        return observed_defection_rate

    def _calculate_adaptive_defection_probability(self) -> float:
        """
        Compute adaptive defection probability based on observed opponent behavior.
        """
        if self.observed_defection_rate > 0.7:
            return 1.0
        elif self.observed_defection_rate < 0.3:
            return 0.8
        else:
            return 0.6

class Strategy_EXPLOITATIVE_491(BaseStrategy):
    """
    Adaptive Extraction Strategy for Common Pool Resource Game.
    
    Exploits asymmetry between cooperative and defective actions while managing
    stock depletion. Uses stock-conditional logic combined with opponent behavior
    monitoring to maximize personal payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            if stock > 0.01 * self.capacity:
                return Action.D
            else:
                return Action.C
        if stock < 0.1 * self.capacity:
            return Action.C
        if stock < 0.5 * self.capacity and round_num < self.n_rounds - 2:
            return Action.C
        if round_num >= 2:
            recent_opponent_actions = history.opponent_actions[round_num - 2:round_num, :]
            defection_rate = 1.0 - np.mean(recent_opponent_actions.astype(float))
            if defection_rate > 0.6:
                return Action.D
            if defection_rate < 0.4:
                return Action.D
        threshold_high = 1.5 * self.capacity
        threshold_medium_high = 0.75 * self.capacity
        threshold_medium_low = 0.75 * self.capacity
        if stock >= threshold_high:
            return Action.D
        if stock >= threshold_medium_low:
            prob_defect = (stock - threshold_medium_low) / threshold_medium_low
            if random.random() < prob_defect:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_492(BaseStrategy):
    """
    Adaptive Predation with Resource Awareness: Unconditional defection strategy
    that exploits the asymmetry between cooperation (stock/(2n)) and defection (stock/n).
    
    Core logic: Always defect regardless of stock level or round number.
    - Defection yields 2x the payoff of cooperation
    - No credible punishment mechanism exists in simultaneous-move games
    - Stock dynamics favor early exploitation before capacity ceiling
    - Final round backward induction mandates defection
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        stock_t = state.current_stock
        critical_threshold = self.capacity * 0.3
        moderate_threshold = self.capacity * 0.7
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if stock_t < critical_threshold:
            return Action.D
        if stock_t < moderate_threshold:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_493(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Maximizes individual extraction by defecting when stock is healthy, cooperating
    only when necessary to preserve the pool, and unconditionally defecting in endgame.
    Exploits the 2:1 payoff ratio of defection over cooperation and free-rides on
    cooperative opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_threshold = self.capacity * (1 - 1 / self.n_players)
        self.threshold_decay_rate = 0.9

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        remaining_rounds = self.n_rounds - round_number
        if round_number == 0:
            return Action.D
        if remaining_rounds <= 2:
            return Action.D
        if history is not None and round_number > 0:
            opponent_actions_last_round = history.opponent_actions[round_number - 1, :]
            observed_defectors = np.sum(opponent_actions_last_round == False)
            if current_stock <= self.capacity / self.n_players and observed_defectors >= self.n_players - 1:
                return Action.D
            if current_stock > self.stock_threshold and observed_defectors >= math.ceil(self.n_players / 2):
                return Action.D
            if round_number >= 2:
                prev_stock = None
                if round_number > 1:
                    prev_defectors = np.sum(history.opponent_actions[round_number - 2, :] == False)
                    if current_stock < state.current_stock and prev_defectors <= math.ceil(self.n_players / 2):
                        self.stock_threshold *= self.threshold_decay_rate
        if current_stock > self.stock_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_494(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Defection
    
    Aggressively defects when stock is healthy (>40% capacity), cooperates when depleted (<20%),
    and conditionally defects in the middle zone based on stock trajectory analysis to detect
    and exploit cooperators while matching mutual defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.consecutive_coop_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock = state.current_stock
        if round_t == self.n_rounds - 1:
            return Action.D
        if round_t == 0:
            return Action.D
        if stock < 0.01:
            self.consecutive_coop_rounds += 1
            if self.consecutive_coop_rounds <= 2:
                return Action.C
            else:
                self.consecutive_coop_rounds = 0
        if stock >= self.capacity * 0.4:
            self.consecutive_coop_rounds = 0
            return Action.D
        low_threshold = self.capacity * 0.15 if self.n_players == 2 else self.capacity * 0.2
        if stock < low_threshold:
            self.consecutive_coop_rounds = 0
            return Action.C
        remaining_rounds = self.n_rounds - round_t
        if remaining_rounds <= 2:
            self.consecutive_coop_rounds = 0
            return Action.D
        if history is not None and round_t > 0:
            prev_stock = history.opponent_payoffs[round_t - 1, 0] if round_t > 0 else stock
            stock_delta = stock - (history.my_payoffs[round_t - 1] + np.sum(history.opponent_payoffs[round_t - 1, :]))
            if round_t >= 1:
                recent_opponent_coop = np.sum(history.opponent_actions[round_t - 1, :])
                recent_my_action = history.my_actions[round_t - 1]
                if recent_opponent_coop >= self.n_players * 0.5:
                    self.consecutive_coop_rounds = 0
                    return Action.D
                if recent_opponent_coop <= self.n_players * 0.25:
                    if remaining_rounds <= 3:
                        self.consecutive_coop_rounds = 0
                        return Action.D
                    else:
                        return Action.C
                return Action.C
        self.consecutive_coop_rounds = 0
        return Action.D

class Strategy_EXPLOITATIVE_495(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Dynamic Pivot
    
    Core philosophy: exploit cooperative opponents while maintaining plausible deniability,
    and transition to aggressive extraction before depletion becomes irreversible.
    Defaults to DEFECT in nearly all conditions to maximize personal payoff at collective expense.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.D
        if stock > 0.6 * self.capacity:
            return Action.D
        if stock > 0.3 * self.capacity:
            return Action.D
        if stock <= 0.3 * self.capacity:
            if current_round == self.n_rounds - 1:
                return Action.D
            if stock < 0.1 * self.capacity:
                return Action.D
            return Action.D
        if history is not None and len(history.opponent_actions) > 0:
            window_size = min(3, len(history.opponent_actions))
            recent_actions = history.opponent_actions[-window_size:, :]
            total_recent_actions = window_size * self.n_players
            if total_recent_actions > 0:
                defection_count = np.sum(~recent_actions)
                recent_defection_rate = defection_count / total_recent_actions
                if recent_defection_rate > 0.5:
                    return Action.D
                elif recent_defection_rate < 0.3:
                    return Action.D
                else:
                    return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_496(BaseStrategy):
    """
    Adaptive Predation: An exploitative strategy that identifies and ruthlessly exploits
    cooperative opponents while matching defectors' aggression. Always defects in first
    and last rounds, classifies opponents by cooperation rate, and maintains predatory
    behavior regardless of stock depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_classifications = {}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        self._update_opponent_classifications(history)
        action = Action.D
        capacity = self.game_description.capacity
        if state.current_stock < capacity / 4:
            action = Action.D
        elif state.current_stock < capacity / 20:
            action = Action.D
        else:
            action = Action.D
        return action

    def _update_opponent_classifications(self, history: PlayerHistory) -> None:
        """
        Classify each opponent as COOPERATIVE, DEFECTOR, or MIXED/UNCERTAIN
        based on their historical play rate.
        """
        n_opponents = self.game_description.n_players - 1
        rounds_played = history.my_actions.shape[0]
        for opp_idx in range(n_opponents):
            if rounds_played == 0:
                self.opponent_classifications[opp_idx] = 'UNCERTAIN'
                continue
            cooperations = np.sum(history.opponent_actions[:rounds_played, opp_idx])
            cooperation_rate = cooperations / rounds_played
            if cooperation_rate >= 0.7:
                self.opponent_classifications[opp_idx] = 'COOPERATIVE'
            elif cooperation_rate <= 0.3:
                self.opponent_classifications[opp_idx] = 'DEFECTOR'
            else:
                self.opponent_classifications[opp_idx] = 'MIXED'

class Strategy_EXPLOITATIVE_497(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Maximizes individual payoff by defecting when stock is healthy, adapting
    to observed cooperators in medium-stock states, and always defecting in
    the final round. Exploits the 2x payoff advantage of defection while
    monitoring stock health to optimize extraction timing.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number
        stock = state.current_stock
        if round_t == self.n_rounds - 1:
            return Action.D
        if round_t == 0:
            return Action.D
        stock_ratio = stock / max(self.capacity, 1e-10)
        if stock_ratio > 0.6:
            return Action.D
        elif stock_ratio > 0.2:
            observed_cooperators = int(np.sum(history.opponent_actions[-1, :]))
            if observed_cooperators >= self.n_players / 2:
                return Action.D
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_498(BaseStrategy):
    """
    Adaptive Predation with Resource Monitoring: An exploitative strategy that
    balances short-term extraction with resource sustainability to maximize long-term
    payoff. Defaults to defection when resources are healthy, switches to cooperation
    only when stock approaches critical depletion levels, and monitors opponent behavior
    to identify exploitation opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.consecutive_coop_rounds = 0
        self.recovery_target_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        rounds_remaining = self.n_rounds - current_round
        if self.recovery_target_stock is not None:
            if stock >= self.recovery_target_stock:
                self.recovery_target_stock = None
                self.consecutive_coop_rounds = 0
            else:
                self.consecutive_coop_rounds += 1
                if self.consecutive_coop_rounds >= 2:
                    self.recovery_target_stock = None
                    self.consecutive_coop_rounds = 0
                    return Action.D
                return Action.C
        if stock_ratio < 0.1:
            self.recovery_target_stock = self.capacity * 0.25
            self.consecutive_coop_rounds = 1
            return Action.C
        if stock_ratio < 0.2 and rounds_remaining > 2:
            return Action.C
        if stock_ratio < 0.35 and rounds_remaining > 2:
            return Action.C
        if current_round >= self.n_rounds - 3:
            if stock_ratio > 0.2:
                return Action.D
            else:
                return Action.C
        opponent_defection_rate = self._calculate_opponent_defection_rate(history)
        if opponent_defection_rate > 0.65:
            return Action.D
        if opponent_defection_rate < 0.3:
            return Action.D
        return Action.D

    def _calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the proportion of defections observed from opponents across all rounds.
        Returns a value between 0.0 and 1.0.
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        total_actions = history.opponent_actions.size
        if total_actions == 0:
            return 0.0
        total_defections = np.sum(~history.opponent_actions)
        defection_rate = float(total_defections) / float(total_actions)
        return defection_rate

class Strategy_EXPLOITATIVE_499(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Resource Monitoring
    
    Exploits cooperators through stock-conditional defection while managing resource
    depletion. Defects aggressively when stock is healthy, adapts probabilistically
    in middle ranges, and strategically cooperates only when stock is critically low
    to allow regeneration. Employs endgame defection in final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round >= self.n_rounds - 2:
            return Action.D
        if current_round == 0:
            return Action.D
        health_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if current_stock <= 0:
            return Action.D
        if health_ratio > 0.5:
            return Action.D
        elif health_ratio > 0.2:
            defection_probability = (health_ratio - 0.2) / 0.3
            if random.random() < defection_probability:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_500(BaseStrategy):
    """
    Adaptive Extraction Strategy for Common Pool Resource Game.
    
    Exploits asymmetry between cooperative and defective payoffs while maintaining
    stock viability. Uses round-dependent logic, stock health assessment, and
    observed opponent behavior to maximize extraction throughout the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.r - 1:
            return Action.D
        if current_round >= self.r - 2:
            return Action.D
        if stock < 2 * self.n * 0.15:
            return Action.D
        if stock < 2 * self.n:
            if random.random() < 0.95:
                return Action.D
            return Action.C
        if stock < 2 * self.n * 0.4:
            depletion_severity = 1.0 - stock / (2 * self.n * 0.4)
            defect_prob = depletion_severity * 0.9
            if random.random() < defect_prob:
                return Action.D
            return Action.C
        rounds_remaining = self.r - current_round
        stock_per_defector = stock / self.n if self.n > 0 else 0
        stock_per_cooperator = stock / (2 * self.n) if self.n > 0 else 0
        defection_benefit = stock_per_defector - stock_per_cooperator
        if stock_per_defector > 0:
            recovery_threshold = self.capacity / stock_per_defector
            if rounds_remaining > recovery_threshold:
                return Action.D
        if defection_benefit * rounds_remaining > stock * 0.25:
            return Action.D
        if current_round <= 2 and len(history.opponent_actions) > 0:
            recent_round_idx = min(current_round - 1, len(history.opponent_actions) - 1)
            if recent_round_idx >= 0:
                recent_defections = self.n - sum(history.opponent_actions[recent_round_idx, :])
                observed_defection_rate = recent_defections / self.n if self.n > 0 else 0
                if observed_defection_rate > 0.5:
                    if random.random() < 0.8:
                        return Action.D
                elif observed_defection_rate <= 0.3:
                    if random.random() < 0.6:
                        return Action.D
                    return Action.C
        if stock >= self.capacity * 0.95 and current_round % 3 == 0:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_501(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Conditional Defection
    
    Maximizes personal payoff by unconditionally defecting to exploit the common pool's
    regenerative capacity. Defection yields S/n per round while cooperation yields S/(2n),
    providing a consistent 2:1 payoff advantage. Uses stock-conditional thresholds to
    adapt to depletion dynamics, but ultimately always defects regardless of stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = self.capacity * 0.75
        self.threshold_medium = self.capacity * 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= 2:
            return Action.D
        if stock > self.threshold_high:
            return Action.D
        elif stock > self.threshold_medium:
            return Action.D
        else:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_502(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Sustainability Harvesting
    
    Systematically exploits the common pool by defecting when stock is abundant,
    and only cooperating minimally when stock approaches critical levels to prevent
    total collapse. Uses threshold-based decision rules to maximize immediate payoff
    while avoiding complete resource depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = self.capacity * 0.75
        self.threshold_critical = self.capacity / self.n_players + 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if stock >= self.threshold_high:
            return Action.D
        if stock > self.threshold_critical:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_503(BaseStrategy):
    """
    Adaptive Predatory Depletion (APD) Strategy for Common Pool Resource Game.
    
    Exploits cooperative players while stock is healthy, matches defectors when they dominate,
    and races to extract resources during collapse or endgame scenarios. Prioritizes individual
    extraction over collective sustainability through adaptive conditional defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.previous_stock = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_stock = state.current_stock
            return Action.D
        current_stock = state.current_stock
        round_num = state.round_number
        observed_defection_rate = self._calculate_defection_rate(history)
        depletion_rate = self._calculate_depletion_rate(self.previous_stock, current_stock)
        self.previous_stock = current_stock
        if round_num == self.n_rounds - 1:
            return Action.D
        if current_stock <= self.capacity * 0.15:
            return Action.D
        if round_num >= self.n_rounds * 0.75:
            return Action.D
        if observed_defection_rate >= 0.5:
            return Action.D
        if depletion_rate > 0.05:
            return Action.D
        if current_stock > self.capacity * 0.85:
            if observed_defection_rate < 0.5:
                return Action.C
        if self.capacity * 0.15 < current_stock <= self.capacity * 0.85:
            if self._is_stock_rising(history):
                return Action.C
            else:
                return Action.D
        return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the observed defection rate of opponents.
        True = Cooperate (C), False = Defect (D)
        Defection rate = proportion of False values (D actions)
        """
        if history.opponent_actions.size == 0:
            return 0.0
        total_actions = history.opponent_actions.size
        cooperations = np.sum(history.opponent_actions)
        defections = total_actions - cooperations
        return defections / total_actions if total_actions > 0 else 0.0

    def _calculate_depletion_rate(self, previous_stock: float, current_stock: float) -> float:
        """
        Calculate the rate of stock depletion.
        Returns (previous - current) / previous
        """
        if previous_stock <= 0:
            return 0.0
        depletion = previous_stock - current_stock
        return depletion / previous_stock

    def _is_stock_rising(self, history: PlayerHistory) -> bool:
        """
        Check if stock has been rising in recent rounds by examining payoff trends.
        If the most recent round has higher aggregate payoffs, stock is likely recovering.
        Alternatively, track stock growth more directly if available in state.
        
        Since we don't have direct stock history in state, we use a heuristic:
        If we're seeing cooperative behavior sustain, stock is likely rising.
        """
        if history.my_payoffs.size < 2:
            return False
        recent_payoff = history.my_payoffs[-1]
        previous_payoff = history.my_payoffs[-2]
        return recent_payoff > previous_payoff

class Strategy_EXPLOITATIVE_504(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Extraction with Conditional Defection
    
    Treats cooperation as a temporary tool for resource accumulation. Extracts maximum
    value while minimizing risk of complete resource collapse. Defects by default,
    cooperates only when stock threatens collapse or to prevent mutual annihilation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.threshold = 0.3 * self.capacity
        self.critical_threshold = 0.1 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        if current_stock < self.critical_threshold:
            return Action.C
        if round_num >= 2:
            stock_decline = history.my_payoffs[round_num - 1]
            if round_num >= 2:
                prev_decline = history.my_payoffs[round_num - 2]
                if stock_decline > 0 and prev_decline > 0:
                    if round_num >= 1:
                        total_consumed_last = sum(history.opponent_actions[round_num - 1, :])
                        total_consumed_prev = sum(history.opponent_actions[round_num - 2, :]) if round_num >= 2 else 0
                        if total_consumed_last > total_consumed_prev * 0.8 and current_stock < 0.6 * self.capacity:
                            return Action.C
        all_opponent_actions = history.opponent_actions[:round_num, :]
        if all_opponent_actions.size > 0:
            cooperations = np.sum(all_opponent_actions)
            total_actions = all_opponent_actions.size
            cooperation_rate = cooperations / total_actions if total_actions > 0 else 0.0
            defection_rate = 1.0 - cooperation_rate
        else:
            cooperation_rate = 0.0
            defection_rate = 0.0
        if current_stock >= self.threshold:
            if defection_rate > 0.5:
                return Action.D
            if cooperation_rate > 0.5:
                return Action.D
            return Action.D
        if current_stock >= self.critical_threshold:
            if defection_rate > 0.5:
                return Action.D
            if cooperation_rate >= 0.5:
                return Action.D
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_505(BaseStrategy):
    """
    Adaptive Predation: An exploitative common pool resource strategy that defaults to defection
    while adapting to observed opponent behavior and game phase. Maximizes extraction by exploiting
    the asymmetric payoff structure (D yields S/n vs C yields S/(2n)) across all conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        observed_defection_rate = 0.0
        if history is not None and current_round > 0:
            last_round_actions = history.opponent_actions[current_round - 1, :]
            n_defectors = np.sum(last_round_actions == False)
            observed_defection_rate = float(n_defectors) / self.n_players
        depleted_threshold = self.capacity * 0.15
        abundant_threshold = self.capacity * 0.7
        moderate_lower = self.capacity * 0.3
        moderate_upper = self.capacity * 0.7
        rounds_remaining = self.n_rounds - current_round
        is_terminal = rounds_remaining <= 2
        if current_stock < depleted_threshold:
            return Action.D
        if is_terminal:
            return Action.D
        if current_stock > abundant_threshold:
            return Action.D
        if moderate_lower <= current_stock <= moderate_upper:
            if observed_defection_rate > 0.65:
                return Action.D
            if history is not None and current_round > 0:
                last_round_coop_rate = float(np.sum(history.opponent_actions[current_round - 1, :] == True)) / self.n_players
                if last_round_coop_rate == 1.0:
                    return Action.D
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_506(BaseStrategy):
    """
    Exploitative Common Pool Resource Strategy.
    
    Prioritizes extracting maximum personal value through defection, with conditional
    cooperation only when defection would reduce payoff. Targets cooperators and adapts
    to defection prevalence in the player population.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.D
        if round_num == self.n_rounds - 1:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio > 0.75:
            return Action.D
        if stock_ratio > 0.4:
            prev_round_idx = round_num - 1
            opponent_actions_prev = history.opponent_actions[prev_round_idx, :]
            cooperators_prev = np.sum(opponent_actions_prev)
            defectors_prev = self.n_players - cooperators_prev
            defection_rate = defectors_prev / self.n_players if self.n_players > 0 else 0.0
            if defection_rate >= 0.5:
                return Action.D
            else:
                return Action.C
        if stock_ratio <= 0.4:
            payoff_d_this = current_stock / self.n_players if self.n_players > 0 else 0.0
            payoff_c_this = current_stock / (2 * self.n_players) if self.n_players > 0 else 0.0
            if payoff_d_this > payoff_c_this:
                return Action.D
            if self.n_rounds - round_num > 1 and current_stock > 0:
                return Action.C
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_507(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with Collapse Prevention
    
    This strategy exploits cooperative players systematically while avoiding mutual defection collapse.
    It treats the common pool as a renewable resource to extract maximum value when others cooperate,
    then adapts when they defect. Key features include conditional defection based on stock levels
    and cooperation patterns, relative payoff tracking, and unconditional defection in endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.danger_threshold = game_description.capacity * 0.15
        self.cooperative_ratio_threshold = 0.5
        self.cumulative_payoff = 0.0
        self.total_payoff_distributed = 0.0
        self.rounds_played = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock = state.current_stock
        current_round = state.round_number
        self.cumulative_payoff = float(np.sum(history.my_payoffs))
        self.rounds_played = current_round
        total_distributed = float(np.sum(history.opponent_payoffs)) + self.cumulative_payoff
        avg_player_payoff = total_distributed / n / max(current_round, 1)
        if current_round >= r - 2:
            return Action.D
        if stock <= self.danger_threshold:
            return Action.D
        last_round_actions = history.opponent_actions[current_round - 1, :]
        cooperators_last_round = int(np.sum(last_round_actions))
        cooperation_ratio = cooperators_last_round / (n - 1) if n > 1 else 0.0
        if cooperation_ratio >= 0.6 and stock > self.danger_threshold:
            return Action.D
        if cooperation_ratio < 0.3 and stock > capacity * 0.5:
            return Action.D
        my_avg_payoff = self.cumulative_payoff / max(current_round, 1)
        if my_avg_payoff < avg_player_payoff * 0.9:
            return Action.D
        if current_round >= 2:
            recent_rounds_start = max(0, current_round - 2)
            recent_actions = history.opponent_actions[recent_rounds_start:current_round, :]
            defector_consistency = np.sum(~recent_actions, axis=0) / (current_round - recent_rounds_start)
            if np.any(defector_consistency >= 0.8):
                return Action.D
        if cooperation_ratio > 0.75 and stock > capacity * 0.5:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_508(BaseStrategy):
    """
    Adaptive Depletion with Recovery Baiting Strategy.
    
    Exploitative strategy that:
    1. Appears cooperative early to identify exploitable players
    2. Defects when stock is abundant (>60% capacity)
    3. Adaptively responds to detected defection rates in medium stock levels
    4. Always defects in final rounds and when stock is low
    5. Prioritizes extraction over sustainability
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0 or current_round == 1:
            return Action.C
        if current_round >= self.n_rounds - 1:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if stock_ratio > 0.6:
            return Action.D
        if stock_ratio <= 0.2:
            return Action.D
        if history is not None and len(history.opponent_actions) > 0:
            total_defections = np.sum(~history.opponent_actions)
            total_opponent_actions = history.opponent_actions.size
            if total_opponent_actions > 0:
                defection_rate = total_defections / total_opponent_actions
                if defection_rate > 0.5:
                    return Action.D
                if defection_rate <= 0.3:
                    return Action.C
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_509(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Predation with State Collapse
    
    Core approach:
    - Round 1: DEFECT to establish aggressive baseline and probe responses
    - Rounds 2 to r-1: DEFECT by default; switch to COOPERATE only when stock < 15% capacity
    - Final round: DEFECT to maximize final extraction
    
    Exploits cooperators through asymmetric payoffs and accelerates stock collapse
    while capturing disproportionate gains during abundance phase.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.collapse_threshold = self.capacity * 0.15

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.collapse_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_510(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Dynamic Defection
    
    Exploits asymmetry between cooperative (S/2n) and defective (S/n) payoffs
    while dynamically adapting to stock levels and opponent behavior.
    Uses stock-conditional defection, temporal exploitation, and history-based
    adaptive responses to maximize individual payoff extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if current_round == 0:
            return Action.D
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining <= 2:
            return Action.D
        cooperation_rate = self._calculate_cooperation_rate(history, current_round)
        if cooperation_rate > 0.6:
            return Action.D
        stock_ratio = stock / self.capacity if self.capacity > 0 else 0.0
        threshold_multiplier = 1.0
        if rounds_remaining <= self.n_rounds / 3:
            threshold_multiplier = 0.95
        if stock_ratio < 0.1:
            return Action.C
        if stock_ratio < 0.05:
            return Action.C
        if stock_ratio > 0.6 * threshold_multiplier:
            return Action.D
        if stock_ratio > 0.3 * threshold_multiplier:
            defection_prob = (stock_ratio - 0.3 * threshold_multiplier) / (0.3 * threshold_multiplier)
            return Action.D if random.random() < defection_prob else Action.C
        return Action.C

    def _calculate_cooperation_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate the cooperation rate of opponents based on observed history.
        Returns ratio of cooperative actions to total actions observed.
        """
        if current_round <= 0:
            return 0.5
        total_coop_actions = 0
        for round_idx in range(current_round):
            total_coop_actions += np.sum(history.opponent_actions[round_idx, :])
        total_actions = current_round * self.n_players
        if total_actions == 0:
            return 0.5
        return float(total_coop_actions) / float(total_actions)

class Strategy_EXPLOITATIVE_511(BaseStrategy):
    """
    Adaptive Predation: Exploitative Common Pool Resource Strategy
    
    Core philosophy: Defect by default to extract double payoffs from cooperators.
    Only consider cooperation in rare middle-game scenarios with specific conditions.
    Unconditionally defect in endgame and when stock is critically depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity * 0.15

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        stock = state.current_stock
        round_num = state.round_number
        rounds_remaining = r - round_num
        if round_num == r - 1:
            return Action.D
        if stock <= self.threshold:
            return Action.D
        if rounds_remaining <= 2:
            return Action.D
        if round_num == 0:
            return Action.D
        if history is not None and rounds_remaining >= 3 and (stock > 2 * self.game_description.capacity / 3):
            cooperators_last_round = int(np.sum(history.opponent_actions[-1, :]))
            majority_threshold = n / 2
            if cooperators_last_round >= majority_threshold:
                immediate_payoff_defect = stock / n
                expected_sustained_stock = stock * 0.95
                expected_future_cooperator_payoff = expected_sustained_stock / (2 * n) * rounds_remaining
                if expected_future_cooperator_payoff >= immediate_payoff_defect:
                    return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_512(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Depletion with Opportunistic Defection
    
    Core philosophy: Exploit asymmetry between cooperators and defectors by opportunistically
    defecting when stock can sustain it, while strategically cooperating only when defection
    risks catastrophic collapse. Adapts to opponent behavior via defection rate monitoring.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        rounds_remaining = self.n_rounds - round_number
        if round_number == 0:
            return Action.D
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0.0
        if rounds_remaining == 1:
            if current_stock > 0:
                return Action.D
            else:
                return Action.C
        observed_defection_rate = self._calculate_recent_defection_rate(history)
        if stock_ratio > 0.5:
            return Action.D
        if observed_defection_rate > 0.25:
            return Action.D
        return Action.C

    def _calculate_recent_defection_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the defection rate of opponents in the last 3 rounds (or all if fewer exist).
        True/1 = Cooperate, False/0 = Defect
        Returns fraction of opponent actions that were DEFECT (False/0)
        """
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        recent_rounds = min(3, len(history.opponent_actions))
        recent_opponent_actions = history.opponent_actions[-recent_rounds:, :]
        total_actions = recent_opponent_actions.size
        if total_actions == 0:
            return 0.0
        defection_count = np.sum(recent_opponent_actions == False)
        defection_rate = float(defection_count) / float(total_actions)
        return defection_rate

class Strategy_COLLECTIVE_180(BaseStrategy):
    """
    Adaptive Stewardship with Defensive Resilience strategy for Common Pool Resource Game.
    
    Prioritizes sustainable collective outcomes while maintaining resilience against exploitation.
    Uses stock-dependent cooperation thresholds and adaptive defection rate tracking to balance
    long-term resource sustainability with individual payoff protection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = 0.75 * self.capacity
        self.threshold_medium = 0.5 * self.capacity
        self.threshold_critical = 0.3 * self.capacity
        self.threshold_collapse = 0.25 * self.capacity
        self.threshold_recovery = 0.8 * self.capacity
        self.rdr_smoothing_current = 0.6
        self.rdr_smoothing_historical = 0.4
        self.rdr_historical = 0.0
        self.last_recovery_reset = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        round_num = state.round_number
        if round_num == self.r - 1:
            return Action.D
        if stock < self.threshold_collapse:
            return Action.D
        if round_num <= 1:
            return Action.C
        last_round_defectors = np.sum(~history.opponent_actions[round_num - 1, :])
        rdr_current = last_round_defectors / self.n
        rdr_smoothed = self.rdr_smoothing_current * rdr_current + self.rdr_smoothing_historical * self.rdr_historical
        self.rdr_historical = rdr_smoothed
        if stock > self.threshold_recovery and (not self.last_recovery_reset):
            self.rdr_historical = self.rdr_historical * 0.8
            self.last_recovery_reset = True
        elif stock <= self.threshold_recovery:
            self.last_recovery_reset = False
        if stock > self.threshold_high:
            return Action.C
        elif stock > self.threshold_medium:
            if rdr_smoothed < 0.35:
                return Action.C
            elif rdr_smoothed < 0.6:
                coop_probability = 1.0 - rdr_smoothed
                if random.random() < coop_probability:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_181(BaseStrategy):
    """
    Adaptive Stewardship Strategy (ASS) for Common Pool Resource Game.
    
    Balances individual payoff maximization with collective resource sustainability
    through threshold-based decision logic and monitoring of opponent defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.danger_threshold = 2 * self.n
        self.caution_threshold = 0.3 * self.capacity
        self.healthy_threshold = 0.6 * self.capacity
        self.defection_surge_cooldown = 0
        self.adjusted_caution_threshold = self.caution_threshold
        self.last_defection_rate = 0.0
        self.solo_cooperation_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.defection_surge_cooldown > 0:
            self.defection_surge_cooldown -= 1
        defection_rate = self._calculate_defection_rate(history, state.round_number)
        if self._is_solo_cooperator(history, state.round_number):
            self.solo_cooperation_rounds += 1
        else:
            self.solo_cooperation_rounds = 0
        if state.round_number > 1:
            if defection_rate - self.last_defection_rate > 0.3:
                self.defection_surge_cooldown = 2
                self.adjusted_caution_threshold = self.caution_threshold * 1.1
        self.last_defection_rate = defection_rate
        active_caution_threshold = self.adjusted_caution_threshold if self.defection_surge_cooldown > 0 else self.caution_threshold
        stock = state.current_stock
        round_num = state.round_number
        if stock < self.danger_threshold:
            return Action.D
        if round_num == self.n_rounds - 1:
            if stock < self.danger_threshold or (stock < active_caution_threshold and defection_rate > 0.4):
                return Action.D
            else:
                return Action.C
        if round_num > 1 and self._has_stock_recovered(history, state.round_number):
            if defection_rate <= 0.7:
                return Action.C
        if self.solo_cooperation_rounds >= 3:
            if stock < active_caution_threshold:
                if round_num == self.n_rounds - 1:
                    return Action.D
        if stock < active_caution_threshold:
            if defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        elif stock >= self.healthy_threshold:
            if defection_rate > 0.7:
                return Action.D
            else:
                return Action.C
        elif defection_rate > 0.6:
            return Action.D
        else:
            return Action.C

    def _calculate_defection_rate(self, history: PlayerHistory, current_round: int) -> float:
        """
        Calculate proportion of defections by all other players across all past rounds.
        """
        if current_round == 0:
            return 0.0
        past_rounds = current_round
        opponent_count = self.n - 1
        if past_rounds == 0 or opponent_count == 0:
            return 0.0
        total_actions = past_rounds * opponent_count
        cooperations = np.sum(history.opponent_actions[:past_rounds, :])
        defections = total_actions - cooperations
        defection_rate = defections / total_actions if total_actions > 0 else 0.0
        return defection_rate

    def _is_solo_cooperator(self, history: PlayerHistory, current_round: int) -> bool:
        """
        Check if this player is the only cooperator in the most recent round.
        """
        if current_round == 0:
            return False
        my_last_action = history.my_actions[current_round - 1]
        if not my_last_action:
            return False
        opponent_defections = ~history.opponent_actions[current_round - 1, :]
        return np.all(opponent_defections)

    def _has_stock_recovered(self, history: PlayerHistory, current_round: int) -> bool:
        """
        Check if stock jumped by >20% from growth in the most recent round.
        """
        if current_round < 2:
            return False
        if current_round >= 2:
            prev_round_payoffs = history.my_payoffs[current_round - 2]
            curr_round_payoffs = history.my_payoffs[current_round - 1]
            if prev_round_payoffs > 0:
                growth_rate = (curr_round_payoffs - prev_round_payoffs) / prev_round_payoffs
                return growth_rate > 0.2
        return False