"""
Generated LLM strategies for social dilemma games.

This file contains strategy classes generated by LLMs for game theory experiments.
Each strategy is a callable class that implements a specific approach to the game.

Generated with:
- Provider: Client
- Model: deepseek-r1:32b
- Game: public_goods
"""

from dataclasses import dataclass
from enum import Enum
import math
import numpy as np
from numpy.typing import NDArray
import random

from emergent_llm.players import BaseStrategy
from emergent_llm.games import PublicGoodsDescription, CollectiveRiskDescription, CommonPoolDescription, CommonPoolState
from emergent_llm.common import Action, C, D, PlayerHistory, GameState




class Strategy_COLLECTIVE_14(BaseStrategy):
    """
    A strategy that cooperates initially, defects when stock drops below 75% of capacity,
    and always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.threshold = 0.75 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_15(BaseStrategy):
    """
    Cooperate in all rounds except the last one where players Defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_39(BaseStrategy):
    """
    Cooperate if current stock exceeds 80% of capacity, else defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        threshold = 0.8 * self.capacity
        current_stock = state.current_stock
        if current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_48(BaseStrategy):
    """
    A strategy that cooperates when the current stock exceeds half the capacity and defects otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.threshold = 0.5 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        if current_stock > self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_58(BaseStrategy):
    """
    A strategy where each player cooperates if the current stock is above 80% of capacity,
    otherwise defects. This balances individual payoff maximization with sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.T_high = 0.8 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if current_stock > self.T_high:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_66(BaseStrategy):

    def __init__(self, game_description):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_actions = history.opponent_actions[-1, :]
        cooperators = np.sum(prev_actions)
        coop_rate = cooperators / self.game_description.n_players
        sustainable_threshold = 0.5 * self.game_description.capacity
        current_stock = state.current_stock
        if coop_rate > 0.6 and current_stock >= sustainable_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_72(BaseStrategy):
    """
    Cooperate if the current stock is greater than half of the capacity; else Defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.threshold = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        if current_stock > self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_83(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.target = 0.5 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.current_stock > self.target:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_84(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        threshold = self.capacity / 2.0
        if current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_95(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances between cooperation and defection based on the current stock level and round number.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            current_round = state.round_number
            n_rounds = self.game_description.n_rounds
            capacity = self.game_description.capacity
            if current_round == n_rounds - 1:
                return Action.D
            else:
                stock = state.current_stock
                if stock > 0.8 * capacity:
                    return Action.C
                else:
                    return Action.D