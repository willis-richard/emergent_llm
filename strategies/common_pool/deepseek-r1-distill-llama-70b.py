"""
Generated LLM strategies for social dilemma games.

This file contains strategy classes generated by LLMs for game theory experiments.
Each strategy is a callable class that implements a specific approach to the game.

Generated with:
- Provider: OpenAI
- Model: deepseek/deepseek-r1-distill-llama-70b
- Game: common_pool
"""

from dataclasses import dataclass
from enum import Enum
import math
import numpy as np
from numpy.typing import NDArray
import random

from emergent_llm.players import BaseStrategy
from emergent_llm.games import PublicGoodsDescription, CollectiveRiskDescription, CommonPoolDescription, CommonPoolState
from emergent_llm.common import Action, C, D, PlayerHistory, GameState




class Strategy_COLLECTIVE_1(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) Strategy.

    This strategy begins by cooperating to establish trust. In subsequent rounds,
    it adapts based on the current stock level and the number of players who
    cooperated in the previous round. It prioritizes cooperation when the stock
    is low to allow recovery and defects to punish or conserve resources when
    thresholds are not met. In the final round, it cooperates if the stock is
    healthy, otherwise defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            stock_level = state.current_stock / self.capacity
            if stock_level > 0.5:
                return Action.C
            else:
                return Action.D
        else:
            stock_level = state.current_stock / self.capacity
            if stock_level <= 0.5:
                return Action.C
            else:
                prev_round = state.round_number - 1
                my_last_action = history.my_actions[prev_round]
                opponent_actions_last = history.opponent_actions[prev_round, :]
                opponent_coops = sum(opponent_actions_last)
                total_coops = opponent_coops + (1 if my_last_action else 0)
                cooperation_threshold = 0.7 * self.n_players
                if total_coops >= cooperation_threshold:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_2(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness Strategy for the Common Pool Resource Game.
    
    This strategy promotes cooperation to sustain the common pool resource while adaptively
    responding to defections. It cooperates initially, prioritizes stock recovery when
    stock is low, punishes widespread defection, and forgives gradual cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.punish_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        half_capacity = self.capacity / 2
        if current_stock < half_capacity:
            self.punish_count = max(0, self.punish_count - 1)
            return Action.C
        else:
            last_opponent_actions = history.opponent_actions[-1, :]
            d_last = len(last_opponent_actions) - np.sum(last_opponent_actions)
            if d_last > self.n_players / 2:
                self.punish_count += 1
                return Action.D
            else:
                if d_last == 0 and self.punish_count > 0:
                    self.punish_count = max(0, self.punish_count - 1)
                return Action.C

class Strategy_COLLECTIVE_4(BaseStrategy):
    """
    A strategy that cooperates if the stock is above 75% of capacity, 
    otherwise defects to secure higher personal payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        threshold = 0.75 * self.capacity
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_5(BaseStrategy):
    """
    A strategy that starts with cooperation, adapts based on stock level and previous cooperation,
    and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        stock = state.current_stock
        stock_threshold = 0.7 * self.capacity
        stock_condition = stock > stock_threshold
        prev_my_action = history.my_actions[-1]
        prev_opponent_actions = history.opponent_actions[-1, :]
        num_coop_prev = prev_my_action + np.sum(prev_opponent_actions)
        cooperation_condition = num_coop_prev > self.n_players / 2
        if stock_condition and cooperation_condition:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_6(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection.
    Cooperates initially, defects if stock is low, more than half defected previously, or in the last three rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 3:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        your_prev_action = history.my_actions[-1]
        prev_defectors = 1 - your_prev_action
        prev_defectors += sum(1 - history.opponent_actions[-1, :])
        n_players = self.game_description.n_players
        if prev_defectors > n_players / 2:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_7(BaseStrategy):
    """
    Adaptive Cooperation with Punishment and Recovery strategy.
    Cooperates initially, defects in the last round, and adapts based on stock levels and cooperation rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == self.n_rounds - 1:
            return Action.D
        else:
            if history is None:
                return Action.C
            t_prev = current_round - 1
            my_action = history.my_actions[t_prev]
            my_payoff = history.my_payoffs[t_prev]
            if my_action:
                S_prev = my_payoff * 2 * self.n_players
            else:
                S_prev = my_payoff * self.n_players
            opponent_actions = history.opponent_actions[t_prev]
            cooperators = (1 if my_action else 0) + sum(opponent_actions)
            consumption = cooperators * (S_prev / (2 * self.n_players)) + (self.n_players - cooperators) * (S_prev / self.n_players)
            S_remaining = S_prev - consumption
            if S_remaining < 0.5 * self.capacity:
                return Action.C
            else:
                cooperation_rate = cooperators / self.n_players
                if cooperation_rate >= 0.75:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_8(BaseStrategy):
    """
    Adaptive strategy for the Common Pool Resource Game, balancing cooperation and defection
    based on stock levels, trends, and opponent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        current_stock = state.current_stock
        if state.round_number == 0:
            return Action.C
        threshold_1 = 0.75 * self.capacity
        threshold_2 = 0.5 * self.capacity
        if len(self.stock_history) < 2:
            prev_stock = self.stock_history[-1]
        else:
            prev_stock = self.stock_history[-2]
        delta = current_stock - prev_stock
        if delta > 1e-09:
            trend = 'increasing'
        elif delta < -1e-09:
            trend = 'decreasing'
        else:
            trend = 'stable'
        if current_stock > threshold_1:
            action = Action.C
        elif current_stock >= threshold_2:
            if trend in ['stable', 'increasing']:
                action = Action.C
            elif history and history.opponent_actions.any():
                last_opponent_actions = history.opponent_actions[-1, :]
                num_defectors = len(last_opponent_actions) - np.sum(last_opponent_actions)
                if num_defectors > self.n_players / 2:
                    action = Action.D
                else:
                    action = Action.C
            else:
                action = Action.C
        else:
            action = Action.D
        if state.round_number >= 0.9 * self.n_rounds:
            action = Action.D
        return action

class Strategy_COLLECTIVE_9(BaseStrategy):
    """
    A strategy designed to maintain cooperation in a Common Pool Resource Game.
    It cooperates initially, defects as punishment if total consumption exceeds
    half the stock, and checks for recovery to resume cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_defected = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_defected = False
            return Action.C
        my_payoff_prev = history.my_payoffs[-1]
        if history.my_actions[-1] == Action.C:
            s_prev = my_payoff_prev * (2 * self.game_description.n_players)
        else:
            s_prev = my_payoff_prev * self.game_description.n_players
        my_action_prev = history.my_actions[-1]
        opponent_actions_prev = history.opponent_actions[-1]
        total_consumption = 0.0
        if my_action_prev == Action.C:
            total_consumption += s_prev / (2 * self.game_description.n_players)
        else:
            total_consumption += s_prev / self.game_description.n_players
        for action in opponent_actions_prev:
            if action == Action.C:
                total_consumption += s_prev / (2 * self.game_description.n_players)
            else:
                total_consumption += s_prev / self.game_description.n_players
        threshold = s_prev / 2
        if total_consumption > threshold:
            action = Action.D
            self.last_defected = True
        elif self.last_defected:
            if state.current_stock > 0.5 * self.game_description.capacity:
                action = Action.C
                self.last_defected = False
            else:
                action = Action.D
        else:
            action = Action.C
            self.last_defected = False
        return action

class Strategy_COLLECTIVE_11(BaseStrategy):
    """
    A dynamic strategy for the Common Pool Resource Game that starts with cooperation
    and dynamically adjusts based on observed stock levels. It defects when the stock
    decreases and reverts to cooperation if the stock shows signs of recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_stock = game_description.capacity
        self.prev_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.prev_action = Action.C
            return Action.C
        else:
            new_stock = state.current_stock
            if self.prev_action == Action.C:
                if new_stock < self.current_stock:
                    action = Action.D
                else:
                    action = Action.C
            elif new_stock >= self.current_stock:
                action = Action.C
            else:
                action = Action.D
            self.current_stock = new_stock
            self.prev_action = action
            return action

class Strategy_COLLECTIVE_12(BaseStrategy):
    """
    Collective Strategy for Common Pool Resource Game.
    Implements adaptive cooperation based on stock levels and opponent behavior,
    with adjustments in final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.threshold = 1.5 * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round_1based = state.round_number + 1
        in_last_10 = current_round_1based >= 0.9 * self.n_rounds
        if in_last_10:
            if state.round_number == self.n_rounds - 1:
                return Action.D
            elif state.current_stock < self.threshold:
                return Action.C
            else:
                return Action.D
        elif state.current_stock < self.threshold:
            return Action.C
        else:
            my_last_action = history.my_actions[-1]
            opponent_actions_last = history.opponent_actions[-1]
            sum_opponents_c = sum(opponent_actions_last)
            sum_coop = sum_opponents_c + (1 if my_last_action else 0)
            if sum_coop > self.n_players / 2:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_13(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels and opponent actions.
    Cooperates initially to establish trust, defects when stock levels are low or opponents defect, and shifts to defection in late rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
        elif state.round_number >= self.r - 2:
            action = Action.D
        elif state.current_stock < 0.3 * self.capacity:
            action = Action.D
        else:
            if history is None:
                prev_defectors = 0
            else:
                prev_opponent_actions = history.opponent_actions[-1, :] if history.opponent_actions.size > 0 else []
                num_cooperators = np.sum(prev_opponent_actions)
                prev_defectors = self.n - num_cooperators
            if prev_defectors > self.n / 2:
                action = Action.D
            elif state.current_stock < 0.5 * self.capacity:
                action = Action.D
            elif state.current_stock > 0.7 * self.capacity:
                action = Action.C
            elif len(self.stock_history) >= 1:
                prev_stock = self.stock_history[-1]
                if state.current_stock > prev_stock:
                    action = Action.C
                else:
                    action = Action.D
            else:
                action = Action.C
        self.stock_history.append(state.current_stock)
        return action

class Strategy_COLLECTIVE_14(BaseStrategy):
    """
    Adaptive Reciprocity strategy for the Common Pool Resource game. 
    Cooperates initially, punishes if stock or cooperation drops below thresholds, 
    and forgives if subsequent cooperation improves.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_prev = 0
        self.stock_prev = 0.0
        self.punishing = False
        self.prev_coop_for_punishment = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        if round_number == total_rounds - 1:
            my_actions = history.my_actions
            opponent_actions = history.opponent_actions
            total_coops = np.sum(my_actions) + np.sum(opponent_actions)
            overall_coop_rate = total_coops / (n * total_rounds)
            return Action.C if overall_coop_rate >= 0.5 else Action.D
        prev_round = round_number - 1
        prev_my_action = history.my_actions[prev_round]
        prev_opponent_actions = history.opponent_actions[prev_round]
        cooperation_prev = 1 if prev_my_action else 0
        cooperation_prev += np.sum(prev_opponent_actions)
        stock_current = state.current_stock
        if self.punishing:
            if cooperation_prev > self.prev_coop_for_punishment:
                self.punishing = False
                self.prev_coop_for_punishment = 0
                return Action.C
            else:
                condition1 = cooperation_prev >= math.ceil(n / 2)
                condition2 = stock_current > 0.75 * capacity
                if condition1 and condition2:
                    self.punishing = False
                    return Action.C
                else:
                    self.cooperation_prev = cooperation_prev
                    self.stock_prev = stock_current
                    return Action.D
        else:
            condition1 = cooperation_prev >= math.ceil(n / 2)
            condition2 = stock_current > 0.75 * capacity
            if condition1 and condition2:
                return Action.C
            else:
                self.punishing = True
                self.prev_coop_for_punishment = cooperation_prev
                return Action.D

class Strategy_COLLECTIVE_15(BaseStrategy):
    """
    A strategy that adapts cooperation based on stock levels and number of defectors.
    Cooperates initially, then uses stock and defection thresholds to decide actions.
    Defects in the last round to maximize final payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.T = 0.75 * self.capacity
        self.H = math.ceil(self.n_players / 2)

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_stock = state.current_stock
        t_prev = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[t_prev]
        defector_count = self.n_players - 1 - np.sum(opponent_actions_prev)
        if prev_stock > self.T and defector_count < self.H:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_16(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.threshold = 0.5 * self.capacity
        self.punishing = False
        self.punishment_remaining = 0
        self.last_punishment_stock = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            if state.current_stock < 0.1 * self.capacity:
                return Action.D
            else:
                return Action.C
        else:
            current_stock = state.current_stock
            if not self.punishing:
                if current_stock < self.threshold:
                    self.punishing = True
                    self.punishment_remaining = 2
                    self.last_punishment_stock = current_stock
                    return Action.D
                else:
                    return Action.C
            elif self.punishment_remaining > 0:
                self.punishment_remaining -= 1
                return Action.D
            elif current_stock > self.last_punishment_stock:
                self.punishing = False
                return Action.C
            elif current_stock < self.threshold:
                self.punishing = True
                self.punishment_remaining = 2
                self.last_punishment_stock = current_stock
                return Action.D
            else:
                self.punishing = False
                return Action.C

class Strategy_COLLECTIVE_17(BaseStrategy):
    """
    Adaptive Threshold Cooperation Strategy (ATC) for Common Pool Resource Game.
    Cooperates when stock is above 50% of capacity, defects otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        threshold = 0.5 * self.capacity
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_3(BaseStrategy):
    """
    Adaptive strategy for the Common Pool Resource Game: Cooperate initially, 
    defect if previous round's consumption was unsustainable, and defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            last_round = state.round_number - 1
            my_prev_action = history.my_actions[last_round]
            my_prev_payoff = history.my_payoffs[last_round]
            n = self.game_description.n_players
            if my_prev_action:
                s_prev = my_prev_payoff * (2 * n)
            else:
                s_prev = my_prev_payoff * n
            opponent_prev_actions = history.opponent_actions[last_round, :]
            defectors_prev = 0
            if not my_prev_action:
                defectors_prev += 1
            defectors_prev += np.count_nonzero(~opponent_prev_actions)
            total_c = defectors_prev * (s_prev / n) + (n - defectors_prev) * (s_prev / (2 * n))
            if total_c > s_prev / 2:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_18(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that combines initial cooperation,
    stock monitoring, threshold-based responses to defection, and late game adaptation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number > 0.9 * self.n_rounds:
            return Action.C
        current_stock = state.current_stock
        if current_stock < 0.5 * self.capacity:
            return Action.C
        last_round = state.round_number - 1
        my_action = history.my_actions[last_round]
        my_defect = 0 if my_action else 1
        opponent_actions_last = history.opponent_actions[last_round, :]
        opponent_defects = np.sum(~opponent_actions_last)
        total_defectors = my_defect + opponent_defects
        percent_defectors = total_defectors / self.n_players * 100
        if percent_defectors > 20:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_19(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that promotes sustainability by 
    cooperating initially, defecting when the stock is low, and reverting to 
    cooperation if the stock recovers. It defects in the last round if the stock 
    is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defect_streak = 0
        self.was_below_threshold = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        if current_round == n_rounds - 1:
            threshold_last = 0.5 * capacity
            if current_stock < threshold_last:
                return Action.D
            else:
                return Action.C
        if current_round == 0:
            return Action.C
        threshold = 0.9 * capacity
        if current_stock >= threshold:
            self.defect_streak = 0
            self.was_below_threshold = False
            return Action.C
        else:
            if self.was_below_threshold:
                self.defect_streak += 1
            else:
                self.defect_streak = 1
                self.was_below_threshold = True
            if self.defect_streak <= 2:
                return Action.D
            elif current_stock >= threshold:
                self.defect_streak = 0
                self.was_below_threshold = False
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_20(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection
    based on the current stock level relative to the capacity. Cooperates initially and when
    the stock is sufficiently high, defects when stock is low or in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            threshold = 0.75 * self.game_description.capacity
            return Action.C if state.current_stock >= threshold else Action.D

class Strategy_COLLECTIVE_21(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and 
    defection based on stock levels, cooperation rates, and remaining rounds. It 
    uses dynamic thresholds to adapt to game progression.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.2 * self.game_description.capacity:
            return Action.C
        prev_rounds = state.round_number
        my_coop = np.sum(history.my_actions[:prev_rounds])
        opponent_coop = np.sum(history.opponent_actions[:prev_rounds, :])
        total_coop = my_coop + opponent_coop
        possible_actions = self.game_description.n_players * prev_rounds
        if possible_actions == 0:
            cooperation_rate = 0.0
        else:
            cooperation_rate = total_coop / possible_actions
        remaining_rounds = self.game_description.n_rounds - state.round_number - 1
        denominator = self.game_description.n_rounds - 2
        if denominator == 0:
            threshold = 0.5
        else:
            threshold = 0.5 * (remaining_rounds / denominator)
        if cooperation_rate >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_22(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels and previous defection rates.
    Cooperates in the first round, continues if stock is above 75% of capacity, and retaliates if previous defection exceeds 30%.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        stock_pct = current_stock / capacity
        if stock_pct > 0.75:
            return Action.C
        previous_round = state.round_number - 1
        my_last_action = history.my_actions[previous_round]
        my_defect = not my_last_action
        opponent_actions_last = history.opponent_actions[previous_round]
        opponent_defectors = np.sum(~opponent_actions_last)
        total_defectors = int(my_defect) + opponent_defectors
        percent_defectors = total_defectors / self.game_description.n_players
        if percent_defectors < 0.3:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_23(BaseStrategy):
    """
    Cooperate in the first round. For subsequent rounds, cooperate if the previous round's stock was above 75% of the capacity; otherwise, defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        threshold = 0.75 * capacity
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_24(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that combines cooperation, reciprocal behavior,
    and stock conservation to maintain sustainable resource usage.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        if state.current_stock < capacity / 2:
            return Action.C
        opponent_actions_last_round = history.opponent_actions[-1]
        sum_opponent_c = np.sum(opponent_actions_last_round)
        m = self.game_description.n_players - 1
        majority_threshold = (m + 1) // 2
        if sum_opponent_c >= majority_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_25(BaseStrategy):
    """
    Adaptive Cooperation with Punishment strategy for the Common Pool Resource Game.
    Cooperates initially, retaliates against excessive defection, defects when the stock is critically low,
    and maximizes final payoffs in the last round if sustainable.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round_actions = history.opponent_actions[-1, :]
        defector_count = sum((1 - action for action in last_round_actions))
        proportion_defectors = defector_count / self.n
        sustainability_threshold = 0.25 * self.capacity
        if state.round_number == self.r - 1:
            if state.current_stock > sustainability_threshold:
                return Action.D
            elif proportion_defectors > 0.5 or state.current_stock < sustainability_threshold:
                return Action.D
            else:
                return Action.C
        elif proportion_defectors > 0.5 or state.current_stock < sustainability_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_26(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) strategy for the Common Pool Resource Game.
    This strategy aims to balance cooperation and punishment to maintain resource sustainability
    while maximizing individual payoffs. It dynamically adjusts based on observed behavior
    and resource levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C
        if state.round_number == n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        my_actions = history.my_actions
        my_last_action = my_actions[state.round_number - 1]
        my_defected = not my_last_action
        last_round_defectors = 1 if my_defected else 0
        opponent_last_actions = history.opponent_actions[state.round_number - 1]
        opp_defectors = np.count_nonzero(~opponent_last_actions)
        last_round_defectors += opp_defectors
        cooperation_threshold = n_players * 0.5
        if last_round_defectors > cooperation_threshold:
            return Action.D
        stock_threshold = 0.5 * capacity
        if current_stock < stock_threshold:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_27(BaseStrategy):
    """
    A collective strategy for managing a Common Pool Resource Game.
    It promotes cooperation when possible and punishes defectors to maintain resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        n = self.n_players
        capacity = self.capacity
        current_stock = state.current_stock
        prev_round_idx = state.round_number - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opp_prev_actions = history.opponent_actions[prev_round_idx]
        me_d = 0 if my_prev_action else 1
        sum_opp_c = np.sum(opp_prev_actions)
        opp_d = n - 1 - sum_opp_c
        d_count = me_d + opp_d
        if current_stock > 0.75 * capacity:
            if d_count <= 0.2 * n:
                return Action.C
            else:
                self.punishment_remaining = 1
                return Action.D
        elif 0.5 * capacity <= current_stock <= 0.75 * capacity or current_stock < 0.25 * capacity:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_28(BaseStrategy):
    """
    A strategy that begins with cooperation, then adapts based on stock levels,
    defecting if the stock drops below 90% of capacity and cooperating again
    if the stock recovers. In the last round, it defects if stock is above 80%.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            threshold = 0.8
        else:
            threshold = 0.9
        ratio = state.current_stock / self.capacity
        if ratio > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_29(BaseStrategy):
    """
    Adaptive Cooperation with Punishment strategy.
    Cooperate initially, defect in the final round, and adapt based on previous round's consumption.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        elif round_number == self.n_rounds - 1:
            return Action.D
        else:
            my_prev_action = history.my_actions[-1]
            my_prev_payoff = history.my_payoffs[-1]
            if my_prev_action:
                S_prev = 2.0 * self.n_players * my_prev_payoff
            else:
                S_prev = 1.0 * self.n_players * my_prev_payoff
            opponent_actions = history.opponent_actions[-1]
            count_C = 1 if my_prev_action else 0
            count_C += sum(opponent_actions)
            total_consumption = count_C * (S_prev / (2.0 * self.n_players)) + (self.n_players - count_C) * (S_prev / self.n_players)
            expected_full_coop = S_prev / 2.0
            min_stock = self.capacity / 2.0
            current_stock = state.current_stock
            if total_consumption > expected_full_coop and current_stock >= min_stock:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_30(BaseStrategy):
    """
    Adaptive Threshold Cooperation strategy for the Common Pool Resource Game.
    Cooperates initially, defects in the last two rounds, and otherwise cooperates
    if the stock is above half capacity, defects otherwise. Always defects if
    stock is zero.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock <= 0:
            return Action.D
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        threshold = self.game_description.capacity / 2.0
        if state.current_stock >= threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_31(BaseStrategy):
    """
    A strategy that cooperates when the stock is above half the capacity and defects otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock > self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_32(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection.
    Cooperates in the first round and when the stock is healthy, and defects otherwise,
    especially in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            if current_stock <= 0.5 * capacity:
                return Action.D
            else:
                opponent_actions_last = history.opponent_actions[-1, :]
                n_players = self.game_description.n_players
                n_defectors = opponent_actions_last.size - np.sum(opponent_actions_last)
                if n_defectors < n_players / 2:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_33(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game. Cooperates initially and 
    continues if cooperation rate exceeds 60% and stock is above 50% of capacity.
    Defects otherwise, with special handling for the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if state.round_number == self.game_description.n_rounds - 1:
            if current_stock > 0.5 * self.capacity:
                return Action.C
            else:
                return Action.D
        t = state.round_number
        n = self.game_description.n_players
        sum_my = sum(history.my_actions[:t])
        sum_opponents = np.sum(history.opponent_actions[:t, :])
        total_coop = sum_my + sum_opponents
        average_coop = total_coop / (t * n)
        if average_coop > 0.6 and current_stock > 0.5 * self.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_34(BaseStrategy):
    """
    Adaptive Cooperation with Stock Thresholds (ACST).
    
    Players cooperate in the first round and when the stock is above 66% of the capacity.
    They defect when the stock drops below this threshold and in the final round.
    This strategy aims to balance resource exploitation and sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        threshold = 0.66 * self.game_description.capacity
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_35(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) Strategy:
    - Cooperate in the first round.
    - Defect in the last round.
    - In intermediate rounds, defect if previous round had majority defectors or stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        total_rounds = self.n_rounds
        current_stock = state.current_stock
        if round_num == 0:
            return Action.C
        if round_num == total_rounds - 1:
            return Action.D
        prev_round = round_num - 1
        my_prev_action = history.my_actions[prev_round]
        my_defected = not my_prev_action
        opp_actions = history.opponent_actions[prev_round]
        opp_defections = np.count_nonzero(~opp_actions)
        total_defectors = opp_defections + (1 if my_defected else 0)
        stock_threshold = 0.25 * self.capacity
        if total_defectors > self.n_players / 2 or current_stock <= stock_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_36(BaseStrategy):
    """
    This strategy cooperates when the stock is above 50% of capacity, defects otherwise.
    Helps maintain a sustainable balance by encouraging cooperation when resources are plentiful.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        threshold = 0.5 * self.capacity
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_37(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation 
    and strategic defection to maintain sustainable stock levels and maximize long-term payoffs.
    The strategy cooperates when the stock is above 75% of capacity, defects otherwise, 
    retaliates if a significant number of players defected recently, and defects in the last two rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        if state.round_number >= total_rounds - 2:
            return Action.D
        if history is not None:
            previous_round = state.round_number - 1
            if 0 <= previous_round < len(history.my_actions):
                my_prev_action = history.my_actions[previous_round]
                opp_prev_actions = history.opponent_actions[previous_round, :]
                n_defectors = 0
                if not my_prev_action:
                    n_defectors += 1
                n_defectors += np.sum(~opp_prev_actions)
                proportion_defectors = n_defectors / n_players
                if proportion_defectors > 0.25:
                    return Action.D
        current_stock = state.current_stock
        stock_fraction = current_stock / capacity
        if stock_fraction > 0.75:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_38(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that balances cooperation and defection to maintain resource sustainability.
    Cooperates when the stock is healthy, defects when necessary, and punishes recent defections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if state.round_number == n_rounds - 1:
            return Action.D
        prev_my_action = history.my_actions[-1]
        prev_my_defected = not prev_my_action
        opponent_actions = history.opponent_actions[-1, :]
        num_opponent_defectors = len(opponent_actions) - np.sum(opponent_actions)
        total_defectors = prev_my_defected + num_opponent_defectors
        if total_defectors > n_players / 2:
            return Action.D
        else:
            stock_ratio = state.current_stock / capacity
            if stock_ratio > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_39(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and punishment
    while maintaining sustainable stock levels. The strategy includes:
    - Initial cooperation in the first round
    - Reciprocal punishment based on previous round's cooperation levels
    - Stock-level consideration to prevent depletion
    - Forgiveness mechanism for sustained cooperation
    - Endgame strategy to avoid depletion in the final rounds
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            n_players = self.game_description.n_players
            n_rounds = self.game_description.n_rounds
            endgame_threshold = math.ceil(n_rounds * 0.1)
            is_endgame = state.round_number >= n_rounds - endgame_threshold
            if current_stock < 0.5 * capacity:
                decision = Action.C
            elif history is not None:
                last_round = state.round_number - 1
                opponent_actions = history.opponent_actions[last_round]
                opponent_coop_count = np.sum(opponent_actions)
                if opponent_coop_count >= n_players // 2:
                    decision = Action.C
                elif last_round >= 2:
                    forgive = False
                    for op in range(n_players - 1):
                        all_c = True
                        for i in range(3):
                            r = last_round - 2 + i
                            if r < 0 or not history.opponent_actions[r, op]:
                                all_c = False
                                break
                        if all_c:
                            forgive = True
                            break
                    decision = Action.C if forgive else Action.D
                else:
                    decision = Action.D
            else:
                decision = Action.D
            if is_endgame and decision == Action.D:
                if random.random() < 0.2:
                    decision = Action.C
            return decision

class Strategy_COLLECTIVE_10(BaseStrategy):
    """
    Adaptive Reciprocity with Stock Sustainability (ARSS) strategy.
    Balances individual payoffs with collective sustainability by adaptively
    responding to stock level and opponents' behavior, promoting cooperation
    while safeguarding against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if current_stock < 0.2 * self.capacity:
            return Action.C
        remaining_rounds = self.n_rounds - state.round_number
        if remaining_rounds <= 2:
            return Action.C
        prev_round = state.round_number - 1
        prev_actions = history.opponent_actions[prev_round]
        num_coop_prev = sum(prev_actions)
        cooperation_rate = num_coop_prev / self.n_players
        if cooperation_rate >= 0.8:
            return Action.C
        elif cooperation_rate < 0.5:
            return Action.D
        elif current_stock < 0.25 * self.capacity:
            return Action.C
        elif 0.25 * self.capacity <= current_stock <= 0.75 * self.capacity:
            if any((not x for x in prev_actions)):
                p_defect = 1.0 - 0.05 * remaining_rounds
                p_defect = max(0.0, min(1.0, p_defect))
                if random.random() < p_defect:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_40(BaseStrategy):
    """
    Adaptive Sustainability Cooperation Strategy.
    Cooperates initially, then adapts based on stock levels and number of defectors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.past_stocks = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        self.past_stocks.append(current_stock)
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        if current_stock < 0.3 * self.capacity:
            return Action.D
        my_last_action = history.my_actions[-1]
        opponent_last_actions = history.opponent_actions[-1]
        defectors = 0
        if not my_last_action:
            defectors += 1
        defectors += np.sum(~opponent_last_actions)
        condition1 = current_stock > 0.7 * self.capacity
        condition2 = defectors < self.n_players / 2
        if condition1 and condition2:
            return Action.C
        elif current_stock <= 0.5 * self.capacity or defectors >= self.n_players / 2:
            return Action.D
        elif len(self.past_stocks) >= 2:
            previous_stock = self.past_stocks[-2]
            current = self.past_stocks[-1]
            if current >= previous_stock:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_41(BaseStrategy):
    """
    Cooperate when the stock is sustainable, otherwise defect to maximize gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.current_stock < self.capacity / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_42(BaseStrategy):
    """
    Adaptive Threshold Cooperation strategy for the Common Pool Resource Game.
    The strategy decides to Cooperate if the current stock is above a dynamic threshold,
    which is (remaining_rounds / total_rounds) * capacity.
    In the first round, it always Cooperates, and in the last round, it always Defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == self.game_description.n_rounds - 1:
            return Action.D
        else:
            remaining_rounds = self.game_description.n_rounds - current_round
            threshold = remaining_rounds / self.game_description.n_rounds * self.game_description.capacity
            if state.current_stock >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_43(BaseStrategy):
    """
    Adaptive Reciprocity with Stock Conservation Strategy:
    Cooperates initially, retaliates if too many defected previously, 
    and conserves stock by defecting when stock is low, while cooperating 
    in the last round if stock is sufficient.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        capacity = self.game_description.capacity
        if round_number == 0:
            return Action.C
        if round_number == self.game_description.n_rounds - 1:
            if state.current_stock > 0.5 * capacity:
                return Action.C
            else:
                return Action.D
        else:
            prev_round = round_number - 1
            my_prev_action = history.my_actions[prev_round]
            my_defection = 0 if my_prev_action else 1
            opponent_actions_prev = history.opponent_actions[prev_round]
            opponent_defections = len(opponent_actions_prev) - sum(opponent_actions_prev)
            total_defectors = my_defection + opponent_defections
            threshold_defections = self.game_description.n_players / 2
            stock_threshold = 0.5 * capacity
            if total_defectors > threshold_defections or state.current_stock < stock_threshold:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_44(BaseStrategy):
    """
    Adaptive Cooperation Strategy for the Common Pool Resource Game.
    This strategy balances cooperation and defection based on observed behavior
    and stock dynamics to maximize individual payoffs while maintaining a sustainable common pool.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_rounds = self.n_rounds
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == total_rounds - 1:
            critical_level = self.capacity / 4
            if current_stock > critical_level:
                return Action.D
            else:
                return Action.C
        else:
            critical_level = self.capacity / 4
            if current_stock < critical_level:
                return Action.C
            else:
                my_prev_action = history.my_actions[-1]
                my_defected = 1 if my_prev_action == 0 else 0
                opponent_prev_actions = history.opponent_actions[-1]
                opponent_defectors = np.count_nonzero(opponent_prev_actions == 0)
                total_defectors = my_defected + opponent_defectors
                defector_threshold = self.n_players // 2
                stock_threshold = self.capacity / 2
                if total_defectors <= defector_threshold and current_stock > stock_threshold:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_45(BaseStrategy):
    """
    Adaptive strategy for the Common Pool Resource Game based on stock level monitoring.
    Cooperates initially, defects if stock drops below half capacity or shows a decreasing trend,
    and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        capacity = self.capacity
        n_rounds = self.n_rounds
        if current_round == 0:
            action = Action.C
        elif current_round == n_rounds - 1:
            action = Action.D
        elif current_stock < capacity / 2:
            action = Action.D
        elif self.previous_stock is not None and self.previous_stock > current_stock:
            action = Action.D
        else:
            action = Action.C
        self.previous_stock = current_stock
        return action

class Strategy_COLLECTIVE_47(BaseStrategy):
    """
    A strategy that initially cooperates, punishes when defections exceed a threshold, 
    and forgives if the stock recovers. Defects in the last round to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.is_punishing = False
        self.last_stock_before_punish = 0.0
        self.last_stock = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_stock = state.current_stock
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            opponent_actions = history.opponent_actions[-1]
            opponent_defectors = len(opponent_actions) - sum(opponent_actions)
            my_last_action = history.my_actions[-1]
            my_defection = 0 if my_last_action else 1
            total_defectors = opponent_defectors + my_defection
            threshold = self.n_players // 2 + 1
            if total_defectors >= threshold and (not self.is_punishing):
                self.is_punishing = True
                self.last_stock_before_punish = state.current_stock
            if self.is_punishing:
                action = Action.D
                if state.current_stock > self.last_stock_before_punish:
                    self.is_punishing = False
            else:
                action = Action.C
            self.last_stock = state.current_stock
            return action

class Strategy_COLLECTIVE_48(BaseStrategy):
    """
    A strategy that always defects in the Common Pool Resource Game.
    This is the dominant strategy as it ensures the highest possible payoff regardless of others' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_COLLECTIVE_49(BaseStrategy):
    """
    This strategy addresses a repeated common pool resource game by balancing cooperation and defection to maximize long-term payoffs.
    It follows a hybrid approach of Tit-for-Tat and stock-level considerations.
    Players cooperate in the first round, defect in the last round, and adapt their actions in middle rounds based on opponents' previous actions and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        opponent_last_actions = history.opponent_actions[-1, :]
        n = self.game_description.n_players
        D_prev = n - opponent_last_actions.sum()
        capacity = self.game_description.capacity
        if D_prev > n / 2:
            return Action.D
        elif state.current_stock < 0.5 * capacity:
            return Action.C
        else:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_50(BaseStrategy):
    """
    Adaptive Threshold Cooperation Strategy.
    
    This strategy starts by cooperating in the first round to promote stock growth.
    In subsequent rounds, it cooperates if the stock is above 70% of capacity, otherwise defects.
    In the final round, it always defects to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        threshold = 0.7 * self.capacity
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_51(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) strategy.
    Cooperates initially, punishes defection, and adapts based on stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.initial_rounds = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        last_10_percent_start = int(0.9 * self.n_rounds)
        if state.round_number >= last_10_percent_start and state.round_number < self.n_rounds - 1:
            return Action.D
        if state.round_number < self.initial_rounds:
            return Action.C
        if history.opponent_actions.shape[0] > 0:
            last_opponents_actions = history.opponent_actions[-1]
            if np.sum(last_opponents_actions) == 0:
                return Action.D
        current_stock = state.current_stock
        if current_stock > 0.7 * self.capacity:
            return Action.C
        elif current_stock < 0.5 * self.capacity:
            return Action.D
        else:
            n_opponents = self.n_players - 1
            recent_window = 3
            available_rounds = history.opponent_actions.shape[0]
            start = max(0, available_rounds - recent_window)
            total_defections = 0
            for r in range(start, available_rounds):
                opp_actions = history.opponent_actions[r]
                defectors = n_opponents - np.sum(opp_actions)
                total_defections += defectors
            avg_defections = total_defections / (available_rounds - start) if available_rounds - start != 0 else 0
            if avg_defections > n_opponents / 2:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_52(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that promotes cooperation 
    and adaptability based on stock levels and previous actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            if state.current_stock > 0.5 * self.capacity:
                return Action.D
        current_stock = state.current_stock
        low_threshold = 0.3 * self.capacity
        high_threshold = 0.6 * self.capacity
        if current_stock < low_threshold:
            return Action.C
        elif current_stock > high_threshold:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_actions_prev = history.opponent_actions[prev_round]
            total_coop = sum(opponent_actions_prev) + (1 if my_prev_action else 0)
            percent_coop = total_coop / self.n_players
            if percent_coop >= 0.8:
                return Action.C
            elif percent_coop < 0.5:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_53(BaseStrategy):
    """
    Adaptive Cooperation with Stock Threshold strategy.
    Cooperates initially, defects when stock is below 50% of capacity except in last round.
    Cooperates in last round if stock is sufficient.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            threshold = 0.5 * self.capacity
            if state.current_stock >= threshold:
                return Action.C
            else:
                return Action.D
        else:
            threshold = 0.5 * self.capacity
            if state.current_stock < threshold:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_54(BaseStrategy):
    """
    A strategy balancing immediate gains and long-term sustainability through cooperation,
    reciprocity, and adaptive defecting based on stock trends and game progress.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.2 * self.game_description.capacity:
            return Action.C
        elif state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        prob_defect = state.round_number / self.game_description.n_rounds * 0.5
        previous_round = state.round_number - 1
        my_last_action = history.my_actions[previous_round]
        opponent_last_actions = history.opponent_actions[previous_round, :]
        total_coop = my_last_action + sum(opponent_last_actions)
        avg_coop = total_coop / self.game_description.n_players
        if avg_coop >= 0.5:
            return Action.C
        trend_decreasing = False
        if len(self.stock_history) >= 2:
            trend_decreasing = self.stock_history[-1] < self.stock_history[-2]
        if trend_decreasing:
            prob_defect += 0.2
        prob_defect = min(prob_defect, 1.0)
        rand = random.random()
        return Action.D if rand < prob_defect else Action.C

class Strategy_COLLECTIVE_55(BaseStrategy):
    """
    Sustainable Cooperation with Punishment Strategy:
    Cooperates initially, then based on stock levels, with punishment for significant stock drops.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_stock: float | None = None
        self.should_punish: bool = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
            self.last_stock = state.current_stock
            self.should_punish = False
            return action
        if self.should_punish:
            action = Action.D
            self.should_punish = False
        else:
            capacity = self.game_description.capacity
            prev_stock = self.last_stock
            if prev_stock > 0.75 * capacity:
                action = Action.C
            elif prev_stock >= 0.5 * capacity:
                action = Action.C if random.random() < 0.5 else Action.D
            else:
                action = Action.D
        capacity = self.game_description.capacity
        if self.last_stock is not None:
            drop = self.last_stock - state.current_stock
            if drop > 0.1 * capacity:
                self.should_punish = True
        self.last_stock = state.current_stock
        return action

class Strategy_COLLECTIVE_56(BaseStrategy):
    """
    Adaptive Collective Sustainability (ACS) strategy for the Common Pool Resource Game.
    Cooperates initially, then adapts based on stock levels and peer cooperation.
    Defects in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.T = 0.8 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round, :]
            total_cooperation = my_prev_action + opp_prev_actions.sum()
            cooperation_rate = total_cooperation / self.n_players
            if state.current_stock >= self.T and cooperation_rate >= 0.75:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_57(BaseStrategy):
    """
    A strategy to address the Tragedy of the Commons by promoting cooperation when the common pool resource is sustainably stocked
    and switching to defection when stock levels drop below sustainable thresholds. This strategy cooperates when the stock is high,
    conditions cooperation on previous round's cooperation when moderate, and defects when stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        stock_percent = current_stock / self.capacity * 100
        if stock_percent > 70:
            return Action.C
        elif 50 <= stock_percent <= 70:
            previous_round = state.round_number - 1
            my_prev = history.my_actions[previous_round]
            opp_prev = history.opponent_actions[previous_round, :]
            n_coop = my_prev + np.sum(opp_prev)
            half = self.n_players / 2
            if n_coop > half:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_58(BaseStrategy):
    """
    Adaptive Cooperation with Stock Threshold (ACST)
    Players cooperate initially and adapt based on stock level and previous defections.
    Inherits from BaseStrategy to handle Type and other game aspects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        current_stock = state.current_stock
        if current_stock < 0.5 * self.capacity:
            return Action.D
        my_last_action = history.my_actions[t_prev]
        opponents_last_actions = history.opponent_actions[t_prev]
        d = 0
        if not my_last_action:
            d += 1
        d += sum((not a for a in opponents_last_actions))
        if d > self.n_players // 2:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_59(BaseStrategy):
    """
    Adaptive Cooperative Conservation (ACC) Strategy.

    This strategy promotes cooperation while adapting to stock levels and opponent behavior.
    It initially cooperates, defects when the stock is low, punishes defectors, and cooperates in final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        in_final_rounds = n_rounds - state.round_number <= 5
        last_opponent_actions = history.opponent_actions[-1]
        opponent_defectors = np.sum(~last_opponent_actions)
        my_last_action = history.my_actions[-1]
        my_defector = 0 if my_last_action else 1
        last_round_defectors = opponent_defectors + my_defector
        fraction_defectors = last_round_defectors / n_players
        action = Action.C
        if in_final_rounds:
            if current_stock < 0.7 * capacity:
                action = Action.D
        elif self.punishment_remaining > 0:
            action = Action.D
            self.punishment_remaining -= 1
        elif fraction_defectors > 0.2:
            action = Action.D
            self.punishment_remaining = 2
        elif current_stock < 0.7 * capacity:
            action = Action.D
        return action

class Strategy_COLLECTIVE_60(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that promotes initial cooperation, 
    adapts to others' actions while considering stock sustainability, defects in the last round, 
    and punishes excessive defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.sustainability_threshold = 0.25 * self.capacity
        self.critical_threshold = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == self.n_rounds - 1:
            current_stock = state.current_stock
            if current_stock < self.critical_threshold:
                return Action.C
            else:
                return Action.D
        else:
            current_stock = state.current_stock
            if current_stock < self.sustainability_threshold:
                return Action.C
            else:
                prev_round = current_round - 1
                my_prev = history.my_actions[prev_round]
                opp_prev = history.opponent_actions[prev_round]
                all_prev_actions = np.append(my_prev, opp_prev)
                count_defect = np.sum(~all_prev_actions)
                if count_defect > self.n_players / 2:
                    return Action.D
                else:
                    return Action.C

class Strategy_COLLECTIVE_61(BaseStrategy):
    """
    A threshold-based strategy for the Common Pool Resource Game where players
    cooperate if the current stock exceeds half the capacity; otherwise, they defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        half_capacity = self.game_description.capacity / 2
        if state.current_stock > half_capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_62(BaseStrategy):
    """
    Cooperate in the first round and if the stock is above half capacity; otherwise, defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.threshold = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.current_stock >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_63(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on stock level and remaining rounds.
    Cooperates when the stock is low or many rounds remain, otherwise defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        if current_stock < 0.5 * capacity:
            return Action.C
        remaining_rounds = n_rounds - 1 - state.round_number
        if remaining_rounds > n_rounds / 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_65(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) strategy for the Common Pool Resource Game.
    Cooperates initially to maintain resource sustainability, then adapts based on stock level and defections.
    Defects in the final round to maximize personal payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            S_threshold = 0.5 * self.capacity
            T = self.n_players / 2
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            my_defect_prev = 0 if my_prev_action else 1
            opponent_actions = history.opponent_actions[prev_round, :]
            num_opponent_defectors = np.sum(~opponent_actions).item()
            D_prev = my_defect_prev + num_opponent_defectors
            if current_stock > S_threshold and D_prev <= T:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_66(BaseStrategy):
    """
    A trigger strategy for the Common Pool Resource Game to maintain cooperation and sustainability.
    Cooperates in the first round, then defects if the previous round's consumption was excessive.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.prev_stock_initial = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
            self.prev_stock_initial = state.current_stock
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev = history.opponent_actions[prev_round]
            num_C = 0
            if my_prev_action:
                num_C += 1
            num_C += sum(opponents_prev)
            S_prev_initial = self.prev_stock_initial
            consumption = num_C * (S_prev_initial / (2 * self.n)) + (self.n - num_C) * (S_prev_initial / self.n)
            S_prev_after = S_prev_initial - consumption
            if S_prev_after < S_prev_initial / 2:
                action = Action.D
            else:
                action = Action.C
            self.prev_stock_initial = state.current_stock
        self.prev_stock_initial = state.current_stock
        return action

class Strategy_COLLECTIVE_67(BaseStrategy):
    """
    An adaptive strategy that balances cooperation with strategic defection 
    to maintain resource sustainability while maximizing individual payoffs.
    Cooperates initially, punishes by defecting when stock falls below 75% of 
    capacity, and defects in the endgame to maximize personal gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defect_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number >= 0.8 * (self.game_description.n_rounds - 1):
            return Action.D
        elif self.defect_count > 0:
            self.defect_count -= 1
            return Action.D
        else:
            capacity = self.game_description.capacity
            threshold = 0.75 * capacity
            if state.current_stock < threshold:
                self.defect_count = 2
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_68(BaseStrategy):
    """
    Adaptive Threshold Cooperation (ATC) strategy. Players cooperate if the current stock is above half the capacity, 
    otherwise defect. Initially, all players cooperate in the first round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock > self.capacity / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_69(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that encourages cooperation 
    and adapts based on previous actions and stock levels to maintain sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > 0.5 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        elif state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        else:
            last_round_opp_actions = history.opponent_actions[-1, :]
            if np.any(last_round_opp_actions == False):
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_70(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that balances cooperation 
    and strategic defection based on stock levels and game progression.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with the game description.
        """
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action based on the current state and history.
        """
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            threshold = 0.75 * self.game_description.capacity
            if state.current_stock >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_71(BaseStrategy):
    """
    Adaptive cooperation strategy that punishes excessive defection.
    Cooperates initially, then defects if more than half of players defected
    in the previous round or if the stock falls below half the capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_action = history.my_actions[previous_round]
        my_defector = 0 if my_action else 1
        opponent_actions = history.opponent_actions[previous_round, :]
        num_opponent_defectors = opponent_actions.shape[0] - opponent_actions.sum()
        total_defectors = my_defector + num_opponent_defectors
        stock_threshold = self.capacity / 2
        previous_stock = state.current_stock
        if total_defectors > self.n_players / 2 or previous_stock < stock_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_72(BaseStrategy):
    """
    Adaptive Cooperation with Gradual Punishment strategy for the Common Pool Resource Game.
    Cooperates initially and under high stock conditions, defects when stock is low, with limited punishment phases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == n_rounds - 1:
            return Action.D
        if current_stock < 0.1 * capacity:
            return Action.D
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        if current_stock > 0.9 * capacity:
            return Action.C
        else:
            self.punishment_remaining = 3
            return Action.D

class Strategy_COLLECTIVE_73(BaseStrategy):
    """
    Collective Strategy for Common Pool Resource Game:
    - Cooperate in the first round, defect in the last.
    - Cooperate if stock is low, otherwise retaliate if average defection exceeds 25%.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            if current_stock < 0.5 * capacity:
                return Action.C
            else:
                total_defections = 0
                n_players = self.game_description.n_players
                max_round = state.round_number - 1
                start_round = max(0, max_round - 2)
                for rnd in range(start_round, max_round + 1):
                    if not history.my_actions[rnd]:
                        total_defections += 1
                    opponent_defections = np.count_nonzero(~history.opponent_actions[rnd])
                    total_defections += opponent_defections
                rounds_considered = max_round - start_round + 1
                avg_defection = total_defections / (3 * n_players) if n_players != 0 else 0
                if avg_defection > 0.25:
                    return Action.D
                else:
                    return Action.C

class Strategy_COLLECTIVE_74(BaseStrategy):
    """
    Adaptive Stock Preservation (ASP) strategy for the Common Pool Resource Game.
    Cooperates initially, defects when stock is threatened, and defects in the last round.
    Tracks if the stock has ever been depleted to zero before the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_was_zero = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if self.stock_was_zero and round_number != total_rounds - 1:
            return Action.D
        if current_stock <= 0:
            if round_number < total_rounds - 1:
                self.stock_was_zero = True
            return Action.D
        if round_number == total_rounds - 1:
            return Action.D
        threshold = capacity / 2
        if current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_75(BaseStrategy):
    """
    Adaptive Cooperation with Punishment Strategy.
    Cooperates initially, defects if stock is low or if many defected previously.
    Defects in the last round to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            half_capacity = self.capacity / 2.0
            if state.current_stock < half_capacity:
                return Action.D
            else:
                prev_round = state.round_number - 1
                my_prev_action = history.my_actions[prev_round]
                opponent_prev_actions = history.opponent_actions[prev_round, :]
                count_defectors = sum((1 for a in opponent_prev_actions if not a))
                if not my_prev_action:
                    count_defectors += 1
                if count_defectors > self.n_players / 2:
                    return Action.D
                else:
                    return Action.C

class Strategy_COLLECTIVE_76(BaseStrategy):
    """
    The Adaptive Cooperative Guardian strategy balances individual payoffs with collective sustainability.
    It initiates cooperation and adapts based on historical cooperation and stock conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        cap = self.game_description.capacity
        sum_coop = 0.0
        for t in range(state.round_number):
            my_coop = history.my_actions[t]
            my_count = 1 if my_coop else 0
            opponent_coops = sum(history.opponent_actions[t, :])
            rate = (my_count + opponent_coops) / n
            sum_coop += rate
        avg_coop = sum_coop / state.round_number
        stock_ratio = state.current_stock / cap
        if avg_coop >= 0.7 and stock_ratio >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_77(BaseStrategy):
    """
    Adaptive Cooperation with Stock Threshold and Defection Response strategy.
    Cooperates initially, defects in the final round, and adapts based on stock level and previous defections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        else:
            t = state.round_number
            if t == self.r - 1:
                return Action.D
            else:
                S_prev = state.current_stock
                threshold_stock = 0.5 * self.capacity
                prev_t = t - 1
                my_prev_action = history.my_actions[prev_t]
                opponent_prev_actions = history.opponent_actions[prev_t, :]
                my_defect = 0 if my_prev_action else 1
                opponent_defect = np.count_nonzero(~opponent_prev_actions)
                total_defectors = my_defect + opponent_defect
                proportion_defectors = total_defectors / self.n_players
                if S_prev > threshold_stock and proportion_defectors < 0.5:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_78(BaseStrategy):
    """
    Adaptive Cooperation with Stock Threshold Strategy.
    
    This strategy starts by cooperating in the first round. In subsequent rounds,
    it chooses to cooperate if the stock is above 75% of capacity. When the stock
    is between 50% and 75%, it uses a mixed strategy where the probability of
    cooperation decreases linearly from 100% to 50%. Below 50%, it defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        threshold_75 = 0.75 * self.capacity
        threshold_50 = 0.5 * self.capacity
        if current_stock > threshold_75:
            return Action.C
        elif current_stock >= threshold_50:
            s = current_stock / self.capacity
            probability = 0.5 + 2 * (s - 0.5)
            probability = max(0.0, min(probability, 1.0))
            if random.random() < probability:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_79(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that dynamically switches between cooperation and defection based on stock levels and opponents' previous actions.
    Cooperates in initial rounds, defects in final rounds, and adapts based on stock and previous behavior in between.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number <= 1:
            return Action.C
        elif round_number >= self.n_rounds - 2:
            return Action.D
        else:
            if self.capacity == 0:
                stock_pct = 0.0
            else:
                stock_pct = state.current_stock / self.capacity
            prev_opp_actions = history.opponent_actions[-1]
            n_defectors_prev = np.sum(1 - prev_opp_actions)
            if stock_pct > 0.75:
                if n_defectors_prev < self.n_players / 2:
                    return Action.C
                else:
                    return Action.D
            elif 0.5 <= stock_pct <= 0.75:
                if self.n_players - n_defectors_prev > self.n_players / 2:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_COLLECTIVE_80(BaseStrategy):
    """
    Adaptive Cooperation Strategy based on stock levels. Cooperates when the stock is sufficient, defects otherwise.
    Tends to revert to cooperation if the stock recovers after defecting. Defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_action = Action.C
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            self.last_action = Action.D
            return Action.D
        else:
            threshold = 0.5 * self.game_description.capacity
            current_stock = state.current_stock
            if current_stock > threshold:
                self.last_action = Action.C
                return Action.C
            else:
                self.last_action = Action.D
                return Action.D

class Strategy_COLLECTIVE_81(BaseStrategy):
    """
    Adaptive Threshold Cooperation Strategy:
    - Cooperate in the first round.
    - In subsequent rounds, calculate a threshold that decreases linearly from 50% to 20% of capacity.
    - Cooperate if current stock exceeds the threshold, otherwise defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        start_threshold = 0.5
        end_threshold = 0.2
        if total_rounds - 1 == 0:
            decay_rate = 0.0
        else:
            decay_rate = (start_threshold - end_threshold) / (total_rounds - 1)
        threshold = start_threshold - decay_rate * current_round
        threshold = max(threshold, end_threshold)
        capacity = self.game_description.capacity
        stock = state.current_stock
        if stock > threshold * capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_82(BaseStrategy):
    """
    Adaptive Collective Strategy for the Common Pool Resource Game.

    This strategy initially cooperates to build trust, monitors stock levels to prevent depletion,
    responds reciprocally to others' actions, defects in endgame rounds, and adaptively reconciles
    if the stock recovers.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.initial_phase_length = int(0.25 * self.n_rounds)
        self.endgame_start_round = int(0.9 * self.n_rounds)
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        self.stock_history.append(state.current_stock)
        if state.round_number < self.initial_phase_length:
            return Action.C
        if state.round_number >= self.endgame_start_round:
            return Action.D
        if state.current_stock < 0.5 * self.capacity:
            return Action.D
        action = None
        if history is not None and len(history.my_payoffs) >= 1:
            recent_rounds = len(history.my_payoffs)
            start = max(0, recent_rounds - 3)
            total_consumptions = []
            for t in range(start, recent_rounds):
                my_payoff = history.my_payoffs[t]
                opponent_payoffs = history.opponent_payoffs[t]
                total = my_payoff + sum(opponent_payoffs)
                total_consumptions.append(total)
            if total_consumptions:
                avg_total = sum(total_consumptions) / len(total_consumptions)
                if avg_total > 0.75 * self.capacity:
                    action = Action.D
        if action is None:
            if len(self.stock_history) >= 3:
                change_prev = self.stock_history[-2] > self.stock_history[-3]
                change_current = self.stock_history[-1] > self.stock_history[-2]
                if change_prev and change_current:
                    action = Action.C
        return Action.C if action is None else action

class Strategy_COLLECTIVE_83(BaseStrategy):
    """
    Adaptive Cooperation with Stock Conservation Strategy.
    
    - Cooperate in the first round.
    - In subsequent rounds, cooperate if the stock is below half the capacity.
    - If the stock is healthy, defect if more than half of the players defected in the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if current_stock < 0.5 * self.capacity:
            return Action.C
        else:
            my_last_action = history.my_actions[-1]
            player_defected = not my_last_action
            opponent_actions_last = history.opponent_actions[-1, :]
            opponent_defectors = (opponent_actions_last == False).sum()
            total_defectors = int(player_defected) + opponent_defectors
            threshold = self.n_players / 2
            if total_defectors > threshold:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_84(BaseStrategy):
    """
    Grim Trigger Strategy: Cooperate until any opponent defects, then defect permanently.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.triggered = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.triggered:
            return Action.D
        any_defection = False
        for round_num in range(history.my_actions.size):
            opponent_actions_round = history.opponent_actions[round_num]
            if (opponent_actions_round == False).any():
                any_defection = True
                break
        if any_defection:
            self.triggered = True
        return Action.D if any_defection else Action.C

class Strategy_COLLECTIVE_85(BaseStrategy):
    """
    Adaptive Threshold-based Cooperation strategy.
    Players cooperate when the stock is above 75% of capacity, defect otherwise.
    Cooperate in the first round and defect in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            threshold = 0.75 * self.capacity
            if state.current_stock >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_86(BaseStrategy):
    """
    Adaptive Threshold Cooperation strategy for the Common Pool Resource game.
    Cooperates when stock is above half capacity, except in the last round.
    First round always Cooperates, last round always Defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            threshold = self.capacity / 2.0
            if state.current_stock > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_87(BaseStrategy):
    """
    Adaptive Sustainability with Punishment (ASP) strategy for Common Pool Resource Game.
    Cooperates when the stock is high enough to ensure sustainability, defects otherwise.
    Adjusts behavior in the last round and when stock is very low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        is_last_round = state.round_number == self.game_description.n_rounds - 1
        capacity = self.game_description.capacity
        if is_last_round:
            if state.current_stock >= 0.9 * capacity:
                return Action.C
            else:
                return Action.D
        elif state.current_stock <= 0.25 * capacity:
            return Action.C
        elif state.current_stock > 0.75 * capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_88(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances reciprocal cooperation with 
    conservation, adapting to others' actions while ensuring resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.C
        if state.current_stock < self.capacity / 2:
            return Action.C
        previous_round = state.round_number - 1
        if history is None:
            return Action.C
        my_prev_action = history.my_actions[previous_round]
        opponent_prev_actions = history.opponent_actions[previous_round, :]
        all_prev_actions = np.append([my_prev_action], opponent_prev_actions)
        if np.all(all_prev_actions):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_89(BaseStrategy):
    """
    This strategy balances cooperation and defection in a repeated common pool resource game.
    It cooperates initially, defects in the last round, and decides based on the stock level
    and opponents' previous actions in the middle rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_round = state.round_number - 1
        opponent_actions = history.opponent_actions[previous_round]
        d_count = (opponent_actions == False).sum()
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        half_capacity = capacity / 2.0
        half_n = n_players / 2.0
        if d_count < half_n and state.current_stock > half_capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_90(BaseStrategy):
    """
    Implements the Adaptive Cooperative Guardian strategy to balance individual payoffs 
    with sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_depleted = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_stock == 0.0:
            self.stock_depleted = True
        if self.stock_depleted:
            return Action.D
        if current_round == 0:
            return Action.C
        if current_round == self.r - 1:
            if current_stock > self.capacity / 4:
                return Action.C
            else:
                return Action.D
        defectors_last_rounds = 0
        look_back = 3
        for i in range(1, look_back + 1):
            round_num = current_round - i
            if round_num < 0:
                continue
            opponent_actions = history.opponent_actions[round_num]
            others_defected = np.sum(opponent_actions == 0)
            my_action = history.my_actions[round_num]
            my_defected = 0 if my_action else 1
            total_defectors = others_defected + my_defected
            half_n = self.n // 2
            if total_defectors > half_n:
                defectors_last_rounds += 1
        if current_stock > self.capacity / 2 and defectors_last_rounds < self.n // 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_91(BaseStrategy):
    """
    A threshold-based strategy to balance cooperation and deter defection.
    Cooperates initially and continues if the stock is at least 70% of capacity.
    Defects otherwise to deter over-exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.7 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock >= self.threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_92(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that balances cooperation and defection based on the stock level.
    It starts with cooperation, defects temporarily if the stock is depleted, and resumes cooperation upon recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.cooperate = True
        self.defect_count = 0
        self.last_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
            self.last_stock = state.current_stock
        else:
            previous_stock = self.last_stock
            current_stock = state.current_stock
            action = Action.C
            if previous_stock is not None and previous_stock < 0.5 * self.capacity:
                self.cooperate = False
                self.defect_count = 0
                action = Action.D
            elif not self.cooperate and self.defect_count < 2:
                action = Action.D
                self.defect_count += 1
            else:
                final_rounds = state.round_number >= self.n_rounds - 2
                if final_rounds and current_stock < 0.25 * self.capacity:
                    action = Action.D
            self.last_stock = current_stock
        return action

class Strategy_COLLECTIVE_93(BaseStrategy):
    """
    Collective Strategy for Common Pool Resource Game.
    Cooperates initially, defects when stock is below 50%, and reverts if stock recovers above 60%.
    Defects in last round if stock is above 50%.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.last_defected_punishment = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            if state.current_stock > 0.5 * self.capacity:
                return Action.D
            else:
                return Action.C
        current_stock = state.current_stock
        if current_stock > 0.75 * self.capacity:
            self.last_defected_punishment = False
            return Action.C
        elif current_stock < 0.5 * self.capacity:
            self.last_defected_punishment = True
            return Action.D
        elif self.last_defected_punishment:
            if current_stock > 0.6 * self.capacity:
                self.last_defected_punishment = False
                return Action.C
            else:
                self.last_defected_punishment = False
                return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_94(BaseStrategy):
    """
    Adaptive Cooperation Threshold strategy for the Common Pool Resource Game.
    Cooperates when the stock is below 50% of capacity, otherwise defects with a probability
    proportional to how much the stock exceeds this threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        threshold = 0.5 * capacity
        if current_stock < threshold:
            return Action.C
        else:
            numerator = current_stock - threshold
            p = numerator / capacity
            p = max(0.0, min(1.0, p))
            if random.random() < p:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_95(BaseStrategy):
    """
    A strategy that adapts based on the current stock level and round number.
    Cooperates when stock is above 75% of capacity, defects otherwise, and always defects in the last round.
    First round always cooperates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.C
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_96(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) Strategy.

    This strategy starts by Cooperating to establish trust. It monitors the cooperation rate and stock level,
    adapting its behavior to promote sustainable resource use while defending against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.C
        critical_threshold = 0.25 * self.game_description.capacity
        if state.current_stock < critical_threshold:
            return Action.C
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        prev_round = state.round_number - 1
        my_last_action = history.my_actions[prev_round]
        opponent_last_actions = history.opponent_actions[prev_round]
        coop_last_round = (1 if my_last_action else 0) + np.count_nonzero(opponent_last_actions)
        coop_rate = coop_last_round / self.game_description.n_players
        if coop_rate > 0.5:
            return Action.C
        else:
            self.punishment_remaining = 2
            return Action.D

class Strategy_COLLECTIVE_97(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection.
    It encourages initial cooperation, punishes non-cooperative behavior, and ensures stock recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        if state.current_stock < 0.5 * capacity:
            return Action.C
        else:
            t_prev = state.round_number - 1
            my_prev = history.my_actions[t_prev]
            opponent_prev = history.opponent_actions[t_prev]
            k_prev = (1 if my_prev else 0) + sum(opponent_prev)
            threshold = 0.75 * self.game_description.n_players
            return Action.C if k_prev >= threshold else Action.D

class Strategy_COLLECTIVE_98(BaseStrategy):
    """
    Threshold-based strategy that cooperates when the stock is above half capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.current_stock > self.capacity / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_99(BaseStrategy):
    """
    A strategy for the Common Pool Resource game that promotes cooperation and 
    punishes resource depletion. It starts with cooperation, punishes when the 
    stock decreases significantly, and defects in the final round to maximize 
    immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.threshold = 0.5 * self.capacity
        self.punish_duration = 3
        self.current_state = 'coop'
        self.punish_count = 0
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        trend = self.calculate_trend()
        if self.current_state == 'coop':
            if state.current_stock < self.threshold and trend == 'decreasing':
                self.current_state = 'punish'
                self.punish_count = 1
                return Action.D
            else:
                return Action.C
        elif self.current_state == 'punish':
            action = Action.D
            if self.punish_count < self.punish_duration:
                self.punish_count += 1
            if state.current_stock > self.threshold and trend == 'increasing':
                self.current_state = 'coop'
                self.punish_count = 0
            return action

    def calculate_trend(self) -> str:
        if len(self.stock_history) >= 2:
            recent = self.stock_history[-1]
            previous = self.stock_history[-2]
            if recent > previous:
                return 'increasing'
            else:
                return 'decreasing'
        else:
            return 'stable'

class Strategy_COLLECTIVE_100(BaseStrategy):
    """
    Adaptive Reciprocal Cooperation (ARC) strategy for the Common Pool Resource game.
    The strategy combines cooperation with reciprocal punishment, adapting to stock levels and others' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.in_punitive_phase = False
        self.previous_coop_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if current_stock < 0.25 * self.capacity:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        self.previous_coop_count = 0
        if my_prev_action:
            self.previous_coop_count += 1
        self.previous_coop_count += sum(opponent_prev_actions)
        defection_detected = self.previous_coop_count < self.n_players
        stock_above_75 = current_stock > 0.75 * self.capacity
        stock_below_50 = current_stock < 0.5 * self.capacity
        if self.in_punitive_phase:
            if current_stock > 0.6 * self.capacity:
                if not defection_detected:
                    self.in_punitive_phase = False
                    return Action.C
            return Action.D
        elif stock_above_75 and (not defection_detected):
            return Action.C
        elif stock_below_50 or defection_detected:
            self.in_punitive_phase = True
            return Action.D
        else:
            prob = (current_stock / self.capacity - 0.5) / 0.25
            prob = max(0.0, min(prob, 1.0))
            if random.random() < prob:
                return Action.C
            else:
                self.in_punitive_phase = True
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_101(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on the current stock level.
    Cooperates initially and if the stock remains above 50% of capacity in subsequent rounds,
    defects otherwise and in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.half_capacity = game_description.capacity * 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock > self.half_capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_102(BaseStrategy):
    """
    Implement a threshold-based strategy for the Common Pool Resource game.
    Cooperate if the current stock is above 50% of capacity, otherwise Defect.
    Starts with Cooperation in the first round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        threshold = 0.5 * self.capacity
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_103(BaseStrategy):
    """
    Adaptive strategy for the Common Pool Resource game that balances cooperation 
    with strategic defection based on stock levels and endgame conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cutoff = max(1, int(0.1 * self.n_rounds))
        endgame_cutoff = self.n_rounds - cutoff
        is_endgame = state.round_number >= endgame_cutoff
        if is_endgame:
            return Action.D
        if state.current_stock < 0.9 * self.capacity:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_104(BaseStrategy):
    """
    Adaptive Cooperation with Stock Threshold (ACST) strategy.

    Cooperates initially, defects if stock falls below half capacity, 
    and defects in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            threshold = self.capacity / 2
            if state.current_stock >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_105(BaseStrategy):
    """
    A strategy that balances immediate gains with long-term sustainability in the Common Pool Resource Game.
    Cooperates in the first and intermediate rounds (when stock is above 50% of capacity), and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            threshold = 0.5 * self.capacity
            if state.current_stock > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_107(BaseStrategy):
    """
    A strategy that balances cooperation with retaliation based on stock levels and opponent behavior.
    Cooperates to rebuild when stock is low and defects if many opponents defected previously.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_stock = state.current_stock
        if previous_stock < 0.5 * self.capacity:
            return Action.C
        previous_round = state.round_number - 1
        my_previous_action = history.my_actions[previous_round]
        opponent_actions = history.opponent_actions[previous_round]
        num_defectors = 0
        if not my_previous_action:
            num_defectors += 1
        num_defectors += sum((not action for action in opponent_actions))
        if num_defectors > self.n_players / 2:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_109(BaseStrategy):
    """
    Adaptive Reciprocity Strategy with Stock Thresholds.
    Cooperates initially and adaptively based on stock level and previous actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock > 0.75 * self.capacity:
            return Action.C
        elif current_stock < 0.25 * self.capacity:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round, :]
            total_coop = np.sum(opp_prev_actions) + my_prev_action
            if total_coop >= self.n_players / 2:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_111(BaseStrategy):
    """
    Adaptive Reciprocity Strategy (ARS) for the Common Pool Resource Game.
    This strategy balances cooperation and defection based on game state and history,
    promoting collective welfare while adapting to others' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        if state.round_number == 0:
            return Action.C
        if state.round_number == n_rounds - 1:
            return Action.D
        total_rounds = n_rounds
        endgame_cutoff = int(0.8 * total_rounds)
        if state.round_number >= endgame_cutoff:
            stock_p = state.current_stock / capacity
            if stock_p >= 0.75:
                prev_round = state.round_number - 1
                my_prev_action = history.my_actions[prev_round]
                opponent_prev_actions = history.opponent_actions[prev_round]
                cooperators_prev = sum(opponent_prev_actions) + (1 if my_prev_action else 0)
                if cooperators_prev / n_players >= 0.5:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        else:
            stock = state.current_stock
            stock_p = stock / capacity
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_prev_actions = history.opponent_actions[prev_round]
            cooperators_prev = sum(opponent_prev_actions) + (1 if my_prev_action else 0)
            if stock_p >= 0.75:
                if cooperators_prev / n_players > 0.5:
                    return Action.C
                else:
                    return Action.D
            elif 0.5 <= stock_p < 0.75:
                if cooperators_prev / n_players >= 0.5:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_COLLECTIVE_112(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that promotes cooperation 
    and punishes overexploitation by defecting for a brief period to restore 
    the stock to a sustainable level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.in_punishment = False
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.round_number == 0:
            return Action.C
        threshold = self.game_description.capacity / 2
        current_stock = state.current_stock
        if self.in_punishment:
            self.punishment_remaining -= 1
            if self.punishment_remaining == 0:
                if current_stock > threshold:
                    self.in_punishment = False
                    return Action.C
                else:
                    self.punishment_remaining = 3
            return Action.D
        elif current_stock <= threshold:
            self.in_punishment = True
            self.punishment_remaining = 3
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_113(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game where players cooperate initially and 
    when the stock is above 50% of capacity, switching to defection when the stock drops 
    to 50% or below to maximize individual payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.current_stock > 0.5 * self.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_114(BaseStrategy):
    """
    Sustainable Cooperation with Gradual Punishment (SCGP) strategy.
    Cooperates initially and monitors compliance. Defects if stock falls below threshold
    or insufficient cooperation is detected, then resumes cooperation unless issues persist.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.coop_threshold = math.ceil(game_description.n_players / 2)
        self.stock_threshold = 0.75 * game_description.capacity
        self.in_punishment = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            if state.current_stock >= self.stock_threshold:
                return Action.C
            else:
                return Action.D
        if self.in_punishment:
            self.in_punishment = False
            return Action.D
        else:
            previous_stock = state.current_stock
            if previous_stock < self.stock_threshold:
                self.in_punishment = True
                return Action.D
            if history is None:
                return Action.C
            total_coops = sum(history.opponent_actions[-1, :]) + history.my_actions[-1]
            if total_coops >= self.coop_threshold:
                return Action.C
            else:
                self.in_punishment = True
                return Action.D

class Strategy_COLLECTIVE_115(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and punishment
    of defectors, with special handling for the first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.critical_low = 0.25 * self.capacity
        self.threshold_defectors = self.n_players / 4
        self.final_round_threshold = 0.5 * self.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == self.n_rounds - 1:
            if state.current_stock > self.final_round_threshold:
                return Action.C
            else:
                return Action.D
        else:
            current_stock = state.current_stock
            if current_stock < self.critical_low:
                return Action.C
            else:
                prev_round = current_round - 1
                my_prev_action = history.my_actions[prev_round]
                my_defect = 0 if my_prev_action else 1
                opp_actions = history.opponent_actions[prev_round, :]
                opp_defects = sum((0 if a else 1 for a in opp_actions))
                total_defectors = my_defect + opp_defects
                if total_defectors > self.threshold_defectors:
                    return Action.D
                else:
                    return Action.C

class Strategy_COLLECTIVE_116(BaseStrategy):
    """
    A strategy that initially cooperates and then continues to cooperate only if the stock is above 50% of the initial capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        threshold = 0.5 * capacity
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_117(BaseStrategy):
    """
    A strategy that starts by cooperating, adapts based on stock levels and others' defections, 
    and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.25 * self.capacity:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_previous = history.my_actions[prev_round]
            opponent_prev = history.opponent_actions[prev_round, :]
            previous_defections = 0
            if not my_previous:
                previous_defections += 1
            previous_defections += np.sum(opponent_prev == False)
            threshold = self.n_players // 2 + 1
            if previous_defections >= threshold:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_118(BaseStrategy):
    """
    Adaptive Collective Cooperation (ACC) strategy balances cooperation with punitive actions
    to maintain sustainable resource levels. Cooperates initially, punishes upon low stock or
    excessive defection, and adapts behavior in the final round based on stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            if current_stock > 0.75 * self.capacity:
                return Action.C
            else:
                return Action.D
        elif current_stock > 0.75 * self.capacity:
            return Action.C
        else:
            previous_round = round_number - 1
            opponent_actions_last_round = history.opponent_actions[previous_round]
            my_last_action = history.my_actions[previous_round]
            cooperators = sum(opponent_actions_last_round) + (1 if my_last_action else 0)
            defectors = self.n_players - cooperators
            if defectors > self.n_players / 2 or current_stock < 0.5 * self.capacity:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_119(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that balances cooperation and punishment.
    It encourages sustainability by adapting to past actions and current stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        if state.current_stock <= 0.5 * self.capacity:
            return Action.C
        prev_round = state.round_number - 1
        my_last_action = history.my_actions[prev_round]
        opp_last_actions = history.opponent_actions[prev_round]
        opp_defectors = sum((1 for action in opp_last_actions if action == 0))
        my_defector = 0 if my_last_action else 1
        total_defectors = opp_defectors + my_defector
        if total_defectors > self.n_players / 2:
            return Action.D
        if state.round_number == self.n_rounds - 1:
            if state.current_stock < 0.25 * self.capacity:
                return Action.D
            else:
                return Action.C
        else:
            count = 0
            total_rounds = 0
            for offset in range(1, 4):
                round_idx = state.round_number - offset
                if round_idx < 0:
                    break
                total_rounds += 1
                my_action = history.my_actions[round_idx]
                opp_actions = history.opponent_actions[round_idx]
                opp_coop = sum(opp_actions)
                total_coop = (1 if my_action else 0) + opp_coop
                if total_coop > self.n_players / 2:
                    count += 1
            if 2 * count > total_rounds:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_120(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource game that balances cooperation 
    with defection to prevent stock depletion, with a forgiveness mechanism to revert 
    to cooperation when the stock recovers.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.threshold = 0.7 * self.capacity
        self.last_action = None
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            self.last_action = Action.C
            self.previous_stock = current_stock
            return Action.C
        elif current_round == self.n_rounds - 1:
            self.last_action = Action.C
            self.previous_stock = current_stock
            return Action.C
        else:
            if self.last_action == Action.D:
                if current_stock > self.previous_stock:
                    action = Action.C
                else:
                    action = Action.D
            elif current_stock < self.threshold:
                action = Action.D
            else:
                action = Action.C
            self.last_action = action
            self.previous_stock = current_stock
            return action

class Strategy_COLLECTIVE_121(BaseStrategy):
    """Adaptive Reciprocity with Stock Threshold strategy.
    
    This strategy balances cooperation and punishment based on others' past actions
    and adjusts according to the current stock level to encourage sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.low_threshold = 0.2 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        prev_defect_me = 0 if my_prev_action else 1
        prev_defect_opponents = (opponent_prev_actions == False).sum()
        total_defect_prev = prev_defect_me + prev_defect_opponents
        if state.current_stock < self.low_threshold:
            return Action.C
        elif total_defect_prev > self.n_players / 2:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_122(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that encourages cooperation while adaptively responding to defections.
    It balances immediate gains with long-term sustainability by cooperating initially, punishing defectors, and maintaining cooperation
    in the last round to ensure resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        capacity = self.game_description.capacity
        stock_percent = state.current_stock / capacity if capacity != 0 else 0.0
        total_coop = 0
        for round in range(len(history.my_actions)):
            opponent_coop = sum(history.opponent_actions[round, :])
            self_coop = 1 if history.my_actions[round] else 0
            total_coop += opponent_coop + self_coop
        average_coop = total_coop / (len(history.my_actions) * self.game_description.n_players) if len(history.my_actions) > 0 else 0.0
        if stock_percent > 0.7:
            if average_coop > 0.5:
                return Action.C
            else:
                return Action.D
        elif average_coop < 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_123(BaseStrategy):
    """
    Adaptive Cooperation with Retaliation strategy.
    Cooperates initially, defects in the last round, and adapts based on stock level and previous defections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        else:
            prev_round = state.round_number - 1
            opponent_actions_prev = history.opponent_actions[prev_round]
            num_defectors = np.sum(opponent_actions_prev == False)
            percent_defectors = num_defectors / len(opponent_actions_prev) * 100
            if percent_defectors > 20:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_124(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that adapts based on stock levels.
    Cooperates initially, defects if stock falls below thresholds, and adjusts in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        round_number = state.round_number
        current_stock = state.current_stock
        n_rounds = self.game_description.n_rounds
        if round_number == 0:
            return Action.C
        elif round_number == n_rounds - 1:
            threshold = capacity / 4
            if current_stock > threshold:
                return Action.C
            else:
                return Action.D
        else:
            threshold = capacity / 2
            if current_stock < threshold:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_125(BaseStrategy):
    """
    Adaptive strategy for the Common Pool Resource Game balancing cooperation and defection.
    Cooperates initially and when the stock is healthy and enough players cooperate.
    Defects when the stock is low or many players defected previously.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        previous_stock = state.current_stock
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        threshold = capacity / 2
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opp_prev = history.opponent_actions[prev_round, :]
        defectors = 0
        if not my_prev:
            defectors += 1
        for action in opp_prev:
            if not action:
                defectors += 1
        proportion_defectors = defectors / n
        if proportion_defectors > 0.5 and previous_stock < threshold:
            return Action.D
        elif previous_stock > threshold and proportion_defectors <= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_126(BaseStrategy):
    """
    An adaptive strategy that balances cooperation with targeted punishment, prioritizing stock replenishment when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        stock_threshold = 0.5 * self.capacity
        if current_stock < stock_threshold:
            return Action.C
        my_prev_action = history.my_actions[-1]
        my_defected = 0 if my_prev_action else 1
        opp_prev_actions = history.opponent_actions[-1]
        opp_defected = np.sum(~opp_prev_actions)
        total_defected = my_defected + opp_defected
        proportion_defected = total_defected / self.n_players
        if proportion_defected > 0.25:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_127(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels, cooperation rates, and round progression.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_last_action = history.my_actions[-1]
        opp_last_actions = history.opponent_actions[-1]
        my_last_C = 1 if my_last_action else 0
        opp_last_C = sum(opp_last_actions)
        H = (my_last_C + opp_last_C) / self.n
        S = state.current_stock
        if state.round_number >= self.r - 3:
            if S > 0.5 * self.capacity:
                return Action.C
            else:
                return Action.D
        elif S < 0.3 * self.capacity:
            return Action.C
        elif H > 0.7 and S > 0.5 * self.capacity:
            return Action.C
        else:
            t = state.round_number
            total_C = sum(history.my_actions) + history.opponent_actions.sum()
            H_avg = total_C / (self.n * t)
            probability_defect = 1 - H_avg
            if random.random() < probability_defect:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_128(BaseStrategy):
    """
    Sustainable Cooperation with Punishment (SCoP) strategy.
    Cooperates when stock is above 70% of capacity, defects otherwise,
    with a punishment phase of up to three rounds, then reassessing based on stock recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.in_punishment = False
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        threshold_coop = 0.7 * capacity
        threshold_recover = 0.5 * capacity
        if current_stock >= threshold_coop:
            return Action.C
        if self.in_punishment and self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        elif self.in_punishment and self.punishment_remaining == 0:
            if current_stock >= threshold_recover:
                self.in_punishment = False
                return Action.C
            else:
                return Action.D
        else:
            self.in_punishment = True
            self.punishment_remaining = 3
            return Action.D

class Strategy_COLLECTIVE_129(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Thresholds strategy.
    Cooperates initially and adjusts based on stock level trends and capacity thresholds.
    Defects when the stock is low or shows a declining trend in moderate ranges.
    Cooperates in the last round if the stock is sufficiently high.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.should_punish_next = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if history is not None:
            self.stock_history.append(current_stock)
        if current_round == 0:
            return Action.C
        if current_round == self.game_description.n_rounds - 1:
            if current_stock < 0.5 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C
        stock_percent = current_stock / self.game_description.capacity * 100
        if stock_percent > 75:
            return Action.C
        elif 50 < stock_percent <= 75:
            if len(self.stock_history) >= 2:
                prev_stock = self.stock_history[-2]
                if current_stock < prev_stock:
                    return Action.D
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_130(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Threshold Strategy.
    Cooperates in the first round and in subsequent rounds if the previous round's stock was above 50% of capacity.
    Defects if the previous round's stock was 50% or below. This promotes sustainability while protecting against over-depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        if state.round_number == 0:
            action = Action.C
        elif self.last_stock > 0.5 * capacity:
            action = Action.C
        else:
            action = Action.D
        self.last_stock = state.current_stock
        return action

class Strategy_COLLECTIVE_131(BaseStrategy):
    """
    Strategy that aims to maintain a sustainable common pool resource by adapting 
    behavior based on stock levels and collective player actions in previous rounds.
    Cooperates initially, and continues if others do; defects if others don't.
    Prioritizes regeneration if stock is low, and ensures stable payoff in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        prev_actions = history.opponent_actions[-1, :]
        coop_count = sum(prev_actions)
        coop_rate = coop_count / self.game_description.n_players
        if coop_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_132(BaseStrategy):
    """
    Sustainable Cooperation with Adaptive Defection (SCAD) Strategy.
    Cooperates initially to establish trust and adapts based on stock levels and others' cooperation.
    Defects when stock is low or insufficient players cooperated, and always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            n = self.game_description.n_players
            capacity = self.game_description.capacity
            my_coop = history.my_actions[prev_round]
            opponent_coop = np.sum(history.opponent_actions[prev_round, :])
            total_coop = my_coop + opponent_coop
            threshold = n / 2
            high = 0.7 * capacity
            low = 0.3 * capacity
            stock = state.current_stock
            if stock >= high and total_coop >= threshold:
                return Action.C
            elif stock <= low or total_coop < threshold:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_133(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that dynamically balances cooperation and defection.
    It cooperates in the first round, defects in the last round, and adapts based on stock levels and historical cooperation rates in intermediate rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock = 0.5 * self.capacity
        self.coop_threshold = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            sum_coop = 0
            for r_idx in range(state.round_number):
                my_action = history.my_actions[r_idx]
                others_actions = history.opponent_actions[r_idx, :]
                others_coop = np.sum(others_actions)
                sum_coop += my_action + others_coop
            total_possible = state.round_number * self.n_players
            avg_coop = sum_coop / total_possible if total_possible != 0 else 0.0
            current_stock = state.current_stock
            if current_stock < self.critical_stock or avg_coop > self.coop_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_134(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that encourages cooperation based on stock levels and detection of defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.D
        my_actions = history.my_actions
        opponent_actions = history.opponent_actions
        if len(my_actions) == 0:
            return Action.D
        my_last = my_actions[-1]
        my_defect = 0 if my_last else 1
        if opponent_actions.size == 0:
            opp_defect_count = 0
        else:
            opp_defect_count = sum((1 for action in opponent_actions[-1] if not action))
        total_defectors = my_defect + opp_defect_count
        stock_threshold = 0.7 * self.capacity
        cooperation_threshold = 0.3 * self.n_players
        stock_condition = state.current_stock > stock_threshold
        cooperation_condition = total_defectors < cooperation_threshold
        if stock_condition and cooperation_condition:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_135(BaseStrategy):
    """
    Adaptive Cooperation with Sustainability Thresholds
    
    This strategy starts by cooperating to encourage a cooperative environment. It then
    assesses the stock level relative to capacity and the number of rounds remaining
    to decide whether to continue cooperating or defect. Additionally, it uses a Tit-for-Tat
    mechanism to mirror the majority action of other players in the previous round.
    In the final round, it always defects to maximize individual payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        rounds_remaining = self.game_description.n_rounds - state.round_number - 1
        if current_stock > 0.5 * capacity and rounds_remaining > 2:
            return Action.C
        else:
            if history is not None:
                last_round = state.round_number - 1
                if last_round >= 0:
                    opponent_actions = history.opponent_actions[last_round, :]
                    count_coop = sum(opponent_actions)
                    n_opponents = opponent_actions.shape[0]
                    if count_coop / n_opponents >= 0.5:
                        return Action.C
            return Action.D

class Strategy_COLLECTIVE_136(BaseStrategy):
    """
    Collective Strategy for Common Pool Resource Game implementing reciprocity and forgiveness.
    Cooperates initially, punishes by defecting if thresholds are crossed, forgives if conditions improve.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_defect_round = -1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        game = self.game_description
        current_round = state.round_number
        n_rounds = game.n_rounds
        capacity = game.capacity
        n_players = game.n_players
        if current_round == 0:
            return Action.C
        if current_round == n_rounds - 1:
            return Action.C
        defectors_prev = self._compute_defectors_previous(history, current_round)
        stock_prev = state.current_stock
        stock_ok = stock_prev > 0.5 * capacity
        defectors_ok = defectors_prev < 0.25 * n_players
        if current_round - 1 == self.last_defect_round:
            if stock_ok and defectors_ok:
                action = Action.C
                self.last_defect_round = -1
            else:
                action = Action.D
                self.last_defect_round = current_round
        elif stock_ok and defectors_ok:
            action = Action.C
        else:
            action = Action.D
            self.last_defect_round = current_round
        return action

    def _compute_defectors_previous(self, history: PlayerHistory, current_round: int) -> int:
        """
        Calculate the number of defectors in the previous round.
        """
        prev_round = current_round - 1
        my_prev = history.my_actions[prev_round]
        opponent_prev = history.opponent_actions[prev_round]
        my_defection = 0 if my_prev else 1
        opponent_defections = opponent_prev.size - np.sum(opponent_prev)
        total_defectors = my_defection + opponent_defections
        return total_defectors

class Strategy_COLLECTIVE_137(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that combines initial cooperation, 
    adaptive response based on previous defections, stock level monitoring, and 
    endgame defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * self.capacity:
            return Action.C
        my_actions = history.my_actions
        opponent_actions = history.opponent_actions
        last_my_action = my_actions[-1]
        last_opponent_actions = opponent_actions[-1]
        num_opponents = last_opponent_actions.shape[0]
        defectors_opponents = num_opponents - sum(last_opponent_actions)
        defector_i = 0 if last_my_action else 1
        total_defectors = defectors_opponents + defector_i
        threshold = 0.5 * self.n_players
        if total_defectors >= threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_138(BaseStrategy):
    """
    Adaptive Collective Cooperation (ACC) strategy.
    
    This strategy promotes cooperation when the stock is healthy, defects when
    the stock is critically low to prioritize recovery, and defects in the
    final round. It encourages reciprocity based on previous rounds' cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        elif current_round == self.r - 1:
            return Action.D
        elif current_stock <= 0.3 * self.capacity:
            return Action.C
        elif current_stock >= 0.7 * self.capacity:
            return Action.C
        else:
            if history is None:
                return Action.C
            last_round_idx = current_round - 1
            my_prev_action = history.my_actions[last_round_idx]
            opponents_prev_actions = history.opponent_actions[last_round_idx, :]
            n_coop = 1 if my_prev_action else 0
            n_coop += np.sum(opponents_prev_actions)
            if n_coop >= self.n / 2:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_139(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection.
    Cooperates initially and in sustainable conditions, defects when resources are scarce or others defect extensively.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_stock < capacity / 2.0:
            return Action.D
        else:
            prev_round = state.round_number - 1
            prev_actions = history.opponent_actions[prev_round]
            count_d = len(prev_actions) - np.sum(prev_actions)
            half_players = self.game_description.n_players // 2
            if count_d > half_players:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_140(BaseStrategy):
    """
    Adaptive Cooperation with Punishment strategy.
    Cooperates initially, switches to cooperation if stock is below 50% of capacity,
    and defects if fewer than 50% of players cooperated in the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_stock < 0.5 * capacity:
            return Action.C
        previous_round = state.round_number - 1
        my_action_prev = history.my_actions[previous_round]
        others_prev = history.opponent_actions[previous_round]
        total_coop = np.sum(others_prev) + (1 if my_action_prev else 0)
        n_players = self.game_description.n_players
        if 2 * total_coop >= n_players:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_141(BaseStrategy):
    """
    A strategy that starts by cooperating, punishes any historical defection by defecting,
    and defects in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        for t_prev in range(state.round_number):
            if not history.my_actions[t_prev]:
                return Action.D
            if np.any(history.opponent_actions[t_prev] == False):
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_142(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            if state.current_stock > 0.5 * self.capacity:
                return Action.C
            else:
                return Action.D
        else:
            prev_actions = history.opponent_actions[-1, :]
            count_defectors = np.sum(prev_actions == False)
            if count_defectors > self.n_players / 2 or state.current_stock < 0.75 * self.capacity:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_143(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) strategy.
    Implements a strategy that encourages cooperation, punishes defection, 
    and ensures stock sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            if current_stock < 0.2 * capacity:
                return Action.C
            elif self.punishment_remaining > 0:
                self.punishment_remaining -= 1
                return Action.D
            else:
                last_round = state.round_number - 1
                my_last = history.my_actions[last_round]
                opponent_last = history.opponent_actions[last_round]
                all_actions = np.append([my_last], opponent_last)
                coop_rate = np.mean(all_actions)
                if coop_rate >= 0.7:
                    return Action.C
                else:
                    self.punishment_remaining = 3
                    return Action.D

class Strategy_COLLECTIVE_144(BaseStrategy):
    """
    An adaptive cooperation strategy with a stock threshold to balance sustainability and self-interest.
    Cooperates when the stock is abundant, defects when it is depleted, and maximizes gain in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.total_rounds = game_description.n_rounds
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.total_rounds - 1:
            return Action.D
        else:
            threshold = 0.75 * self.capacity
            if state.current_stock > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_145(BaseStrategy):
    """
    Collective Strategy for the Common Pool Resource Game.

    This strategy uses a threshold-based approach to determine cooperation or defection.
    Players cooperate if the stock is below 50% of capacity or if more than half defected previously.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round_actions = history.my_actions[-1]
        others_last_actions = history.opponent_actions[-1, :]
        defectors_others = np.count_nonzero(~others_last_actions)
        defectors_total = (0 if last_round_actions else 1) + defectors_others
        stock_condition = state.current_stock < self.capacity / 2
        defectors_condition = defectors_total > self.n_players / 2
        if stock_condition or defectors_condition:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_146(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Driven Thresholds Strategy.
    Cooperates when the stock is above 75% of capacity, defects when below 50%, 
    and adapts based on stock growth otherwise. Defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_stock = state.current_stock
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        seventy_five_percent = 0.75 * capacity
        fifty_percent = 0.5 * capacity
        current_stock = state.current_stock
        if current_stock > seventy_five_percent:
            action = Action.C
        elif current_stock < fifty_percent:
            action = Action.D
        elif self.previous_stock is not None:
            delta_stock = current_stock - self.previous_stock
            action = Action.C if delta_stock <= 0 else Action.D
        else:
            action = Action.C
        self.previous_stock = current_stock
        return action

class Strategy_COLLECTIVE_147(BaseStrategy):
    """
    Adaptive Conservation with Recent Defection Penalty strategy for the Common Pool Resource Game.
    It starts by cooperating, defects in the last round, and adapts based on recent behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock = self.capacity / (2 * self.n_players)
        self.cooperation_threshold = 0.5
        self.window_size = min(game_description.n_rounds, 10)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < self.critical_stock:
            return Action.D
        start_round = max(0, state.round_number - self.window_size)
        n_rounds_to_check = state.round_number - start_round
        total_defections = 0
        for r in range(start_round, state.round_number):
            my_action = history.my_actions[r]
            my_defection = 0 if my_action else 1
            opponents_r = history.opponent_actions[r, :]
            opponent_defections = np.count_nonzero(~opponents_r)
            total_defections += my_defection + opponent_defections
        total_possible_actions = n_rounds_to_check * self.n_players
        if total_possible_actions == 0:
            avg_defection = 0.0
        else:
            avg_defection = total_defections / total_possible_actions
        if avg_defection > self.cooperation_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_148(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances individual gain with collective sustainability.
    Cooperates initially, defects in the final round, and adapts based on stock levels in intermediate rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.current_stock > 0.5 * self.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_149(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection.
    Cooperates initially, defects if previous consumption exceeds sustainable levels,
    and always defects in the last round. Also defects if stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.past_stocks = [self.capacity]
        self.low_stock_threshold = 0.1 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.past_stocks.append(state.current_stock)
        t = state.round_number
        if t == 0:
            return Action.C
        elif t == self.n_rounds - 1:
            return Action.D
        else:
            if state.current_stock < self.low_stock_threshold:
                return Action.D
            t_prev = t - 1
            s_prev = self.past_stocks[t_prev]
            my_action_prev = history.my_actions[t_prev]
            opp_actions_prev = history.opponent_actions[t_prev]
            total_cons = 0.0
            n = self.n_players
            actions = [my_action_prev]
            actions.extend(opp_actions_prev.tolist())
            for action in actions:
                if action:
                    total_cons += s_prev / (2 * n)
                else:
                    total_cons += s_prev / n
            if total_cons > s_prev / 2 + 1e-09:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_150(BaseStrategy):
    """
    Adaptive Threshold Cooperation with Endgame Defection strategy.
    Cooperates based on stock levels and trends, defects in endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.action_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.stock_history.append(state.current_stock)
            self.action_history.append(Action.C)
            return Action.C
        else:
            capacity = self.game_description.capacity
            n_rounds = self.game_description.n_rounds
            current_stock = state.current_stock
            round_number = state.round_number
            self.stock_history.append(current_stock)
            if round_number >= n_rounds - 2:
                self.action_history.append(Action.D)
                return Action.D
            if current_stock < 0.2 * capacity:
                self.action_history.append(Action.C)
                return Action.C
            if len(self.action_history) >= 1 and len(self.stock_history) >= 2:
                last_action = self.action_history[-1]
                if last_action == Action.C:
                    if self.stock_history[-1] < self.stock_history[-2]:
                        self.action_history.append(Action.D)
                        return Action.D
            if current_stock < 0.7 * capacity:
                self.action_history.append(Action.C)
                return Action.C
            else:
                self.action_history.append(Action.D)
                return Action.D

class Strategy_COLLECTIVE_151(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection
    based on the game's state and history to promote sustainability while maximizing payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            capacity = self.game_description.capacity
            current_stock = state.current_stock
            if current_stock < 0.5 * capacity:
                return Action.C
            my_last_action = history.my_actions[-1]
            opponent_last_actions = history.opponent_actions[-1]
            defectors_count = 0
            if not my_last_action:
                defectors_count += 1
            for action in opponent_last_actions:
                if not action:
                    defectors_count += 1
            n_players = self.game_description.n_players
            threshold = n_players / 2
            if defectors_count > threshold:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_152(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that promotes cooperation initially but adapts based on previous players' actions and current stock levels.
    Cooperates in the first round, defects in the last two rounds, and otherwise cooperates unless previous round had excessive defection or stock is low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        my_last_action = history.my_actions[state.round_number - 1]
        n_my_defect = 0 if my_last_action else 1
        opponent_actions_last = history.opponent_actions[state.round_number - 1]
        n_opponents = opponent_actions_last.size
        n_opponent_defects = n_opponents - opponent_actions_last.sum()
        total_defectors = n_my_defect + n_opponent_defects
        condition1 = total_defectors > self.game_description.n_players / 2
        condition2 = state.current_stock < 0.2 * self.game_description.capacity
        if condition1 or condition2:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_153(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        threshold = capacity / 2.0
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_154(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.5 * self.capacity:
            return Action.C
        if random.random() < 0.8:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_155(BaseStrategy):
    """
    A strategy that cooperates initially, defects in the last round, 
    and cooperates or defects in other rounds based on stock changes.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_stock = state.current_stock
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            if state.current_stock > self.previous_stock:
                action = Action.C
            else:
                action = Action.D
            self.previous_stock = state.current_stock
            return action

class Strategy_COLLECTIVE_156(BaseStrategy):
    """
    Sustainable Cooperation with Punishment (SCoP) Strategy.

    This strategy promotes cooperation while punishing defectors to maintain resource sustainability.
    It cooperates initially, then dynamically adjusts based on stock levels and others' cooperation.
    It defects in the last round and can enter a punishment phase for defectors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if history is None:
            return Action.C
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        if state.current_stock <= 1e-08:
            return Action.D
        remaining_rounds = self.game_description.n_rounds - state.round_number - 1
        threshold = remaining_rounds / self.game_description.n_rounds * self.game_description.capacity
        if state.current_stock > threshold:
            my_prev_action = history.my_actions[state.round_number - 1]
            prev_coop = 1 if my_prev_action == Action.C else 0
            opp_prev_actions = history.opponent_actions[state.round_number - 1, :]
            prev_coop += np.sum(opp_prev_actions == Action.C)
            n_players = self.game_description.n_players
            cooperation_threshold_players = n_players - 1
            if prev_coop >= cooperation_threshold_players:
                return Action.C
            else:
                self.punishment_remaining = 2
                return Action.D
        else:
            self.punishment_remaining = 2
            return Action.D

class Strategy_COLLECTIVE_157(BaseStrategy):
    """
    A strategy that begins by cooperating and adapts based on the stock level.
    Cooperates if the stock is at least 70% of capacity; otherwise, defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        else:
            threshold = 0.7 * self.game_description.capacity
            if state.current_stock >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_158(BaseStrategy):
    """
    An adaptive strategy that preserves the common pool resource by 
    cooperating initially, defecting if the stock decreases consecutively, 
    and reverting to cooperation if the stock increases consecutively.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.defecting = False
        self.consecutive_decreases = 0
        self.consecutive_increases = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        current_stock = state.current_stock
        self.stock_history.append(current_stock)
        if not self.defecting:
            if len(self.stock_history) >= 2:
                s_prev = self.stock_history[-2]
                s_curr = self.stock_history[-1]
                if s_prev > s_curr:
                    self.consecutive_decreases += 1
                    if self.consecutive_decreases >= 2:
                        self.defecting = True
                        self.consecutive_decreases = 0
                        return Action.D
                else:
                    self.consecutive_decreases = 0
            return Action.C
        else:
            if len(self.stock_history) >= 2:
                s_prev = self.stock_history[-2]
                s_curr = self.stock_history[-1]
                if s_prev < s_curr:
                    self.consecutive_increases += 1
                    if self.consecutive_increases >= 2:
                        self.defecting = False
                        self.consecutive_increases = 0
                        return Action.C
                else:
                    self.consecutive_increases = 0
            return Action.D

class Strategy_COLLECTIVE_159(BaseStrategy):
    """
    Cooperate in the first round and continue cooperating unless the total consumption 
    in any subsequent round exceeds half of the stock, in which case defect thereafter. 
    If defecting, resume cooperation only if a subsequent round's consumption is 
    sustainable (at or below half the stock).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defecting = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        my_payoff_prev = history.my_payoffs[t_prev]
        opponent_payoffs_prev = history.opponent_payoffs[t_prev]
        C_prev = my_payoff_prev + opponent_payoffs_prev.sum()
        c = 0
        if history.my_actions[t_prev]:
            c += 1
        c += history.opponent_actions[t_prev].sum()
        n = self.game_description.n_players
        denominator = 2 * n - c
        S_prev = C_prev * 2 * n / denominator
        if self.defecting:
            if C_prev <= S_prev / 2:
                self.defecting = False
            return Action.D
        else:
            if C_prev > S_prev / 2:
                self.defecting = True
            return Action.C

class Strategy_COLLECTIVE_160(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACWP) strategy.

    This strategy starts with cooperation, then adapts based on the proportion of defecting players and stock levels.
    It punishes excessive defection by defecting for a limited number of rounds, then forgives and resumes cooperation
    if conditions improve. It prioritizes stock conservation and maximizes payoff in the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_active = False
        self.punishment_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        if current_round >= n_rounds - 1:
            if state.current_stock > 0.75 * capacity:
                return Action.D
        last_my_action = history.my_actions[current_round - 1]
        last_others_actions = history.opponent_actions[current_round - 1, :]
        all_last_actions = np.insert(last_others_actions, 0, last_my_action)
        defect_count = np.count_nonzero(all_last_actions == False)
        defect_proportion = defect_count / self.game_description.n_players
        current_stock = state.current_stock
        if self.punishment_active:
            self.punishment_count += 1
            if self.punishment_count >= 2:
                if defect_proportion > 0.3 or current_stock < 0.5 * capacity:
                    self.punishment_count = 0
                    return Action.D
                else:
                    self.punishment_active = False
                    self.punishment_count = 0
                    return Action.C
            else:
                return Action.D
        elif defect_proportion > 0.3 or current_stock < 0.5 * capacity:
            self.punishment_active = True
            self.punishment_count = 1
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_161(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) strategy.
    Cooperates initially and punishes defections by defecting for up to two consecutive rounds
    if the resource stock falls below 50% of capacity, then reverting based on stock recovery.
    In the last round, decides based on the current stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        threshold = self.capacity / 2
        if history is None:
            return Action.C
        n = self.n_players
        last_action = history.my_actions[-1]
        last_payoff = history.my_payoffs[-1]
        if last_action == Action.C:
            S_prev = last_payoff * (2 * n)
        else:
            S_prev = last_payoff * n
        if S_prev > threshold:
            return Action.C
        punishment_count = 0
        max_check = min(2, len(history.my_actions))
        for i in range(1, max_check + 1):
            if history.my_actions[-i] == Action.D:
                punishment_count += 1
        if state.round_number == self.n_rounds:
            return Action.C if state.current_stock > threshold else Action.D
        elif punishment_count < 2:
            return Action.D
        elif state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_162(BaseStrategy):
    """
    Collective Strategy for Common Pool Resource Game.
    This strategy starts with cooperation, manages stock thresholds, penalizes defection, and shifts to cooperation in late rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        stock_threshold = 0.5 * self.capacity
        if current_stock < stock_threshold:
            return Action.C
        my_last_action = history.my_actions[-1] if history.my_actions.size > 0 else False
        my_defected = not my_last_action
        opponent_last_actions = history.opponent_actions[-1]
        opponent_defections = sum((1 for action in opponent_last_actions if action == 0))
        total_defectors = (1 if my_defected else 0) + opponent_defections
        if total_defectors > self.n_players / 2:
            return Action.D
        else:
            current_round = state.round_number
            if current_round > 0.8 * self.total_rounds:
                return Action.C
            else:
                return Action.C

class Strategy_COLLECTIVE_163(BaseStrategy):
    """
    Adaptive Collective Strategy for Common Pool Resource Game.
    Cooperates initially and adapts based on cooperation rate and stock level.
    In the last round, follows the majority action of the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opp_prev = history.opponent_actions[prev_round, :]
            count_C = sum([my_prev]) + int(np.sum(opp_prev))
            if count_C > self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opp_prev = history.opponent_actions[prev_round, :]
            count_C = sum([my_prev]) + int(np.sum(opp_prev))
            coop_rate = count_C / self.game_description.n_players
            stock_level = state.current_stock / self.game_description.capacity
            if coop_rate >= 0.75 and stock_level >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_164(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and 
    defection based on stock levels and opponents' previous actions. It starts 
    with cooperation, defects if the stock is low, punishes excessive defection 
    by opponents, and cooperates in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.C
        else:
            threshold_stock = 0.5 * self.capacity
            if state.current_stock < threshold_stock:
                return Action.D
            if history is not None:
                n_other_players = self.n_players - 1
                prev_round = state.round_number - 1
                opponent_actions_prev = history.opponent_actions[prev_round, :]
                num_defectors = n_other_players - np.count_nonzero(opponent_actions_prev)
                if num_defectors > n_other_players / 2:
                    return Action.D
            return Action.C

class Strategy_COLLECTIVE_165(BaseStrategy):
    """
    Adaptive Cooperation with Stock Sustainability Strategy.
    Cooperates initially, then adapts based on cooperation rates and stock levels.
    Uses EWMA to track cooperation rates and stock sustainability thresholds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.avg_coop_ema = 0.0
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.stock_history.append(state.current_stock)
            return Action.C
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round >= total_rounds - 1:
            return Action.D
        self.stock_history.append(state.current_stock)
        if current_round == 1:
            my_actions = history.my_actions[0]
            opponent_actions = history.opponent_actions[0, :]
            cooperators = 1 if my_actions else 0 + sum(opponent_actions)
            coop_rate = cooperators / self.game_description.n_players
            self.avg_coop_ema = coop_rate
        else:
            my_actions = history.my_actions[current_round - 1]
            opponent_actions = history.opponent_actions[current_round - 1, :]
            cooperators = 1 if my_actions else 0 + sum(opponent_actions)
            coop_rate = cooperators / self.game_description.n_players
            self.avg_coop_ema = 0.2 * coop_rate + 0.8 * self.avg_coop_ema
        cooperation_threshold = 0.7
        stock_threshold = 0.5 * self.game_description.capacity
        stock_ok = state.current_stock >= stock_threshold
        cooperation_ok = self.avg_coop_ema >= cooperation_threshold
        if cooperation_ok and stock_ok:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_166(BaseStrategy):
    """
    Dynamically adapts cooperation based on stock levels and previous defections.
    Cooperates initially, defects if stock is low or if many defected previously,
    and always defects in the last round to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        stock_threshold = 0.25 * self.game_description.capacity
        if state.current_stock < stock_threshold:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        my_defected = not my_prev_action
        opponent_actions_prev = history.opponent_actions[prev_round]
        opponent_defections = len(opponent_actions_prev) - np.sum(opponent_actions_prev)
        total_defections = (1 if my_defected else 0) + opponent_defections
        n_players = self.game_description.n_players
        defection_ratio = total_defections / n_players
        if defection_ratio > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_167(BaseStrategy):
    """
    A strategy that cooperates if the stock is increasing compared to two rounds ago,
    otherwise defects. Attempts to balance current gains with future stock sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_prev_stock = None
        self.prev_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.prev_prev_stock = state.current_stock
            self.prev_stock = None
            return Action.C
        else:
            current_stock = state.current_stock
            if self.prev_stock is None:
                if current_stock > self.prev_prev_stock:
                    action = Action.C
                else:
                    action = Action.D
                self.prev_stock = current_stock
            else:
                if current_stock > self.prev_stock:
                    action = Action.C
                else:
                    action = Action.D
                self.prev_prev_stock, self.prev_stock = (self.prev_stock, current_stock)
            return action

class Strategy_COLLECTIVE_168(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.threshold = 0.5 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        self.stock_history.append(current_stock)
        k = 3
        if len(self.stock_history) > k:
            self.stock_history = self.stock_history[-k:]
        if state.round_number == 0:
            return Action.C
        else:
            if len(self.stock_history) >= 2:
                changes = [self.stock_history[i] - self.stock_history[i - 1] for i in range(1, len(self.stock_history))]
                total_change = sum(changes)
            else:
                total_change = 0
            if total_change > 0:
                self.threshold = min(self.threshold * 1.05, self.game_description.capacity)
            elif total_change < 0:
                self.threshold = max(self.threshold * 0.95, 0)
            if current_stock > self.threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_169(BaseStrategy):
    """
    Adaptive Cooperation with Stock Threshold strategy for the Common Pool Resource Game.
    Cooperates initially, defects if majority defected previously or if stock is below 50% of capacity,
    and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C
        elif state.round_number == r - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            opponent_prev = history.opponent_actions[prev_round]
            my_defected = 0 if my_prev else 1
            opponent_defected = sum((1 - x for x in opponent_prev))
            D_count = my_defected + opponent_defected
            if D_count > n / 2:
                return Action.D
            elif state.current_stock < 0.5 * capacity:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_170(BaseStrategy):
    """
    A strategy that implements initial cooperation, adapts based on stock levels and opponents' cooperation, and defects in the last round if beneficial.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        round_num = state.round_number
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if round_num == n_rounds - 1:
            if current_stock > 0.5 * capacity:
                return Action.C
            else:
                return Action.D
        elif round_num == 0:
            return Action.C
        elif current_stock < 0.5 * capacity:
            return Action.C
        else:
            prev_round = round_num - 1
            if history is None:
                prev_round_my_action = 0
            else:
                prev_round_my_action = history.my_actions[prev_round]
            prev_round_opponent_actions = history.opponent_actions[prev_round] if history is not None else np.zeros(self.game_description.n_players - 1)
            total_coop = prev_round_my_action + np.sum(prev_round_opponent_actions)
            avg_coop = total_coop / self.game_description.n_players
            if avg_coop >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_171(BaseStrategy):
    """
    Adaptive Reciprocal Cooperation (ARC) strategy for the Common Pool Resource Game.
    Implements a strategy that balances cooperation and punishment to sustain the common resource.
    Initial cooperation, stock-based recovery, and monitoring of cooperation rates guide the actions.
    Defects in the final round to maximize individual gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < 3:
            return Action.C
        elif state.round_number >= self.n_rounds - 1:
            return Action.D
        elif state.current_stock <= 0.5 * self.capacity:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_action = history.my_actions[prev_round]
            opponent_actions = history.opponent_actions[prev_round]
            total_coop = my_action + np.sum(opponent_actions)
            cooperation_rate = total_coop / self.n_players
            if cooperation_rate >= 0.75:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_172(BaseStrategy):
    """
    Adaptive Collective Cooperation (ACC) strategy.

    The strategy promotes long-term sustainability by cooperating unless the stock decreases, 
    in which case it defects once as a punishment. It then monitors for stock recovery to 
    revert to cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_stock = None
        self.in_punishment = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_stock = state.current_stock
            return Action.C
        current_stock = state.current_stock
        if not self.in_punishment:
            if current_stock >= self.last_stock:
                self.last_stock = current_stock
                return Action.C
            else:
                self.in_punishment = True
                self.last_stock = current_stock
                return Action.D
        elif current_stock > self.last_stock:
            self.in_punishment = False
            self.last_stock = current_stock
            return Action.C
        else:
            self.last_stock = current_stock
            return Action.D

class Strategy_COLLECTIVE_173(BaseStrategy):
    """
    Adaptive Cooperation Based on Stock Trends strategy.
    Cooperates initially and adjusts based on stock level trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.my_prev_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.my_prev_action = Action.C
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            current_stock = state.current_stock
            if current_stock > 0.5 * self.capacity:
                self.my_prev_action = Action.C
                return Action.C
            else:
                self.my_prev_action = Action.D
                return Action.D
        else:
            past_stocks = []
            for i in range(len(history.my_actions)):
                action_i = history.my_actions[i]
                payoff_i = history.my_payoffs[i]
                if action_i:
                    s = 2 * payoff_i * self.n_players
                else:
                    s = payoff_i * self.n_players
                past_stocks.append(s)
            if len(past_stocks) >= 3:
                window = past_stocks[-3:]
            else:
                window = past_stocks
            if not window:
                avg_stock = 0.0
            else:
                avg_stock = sum(window) / len(window)
            if avg_stock >= 0.75 * self.capacity:
                action = Action.C
            elif avg_stock <= 0.5 * self.capacity:
                action = Action.D
            elif self.my_prev_action is not None:
                action = self.my_prev_action
            else:
                action = Action.C
            self.my_prev_action = action
            return action

class Strategy_COLLECTIVE_174(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that balances cooperation 
    and defection based on observed actions and stock levels to promote sustainability 
    while maintaining individual gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            self.previous_stock = current_stock
            return Action.C
        if current_stock <= 0:
            self.previous_stock = current_stock
            return Action.C
        if current_round == self.n_rounds - 1:
            if current_stock >= 0.5 * self.capacity:
                self.previous_stock = current_stock
                return Action.C
            else:
                self.previous_stock = current_stock
                return Action.D
        if current_stock < 0.5 * self.capacity:
            self.previous_stock = current_stock
            return Action.D
        stock_prev = self.previous_stock
        expected_consumption = stock_prev / 2
        my_action = history.my_actions[-1]
        opponents_actions = history.opponent_actions[-1, :]
        actual_consumption = 0.0
        if my_action:
            my_contribution = stock_prev / (2 * self.n_players)
        else:
            my_contribution = stock_prev / self.n_players
        actual_consumption += my_contribution
        for action in opponents_actions:
            if action:
                opp_contribution = stock_prev / (2 * self.n_players)
            else:
                opp_contribution = stock_prev / self.n_players
            actual_consumption += opp_contribution
        if actual_consumption >= expected_consumption * 1.1:
            action = Action.D
        else:
            action = Action.C
        self.previous_stock = current_stock
        return action

class Strategy_COLLECTIVE_175(BaseStrategy):
    """
    A threshold-based strategy for the Common Pool Resource Game. 
    Cooperates in the first round, cooperates if stock is above 50% of capacity in middle rounds, 
    and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.round_number == 0:
            return Action.C
        elif state.current_stock > 0.5 * self.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_176(BaseStrategy):
    """
    This strategy implements the Adaptive Cooperation Threshold (ACT) strategy for the Common Pool Resource Game.
    It dynamically adjusts cooperation based on stock levels and previous players' actions to balance individual and collective benefits.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        total_rounds = self.game_description.n_rounds
        if state.round_number >= total_rounds - 3:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round]
        total_coop = my_prev_action + sum(opponents_prev_actions)
        coop_last = total_coop / self.game_description.n_players
        stock_pct = state.current_stock / self.game_description.capacity
        if stock_pct >= 0.5 and coop_last >= 0.75:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_177(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation with punishment,
    conserves stock when necessary, and adapts based on others' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.low_stock_trigger = 0.3 * self.capacity
        self.critical_stock = 0.2 * self.capacity
        self.punishing = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            if current_stock < self.critical_stock:
                return Action.C
        if current_stock <= self.low_stock_trigger:
            return Action.C
        prev_round = round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        n_defectors = 0
        if not my_prev_action:
            n_defectors += 1
        for action in opponent_prev_actions:
            if not action:
                n_defectors += 1
        if n_defectors / self.n_players > 0.5:
            self.punishing = True
            return Action.D
        else:
            if self.punishing:
                self.punishing = False
            return Action.C

class Strategy_COLLECTIVE_178(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if current_round == 0:
            return Action.C
        if current_round == n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < 0.01 * capacity:
            return Action.D
        my_last_action = history.my_actions[-1]
        opponents_last_actions = history.opponent_actions[-1, :]
        last_coop_count = my_last_action + sum(opponents_last_actions)
        last_coop_rate = last_coop_count / self.game_description.n_players
        is_healthy = current_stock > 0.5 * capacity
        if is_healthy and last_coop_rate > 0.7:
            action = Action.C
        else:
            action = Action.D
        if self.check_for_forgiveness():
            action = Action.C
        return action

    def check_for_forgiveness(self) -> bool:
        k = 3
        threshold = 0.5 * self.game_description.capacity
        if len(self.stock_history) < k + 1:
            return False
        recent_stocks = self.stock_history[-(k + 1):-1]
        return all((stock > threshold for stock in recent_stocks))

class Strategy_COLLECTIVE_179(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that starts with cooperation, 
    monitors stock levels, punishes defectors by defecting for a period when 
    stock drops below 80% of capacity, and defects near the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_remaining = 0
        self.endgame_threshold = 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        remaining_rounds = self.game_description.n_rounds - 1 - state.round_number
        if remaining_rounds <= self.endgame_threshold:
            return Action.D
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        threshold = 0.8 * self.game_description.capacity
        if state.current_stock < threshold:
            self.punishment_remaining = 3
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_180(BaseStrategy):
    """
    A strategy that starts with cooperation, punishes defectors for a fixed number of rounds if stock levels fall below a threshold 
    or defection rates exceed a threshold, and reverts to cooperation if conditions improve or defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.7 * game_description.capacity
        self.allowed_defection_rate = 0.3
        self.punishment_duration = 3
        self.in_punishment = False
        self.punishment_rounds_left = 0
        self.total_defections = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        n_opponents = self.game_description.n_players - 1
        if not self.in_punishment and self.punishment_rounds_left == 0:
            stock_below_threshold = state.current_stock < self.stock_threshold
            total_defections = 0
            for r in range(len(history.opponent_actions)):
                defect_actions = ~history.opponent_actions[r, :]
                total_defections += np.count_nonzero(defect_actions)
            average_defection_rate = total_defections / (len(history.opponent_actions) * n_opponents)
            defection_rate_exceeded = average_defection_rate > self.allowed_defection_rate
            if stock_below_threshold or defection_rate_exceeded:
                self.in_punishment = True
                self.punishment_rounds_left = self.punishment_duration
        if self.in_punishment:
            if self.punishment_rounds_left > 0:
                self.punishment_rounds_left -= 1
                return Action.D
            else:
                stock_recovered = state.current_stock >= self.stock_threshold
                total_defections = 0
                for r in range(len(history.opponent_actions)):
                    defect_actions = ~history.opponent_actions[r, :]
                    total_defections += np.count_nonzero(defect_actions)
                average_defection_rate = total_defections / (len(history.opponent_actions) * n_opponents)
                defection_rate_improved = average_defection_rate <= self.allowed_defection_rate
                if stock_recovered and defection_rate_improved:
                    self.in_punishment = False
                    self.punishment_rounds_left = 0
                    return Action.C
                else:
                    self.punishment_rounds_left = self.punishment_duration
                    return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_181(BaseStrategy):
    """
    Adaptive Cooperation with Stock Sustainability (ACSS) strategy for the Common Pool Resource Game.
    This strategy aims to balance individual payoffs with long-term sustainability of the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.stock_history = []
        self.punishment_mode = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        current_stock = state.current_stock
        capacity = self.capacity
        total_rounds = self.n_rounds
        if t == total_rounds - 1:
            if current_stock > 0.25 * capacity:
                return Action.D
            else:
                return Action.C
        if current_stock < 0.25 * capacity:
            if not self.punishment_mode:
                self.punishment_mode = True
                return Action.D
            else:
                if t >= 1:
                    prev_stock = self.stock_history[t - 1]
                    if current_stock > prev_stock:
                        self.punishment_mode = False
                        return Action.C
                self.punishment_mode = False
        else:
            self.punishment_mode = False
        prev_stock = self.stock_history[t - 1]
        stock_change = current_stock - prev_stock
        if current_stock >= capacity:
            return Action.C
        elif current_stock > 0.5 * capacity:
            if stock_change >= 0:
                return Action.C
            else:
                return Action.D
        elif current_stock <= 0.5 * capacity:
            if t >= 2:
                prev_prev_stock = self.stock_history[t - 2]
                prev_change = prev_stock - prev_prev_stock
                if prev_change < 0 and stock_change < 0:
                    return Action.D
            elif stock_change < 0:
                return Action.D
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_182(BaseStrategy):
    """
    Adaptive Cooperation with Hysteresis strategy. Cooperates initially, then adapts based on the stock level.
    Uses hysteresis to maintain cooperation or defection unless significant stock level changes occur.
    Aims to balance long-term resource sustainability with immediate benefits.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        threshold_high = 0.9 * capacity
        threshold_upper_mid = 0.8 * capacity
        threshold_low = 0.7 * capacity
        if current_stock > threshold_high:
            return Action.C
        elif current_stock < threshold_low:
            return Action.D
        else:
            previous_my_action = history.my_actions[-1]
            if previous_my_action:
                return Action.C
            elif current_stock > threshold_upper_mid:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_183(BaseStrategy):
    """
    Cooperate until the stock drops below 50% of capacity, then defect permanently.
    This strategy balances cooperation with self-interest to prevent resource depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.threshold = 0.5 * self.capacity
        self.defecting = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.defecting:
            return Action.D
        if state.current_stock <= self.threshold:
            self.defecting = True
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_184(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection
    based on the current stock level and previous players' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_levels = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if len(self.stock_levels) <= current_round:
            self.stock_levels.append(state.current_stock)
        if current_round == 0:
            return Action.C
        elif current_round == self.r - 1:
            return Action.D
        else:
            stock_percent = state.current_stock / self.capacity
            if stock_percent < 0.25:
                return Action.C
            elif stock_percent > 0.75:
                return Action.C
            else:
                prev_round = current_round - 1
                S_prev = self.stock_levels[prev_round]
                expected_consumption = S_prev / 2.0
                my_prev_action = history.my_actions[prev_round]
                opponent_prev_actions = history.opponent_actions[prev_round]
                actual_consumption = 0.0
                if my_prev_action:
                    actual_consumption += S_prev / (2.0 * self.n)
                else:
                    actual_consumption += S_prev / self.n
                for opponent_action in opponent_prev_actions:
                    if opponent_action:
                        actual_consumption += S_prev / (2.0 * self.n)
                    else:
                        actual_consumption += S_prev / self.n
                if actual_consumption > expected_consumption:
                    return Action.D
                else:
                    return Action.C

class Strategy_COLLECTIVE_185(BaseStrategy):
    """
    Adaptive Reciprocal Cooperation (ARC) Strategy for the Common Pool Resource Game.

    This strategy encourages cooperation while adaptively punishing defection to sustain the common resource.
    It starts with cooperation, punishes once if the stock drops significantly, and resumes cooperation if the stock recovers.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.cooperate_threshold = 0.9 * self.capacity
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
            self.previous_stock = state.current_stock
        else:
            current = state.current_stock
            previous = self.previous_stock
            if current < self.cooperate_threshold and previous > current:
                action = Action.D
            else:
                action = Action.C
            self.previous_stock = current
        return action

class Strategy_COLLECTIVE_186(BaseStrategy):
    """
    A strategy that balances cooperation and self-interest based on previous actions and stock levels.
    Cooperates initially and continues if most players cooperated previously or stock remains high.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.stock_threshold = 0.9 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[-1]
        opponent_prev_actions = history.opponent_actions[-1, :]
        num_opponent_coop = np.sum(opponent_prev_actions)
        num_coop = num_opponent_coop + (1 if my_prev_action else 0)
        if num_coop >= self.n_players - 1:
            return Action.C
        elif state.current_stock >= self.stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_187(BaseStrategy):
    """A strategy that balances individual gain with collective sustainability by cooperating when the stock is low and defecting when it's high."""

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.threshold = 0.5 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock > self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_188(BaseStrategy):
    """
    A responsive cooperation strategy that switches to defection if total consumption 
    exceeds the expected cooperative level by more than 10%.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = [game_description.capacity]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            self.stock_history.append(state.current_stock)
            last_round = state.round_number - 1
            my_action = history.my_actions[last_round]
            opponent_actions = history.opponent_actions[last_round, :]
            all_actions = np.append([my_action], opponent_actions)
            num_C = np.sum(all_actions)
            num_D = len(all_actions) - num_C
            previous_stock = self.stock_history[last_round]
            expected = previous_stock / 2
            total_C = num_C * (previous_stock / (2 * self.game_description.n_players))
            total_D = num_D * (previous_stock / self.game_description.n_players)
            actual = total_C + total_D
            if actual > 1.1 * expected:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_189(BaseStrategy):
    """
    Adaptive Reciprocity with Stock Sustainability (ARSS) strategy.
    Cooperates initially, then adapts based on previous cooperation rates and stock levels.
    Defects in the last round if stock is low to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        r = self.game_description.n_rounds
        if state.round_number == r - 1:
            if state.current_stock > 0.5 * capacity:
                return Action.C
            else:
                return Action.D
        else:
            prev_round = state.round_number - 1
            my_action_prev = history.my_actions[prev_round]
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            sum_coop_opponents = np.sum(opponent_actions_prev)
            total_coop = sum_coop_opponents + (1 if my_action_prev else 0)
            avg_coop = total_coop / n
            current_stock = state.current_stock
            if avg_coop > 0.5 and current_stock > 0.5 * capacity:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_190(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) strategy for the Common Pool Resource Game.
    Balances individual payoffs with sustainability by encouraging cooperation and punishing defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.last_stock = None
        self.recent_defections = 0
        self.delta_threshold = 0.2
        self.is_punishing = False
        self.punishment_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n = self.n_players
        capacity = self.capacity
        if history is None:
            self.last_stock = state.current_stock
            return Action.C
        if current_round == self.game_description.n_rounds - 1:
            if state.current_stock > 0.5 * capacity:
                action = Action.C
            else:
                action = Action.D
        else:
            s_before = self.last_stock
            my_prev_action = history.my_actions[-1]
            opponent_prev_actions = history.opponent_actions[-1]
            total_consumption = 0.0
            if my_prev_action:
                total_consumption += s_before / (2 * n)
            else:
                total_consumption += s_before / n
            for i in range(n - 1):
                if opponent_prev_actions[i]:
                    total_consumption += s_before / (2 * n)
                else:
                    total_consumption += s_before / n
            expected_consumption = s_before / 2
            if total_consumption > expected_consumption * (1 + self.delta_threshold):
                self.recent_defections += 1
                self.is_punishing = True
                self.punishment_rounds_remaining = 2
                action = Action.D
            elif self.recent_defections > 0:
                s_remaining_expected = s_before / 2
                growth_expected = 2 * s_remaining_expected * (1 - s_remaining_expected / capacity)
                new_stock_expected = min(s_remaining_expected + growth_expected, capacity)
                if state.current_stock >= new_stock_expected * 0.9:
                    self.recent_defections = 0
                    self.is_punishing = False
                    self.punishment_rounds_remaining = 0
                    action = Action.C
                else:
                    action = Action.D
                    if self.punishment_rounds_remaining > 0:
                        self.punishment_rounds_remaining -= 1
                    else:
                        self.punishment_rounds_remaining = 2
            else:
                action = Action.C
        self.last_stock = state.current_stock
        return action

class Strategy_COLLECTIVE_191(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that promotes cooperation 
    based on stock levels and historical cooperation rates, adapting to prevent overexploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_last_action = history.my_actions[last_round]
        opponent_actions_last = history.opponent_actions[last_round, :]
        my_coop = 1 if my_last_action else 0
        opp_coop = sum(opponent_actions_last)
        avg_coop_last = (my_coop + opp_coop) / self.game_description.n_players
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            if avg_coop_last >= 0.7 or current_stock < 0.3 * capacity:
                return Action.C
            else:
                return Action.D
        elif current_stock > 0.7 * capacity and avg_coop_last >= 0.7 or current_stock < 0.3 * capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_192(BaseStrategy):
    """
    Cooperate unless the previous round's total consumption exceeded half of the starting stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_stock = 0.0

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            self.last_stock = state.current_stock
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_payoff = history.my_payoffs[prev_round]
            opponent_payoffs = history.opponent_payoffs[prev_round]
            sum_payoffs = my_payoff + np.sum(opponent_payoffs)
            s_prev = self.last_stock
            if sum_payoffs > s_prev / 2:
                action = Action.D
            else:
                action = Action.C
            self.last_stock = state.current_stock
            return action

class Strategy_COLLECTIVE_193(BaseStrategy):
    """
    A trigger strategy that cooperates unless more than 25% of players defected in any prior round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.n_players
        threshold = 0.25
        for prior_round in range(state.round_number):
            my_defect = not history.my_actions[prior_round]
            opponent_actions = history.opponent_actions[prior_round]
            opponents_defect = sum((1 for action in opponent_actions if not action))
            total_defectors = (1 if my_defect else 0) + opponents_defect
            if total_defectors / n > threshold:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_194(BaseStrategy):
    """
    Implementation of a strategy for maintaining a sustainable common resource over multiple rounds.
    The strategy Cooperates in the first round, Defects in the last round, and switches to Defection if previous round's consumption exceeds half the resource capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.stock_level = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            action = Action.C
            num_C = self.n_players
            num_D = 0
            C_prev = num_C * (self.stock_level / (2 * self.n_players))
            s_remaining = self.stock_level - C_prev
            growth = 2 * s_remaining * (1 - s_remaining / self.capacity)
            new_stock = s_remaining + growth
            if new_stock > self.capacity:
                new_stock = self.capacity
            self.stock_level = new_stock
            return action
        elif current_round == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = current_round - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_actions = history.opponent_actions[prev_round, :]
            num_C = sum(opponents_prev_actions) + (1 if my_prev_action else 0)
            num_D = self.n_players - num_C
            C_prev = num_C * (self.stock_level / (2 * self.n_players)) + num_D * (self.stock_level / self.n_players)
            if C_prev > self.capacity / 2:
                action = Action.D
            else:
                action = Action.C
            s_remaining = self.stock_level - C_prev
            growth = 2 * s_remaining * (1 - s_remaining / self.capacity)
            new_stock = s_remaining + growth
            if new_stock > self.capacity:
                new_stock = self.capacity
            self.stock_level = new_stock
            return action

class Strategy_COLLECTIVE_195(BaseStrategy):
    """
    Adaptive Cooperation strategy with stock-level thresholds.
    Cooperates under conditions of high stock and sufficient previous cooperation;
    Defects in low stock conditions or the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            if current_stock < 0.5 * self.capacity:
                return Action.D
            else:
                prev_round = state.round_number - 1
                my_prev = history.my_actions[prev_round]
                my_coop = 1 if my_prev else 0
                opp_coop = np.sum(history.opponent_actions[prev_round])
                total_coop = my_coop + opp_coop
                half_players = self.n_players / 2
                if total_coop >= half_players and current_stock > 0.75 * self.capacity:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_196(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) strategy.
    Balances cooperation with strategic punishment to sustain the common resource and maximize payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = [game_description.capacity]
        self.punishment_active = False
        self.punishment_rounds_remaining = 0
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        self.stock_history.append(state.current_stock)
        current_stock = state.current_stock
        round_number = state.round_number
        if current_stock < 0.5 * self.capacity:
            return Action.C
        if round_number >= self.n_rounds - 3 and current_stock < 0.5 * self.capacity:
            return Action.C
        if self.punishment_active:
            if self.punishment_rounds_remaining > 0:
                self.punishment_rounds_remaining -= 1
                return Action.D
            else:
                self.punishment_active = False
        if history is None:
            return Action.C
        last_round = round_number - 1
        my_payoff = history.my_payoffs[last_round]
        opponents_payoffs = history.opponent_payoffs[last_round]
        total_payoff = my_payoff + np.sum(opponents_payoffs)
        average_payoff = total_payoff / self.n_players
        S_prev = self.stock_history[last_round]
        expected_coop_payoff = S_prev / (2 * self.n_players)
        threshold = 0.75 * expected_coop_payoff
        if average_payoff < threshold:
            self.punishment_active = True
            self.punishment_rounds_remaining = 2
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_197(BaseStrategy):
    """
    Strategy implementing adaptive cooperation with punishment and final round defection.
    Cooperates initially, defects if many others defected or stock is low, defects in last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        my_defection = 0 if my_prev_action else 1
        opponents_defection = sum((1 for action in opponent_prev_actions if not action))
        d_prev = my_defection + opponents_defection
        if d_prev >= self.n_players / 2:
            return Action.D
        elif state.current_stock < 0.5 * self.capacity:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_198(BaseStrategy):
    """
    Adaptive Cooperation with Graduated Responses strategy.

    This strategy promotes cooperation to maintain the common pool resource but adapts to others' actions to protect individual payoffs when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        stock_percent = state.current_stock / self.game_description.capacity
        if stock_percent <= 0.05:
            return Action.D
        last_round = state.round_number - 1
        my_last_action = history.my_actions[last_round]
        opponent_last_actions = history.opponent_actions[last_round, :]
        any_defection = not my_last_action or any((not a for a in opponent_last_actions))
        if not any_defection:
            return Action.C
        elif state.current_stock > 0.5 * self.game_description.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_199(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that adapts based on stock level and previous round defectors.
    Cooperates initially and maintains cooperation unless stock is critically low or excessive defection is observed.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock < 0.3 * capacity:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        opponent_defectors = np.sum(~opponent_actions_prev)
        my_defector = 0 if my_prev_action else 1
        total_defectors = my_defector + opponent_defectors
        n_players = self.game_description.n_players
        if total_defectors > n_players / 2:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_200(BaseStrategy):
    """
    Collective Strategy for Common Pool Resource Game.
    Implements a strategy that promotes cooperation while responding to exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        defectors_prev = 0
        last_round = state.round_number - 1
        my_last_action = history.my_actions[last_round]
        if not my_last_action:
            defectors_prev += 1
        for opp in range(self.n_players - 1):
            opp_last_action = history.opponent_actions[last_round, opp]
            if not opp_last_action:
                defectors_prev += 1
        stock_prev = state.current_stock
        if stock_prev < 0.5 * self.capacity:
            return Action.C
        elif defectors_prev > self.n_players / 2:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_201(BaseStrategy):
    """Adaptive Cooperation Based on Stock Level strategy."""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            threshold = 0.5 * self.capacity
            if state.current_stock < threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_202(BaseStrategy):
    """
    Adaptive Collective Strategy for Common Pool Resource Game.
    This strategy combines cooperation with adaptive retaliation and stock-based adjustments.
    It aims to maintain resource sustainability while optimizing individual payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        if state.round_number == 0:
            return Action.C
        if state.round_number == total_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        if history is None:
            return Action.C
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round, :]
        total_C_prev = opponents_prev_actions.sum() + (1 if my_prev_action else 0)
        cooperation_rate = total_C_prev / n
        cooperation_threshold = 0.5
        current_stock_ratio = state.current_stock / capacity
        if cooperation_rate < cooperation_threshold:
            if current_stock_ratio <= 0.5:
                return Action.C
            else:
                return Action.D
        elif current_stock_ratio >= 0.5:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_203(BaseStrategy):
    """
    Sustainable Cooperation with Punishment (SCoP) Strategy.

    This strategy promotes cooperation while punishing excessive defection.
    It cooperates initially and continues unless the stock is critically low or a majority defected previously.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.critical_threshold = 0.2 * self.capacity
        self.defection_threshold = self.n_players / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if current_stock < self.critical_threshold:
            return Action.C
        if history is not None:
            previous_round = state.round_number - 1
            opponent_actions = history.opponent_actions[previous_round, :]
            my_previous_action = history.my_actions[previous_round]
            all_actions = np.insert(opponent_actions, 0, my_previous_action)
            count_defectors = np.sum(all_actions == False)
            if count_defectors > self.defection_threshold:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_205(BaseStrategy):
    """
    Adaptive Cooperation with Endgame Defection Strategy.
    Cooperates initially, defects in the last round, and adaptively responds
    based on the cooperation level in previous rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_actions = history.opponent_actions[prev_round]
            cooperators = opponents_prev_actions.sum() + (1 if my_prev_action else 0)
            threshold = 0.75 * self.game_description.n_players
            if cooperators >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_206(BaseStrategy):
    """
    Adaptive Collective Cooperation with Forgiveness Strategy.

    Cooperates initially and continues if the stock is above a threshold.
    Defects if the stock drops below the threshold for a certain number of rounds,
    then reverts to cooperation if the stock starts to recover.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / 2
        self.defecting = False
        self.defecting_rounds_left = 0
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_stock = state.current_stock
            return Action.C
        current_stock = state.current_stock
        if current_stock >= self.threshold:
            self.defecting = False
            self.defecting_rounds_left = 0
            action = Action.C
        elif not self.defecting:
            self.defecting = True
            self.defecting_rounds_left = 2
            action = Action.D
        elif self.defecting_rounds_left > 0:
            action = Action.D
            self.defecting_rounds_left -= 1
        elif current_stock > self.previous_stock:
            self.defecting = False
            self.defecting_rounds_left = 0
            action = Action.C
        else:
            self.defecting_rounds_left = 2
            action = Action.D
        self.previous_stock = current_stock
        return action

class Strategy_COLLECTIVE_207(BaseStrategy):
    """
    Adaptive Conservation with Reciprocity Strategy.
    
    This strategy balances reciprocity and conservation. It starts by cooperating,
    reciprocates based on the number of defectors in the previous round, and
    adjusts behavior based on the current stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        round_num = state.round_number
        prev_round = round_num - 1
        my_prev_action = history.my_actions[prev_round]
        my_defect = 0 if my_prev_action else 1
        opponent_actions_prev = history.opponent_actions[prev_round]
        opponent_defect_count = np.sum(1 - opponent_actions_prev)
        total_defectors_prev = my_defect + opponent_defect_count
        if round_num == self.n_rounds - 1:
            if state.current_stock < 0.25 * self.capacity:
                if total_defectors_prev > self.n_players / 2:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        elif total_defectors_prev > self.n_players / 2:
            return Action.D
        elif state.current_stock < 0.5 * self.capacity:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_208(BaseStrategy):
    """
    A strategy that always chooses to Defect in every round, based on the Nash equilibrium of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_COLLECTIVE_209(BaseStrategy):
    """
    A strategy that cooperates when the common pool stock is healthy (above 75% of capacity)
    and defects otherwise, to balance resource sustainability and prevent overexploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        threshold = 0.75 * capacity
        if state.current_stock >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_210(BaseStrategy):
    """
    Adaptive Cooperation with Stock Thresholds strategy.
    Cooperates initially, defects in the last round, and adapts based on stock levels
    and previous cooperation rates to balance individual and collective gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        S_prev = state.current_stock
        if S_prev < 0.3 * capacity:
            return Action.D
        my_prev_action = history.my_actions[-1]
        opp_prev_actions = history.opponent_actions[-1, :]
        if sum(opp_prev_actions) == 0:
            return Action.D
        C_prev = (1 if my_prev_action else 0) + sum(opp_prev_actions)
        if S_prev > capacity / 2 and C_prev >= n_players / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_211(BaseStrategy):
    """
    Collective Strategy for Common Pool Resource Game promoting cooperation
    when stock is above 50% of capacity and defection otherwise.
    Inherits from BaseStrategy and implements the decision logic.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        threshold = 0.5 * self.game_description.capacity
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_213(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels and historical cooperation rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock < 0.1 * capacity:
            return Action.D
        my_actions = history.my_actions[:state.round_number]
        my_coop = sum(my_actions)
        opponent_actions = history.opponent_actions[:state.round_number, :]
        opponent_coop = opponent_actions.sum()
        total_coop = my_coop + opponent_coop
        total_possible = state.round_number * self.game_description.n_players
        avg_coop_rate = total_coop / total_possible if total_possible != 0 else 0.0
        if current_stock > 0.5 * capacity and avg_coop_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_214(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection
    based on the stock levels and round number.
    Cooperates initially, defects if stock falls below 50% of capacity, and defects
    in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_215(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels and round number.
    Cooperates initially, then defects when stock is above 75% of capacity, and always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock <= 0.75 * self.game_description.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_216(BaseStrategy):
    """
    A strategy that always cooperates to ensure sustainable harvesting of the common resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        return Action.C

class Strategy_COLLECTIVE_218(BaseStrategy):
    """
    Adaptive Threshold Cooperation strategy for Common Pool Resource Game.
    Cooperates initially and in rounds where stock is above 80% of capacity, defects when stock is low or in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            threshold = 0.8 * self.game_description.capacity
            if state.current_stock > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_219(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) Strategy.
    Cooperates initially, then adapts based on stock levels and defection rates, with endgame defecting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        super().__init__(game_description)
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        if game_description.n_rounds == 0:
            self.endgame_threshold = 0
        else:
            endgame_rounds = math.ceil(0.2 * self.n_rounds)
            self.endgame_threshold = max(0, self.n_rounds - endgame_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.endgame_threshold:
            return Action.D
        current_stock = state.current_stock
        if self.capacity == 0:
            stock_percent = 0.0
        else:
            stock_percent = current_stock / self.capacity * 100
        if stock_percent > 75:
            return Action.C
        elif 50 < stock_percent <= 75:
            last_round = state.round_number - 1
            opponent_actions = history.opponent_actions[last_round]
            opponent_defectors = sum((1 for action in opponent_actions if not action))
            my_last_action = history.my_actions[last_round]
            total_defectors = opponent_defectors + (0 if my_last_action else 1)
            threshold = 0.25 * self.n_players
            if total_defectors >= threshold:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_220(BaseStrategy):
    """
    Adaptive Reciprocity with Stock Threshold strategy.
    Cooperates initially and if stock is low, otherwise reciprocates opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 2 * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            if state.current_stock < self.stock_threshold:
                return Action.C
            last_round_opp_actions = history.opponent_actions[-1, :]
            any_defected = np.any(~last_round_opp_actions)
            if any_defected:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_COLLECTIVE_222(BaseStrategy):
    """
    A strategy that cooperates initially and adapts based on the stock level relative to capacity.
    Cooperates if the stock after regrowth is above 80% of capacity, otherwise defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            capacity = self.game_description.capacity
            threshold = 0.8 * capacity
            if state.current_stock >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_223(BaseStrategy):
    """
    A strategy that combines cooperation with punishment mechanisms to balance individual payoffs and resource preservation.
    Cooperates initially, retaliates against excessive defection, and maximizes payoff in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        if t == 0:
            return Action.C
        elif t == self.game_description.n_rounds - 1:
            return Action.D
        else:
            threshold = 0.3 * self.game_description.capacity
            if state.current_stock < threshold:
                return Action.C
            else:
                prev_round = t - 1
                my_prev_action = history.my_actions[prev_round]
                my_defected = 0 if my_prev_action else 1
                opponent_actions_prev = history.opponent_actions[prev_round]
                n_opponents = opponent_actions_prev.size
                opponent_defected = n_opponents - np.sum(opponent_actions_prev)
                defectors_count = my_defected + opponent_defected
                if defectors_count > self.game_description.n_players / 2:
                    return Action.D
                else:
                    return Action.C

class Strategy_COLLECTIVE_225(BaseStrategy):
    """
    Adaptive Cooperation with Punishment and Endgame Adjustment Strategy.

    This strategy begins with cooperation, punishes excessive defection, adjusts
    near the endgame, and maintains stock levels for sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        near_end_threshold = max(0, self.game_description.n_rounds - 3)
        if state.round_number >= near_end_threshold:
            if state.current_stock < 0.3 * self.game_description.capacity:
                return Action.D
        if history is not None:
            prev_round = state.round_number - 1
            my_payoff_prev = history.my_payoffs[prev_round]
            opponent_payoffs_prev = history.opponent_payoffs[prev_round, :]
            my_action_prev = history.my_actions[prev_round]
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            C = int(my_action_prev)
            C += np.sum(opponent_actions_prev)
            C = int(C)
            sum_prev = my_payoff_prev + np.sum(opponent_payoffs_prev)
            n_players = self.game_description.n_players
            denominator = 2 * n_players - C
            S_prev = sum_prev * 2 * n_players / denominator
            fair_total = S_prev / 2
            if sum_prev > 1.2 * fair_total:
                return Action.D
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_226(BaseStrategy):
    """
    Cooperative Punishment with Stock Threshold Strategy.
    
    This strategy begins by cooperating in the first round. For subsequent rounds, 
    it cooperates only if fewer than half of the players defected in the previous round 
    and the current stock exceeds 80% of the capacity. Otherwise, it defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions_prev = history.opponent_actions[-1]
        opponent_coop = np.sum(opponent_actions_prev)
        my_coop_prev = history.my_actions[-1]
        my_coop = 1 if my_coop_prev else 0
        total_coop_prev = opponent_coop + my_coop
        n = self.game_description.n_players
        condition1 = total_coop_prev > n / 2
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        condition2 = current_stock > 0.8 * capacity
        if condition1 and condition2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_227(BaseStrategy):
    """
    A strategy that starts with cooperation, uses stock-based thresholds to decide actions,
    and adapts based on stock trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            action = Action.C
            self.previous_stock = current_stock
            return action
        elif current_round == self.game_description.n_rounds - 1:
            return Action.D
        else:
            percent = current_stock / self.capacity
            if percent >= 0.75:
                coop_prob = 1.0
            elif percent <= 0.5:
                coop_prob = 0.0
            else:
                coop_prob = (percent - 0.5) / 0.25
                if self.previous_stock is not None:
                    if current_stock < self.previous_stock:
                        coop_prob *= 0.8
                    else:
                        coop_prob = min(coop_prob * 1.2, 1.0)
                coop_prob = max(0.0, min(1.0, coop_prob))
            if random.random() < coop_prob:
                action = Action.C
            else:
                action = Action.D
            self.previous_stock = current_stock
            return action

class Strategy_COLLECTIVE_228(BaseStrategy):
    """
    Adaptive Cooperate-Punish strategy to balance cooperation and punishment in a Common Pool Resource Game.
    Cooperates initially, then adapts based on stock levels and opponents' behavior, with specific endgame tactics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperate_phase = 0
        self.punish_phase = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        game = self.game_description
        capacity = game.capacity
        rounds = game.n_rounds
        n_players = game.n_players
        if state.round_number >= rounds - 3:
            if state.current_stock > 0.75 * capacity:
                return Action.D
            else:
                return Action.C
        elif self.cooperate_phase > 0:
            self.cooperate_phase -= 1
            return Action.C
        elif self.punish_phase > 0:
            self.punish_phase -= 1
            return Action.D
        elif state.current_stock < 0.5 * capacity:
            self.cooperate_phase = 3
            return Action.C
        else:
            defectors = np.count_nonzero(~history.opponent_actions[-1])
            if defectors > n_players / 2:
                self.punish_phase = 2
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_229(BaseStrategy):
    """
    A strategy that adaptively chooses to Cooperate or Defect based on the current stock level relative to capacity.
    Cooperates when the stock is healthy, defects when it's depleted, and reverts if the stock recovers.
    Defects in the final round.
    Inherits from BaseStrategy and uses the game description to make decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == self.n_rounds - 1:
            return Action.D
        else:
            previous_action = history.my_actions[current_round - 1] if history else False
            current_stock = state.current_stock
            half_capacity = 0.5 * self.capacity
            seventy_percent_capacity = 0.7 * self.capacity
            if not previous_action:
                if current_stock > half_capacity:
                    return Action.C
                else:
                    return Action.D
            elif current_stock > seventy_percent_capacity:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_231(BaseStrategy):
    """
    Adaptive Conservation-Exploitation (ACE) Strategy for the Common Pool Resource Game.
    This strategy balances cooperation and defection based on stock levels and opponent behavior,
    encouraging resource sustainability while protecting individual gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            high_threshold = 0.75 * self.capacity
            low_threshold = 0.5 * self.capacity
            if current_stock >= high_threshold:
                return Action.C
            elif current_stock >= low_threshold:
                t = state.round_number
                my_prev_action = history.my_actions[t - 1]
                my_defect = 0 if my_prev_action else 1
                opponent_prev = history.opponent_actions[t - 1]
                opponent_defect = sum((1 for a in opponent_prev if a == False))
                total_defectors = my_defect + opponent_defect
                half = self.n_players / 2
                if total_defectors > half:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_232(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that begins with cooperation, 
    adapts based on stock levels and others' actions, using reciprocity and 
    signaling to maintain sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.last_round_defected = False
        self.defected_last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_round_defected = False
            self.defected_last_round = False
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock < 0.3 * self.capacity:
                self.last_round_defected = False
                self.defected_last_round = False
                return Action.D
            else:
                self.last_round_defected = False
                self.defected_last_round = False
                return Action.C
        current_stock = state.current_stock
        capacity = self.capacity
        n = self.n_players
        if current_stock > 0.7 * capacity:
            last_round = state.round_number - 1
            my_last_action = history.my_actions[last_round]
            opponent_actions_last_round = history.opponent_actions[last_round]
            defectors_last_round = 0
            if not my_last_action:
                defectors_last_round += 1
            defectors_last_round += (opponent_actions_last_round == False).sum()
            if defectors_last_round >= n / 2:
                action = Action.D
                self.last_round_defected = True
                self.defected_last_round = True
            else:
                action = Action.C
                self.last_round_defected = False
                self.defected_last_round = False
        else:
            action = Action.D
            self.last_round_defected = True
            self.defected_last_round = True
        return action

class Strategy_COLLECTIVE_233(BaseStrategy):
    """
    Dynamically adjusts the cooperation threshold based on the remaining rounds.
    Starts with cooperation and switches to defection as a threshold decreases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        total_rounds = self.n_rounds
        threshold = self.capacity * (1 - current_round / (total_rounds + 1))
        if current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_234(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and strategic defection.
    It initializes by cooperating, monitors stock levels, detects defection, and punishes accordingly.
    It prioritizes sustainability by cooperating when stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.previous_stock = self.capacity
        self.punishment_rounds = 0
        self.sustainability_threshold = 0.2 * self.capacity
        self.detection_threshold = 0.1 * self.capacity

    def calculate_expected_stock(self, previous_stock: float, capacity: float) -> float:
        if previous_stock == 0:
            return 0.0
        s_remaining = previous_stock / 2
        growth = 2 * s_remaining * (1 - s_remaining / capacity)
        new_stock = s_remaining + growth
        return min(new_stock, capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_stock = state.current_stock
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            self.previous_stock = state.current_stock
            return Action.D
        else:
            expected_next_stock = self.calculate_expected_stock(self.previous_stock, self.capacity)
            current_stock = state.current_stock
            if current_stock < expected_next_stock - self.detection_threshold:
                self.punishment_rounds = 2
            if current_stock < self.sustainability_threshold:
                action = Action.C
            elif self.punishment_rounds > 0:
                action = Action.D
                self.punishment_rounds -= 1
            else:
                action = Action.C
            self.previous_stock = current_stock
            return action

class Strategy_COLLECTIVE_235(BaseStrategy):
    """
    A strategy that starts by cooperating and adapts based on stock levels to encourage sustainability.
    Cooperates if the stock is above 70% of capacity, otherwise defects. After defecting, it reassesses
    to revert to cooperation if the stock recovers above the threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
        else:
            threshold = 0.7 * self.game_description.capacity
            current_stock = state.current_stock
            if current_stock > threshold:
                action = Action.C
            elif self.last_action == Action.D:
                if current_stock > threshold:
                    action = Action.C
                else:
                    action = Action.D
            else:
                action = Action.D
        self.last_action = action
        return action

class Strategy_COLLECTIVE_236(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on game state,
    incorporating initial cooperation, adaptive behavior, and endgame defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        r = self.game_description.n_rounds
        current_round = state.round_number
        endgame_cutoff = int(0.8 * r)
        if current_round >= endgame_cutoff:
            return Action.D
        capacity = self.game_description.capacity
        stock = state.current_stock
        if stock < 0.25 * capacity:
            return Action.D
        n_players = self.game_description.n_players
        if history is not None and len(history.my_actions) > 0:
            my_prev_action = history.my_actions[-1]
            opponent_prev_actions = history.opponent_actions[-1] if history is not None else []
        else:
            return Action.D
        total_defectors = 0
        if not my_prev_action:
            total_defectors += 1
        total_defectors += sum((1 for action in opponent_prev_actions if not action))
        previous_majority_defected = total_defectors > n_players // 2
        if stock > 0.5 * capacity and (not previous_majority_defected):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_237(BaseStrategy):
    """
    Collective Strategy for Common Pool Resource Game.
    Cooperates initially and if average payoff is above threshold,
    defects in the last round and punishes if necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        capacity = game_description.capacity
        n_players = game_description.n_players
        max_possible = capacity / (2 * n_players)
        self.threshold = max_possible / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        prev_my_payoff = history.my_payoffs[prev_round]
        prev_opp_payoffs = history.opponent_payoffs[prev_round, :]
        all_payoffs = np.append(prev_my_payoff, prev_opp_payoffs)
        avg_payoff = np.mean(all_payoffs)
        if avg_payoff > self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_238(BaseStrategy):
    """
    This strategy balances self-interest with collective sustainability in a Common Pool Resource Game.
    It adapts based on the number of defectors and the current stock level, with special handling for the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        is_last_round = state.round_number == n_rounds - 1
        if is_last_round:
            if state.current_stock < 500:
                return Action.D
        my_last_action = history.my_actions[-1]
        my_defected = 0 if my_last_action else 1
        last_opp_actions = history.opponent_actions[-1, :]
        opponent_coop = np.sum(last_opp_actions)
        opponent_defectors = len(last_opp_actions) - opponent_coop
        total_defectors = my_defected + opponent_defectors
        defector_proportion = total_defectors / n_players
        if state.current_stock < 500:
            return Action.C
        elif defector_proportion > 0.3:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_239(BaseStrategy):
    """
    Adaptive Cooperative Sustainability (ACS) strategy that balances cooperation 
    with safeguarding against exploitation by adapting based on stock levels and 
    others' past actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        k = 5
        num_rounds = min(k, state.round_number)
        start = max(0, state.round_number - num_rounds)
        recent_actions = history.opponent_actions[start:state.round_number]
        recent_coops = recent_actions.flatten().sum()
        if recent_coops > 3:
            return Action.C
        if state.current_stock < 0.5 * self.capacity:
            return Action.C
        prev_round = state.round_number - 1
        prev_actions = history.opponent_actions[prev_round]
        defectors = (prev_actions == False).sum()
        if defectors > self.n_players / 2:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_240(BaseStrategy):
    """
    A strategy that cooperates in early rounds with sufficient stock and defects 
    in later rounds or when stock is low, optimizing individual payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = 0.5 * self.capacity
        self.k = min(5, self.n_rounds - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        current_stock = state.current_stock
        t = state.round_number
        r = self.n_rounds
        if t < r - self.k:
            if current_stock > self.threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_242(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels and opponents' actions.
    Cooperates initially, then adapts based on the stock's sustainability and majority actions in previous rounds.
    Includes endgame considerations to maximize short-term gains while preserving stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        endgame_threshold = int(0.9 * self.n_rounds)
        if state.round_number >= endgame_threshold:
            return Action.D
        prev_round = state.round_number - 1
        prev_opponent_actions = history.opponent_actions[prev_round, :]
        sum_of_c = np.sum(prev_opponent_actions)
        num_def_prev = self.n_players - 1 - sum_of_c
        half_players = self.n_players / 2.0
        if num_def_prev > half_players:
            return Action.D
        current_stock = state.current_stock
        above_half = current_stock > 0.5 * self.capacity
        exact_half = current_stock == 0.5 * self.capacity
        few_defectors = num_def_prev < half_players
        if above_half or (exact_half and few_defectors):
            if num_def_prev < half_players:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_243(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels.
    Cooperates initially, defects if stock falls below a threshold, and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            return Action.D
        elif state.round_number == 0:
            return Action.C
        elif state.current_stock < self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_244(BaseStrategy):
    """
    A strategy that balances cooperation and defection in the Common Pool Resource Game.
    Cooperates in the first round, cooperates when stock is above half capacity in middle rounds,
    and defects in the last round to maximize final payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        half_capacity = self.capacity / 2.0
        if current_stock > half_capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_245(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels and previous actions.
    Cooperates initially and in rounds where stock is sufficiently high, and switches to defection otherwise, especially in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == r - 1:
            previous_round = state.round_number - 1
            my_action_prev = history.my_actions[previous_round]
            opponent_actions_prev = history.opponent_actions[previous_round]
            cooperators_prev = my_action_prev + sum(opponent_actions_prev)
            if state.current_stock > 0.5 * capacity and cooperators_prev >= n / 2:
                return Action.C
            else:
                return Action.D
        else:
            previous_round = state.round_number - 1
            my_action_prev = history.my_actions[previous_round]
            opponent_actions_prev = history.opponent_actions[previous_round]
            cooperators_prev = my_action_prev + sum(opponent_actions_prev)
            if state.current_stock > 0.75 * capacity and cooperators_prev >= n / 2:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_246(BaseStrategy):
    """
    An adaptive strategy that balances cooperation with protection against exploitation.
    Cooperates initially, defects if stock is low or if many others defected, and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        threshold = 0.5 * capacity
        current_stock = state.current_stock
        if current_stock < threshold:
            return Action.D
        n_players = self.game_description.n_players
        if n_players < 2:
            return Action.C
        n_opponents = n_players - 1
        total_defectors = 0
        for round in range(state.round_number):
            opponent_actions_round = history.opponent_actions[round, :]
            defectors_in_round = sum((1 for action in opponent_actions_round if not action))
            total_defectors += defectors_in_round
        total_possible = n_opponents * state.round_number
        proportion_defectors = total_defectors / total_possible if total_possible != 0 else 0.0
        if proportion_defectors > 0.25:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_247(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that starts by Cooperating and 
    then switches to Defecting when the stock level drops below half the capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            threshold = self.capacity / 2.0
            if state.current_stock > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_248(BaseStrategy):
    """
    Cooperative strategy that defects if previous round's total consumption exceeds half the capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_last_payoff = history.my_payoffs[-1]
        opponents_last_payoffs = history.opponent_payoffs[-1]
        total_consumption = my_last_payoff + np.sum(opponents_last_payoffs)
        threshold = self.game_description.capacity / 2
        if total_consumption > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_249(BaseStrategy):
    """
    An adaptive strategy that balances cooperation withdefection based on previous actions and stock levels.
    Cooperates initially, defects in endgame or when stock is critically low, and adapts based on others' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        r = self.n_rounds
        cutoff = int(0.9 * r)
        if current_round >= cutoff:
            return Action.D
        if current_stock < 0.5 * self.capacity:
            return Action.D
        prev_round = current_round - 1
        my_action_prev = history.my_actions[prev_round]
        opponents_actions_prev = history.opponent_actions[prev_round]
        n_coop = 1 if my_action_prev else 0
        n_coop += sum(opponents_actions_prev)
        if n_coop >= self.n_players / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_250(BaseStrategy):
    """
    Adaptive Cooperation with Stock Thresholds Strategy.
    Cooperates initially, then adapts based on previous cooperation rates and stock levels.
    Defects strategically in the last round based on stock evaluation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif history is None:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > 0.25 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        else:
            my_prev = history.my_actions[-1]
            opponents_prev = history.opponent_actions[-1, :]
            prev_c = my_prev + np.sum(opponents_prev)
            cooperation_rate = prev_c / self.game_description.n_players
            stock_condition = state.current_stock > 0.5 * self.game_description.capacity
            if cooperation_rate > 0.5 and stock_condition:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_251(BaseStrategy):
    """
    This strategy starts with cooperation and then adapts based on the stock level.
    If stock falls below 70% of capacity after regrowth, players cooperate; otherwise, defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = 0.7 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            return Action.C if state.current_stock < self.threshold else Action.D

class Strategy_COLLECTIVE_252(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and 
    exploitation based on stock levels and reciprocity. The strategy encourages cooperation 
    initially, monitors stock levels to decide actions, and reciprocates based on others' past 
    behavior, while also considering endgame scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            if state.current_stock >= 0.5 * self.capacity:
                return Action.C
            else:
                return Action.D
        current_stock = state.current_stock
        capacity = self.capacity
        if current_stock < 0.5 * capacity:
            return Action.C
        elif current_stock > 0.8 * capacity:
            return Action.D
        else:
            last_round = state.round_number - 1
            last_opponent_actions = history.opponent_actions[last_round, :]
            opponent_d_count = np.sum(~last_opponent_actions)
            self_last_action = history.my_actions[last_round]
            self_defected = not self_last_action
            total_d_count = opponent_d_count + (1 if self_defected else 0)
            threshold = self.n_players // 2
            if total_d_count > threshold:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_253(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and defection to maintain stock levels while maximizing payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_action = Action.C
        self.depletion_counter = 0
        self.recovery_counter = 0
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_stock = state.current_stock
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            self.previous_stock = state.current_stock
            return Action.D
        else:
            current_stock = state.current_stock
            previous_stock = self.previous_stock
            if previous_stock is not None:
                if current_stock < previous_stock:
                    self.depletion_counter += 1
                    if self.depletion_counter >= 2 and self.current_action == Action.C:
                        self.current_action = Action.D
                else:
                    self.depletion_counter = 0
                    if self.current_action == Action.D:
                        if current_stock >= previous_stock:
                            self.recovery_counter += 1
                            if self.recovery_counter >= 2:
                                self.current_action = Action.C
                                self.recovery_counter = 0
                        else:
                            self.recovery_counter = 0
            self.previous_stock = current_stock
            return self.current_action

class Strategy_COLLECTIVE_255(BaseStrategy):
    """
    Adaptive Cooperation with Punishment strategy. 
    Cooperates initially, then decides based on stock levels relative to a 75% capacity threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.threshold = 0.75 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            if state.current_stock >= self.threshold:
                return Action.C
            else:
                return Action.D
        elif state.current_stock >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_257(BaseStrategy):
    """
    Adaptive Cooperation with Punishment Strategy.

    This strategy initially cooperates, then adapts based on stock levels and opponent behavior.
    It defects if the stock is low or if many players defected previously, aiming to balance cooperation and self-interest.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if state.round_number == 0:
            return Action.C
        if state.round_number == n_rounds - 1:
            if state.current_stock > 0.75 * capacity:
                return Action.C
            else:
                return Action.D
        if state.current_stock < 0.5 * capacity:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        n_total_defectors = 0
        if not my_prev_action:
            n_total_defectors += 1
        n_opponent_defectors = sum((1 - a for a in opponent_prev_actions))
        n_total_defectors += n_opponent_defectors
        majority_threshold = n_players / 2
        if n_total_defectors > majority_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_258(BaseStrategy):
    """
    Adaptive Cooperation with Stock Thresholds Strategy.

    This strategy starts with cooperation in the first round. In subsequent rounds, it decides based on the current stock level and others' previous actions. It cooperates if the stock is above 70% of capacity and at least half of the other players cooperated previously. It defects if the stock is below 70% capacity. In the last round, it defects if the majority of players defected in the previous round, otherwise cooperates. If the stock is below 30%, it always cooperates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        cap = self.game_description.capacity
        current_stock = state.current_stock
        if state.round_number == self.game_description.n_rounds - 1:
            others_actions = history.opponent_actions[-1, :]
            others_coop = np.sum(others_actions)
            my_prev_action = history.my_actions[-1]
            total_coop = others_coop + (1 if my_prev_action else 0)
            prev_defectors = n_players - total_coop
            if prev_defectors > n_players / 2:
                return Action.D
            else:
                return Action.C
        elif current_stock < 0.3 * cap:
            return Action.C
        elif current_stock > 0.7 * cap:
            others_actions = history.opponent_actions[-1, :]
            others_coop = np.sum(others_actions)
            threshold = (n_players - 1) / 2
            if others_coop >= threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_259(BaseStrategy):
    """
    Adaptive Cooperation with Stock Threshold (ACT) Strategy for Common Pool Resource Game.
    Players cooperate if the current stock exceeds a dynamic threshold decreasing each round, 
    starting at 80% of capacity and decreasing by 8% each round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            k = state.round_number
            threshold = (0.8 - 0.08 * k) * self.capacity
            threshold = max(threshold, 0.0)
            if state.current_stock >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_262(BaseStrategy):
    """
    Adaptive Reciprocal Conservation (ARC) strategy implementation.

    This strategy begins with cooperation and adapts based on the common pool's stock level.
    It switches to defection when the stock drops below a threshold or shows a downward trend,
    then resumes cooperation if the stock recovers. It also adjusts behavior in final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = [game_description.capacity]
        self.defected_last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if len(self.stock_history) <= state.round_number:
            self.stock_history.append(current_stock)
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        threshold = capacity / 2.0
        is_final = False
        if r <= 3:
            is_final = True
        else:
            is_final = state.round_number >= r - 3
        if is_final:
            if current_stock > threshold:
                self.defected_last_round = False
                return Action.C
            else:
                self.defected_last_round = True
                return Action.D
        elif self.defected_last_round:
            if current_stock > threshold:
                self.defected_last_round = False
                return Action.C
            else:
                return Action.D
        else:
            trend_increasing = True
            if len(self.stock_history) >= 3:
                s0 = self.stock_history[-3]
                s1 = self.stock_history[-2]
                s2 = self.stock_history[-1]
                if not (s0 < s1 and s1 < s2):
                    trend_increasing = False
            else:
                trend_increasing = True
            if current_stock > threshold and trend_increasing:
                self.defected_last_round = False
                return Action.C
            else:
                self.defected_last_round = True
                return Action.D

class Strategy_COLLECTIVE_263(BaseStrategy):
    """
    A strategy that combines reciprocity with stock level monitoring to balance cooperation and self-interest.
    Cooperates initially, defects if stock levels are unsustainable or if others defect excessively.
    In the last round, cooperates if overall cooperation was high; otherwise defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        r = self.game_description.n_rounds
        if state.round_number == r - 1:
            my_C = np.sum(history.my_actions)
            opponent_C = np.sum(history.opponent_actions)
            total_C = my_C + opponent_C
            total_possible = state.round_number * n_players
            proportion = total_C / total_possible
            if proportion > 0.5:
                return Action.C
            else:
                return Action.D
        else:
            prev_round = state.round_number - 1
            my_defected = not history.my_actions[prev_round]
            opponents_defected = (~history.opponent_actions[prev_round]).sum()
            total_defectors = my_defected + opponents_defected
            percentage_defectors = total_defectors / n_players
            condition1 = percentage_defectors > 0.3
            condition2 = state.current_stock < 0.5 * capacity
            if condition1 or condition2:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_264(BaseStrategy):
    """
    A strategy that balances immediate gains with future sustainability by using a threshold-based approach.
    Players cooperate when the stock is at or below half the capacity and defect when it's above.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.T = 0.5 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        current_stock = state.current_stock
        if current_stock > self.T:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_265(BaseStrategy):
    """
    Adaptive Cooperation with Punishment strategy.
    
    Cooperates initially and continues if the stock remains above 90% of capacity.
    Defects in the next round if the stock drops below 90%, then reverts to cooperation.
    Cooperates in the last round if the stock is stable, otherwise defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        t = state.round_number
        stock_before = capacity
        for r in range(t):
            my_act = history.my_actions[r]
            opp_acts = history.opponent_actions[r]
            actions = [my_act] + opp_acts.tolist()
            total_consumption = 0.0
            for action in actions:
                if action:
                    consume = stock_before / (2 * n)
                else:
                    consume = stock_before / n
                total_consumption += consume
            S_remaining = stock_before - total_consumption
            growth = 2 * S_remaining * (1 - S_remaining / capacity)
            new_stock = S_remaining + growth
            new_stock = min(new_stock, capacity)
            stock_before = new_stock
        s_after_t_minus_1 = stock_before
        if state.round_number == self.game_description.n_rounds - 1:
            if s_after_t_minus_1 >= 0.9 * capacity:
                return Action.C
            else:
                return Action.D
        elif s_after_t_minus_1 < 0.9 * capacity:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_267(BaseStrategy):
    """
    A strategy that adapts cooperation based on the stock level, defecting when the stock is depleted.
    Cooperates initially, defects in the last round, and switches based on stock threshold otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_zero_flag = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if self.stock_zero_flag:
            return Action.D
        if state.current_stock <= 0.0:
            self.stock_zero_flag = True
            return Action.D
        threshold = 0.5 * self.game_description.capacity
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_268(BaseStrategy):
    """
    An adaptive strategy that balances cooperation with conservation of the common pool stock.
    Cooperates initially, then uses average cooperation rate and stock levels to decide actions.
    Defects in the last round if stock is sufficiently high.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            if self.game_description.n_rounds == 1:
                if state.current_stock >= 0.7 * self.game_description.capacity:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock >= 0.7 * self.game_description.capacity:
                return Action.D
            elif state.current_stock < 0.5 * self.game_description.capacity:
                return Action.C
            else:
                avg_coop = np.mean(history.opponent_actions)
                if avg_coop > 0.7:
                    return Action.C
                else:
                    return Action.D
        elif state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        else:
            avg_coop = np.mean(history.opponent_actions)
            if avg_coop > 0.7:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_269(BaseStrategy):
    """
    Adaptive Threshold Cooperation (ATC) strategy.

    Cooperates initially and if stock is above 50% of capacity. 
    Defects for up to two rounds if stock falls below 50%, then reassesses.
    Defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.round_number == 0:
            return Action.C
        else:
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            threshold = 0.5 * capacity
            if current_stock >= threshold:
                self.punishment_remaining = 0
                return Action.C
            elif self.punishment_remaining > 0:
                self.punishment_remaining -= 1
                return Action.D
            else:
                self.punishment_remaining = 2
                return Action.D

class Strategy_COLLECTIVE_270(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that balances immediate gains with sustainable resource use.
    It uses an adaptive approach with cooperation, defection based on past actions, and forgiveness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        current_round = state.round_number
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        threshold = capacity / 2
        if current_round == 0:
            return Action.C
        elif current_round == self.game_description.n_rounds - 1:
            if current_stock < threshold:
                return Action.D
            else:
                return Action.C
        elif current_stock < threshold:
            return Action.C
        else:
            if len(history.opponent_actions) >= 1:
                recent_rounds = history.opponent_actions[max(0, len(history.opponent_actions) - 3):]
                total_defections = np.sum(~recent_rounds)
                required_max = 0.25 * recent_rounds.shape[0] * n
                if total_defections <= required_max:
                    return Action.C
            if len(history.opponent_actions) >= 1:
                prev_actions = history.opponent_actions[-1]
                prev_defections = np.sum(~prev_actions)
                proportion = prev_defections / n
                if proportion > 0.25:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C

class Strategy_COLLECTIVE_271(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Triggers strategy.
    Cooperates initially and in stable or increasing stock conditions,
    starts defecting if the stock consistently decreases over two consecutive rounds,
    and always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_levels = [game_description.capacity]
        self.previous_round = -1

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            if history is not None:
                for i in range(self.previous_round + 1, state.round_number):
                    if i >= len(history.my_actions):
                        break
                    my_action = history.my_actions[i]
                    opponent_actions = history.opponent_actions[i] if i < history.opponent_actions.shape[0] else np.zeros(0, dtype=bool)
                    n_players = self.game_description.n_players
                    previous_stock = self.stock_levels[-1]
                    if my_action:
                        my_consume = previous_stock / (2 * n_players)
                    else:
                        my_consume = previous_stock / n_players
                    opp_C_count = np.sum(opponent_actions)
                    opp_D_count = n_players - 1 - opp_C_count
                    opp_C_consume = opp_C_count * (previous_stock / (2 * n_players))
                    opp_D_consume = opp_D_count * (previous_stock / n_players)
                    opp_total = opp_C_consume + opp_D_consume
                    total_consume = my_consume + opp_total
                    stock_after = previous_stock - total_consume
                    stock_after = max(0.0, stock_after)
                    capacity = self.game_description.capacity
                    if stock_after <= 0:
                        growth = 0.0
                    else:
                        growth = 2 * stock_after * (1 - stock_after / capacity)
                    new_stock = stock_after + growth
                    new_stock = min(new_stock, capacity)
                    self.stock_levels.append(new_stock)
                    self.previous_round = i
            if len(self.stock_levels) >= 3:
                s1 = self.stock_levels[-3]
                s2 = self.stock_levels[-2]
                s3 = self.stock_levels[-1]
                if s3 < s2 and s2 < s1:
                    return Action.D
            return Action.C

class Strategy_COLLECTIVE_272(BaseStrategy):
    """
    A strategy that cooperates if the previous round's stock exceeds 50% of the capacity, 
    otherwise defects. This balances resource utilization with conservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.last_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            current_stock = state.current_stock
            self.last_stock = current_stock
            if current_stock > 0.5 * self.capacity:
                return Action.C
            else:
                return Action.D
        else:
            if self.last_stock > 0.5 * self.capacity:
                decision = Action.C
            else:
                decision = Action.D
            self.last_stock = state.current_stock
            return decision

class Strategy_COLLECTIVE_273(BaseStrategy):
    """
    Cooperative Punishment with Stock Threshold (CPS) strategy. 
    Starts by cooperating, punishes if others defected, and adapts based on stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        n = self.n_players
        r = self.n_rounds
        if t == 0:
            return Action.C
        if t >= r - 2:
            if state.current_stock < 2 * n:
                return Action.D
            else:
                return Action.C
        prev_t = t - 1
        my_payoff_prev = history.my_payoffs[prev_t]
        my_action_prev = history.my_actions[prev_t]
        if my_action_prev:
            s_prev = my_payoff_prev * (2 * n)
        else:
            s_prev = my_payoff_prev * n
        e_prev = s_prev / 2
        opponent_actions_prev = history.opponent_actions[prev_t]
        all_actions = np.append(opponent_actions_prev, my_action_prev)
        num_c = np.count_nonzero(all_actions)
        num_d = n - num_c
        actual = num_c * (s_prev / (2 * n)) + num_d * (s_prev / n)
        if actual > e_prev:
            return Action.D
        elif state.current_stock >= 2 * n:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_274(BaseStrategy):
    """
    A strategy that cooperates if enough players cooperated in the last round and the stock is sufficient.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_last_action = history.my_actions[-1]
        sum_opponent = sum(history.opponent_actions[-1, :])
        num_cooperators = sum_opponent + (1 if my_last_action else 0)
        cooperation_threshold = self.game_description.n_players / 2.0
        enough_cooperators = num_cooperators > cooperation_threshold
        stock_threshold = 0.5 * self.game_description.capacity
        current_stock = state.current_stock
        above_threshold = current_stock >= stock_threshold
        if enough_cooperators and above_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_275(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Thresholds (ACS) strategy.
    - Cooperates in the first round.
    - Defects in the last round.
    - Cooperates if the stock is above a decreasing threshold and not depleting.
    - Defects if the stock falls below the threshold or is depleting.
    Tracks stock levels to assess depletion trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_levels = []

    def is_stock_depleting(self):
        stock_levels = self.stock_levels
        if len(stock_levels) < 3:
            return False
        last_three = stock_levels[-3:]
        for i in range(1, len(last_three)):
            if last_three[i] >= last_three[i - 1]:
                return False
        return True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_levels.append(state.current_stock)
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock <= 0:
            return Action.D
        else:
            current_round = state.round_number
            r = self.game_description.n_rounds
            progress_ratio = (current_round + 1) / (r + 1)
            cooperation_threshold = self.game_description.capacity * (1 - progress_ratio)
            stock = state.current_stock
            if stock > cooperation_threshold and (not self.is_stock_depleting()):
                action = Action.C
            else:
                action = Action.D
            self.stock_levels.append(stock)
            return action

class Strategy_COLLECTIVE_277(BaseStrategy):
    """
    An adaptive strategy that cooperates initially, defects in the last two rounds, 
    and uses a stock-based threshold to decide actions in earlier rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        threshold = self.game_description.capacity / (self.game_description.n_rounds - state.round_number)
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_278(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = [game_description.capacity]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.stock_history.append(state.current_stock)
        if state.round_number >= self.game_description.n_rounds - 3:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        sum_payoff = history.my_payoffs[-1] + np.sum(history.opponent_payoffs[-1, :])
        average = sum_payoff / self.game_description.n_players
        S_prev = self.stock_history[state.round_number - 1]
        cooperative_share = S_prev / (2 * self.game_description.n_players)
        if average > cooperative_share:
            return Action.D
        my_last_action = history.my_actions[-1]
        opponent_last_actions = history.opponent_actions[-1, :]
        n_defectors = 0
        if my_last_action == 0:
            n_defectors += 1
        n_defectors += len(opponent_last_actions) - np.sum(opponent_last_actions)
        if n_defectors > self.game_description.n_players // 2:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_279(BaseStrategy):
    """
    An adaptive strategy that balances cooperation with defection based on observed stock trends.
    Cooperates initially, defects if the stock decreases for two consecutive rounds,
    and resumes cooperation if the stock recovers after defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_stock = None
        self.second_last_stock = None
        self.defect_flag = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_stock = state.current_stock
            self.second_last_stock = None
            return Action.C
        self.second_last_stock = self.last_stock
        self.last_stock = state.current_stock
        if self.second_last_stock is not None and self.last_stock is not None:
            prior_decrease = self.second_last_stock > self.last_stock
            current_decrease = self.last_stock > state.current_stock
            if prior_decrease and current_decrease:
                self.defect_flag = True
                return Action.D
        if self.defect_flag:
            if state.current_stock > self.last_stock:
                self.defect_flag = False
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_280(BaseStrategy):
    """
    Adaptive Cooperation with Gradual Punishment strategy. Cooperates initially, 
    punishes by defecting for up to two rounds if the stock drops below 90%, 
    and cooperates more in the endgame to preserve remaining resources.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishing = False
        self.punishment_defection_count = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            capacity = self.game_description.capacity
            current_stock = state.current_stock
            n_rounds = self.game_description.n_rounds
            rounds_remaining = n_rounds - state.round_number
            percentage = current_stock / capacity
            if percentage > 0.9:
                self.punishing = False
                self.punishment_defection_count = 0
                return Action.C
            elif percentage > 0.1:
                if self.punishing:
                    if self.punishment_defection_count < 2:
                        self.punishment_defection_count += 1
                        return Action.D
                    else:
                        self.punishing = False
                        self.punishment_defection_count = 0
                        return Action.C
                else:
                    self.punishing = True
                    self.punishment_defection_count = 1
                    return Action.D
            elif rounds_remaining <= 0.1 * n_rounds:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_281(BaseStrategy):
    """
    Adaptive Collective Cooperation (ACC) Strategy
    Balances individual payoffs with collective sustainability through cooperation, reciprocity, and stock conservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        threshold_high = 0.75 * capacity
        threshold_low = 0.5 * capacity
        if current_stock >= threshold_high:
            return Action.C
        elif current_stock <= threshold_low:
            return Action.C
        else:
            last_round_actions = history.opponent_actions[-1, :]
            num_coop = last_round_actions.sum()
            n_opponents = len(last_round_actions)
            half_opponents = n_opponents / 2
            if num_coop >= half_opponents:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_282(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACWP) strategy.

    This strategy starts with cooperation, monitors the cooperation rate and stock level,
    and adaptively switches to defection when necessary to maintain resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        if state.current_stock <= 0.1 * self.game_description.capacity:
            if history is not None:
                last_round = state.round_number - 1
                my_last_action = history.my_actions[last_round]
                opp_last_actions = history.opponent_actions[last_round, :]
                sum_coop = 1 if my_last_action else 0
                sum_coop += np.sum(opp_last_actions)
                avg_coop_last = sum_coop / self.game_description.n_players
                if avg_coop_last < 0.75:
                    return Action.D
            return Action.C
        total_coop = 0.0
        n_players = self.game_description.n_players
        for round_num in range(state.round_number):
            my_action = history.my_actions[round_num]
            opp_actions = history.opponent_actions[round_num, :]
            sum_c = 1 if my_action else 0
            sum_c += np.sum(opp_actions)
            total_coop += sum_c / n_players
        avg_coop = total_coop / state.round_number
        if avg_coop >= 0.75:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_283(BaseStrategy):
    """Adaptive Cooperation with Stock-Based Thresholds strategy for the Common Pool Resource Game."""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_stock = state.current_stock
        lower_threshold = 0.3 * self.capacity
        upper_threshold = 0.7 * self.capacity
        if prev_stock < lower_threshold:
            return Action.C
        elif prev_stock > upper_threshold:
            my_last_coop = history.my_actions[-1]
            opponents_last_coops = history.opponent_actions[-1]
            count_C = sum([my_last_coop] + opponents_last_coops.tolist())
            k = self.n_players / 2
            if count_C >= k:
                return Action.C
            else:
                return Action.D
        else:
            my_last_coop = history.my_actions[-1]
            opponents_last_coops = history.opponent_actions[-1]
            count_C = sum([my_last_coop] + opponents_last_coops.tolist())
            if count_C > self.n_players / 2:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_284(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that balances cooperation and strategic defection.
    Cooperates initially, defects once when the stock drops below 50%, and reverts to cooperation if the stock recovers.
    In the final round, defects if the stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.last_stock = None
        self.last_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_stock = state.current_stock
            self.last_action = Action.C
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            if state.current_stock < 0.25 * self.capacity:
                return Action.D
            else:
                return Action.C
        else:
            current_stock = state.current_stock
            if current_stock > 0.5 * self.capacity:
                self.last_stock = current_stock
                self.last_action = Action.C
                return Action.C
            else:
                if history is not None and history.my_actions.size > 0:
                    prev_action = history.my_actions[-1]
                    if prev_action == Action.C:
                        self.last_stock = current_stock
                        self.last_action = Action.D
                        return Action.D
                self.last_stock = current_stock
                self.last_action = Action.D
                return Action.D

class Strategy_COLLECTIVE_285(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that adapts based on previous actions, stock level, and endgame considerations.
    Cooperates initially, reciprocates cooperation unless defection prevalence exceeds 50%, conserves when stock is low, and defects in the final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        round_num = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_stock < 0.25 * capacity:
            return Action.C
        if round_num >= total_rounds - 2:
            return Action.D
        previous_opp_actions = history.opponent_actions[-1]
        n_defectors = sum((1 - action for action in previous_opp_actions))
        if n_defectors > self.game_description.n_players / 2:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_286(BaseStrategy):
    """
    A strategy that starts with cooperation, defects in the last round,
    and adapts based on stock trends and thresholds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.3 * self.capacity:
            return Action.D
        past_stocks = self.stock_history[:-1]
        k = 3
        relevant_past = past_stocks[-k:] if len(past_stocks) >= k else past_stocks
        if not relevant_past:
            average = 0.0
        else:
            average = sum(relevant_past) / len(relevant_past)
        if state.current_stock < average:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_287(BaseStrategy):
    """
    Threshold-based Strategy for Common Pool Resource Game.
    Cooperates when stock is above 50% of capacity; otherwise, Defects.
    Cooperates in the first round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock > self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_288(BaseStrategy):
    """Adaptive Cooperate-Punish (ACP) strategy for the Common Pool Resource Game."""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        t_prev = state.round_number - 1
        my_defected = 0 if history.my_actions[t_prev] else 1
        opponent_actions = history.opponent_actions[t_prev]
        opponent_defected = sum((0 if action else 1 for action in opponent_actions))
        d_count = my_defected + opponent_defected
        n_players = self.game_description.n_players
        condition1 = d_count <= n_players / 2
        condition2 = state.current_stock >= self.game_description.capacity / 2
        if condition1 and condition2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_289(BaseStrategy):
    """
    A strategy where players cooperate in all rounds except the last one,
    provided the current stock is at least half the capacity. Players defect
    in the final round to maximize their immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            return Action.C if state.current_stock >= 0.5 * self.capacity else Action.D

class Strategy_COLLECTIVE_290(BaseStrategy):
    """
    Adaptive Reciprocity Strategy for the Common Pool Resource Game.
    Balances cooperation with strategic defection to maintain stock sustainability.
    Cooperates initially, punishes defection, and forgives if stock recovers.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        start = max(0, state.round_number - 3)
        recent_opponent_actions = history.opponent_actions[start:state.round_number]
        recent_opponent_actions_flat = recent_opponent_actions.ravel()
        D_count = np.sum(recent_opponent_actions_flat == False)
        action = Action.D if D_count > 1 else None
        if action is None:
            if state.current_stock > 0.5 * capacity:
                action = Action.C
            else:
                action = Action.D
        if history.my_actions.size > 0:
            last_action = history.my_actions[-1]
            if not last_action:
                if state.current_stock > 0.3 * capacity:
                    action = Action.C
        return action

class Strategy_COLLECTIVE_291(BaseStrategy):
    """
    A strategy that begins by Cooperating, then reciprocates based on the majority of previous round.
    Cooperates if stock is below half capacity.
    Implements Forgiveness by re-establishing cooperation if majority returns after a Defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_action = Action.C
            return Action.C
        if state.current_stock < 0.5 * self.game_description.capacity:
            action = Action.C
        else:
            prev_round = state.round_number - 1
            opponent_actions_prev = history.opponent_actions[prev_round]
            n_coop_prev = np.sum(opponent_actions_prev)
            n_players = self.game_description.n_players
            if n_coop_prev > n_players / 2:
                action = Action.C
            else:
                action = Action.D
        self.last_action = action
        return action

class Strategy_COLLECTIVE_292(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and 
    defection based on resource stock levels, employing a threshold-based approach 
    with punishment and forgiveness mechanisms to maintain resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.punishing = False
        self.punishment_start_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        percentage = current_stock / self.capacity
        if self.punishing:
            if current_stock > self.punishment_start_stock:
                self.punishing = False
                return Action.C
            else:
                return Action.D
        elif percentage >= 0.75:
            return Action.C
        elif 0.5 <= percentage < 0.75:
            coop_prob = percentage
            if random.random() < coop_prob:
                return Action.C
            else:
                return Action.D
        else:
            self.punishing = True
            self.punishment_start_stock = current_stock
            return Action.D

class Strategy_COLLECTIVE_294(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels and other players' recent behavior.
    Cooperates initially, punishes when fewer than half cooperate, and adapts based on stock thresholds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if capacity == 0:
            return Action.D
        stock_percent = current_stock / capacity
        if stock_percent > 0.75:
            return Action.C
        elif stock_percent <= 0.25:
            return Action.C
        my_last_action = history.my_actions[-1]
        opponents_last_actions = history.opponent_actions[-1]
        n_cooperators = int(my_last_action) + np.sum(opponents_last_actions)
        n_players = self.game_description.n_players
        half_players = n_players / 2.0
        if n_cooperators >= half_players:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_296(BaseStrategy):
    """
    A strategy that promotes cooperation when the common pool is healthy and 
    a majority of players have previously cooperated, aiming to sustain the 
    resource for long-term payoff while being adaptive to changing dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        s_prev = state.current_stock
        stock_condition = s_prev > self.capacity / 2
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        my_prev_action = history.my_actions[prev_round]
        cooperators = sum(opponent_actions_prev) + my_prev_action
        cooperation_condition = cooperators >= self.n_players / 2
        if stock_condition and cooperation_condition:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_297(BaseStrategy):
    """
    Strategy that cooperates initially and switches to defecting if the stock level after growth falls below 50% of capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        threshold = 0.5 * self.capacity
        if state.current_stock < threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_298(BaseStrategy):
    """
    Cooperate in the first round and while the stock is above 50% of capacity, defect otherwise and in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.C
        if state.current_stock <= self.capacity / 2.0:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_299(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that balances cooperation and defection.
    It starts with cooperation, adapts based on previous players' actions, and switches to defection 
    in the last round. It also prioritizes stock recovery when the stock level is critical.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        threshold = 0.25 * self.capacity
        if current_stock < threshold:
            return Action.C
        t_prev = round_number - 1
        my_prev = history.my_actions[t_prev]
        opponent_prev = history.opponent_actions[t_prev, :]
        sum_opponent = np.sum(opponent_prev)
        total_cooperators = (1 if my_prev else 0) + sum_opponent
        if total_cooperators > self.n_players / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_300(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        if t < 2:
            return Action.C
        capacity = self.game_description.capacity
        threshold = capacity / 2
        n_players = self.game_description.n_players
        S_prev = capacity
        S_afters = []
        for k in range(t):
            my_action = history.my_actions[k]
            n_C = 0
            n_D = 0
            if my_action:
                n_C += 1
            else:
                n_D += 1
            for opponent_action in history.opponent_actions[k]:
                if opponent_action:
                    n_C += 1
                else:
                    n_D += 1
            consumption = n_C * (S_prev / (2 * n_players)) + n_D * (S_prev / n_players)
            S_after = S_prev - consumption
            S_afters.append(S_after)
            growth = 2 * S_after * (1 - S_after / capacity)
            S_prev = min(S_after + growth, capacity)
        if len(S_afters) >= 2:
            s1 = S_afters[-2]
            s2 = S_afters[-1]
            if s1 < threshold and s2 < threshold:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_301(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation 
    and defection based on the state of the common pool. Players cooperate to maintain 
    the stock initially, defect when the stock is depleted significantly, and always 
    defect in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            half_capacity = self.game_description.capacity / 2.0
            current_stock = state.current_stock
            if current_stock > half_capacity:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_302(BaseStrategy):
    """
    A threshold-based strategy for the Common Pool Resource Game.
    Cooperates if the stock is sufficient; otherwise, defects to encourage recovery.
    Defects in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.threshold = 0.75 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.current_stock >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_303(BaseStrategy):
    """
    Adaptive Cooperation with Stock Preservation strategy.

    This strategy starts with cooperation in the first round, defects in the last round,
    and adapts based on the previous round's cooperation and current stock level.
    It defects if the stock drops below half the capacity, promoting stock preservation
    while maximizing individual payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        elif round_number == self.r - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            if current_stock < self.capacity / 2:
                return Action.D
            else:
                prev_round = round_number - 1
                my_prev_action = history.my_actions[prev_round]
                opponents_prev_actions = history.opponent_actions[prev_round, :]
                total_cooperators = int(my_prev_action) + np.sum(opponents_prev_actions)
                n_half = self.n / 2
                if total_cooperators > n_half:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_304(BaseStrategy):
    """A strategy for the Common Pool Resource Game that switch between Cooperate and Defect based on stock levels."""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.epsilon = 1e-09

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif abs(state.current_stock - self.capacity) < self.epsilon:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_306(BaseStrategy):
    """
    Sustainable Cooperation with Adaptive Responses (SCAR) strategy.

    This strategy promotes cooperation during periods of stock abundance, 
    with adaptive responses to maintain sustainability by defecting when 
    the stock is depleted beyond a threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.is_defecting = False

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.n_rounds - 2:
            return Action.D
        if self.is_defecting:
            if state.current_stock > 0.75 * self.capacity:
                self.is_defecting = False
                return Action.C
            else:
                return Action.D
        elif state.current_stock < 0.5 * self.capacity:
            self.is_defecting = True
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_307(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game. Cooperates if the stock is above half capacity, defects otherwise.
    Always cooperates in the first round and defects in the last.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock > self.game_description.capacity / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_308(BaseStrategy):
    """
    Defect in every round regardless of history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        return Action.D

class Strategy_COLLECTIVE_309(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        return Action.C

class Strategy_COLLECTIVE_311(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that adapts based on the stock level and previous cooperation.
    It cooperates initially and in middle rounds if the stock is healthy and most players cooperated before,
    otherwise it defects, especially when the stock is low. Always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        half_capacity = self.capacity / 2
        if current_stock > half_capacity:
            my_last_action = history.my_actions[-1]
            opponent_last_actions = history.opponent_actions[-1]
            coop_count = sum(opponent_last_actions) + (1 if my_last_action else 0)
            if coop_count > self.n_players / 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_312(BaseStrategy):
    """
    Adaptive Reciprocal Cooperation (ARC) Strategy.
    Cooperates initially and in subsequent rounds unless the stock is lower than expected,
    simulating cooperation. If stock is depleted, defects until recovery begins.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_initial_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
            self.prev_initial_stock = state.current_stock
            return action
        else:
            current_stock = state.current_stock
            if current_stock == 0:
                action = Action.D
                self.prev_initial_stock = current_stock
                return action
            if self.prev_initial_stock is None:
                action = Action.C
                return action
            s_prev_initial = self.prev_initial_stock
            expected_total_consumption = s_prev_initial / 2
            s_remaining_expected = s_prev_initial - expected_total_consumption
            growth_expected = 2 * s_remaining_expected * (1 - s_remaining_expected / self.game_description.capacity)
            new_stock_expected = min(s_remaining_expected + growth_expected, self.game_description.capacity)
            if current_stock < new_stock_expected:
                action = Action.D
            else:
                action = Action.C
            self.prev_initial_stock = current_stock
            return action

class Strategy_COLLECTIVE_313(BaseStrategy):
    """
    This strategy decides when to cooperate or defect based on the current stock level and round number.
    It cooperates in the first round, defects in the last round, and defects if the stock falls below 50% of capacity in intermediate rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.round_number == 0:
            return Action.C
        elif state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_314(BaseStrategy):
    """
    A strategy for the Common Pool Resource game that balances cooperation with strategic defection,
    ensuring resource sustainability while adapting to others' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock_threshold = capacity / 2.0
        if state.round_number == 0:
            return Action.C
        is_last_round = state.round_number == r - 1
        current_stock = state.current_stock
        if is_last_round:
            if current_stock > stock_threshold:
                return Action.D
            else:
                return Action.C
        elif current_stock < stock_threshold:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            sum_others = np.sum(history.opponent_actions[prev_round, :])
            coop_count = sum_others + int(my_prev_action)
            coop_rate = coop_count / n
            if coop_rate >= 0.7:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_315(BaseStrategy):
    """A strategy that balances cooperation and defection based on stock levels and historical cooperation rates."""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        n_rounds = self.game_description.n_rounds
        if round_num == n_rounds - 1:
            return Action.D
        elif round_num == 0:
            return Action.C
        sum_coop = 0
        n_players = self.game_description.n_players
        for i in range(round_num):
            my_action = history.my_actions[i]
            my_coop = 1 if my_action else 0
            opponent_coop = sum(history.opponent_actions[i, :])
            sum_coop += my_coop + opponent_coop
        average_coop = sum_coop / (round_num * n_players)
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        stock_threshold = 0.5 * capacity
        if current_stock > stock_threshold:
            if average_coop >= 0.7:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_316(BaseStrategy):
    """
    Adaptive Reciprocal Cooperation Strategy.
    
    This strategy starts by cooperating in the first round, defects in the last round, and adapts based on stock trends.
    It defects if the stock decreases for two consecutive rounds or drops below a threshold, then resumes cooperation once the stock recovers.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.is_defecting = False
        self.threshold = 0.5 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            if current_stock < self.threshold:
                self.is_defecting = True
                return Action.D
            elif self.is_defecting:
                last_stock = self.stock_history[-2] if len(self.stock_history) >= 2 else 0
                if current_stock > last_stock:
                    self.is_defecting = False
                    return Action.C
                else:
                    return Action.D
            elif len(self.stock_history) >= 3:
                prev_prev = self.stock_history[-3]
                prev = self.stock_history[-2]
                if prev < prev_prev and current_stock < prev:
                    self.is_defecting = True
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C

class Strategy_COLLECTIVE_317(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) strategy for the Common Pool Resource Game.
    Cooperates initially, defects in the last round, and cooperates or defects in intermediate 
    rounds based on the number of defectors in the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            opponent_defectors = np.sum(~opponent_actions_prev)
            if not my_prev_action:
                opponent_defectors += 1
            n_players = self.game_description.n_players
            if opponent_defectors > n_players / 2:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_318(BaseStrategy):
    """
    Adaptive Collective Cooperation with Punishment and Conservation Strategy.
    Balances cooperation with strategic defection to maintain resource sustainability
    while deterring exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_active = False
        self.punishment_counter = 0
        self.exploration_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            previous_round = state.round_number - 1
            my_coop = history.my_actions[previous_round]
            other_coop = sum(history.opponent_actions[previous_round, :])
            total_coop = my_coop + other_coop
            cooperation_rate = total_coop / self.game_description.n_players
            if cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        self.exploration_counter += 1
        exploration_trigger = self.exploration_counter >= 10
        if exploration_trigger:
            self.exploration_counter = 0
        previous_round = state.round_number - 1
        my_coop = history.my_actions[previous_round]
        other_coop = sum(history.opponent_actions[previous_round, :])
        total_coop = my_coop + other_coop
        cooperation_rate = total_coop / n_players
        if self.punishment_active and self.punishment_counter > 0:
            action = Action.D
            self.punishment_counter -= 1
            if self.punishment_counter == 0:
                self.punishment_active = False
        elif current_stock < 0.5 * capacity:
            action = Action.C
        elif cooperation_rate > 0.8:
            action = Action.C
        elif exploration_trigger:
            action = Action.D
        else:
            action = Action.C
        if cooperation_rate < 0.8:
            self.punishment_active = True
            self.punishment_counter = 3
        return action

class Strategy_COLLECTIVE_319(BaseStrategy):
    """
    An adaptive strategy based on reciprocity and observed behavior in the Common Pool Resource Game.
    Cooperates initially and switches to Defect if others over-consume.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_stock = state.current_stock
            return Action.C
        prev_round = state.round_number - 1
        s_prev = self.previous_stock
        cooperative_benchmark = s_prev / 2
        current_action_prev = history.my_actions[prev_round]
        other_actions_prev = history.opponent_actions[prev_round]
        actual_consumption = 0.0
        if current_action_prev:
            current_contrib = s_prev / (2 * self.n)
        else:
            current_contrib = s_prev / self.n
        actual_consumption += current_contrib
        for action in other_actions_prev:
            if action:
                contrib = s_prev / (2 * self.n)
            else:
                contrib = s_prev / self.n
            actual_consumption += contrib
        if actual_consumption > cooperative_benchmark:
            action_to_take = Action.D
        else:
            action_to_take = Action.C
        self.previous_stock = state.current_stock
        return action_to_take

class Strategy_COLLECTIVE_320(BaseStrategy):
    """
    A strategy that adapts cooperation based on stock level and past player behavior.
    Cooperates initially, defects if stock is low or insufficient players cooperated.
    Always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_actions = history.opponent_actions[prev_round, :]
            total_coop = 1 if my_prev_action else 0
            total_coop += np.sum(opponents_prev_actions)
            cooperation_rate = total_coop / self.n_players
            if state.current_stock > 0.5 * self.capacity and cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_321(BaseStrategy):
    """
    A strategy for the Common Pool Resource game that balances cooperation and defection based on the current stock level and opponents' previous actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.5 * self.capacity:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            my_defect = 0 if my_prev_action else 1
            opponent_prev_actions = history.opponent_actions[prev_round]
            opponent_defect = sum((1 for action in opponent_prev_actions if not action))
            total_defect_prev = my_defect + opponent_defect
            if total_defect_prev > self.n_players / 2:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_322(BaseStrategy):
    """
    A strategy to maintain maximum long-term payoffs in a Common Pool Resource Game.
    Players cooperate initially, punish by defecting once if the stock drops below capacity,
    then resume cooperation if the stock recovers towards capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < self.capacity:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_323(BaseStrategy):
    """
    A strategy that balances cooperation and defection to maintain sustainable resource use. 
    Players cooperate initially, defect in the final round, and cooperate in intermediate rounds if the resource is healthy and few defected previously.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            opponent_prev = history.opponent_actions[prev_round, :]
            opponent_D = (~opponent_prev).sum()
            my_prev = history.my_actions[prev_round]
            num_D = opponent_D + (0 if my_prev else 1)
            half = self.game_description.n_players / 2
            above_half = num_D < half
            over_half_capacity = state.current_stock > 0.5 * self.game_description.capacity
            if above_half and over_half_capacity:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_324(BaseStrategy):
    """
    A strategy that combines cooperation with retaliatory defection, adapting based on observed behavior and stock levels.
    Cooperates initially, retaliates against high defection rates, and adapts based on stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < 0.1 * capacity:
            return Action.D
        if current_stock >= 0.8 * capacity:
            return Action.C
        if current_stock < 0.5 * capacity:
            return Action.D
        prev_round = state.round_number - 1
        my_last_action = history.my_actions[prev_round]
        total_defectors = 0
        if not my_last_action:
            total_defectors += 1
        for opponent_action in history.opponent_actions[prev_round]:
            if not opponent_action:
                total_defectors += 1
        n_players = self.game_description.n_players
        defection_rate = total_defectors / n_players
        if defection_rate > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_325(BaseStrategy):
    """
    A threshold-based strategy where players cooperate if the current stock is above 75% of capacity and defect otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        threshold = 0.75 * self.capacity
        if state.current_stock >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_327(BaseStrategy):
    """
    Cooperative Threshold with Recovery Mechanism Strategy.
    
    Cooperates if the current stock is above 75% of capacity, otherwise defects.
    The first round is always cooperative.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.75 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock >= self.threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_328(BaseStrategy):
    """
    Adaptive Cooperation with Stock Threshold Strategy.
    Cooperates unless stock falls below half capacity, defects otherwise, and always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.round_number == 0:
            return Action.C
        else:
            threshold = self.game_description.capacity / 2.0
            if state.current_stock > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_329(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Trigger (ACST) strategy.
    Cooperates initially, then adapts based on stock levels and trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        self.stock_history.append(current_stock)
        if round_num == 0:
            return Action.C
        elif round_num == self.game_description.n_rounds - 1:
            return Action.D
        else:
            threshold = 0.75 * self.game_description.capacity
            if current_stock > threshold:
                prev_stock = self.stock_history[-2]
                if current_stock >= prev_stock:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_COLLECTIVE_330(BaseStrategy):
    """
    Adaptive Threshold Cooperation (ATC) strategy for the Common Pool Resource Game.
    Cooperates in the first round, defects in the last round, and cooperates when the stock 
    is above 50% of capacity, otherwise defects. Always defects if stock is zero.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.current_stock == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.C
        if state.current_stock / self.game_description.capacity > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_332(BaseStrategy):
    """
    A strategy that cooperates when the stock is above 75% of capacity, 
    and defects otherwise. Always cooperates in the first round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock > 0.75 * self.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_333(BaseStrategy):
    """
    Adaptive Cooperation with Monitoring (ACM) strategy for a Common Pool Resource game.
    This strategy balances individual gains with sustainability by cooperating initially, 
    monitoring others' actions, and adapting based on stock levels and collective behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_num = state.round_number - 1
        prev_my_action = history.my_actions[prev_round_num]
        opp_actions_prev = history.opponent_actions[prev_round_num, :]
        defect_count = 0
        if not prev_my_action:
            defect_count += 1
        defect_count += np.sum(opp_actions_prev == False)
        defect_rate = defect_count / self.game_description.n_players
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        stock_proportion = current_stock / capacity
        n_rounds = self.game_description.n_rounds
        is_last_round = state.round_number == n_rounds - 1
        if stock_proportion <= 0.2:
            return Action.C
        elif stock_proportion >= 0.8:
            if is_last_round:
                return Action.D
            else:
                return Action.C
        elif is_last_round:
            return Action.C
        elif defect_rate <= 0.25:
            return Action.C
        elif defect_rate > 0.5:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_334(BaseStrategy):
    """
    A strategy that starts with cooperation and adapts based on stock levels and trends.
    Cooperates if stock is above 70% of capacity and no downward trend, otherwise defects.
    Defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        threshold = 0.7 * self.game_description.capacity
        current_stock = state.current_stock
        if current_stock > threshold:
            trend_down = self.analyze_trend()
            if not trend_down:
                return Action.C
        return Action.D

    def analyze_trend(self) -> bool:
        """
        Checks if the stock history indicates a downward trend.
        A downward trend is defined as two consecutive decreases in stock levels.
        """
        stock_history = self.stock_history
        if len(stock_history) >= 3:
            if stock_history[-3] > stock_history[-2] and stock_history[-2] > stock_history[-1]:
                return True
        elif len(stock_history) >= 2:
            if stock_history[-2] > stock_history[-1]:
                return True
        return False

class Strategy_COLLECTIVE_335(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) strategy for Common Pool Resource Game.
    Cooperates initially and in the last round, continues cooperating if sufficient players cooperated and the stock is healthy,
    otherwise defects as punishment if the stock is too low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        previous_round = state.round_number - 1
        prev_stock = state.current_stock
        capacity = self.game_description.capacity
        my_coop = history.my_actions[previous_round]
        opponent_coops = np.sum(history.opponent_actions[previous_round, :])
        total_coop = my_coop + opponent_coops
        cooperation_rate = total_coop / self.game_description.n_players
        if cooperation_rate >= 0.8 and prev_stock >= 0.75 * capacity:
            return Action.C
        elif prev_stock < 0.5 * capacity:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_338(BaseStrategy):
    """
    Adaptive Cooperation with Sustainability strategy.
    Cooperates in the first round. In subsequent rounds, cooperates if stock is above 50% and previous round had fewer than half defecting. Defects in the last two rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        if state.round_number >= n_rounds - 2:
            return Action.D
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_stock <= 0.5 * capacity:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        n_defectors = 0
        if not my_prev_action:
            n_defectors += 1
        opponent_actions_prev = history.opponent_actions[prev_round]
        for action in opponent_actions_prev:
            if not action:
                n_defectors += 1
        n_players = self.game_description.n_players
        if n_defectors < n_players / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_339(BaseStrategy):
    """
    Adaptive strategy for the Common Pool Resource Game aiming to balance individual gain with sustainability.
    Cooperates initially, adapts based on stock levels and trends, and defects when necessary to manage resource depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_levels = []
        self.in_defect_mode = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        round_number = state.round_number
        self.stock_levels.append(state.current_stock)
        if round_number == 0:
            return Action.C
        if round_number == self.game_description.n_rounds - 1:
            if state.current_stock > 0.5 * capacity:
                return Action.C
            else:
                return Action.D
        if state.current_stock < 0.3 * capacity:
            self.in_defect_mode = False
            return Action.C
        if self.in_defect_mode:
            if state.current_stock > 0.6 * capacity:
                self.in_defect_mode = False
                return Action.C
            else:
                return Action.D
        two_round_decline = False
        if len(self.stock_levels) >= 3:
            s_prev_prev = self.stock_levels[-3]
            s_prev = self.stock_levels[-2]
            s_current = self.stock_levels[-1]
            if s_prev < s_prev_prev and s_current < s_prev:
                two_round_decline = True
        if state.current_stock < 0.5 * capacity or two_round_decline:
            self.in_defect_mode = True
            return Action.D
        elif state.current_stock > 0.7 * capacity:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_340(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation 
    and defection based on stock levels and previous cooperation rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.high_stock_threshold = 0.5 * self.capacity
        self.low_stock_threshold = 0.25 * self.capacity
        self.cooperation_threshold = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        my_prev_action = history.my_actions[-1]
        opp_prev_actions = history.opponent_actions[-1, :]
        my_coop = 1 if my_prev_action else 0
        opp_coop = sum(opp_prev_actions)
        total_coop = my_coop + opp_coop
        cooperation_rate = total_coop / self.n_players
        current_stock = state.current_stock
        if current_stock > self.high_stock_threshold and cooperation_rate >= self.cooperation_threshold or current_stock < self.low_stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_341(BaseStrategy):
    """
    Adaptive Cooperative Sustainability Strategy.

    This strategy aims to maximize collective payoff by balancing immediate gains with 
    long-term sustainability through adaptive cooperation and strategic defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = 0.75 * self.capacity
        self.critical_level = 0.25 * self.capacity
        self.stock_trend_window = 3
        self.recent_defect_threshold = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.n_rounds - 1:
            return Action.C
        stock_levels = [self.capacity]
        current_stock = self.capacity
        for round in range(state.round_number):
            if history is None:
                break
            my_action = history.my_actions[round]
            opponent_actions = history.opponent_actions[round, :].tolist()
            all_actions = [my_action] + opponent_actions
            total_consumption = 0.0
            for action in all_actions:
                if action:
                    consumption = current_stock / (2 * self.n_players)
                else:
                    consumption = current_stock / self.n_players
                total_consumption += consumption
            S_remaining = current_stock - total_consumption
            S_remaining = max(0, S_remaining)
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
            new_stock = S_remaining + growth
            new_stock = min(new_stock, self.capacity)
            stock_levels.append(new_stock)
            current_stock = new_stock
        if state.current_stock < self.critical_level:
            return Action.C
        recent_defectors = 0
        recent_rounds = history.my_actions.shape[0] if history else 0
        start_round = max(0, recent_rounds - self.stock_trend_window)
        for r in range(start_round, recent_rounds):
            my_action = history.my_actions[r]
            others_actions = history.opponent_actions[r, :].tolist()
            all_actions = [my_action] + others_actions
            defectors = sum((not a for a in all_actions))
            recent_defectors += defectors
        numerator = recent_defectors
        num_rounds = max(1, recent_rounds - start_round)
        denominator = num_rounds * self.n_players
        proportion_defect = numerator / denominator
        if proportion_defect > self.recent_defect_threshold:
            return Action.D
        trend = self.get_stock_trend(stock_levels[-self.stock_trend_window:])
        if trend in ['increasing', 'stable'] and state.current_stock >= self.threshold:
            return Action.C
        else:
            return Action.D

    def get_stock_trend(self, stock_levels: list[float]) -> str:
        """
        Determine stock trend based on the given stock levels.
        Returns 'increasing', 'stable', or 'decreasing'.
        """
        if len(stock_levels) < 2:
            return 'stable'
        first = stock_levels[0]
        last = stock_levels[-1]
        if last > first:
            return 'increasing'
        elif last < first:
            return 'decreasing'
        else:
            return 'stable'

class Strategy_COLLECTIVE_342(BaseStrategy):
    """
    An adaptive strategy that cooperates initially and switches to defection 
    when the stock starts to deplete or in the final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.consecutive_decreases = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            action = Action.C
            self.stock_history.append(state.current_stock)
            return action
        else:
            self.stock_history.append(state.current_stock)
            remaining_rounds = self.game_description.n_rounds - state.round_number - 1
            if remaining_rounds <= 2:
                return Action.D
            current_stock = self.stock_history[-1]
            previous_stock = self.stock_history[-2]
            if current_stock < previous_stock:
                self.consecutive_decreases += 1
            else:
                self.consecutive_decreases = 0
            if self.consecutive_decreases >= 2:
                return Action.D
            return Action.C

class Strategy_COLLECTIVE_343(BaseStrategy):
    """
    A strategy designed for the Common Pool Resource Game that adapts based on observed behavior and current resource levels.
    It encourages cooperation under favorable conditions while safeguarding against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_round_idx = state.round_number - 1
        my_prev_action = history.my_actions[prev_round_idx]
        my_prev_payoff = history.my_payoffs[prev_round_idx]
        if my_prev_action:
            s_prev = my_prev_payoff * 2 * self.n_players
        else:
            s_prev = my_prev_payoff * self.n_players
        my_consumption = s_prev / (2 * self.n_players) if my_prev_action else s_prev / self.n_players
        opp_actions = history.opponent_actions[prev_round_idx, :]
        opp_consumption = 0.0
        for action in opp_actions:
            if action:
                opp_consumption += s_prev / (2 * self.n_players)
            else:
                opp_consumption += s_prev / self.n_players
        total_consumption = my_consumption + opp_consumption
        condition1 = total_consumption <= s_prev / 2
        condition2 = state.current_stock >= 0.6 * self.capacity
        if condition1 and condition2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_345(BaseStrategy):
    """
    Adaptive Cooperate-Punish with Stock Monitoring Strategy.

    This strategy starts with cooperation, punishes defectors if more than half of 
    players defected last round, defects if the stock falls below an adaptive threshold, 
    and ensures cooperation in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            return Action.C
        my_defect = 1 if not history.my_actions[-1] else 0
        opponent_defectors = np.sum(1 - history.opponent_actions[-1, :])
        total_defectors = my_defect + opponent_defectors
        n_players = self.game_description.n_players
        condition_a = total_defectors > n_players / 2
        capacity = self.game_description.capacity
        threshold = 0.5 * (1 - state.round_number / (n_rounds - 1)) * capacity
        condition_b = state.current_stock < threshold
        if condition_a or condition_b:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_346(BaseStrategy):
    """
    A strategy that combines cooperation with punishment for sustained resource management.
    It starts with cooperation, punishes when others defect excessively, and ensures stock sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.punishment_rounds = 3
        self.sustainability_threshold = 0.2 * game_description.capacity
        self.in_punishment = False
        self.punishment_countdown = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock <= self.sustainability_threshold:
            return Action.C
        if self.in_punishment:
            self.punishment_countdown -= 1
            if self.punishment_countdown <= 0:
                self.in_punishment = False
            return Action.D
        else:
            sum_coop = 0
            n_prev_rounds = state.round_number
            for t in range(n_prev_rounds):
                sum_coop += np.sum(history.opponent_actions[t])
            other_players = self.game_description.n_players - 1
            if other_players == 0:
                average_coop = 1.0
            else:
                average_coop = sum_coop / (n_prev_rounds * other_players)
            if average_coop < self.cooperation_threshold:
                self.in_punishment = True
                self.punishment_countdown = self.punishment_rounds
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_347(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels.
    Cooperates initially and defects if the stock is depleting. Forgiveness mechanism to revert to cooperation if stock recovers.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.threshold = 0.5 * self.capacity
        self.recent_rounds = 3

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        past_stocks = []
        for t in range(current_round):
            if t >= len(history.my_actions):
                continue
            action = history.my_actions[t]
            payoff = history.my_payoffs[t]
            if action:
                stock = payoff * 2 * self.n_players
            else:
                stock = payoff * self.n_players
            past_stocks.append(stock)
        start = max(0, len(past_stocks) - self.recent_rounds)
        recent_stocks = past_stocks[start:]
        if len(recent_stocks) == 0:
            avg_stock = 0.0
        else:
            avg_stock = np.mean(recent_stocks)
        is_last_round = current_round == self.n_rounds - 1
        if is_last_round:
            if current_stock < self.threshold:
                return Action.D
            else:
                return Action.C
        elif avg_stock < self.threshold and current_stock < self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_46(BaseStrategy):
    """
    Collective Strategy for Common Pool Resource Game.
    Cooperates initially and adaptively based on cooperation rates and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_stock = state.current_stock
        if current_stock < 0.5 * self.capacity:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        num_coop = my_prev_action + np.sum(opponent_prev_actions)
        if num_coop > 0.75 * self.n_players:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_64(BaseStrategy):
    """
    Adaptive Sustainability with Reciprocity (ASR) strategy. 
    It encourages initial cooperation, adapts based on stock levels, 
    reciprocates others' actions, and considers growth trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        game = self.game_description
        capacity = game.capacity
        n = game.n_players
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        if state.round_number == game.n_rounds - 1:
            self.stock_history.append(state.current_stock)
            if state.current_stock > 0.7 * capacity:
                return Action.D
            else:
                return Action.C
        if state.current_stock < 0.3 * capacity:
            self.stock_history.append(state.current_stock)
            return Action.C
        if state.round_number < 5:
            self.stock_history.append(state.current_stock)
            return Action.C
        opponent_actions_last = history.opponent_actions[-1]
        n_defectors = len(opponent_actions_last) - np.sum(opponent_actions_last)
        percent_defectors = n_defectors / n * 100
        if percent_defectors >= 30:
            self.stock_history.append(state.current_stock)
            return Action.D
        else:
            stock = state.current_stock
            if stock < 0.5 * capacity:
                self.stock_history.append(state.current_stock)
                return Action.C
            elif stock >= 0.9 * capacity:
                if len(self.stock_history) >= 2:
                    s_prev = self.stock_history[-1]
                    s_prev_prev = self.stock_history[-2]
                    if s_prev > s_prev_prev and stock > s_prev:
                        self.stock_history.append(state.current_stock)
                        return Action.D
                    else:
                        self.stock_history.append(state.current_stock)
                        return Action.C
                else:
                    self.stock_history.append(state.current_stock)
                    return Action.C
            else:
                self.stock_history.append(state.current_stock)
                return Action.C

class Strategy_COLLECTIVE_106(BaseStrategy):
    """
    Adaptive Conservation with Reciprocal Punishment (ACRP) strategy.
    This strategy balances cooperation and defection based on stock levels and previous actions.
    It promotes sustainability by conserving the stock when necessary and punishes defectors to maintain cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if state.current_stock < 0.1 * capacity:
            return Action.C
        if state.round_number >= n_rounds - 2:
            if state.current_stock > 0.5 * capacity:
                return Action.D
            else:
                return Action.C
        if state.current_stock < 0.5 * capacity:
            return Action.C
        prev_round = state.round_number - 1
        if history is None:
            return Action.C
        my_action_prev = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        all_actions_prev = np.append([my_action_prev], opponent_actions_prev)
        num_defectors = np.sum(~all_actions_prev)
        if num_defectors > n_players / 2:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_108(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness strategy balances immediate gains with long-term sustainability
    by using dynamic thresholds, reciprocity, and sustainability checks to decide actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.n_opponents = game_description.n_players - 1
        self.capacity = game_description.capacity
        self.K = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        self.stock_history.append(state.current_stock)
        current_stock = state.current_stock
        p_sustainability = 1 - current_stock / (2 * self.capacity)
        p_sustainability = max(0, min(1, p_sustainability))
        if len(self.stock_history) >= 2:
            previous_stock = self.stock_history[-2]
            current_stock_before = self.stock_history[-1]
            delta = current_stock_before - previous_stock
            max_delta = 0.5 * self.capacity
            trend = delta / max_delta
            trend_factor = 0.5 + trend * 0.5
            trend_factor = max(0, min(1, trend_factor))
        else:
            trend_factor = 0.5
        p_sustainability *= (1 + trend_factor) / 2
        p_sustainability = max(0, min(1, p_sustainability))
        sum_coop = 0
        if history is not None and len(history.opponent_actions) >= 1:
            for i in range(1, self.K + 1):
                round_idx = state.round_number - i
                if round_idx < 0:
                    break
                opp_actions = history.opponent_actions[round_idx]
                sum_coop += sum(opp_actions)
            avg_coop_prop = sum_coop / (self.K * self.n_opponents) if self.K * self.n_opponents != 0 else 0
        else:
            avg_coop_prop = 0
        p_reciprocity = avg_coop_prop
        p_total = p_sustainability * p_reciprocity
        p_total = max(0, min(1, p_total))
        if random.random() < p_total:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_110(BaseStrategy):
    """
    Adaptive Cooperation with Punishment and Forgiveness Strategy.
    Cooperates initially, then adapts based on cooperation rate and stock level.
    Defects when stock is critically low, and cooperates in final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round]
        total_coop = my_prev_action + np.sum(opp_prev_actions)
        cooperation_rate = total_coop / self.game_description.n_players
        if cooperation_rate > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_204(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that combines cooperation with adaptive responses 
    based on stock levels and opponent actions. The strategy starts with cooperation and adjusts based 
    on environmental and social factors to balance individual gain with sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.n_rounds - 2:
            return Action.D
        current_stock = state.current_stock
        stock_threshold = 0.75 * self.capacity
        if current_stock > stock_threshold:
            return Action.C
        my_last_action = history.my_actions[-1]
        my_last_defect = not my_last_action
        last_opponent_actions = history.opponent_actions[-1]
        opp_defect_last_round = np.count_nonzero(~last_opponent_actions)
        total_defect_last = opp_defect_last_round + (1 if my_last_defect else 0)
        prop_defect = total_defect_last / self.n_players
        if prop_defect > 0.5:
            return Action.D
        if opp_defect_last_round > 0:
            return Action.D
        recent_defection = False
        for i in range(1, 3):
            prev_round = state.round_number - i
            if prev_round < 0:
                continue
            prev_opponent_actions = history.opponent_actions[prev_round]
            if np.any(~prev_opponent_actions):
                recent_defection = True
                break
        if recent_defection:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_212(BaseStrategy):
    """
    Strategic Approach for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.stock_levels = [self.capacity]
        self.consecutive_high = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        current_stock = state.current_stock
        capacity = self.capacity
        current_stock_percent = current_stock / capacity
        if state.round_number == 0:
            self.consecutive_high = 1 if current_stock > 0.9 * capacity else 0
            return Action.C
        self.stock_levels.append(current_stock)
        if self.consecutive_high >= 3:
            self.consecutive_high = 0
            return Action.C
        if state.round_number == self.n_rounds - 1:
            previous_stock = self.stock_levels[-2]
            if previous_stock > 0.9 * capacity:
                return Action.C
            else:
                return Action.D
        if current_stock_percent < 0.5:
            return Action.D
        elif 0.5 <= current_stock_percent <= 0.9:
            prev_round = state.round_number - 1
            prev_my_action = history.my_actions[prev_round]
            prev_opponents = history.opponent_actions[prev_round]
            n_coop = sum(prev_opponents) + (1 if prev_my_action else 0)
            threshold = (self.n_players + 1) // 2
            if n_coop >= threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C
        if current_stock_percent > 0.9:
            self.consecutive_high += 1
        else:
            self.consecutive_high = 0

class Strategy_COLLECTIVE_217(BaseStrategy):
    """
    A strategy that adjusts cooperation based on stock level and previous defections.
    Uses two thresholds: one for the current stock and one for the number of defectors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_th = 40.0
        self.T_defect = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_actions = history.opponent_actions[-1]
        prev_defectors = sum((1 for action in prev_actions if not action))
        current_stock = state.current_stock
        if current_stock < self.S_th:
            return Action.C
        elif prev_defectors > self.T_defect:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_221(BaseStrategy):
    """
    A strategy that balances cooperation with strategic defection to protect resources 
    and maximize payoffs, adapting based on both the stock level and others' past actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            threshold_stock = 0.2 * self.capacity
            if current_stock < threshold_stock:
                return Action.C
            else:
                prev_round = state.round_number - 1
                my_prev_action = history.my_actions[prev_round]
                opponent_prev_actions = history.opponent_actions[prev_round]
                opponent_defections = len(opponent_prev_actions) - np.sum(opponent_prev_actions)
                my_defection = 0 if my_prev_action else 1
                total_defectors = opponent_defections + my_defection
                threshold = math.ceil(self.n_players / 2)
                if total_defectors >= threshold:
                    return Action.D
                else:
                    return Action.C

class Strategy_COLLECTIVE_224(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if history is None:
            return Action.C
        elif current_round == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = current_round - 1
            own_prev_action = history.my_actions[prev_round]
            own_prev_payoff = history.my_payoffs[prev_round]
            n_players = self.game_description.n_players
            if own_prev_action:
                s_prev = own_prev_payoff * 2 * n_players
            else:
                s_prev = own_prev_payoff * n_players
            opponent_actions_prev = history.opponent_actions[prev_round]
            all_actions = [own_prev_action] + opponent_actions_prev.tolist()
            total_consumption = 0.0
            for action in all_actions:
                if action:
                    total_consumption += s_prev / (2 * n_players)
                else:
                    total_consumption += s_prev / n_players
            if total_consumption > s_prev / 2:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_230(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances 
    cooperation and self-interest based on observed stock trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.strategy_state = 'Cooperate'

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        elif current_round == self.n_rounds - 1:
            return Action.D
        else:
            stock_levels = [current_stock]
            if history is not None:
                for r in range(len(history.my_payoffs)):
                    payoff = history.my_payoffs[r]
                    action = history.my_actions[r]
                    if action:
                        s = payoff * 2 * self.n_players
                    else:
                        s = payoff * self.n_players
                    stock_levels.append(s)
            window_size = min(3, len(stock_levels) - 1)
            recent_stocks = stock_levels[-window_size:]
            is_decreasing = True
            for i in range(len(recent_stocks) - 1):
                if recent_stocks[i] < recent_stocks[i + 1]:
                    is_decreasing = False
                    break
            lower_threshold = self.capacity / (2 * self.n_players)
            upper_threshold = self.capacity / self.n_players
            if self.strategy_state == 'Cooperate':
                if current_stock < lower_threshold or is_decreasing:
                    self.strategy_state = 'Defect'
                    return Action.D
                else:
                    return Action.C
            elif current_stock > upper_threshold:
                self.strategy_state = 'Cooperate'
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_241(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and punishment to maintain stock sustainability.
    Cooperates under favorable conditions and punishes when defection is prevalent, while ensuring stock regeneration and sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if state.round_number >= n_rounds - 2:
            return Action.C
        if self.punishment_remaining > 0:
            action = Action.D
            self.punishment_remaining -= 1
        else:
            capacity = self.game_description.capacity
            current_stock = state.current_stock
            stock_ratio = current_stock / capacity if capacity != 0 else 0.0
            if stock_ratio < 0.5:
                action = Action.C
            else:
                prev_round = state.round_number - 1
                my_prev_act = history.my_actions[prev_round]
                opponent_prev_acts = history.opponent_actions[prev_round, :]
                n_coops = 1 if my_prev_act else 0
                n_coops += sum(opponent_prev_acts)
                if n_coops >= 0.7 * n_players:
                    action = Action.C
                else:
                    action = Action.D
        if history is not None and state.round_number >= 1:
            prev_round = state.round_number - 1
            my_prev_act = history.my_actions[prev_round]
            opponent_prev_acts = history.opponent_actions[prev_round, :]
            my_defect = 0 if my_prev_act else 1
            opponent_defects = sum((0 if act else 1 for act in opponent_prev_acts))
            total_defectors = my_defect + opponent_defects
            if total_defectors > n_players / 2:
                self.punishment_remaining = 2
        return action

class Strategy_COLLECTIVE_254(BaseStrategy):
    """
    Adaptive Reciprocity with Stock Sustainability Strategy.
    Cooperates initially and adapts based on stock levels and others' past actions.
    Defects in critical stock conditions or when cooperation is not reciprocated.
    Maximizes immediate gain in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.2 * self.game_description.capacity:
            return Action.D
        prev_actions = history.opponent_actions[-1]
        coop_count = np.sum(prev_actions)
        coop_prop = coop_count / self.game_description.n_players
        capacity = self.game_description.capacity
        if state.current_stock > 0.8 * capacity and coop_prop >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_256(BaseStrategy):
    """A strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels and recent cooperation."""

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number >= self.n_rounds - 2:
            return Action.D
        elif state.current_stock > 0.5 * self.capacity:
            required = math.ceil(self.n_players / 2)
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators >= required:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_260(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Triggers Strategy.
    Promotes cooperation when sustainable, adapts based on stock levels and player actions.
    Cooperates initially, defects in endgame, and adapts based on triggers.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C
        if state.round_number >= n_rounds - 2:
            return Action.D
        current_stock = state.current_stock
        if current_stock < 0.5 * capacity:
            return Action.D
        last_round = state.round_number - 1
        my_prev_action = history.my_actions[last_round]
        opponent_actions_last = history.opponent_actions[last_round]
        my_coop = my_prev_action
        opponent_coop = np.sum(opponent_actions_last)
        total_coop = my_coop + opponent_coop
        majority_coop = total_coop > n_players / 2
        my_defect_last = my_prev_action == False
        opponent_defectors = np.count_nonzero(opponent_actions_last == False)
        total_defectors = my_defect_last + opponent_defectors
        proportion_defectors = total_defectors / n_players
        if proportion_defectors > 0.3:
            return Action.D
        if current_stock > 0.75 * capacity and majority_coop:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_261(BaseStrategy):
    """
    Adaptive Cooperation with Punishment strategy for the Common Pool Resource Game.
    Cooperates initially, punishes defection, recovers stock when low, and adjusts in endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.critical_stock = 0.5 * self.capacity
        self.endgame_threshold = 0.8 * self.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number >= self.endgame_threshold:
            if state.current_stock > 0.7 * self.capacity:
                return Action.D
            else:
                return Action.C
        else:
            actual_consumption = 0.0
            if history is not None:
                my_payoff_prev = history.my_payoffs[-1]
                opponent_payoffs_prev = history.opponent_payoffs[-1, :]
                actual_consumption = my_payoff_prev + sum(opponent_payoffs_prev)
            expected_C = state.current_stock / 2
            if state.current_stock < self.critical_stock:
                return Action.C
            elif actual_consumption > expected_C:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_266(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Thresholds (ACST) strategy for the Common Pool Resource game.
    Cooperates initially, defects if stock is over-exploited, and forgives when the stock recovers.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = [game_description.capacity]
        self.punishing = False
        self.last_defected_stock = 0.0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        self.stock_history.append(current_stock)
        capacity = self.game_description.capacity
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds - 1:
            return Action.D
        if current_stock < 0.5 * capacity:
            return Action.D
        if self.punishing:
            if current_stock > self.last_defected_stock:
                self.punishing = False
                return Action.C
            else:
                return Action.D
        significant_decrease = False
        if current_stock < 0.75 * capacity:
            significant_decrease = True
        elif len(self.stock_history) >= 3:
            prev_two = self.stock_history[-3]
            prev_one = self.stock_history[-2]
            current = self.stock_history[-1]
            if prev_one < prev_two and current < prev_one:
                significant_decrease = True
        if significant_decrease:
            self.last_defected_stock = current_stock
            self.punishing = True
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_276(BaseStrategy):
    """
    Adaptive Cooperation with Punishment and Endgame Optimization Strategy.
    This strategy promotes cooperation while adapting to the stock levels 
    and employing punishment for widespread defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n_rounds = game_description.n_rounds
        initial_coop_rounds = min(math.ceil(0.1 * n_rounds), 5)
        endgame_rounds = min(math.ceil(0.1 * n_rounds), 5)
        self.endgame_start_round = max(n_rounds - endgame_rounds, 0)
        self.initial_coop_rounds = initial_coop_rounds
        self.capacity = game_description.capacity
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round < self.initial_coop_rounds:
            return Action.C
        if current_round >= self.endgame_start_round:
            if state.current_stock > 0.75 * self.capacity:
                return Action.D
            else:
                return Action.C
        elif self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        elif state.current_stock < 0.5 * self.capacity:
            return Action.C
        else:
            opponent_actions_prev = history.opponent_actions[-1, :]
            n_opponent_defectors = np.sum(opponent_actions_prev == False)
            my_prev_action = history.my_actions[-1]
            my_defected = my_prev_action == False
            total_defectors = n_opponent_defectors + (1 if my_defected else 0)
            n_players = self.game_description.n_players
            if total_defectors > n_players // 2:
                self.punishment_remaining = 3
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_293(BaseStrategy):
    """
    This strategy adapts based on past defections and stock levels to balance cooperation and defection.
    It starts by cooperating, then defects if too many players have defected or if the stock is low.
    In the last round, it cooperates if the stock is sufficient; otherwise, it defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock >= 0.5 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        t = state.round_number
        total_defections = 0
        for round in range(t):
            if not history.my_actions[round]:
                total_defections += 1
            for opponent in range(self.game_description.n_players - 1):
                if not history.opponent_actions[round, opponent]:
                    total_defections += 1
        threshold = 0.2 * self.game_description.n_players * t
        critical_stock = 0.5 * self.game_description.capacity
        if total_defections > threshold or state.current_stock < critical_stock:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_295(BaseStrategy):
    """
    Implements a strategy that cooperates initially and defects if previous round's consumption was unsustainable.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_minus_1 = state.round_number - 1
        my_action = history.my_actions[t_minus_1]
        my_payoff = history.my_payoffs[t_minus_1]
        if my_action:
            s_prev = my_payoff * 2 * self.n
        else:
            s_prev = my_payoff * self.n
        total_consumption = my_payoff + history.opponent_payoffs[t_minus_1].sum()
        if total_consumption > 0.5 * s_prev:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_305(BaseStrategy):
    """
    Adaptive Cooperation with Triggering Strategy.
    Cooperates initially and in rounds where stock is sufficient and others cooperated.
    Defects if stock is low or others defected, especially in last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_stock = None
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            self.prev_stock = state.current_stock
            return Action.C
        current_stock = state.current_stock
        if self.prev_stock is not None:
            delta = current_stock - self.prev_stock
        else:
            delta = 0.0
        self.prev_stock = current_stock
        opponent_actions_previous_round = history.opponent_actions[-1, :]
        prev_coops = sum(opponent_actions_previous_round)
        cooperate_threshold = math.ceil(self.n / 2)
        if current_stock >= self.capacity / 2:
            if prev_coops >= cooperate_threshold:
                return Action.C
            else:
                return Action.D
        elif prev_coops < cooperate_threshold or delta < 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_331(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource game that balances cooperation
    with strategic retaliation to maintain sustainable stock levels while maximizing payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            stock_threshold = 0.5 * self.capacity
            if state.current_stock >= stock_threshold:
                return Action.C
            else:
                return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round, :]
            defector_count = 0
            if not my_prev_action:
                defector_count += 1
            opponent_defectors = len(opp_prev_actions) - np.sum(opp_prev_actions)
            defector_count += opponent_defectors
            threshold_defectors = 0.2 * self.n_players
            stock_threshold = 0.5 * self.capacity
            if state.current_stock < stock_threshold or defector_count > threshold_defectors:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_336(BaseStrategy):
    """
    A strategy that begins with cooperation and responds to excessive defection.
    Players cooperate initially. In subsequent rounds, they defect if more than 20% of the players defected in the previous round.
    Otherwise, they continue to cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_opponent_actions = history.opponent_actions[-1]
        sum_last_coop = np.sum(last_opponent_actions)
        n = self.game_description.n_players
        number_last_defectors = n - 1 - sum_last_coop
        threshold = 0.2 * n
        if number_last_defectors > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_337(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection 
    based on stock levels, opponents' actions, and game progression. It aims to maximize 
    individual and collective payoffs while maintaining resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.listeners_defection_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.C
        if state.current_stock <= self.game_description.capacity / 2:
            return Action.C
        prev_coop = sum(history.opponent_actions[-1, :]) + (1 if history.my_actions[-1] else 0)
        n = self.game_description.n_players
        if prev_coop > n / 2:
            self.listeners_defection_count = 0
            return Action.C
        else:
            self.listeners_defection_count += 1
            if self.listeners_defection_count >= 2:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_348(BaseStrategy):
    """
    A strategy that adapts cooperation based on stock level and game progress.
    Cooperates initially, then cooperates if stock is above 50% capacity, otherwise defects.
    Defects in the last two rounds to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if round_number == 0:
            return Action.C
        elif round_number >= total_rounds - 2:
            return Action.D
        elif current_stock >= 0.5 * capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_349(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances individual payoffs with collective sustainability.
    Cooperates initially, then uses stock level thresholds to decide actions, with endgame adjustments.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        round_number = state.round_number
        n_rounds = self.game_description.n_rounds
        in_final_three = round_number >= n_rounds - 3
        if in_final_three:
            if current_stock > 0.5 * capacity:
                return Action.D
        if capacity == 0:
            stock_pct = 0.0
        else:
            stock_pct = current_stock / capacity
        if stock_pct > 0.75:
            return Action.C
        elif 0.25 < stock_pct < 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_350(BaseStrategy):
    """
    Cooperative Reciprocity with Forgiveness Strategy.
    Cooperates initially, defects if previous consumption indicates defection, then can revert to cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        if history is None:
            return Action.C
        sum_prev = history.my_payoffs[t_prev]
        sum_prev += history.opponent_payoffs[t_prev].sum()
        expected_sum = self.capacity / 2
        return Action.D if sum_prev > expected_sum else Action.C

class Strategy_COLLECTIVE_351(BaseStrategy):
    """
    Cooperative Strategy with Stock Threshold:
    Cooperate if the stock after the previous round is at least 90% of capacity; otherwise defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            threshold = 0.9 * self.capacity
            if state.current_stock >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_352(BaseStrategy):
    """
    This strategy starts by cooperating in the first round, defects in the last round, 
    and adapts based on stock levels and previous cooperation in the middle rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            if state.current_stock == 0:
                return Action.C
            previous_round = state.round_number - 1
            my_coop = history.my_actions[previous_round]
            my_coop_count = 1 if my_coop else 0
            opponent_actions = history.opponent_actions[previous_round]
            opponent_coop = np.sum(opponent_actions)
            total_coop = my_coop_count + opponent_coop
            threshold_stock = self.game_description.capacity / 2
            threshold_coop = self.game_description.n_players / 2
            if state.current_stock > threshold_stock and total_coop >= threshold_coop:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_353(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that promotes cooperation,
    punishes defection, and ensures sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.prev_stock = state.current_stock
            return Action.C
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            self.prev_stock = state.current_stock
            return Action.C
        if state.current_stock < capacity / 2:
            self.prev_stock = state.current_stock
            return Action.C
        S_prev = self.prev_stock
        s_remaining = S_prev / 2
        growth = 2 * s_remaining * (1 - s_remaining / capacity)
        expected_stock = min(s_remaining + growth, capacity)
        if state.current_stock < expected_stock:
            self.prev_stock = state.current_stock
            return Action.D
        else:
            self.prev_stock = state.current_stock
            return Action.C

class Strategy_COLLECTIVE_354(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that adapts based on the stock level and number of players.
    It uses a threshold-based cooperation approach, adjusting the threshold dynamically with the number of players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
        else:
            if len(self.stock_history) == 0:
                avg_stock = 0.0
            else:
                avg_stock = sum(self.stock_history) / len(self.stock_history)
            n = self.game_description.n_players
            capacity = self.game_description.capacity
            if capacity == 0:
                dynamic_threshold = 0.0
            else:
                dynamic_threshold = 0.75 * 4.0 / (n + 2.0) * capacity
            if avg_stock > dynamic_threshold:
                action = Action.C
            else:
                action = Action.D
        self.stock_history.append(state.current_stock)
        return action

class Strategy_COLLECTIVE_355(BaseStrategy):
    """
    Adaptive Cooperation with Stock Threshold (ACS) strategy.
    
    This strategy balances individual gain with collective sustainability by adapting 
    based on the current stock level, past players' actions, and the game's progression.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C
        elif state.round_number == r - 1:
            return Action.D
        else:
            condition_a = state.current_stock > 0.5 * capacity
            prev_round = state.round_number - 1
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            sum_opponent_c = np.sum(opponent_actions_prev)
            my_prev_action = history.my_actions[prev_round]
            sum_my_c = 1 if my_prev_action else 0
            total_cooperators = sum_opponent_c + sum_my_c
            required_cooperators = (n_players + 1) // 2
            condition_b = total_cooperators >= required_cooperators
            if condition_a and condition_b:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_356(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that adapts based on stock level, 
    remaining rounds, and opponents' past actions to balance individual gain and collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        if current_round == self.n_rounds - 1:
            return Action.D
        remaining_rounds = self.n_rounds - current_round - 1
        current_stock = state.current_stock
        total_d = 0
        for round in range(current_round):
            opponent_actions = history.opponent_actions[round]
            sum_c = opponent_actions.sum()
            num_d = opponent_actions.shape[0] - sum_c
            total_d += num_d
        total_possible_d = current_round * (self.n_players - 1)
        if total_possible_d == 0:
            average_d = 0.0
        else:
            average_d = total_d / total_possible_d
        if average_d > 0.5:
            reduction = max(0.0, average_d - 0.5)
            threshold = self.capacity * 0.7 * (1 - reduction)
            threshold = max(threshold, 0.3 * self.capacity)
        else:
            threshold = 0.7 * self.capacity
        if current_stock > threshold and remaining_rounds > 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_357(BaseStrategy):
    """
    Adaptive Cooperation with Stock Threshold and Defection Punishment Strategy.
    Cooperates initially, defects in the last round, and adapts based on previous defections and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            previous_my_action = history.my_actions[state.round_number - 1]
            previous_opponent_actions = history.opponent_actions[state.round_number - 1]
            defectors = 0
            if not previous_my_action:
                defectors += 1
            for action in previous_opponent_actions:
                if not action:
                    defectors += 1
            if defectors > self.n_players / 2 or state.current_stock < self.capacity / 2:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_358(BaseStrategy):
    """
    An adaptive strategy that starts with cooperation, punishes significant stock depletion,
    and defects in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.threshold = 0.1 * self.capacity
        self.last_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            action = Action.C
        elif round_number == self.n_rounds - 1:
            action = Action.D
        elif self.last_stock is not None:
            delta = current_stock - self.last_stock
            if delta < -self.threshold:
                action = Action.D
            else:
                action = Action.C
        else:
            action = Action.C
        self.last_stock = current_stock
        return action

class Strategy_COLLECTIVE_359(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that starts by cooperating and switches to defecting permanently if any prior round's total consumption exceeds half the stock. This encourages cooperation while preventing exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_stocks = []
        self.has_defected = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.round_stocks.append(state.current_stock)
        t = state.round_number
        if t == 0:
            return Action.C
        if self.has_defected:
            return Action.D
        n = self.game_description.n_players
        for r in range(t):
            S_r = self.round_stocks[r]
            my_action = history.my_actions[r]
            total = 0.0
            if my_action:
                total += S_r / (2 * n)
            else:
                total += S_r / n
            opponent_actions = history.opponent_actions[r]
            for opponent_action in opponent_actions:
                if opponent_action:
                    total += S_r / (2 * n)
                else:
                    total += S_r / n
            threshold = S_r / 2.0
            if total > threshold:
                self.has_defected = True
                break
        return Action.D if self.has_defected else Action.C

class Strategy_COLLECTIVE_360(BaseStrategy):
    """
    Adaptive Cooperation with Punishment Strategy.
    Cooperates initially and continues if cooperation is sufficiently high and the stock isn't depleting.
    Defects if fewer than half cooperate or the stock decreases. Defects in the last round.
    Cooperates if the stock is depleted unless it's the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_stock = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == 0:
            self.prev_stock = state.current_stock
            return Action.C
        if current_round == n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock <= 0:
            return Action.C
        previous_round = current_round - 1
        my_prev_action = history.my_actions[previous_round]
        opponent_prev_actions = history.opponent_actions[previous_round]
        total_coop = sum(opponent_prev_actions) + (1 if my_prev_action else 0)
        half_n = n_players / 2
        if total_coop >= half_n and current_stock >= self.prev_stock:
            action = Action.C
        else:
            action = Action.D
        self.prev_stock = current_stock
        return action

class Strategy_COLLECTIVE_361(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation with self-protection.
    Cooperates initially, then adapts based on stock levels and past defections to maximize payoff while conserving resources.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        round_number = state.round_number
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if round_number == n_rounds - 1:
            return Action.D
        if current_stock <= 1 / 3 * capacity:
            return Action.D
        elif current_stock > 2 / 3 * capacity:
            t = round_number - 1
            my_action = history.my_actions[t]
            sum_opponent_coop = np.sum(history.opponent_actions[t, :])
            num_opponents = self.game_description.n_players - 1
            num_opponent_defectors = num_opponents - sum_opponent_coop
            my_defect = 0 if my_action else 1
            total_defectors = my_defect + num_opponent_defectors
            if total_defectors < self.game_description.n_players / 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_362(BaseStrategy):
    """
    Adaptive Cooperation with Punishment Strategy.

    This strategy encourages cooperation while penalizing defectors and conserving the stock when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        super().__init__(game_description)
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.punishment_remaining > 0:
            if state.current_stock < 0.5 * self.capacity:
                self.punishment_remaining = 0
                return Action.C
            else:
                self.punishment_remaining -= 1
                return Action.D
        else:
            my_prev_action = history.my_actions[-1]
            opp_prev_actions = history.opponent_actions[-1, :] if history else np.array([], dtype=bool)
            my_prev_C = 1 if my_prev_action else 0
            opp_prev_C = np.sum(opp_prev_actions)
            C_prev = my_prev_C + opp_prev_C
            threshold = 0.8 * self.n_players
            if C_prev >= threshold:
                return Action.C
            elif state.current_stock < 0.5 * self.capacity:
                return Action.C
            else:
                self.punishment_remaining = 2
                return Action.D

class Strategy_COLLECTIVE_363(BaseStrategy):
    """
    Cooperative Punishment with Forgiveness (CPwF) Strategy.

    This strategy starts with cooperation, punishes upon overconsumption, and forgives when consumption becomes sustainable.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_stock = None
        self.in_punishment_phase = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
            self.prev_stock = state.current_stock
            return action
        else:
            n = self.game_description.n_players
            s_prev = self.prev_stock
            if s_prev is None:
                self.prev_stock = state.current_stock
                return Action.C
            my_prev_action = history.my_actions[-1]
            others_prev_actions = history.opponent_actions[-1, :]
            if my_prev_action:
                my_consume = s_prev / (2 * n)
            else:
                my_consume = s_prev / n
            oppo_consume = 0.0
            for opp_act in others_prev_actions:
                if opp_act:
                    oppo_consume += s_prev / (2 * n)
                else:
                    oppo_consume += s_prev / n
            total_consumption = my_consume + oppo_consume
            if s_prev == 0:
                threshold = 0.0
            else:
                base = s_prev / 2.0
                epsilon = 0.05 * base
                threshold = base + epsilon
            overconsumed = total_consumption > threshold
            if overconsumed:
                action = Action.D
                self.in_punishment_phase = True
            elif self.in_punishment_phase:
                sustainable_level = s_prev / 2.0 if s_prev != 0 else 0.0
                if total_consumption <= sustainable_level:
                    action = Action.C
                    self.in_punishment_phase = False
                else:
                    action = Action.D
            else:
                action = Action.C
            self.prev_stock = state.current_stock
            return action

class Strategy_COLLECTIVE_364(BaseStrategy):
    """
    A tit-for-tat inspired strategy for the Common Pool Resource Game. 
    It starts with cooperation, defects if more than half the players defected previously,
    and cooperates if the stock is below 50% of capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            threshold_stock = 0.5 * self.capacity
            if state.current_stock < threshold_stock:
                return Action.C
            else:
                prev_ops = history.opponent_actions[-1, :]
                sum_coop = sum(prev_ops)
                defectors = self.n_players - sum_coop
                if defectors > self.n_players / 2:
                    return Action.D
                else:
                    return Action.C

class Strategy_COLLECTIVE_365(BaseStrategy):
    """
    Dynamic threshold strategy based on stock level and remaining rounds.
    Cooperates when the stock is above a decreasing threshold; defects otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            T = self.game_description.capacity * (1 - state.round_number / self.game_description.n_rounds)
            if state.current_stock > T:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_366(BaseStrategy):
    """
    Cooperate if the stock after growth is above 50% of capacity; otherwise Defect.
    Always Defect in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        threshold = 0.5 * self.capacity
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_367(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) Strategy.
    Cooperates initially, defects if stock falls below 50% capacity, then resumes cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number <= 2:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        threshold = 0.5 * capacity
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        if current_stock < threshold:
            self.punishment_remaining = 1
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_368(BaseStrategy):
    """
    Adaptive Stock Conservation strategy balances immediate gains with long-term sustainability.
    Cooperates when the stock is below 80% of capacity and in the penultimate round.
    Defects otherwise to maximize immediate payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 2:
            return Action.C
        capacity = self.game_description.capacity
        threshold = 0.8 * capacity
        if state.current_stock < threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_369(BaseStrategy):
    """
    Adaptive Reciprocity with Stock Sustainability (ARSS) strategy.
    Cooperates initially, then reciprocates based on previous actions and maintains stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < 0.5 * self.capacity:
            return Action.C
        else:
            previous_round = state.round_number - 1
            my_prev_action = history.my_actions[previous_round]
            opponent_prev_actions = history.opponent_actions[previous_round]
            total_C = sum(opponent_prev_actions) + (1 if my_prev_action else 0)
            if total_C > self.n_players / 2:
                return Action.C
            elif random.random() < 0.2:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_371(BaseStrategy):
    """
    A threshold-based adaptive strategy for the Common Pool Resource Game.
    Cooperates initially and in rounds where the stock is above half capacity, 
    and defects otherwise, including the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.5 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock > self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_372(BaseStrategy):
    """
    A threshold-based strategy where players cooperate if the stock is above 50% of capacity and defect otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.threshold = 0.5 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.current_stock > self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_373(BaseStrategy):
    """Adaptive Collective Strategy for the Common Pool Resource Game:
    Cooperates initially, punishes defection, conserves stock when low,
    and cooperates in the last round to foster sustainability."""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if state.round_number == n_rounds - 1:
            return Action.C
        if state.current_stock < capacity / 2:
            return Action.C
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        if history is not None and state.round_number > 0:
            prev_round = state.round_number - 1
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            num_defectors = sum(1 - opponent_actions_prev)
            percentage_defect = num_defectors / n_players * 100
            if percentage_defect > 25:
                self.punishment_remaining = 3
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_374(BaseStrategy):
    """
    Implements a responsive strategy that cooperates initially, punishes 
    upon excessive consumption, and forgives upon stock recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = [game_description.capacity]
        self.is_punishing = False
        self.punishment_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if len(self.stock_history) <= state.round_number:
            self.stock_history.append(state.current_stock)
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        S_prev = self.stock_history[prev_round]
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        sum_consumption = 0.0
        my_prev_action = history.my_actions[prev_round]
        if my_prev_action:
            my_consumption = S_prev / (2 * n)
        else:
            my_consumption = S_prev / n
        sum_consumption += my_consumption
        for opponent_action in history.opponent_actions[prev_round]:
            if opponent_action:
                opp_consumption = S_prev / (2 * n)
            else:
                opp_consumption = S_prev / n
            sum_consumption += opp_consumption
        cooperation_threshold = S_prev / 2
        cooperation_threshold_exceeded = sum_consumption > cooperation_threshold
        current_stock = state.current_stock
        if self.is_punishing:
            if current_stock >= 0.8 * capacity:
                self.is_punishing = False
                self.punishment_rounds = 0
                return Action.C
            elif current_stock < 0.5 * capacity:
                self.punishment_rounds += 1
                return Action.D
            else:
                return Action.D
        elif cooperation_threshold_exceeded:
            self.is_punishing = True
            self.punishment_rounds = 1
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_375(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels.
    Cooperates initially, defects in the last round, and uses a threshold to decide in between.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        threshold = 0.5 * self.capacity
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_376(BaseStrategy):
    """
    A threshold-based strategy for the Common Pool Resource Game.
    Cooperates if the current stock is below 75% of capacity, otherwise defects.
    All players cooperate in the first round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            threshold = 0.75 * self.capacity
            if state.current_stock < threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_377(BaseStrategy):
    """
    This class implements the Adaptive Cooperation with Punishment (ACWP) strategy.
    It cooperates initially, punishes when cooperation is insufficient, and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_actions = history.opponent_actions[prev_round]
        total_coop = (1 if my_prev_action else 0) + sum(opponent_actions)
        condition2 = total_coop * 2 >= self.game_description.n_players
        condition1 = state.current_stock > 0.5 * self.game_description.capacity
        if condition1 and condition2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_378(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game.
    It starts with cooperation in the first round, then uses a combination of stock level and historical cooperation to decide subsequent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        threshold = 0.7 * capacity
        if current_stock > threshold:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponents_prev_actions = history.opponent_actions[previous_round, :]
        n_C = sum(opponents_prev_actions) + (1 if my_prev_action else 0)
        n_players = self.game_description.n_players
        if n_C > n_players / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_379(BaseStrategy):
    """
    Adaptive Cooperation with Punishment strategy for the Common Pool Resource Game.
    Players cooperate to maintain stock levels, defect to punish excessive defection,
    and defect in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            stock_percent = current_stock / capacity
            if stock_percent < 0.5:
                return Action.C
            elif stock_percent < 0.7:
                previous_round = state.round_number - 1
                my_prev_action = history.my_actions[previous_round]
                opponent_actions_prev = history.opponent_actions[previous_round]
                my_defection = 0 if my_prev_action else 1
                opponent_defections = len(opponent_actions_prev) - np.sum(opponent_actions_prev)
                total_defections = my_defection + opponent_defections
                n_players = self.game_description.n_players
                if total_defections > n_players / 2:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C

class Strategy_COLLECTIVE_380(BaseStrategy):
    """
    Adaptive Cooperation Strategy for Common Pool Resource Game.
    
    Cooperates initially and in early rounds if stock is sufficient, 
    defects if stock falls below a threshold, and always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            threshold = 0.5 * self.game_description.capacity
            return Action.C if state.current_stock >= threshold else Action.D

class Strategy_COLLECTIVE_381(BaseStrategy):
    """
    This strategy begins by cooperating in the first round. In subsequent rounds, it defects if more than half of the players defected in the previous round or if the current stock level is below a recovery threshold (quarter of the capacity). Otherwise, it continues to cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        my_prev = history.my_actions[previous_round]
        opponent_prev = history.opponent_actions[previous_round, :]
        D_count = 0
        if not my_prev:
            D_count += 1
        D_count += np.sum(~opponent_prev)
        threshold_stock = self.capacity / 4.0
        n_half = self.n_players / 2.0
        if D_count > n_half or state.current_stock <= threshold_stock:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_382(BaseStrategy):
    """
    Adaptive Threshold Cooperation strategy for the Common Pool Resource Game.

    This strategy balances cooperation and defection based on the current stock level
    relative to capacity and the cooperation level of players in the last round.
    Players cooperate when the stock is above 50% of capacity and at least half
    of the players cooperated in the last round, otherwise they defect.
    In the last round, players always defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        threshold = 0.5 * self.game_description.capacity
        if state.current_stock > threshold:
            n = self.game_description.n_players
            my_last = history.my_actions[-1] if history else False
            if not history:
                my_last = False
            opponent_last = history.opponent_actions[-1, :] if history else np.zeros(n - 1, dtype=bool)
            total_coops = my_last + sum(opponent_last)
            if total_coops * 2 >= n:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_383(BaseStrategy):
    """
    A strategy that initially cooperates and then defects if previous round's consumption exceeds half the stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        my_payoff_prev = history.my_payoffs[t_prev]
        opponent_payoffs_prev = history.opponent_payoffs[t_prev]
        total_consumption = my_payoff_prev + opponent_payoffs_prev.sum()
        threshold = state.current_stock / 2
        if total_consumption > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_384(BaseStrategy):
    """Adaptive Collective Cooperation strategy promoting sustainability while considering collective behavior."""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            total_coop = 0
            for t in range(state.round_number):
                if t >= len(history.my_actions):
                    continue
                my_action = history.my_actions[t]
                opponent_actions = history.opponent_actions[t]
                coop = sum(opponent_actions) + (1 if my_action else 0)
                total_coop += coop
            if total_coop == 0:
                avg = 0.0
            else:
                avg = total_coop / (n_players * state.round_number)
            return Action.C if avg > 0.5 else Action.D
        else:
            previous_round = state.round_number - 1
            my_prev_action = history.my_actions[previous_round]
            my_defect = 0 if my_prev_action else 1
            opponent_actions_prev = history.opponent_actions[previous_round]
            opponent_defects = np.sum(opponent_actions_prev == False)
            total_defectors = my_defect + opponent_defects
            percent_defectors = total_defectors / n_players * 100
            stock_ok = state.current_stock / capacity > 0.5
            return Action.C if percent_defectors < 30 and stock_ok else Action.D

class Strategy_COLLECTIVE_385(BaseStrategy):
    """Adaptive Sustainability Strategy.

    Cooperates initially to preserve stock and sets a cooperative tone.
    In subsequent rounds, cooperates if the stock is below 50% of capacity and defects otherwise.
    Always defects in the last round to maximize personal gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        elif round_number == self.n_rounds - 1:
            return Action.D
        else:
            half_capacity = self.capacity / 2
            if current_stock < half_capacity:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_386(BaseStrategy):
    """
    A threshold-based strategy for the Common Pool Resource Game.
    Cooperate if current stock is below half of capacity; otherwise, defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.threshold = self.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.current_stock <= self.threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_387(BaseStrategy):
    """
    A strategy that starts with cooperation, then defects for one round if the stock falls below 90% of capacity, 
    and resumes cooperation regardless of the stock level after the punishment.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishing = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.punishing:
            self.punishing = False
            return Action.C
        else:
            threshold = 0.9 * self.game_description.capacity
            current_stock = state.current_stock
            if current_stock < threshold:
                self.punishing = True
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_388(BaseStrategy):
    """
    Adaptive Stock Threshold Cooperation (ASTC) strategy.
    Cooperates if current stock is above 50% of capacity, otherwise defects.
    All players cooperate in the first round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        threshold = 0.5 * self.game_description.capacity
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_389(BaseStrategy):
    """
    Cooperative Threshold Strategy: Cooperates when stock is below 75% of capacity, defects otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        threshold = 0.75 * self.capacity
        if state.current_stock < threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_390(BaseStrategy):
    """
    Adaptive Conservation with Punishment (ACP) strategy for the Common Pool Resource Game.
    Balances cooperation with strategic defection to promote sustainability and deter exploitation.
    Cooperates initially, punishes excessive defection, conserves stock when low, and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round, :]
            D_prev = 1 - my_prev_action
            D_prev += (opp_prev_actions == False).sum()
            S_prev = state.current_stock
            if D_prev > self.n_players / 2:
                return Action.D
            elif S_prev < self.capacity / 2:
                return Action.C
            else:
                return Action.C

class Strategy_COLLECTIVE_391(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that adapts based on stock levels and opponents' past actions.
    Cooperates initially, punishes defectors, and manages stock replenishment.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        cap = self.game_description.capacity
        current_stock = state.current_stock
        round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        if round_number == total_rounds - 1:
            if current_stock > 0.7 * cap:
                return Action.D
            else:
                return Action.C
        if current_stock < 0.5 * cap:
            return Action.C
        if history is not None:
            max_rounds = len(history.my_actions)
            start = max(0, max_rounds - 3)
            sum_defectors = 0
            for r in range(start, max_rounds):
                opp_def = 0
                for opponent_action in history.opponent_actions[r, :]:
                    if not opponent_action:
                        opp_def += 1
                if not history.my_actions[r]:
                    opp_def += 1
                sum_defectors += opp_def
            avg_defectors = sum_defectors / (max_rounds - start)
            if avg_defectors > n / 2:
                return Action.D
        if history is not None and round_number > 0:
            prev_round = round_number - 1
            my_prev_action = history.my_actions[prev_round]
            my_prev_payoff = history.my_payoffs[prev_round]
            if my_prev_action:
                S_prev = my_prev_payoff * (2 * n)
            else:
                S_prev = my_prev_payoff * n
            opp_actions = history.opponent_actions[prev_round, :]
            n_coop_opp = sum(opp_actions)
            n_coop_total = n_coop_opp + (1 if my_prev_action else 0)
            n_def_total = n - n_coop_total
            consumption = n_coop_total * (S_prev / (2 * n)) + n_def_total * (S_prev / n)
            S_remaining = S_prev - consumption
            if S_remaining < 0.3 * cap:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_392(BaseStrategy):
    """
    A strategy that cooperates initially and in middle rounds if the stock remains above half the capacity,
    defects in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            threshold = self.game_description.capacity / 2
            previous_stock = state.current_stock
            if previous_stock > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_393(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and self-interest.
    Cooperates initially, adapts based on stock health and opponents' behavior, and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C
        if state.round_number == r - 1:
            return Action.D
        prev_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round]
        opponent_defectors = n - 1 - np.sum(opponent_actions_prev)
        my_prev_action = history.my_actions[prev_round]
        total_defectors_prev = opponent_defectors + (0 if my_prev_action else 1)
        percentage_defected = total_defectors_prev / n * 100
        current_stock = state.current_stock
        if current_stock < 0.5 * capacity:
            return Action.C
        elif percentage_defected > 30:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_394(BaseStrategy):
    """
    Adaptive Sustainability with Reciprocal Cooperation (ASRC) strategy.
    Cooperates initially, defects in the last round, and adapts based on stock level and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        if state.round_number == n_rounds - 1:
            return Action.D
        elif state.round_number == 0:
            return Action.C
        else:
            current_stock = state.current_stock
            if current_stock <= 0.05 * capacity:
                return Action.D
            if history is not None:
                sum_C = np.sum(history.opponent_actions)
                num_opponent_actions = state.round_number * (n_players - 1)
                if num_opponent_actions > 0:
                    cooperator_rate = sum_C / num_opponent_actions
                    if cooperator_rate > 0.75:
                        return Action.C
            if current_stock > 0.5 * capacity:
                base_action = Action.C
            else:
                base_action = Action.D
            if history is not None:
                total_defectors = np.sum(~history.opponent_actions)
                round_count = state.round_number
                average_defectors = total_defectors / round_count
                threshold_defect = n_players / 2
                if average_defectors > threshold_defect:
                    return Action.D
            return base_action

class Strategy_COLLECTIVE_396(BaseStrategy):
    """
    Adaptive Cooperation strategy with threshold and endgame considerations.
    Cooperates initially, then adapts based on stock level and others' actions.
    Switches to defecting under specific conditions to optimize payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        cooperators = sum(opponent_prev_actions) + (1 if my_prev_action else 0)
        cooperation_rate = cooperators / self.game_description.n_players
        if state.current_stock > 0.5 * self.game_description.capacity and cooperation_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_397(BaseStrategy):
    """
    Cooperate if current stock is above 50% of capacity; defect otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        half_capacity = 0.5 * self.game_description.capacity
        if state.current_stock > half_capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_398(BaseStrategy):
    """
    Adaptive Coopetition Strategy for the Common Pool Resource Game.
    Cooperates initially, defects when stock is high, and adapts based on others' cooperation when stock is low or moderate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_stock > 0.7 * capacity:
            return Action.D
        prev_actions = history.opponent_actions[-1, :]
        cooperators = sum(prev_actions)
        threshold = self.game_description.n_players // 2
        if cooperators >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_399(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that combines reciprocation of past actions with stock-level monitoring to adapt to various opponent behaviors while maintaining resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        cap = self.game_description.capacity
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if state.round_number == 0:
            return Action.C
        elif state.round_number == r - 1:
            stock = state.current_stock
            threshold_last = 0.3 * cap
            if stock > threshold_last:
                return Action.C
            else:
                return Action.D
        else:
            stock = state.current_stock
            if stock < 0.2 * cap:
                return Action.C
            prev_round = state.round_number - 1
            my_prev_bool = history.my_actions[prev_round]
            my_prev = int(my_prev_bool)
            opponent_prev = history.opponent_actions[prev_round, :]
            sum_opponent_prev = np.sum(opponent_prev)
            total_coop_prev = my_prev + sum_opponent_prev
            more_than_half = total_coop_prev / n > 0.5
            if more_than_half:
                return Action.C
            else:
                current_round = state.round_number
                max_rounds = r - 2
                if max_rounds <= 0:
                    threshold = 0.5 * cap
                else:
                    current_position = current_round - 1
                    fraction = (max_rounds - current_position) / max_rounds
                    threshold = 0.5 * cap * fraction
                if stock > threshold:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_400(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection based on historical actions and stock levels.
    Cooperates in the first round, defects in the last, and adapts in intermediate rounds based on cooperation and stock health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[-1]
        opponent_prev_actions = history.opponent_actions[-1, :]
        c_prev = int(my_prev_action) + int(opponent_prev_actions.sum())
        threshold = 0.75 * self.game_description.capacity
        if c_prev >= self.game_description.n_players / 2 and state.current_stock >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_401(BaseStrategy):
    """
    A strategy for the Common Pool Resource game that starts with cooperation and switches to defection if overconsumption occurs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_action = history.my_actions[prev_round]
        my_payoff = history.my_payoffs[prev_round]
        if my_action:
            s_prev = 2 * self.n_players * my_payoff
        else:
            s_prev = 1 * self.n_players * my_payoff
        all_actions = [my_action]
        all_actions.extend(history.opponent_actions[prev_round].tolist())
        total_consumption = 0.0
        for action in all_actions:
            if action:
                consumption = s_prev / (2 * self.n_players)
            else:
                consumption = s_prev / self.n_players
            total_consumption += consumption
        if total_consumption > s_prev / 2.0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_402(BaseStrategy):
    """
    Adaptive strategy that balances cooperation and defection based on stock levels and past consumption.
    Cooperates initially, defects in the last round, and adapts based on stock conditions in intermediate rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            if current_stock < self.capacity / 2.0:
                return Action.C
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_actions = history.opponent_actions[prev_round]
            c = int(my_prev_action) + sum(opponent_actions)
            n = self.n_players
            C = self.capacity
            target = current_stock
            low = 0.0
            high = C
            tolerance = 1e-06
            for _ in range(100):
                mid = (low + high) / 2.0
                if mid == 0.0:
                    computed = 0.0
                else:
                    term1 = mid * c / (2.0 * n)
                    S_remaining_prev = term1
                    if S_remaining_prev <= 0.0:
                        growth = 0.0
                    else:
                        growth_factor = 1.0 - S_remaining_prev / C
                        growth = 2.0 * S_remaining_prev * growth_factor
                    new_stock = S_remaining_prev + growth
                    if new_stock > C:
                        new_stock = C
                    computed = new_stock
                if computed < target:
                    low = mid
                else:
                    high = mid
                if high - low < tolerance:
                    break
            S_prev = (low + high) / 2.0
            if S_prev == 0.0:
                T_prev = 0.0
            else:
                T_prev = (2.0 * n - c) / (2.0 * n) * S_prev
            if T_prev > S_prev / 2.0:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_403(BaseStrategy):
    """
    Adaptive Cooperation Strategy for Common Pool Resource Game.

    The strategy cooperates in the first round, then adapts based on the previous round's cooperation rate.
    It defects if the previous cooperation rate was below 70% and switches back to cooperation if subsequent
    cooperation is sufficient. It prioritizes cooperation if the stock falls below half capacity and considers
    the average cooperation rate in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < self.capacity / 2:
            return Action.C
        is_last_round = state.round_number == self.n_rounds - 1
        prev_round = state.round_number - 1
        if is_last_round:
            total_coop = 0
            for r in range(prev_round + 1):
                my_act = history.my_actions[r]
                opponents_acts = history.opponent_actions[r]
                my_vote = 1 if my_act else 0
                opponents_votes = sum(opponents_acts)
                total_coop += my_vote + opponents_votes
            rounds_count = prev_round + 1
            avg_coop = total_coop / (self.n_players * rounds_count)
            if avg_coop >= 0.7:
                return Action.C
            else:
                return Action.D
        else:
            my_prev_act = history.my_actions[prev_round]
            opponents_prev_acts = history.opponent_actions[prev_round]
            my_vote = 1 if my_prev_act else 0
            opponents_votes = sum(opponents_prev_acts)
            coop_rate = (my_vote + opponents_votes) / self.n_players
            if coop_rate >= 0.7:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_404(BaseStrategy):
    """
    A strategy that adapts between cooperation and defection based on observed stock trends and others' behavior.
    Cooperates initially, punishes defectors, and defects when the stock is critically low or in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.critical_stock = 0.25 * self.capacity
        self.punishment_rounds = 3
        self.punishing = False
        self.punishment_remaining = 0
        self.defect_until_recovery = False
        self.prev_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.prev_stock = state.current_stock
            return Action.C
        round_number = state.round_number
        if round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < self.critical_stock:
            self.defect_until_recovery = True
            return Action.D
        elif self.defect_until_recovery:
            if current_stock >= self.critical_stock:
                self.defect_until_recovery = False
            return Action.D
        if self.punishing:
            if self.punishment_remaining > 0:
                self.punishment_remaining -= 1
                return Action.D
            else:
                self.punishing = False
                return Action.C
        my_prev_action = history.my_actions[-1]
        opp_prev_actions = history.opponent_actions[-1]
        total_coop = my_prev_action + opp_prev_actions.sum()
        coop_rate = total_coop / self.n_players
        stock_trend = 'stable'
        if self.prev_stock is not None:
            if current_stock > self.prev_stock:
                stock_trend = 'increasing'
            elif current_stock < self.prev_stock:
                stock_trend = 'decreasing'
        if stock_trend == 'decreasing':
            self.punishing = True
            self.punishment_remaining = self.punishment_rounds
            return Action.D
        return Action.C
        self.prev_stock = current_stock

class Strategy_COLLECTIVE_405(BaseStrategy):
    """
    Strategy to Cooperate if current stock is below half of capacity, otherwise Defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        threshold = self.game_description.capacity / 2.0
        if state.current_stock < threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_406(BaseStrategy):
    """
    Adaptive Reciprocity with Stock Conservation (ARSC) strategy.
    Cooperates initially, monitors cooperation rates, and adapts based on stock levels.
    Punishes defectors while conserving stock when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        cap = self.capacity
        very_low_stock = 0.2 * cap
        if current_stock < very_low_stock:
            return Action.C
        is_last_round = state.round_number == self.r - 1
        if is_last_round:
            if current_stock > 0.7 * cap:
                return Action.C
            else:
                return Action.D
        coop_rates = []
        for i in range(1, 4):
            round_num = state.round_number - i
            if round_num < 0:
                continue
            my_action = history.my_actions[round_num]
            opponents_actions = history.opponent_actions[round_num]
            coop_count = my_action + sum(opponents_actions)
            cr = coop_count / self.n
            coop_rates.append(cr)
        avg_cr = np.mean(coop_rates) if coop_rates else 0.0
        if avg_cr >= 0.8:
            return Action.C
        elif 0.6 <= avg_cr < 0.8:
            if current_stock > 0.5 * cap:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_407(BaseStrategy):
    """
    A strategy balancing cooperation, retaliation, and stock regeneration.
    Cooperates initially, defects in the last round, and adapts based on stock and previous defections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.game_description.capacity / 2:
            return Action.C
        prev_round = state.round_number - 1
        my_action_prev = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        my_defection = 0 if my_action_prev else 1
        opp_defectors = opponent_actions_prev.size - np.sum(opponent_actions_prev)
        total_defectors = my_defection + opp_defectors
        n = self.game_description.n_players
        if total_defectors > n / 2:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_408(BaseStrategy):
    """
    A strategy that cooperates if the current stock is above 50% of capacity, otherwise defects.
    Cooperates in the first round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.threshold = 0.5 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock > self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_409(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on stock level sustainability and reciprocity.
    Cooperates initially, continues if stock is low, and punishes excessive defection otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            s_prev = state.current_stock
            if s_prev < 0.5 * self.capacity:
                return Action.C
            else:
                t_prev = state.round_number - 1
                my_action = history.my_actions[t_prev]
                opp_actions = history.opponent_actions[t_prev]
                k = 0
                if not my_action:
                    k += 1
                for act in opp_actions:
                    if not act:
                        k += 1
                if k > self.n_players / 2:
                    return Action.D
                else:
                    return Action.C

class Strategy_COLLECTIVE_410(BaseStrategy):
    """
    A strategy that Cooperates if the stock is at least half of the capacity, otherwise Defects.
    Cooperates in the first round to establish trust and sustainable resource use.
    Subsequent rounds: Defect if the remaining stock is below half the capacity to maximize personal gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            threshold = self.capacity / 2.0
            if state.current_stock >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_411(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that balances immediate gains with long-term sustainability.
    Players cooperate when the stock is high, defect when critically low, and use cooperation rates from previous rounds for intermediate stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.capacity
        if current_stock > 0.9 * capacity:
            return Action.C
        elif current_stock < 0.5 * capacity:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_actions = history.opponent_actions[prev_round, :]
            opponent_coop = np.sum(opponents_actions)
            total_coop = opponent_coop + (1 if my_prev_action else 0)
            if total_coop > self.n_players / 2:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_412(BaseStrategy):
    """
    Adaptive Cooperation Threshold (ACT) strategy.
    Cooperates in the first round, defects in the last. In middle rounds, cooperates if stock is above half capacity, else defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            threshold = self.capacity / 2.0
            if state.current_stock > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_413(BaseStrategy):
    """
    A strategy designed to balance cooperation and defection in a Common Pool Resource Game.
    It promotes initial cooperation, punishes excessive defection, and aims to sustain a healthy stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_active = False
        self.punishment_remaining = 0
        self.previous_stock_before_punishment = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.punishment_active:
            action = Action.D
            self.punishment_remaining -= 1
            if self.punishment_remaining == 0:
                current_stock = state.current_stock
                previous_stock = self.previous_stock_before_punishment
                if current_stock > previous_stock:
                    self.punishment_active = False
                else:
                    self.punishment_active = False
            return action
        else:
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            if current_stock <= 0:
                return Action.C
            previous_actions = history.opponent_actions[-1, :]
            defectors = sum((1 for a in previous_actions if not a))
            threshold_defectors = 0.2 * self.game_description.n_players
            if defectors > threshold_defectors:
                self.punishment_active = True
                self.punishment_remaining = 2
                self.previous_stock_before_punishment = current_stock
                return Action.D
            elif current_stock / capacity >= 0.7:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_414(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACWP) Strategy for Common Pool Resource Game.
    Cooperates initially, defects if cooperation rate falls below 80%, and defects 
    when stock is critically low. Defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            threshold = 0.25 * self.game_description.capacity
            if state.current_stock < threshold:
                return Action.D
            elif history is None:
                return Action.D
            else:
                prev_opponent_actions = history.opponent_actions[-1]
                n_coop_opponent = np.sum(prev_opponent_actions)
                my_prev = history.my_actions[-1]
                total_coop = n_coop_opponent + (1 if my_prev else 0)
                coop_rate = total_coop / self.game_description.n_players
                if coop_rate >= 0.8:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_415(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation with strategic defection.
    It starts with cooperation, defects if the stock falls below 50% of capacity, and adapts based on 
    observed behavior to maintain resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.last_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_stock = state.current_stock
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            if history is None:
                return Action.C
            opponent_actions = history.opponent_actions
            total_coop = opponent_actions.sum()
            total_possible = opponent_actions.size
            cooperation_rate = total_coop / total_possible
            if cooperation_rate >= 0.5:
                action = Action.C
            else:
                action = Action.D
            self.last_stock = state.current_stock
            return action
        else:
            if history is None:
                return Action.C
            last_action = history.my_actions[-1]
            current_stock = state.current_stock
            threshold = self.capacity * 0.5
            last_stock_val = self.last_stock
            if current_stock < threshold:
                if last_action == Action.D:
                    if current_stock > last_stock_val:
                        action = Action.C
                    else:
                        action = Action.D
                else:
                    action = Action.D
            else:
                action = Action.C
            self.last_stock = current_stock
            return action

class Strategy_COLLECTIVE_416(BaseStrategy):
    """
    Cooperate unless more than half of the players defected in the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_last = history.my_actions[last_round]
        opp_last = history.opponent_actions[last_round]
        my_defected = 0 if my_last else 1
        opp_defected = opp_last.size - np.sum(opp_last)
        total_defected = my_defected + opp_defected
        threshold = self.game_description.n_players / 2
        if total_defected > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_417(BaseStrategy):
    """
    A strategy that starts with cooperation, adapts based on others' behavior and resource levels, 
    and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            opponent_actions = history.opponent_actions[prev_round, :]
            k = (opponent_actions == False).sum()
            if k > self.game_description.n_players / 2:
                return Action.D
            elif state.current_stock < 0.25 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_418(BaseStrategy):
    """
    A collectivist strategy for the Common Pool Resource Game that starts with cooperation, reciprocates based on stock levels, and punishes defectors to maintain resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        if state.round_number == self.n_rounds - 1:
            if state.current_stock > 0.8 * self.capacity:
                return Action.C
            else:
                return Action.D
        if state.current_stock < 0.2 * self.capacity:
            return Action.D
        if state.current_stock > 0.9 * self.capacity:
            return Action.C
        elif state.current_stock < 0.8 * self.capacity:
            self.punishment_remaining = 1
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_419(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that promotes cooperation when beneficial and sustainability is maintained.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / game_description.n_players
        self.stock_history = [game_description.capacity]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            if current_stock < self.threshold:
                return Action.D
            else:
                prev_round = state.round_number - 1
                my_prev_action = history.my_actions[prev_round]
                opp_prev_actions = history.opponent_actions[prev_round]
                cooperators = sum(opp_prev_actions)
                if my_prev_action:
                    cooperators += 1
                majority_threshold = self.game_description.n_players // 2
                if cooperators > majority_threshold:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_420(BaseStrategy):
    """
    Adaptive Cooperation with Trigger Defection Strategy for Common Pool Resource Game.
    
    - First round: Always Cooperate.
    - Subsequent rounds: Cooperate if stock is above 75% of capacity and less than 20% of players defected in the previous round.
    - Last round: Always Defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock > 0.75 * self.capacity:
            my_last_action = history.my_actions[-1]
            my_defect = 0 if my_last_action else 1
            opponent_actions_last = history.opponent_actions[-1, :]
            n_opp_def = (opponent_actions_last == False).sum()
            total_defectors = my_defect + n_opp_def
            ratio = total_defectors / self.n_players
            if ratio < 0.2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_421(BaseStrategy):
    """
    Cooperative Punishment with Gradual Escalation strategy for the Common Pool Resource Game.
    The strategy promotes cooperation while safeguarding against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_opponents = game_description.n_players - 1
        self.opponent_defection_counts = [0] * self.n_opponents

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        game = self.game_description
        capacity = game.capacity
        threshold = 0.2 * capacity
        last_round = state.round_number == game.n_rounds - 1
        if last_round and state.current_stock < threshold or state.current_stock < threshold:
            return Action.D
        if state.round_number < 3:
            return Action.C
        n_rounds_to_consider = 3
        start_round = max(0, state.round_number - n_rounds_to_consider)
        total_cooperative = 0
        for prior_round in range(start_round, state.round_number):
            if history is None or prior_round >= len(history.my_actions):
                continue
            my_action = history.my_actions[prior_round]
            if my_action:
                total_cooperative += 1
            opponent_actions_prior = history.opponent_actions[prior_round, :]
            total_cooperative += sum(opponent_actions_prior)
        n_players = game.n_players
        n_prior_rounds = state.round_number - start_round
        if n_prior_rounds == 0:
            average_coop = 0.0
        else:
            average_coop = total_cooperative / (n_prior_rounds * n_players)
        if average_coop >= 0.8:
            return Action.C
        previous_round = state.round_number - 1
        if previous_round >= 0 and history is not None:
            opponent_last_actions = history.opponent_actions[previous_round] if previous_round < history.opponent_actions.shape[0] else []
            if len(opponent_last_actions) == self.n_opponents:
                for j in range(self.n_opponents):
                    if not opponent_last_actions[j]:
                        self.opponent_defection_counts[j] += 1
                    else:
                        self.opponent_defection_counts[j] = 0
        defect_prob = 0.0
        for count in self.opponent_defection_counts:
            contribution = 0.05 * min(count, 10)
            defect_prob += contribution
        defect_prob = min(defect_prob, 0.5)
        if random.random() < defect_prob:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_422(BaseStrategy):
    """
    A strategy that balances cooperation with defection based on stock levels and previous cooperation.
    Cooperates initially and continues if stock is sustainable and others cooperate.
    Defects if stock is low or others defected.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if state.round_number == self.game_description.n_rounds - 1:
            threshold = 0.5 * capacity
            return Action.C if current_stock > threshold else Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_prev_actions = history.opponent_actions[prev_round, :].tolist()
            prev_coop_list = [my_prev_action] + opponent_prev_actions
            total_coop_prev = sum(prev_coop_list)
            if current_stock > 0.5 * capacity and total_coop_prev > n // 2:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_423(BaseStrategy):
    """
    Adaptive Collective Sustainability (ACS) Strategy.
    
    Cooperates if the stock is above 50% of capacity and fewer than half the players defected previously.
    Defects if the stock drops below 50% or more than half defected. 
    Always cooperates in the first round. In the last round, cooperates if overall cooperation was high.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == n_rounds - 1:
            count_C = 0
            for prev_round in range(state.round_number):
                if history.my_actions[prev_round]:
                    count_C += 1
                opponent_actions = history.opponent_actions[prev_round, :]
                count_C += sum(opponent_actions)
            threshold = n_players * state.round_number / 2
            return Action.C if count_C > threshold else Action.D
        else:
            current_stock = state.current_stock
            if current_stock > 0.5 * capacity:
                t_prev = state.round_number - 1
                my_prev = history.my_actions[t_prev]
                opponents_prev = history.opponent_actions[t_prev, :]
                defectors = 0
                if not my_prev:
                    defectors += 1
                for opp_act in opponents_prev:
                    if not opp_act:
                        defectors += 1
                if defectors < n_players / 2:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_COLLECTIVE_424(BaseStrategy):
    """
    A strategy that adapts based on collective behavior and stock level,
    promoting cooperation while ensuring individual gains through
    reciprocal responses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        my_previous_action = history.my_actions[-1]
        opponent_last_actions = history.opponent_actions[-1]
        my_defected = 0 if my_previous_action else 1
        opponent_defected = np.count_nonzero(opponent_last_actions == 0)
        num_defectors = my_defected + opponent_defected
        fraction_defectors = num_defectors / n_players
        stock_level = state.current_stock
        t = state.round_number
        rounds_remaining = r - t
        endgame_threshold = 0.1 * r
        endgame_condition = rounds_remaining <= endgame_threshold and stock_level < 0.2 * capacity
        if fraction_defectors >= 0.5 or stock_level < 0.3 * capacity or endgame_condition:
            action = Action.D
        else:
            action = Action.C
        reciprocal = False
        if len(history.opponent_actions) >= 5:
            last_five = history.opponent_actions[-5:]
            for round_actions in last_five:
                if not (round_actions == 1).all():
                    reciprocal = False
                    break
            else:
                reciprocal = True
        if reciprocal:
            action = Action.C
        return action

class Strategy_COLLECTIVE_425(BaseStrategy):
    """
    A strategy that combines stock-level triggers and history-based responses to maintain cooperation while avoiding exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.75 * self.capacity:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        c_count = 0
        if my_prev_action:
            c_count += 1
        c_count += np.sum(opponent_prev_actions)
        if c_count < self.n_players:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_426(BaseStrategy):
    """
    Adaptive Collective Management (ACM) Strategy.

    This strategy promotes cooperation while safeguarding against over-exploitation
    of the common pool resource. It adapts based on the current stock level and
    the cooperation rate of all players in the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if state.round_number == 0:
            return Action.C
        if current_stock < 0.01 * capacity:
            return Action.D
        if state.round_number == r - 1:
            if current_stock > 0.25 * capacity:
                return Action.C
            else:
                return Action.D
        elif current_stock < 0.5 * capacity:
            return Action.D
        else:
            my_last = history.my_actions[-1]
            opponent_actions = history.opponent_actions[-1, :]
            num_coop = (1 if my_last else 0) + sum(opponent_actions)
            coop_rate = num_coop / n
            if coop_rate < 0.5:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_427(BaseStrategy):
    """
    Adaptive Cooperation with Stock Threshold (ACST) strategy for the Common Pool Resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.k = min(5, self.n_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        if t == 0:
            return Action.C
        current_stock = state.current_stock
        critical_threshold = 0.5 * self.capacity
        if current_stock < critical_threshold:
            return Action.C
        start = max(0, t - self.k)
        sum_coop = 0.0
        for r in range(start, t):
            my_action = history.my_actions[r]
            opponent_actions = history.opponent_actions[r, :]
            coop_count = my_action + opponent_actions.sum()
            sum_coop += coop_count / self.n_players
        avg_coop = sum_coop / (t - start)
        if avg_coop > 0.7:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_429(BaseStrategy):
    """
    A strategy that adaptively chooses to cooperate or defect based on previous rounds' outcomes.
    Cooperates initially, defects if excessive defection or low stock occurs, and always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            self_defected_prev = 1 if not my_prev_action else 0
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            n_defectors_opponents = (opponent_actions_prev == False).sum()
            total_defectors_prev = self_defected_prev + n_defectors_opponents
            perc_defectors_prev = total_defectors_prev / self.game_description.n_players
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            stock_below_20 = current_stock / capacity < 0.2
            if perc_defectors_prev > 0.5 or stock_below_20:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_430(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) Strategy.

    This strategy starts with cooperation (C) in the first round. If the stock level falls 
    below a lower threshold (50% of capacity), the player starts defecting (D) for 3 rounds 
    as a punishment. After the punishment phase, if the stock recovers above an upper 
    threshold (70% of capacity), cooperation resumes.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.lower_threshold = 0.5 * self.capacity
        self.upper_threshold = 0.7 * self.capacity
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        elif current_stock < self.lower_threshold:
            self.punishment_remaining = 3
            return Action.D
        elif current_stock >= self.upper_threshold:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_431(BaseStrategy):
    """
    Balances cooperation and defection based on previous defection levels and stock status.
    Cooperates initially, then defects if more than half defected previously or stock is below half capacity.
    Defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            t_prev = state.round_number - 1
            my_prev_action = history.my_actions[t_prev]
            my_defect_prev = not my_prev_action
            opponent_actions_t_prev = history.opponent_actions[t_prev]
            opponent_defects = [not a for a in opponent_actions_t_prev]
            k_prev = my_defect_prev + sum(opponent_defects)
            if k_prev > self.n_players / 2:
                return Action.D
            else:
                half_capacity = 0.5 * self.capacity
                if state.current_stock > half_capacity:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_432(BaseStrategy):
    """
    A strategy that adapts based on stock levels and cooperation rates, 
    combining initial cooperation with dynamic responses to maintain sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        stock_threshold = 0.75 * capacity
        if current_stock < stock_threshold:
            return Action.C
        sum_my_C = np.sum(history.my_actions)
        sum_opponent_C = np.sum(history.opponent_actions)
        total_C = sum_my_C + sum_opponent_C
        total_actions = state.round_number * self.game_description.n_players
        cooperation_rate = total_C / total_actions
        if cooperation_rate < 0.7:
            return Action.D
        n_rounds = self.game_description.n_rounds
        if state.round_number >= max(0, n_rounds - 5):
            if random.random() < 0.6:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_COLLECTIVE_434(BaseStrategy):
    """
    This strategy balances punishing recent defection, maintaining healthy stock levels, 
    and adjusting behavior in the final round to either sustain cooperation or maximize gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > 0.75 * self.game_description.capacity:
                my_coop = sum(history.my_actions)
                others_coop = sum(sum(history.opponent_actions))
                total_coop = my_coop + others_coop
                total_actions = state.round_number * self.game_description.n_players
                cooperation_rate = total_coop / total_actions
                if cooperation_rate > 0.5:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            others_prev_actions = history.opponent_actions[prev_round]
            others_defected = sum(~others_prev_actions)
            my_defected = 0 if my_prev_action else 1
            D_prev = others_defected + my_defected
            threshold = 0.25 * self.game_description.n_players
            if D_prev > threshold or state.current_stock < 0.5 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_435(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that promotes sustainability by 
    cooperating in all rounds except the last, where it defects to maximize final payoff.
    
    The strategy is designed to balance immediate gains with long-term sustainability.
    Players cooperate in the first and all middle rounds to maintain a healthy stock level 
    and defect in the final round to maximize their payoff without concern for future rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_436(BaseStrategy):
    """
    A adaptive strategy that balances cooperation and defection based on stock levels and remaining rounds.
    Cooperates initially, defects in response to stock decreases, rebuilds when necessary, and maximizes final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.round_number == self.n_rounds - 2:
            if state.current_stock > 0.8 * self.capacity:
                return Action.C
            else:
                return Action.D
        elif state.current_stock < 0.5 * self.capacity:
            return Action.C
        elif len(self.stock_history) >= 2 and state.current_stock < self.stock_history[-2]:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_437(BaseStrategy):
    """
    Adaptive Collective Optimization (ACO) Strategy.

    This strategy balances cooperation with strategic defection to maximize long-term payoffs
    while maintaining a sustainable stock level. It prioritizes cooperation but adapts to
    prevent exploitation and ensure stock regeneration when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_phase = False
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if self.punishment_phase:
            action = Action.D
            if self.punishment_remaining > 0:
                self.punishment_remaining -= 1
                if self.punishment_remaining == 0:
                    self.punishment_phase = False
            return action
        prev_round = state.round_number - 1
        my_coop = 1 if history.my_actions[prev_round] else 0
        opponent_coop = np.sum(history.opponent_actions[prev_round])
        total_coop = my_coop + opponent_coop
        cooperation_rate = total_coop / self.game_description.n_players
        if cooperation_rate < 0.5:
            self.punishment_phase = True
            self.punishment_remaining = 2
            return Action.D
        elif state.current_stock < 0.2 * self.game_description.capacity:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_438(BaseStrategy):
    """
    Adaptive Cooperation with Punishment Strategy.
    Cooperates by default, defects if stock decreases for two consecutive rounds or drops significantly.
    Returns to cooperation if stock recovers after defecting.
    Defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.is_punishing = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number >= len(self.stock_history):
            self.stock_history.append(state.current_stock)
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if not self.is_punishing:
            two_consecutive_decreases = False
            if len(self.stock_history) >= 3:
                s_t_minus2 = self.stock_history[-3]
                s_t_minus1 = self.stock_history[-2]
                s_t = self.stock_history[-1]
                two_consecutive_decreases = s_t_minus1 < s_t_minus2 and s_t < s_t_minus1
            significant_drop = False
            if len(self.stock_history) >= 1:
                significant_drop = self.stock_history[-1] < 0.5 * self.game_description.capacity
            if two_consecutive_decreases or significant_drop:
                self.is_punishing = True
                return Action.D
            else:
                return Action.C
        else:
            if len(self.stock_history) >= 2:
                current_stock = self.stock_history[-1]
                prev_stock = self.stock_history[-2]
                if current_stock > prev_stock:
                    self.is_punishing = False
                    return Action.C
            return Action.D

class Strategy_COLLECTIVE_439(BaseStrategy):
    """
    A strategy that starts with cooperation, cooperates if stock is above half capacity, 
    defects otherwise, and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.current_stock > self.capacity / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_440(BaseStrategy):
    """
    Cooperate until the stock drops below 50% of the initial capacity, then defect for all subsequent rounds. 
    Always defect in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.should_defect = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            if self.should_defect:
                return Action.D
            current_threshold = 0.5 * self.capacity
            if state.current_stock < current_threshold:
                self.should_defect = True
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_441(BaseStrategy):
    """
    A strategy balancing cooperation and defection to sustain the stock while maximizing individual payoffs.
    Cooperates initially, defects when stock is low, and increases defection as the game progresses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        threshold = 0.5 * self.capacity
        remaining_rounds = self.n_rounds - state.round_number - 1
        if remaining_rounds <= 2:
            return Action.D
        elif current_stock < threshold:
            return Action.D
        elif state.round_number >= self.n_rounds // 2:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_442(BaseStrategy):
    """
    A strategy that cooperates when the stock is below 50% of capacity and defects otherwise, 
    considering the cooperation rate of previous rounds when above the threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < 0.5 * self.capacity:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_c = history.my_actions[prev_round]
            opponents_actions = history.opponent_actions[prev_round]
            others_c = np.count_nonzero(opponents_actions)
            total_c = my_c + others_c
            if total_c > self.n_players / 2:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_443(BaseStrategy):
    """
    A strategy based on reciprocal behavior with forgiveness, aimed at maintaining cooperation while avoiding exploitation.
    Cooperates initially, then reciprocates based on the previous round's defection rate, with forgiveness if others comply.
    Defects in endgame rounds to maximize final payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.is_punishing = False

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        endgame_cutoff = int(0.9 * self.game_description.n_rounds)
        if state.round_number >= endgame_cutoff:
            return Action.D
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opp_prev_actions = history.opponent_actions[previous_round, :]
        n_defectors = 0
        if not my_prev_action:
            n_defectors += 1
        n_defectors += len(opp_prev_actions) - np.sum(opp_prev_actions)
        defection_rate = n_defectors / self.game_description.n_players
        if self.is_punishing:
            if defection_rate <= 0.5:
                self.is_punishing = False
                return Action.C
            else:
                self.is_punishing = True
                return Action.D
        elif defection_rate > 0.5:
            self.is_punishing = True
            return Action.D
        else:
            self.is_punishing = False
            return Action.C

class Strategy_COLLECTIVE_444(BaseStrategy):
    """
    A threshold-based strategy for the Common Pool Resource Game.
    Cooperates if the current stock is >=75% of capacity; otherwise Defects.
    Cooperates in the first round unconditionally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            threshold = 0.75 * self.game_description.capacity
            if state.current_stock >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_445(BaseStrategy):
    """
    Adaptive Cooperation with Stock Conservation strategy.
    Cooperates initially, then adapts based on players' previous actions and stock levels.
    Defects in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            previous_round = state.round_number - 1
            my_last = history.my_actions[previous_round]
            opponent_last = history.opponent_actions[previous_round, :]
            total_coop = sum([my_last]) + sum(opponent_last)
            percent_coop = total_coop / self.game_description.n_players * 100
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            condition1 = percent_coop > 50 and current_stock > 0.5 * capacity
            if condition1:
                return Action.C
            elif current_stock < 0.2 * capacity:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_446(BaseStrategy):
    """
    Adaptive Cooperation with Stock Thresholds (ACST) strategy for Common Pool Resource Game.
    Balances cooperation and defection based on stock level and others' previous actions.
    Includes handling for last round and low stock recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_stock = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_stock = state.current_stock
            return Action.C
        else:
            capacity = self.game_description.capacity
            n_players = self.game_description.n_players
            round_number = state.round_number
            if round_number == self.game_description.n_rounds - 1:
                stock_threshold = 0.5 * capacity
                if state.current_stock > stock_threshold:
                    action = Action.C
                else:
                    action = Action.D
            else:
                my_actions = history.my_actions
                my_last = my_actions[-1] if len(my_actions) > 0 else False
                opponent_actions = history.opponent_actions
                opponent_last = opponent_actions[-1] if opponent_actions is not None and opponent_actions.size > 0 else np.array([], dtype=bool)
                cooperators = 0
                if my_last:
                    cooperators += 1
                cooperators += sum(opponent_last)
                cooperation_rate = cooperators / n_players if n_players != 0 else 0.0
                stock_threshold = 0.5 * capacity
                if state.current_stock > stock_threshold and cooperation_rate > 0.5:
                    action = Action.C
                else:
                    action = Action.D
                lower_threshold = 0.25 * capacity
                if action == Action.D:
                    if self.last_stock is not None:
                        if state.current_stock > self.last_stock and state.current_stock < lower_threshold:
                            action = Action.C
            self.last_stock = state.current_stock
            return action

class Strategy_COLLECTIVE_447(BaseStrategy):
    """
    A strategy that starts with cooperation, switches to defection based on stock levels,
    and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            threshold = 0.7 * self.game_description.capacity
            if state.current_stock > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_448(BaseStrategy):
    """
    Adaptive Cooperative Management strategy for the Common Pool Resource Game.
    Promotes sustained cooperation with retaliatory defection and stock-based adaptation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.C
        current_stock = state.current_stock
        if current_stock < 0.7 * self.capacity:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        prev_opponent_actions = history.opponent_actions[prev_round, :]
        total_coop = sum(prev_opponent_actions) + (1 if my_prev_action else 0)
        if total_coop == self.n_players:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_449(BaseStrategy):
    """
    Adaptive Reciprocity with Stock Conservation (ARSC) strategy.
    Cooperates initially and in sustainable conditions, defects when necessary,
    with special handling for stock depletion and a defection phase for up to two rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.defecting = False
        self.defection_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            if state.current_stock <= 0.2 * self.capacity:
                return Action.D
            if self.defecting:
                action = Action.D
                self.defection_remaining -= 1
                if self.defection_remaining <= 0:
                    self.defecting = False
                    if history is not None and history.my_actions.size > 0:
                        prev_my_action = history.my_actions[-1]
                        prev_opponent_actions = history.opponent_actions[-1]
                        total_coop_prev = prev_my_action + np.sum(prev_opponent_actions)
                        coop_threshold = self.n_players // 2
                        stock_ok = state.current_stock > 0.5 * self.capacity
                        if total_coop_prev > coop_threshold and stock_ok:
                            return Action.C
                        else:
                            return Action.D
                    else:
                        return Action.D
                else:
                    return action
            elif history is not None and history.my_actions.size > 0:
                prev_my_action = history.my_actions[-1]
                prev_opponent_actions = history.opponent_actions[-1]
                total_coop_prev = prev_my_action + np.sum(prev_opponent_actions)
                coop_threshold = self.n_players // 2
                stock_ok = state.current_stock > 0.5 * self.capacity
                if total_coop_prev > coop_threshold and stock_ok:
                    return Action.C
                else:
                    self.defecting = True
                    self.defection_remaining = 2
                    return Action.D
            else:
                return Action.D

class Strategy_COLLECTIVE_450(BaseStrategy):
    """
    A strategy that balances individual gains with collective sustainability by cooperating 
    when the stock is low and defecting when it is high.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.half_capacity = self.capacity * 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if current_stock < self.half_capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_451(BaseStrategy):
    """
    A strategy that cooperates initially and uses a punishment mechanism when stock levels fall below a threshold.
    Cooperates to maintain sustainable stock levels but defects once when stock falls below 50% of capacity,
    then reverts unless the stock falls again.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.punished_last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.n_players
        capacity = self.capacity
        round_number = state.round_number
        my_action_last = history.my_actions[round_number - 1]
        my_payoff_last = history.my_payoffs[round_number - 1]
        if my_payoff_last == 0:
            S_prev_initial = 0.0
        elif my_action_last:
            S_prev_initial = my_payoff_last * 2 * n
        else:
            S_prev_initial = my_payoff_last * n
        my_action_bool = my_action_last
        opponent_actions_last = history.opponent_actions[round_number - 1].tolist()
        all_actions = [my_action_bool] + opponent_actions_last
        total_consumption = 0.0
        for action in all_actions:
            if action:
                if S_prev_initial == 0:
                    continue
                consumption = S_prev_initial / (2 * n)
            else:
                if S_prev_initial == 0:
                    continue
                consumption = S_prev_initial / n
            total_consumption += consumption
        S_remaining = S_prev_initial - total_consumption
        if S_remaining <= 0:
            growth = 0.0
        else:
            growth_factor = 1 - S_remaining / capacity
            growth = 2 * S_remaining * growth_factor
        new_stock_after_growth = min(S_remaining + growth, capacity)
        threshold = 0.5 * capacity
        if new_stock_after_growth <= threshold:
            if not self.punished_last_round:
                action = Action.D
                self.punished_last_round = True
            else:
                action = Action.C
                self.punished_last_round = False
        else:
            action = Action.C
            self.punished_last_round = False
        return action

class Strategy_COLLECTIVE_452(BaseStrategy):
    """
    An adaptive strategy that balances cooperation and defection based on stock levels, 
    remaining rounds, and opponent behavior to maintain the sustainability of the common pool resource while maximizing individual payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.payoff_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.stock_history.append(state.current_stock)
        if history is not None and history.my_payoffs.size > 0:
            if history.my_payoffs[-1] is not None:
                my_last_payoff = float(history.my_payoffs[-1])
                self.payoff_history.append(my_last_payoff)
        current_round = state.round_number + 1
        remaining_rounds = self.game_description.n_rounds - current_round
        stock = state.current_stock
        capacity = self.game_description.capacity
        stock_threshold = 0.5 * capacity
        critically_low_stock = 0.2 * capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D if stock <= stock_threshold else Action.C
        if stock <= critically_low_stock:
            return Action.C
        if stock > stock_threshold and remaining_rounds > self.game_description.n_rounds // 2:
            return Action.C
        avg_stock = 0.0
        if len(self.stock_history) >= 3:
            avg_stock = sum(self.stock_history[-3:]) / 3
        elif self.stock_history:
            avg_stock = sum(self.stock_history) / len(self.stock_history)
        if avg_stock < stock_threshold:
            return Action.D
        if history is not None and state.round_number > 0:
            last_round_index = state.round_number - 1
            opponent_actions = history.opponent_actions[last_round_index, :]
            n_defectors = len(opponent_actions) - sum(opponent_actions)
            if n_defectors > self.game_description.n_players // 2:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_453(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation with self-interest,
    adapting dynamically based on the game's state and others' behavior to sustain resources
    while maximizing personal gain when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.n_rounds - 3:
            return Action.D
        if state.current_stock <= 1e-08 * self.capacity:
            return Action.D
        n_opponents = self.n_players - 1
        recent_rounds_count = min(state.round_number, 5)
        recent_rounds = history.opponent_actions[-recent_rounds_count:]
        total_coop = sum((sum(row) for row in recent_rounds))
        total_possible = recent_rounds_count * n_opponents
        half_total = total_possible / 2
        if total_coop < half_total:
            return Action.D
        stock_two_thirds = 2.0 / 3 * self.capacity
        stock_one_third = 1.0 / 3 * self.capacity
        current_stock = state.current_stock
        if current_stock > stock_two_thirds:
            last_round_coop = sum(recent_rounds[-1])
            if last_round_coop >= n_opponents / 2:
                return Action.C
            else:
                return Action.D
        elif current_stock < stock_one_third:
            return Action.D
        else:
            last_round_coop = sum(recent_rounds[-1])
            if last_round_coop < n_opponents / 2:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_454(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Triggers (ACST) Strategy.
    Cooperates initially and in the last round, defects if stock is decreasing or 
    payoffs are below a threshold, and cooperates otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        super().__init__(game_description)
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if not hasattr(self, 'stock_history'):
            self.stock_history = []
        self.stock_history.append(state.current_stock)
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        k = 3
        decreasing_trend = False
        if len(self.stock_history) >= 2 * k:
            last_3 = self.stock_history[-k:]
            prev_3 = self.stock_history[-2 * k:-k]
            avg_last = sum(last_3) / k
            avg_prev = sum(prev_3) / k
            if avg_last < avg_prev:
                decreasing_trend = True
        payoff_below_threshold = False
        if history is not None and len(history.my_payoffs) >= k:
            last_3_payoffs = history.my_payoffs[-k:]
            avg_payoff = sum(last_3_payoffs) / k
            max_payoff = self.game_description.capacity / (2 * self.game_description.n_players)
            if max_payoff != 0 and avg_payoff < 0.75 * max_payoff:
                payoff_below_threshold = True
        if decreasing_trend or payoff_below_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_455(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels and opponents' past actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            threshold = self.capacity / 2.0
            if current_stock < threshold:
                return Action.C
            else:
                n_opponents = self.n_players - 1
                total_actions = state.round_number * n_opponents
                previous_actions = history.opponent_actions[:state.round_number, :]
                count_defectors = np.sum(~previous_actions)
                threshold_defectors = 0.25 * total_actions
                if count_defectors > threshold_defectors:
                    return Action.D
                else:
                    return Action.C

class Strategy_COLLECTIVE_456(BaseStrategy):
    """
    This strategy cooperates in the first round and then defects if the total consumption in the previous round exceeds half of the stock, otherwise continues cooperating.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[-1]
        opp_prev_actions = history.opponent_actions[-1]
        sum_pi = history.my_payoffs[-1] + np.sum(history.opponent_payoffs[-1])
        if my_prev_action:
            s_prev = 2 * self.game_description.n_players * history.my_payoffs[-1]
        else:
            s_prev = None
            for i in range(len(opp_prev_actions)):
                if opp_prev_actions[i]:
                    s_prev = 2 * self.game_description.n_players * history.opponent_payoffs[-1][i]
                    break
            else:
                s_prev = self.game_description.n_players * history.my_payoffs[-1]
        if sum_pi > s_prev / 2.0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_457(BaseStrategy):
    """
    A strategy that cooperates when the previous round's stock was above 50% of capacity and defects otherwise.
    The first round always cooperates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        threshold = 0.5 * self.game_description.capacity
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_458(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances individual gain with collective sustainability.
    Cooperates in the first round and subsequent rounds if the stock is above half the capacity, otherwise Defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            threshold = self.game_description.capacity / 2
            if state.current_stock > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_459(BaseStrategy):
    """
    A strategy that cooperates when the stock is above 75% of capacity and defects otherwise, 
    except in the final round where it always defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        threshold = 0.75 * self.game_description.capacity
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_460(BaseStrategy):
    """
    A collective strategy designed to balance cooperation and defection in a Common Pool Resource Game.
    It aims to maximize collective payoff while ensuring long-term sustainability through adaptive responses.
    The strategy incorporates initial cooperation, dynamic response to defection, stock-based thresholds,
    and a forgiving tit-for-tat mechanism.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishing = False
        self.punish_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.capacity / 2:
            return Action.C
        if current_stock > 0.8 * self.capacity:
            pass
        if self.punishing and self.punish_remaining > 0:
            self.punish_remaining -= 1
            return Action.D
        k = 3
        start_round = max(0, current_round - k)
        recent_defect_rounds = 0
        for rn in range(start_round, current_round):
            if history is None or rn >= len(history.my_actions):
                break
            my_defect = 0 if history.my_actions[rn] else 1
            opp_actions_rn = history.opponent_actions[rn]
            opp_defect = len(opp_actions_rn) - np.sum(opp_actions_rn)
            total_defect = my_defect + opp_defect
            if total_defect > self.n_players / 2:
                recent_defect_rounds += 1
        if recent_defect_rounds > 0:
            self.punishing = True
            self.punish_remaining = 2
            return Action.D
        else:
            self.punishing = False
        if history is not None and current_round > 0:
            last_round_num = current_round - 1
            if last_round_num < len(history.my_actions) and last_round_num < len(history.opponent_actions):
                opp_last_actions = history.opponent_actions[last_round_num]
                my_last_action = history.my_actions[last_round_num]
                n_coop = np.sum(opp_last_actions)
                if my_last_action:
                    n_coop += 1
                if n_coop >= self.n_players // 2:
                    return Action.C
        return Action.D

class Strategy_COLLECTIVE_461(BaseStrategy):
    """
    Adaptive cooperation strategy based on stock level and historical player behavior.
    Cooperates initially, defects if stock drops below 50% of capacity, defects in last round,
    and defects if significant portion of players defected in previous rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        if history is not None:
            if len(history.my_actions) > 0:
                my_prev_action = history.my_actions[-1]
                my_defected = 0 if my_prev_action else 1
                opp_prev_actions = history.opponent_actions[-1]
                opponent_defectors = np.sum(opp_prev_actions == False)
                total_defectors = my_defected + opponent_defectors
                if total_defectors > self.game_description.n_players / 2:
                    return Action.D
        return Action.C

class Strategy_COLLECTIVE_462(BaseStrategy):
    """
    Cooperate on Sustainable Outcomes (COSO) strategy.
    Cooperates in the first round and continues if the stock remains at capacity,
    otherwise defects to prevent overexploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < self.capacity:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_463(BaseStrategy):
    """Implements an Adaptive Cooperation with Retaliation strategy.
    
    The strategy starts by Cooperating, and in each subsequent round, it calculates the expected stock level
    if all players had Cooperated. If the actual stock is less than this expected value, it Defects in the next
    round; otherwise, it continues to Cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.s_prev = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.s_prev = state.current_stock
            return Action.C
        else:
            if self.s_prev is None:
                self.s_prev = state.current_stock
                return Action.C
            capacity = self.game_description.capacity
            s_prev = self.s_prev
            s_after_coop = s_prev / 2
            growth = 2 * s_after_coop * (1 - s_after_coop / capacity)
            s_expected = s_after_coop + growth
            s_expected = min(s_expected, capacity)
            current_stock = state.current_stock
            if current_stock < s_expected:
                action = Action.D
            else:
                action = Action.C
            self.s_prev = current_stock
            return action

class Strategy_COLLECTIVE_464(BaseStrategy):
    """
    Adaptive Cooperation with Stock Monitoring Strategy.

    This strategy starts by cooperating to build trust and maintain a high stock level.
    It monitors the stock level after each round and switches to defecting if the stock
    drops below a predefined threshold (50% of capacity) or during the last round to maximize
    personal gain without concern for future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.threshold = 0.5 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.n_rounds - 1:
            return Action.D
        if state.current_stock < self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_466(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game, balancing cooperation and defection
    to maximize individual and collective payoffs while preventing overexploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round]
        D_count = self.game_description.n_players - np.sum(opponent_actions_prev)
        n_players = self.game_description.n_players
        threshold = n_players / 2
        current_stock = state.current_stock
        half_capacity = self.game_description.capacity / 2
        if D_count > threshold or current_stock < half_capacity:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_467(BaseStrategy):
    """
    A strategy that combines cooperation with adaptive defection based on resource health and others' actions.
    Cooperates initially, defects if the stock is low or if too many others defected previously, and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        else:
            opponent_actions = history.opponent_actions[state.round_number - 1, :]
            defectors = np.count_nonzero(~opponent_actions)
            if defectors > self.game_description.n_players / 2:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_468(BaseStrategy):
    """
    A strategy that adapts based on the current stock level relative to capacity.
    Cooperates when stock is above 50% of capacity and there are remaining rounds,
    defects otherwise, with the first round always being cooperative.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        remaining_rounds = self.n_rounds - state.round_number
        if remaining_rounds == 1:
            return Action.D
        if state.current_stock > 0.5 * self.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_469(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that balances cooperation, 
    conservation, and strategic punishment.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        half_capacity = self.game_description.capacity / 2.0
        if current_stock < half_capacity:
            return Action.C
        else:
            my_last_action = history.my_actions[state.round_number - 1]
            my_defected_last = not my_last_action
            opponent_last_actions = history.opponent_actions[state.round_number - 1]
            opponent_defections = np.count_nonzero(~opponent_last_actions)
            total_defectors = my_defected_last + opponent_defections
            threshold = self.game_description.n_players / 2.0
            if total_defectors > threshold:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_470(BaseStrategy):
    """
    Adaptive Sustainability (AS) Strategy: Players cooperate initially, adapt based on stock levels and others' cooperation,
    and defect in the final round to maximize gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_target = game_description.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_actions = history.opponent_actions[prev_round]
            n_cooperators = sum(opponents_prev_actions) + (1 if my_prev_action else 0)
            current_stock = state.current_stock
            if current_stock > self.S_target and n_cooperators > self.n_players / 2:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_471(BaseStrategy):
    """
    Cooperates in the first round and continues cooperating as long as the stock level remains above 75% of the capacity; otherwise, defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.current_stock >= 0.75 * self.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_472(BaseStrategy):
    """
    Adaptive strategy that balances cooperation and defection based on stock levels and round number.
    Cooperates to maintain the resource unless the stock falls below half the capacity or it's the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        half_capacity = 0.5 * self.capacity
        if state.current_stock < half_capacity:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_473(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            n_players = self.game_description.n_players
            n_rounds = self.game_description.n_rounds
            capacity = self.game_description.capacity
            if state.round_number == n_rounds - 1:
                any_defection = False
                for prev_round in range(len(history.opponent_actions)):
                    if np.any(history.opponent_actions[prev_round, :] == False):
                        any_defection = True
                        break
                return Action.D if any_defection else Action.C
            else:
                current_stock = state.current_stock
                condition_a = current_stock > 0.5 * capacity
                if not condition_a:
                    return Action.D
                prev_round = state.round_number - 1
                prev_opponent_actions = history.opponent_actions[prev_round, :]
                count_opponents_d = np.count_nonzero(prev_opponent_actions == False)
                my_prev_action = history.my_actions[prev_round]
                my_d = 1 if my_prev_action == False else 0
                num_defectors_prev = count_opponents_d + my_d
                condition_b = num_defectors_prev < n_players / 2
                return Action.C if condition_a and condition_b else Action.D

class Strategy_COLLECTIVE_474(BaseStrategy):
    """
    Adaptive Cooperation with Stock Thresholds strategy.
    Cooperates initially, defects if stock is low or many defected in previous round, defects in last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            my_prev_action = history.my_actions[-1]
            my_defected = 0 if my_prev_action else 1
            opponent_actions_prev = history.opponent_actions[-1]
            opponent_defectors = sum((1 for action in opponent_actions_prev if not action))
            total_prev_defectors = my_defected + opponent_defectors
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            if current_stock < 0.5 * capacity or total_prev_defectors > self.game_description.n_players / 2:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_475(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and defection.
    Cooperates if the stock is above 50% capacity and fewer than half the players defected last round; 
    otherwise defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_stock = state.current_stock
        t_prev = state.round_number - 1
        my_defected = 1 if not history.my_actions[t_prev] else 0
        opponent_actions_last = history.opponent_actions[t_prev, :]
        opponent_defected = np.count_nonzero(~opponent_actions_last)
        total_defectors = my_defected + opponent_defected
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        stock_condition = previous_stock > 0.5 * capacity
        defector_condition = total_defectors < n_players / 2.0
        if stock_condition and defector_condition:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_476(BaseStrategy):
    """
    Adaptive Collective Cooperation with Stock Threshold (ACCT) Strategy.

    This strategy promotes cooperation while safeguarding against over-exploitation.
    It uses a stock threshold to determine actions and punishes excessive defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < 0.2 * self.capacity:
            return Action.D
        if state.round_number == self.r - 1:
            if state.current_stock >= 0.5 * self.capacity:
                count = 0
                total_previous_rounds = state.round_number
                for rnd in range(total_previous_rounds):
                    defectors = np.count_nonzero(~history.opponent_actions[rnd])
                    if defectors <= self.n / 2:
                        count += 1
                if count > total_previous_rounds / 2:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        else:
            previous_round = state.round_number - 1
            defectors_last = np.count_nonzero(~history.opponent_actions[previous_round])
            if defectors_last > self.n / 2:
                return Action.D
            elif state.current_stock >= 0.5 * self.capacity:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_477(BaseStrategy):
    """
    Strategy based on current stock level relative to capacity.
    Cooperates if stock > 50% of capacity, defects otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        half_capacity = 0.5 * self.game_description.capacity
        if state.current_stock > half_capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_478(BaseStrategy):
    """
    Adaptive Cooperation with Stock Conservation Strategy.
    
    This strategy starts by cooperating in the first round to set a foundation for resource sustainability.
    In intermediate rounds, it adapts based on the stock level and the cooperation rate from the previous round.
    If the stock drops below 50% of the capacity, it cooperates to allow replenishment.
    Otherwise, it checks if more than half of the players cooperated previously; if so, it continues to cooperate, else it defects.
    In the last round, it defects to maximize its final payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        others_prev_actions = history.opponent_actions[prev_round, :]
        sum_others = np.sum(others_prev_actions)
        sum_coops = (1 if my_prev_action else 0) + sum_others
        n_players = self.game_description.n_players
        if sum_coops > n_players / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_479(BaseStrategy):
    """
    A strategy that starts with cooperation and switches to defection when stock falls below 50% of capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            fifty_percent = 0.5 * self.capacity
            if state.current_stock > fifty_percent:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_480(BaseStrategy):
    """
    Adaptive Cooperation with Punishment strategy.
    
    This strategy starts by cooperating to establish trust. In subsequent rounds, it adapts based on the stock level
    and opponents' previous actions. It defects if the stock is critically low or if opponents are not cooperating enough.
    In the last round, it defects if many opponents defected previously.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        total_rounds = self.game_description.n_rounds
        round_number = state.round_number
        if round_number == total_rounds - 1:
            my_prev_action = history.my_actions[-1]
            opponent_prev_actions = history.opponent_actions[-1, :]
            prev_coop = my_prev_action + np.sum(opponent_prev_actions)
            prev_coop_rate = prev_coop / n
            if prev_coop_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        elif current_stock < 0.3 * capacity:
            return Action.D
        elif current_stock > 0.7 * capacity:
            my_prev_action = history.my_actions[-1]
            opponent_prev_actions = history.opponent_actions[-1, :]
            prev_coop = my_prev_action + np.sum(opponent_prev_actions)
            prev_coop_rate = prev_coop / n
            if prev_coop_rate >= 0.6:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_481(BaseStrategy):
    """
    This strategy cooperates in the first round. In subsequent rounds, it decides to cooperate if both the current stock is above 50% of capacity and more than half of the rounds remain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        condition1 = current_stock > 0.5 * capacity
        n_rounds = self.game_description.n_rounds
        t = state.round_number
        remaining_rounds = n_rounds - t - 1
        condition2 = remaining_rounds > n_rounds / 2
        if condition1 and condition2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_482(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on the current stock level.
    Cooperates initially and when the stock is above 50% of capacity, otherwise defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock > 0.5 * self.capacity:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_483(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation with resource preservation.
    Cooperates initially, mirrors the majority's previous action, and switches to cooperation if the stock falls below 50% of capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        threshold = 0.5 * capacity
        current_stock = state.current_stock
        if current_stock < threshold:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round]
        n_coop = np.sum(opp_prev_actions) + (1 if my_prev_action else 0)
        n_players = self.game_description.n_players
        if n_coop >= n_players / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_484(BaseStrategy):
    """
    Adaptive Reciprocation with Stock Conservation (ARSC) strategy.
    Cooperates initially, then reciprocates based on others' behavior, conserves stock when low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.threshold = 0.5 * self.capacity
        self.final_round_low_threshold = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        elif round_number == self.game_description.n_rounds - 1:
            if current_stock < self.final_round_low_threshold:
                return Action.D
            else:
                return Action.C
        else:
            last_round = round_number - 1
            my_last_action = history.my_actions[last_round]
            sum_my_defect = 0 if my_last_action else 1
            opponent_last_actions = history.opponent_actions[last_round, :]
            sum_opponent_defect = np.sum(1 - opponent_last_actions)
            total_defectors = sum_my_defect + sum_opponent_defect
            n_players = self.game_description.n_players
            if current_stock < self.threshold:
                return Action.C
            else:
                defector_half = n_players / 2
                if total_defectors < defector_half:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_485(BaseStrategy):
    """
    Adaptive Cooperation with Threshold-Based Defection (ACTBD) Strategy.

    - Cooperate in the first round to build trust.
    - Defect in the last round to maximize immediate payoff.
    - Cooperate in middle rounds if the stock is above 50% of capacity; otherwise, defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            threshold = 0.5 * self.capacity
            if state.current_stock > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_486(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances individual gain with collective sustainability.
    It starts with cooperation and adapts based on the average cooperation rate, while managing stock levels to prevent depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.sum_coop = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_stock < 0.3 * capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if current_stock < 0.2 * capacity:
                return Action.C
        t = state.round_number
        sum_coop = 0.0
        for k in range(t):
            my_action = history.my_actions[k]
            my_c = 1 if my_action else 0
            opp_actions = history.opponent_actions[k]
            opp_c = np.sum(opp_actions)
            sum_coop += my_c + opp_c
        total_actions = t * self.game_description.n_players
        avg_coop = sum_coop / total_actions if total_actions != 0 else 0.0
        if avg_coop >= 0.7:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_487(BaseStrategy):
    """
    Grim Trigger Strategy: Cooperate initially, defect permanently if any deviation 
    from expected cooperation is detected based on stock level discrepancies.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.has_defected = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.has_defected:
            return Action.D
        for k in range(state.round_number):
            my_action = history.my_actions[k]
            my_payoff = history.my_payoffs[k]
            if my_action:
                s_k = 2 * self.n_players * my_payoff
            else:
                s_k = self.n_players * my_payoff
            total_consumption = 0.0
            if my_action:
                contrib = s_k / (2 * self.n_players)
            else:
                contrib = s_k / self.n_players
            total_consumption += contrib
            for opp_act in history.opponent_actions[k, :]:
                if opp_act:
                    contrib = s_k / (2 * self.n_players)
                else:
                    contrib = s_k / self.n_players
                total_consumption += contrib
            s_remaining = s_k - total_consumption
            growth = 2 * s_remaining * (1 - s_remaining / self.capacity)
            s_next_actual = min(s_remaining + growth, self.capacity)
            total_consumption_expected = s_k / 2
            s_remaining_expected = s_k - total_consumption_expected
            growth_expected = 2 * s_remaining_expected * (1 - s_remaining_expected / self.capacity)
            s_next_expected = min(s_remaining_expected + growth_expected, self.capacity)
            if s_next_actual < s_next_expected:
                self.has_defected = True
                break
        return Action.D if self.has_defected else Action.C

class Strategy_COLLECTIVE_488(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that promotes
    cooperation while retaliating against excessive defection to maintain
    stock sustainability. Forgiveness is shown after retaliation if
    cooperation resumes. Critical stock levels trigger defection to secure
    immediate payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_stock = None
        self.retaliate_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.last_stock = state.current_stock
            return Action.C
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == self.game_description.n_rounds - 1:
            if current_stock < 0.3 * capacity:
                return Action.D
            else:
                prev_my_action = history.my_actions[-1]
                prev_opponent_actions = history.opponent_actions[-1, :]
                n_coop_prev = sum(prev_opponent_actions) + (1 if prev_my_action else 0)
                if n_coop_prev >= n_players // 2 + 1:
                    return Action.C
                else:
                    return Action.D
        else:
            if self.retaliate_remaining > 0:
                self.retaliate_remaining -= 1
                return Action.D
            prev_my_action = history.my_actions[-1]
            prev_opponent_actions = history.opponent_actions[-1, :]
            n_defectors = sum((not a for a in [prev_my_action] + list(prev_opponent_actions)))
            if n_defectors >= n_players // 2 + 1:
                self.retaliate_remaining = 2
                return Action.D
            elif current_stock > 0.5 * capacity:
                return Action.C
            else:
                return Action.D
        if current_stock < 0.1 * capacity:
            return Action.D
        self.last_stock = current_stock
        return Action.C

class Strategy_COLLECTIVE_489(BaseStrategy):
    """
    A dynamic strategy that cooperates when the stock is low or a declining trend is detected.
    Cooperates in the first round and adapts based on stock level and trend in subsequent rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        self.stock_history.append(current_stock)
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C
        if current_stock < 0.75 * capacity:
            return Action.C
        n = len(self.stock_history)
        if n >= 3:
            s_prev1 = self.stock_history[-1]
            s_prev2 = self.stock_history[-2]
            s_prev3 = self.stock_history[-3]
            if s_prev1 < s_prev2 and s_prev2 < s_prev3:
                return Action.C
        elif n >= 2:
            s_prev1 = self.stock_history[-1]
            s_prev2 = self.stock_history[-2]
            if s_prev1 < s_prev2:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_490(BaseStrategy):
    """
    Collective Strategy for Common Pool Resource Game.
    Cooperates initially, monitors stock trends, defects when stock is low and decreasing,
    defects in last round, and continues defecting if stock is depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.stock_history = []
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        if state.current_stock <= 0.0:
            return Action.D
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        if state.current_stock <= 0.5 * self.capacity:
            if len(self.stock_history) >= 3:
                past_three = self.stock_history[-3:]
                initialStock = past_three[0]
                finalStock = past_three[-1]
                slope = (finalStock - initialStock) / 2
                if slope < 0:
                    self.punishment_remaining = 2
                    return Action.D
        return Action.C

class Strategy_COLLECTIVE_491(BaseStrategy):
    """
    Adaptive Stock Guardian (ASG) strategy balances individual and collective payoffs by adapting actions based on stock levels and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            n_players = self.game_description.n_players
            sum_coop = sum(opponent_actions_prev)
            defectors = n_players - sum_coop
            defector_proportion = defectors / n_players
            critical_stock = 0.5 * self.game_description.capacity
            if state.current_stock < critical_stock or defector_proportion > 0.3:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_492(BaseStrategy):
    """
    This strategy starts by cooperating in the first round. In subsequent rounds, it defects if the stock falls below 
    50% of the initial capacity or if more than 25% of players defected in the previous round. Otherwise, it continues 
    to cooperate to maintain resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if current_stock < 0.5 * self.capacity:
            return Action.D
        my_last_action = history.my_actions[-1]
        defectors = 0
        if not my_last_action:
            defectors += 1
        for opponent_action in history.opponent_actions[-1]:
            if not opponent_action:
                defectors += 1
        if defectors / self.n_players > 0.25:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_493(BaseStrategy):
    """
    Collective Strategy for Common Pool Resource Game. 
    Cooperates initially, continues if stock and cooperation levels are sufficient, defects in final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opponents_prev = history.opponent_actions[prev_round, :]
        total_coop = sum(opponents_prev) + (1 if my_prev else 0)
        threshold = math.ceil(self.n_players / 2)
        stock_ok = state.current_stock > 0.5 * self.capacity
        if stock_ok and total_coop >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_494(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that balances cooperation with punishment.
    Players cooperate initially, punish widespread defection, and adapt based on stock levels in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = self.n_players / 2.0
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            if state.current_stock >= 0.75 * self.capacity:
                return Action.C
            else:
                return Action.D
        elif self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            my_defected = 0 if my_prev_action else 1
            opponents_prev_actions = history.opponent_actions[prev_round]
            sum_opponents = np.sum(opponents_prev_actions)
            opponent_defections = self.n_players - 1 - sum_opponents
            total_defectors = my_defected + opponent_defections
            if total_defectors > self.threshold:
                self.punishment_remaining = 2
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_495(BaseStrategy):
    """
    Adaptive Cooperative Punisher with Endgame Defection strategy.
    Cooperates initially, defects in the last round, and adapts based on stock level and previous defections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            previous_round = state.round_number - 1
            my_action_prev = history.my_actions[previous_round]
            my_defection = 0 if my_action_prev else 1
            opponent_actions_prev = history.opponent_actions[previous_round, :]
            opponent_defections = (opponent_actions_prev == False).sum()
            D_count = my_defection + opponent_defections
            threshold_low = self.game_description.capacity / 4
            if state.current_stock < threshold_low:
                return Action.C
            elif D_count > self.game_description.n_players / 2:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_496(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Level Trigger strategy for the Common Pool Resource Game.
    This strategy starts by cooperating in the first round, defects in the last round, and switches
    based on the stock level in the middle rounds. It cooperates if the stock is above 50% of the 
    capacity and defects otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.current_stock > 0.5 * self.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_497(BaseStrategy):
    """
    Adaptive Collective Cooperation with Sustainability Thresholds (ACCS)
    Balances individual payoff maximization with collective sustainability.
    Cooperates at high stock levels, defects when stock is moderate, and 
    cooperates again when stock is critically low. In the last round, defects 
    if the stock is sufficient.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            critical_threshold = 0.25 * self.capacity
            if state.current_stock > critical_threshold:
                return Action.D
            else:
                return Action.C
        else:
            stock = state.current_stock
            sustainability_threshold = 0.75 * self.capacity
            critical_threshold = 0.25 * self.capacity
            if stock >= sustainability_threshold:
                return Action.C
            elif stock <= critical_threshold:
                return Action.C
            else:
                prev_round = state.round_number - 1
                if prev_round < 0:
                    return Action.C
                prev_actions = history.opponent_actions[prev_round, :]
                num_defectors = sum((1 for a in prev_actions if a is False))
                if num_defectors > self.n_players / 2:
                    return Action.D
                else:
                    return Action.C

class Strategy_COLLECTIVE_498(BaseStrategy):
    """
    A cooperative strategy promoting sustainable resource management by considering stock health and previous cooperation.
    Cooperates if stock is above 50% capacity and at least half of players cooperated previously.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_coop = history.my_actions[prev_round]
            opp_prev_actions = history.opponent_actions[prev_round, :]
            num_opp_coops = np.sum(opp_prev_actions)
            total_prev_coop = int(my_prev_coop) + num_opp_coops
            stock = state.current_stock
            capacity = self.game_description.capacity
            threshold = 0.5 * capacity
            n = self.game_description.n_players
            if stock > threshold and total_prev_coop / n >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_499(BaseStrategy):
    """
    Adaptive Cooperation with Stock Management (ACSM) strategy.
    Cooperates initially, defects if others over-consume, and cooperates if stock is low.
    Defects in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.stock_history = [state.current_stock]
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            self.stock_history.append(state.current_stock)
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            if current_stock == 0:
                return Action.D
            elif current_stock < 0.25 * capacity:
                return Action.C
            else:
                n_prev_rounds = len(history.my_payoffs)
                prev_round = n_prev_rounds - 1
                prev_my_payoff = history.my_payoffs[prev_round]
                prev_opp_payoffs = history.opponent_payoffs[prev_round, :]
                prev_total = prev_my_payoff + prev_opp_payoffs.sum()
                s_prev = self.stock_history[prev_round]
                if prev_total > s_prev / 2.0:
                    return Action.D
                else:
                    return Action.C

class Strategy_COLLECTIVE_500(BaseStrategy):
    """
    A threshold-based strategy encouraging cooperation when fewer than 50% of players defect,
    and defecting otherwise to maximize personal payoff while considering collective behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        if history.my_actions[-1] == False:
            my_defect = 1
        else:
            my_defect = 0
        opponent_defect = sum((1 for action in history.opponent_actions[-1] if not action))
        total_defectors = my_defect + opponent_defect
        threshold = 0.5 * n_players
        return Action.D if total_defectors >= threshold else Action.C

class Strategy_COLLECTIVE_501(BaseStrategy):
    """
    A strategy that balances cooperation with measured retaliation based on stock levels.
    Cooperates initially, defects if the stock falls below 75% of capacity, and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            threshold = 0.75 * self.game_description.capacity
            if state.current_stock > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_502(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that combines initial cooperation, 
    reciprocal punishment, and adaptive conservation to sustain the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.initial_k = max(1, int(0.05 * n_rounds))
        self.endgame_start_round = n_rounds - max(1, int(0.05 * n_rounds))
        self.punishment_duration = 5
        self.conserve_duration = 10
        self.punishment_remaining = 0
        self.conserve_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round < self.initial_k:
            return Action.C
        elif current_round >= self.endgame_start_round:
            return Action.D
        elif self.conserve_remaining > 0:
            self.conserve_remaining -= 1
            return Action.C
        elif current_stock < 0.2 * self.capacity:
            self.conserve_remaining = self.conserve_duration
            return Action.C
        elif self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        elif history is not None and history.opponent_actions.size > 0:
            last_actions = history.opponent_actions[-1, :]
            cooperators = np.sum(last_actions)
            threshold = 0.8 * self.n_players
            if cooperators >= threshold:
                return Action.C
            else:
                self.punishment_remaining = self.punishment_duration
                return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_503(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) strategy for the Common Pool Resource Game.
    Cooperates initially, punishes defectors for two rounds, and adjusts based on stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        any_defection = False
        if history is not None:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_prev_actions = history.opponent_actions[prev_round]
            opponent_defected = (opponent_prev_actions == 0).any()
            my_defected = not my_prev_action
            any_defection = opponent_defected or my_defected
            if any_defection:
                self.punishment_remaining = 2
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        elif state.current_stock < 0.5 * self.capacity:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_prev_actions = history.opponent_actions[prev_round]
            opponent_all_coop = opponent_prev_actions.all()
            all_coop = opponent_all_coop and my_prev_action
            if all_coop and state.current_stock > 0.5 * self.capacity:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_504(BaseStrategy):
    """
    Cooperate if current stock is above 50% of capacity, defect otherwise.
    Inherits from BaseStrategy and uses threshold-based cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        super().__init__(game_description)
        self.threshold = game_description.capacity * 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.current_stock > self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_505(BaseStrategy):
    """
    Adaptive Cooperation Strategy for the Common Pool Resource Game.
    Cooperates initially then defects if previous consumption was unsustainable.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number - 1
        my_action = history.my_actions[t]
        my_payoff = history.my_payoffs[t]
        n = self.game_description.n_players
        if my_action:
            S_prev = my_payoff * 2 * n
        else:
            S_prev = my_payoff * n
        opponent_actions_prev = history.opponent_actions[t]
        coops = (1 if my_action else 0) + np.sum(opponent_actions_prev)
        total_consumption = coops * (S_prev / (2 * n)) + (n - coops) * (S_prev / n)
        if total_consumption > 0.5 * S_prev:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_506(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that balances cooperation 
    with self-interest, adapting based on group behavior and resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < 0.5 * self.capacity:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.C
        prev_round = state.round_number - 1
        my_previous = history.my_actions[prev_round].item()
        opp_previous = history.opponent_actions[prev_round]
        coop_count = my_previous + opp_previous.sum()
        coop_rate = coop_count / self.n_players
        if coop_rate >= 0.75:
            return Action.C
        elif 0.5 <= coop_rate < 0.75:
            if state.round_number % 2 == 0:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_507(BaseStrategy):
    """
    A strategy that balances individual gain with collective sustainability by adapting based on reciprocity, stock levels, and round position.
    Cooperates in the first round, defects in the last round or when stock is critically low, otherwise Cooperates if a sufficient number of players Cooperated previously.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        critical_stock_level = 0.4 * self.game.capacity
        if current_stock <= critical_stock_level:
            return Action.D
        previous_round = state.round_number - 1
        my_last_action = history.my_actions[previous_round]
        opponent_last_actions = history.opponent_actions[previous_round, :]
        total_coops = sum(opponent_last_actions) + (1 if my_last_action else 0)
        cooperation_rate = total_coops / self.game.n_players
        if cooperation_rate > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_508(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels.
    Cooperates initially and in middle rounds if the stock is sufficiently high, defects in the last round if 
    stock is high to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            if state.current_stock > 0.2 * self.capacity:
                return Action.D
            else:
                return Action.C
        elif state.current_stock > 0.5 * self.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_509(BaseStrategy):
    """
    A strategy that starts with cooperation and switches to defection when the stock falls below half capacity.
    Cooperates in the first round to maximize the resource. Subsequently, cooperates if the stock is at or above half 
    of the capacity; otherwise, defects to protect the resource or respond to overuse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            half_capacity = self.capacity / 2
            if state.current_stock >= half_capacity:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_510(BaseStrategy):
    """
    Adaptive Reciprocity with Sustainability Thresholds (ARST) strategy.
    Cooperates initially, punishes if previous round's consumption is unsustainable,
    and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if current_round == 0:
            self.previous_stock = state.current_stock
            return Action.C
        if current_round == r - 1:
            self.previous_stock = state.current_stock
            return Action.D
        S_prev = self.previous_stock
        prev_round = current_round - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        total_consumption = 0.0
        if my_prev_action:
            my_contribution = S_prev / (2 * n)
        else:
            my_contribution = S_prev / n
        total_consumption += my_contribution
        for opponent_action in opponent_prev_actions:
            if opponent_action:
                opp_contribution = S_prev / (2 * n)
            else:
                opp_contribution = S_prev / n
            total_consumption += opp_contribution
        if total_consumption > S_prev / 2:
            action = Action.D
        else:
            action = Action.C
        self.previous_stock = state.current_stock
        return action

class Strategy_COLLECTIVE_511(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and 
    defection based on stock levels, past cooperation rates, and majority behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_round == 0:
            return Action.C
        if current_round == n_rounds - 1:
            return Action.D
        if state.current_stock < 0.5 * capacity:
            return Action.D
        rounds_to_consider = list(range(1, current_round))
        average_coop = 0.0
        if len(rounds_to_consider) > 0:
            total_coop = 0.0
            for r in rounds_to_consider:
                my_action = history.my_actions[r]
                opponents = history.opponent_actions[r, :]
                n_coop = my_action + np.sum(opponents)
                rate = n_coop / n_players
                total_coop += rate
            average_coop = total_coop / len(rounds_to_consider)
        if average_coop >= 0.7:
            return Action.C
        else:
            latest_round = current_round - 1
            my_action = history.my_actions[latest_round]
            opponents = history.opponent_actions[latest_round, :]
            n_coop = my_action + np.sum(opponents)
            if n_coop / n_players > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_512(BaseStrategy):
    """
    Adaptive Cooperation with Stock Threshold Strategy.

    Cooperates initially and in rounds where the stock is above 50% of capacity. 
    Defects when the stock drops to 50% or below, and always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            threshold = self.capacity / 2
            if state.current_stock > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_1(BaseStrategy):
    """
    Adaptive Exploitation with Sustainability Strategy.

    This strategy begins by cooperating in the first round. In subsequent rounds, 
    it uses dynamic stock thresholds and defection rates from previous rounds to 
    decide whether to cooperate or defect. The strategy defects in the last round.
    It balances exploitation with sustainability by considering stock levels and 
    opponents' past actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        threshold = 2.0 * self.capacity / (self.n_players + 1)
        current_stock = state.current_stock
        opponent_actions = history.opponent_actions[:state.round_number, :]
        total_defections = np.sum(opponent_actions == False)
        num_rounds = state.round_number
        num_opponents = self.n_players - 1
        average_defection = total_defections / (num_rounds * num_opponents) if num_rounds > 0 else 0.0
        prev_opp_actions = history.opponent_actions[state.round_number - 1, :]
        prev_defections = np.sum(prev_opp_actions == False)
        prev_defect_rate = prev_defections / num_opponents
        if current_stock > threshold and average_defection <= 0.5 and (prev_defect_rate <= 0.5):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_2(BaseStrategy):
    """
    Adaptive Exploitation with Stock Conservation strategy.

    Cooperates initially, then adapts based on player defections and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            if current_stock < 0.5 * self.capacity:
                return Action.D
            opponent_actions_last = history.opponent_actions[-1]
            opponent_defectors = len(opponent_actions_last) - np.sum(opponent_actions_last)
            my_defection = 0 if history.my_actions[-1] else 1
            total_defectors = opponent_defectors + my_defection
            if total_defectors > self.n_players / 2:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_3(BaseStrategy):
    """
    A strategy that adapts to others' behavior while managing the common pool resource.
    Cooperates initially, defects if many others defect, and defects in the last round.
    Balances sustainability and payoff maximization based on stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            action = Action.C
            self.previous_stock = state.current_stock
            return action
        if current_round == self.r - 1:
            action = Action.D
            self.previous_stock = state.current_stock
            return action
        my_prev_action = history.my_actions[current_round - 1]
        opp_prev_actions = history.opponent_actions[current_round - 1, :]
        D_prev = 0
        if not my_prev_action:
            D_prev += 1
        for action in opp_prev_actions:
            if not action:
                D_prev += 1
        if D_prev > self.n / 2:
            action = Action.D
        else:
            total_consumption = 0.0
            for i in range(self.n):
                if i == 0:
                    current_action = my_prev_action
                else:
                    current_action = opp_prev_actions[i - 1]
                if current_action:
                    consumption = self.previous_stock / (2 * self.n)
                else:
                    consumption = self.previous_stock / self.n
                total_consumption += consumption
            S_remaining_prev = max(0.0, self.previous_stock - total_consumption)
            if S_remaining_prev < self.capacity / 2:
                action = Action.C
            else:
                action = Action.D
        self.previous_stock = state.current_stock
        return action

class Strategy_EXPLOITATIVE_4(BaseStrategy):
    """
    Cooperate if current stock exceeds 50% of capacity, otherwise defect.
    This strategy balances immediate gain with sustainable resource use.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        threshold = self.capacity / 2
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_5(BaseStrategy):
    """
    Adaptive Exploitation with Sustainability Checks strategy for the Common Pool Resource Game.
    Cooperates initially, then reciprocates based on majority behavior, while safeguarding resource levels and defecting in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C
        elif state.round_number == n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            if current_stock <= 0.5 * capacity:
                return Action.C
            elif current_stock >= 0.75 * capacity:
                return Action.D
            else:
                t = state.round_number - 1
                my_prev_action = history.my_actions[t]
                my_defection = 0 if my_prev_action else 1
                opponent_actions_prev = history.opponent_actions[t, :]
                opponent_defectors = opponent_actions_prev.shape[0] - np.sum(opponent_actions_prev)
                total_defectors = my_defection + opponent_defectors
                if total_defectors > n_players / 2:
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_6(BaseStrategy):
    """
    Adaptive Exploitation with Sustainability strategy for the Common Pool Resource Game.
    The strategy balances cooperation and defection based on stock levels, opponents' actions, and round number.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_stock = state.current_stock
        previous_round = state.round_number - 1
        my_actions = history.my_actions
        opponent_actions = history.opponent_actions
        my_action = my_actions[previous_round]
        my_defection = 0 if my_action else 1
        opponents_in_previous = opponent_actions[previous_round, :]
        opponent_defections = sum((0 if action else 1 for action in opponents_in_previous))
        total_defections = my_defection + opponent_defections
        if previous_stock < 0.5 * self.capacity:
            return Action.D
        if total_defections > self.n_players / 2:
            return Action.D
        if state.round_number == self.n_rounds - 1:
            if previous_stock >= 0.5 * self.capacity:
                return Action.C
            else:
                return Action.D
        elif random.random() < 0.1:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_7(BaseStrategy):
    """
    Adaptive Exploitation Strategy for the Common Pool Resource Game.
    Cooperates initially, defects if stock decreases, and always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_stock = state.current_stock
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < self.previous_stock:
            action = Action.D
        else:
            action = Action.C
        self.previous_stock = current_stock
        return action

class Strategy_EXPLOITATIVE_8(BaseStrategy):
    """
    Adaptive Exploitation with Sustainability Strategy.
    
    This strategy balances between exploiting the common pool resource and conserving it
    for future rounds. It cooperates initially to observe others, defects when many others
    have defected, conserves when the stock is low, and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock < self.capacity / 2:
            return Action.C
        prev_actions = history.opponent_actions[-1]
        defectors = sum((not action for action in prev_actions))
        if defectors > self.n_players / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_9(BaseStrategy):
    """
    A strategy that adaptively switches between cooperation and defection based on historical behavior and stock levels.
    Cooperates initially, defects if stock is low or many players defected in the previous round, and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round]
        opponents_defected = np.sum(~opponent_actions_prev)
        my_prev = history.my_actions[prev_round]
        my_defected = 0 if my_prev else 1
        total_defectors = opponents_defected + my_defected
        current_stock = state.current_stock
        threshold = self.game_description.capacity / 2
        if total_defectors > self.game_description.n_players / 2 or current_stock < threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_10(BaseStrategy):
    """
    Adaptive Cooperation with Stock Consideration Strategy.
    Cooperates initially, then adapts based on opponent actions and stock trends.
    Defects if high defection rate and declining stock, or in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_rounds = game_description.n_rounds
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.total_rounds - 1:
            return Action.D
        avg_defectors = self._calculate_average_defectors(history)
        trend = self._get_stock_trend()
        if avg_defectors > 0.3 and trend == 'declining':
            return Action.D
        else:
            return Action.C

    def _calculate_average_defectors(self, history: PlayerHistory) -> float:
        if history is None or len(history.opponent_actions) == 0:
            return 0.0
        n_opponents = history.opponent_actions.shape[1]
        total_defectors = 0.0
        for round_data in history.opponent_actions:
            cooperators = np.sum(round_data)
            defectors = n_opponents - cooperators
            total_defectors += defectors
        avg = total_defectors / len(history.opponent_actions)
        return avg

    def _get_stock_trend(self) -> str:
        if len(self.stock_history) < 2:
            return 'stable'
        prev = self.stock_history[-2]
        current = self.stock_history[-1]
        delta = current - prev
        if delta > 1e-09:
            return 'increasing'
        elif delta < -1e-09:
            return 'declining'
        else:
            return 'stable'

class Strategy_EXPLOITATIVE_11(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Common Pool Resource Game.
    Cooperates initially, then switches to Defect if more than 50% of players Defected
    in the previous round or stock levels drop below 50% of capacity. Defects in the last two rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_r = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        if state.round_number >= n_r - 2:
            return Action.D
        prev_round_idx = state.round_number - 1
        my_prev_action = history.my_actions[prev_round_idx]
        prev_defect_self = 0 if my_prev_action else 1
        prev_opponent_actions = history.opponent_actions[prev_round_idx]
        prev_defect_opponents = (~prev_opponent_actions).sum()
        prev_total_defectors = prev_defect_self + prev_defect_opponents
        threshold = n_players / 2
        if prev_total_defectors > threshold or state.current_stock < 0.5 * capacity:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_12(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that starts with cooperation, 
    adapts based on the average cooperation rate, and conserves the stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_prev_actions = history.opponent_actions[prev_round]
            coop_count = 1 if my_prev_action else 0
            coop_count += np.sum(opponent_prev_actions)
            avg_coop_rate = coop_count / self.game_description.n_players
            if avg_coop_rate >= 0.5:
                half_capacity = self.game_description.capacity / 2
                if state.current_stock > half_capacity:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_13(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances immediate gain with long-term sustainability.
    Cooperates initially, defects when stock is high, cooperates when stock is low, and uses the majority 
    previous action for intermediate stock levels. Defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        threshold_high = 0.75 * capacity
        threshold_low = 0.25 * capacity
        if current_stock > threshold_high:
            return Action.D
        elif current_stock < threshold_low:
            return Action.C
        elif history is None:
            return Action.D
        else:
            prev_actions = history.opponent_actions[-1, :]
            n_opponents = prev_actions.shape[0]
            count_coop = sum(prev_actions)
            count_defect = n_opponents - count_coop
            if count_defect > n_opponents / 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_14(BaseStrategy):
    """
    This strategy starts by cooperating, then adaptively switches based on stock trends and others' behavior.
    It uses a combination of stock trend analysis and defector estimation to decide actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.k = 3
        self.threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock < self.game_description.capacity / 2:
                return Action.D
            else:
                return Action.C
        self.stock_history.append(state.current_stock)
        if len(self.stock_history) >= self.k + 1:
            current = self.stock_history[-1]
            past = self.stock_history[-self.k - 1]
            trend_improving = current > past
        else:
            trend_improving = False
        if trend_improving:
            return Action.C
        prev_round = state.round_number - 1
        S_prev = self.stock_history[-2] if len(self.stock_history) >= 2 else 0
        my_prev_action = history.my_actions[prev_round]
        opp_actions_prev = history.opponent_actions[prev_round]
        count_C = 0
        if my_prev_action:
            count_C += 1
        count_C += np.sum(opp_actions_prev)
        n = self.game_description.n_players
        total_coop = S_prev / 2.0
        sum_C = count_C * (S_prev / (2 * n))
        sum_D = (n - count_C) * (S_prev / n)
        total_consumption = sum_C + sum_D
        if total_consumption > total_coop:
            defector_estimate = n - count_C
            defector_proportion = defector_estimate / n
            if defector_proportion > self.threshold:
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_15(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to others' behavior and stock levels.
    Cooperates initially, then responds to stock levels and opponents' cooperation rates.
    Defects in the final round and when others' average cooperation is below a threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.opponent_count = self.n_players - 1
        self.opponent_coop_rates = [0.0] * self.opponent_count
        self.last_processed_round = [-1] * self.opponent_count
        self.alpha = 0.7

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        for i in range(self.opponent_count):
            last_r_processed = self.last_processed_round[i]
            for r in range(last_r_processed + 1, current_round):
                if r >= len(history.opponent_actions):
                    break
                action = history.opponent_actions[r][i]
                current_action = 1.0 if action else 0.0
                self.opponent_coop_rates[i] = self.alpha * self.opponent_coop_rates[i] + (1.0 - self.alpha) * current_action
            self.last_processed_round[i] = current_round - 1
        if state.current_stock < 0.5 * self.capacity:
            return Action.C
        else:
            avg_coop = np.mean(self.opponent_coop_rates)
            if avg_coop < 0.5:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_16(BaseStrategy):
    """
    Exploitative Strategy for Common Pool Resource Game.
    Cooperates initially, defects based on stock and historical defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == n_rounds - 1:
            return Action.D
        if current_stock < capacity * 0.5:
            return Action.C
        start = max(0, current_round - 3)
        end = current_round - 1
        total_defectors = 0.0
        num_rounds = 0
        for r in range(start, end + 1):
            my_defect = 0 if history.my_actions[r] else 1
            opp_defect = np.sum(history.opponent_actions[r] == False)
            total_defectors += my_defect + opp_defect
            num_rounds += 1
        if num_rounds == 0:
            return Action.C
        average_defectors = total_defectors / num_rounds
        threshold = n_players / 2
        if average_defectors > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_17(BaseStrategy):
    """
    A strategy that adapts based on stock levels and opponents' defection rates.
    Cooperates initially, defects if stock is critically low, and switches to defecting if a majority of opponents defect consistently.
    Defects in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        stock_threshold = 0.2 * self.capacity
        if current_stock < stock_threshold:
            return Action.D
        if history is None:
            return Action.C
        current_round = state.round_number
        opponent_actions = history.opponent_actions
        start = max(0, current_round - 2)
        end = current_round
        last_two_rounds = opponent_actions[start:end]
        try:
            count_defects = np.sum(last_two_rounds == False)
        except TypeError:
            count_defects = 0
        total_actions = last_two_rounds.size
        defect_ratio = count_defects / total_actions if total_actions > 0 else 0.0
        if defect_ratio > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_18(BaseStrategy):
    """
    A strategy that balances cooperation with defection based on stock levels and previous defections.
    Cooperates initially, defects when many others defect, and uses a dynamic threshold to decide.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponents_prev_actions = history.opponent_actions[prev_round, :]
            n_players = self.game_description.n_players
            my_d = 0 if my_prev_action else 1
            opponent_d_count = opponents_prev_actions.shape[0] - np.sum(opponents_prev_actions)
            D_count = my_d + opponent_d_count
            if D_count > n_players / 2:
                return Action.D
            else:
                t_strat = state.round_number + 1
                r = self.game_description.n_rounds
                threshold = (1 - t_strat / r) * self.game_description.capacity
                if state.current_stock > threshold:
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_20(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on the average number of defectors and stock sustainability.
    Cooperates initially, then uses recent behavior and stock levels to decide actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        max_recent = 5
        start_round = max(0, state.round_number - max_recent)
        recent_rounds = history.opponent_actions[start_round:state.round_number]
        defector_counts = []
        for r in recent_rounds:
            count = sum((1 - action for action in r))
            defector_counts.append(count)
        d_avg = sum(defector_counts) / len(defector_counts) if defector_counts else 0.0
        threshold = self.n_players / 2.0
        if d_avg > threshold:
            return Action.C
        if state.current_stock < 0.5 * self.capacity:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_22(BaseStrategy):
    """
    Adaptive Exploitation with Stock Conservation Strategy.
    Cooperates initially, defects in the last round, adapts based on others' defection rates
    and conserves stock when levels are critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        if state.current_stock < 0.5 * capacity:
            return Action.C
        prev_opponent_actions = history.opponent_actions[-1, :]
        n_prev_opponents = len(prev_opponent_actions)
        cooperators = np.sum(prev_opponent_actions)
        defectors = n_prev_opponents - cooperators
        proportion_defectors = defectors / n_prev_opponents
        if proportion_defectors > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_23(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource game that balances 
    immediate gains with long-term sustainability by adapting to stock levels 
    and opponents' past actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.5 * self.capacity:
            return Action.C
        else:
            prev_round = state.round_number - 1
            my_defected = not history.my_actions[prev_round]
            opponent_prev_actions = history.opponent_actions[prev_round]
            opponent_defectors = np.sum(opponent_prev_actions == False)
            total_defectors = opponent_defectors + (1 if my_defected else 0)
            if total_defectors > self.n_players / 2:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_24(BaseStrategy):
    """
    A strategy that adapts based on other players' consumption patterns.
    Cooperates initially, then defects if others over-exploit, with endgame defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        self.stock_history.append(state.current_stock)
        if t == 0:
            return Action.C
        r = self.game_description.n_rounds
        remaining_rounds = r - t
        if remaining_rounds <= 5:
            return Action.D
        prev_stock = self.stock_history[t - 1]
        prev_round = t - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        n_players = self.game_description.n_players
        total_consumption = 0.0
        if my_prev_action:
            my_cons = prev_stock / (2 * n_players)
        else:
            my_cons = prev_stock / n_players
        total_consumption += my_cons
        for action in opponent_actions_prev:
            if action:
                cons = prev_stock / (2 * n_players)
            else:
                cons = prev_stock / n_players
            total_consumption += cons
        average_cons = total_consumption / n_players
        cooperative_share = prev_stock / (2 * n_players)
        ratio = float('inf') if cooperative_share == 0 else average_cons / cooperative_share
        threshold = 1.5
        capacity = self.game_description.capacity
        if ratio > threshold or prev_stock < 0.3 * capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_25(BaseStrategy):
    """
    An adaptive strategy that balances cooperation with exploitation, considering stock levels and historical defections.
    Cooperates initially, defects if others defected excessively or in the last round, and adjusts based on stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == n_rounds - 1:
            return Action.D
        if current_stock < 0.5 * capacity:
            return Action.C
        previous_rounds = current_round
        total_defectors = 0
        for round in range(previous_rounds):
            my_defect = 0 if history.my_actions[round] else 1
            opponent_defect = np.count_nonzero(history.opponent_actions[round] == False)
            total_defectors += my_defect + opponent_defect
        avg_defectors = total_defectors / previous_rounds
        threshold = n_players / 2
        if avg_defectors > threshold:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_26(BaseStrategy):
    """
    This strategy implements a mix of cooperation and defection based on observed behavior and stock levels.
    It starts with cooperation, then adapts based on consumption patterns, remaining rounds, stock depletion,
    and forgiveness conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_stocks = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_stocks.append(state.current_stock)
            return Action.C
        self.previous_stocks.append(state.current_stock)
        prev_round_number = state.round_number - 1
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        rounds_remaining = self.game_description.n_rounds - state.round_number
        S_prev_before = self.previous_stocks[prev_round_number]
        my_prev_action = history.my_actions[prev_round_number]
        opponent_prev_actions = history.opponent_actions[prev_round_number, :]
        total_cons = 0.0
        for i in range(n):
            if i == 0:
                action = my_prev_action
            else:
                action = opponent_prev_actions[i - 1]
            if action:
                cons = S_prev_before / (2 * n)
            else:
                cons = S_prev_before / n
            total_cons += cons
        avg_prev_cons = total_cons / n
        threshold = 1.5 * (S_prev_before / (2 * n))
        defect1 = avg_prev_cons > threshold
        defect2 = rounds_remaining <= 2
        defect3 = state.current_stock < capacity / 2
        defect = defect1 or defect2 or defect3
        if defect:
            if state.round_number > 1:
                two_rounds_ago = state.round_number - 2
                if two_rounds_ago >= 0:
                    S_two_rounds_ago = self.previous_stocks[two_rounds_ago]
                    if S_two_rounds_ago > state.current_stock * 0.8:
                        return Action.C
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_27(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection based on stock trends and thresholds.
    Cooperates initially, defects in the last round, and adapts based on stock level trends in intermediate rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_stock = state.current_stock
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        previous_stock = self.previous_stock
        trend = current_stock - previous_stock
        threshold = 0.7 * self.game_description.capacity
        if current_stock < threshold and trend < 0:
            action = Action.C
        else:
            action = Action.D
        self.previous_stock = current_stock
        return action

class Strategy_EXPLOITATIVE_28(BaseStrategy):
    """
    A strategy that cooperates when the stock is above 50% of capacity and more than 10 rounds remain, otherwise defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        remaining_rounds = self.game_description.n_rounds - state.round_number - 1
        if remaining_rounds < 10:
            return Action.D
        elif state.current_stock > 0.5 * self.game_description.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_29(BaseStrategy):
    """
    An adaptive strategy that starts by Cooperating, then responds to stock trends.
    Cooperates if the stock decreased from the previous round, otherwise Defects.
    Defects in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round == 0:
            self.previous_stock = state.current_stock
            return Action.C
        elif current_round == total_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            if current_stock < self.previous_stock:
                action = Action.C
            else:
                action = Action.D
            self.previous_stock = current_stock
            return action

class Strategy_EXPLOITATIVE_30(BaseStrategy):
    """
    A strategy that balances exploiting others' cooperation with maintaining a sustainable stock level.
    Cooperates initially, defects in the last round, and uses stock level and others' cooperation history to decide actions otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        round_number = state.round_number
        if round_number == n_rounds - 1:
            return Action.D
        if round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        current_stock = state.current_stock
        stock_pct = current_stock / capacity * 100
        if stock_pct < 25:
            return Action.C
        n_opponents = self.game_description.n_players - 1
        n_rounds_so_far = round_number
        opp_actions = history.opponent_actions[:round_number, :]
        sum_C = np.sum(opp_actions)
        avg_coop = sum_C / (n_rounds_so_far * n_opponents) if n_rounds_so_far * n_opponents != 0 else 0.0
        if stock_pct > 50 and avg_coop >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_31(BaseStrategy):
    """
    Adaptive Conservation-Exploitation strategy for the Common Pool Resource Game.
    Balances conservation in early rounds, dynamic cooperation/exploitation in middle rounds,
    and defection in late rounds. Adapts based on stock levels and round progression.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == total_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < 0.5 * capacity:
            return Action.D
        phase_early_cutoff = int(total_rounds * 0.25)
        phase_middle_cutoff = phase_early_cutoff + int(total_rounds * 0.5)
        current_round = state.round_number
        if current_round < phase_early_cutoff:
            return Action.C
        elif current_round < phase_middle_cutoff:
            if current_stock >= 0.5 * capacity:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_32(BaseStrategy):
    """
    Adaptive Exploitation Strategy for the Common Pool Resource Game.
    Cooperates initially, then adapts based on stock level and others' cooperation.
    Defects in endgame rounds to maximize late-game payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = self.capacity / 2.0
        self.endgame_threshold = int(0.7 * self.n_rounds)

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        opponent_actions_last_round = history.opponent_actions[previous_round, :]
        cooperators = np.sum(opponent_actions_last_round)
        avg_coop = cooperators / (self.n_players - 1) if self.n_players - 1 != 0 else 0.0
        if state.current_stock > self.threshold and avg_coop >= 0.5:
            return Action.D
        elif state.round_number >= self.endgame_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_33(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource game that balances cooperation and exploitation.
    Cooperates initially, then adapts based on stock levels and opponents' historical actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        high_threshold = 0.75 * self.capacity
        low_threshold = 0.25 * self.capacity
        if current_stock > high_threshold:
            last_round = state.round_number - 1
            my_action = history.my_actions[last_round]
            opponents_actions = history.opponent_actions[last_round]
            coop_count = (1 if my_action else 0) + sum(opponents_actions)
            coop_rate = coop_count / self.n_players
            if coop_rate >= 0.7:
                return Action.C
            else:
                return Action.D
        elif current_stock < low_threshold:
            return Action.D
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            total_defections = 0
            total_actions = 0
            for r in range(state.round_number):
                my_action = history.my_actions[r]
                total_defections += 0 if my_action else 1
                total_actions += 1
                opponents_actions = history.opponent_actions[r]
                num_opponents = len(opponents_actions)
                num_defections = num_opponents - sum(opponents_actions)
                total_defections += num_defections
                total_actions += num_opponents
            if total_actions == 0:
                return Action.C
            defection_rate = total_defections / total_actions
            if defection_rate > 0.3:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_34(BaseStrategy):
    """
    This strategy begins with cooperation and adapts based on previous actions and stock levels.
    It balances exploitation and preservation to optimize long-term payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        if state.round_number == 0:
            return Action.C
        if state.round_number == n_rounds - 1:
            return Action.D
        stock_ratio = current_stock / capacity
        if current_stock < 0.1 * capacity:
            return Action.C
        if stock_ratio > 0.8:
            return Action.D
        if current_stock < 0.3 * capacity:
            return Action.C
        prev_my_coop = history.my_actions[-1]
        prev_opponent_coop = sum(history.opponent_actions[-1, :])
        num_coop = prev_my_coop + prev_opponent_coop
        if num_coop > n_players / 2:
            if stock_ratio > 0.75:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_35(BaseStrategy):
    """
    Adaptive Trigger Strategy for the Common Pool Resource Game.
    This strategy begins with cooperation, monitors the common pool stock level, 
    and defects if there is significant stock shortfall indicating widespread defection. 
    It reverts to cooperation if the stock recovers.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.defect_triggered = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        r = self.game_description.n_rounds
        if round_number == 0:
            return Action.C
        expected_stock = self.capacity
        for t in range(1, round_number + 1):
            if expected_stock <= 0:
                expected_stock = 0
                continue
            consumption = expected_stock / 2
            s_remaining = max(expected_stock - consumption, 0)
            growth = 2 * s_remaining * (1 - s_remaining / self.capacity)
            new_stock = s_remaining + growth
            expected_stock = min(new_stock, self.capacity)
        stock_shortfall = expected_stock - current_stock
        threshold = 0.2 * self.capacity
        if round_number == r - 1:
            if current_stock > 0.5 * self.capacity:
                return Action.C
            else:
                return Action.D
        if current_stock <= 0:
            return Action.D
        if self.defect_triggered:
            if stock_shortfall <= threshold:
                self.defect_triggered = False
        elif stock_shortfall > threshold:
            self.defect_triggered = True
        return Action.D if self.defect_triggered else Action.C

class Strategy_EXPLOITATIVE_36(BaseStrategy):
    """
    Adaptive Exploitation Strategy for the Common Pool Resource Game.
    Cooperates initially, then adapts based on others' behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        game_desc = self.game_description
        n_players = game_desc.n_players
        capacity = game_desc.capacity
        current_stock = state.current_stock
        r = state.round_number
        sum_me = np.sum(history.my_actions[:r])
        sum_opponents = np.sum(history.opponent_actions[:r, :])
        total_C = sum_me + sum_opponents
        avg_coop = total_C / (r * n_players) * 100
        if r == game_desc.n_rounds - 1:
            if avg_coop >= 50 and current_stock >= 0.3 * capacity:
                return Action.C
            else:
                return Action.D
        elif current_stock < 0.3 * capacity:
            return Action.D
        elif avg_coop >= 70:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_37(BaseStrategy):
    """
    A strategy that starts with cooperation, adapts based on stock level and opponents' past defections, 
    and defects in the final round to maximize immediate gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            ht = 0.66 * self.capacity
            if current_stock > ht:
                return Action.D
            else:
                if history is None:
                    return Action.C
                previous_rounds = state.round_number
                opponent_actions = history.opponent_actions[:previous_rounds, :]
                total_defections = np.sum(opponent_actions == False)
                possible_actions = previous_rounds * (self.n_players - 1)
                k_avg = total_defections / possible_actions
                if k_avg >= 0.5:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_38(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that adaptively exploits others' cooperation while maintaining stock sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock <= 0:
            return Action.D
        last_round = state.round_number - 1
        opponent_actions_last_round = history.opponent_actions[last_round]
        sum_opponents_coop = np.sum(opponent_actions_last_round)
        my_last_action = bool(history.my_actions[last_round])
        total_coop_last_round = sum_opponents_coop + (1 if my_last_action else 0)
        last_coop_rate = total_coop_last_round / self.game_description.n_players
        if state.current_stock > 0.75 * self.game_description.capacity and last_coop_rate >= 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_39(BaseStrategy):
    """Adaptive Resource Exploitation Strategy (ARES) is a dynamic approach balancing cooperation and defection based on past consumption patterns and stock levels."""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_stock = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            self.last_stock = state.current_stock
            return Action.C
        else:
            if state.round_number == self.game_description.n_rounds - 1:
                self.last_stock = state.current_stock
                return Action.D
            if state.current_stock < 0.2 * self.game_description.capacity:
                self.last_stock = state.current_stock
                return Action.D
            else:
                prev_stock = self.last_stock
                n = self.game_description.n_players
                total_consumption = 0.0
                my_prev_action = history.my_actions[-1]
                if my_prev_action:
                    total_consumption += prev_stock / (2 * n)
                else:
                    total_consumption += prev_stock / n
                for opponent_action in history.opponent_actions[-1, :]:
                    if opponent_action:
                        total_consumption += prev_stock / (2 * n)
                    else:
                        total_consumption += prev_stock / n
                if total_consumption / self.game_description.capacity > 0.5:
                    self.last_stock = state.current_stock
                    return Action.D
                else:
                    self.last_stock = state.current_stock
                    return Action.C

class Strategy_EXPLOITATIVE_40(BaseStrategy):
    """
    A strategy that cooperates in the first round, cooperates when the stock is above half capacity 
    in middle rounds, defects when the stock falls below half capacity, and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.total_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == self.total_rounds - 1:
            return Action.D
        threshold = self.capacity / 2
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_42(BaseStrategy):
    """
    Implements a strategy that balances cooperation and defection based on stock levels and opponents' past actions.
    Cooperates initially, adapts based on resource depletion, and defects strategically in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            n_rounds = self.game_description.n_rounds
            capacity = self.game_description.capacity
            if state.round_number == n_rounds - 1:
                half_capacity = capacity * 0.5
                if state.current_stock > half_capacity:
                    return Action.D
                else:
                    return Action.C
            else:
                half_capacity = capacity * 0.5
                if state.current_stock < half_capacity:
                    return Action.C
                else:
                    t = state.round_number
                    sum_coop = 0.0
                    for r in range(t):
                        my_action = history.my_actions[r]
                        sum_coop += 1 if my_action else 0
                        opponents_actions = history.opponent_actions[r]
                        sum_coop += np.sum(opponents_actions)
                    n_players = self.game_description.n_players
                    average_coop = sum_coop / (t * n_players) if t != 0 else 0.0
                    return Action.C if average_coop >= 0.5 else Action.D

class Strategy_EXPLOITATIVE_43(BaseStrategy):
    """
    This strategy cooperates when the stock is sufficient and others are cooperating,
    and defects when the stock is low or others are frequently defecting.
    It defects in the last round to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        threshold = capacity / 2
        current_stock = state.current_stock
        stock_trigger = current_stock < threshold
        n_players = self.game_description.n_players
        t = state.round_number
        start_round = max(0, t - 3)
        total_defections = 0
        for round in range(start_round, t):
            opponent_actions = history.opponent_actions[round]
            defectors = sum((1 for act in opponent_actions if not act))
            total_defections += defectors
        number_of_rounds = t - start_round
        if number_of_rounds == 0:
            average_defection_rate = 0.0
        else:
            average_defection_rate = total_defections / (number_of_rounds * (n_players - 1))
        defection_trigger = average_defection_rate > 0.3
        if stock_trigger or defection_trigger:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_44(BaseStrategy):
    """
    A strategy that balances immediate gains with long-term resource preservation in a Common Pool Resource game.
    It cooperates initially, defects in the last round, and adapts based on stock levels and previous actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            half_capacity = 0.5 * self.game_description.capacity
            if state.current_stock < half_capacity:
                return Action.C
            else:
                prev_round = state.round_number - 1
                player_defected = 0 if history.my_actions[prev_round] else 1
                opponent_actions_prev = history.opponent_actions[prev_round]
                opponents_defected = (opponent_actions_prev == False).sum()
                total_defectors = player_defected + int(opponents_defected)
                half_n = self.game_description.n_players / 2
                if total_defectors > half_n:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_45(BaseStrategy):
    """
    Implement an adaptive strategy for the Common Pool Resource Game, 
    starting with cooperation, dynamically adjusting based on stock levels, 
    and defecting in late rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.initial_threshold = int(0.25 * self.n_rounds)
        self.middle_threshold = int(0.75 * self.n_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.round_number < self.initial_threshold:
            return Action.C
        if state.round_number >= self.middle_threshold:
            return Action.D
        if state.current_stock > 0.5 * self.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_46(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and defection based on 
    dynamic thresholds and opponents' behavior to maximize cumulative payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.n_players = game_description.n_players
        self.should_always_defect = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        has_majority_defection = False
        if history is not None:
            for round_in_history in range(state.round_number):
                opp_def = 0
                for p in range(self.n_players - 1):
                    if not history.opponent_actions[round_in_history, p]:
                        opp_def += 1
                my_def = 0 if history.my_actions[round_in_history] else 1
                total_def = opp_def + my_def
                if total_def > self.n_players // 2:
                    has_majority_defection = True
                    break
            if has_majority_defection:
                self.should_always_defect = True
        if self.should_always_defect:
            return Action.D
        else:
            current_stock = state.current_stock
            if current_stock < 0.2 * self.capacity:
                return Action.C
            else:
                t = state.round_number + 1
                r = self.n_rounds
                threshold = self.capacity * max(0.7, 1 - t / r)
                if current_stock > threshold:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_47(BaseStrategy):
    """
    A dynamic strategy for the Common Pool Resource Game, balancing cooperation and defection based on stock levels and historical defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        condition1 = current_stock > 0.75 * capacity
        if not condition1:
            return Action.C
        total_d = 0
        for t in range(state.round_number):
            round_d = n - 1 - np.sum(history.opponent_actions[t, :])
            total_d += round_d
        avg_defection_rate = total_d / (state.round_number * (n - 1) + 1e-09)
        condition2 = avg_defection_rate < 0.3
        if condition1 and condition2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_48(BaseStrategy):
    """
    Exploitative Strategy for the Common Pool Resource Game.
    
    This strategy starts by cooperating in the first round. In subsequent rounds,
    it defects if the stock falls below 30% of capacity or if more than 50% of
    players have defected on average historically. It always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        t = state.round_number
        if t == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if t == n_rounds - 1:
            return Action.D
        if state.current_stock < 0.3 * capacity:
            return Action.D
        total_defectors = 0.0
        n_players = self.game_description.n_players
        previous_rounds = t
        for round_t in range(previous_rounds):
            my_d = 0 if history.my_actions[round_t] else 1
            opponent_actions = history.opponent_actions[round_t, :]
            n_opponents = opponent_actions.shape[0]
            sum_coop = np.sum(opponent_actions)
            opponent_defectors = n_opponents - sum_coop
            total_defectors += my_d + opponent_defectors
        average_defectors = total_defectors / previous_rounds
        threshold = n_players / 2
        if average_defectors > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_49(BaseStrategy):
    """
    Adaptive Threshold Exploitation strategy for the Common Pool Resource Game.
    Cooperates initially, then adapts based on defector proportion and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        round_number = state.round_number
        if round_number == n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        threshold = 0.25 * capacity
        if current_stock < threshold:
            return Action.C
        last_round_actions = history.opponent_actions[-1]
        defectors = np.sum(~last_round_actions)
        n_players = self.game_description.n_players
        if defectors > n_players / 2:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_50(BaseStrategy):
    """
    A strategy that starts with cooperation, then adapts based on cooperation rate and stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_lower_bound = 0.3 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        my_prev_act = history.my_actions[state.round_number - 1]
        opp_prev_act = history.opponent_actions[state.round_number - 1, :]
        total_coop = my_prev_act + opp_prev_act.sum()
        coop_rate = total_coop / self.n_players
        s_prev = state.current_stock
        if coop_rate >= 0.5 and s_prev > self.stock_lower_bound:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_51(BaseStrategy):
    """
    Adaptive Exploitation Based on Stock Trends (AEBST)
    This strategy starts by cooperating to observe the initial stock dynamics.
    It then adaptively decides to cooperate or defect based on the stock level trends,
    defecting in the last two rounds to maximize immediate gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_stock = state.current_stock
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 1:
            self.last_stock = state.current_stock
            return Action.D
        current_stock = state.current_stock
        previous_stock = self.last_stock
        if current_stock < previous_stock:
            trend = 'decreasing'
        elif current_stock > previous_stock:
            trend = 'increasing'
        else:
            trend = 'stable'
        capacity = self.game_description.capacity
        threshold_low = 0.25 * capacity
        threshold_high = 0.75 * capacity
        if current_stock <= threshold_low:
            action = Action.C
        elif current_stock >= threshold_high:
            action = Action.D
        elif trend == 'decreasing':
            action = Action.C
        else:
            action = Action.D
        self.last_stock = current_stock
        return action

class Strategy_EXPLOITATIVE_52(BaseStrategy):
    """
    Adaptive Exploitation in Common Pool Resource Game.

    This strategy balances cooperation to maintain stock health with strategic defection.
    Cooperates initially, defects in the last round, and adapts based on stock levels and others' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            very_low_threshold = self.game_description.capacity * 0.05
            if state.current_stock <= 0 or state.current_stock < very_low_threshold:
                return Action.D
            if state.current_stock < self.game_description.capacity / 2:
                return Action.D
            previous_actions = history.opponent_actions[-1]
            n_defectors = np.count_nonzero(~previous_actions)
            if n_defectors > self.game_description.n_players / 2:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_53(BaseStrategy):
    """
    A dynamic strategy that balances cooperation with strategic defection based on observed stock levels.
    It cooperates initially unless the stock is critically low or shows a decreasing trend, switching to defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if self.game_description.n_rounds == 1:
                return Action.D
            else:
                return Action.C
        else:
            self.stock_history.append(state.current_stock)
            capacity = self.game_description.capacity
            if state.round_number == self.game_description.n_rounds - 1:
                return Action.D
            if state.current_stock < 0.5 * capacity:
                return Action.D
            if len(self.stock_history) >= 2:
                prev_stock = self.stock_history[-2]
                current_stock = self.stock_history[-1]
                if current_stock < prev_stock:
                    return Action.D
            return Action.C

class Strategy_EXPLOITATIVE_54(BaseStrategy):
    """
    An adaptive strategy that balances cooperation and defection based on the current stock level and past actions.
    Cooperates initially, defects in the last round, and adaptively defects if at least half of the players defected previously.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.s_prev = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.s_prev = state.current_stock
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.2 * self.capacity:
            self.s_prev = state.current_stock
            return Action.C
        t_prev = state.round_number - 1
        s_prev_prev_round = self.s_prev
        my_action_prev = history.my_actions[t_prev]
        opponent_actions_prev = history.opponent_actions[t_prev, :]
        n_players = self.game_description.n_players
        x_prev = 0.0
        if my_action_prev:
            my_consume = s_prev_prev_round / (2 * n_players)
        else:
            my_consume = s_prev_prev_round / n_players
        x_prev += my_consume
        for opponent_action in opponent_actions_prev:
            if opponent_action:
                consume = s_prev_prev_round / (2 * n_players)
            else:
                consume = s_prev_prev_round / n_players
            x_prev += consume
        if s_prev_prev_round == 0:
            d = 0
        else:
            d = 2 * n_players * x_prev / s_prev_prev_round - n_players
        if d >= self.n_players / 2:
            action = Action.D
        else:
            action = Action.C
        self.s_prev = state.current_stock
        return action

class Strategy_EXPLOITATIVE_55(BaseStrategy):
    """
    Exploitative Strategy for Common Pool Resource Game.

    This strategy starts by cooperating in the first round to encourage cooperation. 
    It then adapts based on the stock level and the average cooperation rate of all players. 
    It defects if the stock falls below 50% of capacity or if more than 50% of players have defected on average. 
    In the last two rounds, it defects to maximize immediate gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number >= n_rounds - 2:
            return Action.D
        if state.current_stock < 0.5 * capacity:
            return Action.D
        t = state.round_number
        total_coop = 0
        for round in range(t):
            if history.my_actions[round]:
                total_coop += 1
            total_coop += sum(history.opponent_actions[round])
        total_possible = t * n_players
        if total_possible == 0:
            avg_coop = 0.0
        else:
            avg_coop = total_coop / total_possible
        if 1.0 - avg_coop > 0.5:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_56(BaseStrategy):
    """
    Smoothed Adaptive Exploitation (SAX) Strategy for the Common Pool Resource Game.

    This strategy balances immediate gains with long-term sustainability by adapting based on observed behavior and current stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.T = 0.5 * self.capacity
        self.D = 0.5
        self.k = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        n_players = self.game_description.n_players
        n_past_rounds = min(self.k, state.round_number)
        my_actions = history.my_actions[-n_past_rounds:]
        opponent_actions = history.opponent_actions[-n_past_rounds:]
        my_defect_count = (my_actions == False).sum()
        opponent_defect_count = (opponent_actions == False).sum()
        total_defectors = my_defect_count + opponent_defect_count
        defection_rate = total_defectors / (n_players * n_past_rounds)
        if state.current_stock < self.T:
            return Action.C
        elif defection_rate > self.D:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_57(BaseStrategy):
    """
    A dynamic strategy that balances immediate gains with long-term sustainability in a Common Pool Resource Game.
    Cooperates initially, defects in the last round, and adapts based on stock levels and collective behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            S = state.current_stock
            capacity = self.game_description.capacity
            my_last_action = history.my_actions[-1]
            opponent_actions = history.opponent_actions[-1, :]
            C_count = sum(opponent_actions) + (1 if my_last_action else 0)
            D_count = self.game_description.n_players - C_count
            if S / capacity > 0.75 and C_count > D_count:
                return Action.D
            elif S / capacity < 0.5:
                return Action.C
            else:
                return Action.C if C_count >= D_count else Action.D

class Strategy_EXPLOITATIVE_58(BaseStrategy):
    """
    An adaptive strategy that balances cooperation and defection based on stock levels and trends.
    Cooperates initially, defects when stock falls below a threshold, and adapts based on stock trends.
    Defects more frequently in later rounds and always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        self.stock_history.append(state.current_stock)
        current_stock = state.current_stock
        if state.round_number == self.r - 1:
            return Action.D
        if state.round_number > 0.8 * self.r:
            return Action.D
        stock_ratio = current_stock / self.capacity
        if stock_ratio > 0.7:
            return Action.C
        recent_stocks = self.stock_history[-3:]
        if len(recent_stocks) < 2:
            if state.round_number > 0.5 * self.r:
                return Action.D
            else:
                return Action.C if stock_ratio > 0.7 else Action.D
        else:
            changes = []
            for i in range(1, len(recent_stocks)):
                changes.append(recent_stocks[i] - recent_stocks[i - 1])
            if not changes:
                avg_change = 0
            else:
                avg_change = sum(changes) / len(changes)
            if avg_change < 0:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_59(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Common Pool Resource Game.
    The strategy starts by defecting to test opponents, then adapts based on cooperation rates and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        t = state.round_number
        if t == 0:
            return Action.D
        if t == self.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * self.capacity:
            return Action.C
        my_last_action = history.my_actions[t - 1]
        opponent_last_actions = history.opponent_actions[t - 1, :]
        num_coop = my_last_action + np.sum(opponent_last_actions)
        avg_coop_rate = num_coop / self.n_players
        if avg_coop_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_61(BaseStrategy):
    """
    Exploitative strategy for the Common Pool Resource Game that balances cooperation and exploitation.
    Cooperates initially, punishes defection for up to two rounds, and defects in the final rounds.
    Tends to cooperate if others do, defects otherwise, while ensuring stock sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number >= r - 2:
            return Action.D
        stock_threshold = 0.25 * capacity
        if state.current_stock < stock_threshold:
            return Action.C
        n_players = self.game_description.n_players
        last_actions = history.opponent_actions[-1]
        n_coop = sum(last_actions)
        coop_rate = n_coop / n_players
        if coop_rate >= 0.5:
            return Action.C
        elif self.punish_counter < 2:
            self.punish_counter += 1
            return Action.D
        else:
            self.punish_counter = 0
            if n_coop / n_players >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_62(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Common Pool Resource Game.
    Cooperates initially, then adapts based on stock level and previous defection rates.
    Defects in the last round to maximize immediate gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            cooperation_threshold = 0.25 * self.capacity
            current_stock = state.current_stock
            if current_stock < cooperation_threshold:
                return Action.C
            else:
                my_last_action = history.my_actions[-1]
                opponent_last_actions = history.opponent_actions[-1]
                D_count = 0
                if not my_last_action:
                    D_count += 1
                for action in opponent_last_actions:
                    if not action:
                        D_count += 1
                D_percent = D_count / self.n_players
                if D_percent > 0.5:
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_63(BaseStrategy):
    """
    Adaptive Exploitation with Dynamic Threshold (AEDT) strategy for the Common Pool Resource game.
    This strategy balances immediate gains and long-term sustainability by dynamically adjusting a threshold
    based on recent stock trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = [game_description.capacity]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        self.stock_history.append(current_stock)
        if current_stock <= 0:
            return Action.D
        if current_round == self.game_description.n_rounds - 1:
            return Action.D
        recent_stocks = self.stock_history[-3:]
        trend = 0
        for i in range(1, len(recent_stocks)):
            if recent_stocks[i] > recent_stocks[i - 1]:
                trend += 1
            elif recent_stocks[i] < recent_stocks[i - 1]:
                trend -= 1
        T = self.game_description.capacity / 2
        if trend > 0:
            T *= 1.05
        elif trend < 0:
            T *= 0.95
        T = max(0, min(T, self.game_description.capacity))
        if current_stock > T:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_64(BaseStrategy):
    """
    An adaptive strategy that balances cooperation and defection based on stock levels 
    and opponents' past actions to maximize long-term payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        game_desc = self.game_description
        if current_round == 0:
            return Action.C
        if current_round == game_desc.n_rounds - 1:
            return Action.D
        previous_round = current_round - 1
        my_prev_action = history.my_actions[previous_round]
        my_defected = 0 if my_prev_action else 1
        opponent_prev_actions = history.opponent_actions[previous_round]
        op_defected = np.sum(~opponent_prev_actions)
        total_defectors = my_defected + op_defected
        avg_defection = total_defectors / game_desc.n_players
        current_stock = state.current_stock
        capacity = game_desc.capacity
        if current_stock < 0.25 * capacity:
            return Action.C
        elif current_stock > 0.75 * capacity:
            return Action.D
        elif avg_defection > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_65(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that aims to maximize individual payoff through cooperation and selective defection.
    
    The strategy starts with cooperation to maintain stock levels, defects in the final round for maximum gain, and uses adaptive checks 
    on stock levels, opponents' past actions, and personal performance to decide actions in intermediate rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            capacity = self.game_description.capacity
            if state.current_stock < 0.2 * capacity:
                return Action.C
            prev_round = state.round_number - 1
            prev_opponents = history.opponent_actions[prev_round]
            cooperators_prev = np.sum(prev_opponents)
            defectors_prev = self.game_description.n_players - cooperators_prev
            if defectors_prev > self.game_description.n_players / 2:
                return Action.D
            my_payoffs = history.my_payoffs
            avg = np.mean(my_payoffs)
            max_avg = capacity / (2 * self.game_description.n_players)
            if avg < 0.8 * max_avg:
                return Action.D
            return Action.C

class Strategy_EXPLOITATIVE_66(BaseStrategy):
    """
    Exploitative Strategy for Common Pool Resource Game.
    This strategy adapts based on opponents' past actions and the current state of the stock,
    balancing immediate gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.previous_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        capacity = self.capacity
        n_players = self.n_players
        n_rounds = self.n_rounds
        if state.round_number == 0:
            action = Action.C
        elif state.round_number == n_rounds - 1:
            action = Action.D
        elif current_stock < 0.2 * capacity:
            action = Action.C
        else:
            my_last_action = history.my_actions[-1]
            my_defect = 0 if my_last_action else 1
            opponent_actions_last_round = history.opponent_actions[-1]
            opponent_defectors = len(opponent_actions_last_round) - sum(opponent_actions_last_round)
            total_defectors_last_round = my_defect + opponent_defectors
            half_n_players = n_players / 2
            defect_conditions = (total_defectors_last_round > half_n_players, current_stock > 0.5 * capacity)
            if any(defect_conditions):
                action = Action.D
            else:
                action = Action.C
        self.previous_stock = current_stock
        return action

class Strategy_EXPLOITATIVE_67(BaseStrategy):
    """
    Exploitative strategy for Common Pool Resource Game.
    Cooperates in the first round, defects in the last.
    For intermediate rounds, cooperate if stock is below 50% of capacity,
    otherwise adapt based on the majority of previous defections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.5 * self.capacity:
            return Action.C
        else:
            total_defections = 0.0
            for t in range(state.round_number):
                my_defect = 0 if history.my_actions[t] else 1
                opponent_defs = np.sum(history.opponent_actions[t] == False)
                total_defections += my_defect + opponent_defs
            average_defects = total_defections / state.round_number
            threshold = self.n_players / 2
            if average_defects > threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_68(BaseStrategy):
    """
    A strategy for the Common Pool Resource game that balances cooperation and defection based on observed behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        capacity = self.capacity
        n_rounds = self.n_rounds
        if t == 0:
            return Action.C
        if t == n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < 0.5 * capacity:
            return Action.D
        k = min(3, t)
        recent_actions = []
        for r in range(max(0, t - k), t):
            my_act = history.my_actions[r]
            recent_actions.append(my_act)
            opponent_acts = history.opponent_actions[r].tolist()
            recent_actions.extend(opponent_acts)
        recent_defections = 0
        for action in recent_actions:
            if not action:
                recent_defections += 1
        total_actions = len(recent_actions)
        avg_defect = recent_defections / total_actions if total_actions else 0.0
        if avg_defect > 0.5:
            return Action.D
        if current_stock > 0.75 * capacity:
            return Action.C
        if current_stock > 0.5 * capacity:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_69(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection based on historical actions and stock levels.
    Cooperates initially, defects in the last round, and defects if others defected or stock is low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            my_defect = 0 if my_prev_action else 1
            opponent_prev_actions = history.opponent_actions[prev_round, :]
            opponent_defectors = sum((1 for action in opponent_prev_actions if not action))
            total_defectors = my_defect + opponent_defectors
            threshold_players = self.n_players / 2
            if total_defectors >= threshold_players or state.current_stock < self.capacity / 2:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_70(BaseStrategy):
    """
    Implements an exploitative strategy for the Common Pool Resource Game.
    The strategy initially alternates between Cooperate and Defect, then adapts based on average consumption,
    and defects in the late game or when stock is low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number >= self.n_rounds - 3:
            return Action.D
        if state.current_stock < 0.2 * self.capacity:
            return Action.D
        if state.round_number == 0:
            return Action.C
        elif state.round_number == 1:
            return Action.D
        threshold = 0.75 * (self.capacity / self.n_players)
        total_per_round = []
        if history is not None:
            for t in range(len(history.my_payoffs)):
                my_payoff = history.my_payoffs[t]
                opponent_payoffs = history.opponent_payoffs[t]
                total_consumption = my_payoff + np.sum(opponent_payoffs)
                per_player_avg = total_consumption / self.n_players
                total_per_round.append(per_player_avg)
            if total_per_round:
                avg_consumption = np.mean(total_per_round)
                if avg_consumption > threshold:
                    return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_71(BaseStrategy):
    """
    A strategy that Cooperates when the stock is below 70% of capacity and Defects otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            threshold = 0.7 * self.game_description.capacity
        else:
            threshold = 0.7 * self.game_description.capacity
        if state.current_stock < threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_72(BaseStrategy):
    """
    This strategy starts by cooperating in the first round to observe others' behavior. 
    In subsequent rounds, it adapts based on the current stock level and the number of previous defectors.
    It cooperates if the stock is healthy and fewer than half defected last round, otherwise it defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        my_last_action = history.my_actions[last_round]
        my_defection = 0 if my_last_action else 1
        opponent_actions = history.opponent_actions[last_round, :]
        opponent_defections = np.sum(~opponent_actions)
        total_defectors = my_defection + opponent_defections
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        half_capacity = capacity / 2
        if current_stock > half_capacity:
            if total_defectors > n_players / 2:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_73(BaseStrategy):
    """
    Strategy that adapts based on stock levels. Cooperates initially, 
    defects if stock is low, and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            previous_stock = state.current_stock
            quarter_capacity = 0.25 * self.capacity
            three_quarters_capacity = 0.75 * self.capacity
            if previous_stock < quarter_capacity:
                return Action.D
            elif previous_stock > three_quarters_capacity:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_74(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game. Cooperates initially, 
    then adapts based on stock changes, defecting in the last round to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.prev_stock = state.current_stock
            return Action.C
        else:
            is_last_round = state.round_number == self.game_description.n_rounds - 1
            if is_last_round:
                return Action.D
            else:
                if state.current_stock >= self.prev_stock:
                    action = Action.C
                else:
                    action = Action.D
                self.prev_stock = state.current_stock
                return action

class Strategy_EXPLOITATIVE_75(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        sum_C = np.sum(history.opponent_actions[:state.round_number, :])
        n_opponents = self.game_description.n_players - 1
        total_possible = state.round_number * n_opponents
        ACR = sum_C / total_possible
        threshold = 0.2 * self.game_description.capacity
        current_stock = state.current_stock
        if current_stock <= threshold:
            return Action.C
        elif ACR > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_76(BaseStrategy):
    """
    Implements a strategy for the Common Pool Resource Game that combines 
    cooperation and defection based on game state and opponent history.
    
    The strategy cooperates in the first round, defects in the last round, and 
    adapts in middle rounds by considering opponents' historical cooperation 
    rate and the current stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n = self.n_players
        r = self.n_rounds
        capacity = self.capacity
        stock = state.current_stock
        if current_round == 0:
            return Action.C
        elif current_round == r - 1:
            return Action.D
        else:
            if history is None:
                return Action.C
            sum_coop = 0
            for t in range(current_round):
                opp_actions = history.opponent_actions[t]
                sum_coop += np.sum(opp_actions)
            total_opponent_rounds = current_round * (n - 1)
            average_coop = sum_coop / total_opponent_rounds
            if average_coop > 0.5 and stock > capacity / 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_78(BaseStrategy):
    """
    Adaptive Exploitation with Forgiveness (AEF) strategy for the Common Pool Resource Game.
    Cooperates initially, punishes if defection exceeds a threshold, and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock = 0.25 * game_description.capacity
        self.lookback = 3
        self.punishing = False
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == 0 and history is None:
            return Action.C
        if state.current_stock < self.critical_stock:
            return Action.D
        if self.punishing:
            action = Action.D
            self.punishment_remaining -= 1
            if self.punishment_remaining == 0:
                self.punishing = False
            return action
        n_opponents = self.n_players - 1
        start_round = max(0, state.round_number - self.lookback)
        opponent_actions = history.opponent_actions[start_round:state.round_number, :]
        if len(opponent_actions) == 0:
            avg_defection = 0.0
        else:
            total_defectors = np.sum(opponent_actions == 0)
            k = len(opponent_actions)
            avg_defection = total_defectors / (k * n_opponents) if k > 0 else 0.0
        if avg_defection > 0.5:
            self.punishing = True
            self.punishment_remaining = 3
            return Action.D
        else:
            total_defectors = np.sum(opponent_actions == 0)
            if total_defectors == 0:
                return Action.C
            elif avg_defection > 0.5:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_79(BaseStrategy):
    """
    Adaptive Exploitation with Sustainability (AES) strategy for the Common Pool Resource Game.
    This strategy combines reciprocal behavior with stock-level adaptation to balance cooperation and exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if round_num == 0:
            return Action.C
        if round_num == n_rounds - 1:
            return Action.D
        conservation_threshold = 0.25 * capacity
        current_stock = state.current_stock
        if current_stock < conservation_threshold:
            return Action.C
        recent_k = 3
        n_rounds_played = round_num
        start_idx = max(0, n_rounds_played - recent_k)
        selected_actions = history.opponent_actions[start_idx:n_rounds_played]
        total_coop = selected_actions.sum()
        total_actions = selected_actions.size
        if total_actions == 0:
            cooperation_avg = 0.5
        else:
            cooperation_avg = total_coop / total_actions
        if cooperation_avg > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_80(BaseStrategy):
    """
    Adaptive Exploitation Strategy: Cooperate initially, defect in last round, 
    and adjust based on stock level and defection history of others.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == n_rounds - 1:
            return Action.D
        T = 0.5 * capacity
        current_stock = state.current_stock
        current_round = state.round_number
        my_defections = np.sum(~history.my_actions[:current_round])
        opponent_defections = np.sum(~history.opponent_actions[:current_round])
        total_defections = my_defections + opponent_defections
        total_actions = n_players * current_round
        D_avg = total_defections / total_actions
        if current_stock < T or D_avg > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_81(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that starts with cooperation
    and adapts based on the defection rate and stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_actions = history.opponent_actions[-1, :]
        num_defectors = self.n_players - np.sum(prev_actions)
        defect_rate = num_defectors / self.n_players
        stock_percent = state.current_stock / self.capacity
        if defect_rate > 0.3 or stock_percent < 0.6:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_82(BaseStrategy):
    """
    A strategy that cooperates in the first round and then defects if the current stock exceeds half the capacity.
    Otherwise, it cooperates to conserve the stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock > self.capacity / 2.0:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_83(BaseStrategy):
    """
    Adaptive Exploitation for Sustainable Resource Management strategy:
    Cooperates initially, defects when stock is high, conserves when stock is low,
    and defects in the last round. Handles near-zero stock by cooperating to allow recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        elif round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            near_zero_threshold = 0.05 * capacity
            if current_stock < near_zero_threshold:
                return Action.C
            threshold = 0.7 * capacity
            if current_stock > threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_84(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        else:
            threshold = 0.75 * self.capacity
            if state.current_stock > threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_85(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_actions = history.opponent_actions[prev_round]
        total_defectors = (0 if my_prev_action else 1) + sum((1 for action in opponent_actions if not action))
        threshold = self.game_description.n_players / 2
        if total_defectors > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_86(BaseStrategy):
    """
    This strategy cooperates in the first round. In subsequent rounds, it defects if 
    fewer than 25% of the players defected in the last round and the current stock is 
    above half the capacity; otherwise, it cooperates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            if history is None:
                return Action.C
            last_round_opp_actions = history.opponent_actions[-1, :]
            defectors = np.count_nonzero(~last_round_opp_actions)
            threshold = 0.25 * self.n_players
            stock_condition = state.current_stock > 0.5 * self.capacity
            if defectors < threshold and stock_condition:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_87(BaseStrategy):
    """
    A strategy that adapts between cooperation and defection based on stock levels and opponents' actions.
    Cooperates initially, defects if the stock drops below 50% of capacity, infers opponent behavior to decide actions,
    and defects in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.r - 1:
            return Action.D
        elif state.current_stock < 0.5 * self.capacity:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            others_prev_actions = history.opponent_actions[prev_round]
            my_defected = not my_prev_action
            any_opponent_defected = np.any(others_prev_actions == False)
            if my_defected or any_opponent_defected:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_88(BaseStrategy):
    """
    Adaptive Exploitation Based on Sustainability strategy.
    
    This strategy balances immediate gains with long-term sustainability by adapting based on others' actions and the state of the common pool.
    It cooperates initially, defects in the last round, and adjusts based on the sustainability of previous rounds' consumption.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_stock_before_round = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_stock_before_round = state.current_stock
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            s_prev = self.last_stock_before_round
            prev_round = state.round_number - 1
            my_action = history.my_actions[prev_round]
            opponent_actions = history.opponent_actions[prev_round, :]
            all_actions = [my_action]
            for action in opponent_actions:
                all_actions.append(action)
            total_consumption = 0.0
            for action in all_actions:
                if action:
                    total_consumption += s_prev / (2 * self.game_description.n_players)
                else:
                    total_consumption += s_prev / self.game_description.n_players
            threshold = s_prev / 2.0
            if total_consumption > threshold:
                action = Action.D
            else:
                action = Action.C
        self.last_stock_before_round = state.current_stock
        return action

class Strategy_EXPLOITATIVE_89(BaseStrategy):
    """
    The Adaptive Exploitation Strategy: Cooperates initially, defects if stock is low or trend decreases, and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.previous_stocks = []

    def _check_trend(self):
        if len(self.previous_stocks) < 2:
            return False
        prev = self.previous_stocks[-2]
        curr = self.previous_stocks[-1]
        change = curr - prev
        return change < 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        t = state.round_number
        self.previous_stocks.append(current_stock)
        if t == 0:
            action = Action.C
        elif t == self.game_description.n_rounds - 1:
            action = Action.D
        elif current_stock < 0.5 * self.capacity:
            action = Action.D
        elif self._check_trend():
            action = Action.D
        else:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_90(BaseStrategy):
    """
    Adaptive Exploitation with Stock Conservation Strategy.

    This strategy balances cooperation with exploitation, adapting to both the current state of the stock and the historical actions of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        is_last_round = state.round_number == self.game_description.n_rounds - 1
        prev_actions = history.opponent_actions[-1]
        D_count = (prev_actions == False).sum()
        stock_threshold = self.game_description.capacity / 2
        if state.current_stock < stock_threshold:
            return Action.C
        elif D_count > self.game_description.n_players / 2 or is_last_round:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_91(BaseStrategy):
    """
    A strategy that adapts to other players' behavior while balancing sustainability and exploitation.
    Cooperates initially, then dynamically adjusts based on opponent actions, stock levels, and game progress.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if history is None or len(history.my_actions) == 0:
            return Action.C
        sum_a = 0.0
        n_rounds = len(history.my_actions)
        for t in range(n_rounds):
            my_action = history.my_actions[t]
            a_me = 0.5 if my_action else 1.0
            op_actions = history.opponent_actions[t]
            a_others = np.where(op_actions, 0.5, 1.0)
            sum_a += a_me + a_others.sum()
        avg_consumption = sum_a / (n_rounds * n)
        if avg_consumption > 0.75:
            return Action.D
        critical_stock = 0.2 * capacity
        if current_stock < critical_stock:
            return Action.D
        last_round = n_rounds - 1
        my_last = history.my_actions[last_round]
        op_last = history.opponent_actions[last_round]
        my_defect = 0 if my_last else 1
        op_defects = np.count_nonzero(~op_last)
        total_defectors = my_defect + op_defects
        if total_defectors > n / 2:
            return Action.D
        endgame_threshold = 0.8 * total_rounds
        if current_round >= endgame_threshold:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_92(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection based on historical cooperation rates and current stock levels.
    The strategy cooperates if the average cooperation rate (ACR) exceeds 70% and the stock is above 50% of capacity, otherwise it defects.
    It always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with the game description.
        :param game_description: Contains the number of players, rounds, and capacity.
        """
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (C or D) based on the current state and history.
        :param state: Current state of the game including the round number and stock level.
        :param history: Historical actions and payoffs of all players.
        :return: The chosen action as an Action enum.
        """
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        threshold = 0.5 * capacity
        if history is None:
            acr = 0.0
        else:
            total_c = 0
            for round_num in range(state.round_number):
                my_action = history.my_actions[round_num]
                total_c += 1 if my_action else 0
                others = history.opponent_actions[round_num]
                total_c += sum(others)
            total_possible = state.round_number * self.game_description.n_players
            acr = total_c / total_possible if total_possible > 0 else 0.0
        cooperate = acr > 0.7 and state.current_stock > threshold
        return Action.C if cooperate else Action.D

class Strategy_EXPLOITATIVE_93(BaseStrategy):
    """
    Dynamic cooperation strategy based on stock level and opponent behavior.
    Cooperates initially, defects if stock is low, or if majority defected.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < 3:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity_threshold = 0.3 * self.game_description.capacity
        if current_stock < capacity_threshold:
            return Action.D
        else:
            my_last_action = history.my_actions[state.round_number - 1]
            others_last_actions = history.opponent_actions[state.round_number - 1]
            defectors_count = 0
            if not my_last_action:
                defectors_count += 1
            others_defectors = len(others_last_actions) - others_last_actions.sum()
            defectors_count += others_defectors
            n_players = self.game_description.n_players
            proportion_defectors = defectors_count / n_players
            if proportion_defectors > 0.5:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_95(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game. Cooperates initially, 
    then dynamically adjusts based on stock levels and opponents' actions, 
    defecting in endgame rounds to maximize immediate gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        if n_rounds - state.round_number <= 3:
            return Action.D
        prev_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round]
        sum_others_D = sum((not action for action in opponent_actions_prev))
        my_prev_action = history.my_actions[prev_round]
        my_D = 1 if not my_prev_action else 0
        total_D = sum_others_D + my_D
        n_players = self.game_description.n_players
        if total_D > n_players / 2:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock < 0.5 * capacity:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_96(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and defection based on stock level and opponents' previous actions.
    Cooperates initially, defects when stock is low, considers opponents' previous actions, and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history):
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock <= 0.25 * self.capacity:
            return Action.D
        prev_actions = history.opponent_actions[-1]
        defectors = np.sum(prev_actions == 0)
        n_opponents = self.n_players - 1
        majority_defectors = (n_opponents + 1) // 2
        if defectors >= majority_defectors:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_97(BaseStrategy):
    """
    A strategy that decides to Cooperate or Defect in a Common Pool Resource Game based on a stock threshold that decreases as the game progresses. Defects in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        t = state.round_number + 1
        threshold = self.capacity * (self.n_rounds - t + 1) / (2 * self.n_rounds)
        if state.current_stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_98(BaseStrategy):
    """
    Hybrid strategy combining cooperation and defection based on historical cooperation and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            total_coop = 0
            t = state.round_number
            n = self.game_description.n_players
            for r in range(t):
                my_coop = history.my_actions[r]
                opponent_coop = sum(history.opponent_actions[r])
                total_coop += (1 if my_coop else 0) + opponent_coop
            acr = total_coop / (t * n)
            s_safe = self.game_description.capacity / 2
            if acr > 0.5 and state.current_stock > s_safe:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_99(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.previous_stock = game_description.capacity
        self.stock_depletion_threshold = 0.1 * self.capacity
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            self.previous_stock = state.current_stock
            return Action.C
        elif state.round_number == self.r - 1:
            self.previous_stock = state.current_stock
            return Action.D
        else:
            if self.punishment_remaining > 0:
                action = Action.D
                self.punishment_remaining -= 1
            else:
                stock_change = state.current_stock - self.previous_stock
                if stock_change < -self.stock_depletion_threshold:
                    action = Action.D
                    self.punishment_remaining = 1
                else:
                    action = Action.C
            self.previous_stock = state.current_stock
            return action

class Strategy_EXPLOITATIVE_100(BaseStrategy):
    """
    Adaptive Exploitation Strategy for the Common Pool Resource Game.
    Cooperates initially, defects in the last round, conserves stock when low,
    and adapts based on opponents' previous actions and average payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        twenty_percent_capacity = 0.2 * capacity
        if current_stock <= twenty_percent_capacity:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        my_defection = 0 if my_prev_action else 1
        opponent_defections = sum((1 for action in opponent_prev_actions if not action))
        total_defections = my_defection + opponent_defections
        if total_defections / n_players > 0.5:
            return Action.D
        my_prev_payoff = history.my_payoffs[prev_round]
        opponent_prev_payoffs = history.opponent_payoffs[prev_round]
        total_payoff = my_prev_payoff + np.sum(opponent_prev_payoffs)
        avg_payoff = total_payoff / n_players
        threshold = 0.8 * (capacity / (2 * n_players))
        if avg_payoff >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_101(BaseStrategy):
    """
    Adaptive Exploitation Based on Stock Levels strategy for the Common Pool Resource Game.
    Cooperates initially, defects in the last round, and adapts based on the average stock level relative to 75% of capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if current_round == 0:
            return Action.C
        if current_round == total_rounds - 1:
            return Action.D
        previous_rounds_count = current_round
        sum_stock = sum(self.stock_history[:previous_rounds_count])
        average_stock = sum_stock / previous_rounds_count
        threshold = 0.75 * capacity
        if average_stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_102(BaseStrategy):
    """
    Exploitative strategy for the Common Pool Resource Game. 
    This strategy starts by cooperating, then adapts based on opponents' actions, 
    stock levels, and remaining rounds to maximize individual payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        low_threshold = 0.2 * self.capacity
        high_threshold = 0.8 * self.capacity
        if state.current_stock < low_threshold:
            return Action.C
        if history is None:
            return Action.C
        previous_rounds = history.opponent_actions.shape[0]
        n_opponents = self.n_players - 1
        high_defect_count = 0
        for r in range(previous_rounds):
            defectors = 0
            for action in history.opponent_actions[r, :]:
                if not action:
                    defectors += 1
            proportion = defectors / n_opponents
            if proportion > 0.5:
                high_defect_count += 1
        if previous_rounds > 0:
            high_defect_proportion = high_defect_count / previous_rounds
            if high_defect_proportion > 0.5:
                return Action.D
        if state.current_stock > high_threshold and self.n_rounds - state.round_number > 2:
            return Action.C
        remaining_rounds = self.n_rounds - state.round_number
        if remaining_rounds < 3:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_103(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances 
    sustaining the resource and maximizing immediate payoffs by monitoring 
    stock levels and switching actions based on significant changes.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_stock = game_description.capacity
        self.last_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
            self.last_action = action
            self.last_stock = state.current_stock
            return action
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        else:
            threshold = 0.25 * self.game_description.capacity
            if state.current_stock < threshold:
                action = Action.C
            else:
                significant_decrease = state.current_stock < 0.9 * self.last_stock
                if self.last_action == Action.C and significant_decrease:
                    action = Action.D
                elif self.last_action == Action.D and state.current_stock > threshold:
                    action = Action.D
                else:
                    action = Action.C
        self.last_action = action
        self.last_stock = state.current_stock
        return action

class Strategy_EXPLOITATIVE_104(BaseStrategy):
    """
    Implements the Adaptive Exploitation Strategy for the Common Pool Resource Game.
    Cooperates initially, defects in last round, tracks cooperation rate to decide actions,
    and ensures sustainable consumption.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        recent_rounds = min(3, state.round_number)
        start_round = max(0, state.round_number - 3)
        total_coop = 0.0
        for t in range(start_round, state.round_number):
            my_action = history.my_actions[t]
            opponents = history.opponent_actions[t, :]
            coop_count = 1 if my_action else 0
            coop_count += sum(opponents)
            total_coop += coop_count / self.n_players
        avg_coop = total_coop / recent_rounds if recent_rounds > 0 else 0.0
        if avg_coop >= 0.5:
            return Action.C
        S = state.current_stock
        if S <= 0:
            return Action.D
        my_d_consumption = S / self.n_players
        others_c_consumption = (self.n_players - 1) * (S / (2 * self.n_players))
        potential_total = my_d_consumption + others_c_consumption
        if potential_total <= S / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_105(BaseStrategy):
    """
    Adaptive Exploitative Strategy for Common Pool Resource Game.

    Cooperates in the first round, defects in the last round, and in middle
    rounds cooperates if the stock is below half capacity or if opponents'
    average cooperation is above 50%. Otherwise, defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        threshold = capacity / 2
        if current_stock < threshold:
            return Action.C
        else:
            opponent_actions = history.opponent_actions
            prior_rounds = state.round_number
            opponent_actions_prior = opponent_actions[:prior_rounds, :]
            total_coop = np.sum(opponent_actions_prior)
            total_actions = prior_rounds * (self.game_description.n_players - 1)
            average_coop = total_coop / total_actions
            if average_coop > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_106(BaseStrategy):
    """
    Adaptive Exploitation with Conservation Strategy.
    Cooperates initially, then adapts based on stock levels and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.stock_threshold = 0.25 * self.capacity
        self.prev_stock = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.prev_stock = state.current_stock
            return Action.C
        else:
            current_stock = state.current_stock
            stock_change = current_stock - self.prev_stock
            self.prev_stock = current_stock
            if current_stock < self.stock_threshold:
                return Action.D
            else:
                prev_round = state.round_number - 1
                opponent_actions_prev = history.opponent_actions[prev_round]
                cooperation_rate = np.mean(opponent_actions_prev)
                if stock_change < 0 and cooperation_rate < 0.5:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_107(BaseStrategy):
    """
    Adaptive Exploitation strategy for Common Pool Resource game.
    Cooperates initially, then adapts based on previous actions, stock level,
    and game progression. Defects more frequently as the game concludes.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        round_num = state.round_number
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if round_num == n_rounds - 1:
            return Action.D
        elif round_num >= n_rounds - 3 and round_num < n_rounds - 1:
            if random.random() < 0.7:
                return Action.D
            else:
                return Action.C
        elif current_stock < 0.2 * capacity:
            return Action.D
        elif current_stock > 0.8 * capacity:
            return Action.C
        else:
            prev_my_action = history.my_actions[-1]
            prev_opp_actions = history.opponent_actions[-1]
            my_defect = 0 if prev_my_action else 1
            opp_defectors = sum(~prev_opp_actions)
            total_defectors = my_defect + opp_defectors
            threshold = n_players / 2
            if total_defectors > threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_108(BaseStrategy):
    """
    Adaptive Exploitation with Stock Threshold (AES) strategy for the Common Pool Resource Game.
    Cooperates initially, defects if stock is critically low, follows majority defection otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < 0.2 * self.capacity:
            return Action.D
        prev_round = state.round_number - 1
        opponent_actions_last = history.opponent_actions[prev_round, :]
        num_opponent_defectors = len(opponent_actions_last) - np.sum(opponent_actions_last)
        my_prev_action = history.my_actions[prev_round]
        my_defected = not my_prev_action
        total_defectors = num_opponent_defectors + (1 if my_defected else 0)
        if total_defectors > self.n_players / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_109(BaseStrategy):
    """
    A strategy for the Common Pool Resource game that adapts based on recent cooperation rates and stock levels.
    Cooperates in the first round, defects in the last round, and decides based on thresholds in between.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        if state.round_number == 0:
            return Action.C
        elif state.round_number == n_rounds - 1:
            return Action.D
        else:
            last_round = state.round_number - 1
            my_last_action = history.my_actions[last_round]
            opponents_last_actions = history.opponent_actions[last_round, :]
            opponent_coop = np.sum(opponents_last_actions)
            total_coop = my_last_action + opponent_coop
            RCR = total_coop / self.game_description.n_players
            SR = state.current_stock / self.game_description.capacity
            if RCR > 0.5 and SR > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_110(BaseStrategy):
    """
    Exploitative Strategy for the Common Pool Resource Game.

    This strategy adapts based on opponents' recent actions and the stock level.
    It initially cooperates to encourage others, then defects if exploitation is detected or stock is low.
    In the last round, it always defects to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            opponent_actions = history.opponent_actions[prev_round, :]
            opponent_defectors = len(opponent_actions) - sum(opponent_actions)
            own_defected = 0 if history.my_actions[prev_round] else 1
            num_defectors = opponent_defectors + own_defected
            if num_defectors > self.game_description.n_players / 2 or state.current_stock < 0.5 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_111(BaseStrategy):
    """
    Adaptive Exploitation Strategy (AES) for the Common Pool Resource Game.
    Cooperates initially, defects if more than half defected previously or stock is below 30% of capacity, and always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            previous_round = state.round_number - 1
            my_prev_action = history.my_actions[previous_round]
            my_defection = 0 if my_prev_action else 1
            opponent_actions = history.opponent_actions[previous_round, :]
            opponent_defections = np.sum(~opponent_actions)
            total_defectors = my_defection + opponent_defections
            if total_defectors > self.game_description.n_players / 2 or state.current_stock < 0.3 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_112(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection
    based on game state, opponent actions, and dynamic factors.
    Inherits from BaseStrategy and uses the given game description to make decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        endgame_threshold = 0.8 * n_rounds
        in_endgame = state.round_number >= endgame_threshold
        stock_low = state.current_stock < 0.5 * self.game_description.capacity
        if history is not None and history.opponent_actions.size > 0:
            sum_coop_last_round = sum(history.opponent_actions[-1])
        else:
            sum_coop_last_round = 0
        maj = self.game_description.n_players // 2
        recent_coop = sum_coop_last_round >= maj
        p_coop = 1.0
        if in_endgame:
            p_coop *= 0.5
        if stock_low:
            p_coop *= 0.5
        if not recent_coop:
            p_coop *= 0.5
        p_coop += random.random() * 0.2 - 0.1
        p_coop = max(0.0, min(1.0, p_coop))
        if random.random() < p_coop:
            action = Action.C
        else:
            action = Action.D
        if random.random() < 0.1:
            action = Action.D if action == Action.C else Action.C
        return action

class Strategy_EXPLOITATIVE_113(BaseStrategy):
    """
    An adaptive strategy that starts with cooperation and adjusts based on the cooperation rate and stock health.
    Cooperates if a high proportion of players cooperated previously and the stock is healthy; otherwise defects.
    Defects in the final round if the stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            final_stock_threshold = 0.2 * self.capacity
            if current_stock < final_stock_threshold:
                return Action.D
            else:
                return Action.C
        prev_round = current_round - 1
        my_last_action = history.my_actions[prev_round]
        opponent_actions_last_round = history.opponent_actions[prev_round]
        coop_count = 1 if my_last_action else 0
        coop_count += sum(opponent_actions_last_round)
        coop_rate = coop_count / self.n_players
        stock_health_threshold = 0.5 * self.capacity
        below_threshold = current_stock < stock_health_threshold
        if coop_rate >= 0.7 and (not below_threshold):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_114(BaseStrategy):
    """
    This strategy combines cooperation and defection based on observed game history and stock levels.
    It cooperates initially to conserve resources, defects in late game, and adapts behavior based on
    resource consumption patterns and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        t = state.round_number
        stock_history = [capacity]
        for t_prime in range(t):
            s_prev = stock_history[t_prime]
            my_action = history.my_actions[t_prime]
            opponents_actions = history.opponent_actions[t_prime, ...]
            total_cons = 0.0
            if my_action:
                total_cons += s_prev / (2 * n)
            else:
                total_cons += s_prev / n
            for i in range(opponents_actions.shape[0]):
                if opponents_actions[i]:
                    total_cons += s_prev / (2 * n)
                else:
                    total_cons += s_prev / n
            s_after = s_prev - total_cons
            s_after = max(s_after, 0.0)
            growth = 2 * s_after * (1 - s_after / capacity)
            new_stock = s_after + growth
            new_stock = min(new_stock, capacity)
            stock_history.append(new_stock)
        current_stock = state.current_stock
        if current_stock < 0.25 * capacity:
            return Action.C
        if t >= r - 3:
            return Action.D
        if current_stock < 0.5 * capacity:
            return Action.C
        if current_stock > 0.75 * capacity:
            return Action.D
        considered_rounds = range(max(0, t - 3), t)
        total_consumptions = []
        s_prev_list = []
        for t_prime in considered_rounds:
            s_prev = stock_history[t_prime]
            my_act = history.my_actions[t_prime]
            opp_acts = history.opponent_actions[t_prime, ...]
            total_cons = 0.0
            if my_act:
                total_cons += s_prev / (2 * n)
            else:
                total_cons += s_prev / n
            for i in range(opp_acts.shape[0]):
                if opp_acts[i]:
                    total_cons += s_prev / (2 * n)
                else:
                    total_cons += s_prev / n
            total_consumptions.append(total_cons)
            s_prev_list.append(s_prev)
        if not total_consumptions:
            return Action.C
        avg_cons = np.mean(total_consumptions)
        avg_target = np.mean([s / 2 for s in s_prev_list])
        if avg_cons <= avg_target:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_115(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Common Pool Resource Game.
    Cooperates initially, punishes defectors, and adapts based on stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_active = False
        self.punishment_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if self.punishment_active:
            self.punishment_rounds_remaining -= 1
            if self.punishment_rounds_remaining <= 0:
                self.punishment_active = False
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        is_low_stock = current_stock < 0.5 * capacity
        if state.round_number == 0:
            return Action.C
        last_round = state.round_number - 1
        opponent_actions_last = history.opponent_actions[last_round]
        n_opponents = len(opponent_actions_last)
        n_defectors = len(opponent_actions_last) - np.sum(opponent_actions_last)
        proportion_defectors = n_defectors / n_opponents
        if proportion_defectors > 0.5:
            self.punishment_active = True
            self.punishment_rounds_remaining = 3
            return Action.D
        elif is_low_stock:
            return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_116(BaseStrategy):
    """
    A strategy that balances cooperation and defection in the Common Pool Resource Game.
    Cooperates initially, then defects based on a dynamically decreasing threshold of stock level.
    Always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.r = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        current_stock = state.current_stock
        if t == 0:
            return Action.C
        elif t == self.r - 1:
            return Action.D
        else:
            threshold = self.capacity * (1 - t / self.r)
            if current_stock > threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_117(BaseStrategy):
    """
    A strategy that balances cooperation and defection in a Common Pool Resource Game.
    Cooperates in the first round, continues if stock is above 50% of capacity, 
    and defects in the last round or when stock is depleted beyond half capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.current_stock > 0.5 * self.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_118(BaseStrategy):
    """
    A strategy that cooperates initially, defects if the stock drops below capacity in middle rounds, and defects in the last two rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number + 1
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if current_round > r - 2:
            return Action.D
        previous_stock = state.current_stock
        if previous_stock < capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_119(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation 
    and defection based on observed cooperation rates and stock levels, with 
    special handling for the first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            sum_coop = 0
            n_prev_rounds = len(history.my_actions) if history is not None else 0
            for r in range(n_prev_rounds):
                my_action = history.my_actions[r]
                opponent_actions = history.opponent_actions[r]
                my_count = 1 if my_action else 0
                coop_count = my_count + sum(opponent_actions)
                sum_coop += coop_count
            if n_prev_rounds == 0:
                avg_coop_rate = 0.0
            else:
                avg_coop_rate = sum_coop / (self.game_description.n_players * n_prev_rounds)
            if state.current_stock < 0.2 * self.game_description.capacity:
                return Action.C
            elif avg_coop_rate > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_120(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Common Pool Resource Game.

    Cooperates in the first round. In intermediate rounds, defects if stock is below 75% of capacity. Always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            capacity = self.game_description.capacity
            threshold = 0.75 * capacity
            if state.current_stock < threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_121(BaseStrategy):
    """
    A strategy that starts with cooperation, responds to the number of defectors, 
    and defects in the final round to maximize payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_last_action = history.my_actions[prev_round]
            opponents_last_actions = history.opponent_actions[prev_round, :]
            I_defected = 0 if my_last_action else 1
            opponents_defected = (~opponents_last_actions).sum()
            total_defectors = I_defected + opponents_defected
            n_players = self.game_description.n_players
            if total_defectors > n_players - total_defectors:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_122(BaseStrategy):
    """
    An adaptive strategy that starts with cooperation and switches to defection based on stock levels and remaining rounds.
    Cooperates if the average stock is above 50% capacity and sufficient rounds remain; otherwise, defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.capacity = game_description.capacity
        self.cooperation_threshold = 0.5 * self.capacity
        self.total_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            current_stock = state.current_stock
            self.stock_history.append(current_stock)
            avg_stock = sum(self.stock_history) / len(self.stock_history)
            remaining_rounds = self.total_rounds - state.round_number - 1
            if avg_stock >= self.cooperation_threshold and remaining_rounds > 0.2 * self.total_rounds:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_123(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Level Threshold strategy.
    
    This strategy starts by cooperating, then cooperates as long as the stock remains above 75% of capacity, 
    and defects when the stock falls below this threshold. In the last round, it always defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.threshold = 0.75 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.current_stock < self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_124(BaseStrategy):
    """
    Adaptive Exploitation Strategy for the Common Pool Resource Game.
    This strategy balances immediate gain with long-term sustainability by
    adapting based on observed behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if state.round_number == self.game_description.n_rounds - 1:
            if current_stock > 0.75 * capacity:
                return Action.D
        if current_stock < 0.3 * capacity:
            return Action.C
        if current_stock < 0.5 * capacity:
            return Action.C
        total_avg_def = 0.0
        weighted_sum = 0.0
        total_weight = 0.0
        for t in range(state.round_number):
            my_action = history.my_actions[t]
            opp_actions = history.opponent_actions[t]
            my_defect = 0 if my_action else 1
            opp_defects = sum((1 for a in opp_actions if not a))
            total_def = my_defect + opp_defects
            round_avg = total_def / n
            total_avg_def += round_avg
            weight = 0.5 ** t
            weighted_sum += round_avg * weight
            total_weight += weight
        avg_defections = total_avg_def / state.round_number
        weighted_defections = weighted_sum / total_weight if total_weight != 0 else 0.0
        if avg_defections > 0.25 or weighted_defections > 0.3:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_125(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Common Pool Resource Game.

    This strategy starts with initial cooperation to observe others, then adapts based on 
    historical cooperation rates and stock levels. It switches to defecting if others are 
    defecting or if the stock is critically low, and defects in the endgame rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock = 0.3 * self.capacity
        self.initial_coop_rounds = 3
        self.endgame_rounds = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < self.initial_coop_rounds:
            return Action.C
        if state.round_number >= self.r - self.endgame_rounds:
            return Action.D
        if history is not None:
            opponent_actions = history.opponent_actions
            if opponent_actions.size == 0:
                cooperation_rate = 0.0
            else:
                cooperation_rate = np.sum(opponent_actions) / opponent_actions.size
            defect_threshold = 0.5
            if cooperation_rate < defect_threshold or state.current_stock < self.critical_stock:
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_126(BaseStrategy):
    """
    Exploitative Strategy for the Common Pool Resource Game.
    Cooperates initially, defects if others cooperate and stock is high, and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        game = self.game_description
        n_rounds = game.n_rounds
        capacity = game.capacity
        if state.round_number == 0:
            return Action.C
        elif state.round_number == n_rounds - 1:
            return Action.D
        else:
            last_actions = history.opponent_actions[-1, :]
            cooperators = last_actions.sum()
            n_players = game.n_players
            threshold = n_players / 2
            if cooperators > threshold:
                if state.current_stock >= 0.5 * capacity:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C

class Strategy_EXPLOITATIVE_127(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection
    based on opponents' previous actions and current stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        elif self.last_action == Action.D and state.current_stock < 0.5 * self.game_description.capacity:
            action = Action.C
        else:
            cooperators = sum(history.opponent_actions[-1, :])
            n_players = self.game_description.n_players
            capacity = self.game_description.capacity
            if cooperators > n_players / 2 and state.current_stock > 0.75 * capacity:
                action = Action.D
            else:
                action = Action.C
        self.last_action = action
        return action

class Strategy_EXPLOITATIVE_128(BaseStrategy):
    """
    A dynamic strategy for the Common Pool Resource Game that balances cooperation and defection,
    adapting based on stock levels, opponent actions, and past payoffs to maximize sustainability and payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            if state.current_stock > 0.5 * self.capacity:
                return Action.D
            else:
                return Action.C
        prev_opponent_actions = history.opponent_actions[-1]
        count_c = np.sum(prev_opponent_actions)
        count_d = prev_opponent_actions.size - count_c
        if count_c > count_d:
            proposed_action = Action.C
        else:
            proposed_action = Action.D
        if state.current_stock < 0.25 * self.capacity:
            return Action.C
        my_actions = history.my_actions
        coop_indices = np.where(my_actions == 1)[0]
        defect_indices = np.where(my_actions == 0)[0]
        coop_payoffs = history.my_payoffs[coop_indices] if coop_indices.size > 0 else np.array([], dtype=float)
        defect_payoffs = history.my_payoffs[defect_indices] if defect_indices.size > 0 else np.array([], dtype=float)
        coop_avg = np.mean(coop_payoffs) if coop_payoffs.size > 0 else 0.0
        defect_avg = np.mean(defect_payoffs) if defect_payoffs.size > 0 else 0.0
        if defect_avg > coop_avg and state.current_stock > 0.5 * self.capacity:
            return Action.D
        else:
            return proposed_action

class Strategy_EXPLOITATIVE_129(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game.
    Cooperates initially, then adapts based on stock levels.
    Defects in the last round to maximize immediate gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_levels = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_round == 0:
            self.stock_levels = [capacity]
            return Action.C
        if current_round == self.game_description.n_rounds - 1:
            return Action.D
        stock_levels = [capacity]
        for k in range(current_round):
            if k >= len(history.my_actions):
                break
            my_action = history.my_actions[k]
            opponent_actions = history.opponent_actions[k]
            current_S = stock_levels[k]
            total_consumption = 0.0
            if my_action == Action.C:
                my_consumption = current_S / (2 * n_players)
            else:
                my_consumption = current_S / n_players
            total_consumption += my_consumption
            for opponent_action in opponent_actions:
                if opponent_action == Action.C:
                    cons = current_S / (2 * n_players)
                else:
                    cons = current_S / n_players
                total_consumption += cons
            S_after = current_S - total_consumption
            growth = 2 * S_after * (1 - S_after / capacity)
            new_stock = S_after + growth
            if new_stock > capacity:
                new_stock = capacity
            stock_levels.append(new_stock)
        threshold_defect = 0.5 * capacity
        threshold_cooperate = 0.75 * capacity
        current_stock = stock_levels[-1]
        if current_stock < threshold_defect:
            return Action.D
        elif current_stock > threshold_cooperate:
            return Action.C
        elif len(stock_levels) >= 2:
            prev_stock = stock_levels[-2]
            if current_stock < prev_stock:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_130(BaseStrategy):
    """
    Exploitative Strategy for Common Pool Resource Game:
    Cooperates initially, then adapts based on stock level and others' past actions.
    Defects when stock is low or when opponents defected extensively.
    Always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.current_stock > 0.5 * self.capacity:
            previous_round = state.round_number - 1
            prev_opponent_actions = history.opponent_actions[previous_round]
            num_opponents = prev_opponent_actions.size
            n_defectors = np.sum(~prev_opponent_actions)
            if n_defectors < num_opponents / 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_131(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on the current resource state and previous player behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        half_capacity = self.game_description.capacity / 2
        if current_stock < half_capacity:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        defectors = 0
        if not my_prev_action:
            defectors += 1
        for action in opponent_prev_actions:
            if not action:
                defectors += 1
        if defectors >= self.game_description.n_players / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_132(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Common Pool Resource Game.
    Cooperates initially, then adapts based on stock levels and trends.
    Defects if stock levels drop below a threshold or show decline,
    and in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold = 0.5 * self.capacity
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            if state.round_number > 0:
                self.stock_history.append(state.current_stock)
            expected_S = self.capacity
            for prev_round in range(1, state.round_number + 1):
                consume = expected_S / 2
                s_remaining = expected_S - consume
                growth = 2 * s_remaining * (1 - s_remaining / self.capacity)
                new_expected_S = s_remaining + growth
                if new_expected_S > self.capacity:
                    new_expected_S = self.capacity
                expected_S = new_expected_S
            condition_2 = state.current_stock < self.cooperation_threshold
            condition_3 = state.current_stock < expected_S
            condition_4 = False
            if len(self.stock_history) >= 2:
                if self.stock_history[-1] < self.stock_history[-2]:
                    condition_4 = True
            if condition_2 or condition_3 or condition_4:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_133(BaseStrategy):
    """
    A strategy that adapts based on the previous round's actions and the current stock level.
    It defects if the stock is low, if many others defected, or in the last round.
    Cooperates in the first round to establish cooperation, then responds to stock levels and opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.C
        previous_stock = state.current_stock
        if previous_stock < 0.25 * self.capacity:
            return Action.D
        if previous_stock < 0.5 * self.capacity:
            return Action.D
        prev_round = state.round_number - 1
        my_action = history.my_actions[prev_round]
        my_defect = not my_action
        opp_actions = history.opponent_actions[prev_round]
        opp_defects = sum((1 for action in opp_actions if not action))
        total_defects = int(my_defect) + opp_defects
        proportion = total_defects / self.n_players
        if proportion > 0.5:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_134(BaseStrategy):
    """
    A reactive strategy that Cooperates initially, then Defects if the stock decreased 
    in the previous round, and always Defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_stock = state.current_stock
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            if self.previous_stock > current_stock:
                action = Action.D
            else:
                action = Action.C
            self.previous_stock = current_stock
            return action

class Strategy_EXPLOITATIVE_135(BaseStrategy):
    """
    An adaptive strategy balancing cooperation and defection based on stock levels and trends.
    Cooperates initially, defects in the last round, and uses thresholds to decide in between.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.prev_stock = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            action = Action.C
        elif current_round == self.n_rounds - 1:
            action = Action.D
        elif current_stock > 0.75 * self.capacity:
            action = Action.D
        elif current_stock < 0.5 * self.capacity:
            action = Action.C
        elif current_stock >= self.prev_stock:
            action = Action.D
        else:
            action = Action.C
        self.prev_stock = current_stock
        return action

class Strategy_EXPLOITATIVE_136(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation with strategic defection,
    adapting based on others' behavior and game progression to maximize total payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        remaining_rounds = self.game_description.n_rounds - state.round_number
        if remaining_rounds <= 2:
            return Action.D
        if state.current_stock < 0.3 * self.game_description.capacity:
            return Action.D
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opponent_prev = history.opponent_actions[prev_round, ...]
        cooperators_prev = my_prev + np.sum(opponent_prev)
        cooperation_ratio = cooperators_prev / self.game_description.n_players
        if cooperation_ratio >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_137(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on stock level trends.
    Cooperates to replenish stock when it's low and defects when stock is high,
    with an initial round cooperation and final round defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        threshold = 0.75 * self.capacity
        if state.current_stock < threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_138(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts based on stock levels and opponent behavior.
    Cooperates when the stock is above a dynamic threshold, otherwise defects. Includes special handling for the first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            n = self.game_description.n_players
            capacity = self.game_description.capacity
            if current_stock < capacity / n:
                return Action.D
            sum_avg_cons = 0.0
            for prev_round in range(state.round_number):
                opp_payoffs = history.opponent_payoffs[prev_round]
                total_payoffs = np.sum(opp_payoffs)
                avg_cons_per_round = total_payoffs / (n - 1)
                sum_avg_cons += avg_cons_per_round
            avg_opponent_cons = sum_avg_cons / state.round_number
            alpha = 0.3
            term = current_stock / n + alpha * avg_opponent_cons
            threshold = max(capacity / 2, min(capacity, term))
            return Action.C if current_stock >= threshold else Action.D

class Strategy_EXPLOITATIVE_139(BaseStrategy):
    """
    A strategy that adapts based on the number of defectors and stock sustainability.
    Cooperates initially, defects if sustainability is at risk, and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            actions = history.opponent_actions[-1, :]
            num_defectors = len(actions) - np.sum(actions)
            threshold_players = self.n_players / 2
            threshold_stock = self.capacity / 2
            if num_defectors > threshold_players or state.current_stock < threshold_stock:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_140(BaseStrategy):
    """
    A strategy designed for the Common Pool Resource Game that balances exploitation and long-term sustainability.
    It starts with cooperation, adapts based on the stock level and opponents' past actions, and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.previous_actions = [Action.C]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        previous_round = state.round_number - 1
        opp_actions = history.opponent_actions[previous_round]
        sum_op = np.sum(opp_actions)
        other_defectors = self.n_players - 1 - sum_op
        s = state.current_stock
        if s > 0.75 * self.capacity:
            if other_defectors > (self.n_players - 1) / 2:
                return Action.D
            else:
                return Action.C
        elif 0.5 * self.capacity <= s <= 0.75 * self.capacity:
            if other_defectors > (self.n_players - 1) / 2:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_141(BaseStrategy):
    """
    Adaptive strategy for Common Pool Resource Game balancing exploitation and sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            my_last_action = history.my_actions[-1]
            opponent_actions_last = history.opponent_actions[-1]
            my_defected = 0 if my_last_action else 1
            n_opponent_defectors = (opponent_actions_last == False).sum()
            total_defectors = my_defected + n_opponent_defectors
            proportion_defectors = total_defectors / self.game_description.n_players
            if proportion_defectors >= 0.5:
                return Action.C
            elif state.current_stock > 0.75 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_142(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on stock levels and previous cooperation.
    Cooperates initially, defects in the last round, and decides based on previous cooperation and stock in between.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        c_prev = int(my_prev_action) + np.sum(opponent_prev_actions)
        threshold_coop = self.game_description.n_players / 2
        stock_threshold = 0.75 * self.game_description.capacity
        if c_prev >= threshold_coop and state.current_stock > stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_143(BaseStrategy):
    """
    An adaptive strategy that balances cooperation and defection based on the stock level.
    Cooperates initially, defects when stock is below a threshold, and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            threshold = 2.0 / 3.0 * self.capacity
            if state.current_stock > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_144(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on observed resource consumption.
    Cooperates initially, defects in the last round, and adapts based on previous consumption.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_payoff = history.my_payoffs[prev_round]
            opponent_prev_payoffs = history.opponent_payoffs[prev_round, :]
            total_consumption = my_prev_payoff + np.sum(opponent_prev_payoffs)
            threshold = self.capacity / 2
            if total_consumption > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_145(BaseStrategy):
    """
    Adaptive Exploitation with Punishment strategy for the Common Pool Resource Game.
    Cooperates initially, punishes excessive consumption, defects when stock is low, and maximizes in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_stock = state.current_stock
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        is_last_round = state.round_number == self.game_description.n_rounds - 1
        if is_last_round:
            self.last_stock = state.current_stock
            return Action.D
        t_prev = state.round_number - 1
        S_prev = self.last_stock
        my_prev_action = history.my_actions[t_prev]
        opp_prev_actions = history.opponent_actions[t_prev, :]
        total_consumption = 0.0
        if my_prev_action:
            total_consumption += S_prev / (2 * n)
        else:
            total_consumption += S_prev / n
        for opponent_action in opp_prev_actions:
            if opponent_action:
                total_consumption += S_prev / (2 * n)
            else:
                total_consumption += S_prev / n
        threshold = 0.5 * capacity
        stock_threshold = 0.25 * capacity
        if total_consumption > threshold:
            action = Action.D
        elif state.current_stock < stock_threshold:
            action = Action.D
        else:
            action = Action.C
        self.last_stock = state.current_stock
        return action

class Strategy_EXPLOITATIVE_146(BaseStrategy):
    """
    This strategy cooperates in the first round, continues cooperating while stock is above 50% of capacity,
    defects when stock is below that threshold, and always defects in the last round to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C
        elif state.round_number == n_rounds - 1:
            return Action.D
        else:
            half_capacity = capacity / 2.0
            current_stock = state.current_stock
            if current_stock > half_capacity:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_147(BaseStrategy):
    """
    A threshold-based strategy for the Common Pool Resource Game. Defects when the stock exceeds 50% of capacity or when it's the last round; otherwise, cooperates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        half_capacity = 0.5 * capacity
        if state.current_stock > half_capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_148(BaseStrategy):
    """
    A strategy that cooperates initially, defects in the last round, and adapts based on stock levels in middle rounds.
    Cooperates if the current stock is above half the capacity; otherwise, defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            half_capacity = self.game_description.capacity / 2.0
            if state.current_stock > half_capacity:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_149(BaseStrategy):
    """
    Exploitative Strategy for Common Pool Resource Game.

    This strategy balances exploiting others' cooperation with maintaining stock health,
    adapting dynamically based on observed behavior and game state. It uses a mix of
    cooperation, defection, and punishment mechanisms to optimize the player's payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if state.round_number == n_rounds - 1:
            return Action.D
        if current_stock <= 0.1 * capacity:
            return Action.D
        if current_stock >= capacity:
            return Action.C
        if current_stock > 0.75 * capacity:
            last_opponent_actions = history.opponent_actions[-1]
            n_cooperators = np.sum(last_opponent_actions)
            n_opponents = len(last_opponent_actions)
            if n_cooperators > n_opponents / 2:
                return Action.C
            else:
                return Action.D
        elif current_stock < 0.25 * capacity:
            return Action.D
        else:
            last_opponent_actions = history.opponent_actions[-1]
            any_defected = np.any(~last_opponent_actions)
            return Action.D if any_defected else Action.C

class Strategy_EXPLOITATIVE_150(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game. Starts cooperatively, 
    adapts based on stock levels and opponents' actions, with a bias towards defecting 
    when exploitation is detected or in the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        last_round_actions = history.opponent_actions[-1, :]
        defector_count = np.count_nonzero(~last_round_actions)
        defector_prop = defector_count / n_players
        if current_stock > 0.75 * capacity and defector_prop < 0.5:
            return Action.C
        elif current_stock < 0.5 * capacity or defector_prop >= 0.5:
            return Action.D
        else:
            other_coop_count = sum(last_round_actions)
            n_others = len(last_round_actions)
            avg_coop = other_coop_count / n_others
            if avg_coop >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_151(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation with strategic defection.
    The strategy starts by cooperating, adapts based on opponents' past actions and resource levels, 
    and defects in the final round to maximize immediate gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        n_players = self.game_description.n_players
        n_opponents = n_players - 1
        current_round = state.round_number
        num_defections = 0
        for r in range(current_round):
            for p in range(n_opponents):
                if not history.opponent_actions[r][p]:
                    num_defections += 1
        total_actions = current_round * n_opponents
        avg_defect = num_defections / total_actions
        if avg_defect > 0.5:
            return Action.D
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_152(BaseStrategy):
    """
    A strategy for the Common Pool Resource game that adaptively responds to stock levels
    and opponents' actions, balancing cooperation and defection to maximize payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        stock_threshold = 0.2 * capacity
        current_stock = state.current_stock
        if current_stock < stock_threshold:
            return Action.C
        prev_round = state.round_number - 1
        opp_actions = history.opponent_actions[prev_round]
        n_players = self.game_description.n_players
        defectors = np.sum(1 - opp_actions)
        if defectors >= n_players / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_153(BaseStrategy):
    """
    Adaptive strategy for the Common Pool Resource Game that balances cooperation 
    with strategic defection based on stock levels, opponent behavior, and recent payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.C
        if state.current_stock < 0.2 * self.game_description.capacity:
            return Action.C
        capacity = self.game_description.capacity
        threshold = 0.7 * capacity
        stock = state.current_stock
        n = self.game_description.n_players
        available_rounds = state.round_number
        if stock > threshold:
            opponent_actions = history.opponent_actions
            sum_coop = sum(opponent_actions.flatten())
            total_possible = (n - 1) * available_rounds
            avg_coop = sum_coop / total_possible if total_possible > 0 else 0.0
            my_payoffs = history.my_payoffs
            last_payoff = my_payoffs[-1] if available_rounds > 0 else 0.0
            coop_payoff = stock / (2 * n)
            if avg_coop >= 0.5 and last_payoff > coop_payoff:
                return Action.C
            else:
                return Action.D
        else:
            my_payoffs = history.my_payoffs
            if len(my_payoffs) >= 5:
                avg_last_five = np.mean(my_payoffs[-5:])
                coop_payoff = stock / (2 * n)
                if avg_last_five > coop_payoff:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_154(BaseStrategy):
    """
    Adaptive Exploitation with Sustainability strategy for the Common Pool Resource Game.
    This strategy aims to balance cooperation to sustain the resource and defection to exploit higher stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == self.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            threshold = self.capacity / 2
            if current_stock <= threshold:
                my_prev_action = history.my_actions[-1]
                my_D = 0 if my_prev_action else 1
                prev_opponent_actions = history.opponent_actions[-1, :]
                opponent_Ds = np.sum(~prev_opponent_actions)
                D_count_total = my_D + opponent_Ds
                if D_count_total < self.n_players / 2:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_155(BaseStrategy):
    """
    A strategy for the Common Pool Resource game that balances exploitation and preservation.
    Cooperates initially, defects in the last round, and adapts based on previous defections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        t_prev = state.round_number - 1
        opponent_prev_actions = history.opponent_actions[t_prev]
        my_prev_action = history.my_actions[t_prev]
        k_prev = (0 if my_prev_action else 1) + sum((1 for action in opponent_prev_actions if not action))
        critical_threshold = self.game_description.capacity / (2 * self.game_description.n_players)
        if state.current_stock < critical_threshold:
            return Action.C
        elif k_prev > self.game_description.n_players / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_156(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that adapts based on stock level and opponents' behavior.
    Cooperates initially, defects in the last round, and adapts in middle rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        opponent_actions = history.opponent_actions
        relevant_rounds = opponent_actions[:state.round_number]
        total_actions = relevant_rounds.size
        sum_coop = np.sum(relevant_rounds)
        sum_defect = total_actions - sum_coop
        defect_rate = sum_defect / total_actions if total_actions != 0 else 0.0
        s_current = state.current_stock
        capacity = self.game_description.capacity
        stock_below_half = s_current < 0.5 * capacity
        if stock_below_half or defect_rate > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_159(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that adaptively balances cooperation and defection.
    Cooperates initially, defects if high exploitation is detected or stock is low, and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.last_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            self.last_stock = state.current_stock
            return Action.D
        if state.round_number == 0:
            self.last_stock = state.current_stock
            return Action.C
        t_prev = state.round_number - 1
        my_prev_action = history.my_actions[t_prev]
        opp_prev_actions = history.opponent_actions[t_prev]
        cooperators_count = 0
        if my_prev_action:
            cooperators_count += 1
        cooperators_count += sum(opp_prev_actions)
        n = self.n_players
        s_prev = self.last_stock
        total_cons = s_prev * (1 - cooperators_count / (2 * n))
        percent_consumption = total_cons / self.capacity * 100
        current_stock = state.current_stock
        stock_below_threshold = current_stock < 0.5 * self.capacity
        if percent_consumption > 30 or stock_below_threshold:
            action = Action.D
        else:
            action = Action.C
        self.last_stock = state.current_stock
        return action

class Strategy_EXPLOITATIVE_160(BaseStrategy):
    """
    A strategy that adapts based on stock levels and historical cooperation.
    Cooperates initially, defects if stock drops below 50%, and dynamically adjusts cooperation threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_below50 = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        capacity = self.capacity
        n_rounds = self.n_rounds
        if t == n_rounds - 1:
            return Action.D
        if t == 0:
            return Action.C
        current_stock = state.current_stock
        if current_stock < 0.5 * capacity:
            if not self.stock_below50:
                self.stock_below50 = True
            return Action.D
        if self.stock_below50:
            return Action.D
        opponent_actions = history.opponent_actions
        total_coops = np.sum(opponent_actions)
        avg_coop = total_coops / (t * (self.n_players - 1)) if t * (self.n_players - 1) != 0 else 0.0
        threshold = 0.5 + 0.5 * ((t + 1) / n_rounds)
        if avg_coop >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_161(BaseStrategy):
    """
    This strategy begins by cooperating to encourage reciprocity. It adapts by defecting if most others defected or if the stock is critically low. It defects in the endgame rounds to maximize late gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        num_endgame_rounds = max(1, min(5, int(0.1 * self.game_description.n_rounds)))
        endgame_threshold = self.game_description.n_rounds - num_endgame_rounds
        in_endgame = state.round_number >= endgame_threshold
        if in_endgame:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        my_payoff_prev = history.my_payoffs[prev_round]
        if my_prev_action:
            S_prev = my_payoff_prev * (2 * self.game_description.n_players)
        else:
            S_prev = my_payoff_prev * self.game_description.n_players
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        num_cooperators = int(my_prev_action) + int(opponent_prev_actions.sum())
        num_defectors = self.game_description.n_players - num_cooperators
        defector_condition = num_defectors > self.game_description.n_players / 2
        critical_stock = self.game_description.capacity / 2
        stock_condition = state.current_stock < critical_stock
        if defector_condition or stock_condition:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_162(BaseStrategy):
    """
    Adaptive Exploitation with Sustainability strategy for the Common Pool Resource Game.
    Balances cooperation and defection dynamically based on opponents' actions and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number > self.n_rounds - 3:
            return Action.D
        current_round = state.round_number
        window_size = min(5, current_round)
        start = max(0, current_round - window_size)
        recent_actions = history.opponent_actions[start:current_round, :]
        coop_count = np.sum(recent_actions)
        total_actions = recent_actions.size
        recent_coop_rate = coop_count / total_actions
        if recent_coop_rate < 0.5:
            defect_prob = 0.8
        else:
            defect_prob = 0.2
        stock_ratio = state.current_stock / self.capacity
        if stock_ratio > 0.75:
            defect_prob += 0.2
            defect_prob = min(defect_prob, 1.0)
        elif stock_ratio < 0.25:
            defect_prob -= 0.2
            defect_prob = max(defect_prob, 0.0)
        if state.current_stock / self.capacity < 0.1:
            return Action.C
        if random.random() < defect_prob:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_163(BaseStrategy):
    """
    Adaptive Exploitation Strategy based on stock trends in the Common Pool Resource game.
    
    - Cooperates in the first round to establish a sustainable baseline.
    - Defects in the final round to maximize immediate payoff.
    - In intermediate rounds, cooperates if the stock is sustainably high and shows a non-decreasing trend, otherwise defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            self.stock_history.append(state.current_stock)
            current_stock = state.current_stock
            threshold = self.game_description.capacity / 2
            recent_stocks = self.stock_history[-3:]
            avg_recent = np.mean(recent_stocks) if recent_stocks else 0.0
            if current_stock > threshold:
                if avg_recent >= current_stock:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_164(BaseStrategy):
    """
    Adaptive Exploitation Strategy (AES) for the Common Pool Resource Game.
    This strategy balances cooperation and defection based on stock levels and trends.
    It encourages sustainability while maximizing individual payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.stock_history = [self.capacity]

    def determine_trend(self) -> str:
        if len(self.stock_history) < 2:
            return 'stable'
        recent = self.stock_history[-1]
        previous = self.stock_history[-2]
        delta = recent - previous
        if delta > 1e-09:
            return 'increasing'
        elif delta < -1e-09:
            return 'declining'
        else:
            return 'stable'

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        current_stock = state.current_stock
        if t == len(self.stock_history):
            self.stock_history.append(current_stock)
        if t == 0:
            return Action.C
        if t == self.game_description.n_rounds - 1:
            return Action.D
        threshold_high = 0.7 * self.capacity
        threshold_low = 0.5 * self.capacity
        trend = self.determine_trend()
        if current_stock < threshold_low or trend == 'declining':
            return Action.D
        elif current_stock > threshold_high and trend in ['increasing', 'stable']:
            return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_165(BaseStrategy):
    """
    An Adaptive Exploitation with Stock Preservation (AES) strategy for the Common Pool Resource Game.
    It balances cooperation and defection based on opponent actions and stock levels to maximize payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        prev_my_action = history.my_actions[state.round_number - 1]
        prev_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        num_defectors = 0
        if not prev_my_action:
            num_defectors += 1
        num_defectors += sum((1 for action in prev_opponent_actions if not action))
        if num_defectors > n_players / 2:
            return Action.D
        elif current_stock < 0.25 * capacity:
            return Action.C
        elif state.round_number == total_rounds:
            if current_stock < 0.5 * capacity:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C if prev_my_action else Action.D

class Strategy_EXPLOITATIVE_167(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on stock levels and game progression.
    - Cooperates in the first round.
    - Defects in the last round.
    - Defects when stock is above 75% of capacity, Cooperates when below 50%.
    - Alternates between Cooperate and Defect when stock is between 50-75%.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.alternate_next = Action.C

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        percentage = state.current_stock / self.game_description.capacity
        if percentage > 0.75:
            return Action.D
        elif percentage < 0.5:
            return Action.C
        else:
            action = self.alternate_next
            self.alternate_next = Action.D if action == Action.C else Action.C
            return action

class Strategy_EXPLOITATIVE_168(BaseStrategy):
    """
    Reciprocative Threshold with Stock Consideration strategy for the Common Pool Resource Game.
    Cooperates initially, adapts based on stock levels and opponent behavior, and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.5 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < self.threshold:
            return Action.C
        else:
            prev_opp_actions = history.opponent_actions[-1, :]
            sum_coop = np.sum(prev_opp_actions)
            sum_defect = self.game_description.n_players - sum_coop
            proportion_defect = sum_defect / self.game_description.n_players
            if proportion_defect >= 0.5:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_169(BaseStrategy):
    """
    Adaptive strategy for the Common Pool Resource Game balancing experimentation, reciprocation, 
    conservation, and exploitation to maximize total payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.num_experimentation_rounds = math.floor(0.2 * self.n_rounds)
        self.experimentation_cutoff = self.num_experimentation_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return random.choice([Action.C, Action.D])
        elif current_round <= self.experimentation_cutoff:
            return random.choice([Action.C, Action.D])
        else:
            sum_coop = np.sum(history.opponent_actions[:current_round, :])
            total_actions = current_round * (self.n_players - 1)
            avg_coop = sum_coop / total_actions if total_actions != 0 else 0.0
            endgame_cutoff = 0.9 * (self.n_rounds - 1)
            in_endgame = current_round > endgame_cutoff
            conservation_threshold = 0.2 * self.capacity
            if avg_coop > 0.7:
                return Action.C
            elif avg_coop < 0.3:
                return Action.D
            elif state.current_stock < conservation_threshold:
                if in_endgame:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_170(BaseStrategy):
    """
    Adaptive Exploitative Approach for the Common Pool Resource Game.

    This strategy initially cooperates, punishes defectors, adapts to stock levels,
    and defects in the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number <= 1:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        if self.punish_rounds > 0:
            self.punish_rounds -= 1
            return Action.D
        stock_level = state.current_stock / self.game_description.capacity
        if stock_level < 0.3:
            return Action.C
        elif stock_level > 0.7:
            return Action.D
        else:
            prev_actions = history.opponent_actions[-1, :]
            n_defectors = sum((1 for action in prev_actions if not action))
            defect_rate = n_defectors / self.game_description.n_players
            if defect_rate > 0.5:
                self.punish_rounds = 2
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_171(BaseStrategy):
    """
    Adaptive strategy for Common Pool Resource Game balancing cooperation and defection based on stock levels and opponents' behavior.
    Cooperates initially, defects in the last round, and adapts middle rounds based on stock and opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_prev_actions = history.opponent_actions[prev_round]
            n_coop_prev = sum(opponent_prev_actions) + my_prev_action
            defectors = self.game_description.n_players - n_coop_prev
            condition1 = defectors > self.game_description.n_players / 2
            condition2 = state.current_stock < 0.5 * self.game_description.capacity
            if condition1 or condition2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_172(BaseStrategy):
    """
    Exploitative Strategy for Common Pool Resource Game.

    Cooperates initially and in subsequent rounds if cooperation rate exceeds 50% and 
    stock is above half capacity. Defects otherwise, especially in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        n_rounds = self.game_description.n_rounds
        if round_number == 0:
            return Action.C
        elif round_number == n_rounds - 1:
            return Action.D
        previous_rounds = round_number
        total_cooperators = 0
        for r in range(previous_rounds):
            my_c = history.my_actions[r]
            opponent_actions = history.opponent_actions[r]
            coop_count = np.sum(opponent_actions) + (1 if my_c else 0)
            total_cooperators += coop_count
        n_players = self.game_description.n_players
        avg_coop = total_cooperators / (n_players * previous_rounds)
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        threshold = capacity / 2
        if avg_coop > 0.5 and current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_173(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that adapts based on cooperation rates, 
    stock levels, and round progression. It cooperates initially, defects in the final round, 
    and dynamically adjusts based on others' cooperation and resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        threshold = 0.5 * self.capacity
        if state.current_stock < threshold:
            return Action.D
        prev_actions = history.opponent_actions[-1]
        n_coop_prev = sum(prev_actions)
        n_opponents = self.n_players - 1
        if n_coop_prev > n_opponents // 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_174(BaseStrategy):
    """
    This strategy adapts based on the stock level and previous actions to balance exploitation and conservation.
    It cooperates initially to observe opponents, defects when the stock is plentiful, conserves when stock is low,
    and adjusts based on others' past behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        stock_ratio = state.current_stock / self.capacity
        if stock_ratio > 0.75:
            return Action.D
        elif stock_ratio <= 0.25:
            return Action.C
        else:
            previous_round = state.round_number - 1
            self_defected = not history.my_actions[previous_round]
            opponent_actions_last_round = history.opponent_actions[previous_round]
            opponent_defectors = len(opponent_actions_last_round) - np.count_nonzero(opponent_actions_last_round)
            total_defectors = (1 if self_defected else 0) + opponent_defectors
            threshold = self.n_players / 2.0
            if total_defectors > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_175(BaseStrategy):
    """
    A strategy that adapts based on stock trends and cooperation levels.
    Cooperates initially and monitors stock levels to decide actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = [game_description.capacity]

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        round_number = state.round_number
        n_rounds = self.game_description.n_rounds
        if round_number == 0:
            action = Action.C
        elif round_number == n_rounds - 1:
            action = Action.D
        else:
            threshold_high = 0.75 * capacity
            threshold_low = 0.25 * capacity
            if current_stock > threshold_high:
                action = Action.C
            elif current_stock < threshold_low:
                action = Action.D
            else:
                stock_history_length = len(self.stock_history)
                k = min(3, stock_history_length - 1)
                if k == 0:
                    action = Action.C
                else:
                    recent_stocks = self.stock_history[-k:]
                    sum_recent = sum(recent_stocks)
                    avg_change = (sum_recent - current_stock) / k
                    if avg_change > 0:
                        action = Action.C
                    else:
                        action = Action.D
        if round_number != 0:
            self.stock_history.append(current_stock)
        return action

class Strategy_EXPLOITATIVE_176(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            capacity = self.game_description.capacity
            half_capacity = capacity / 2.0
            if state.current_stock > half_capacity:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_177(BaseStrategy):
    """
    Adaptive Exploitation Strategy for the Common Pool Resource Game.
    Cooperates initially, then decides based on stock trends and adjusts threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history_stocks = []
        self.current_threshold = game_description.capacity / 2
        self.min_threshold = 0.1 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.history_stocks.append(state.current_stock)
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.C
        window = min(3, len(self.history_stocks) - 1)
        last_stocks = self.history_stocks[-window:]
        avg_stock = sum(last_stocks) / window
        if avg_stock < self.current_threshold:
            self.current_threshold *= 0.95
            self.current_threshold = max(self.current_threshold, self.min_threshold)
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_178(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game. It cooperates initially, 
    then adapts based on opponents' previous actions and current stock levels, defecting 
    in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        previous_opponents = history.opponent_actions[-1, :]
        defectors = np.sum(~previous_opponents)
        n_players = self.game_description.n_players
        if defectors > n_players / 2:
            return Action.D
        elif state.current_stock > 0.5 * self.game_description.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_179(BaseStrategy):
    """
    This strategy implements the Adaptive Exploitation with Sustainability (AES) approach.
    It starts by Cooperating, then switches to Defecting if the stock drops below a threshold,
    with special handling for critically low stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == self.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            twenty_five_percent = 0.25 * self.capacity
            seventy_five_percent = 0.75 * self.capacity
            if current_stock < twenty_five_percent:
                return Action.C
            elif current_stock >= seventy_five_percent:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_181(BaseStrategy):
    """
    Cooperate if the previous stock was below 50% of capacity; otherwise, Defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_182(BaseStrategy):
    """
    A strategy that adaptively exploits the common pool resource based on stock levels and opponents' past actions.
    Cooperates initially, defects in endgame, and dynamically adjusts based on current conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C
        if state.round_number >= n_rounds - 3:
            return Action.D
        if state.current_stock < 0.5 * capacity:
            return Action.C
        if history is None:
            return Action.C
        opponent_actions = history.opponent_actions
        total_rounds = len(opponent_actions)
        start = max(0, total_rounds - 3)
        recent_actions = opponent_actions[start:]
        flattened = recent_actions.ravel()
        total_actions = len(flattened)
        if total_actions == 0:
            return Action.C
        defection_count = total_actions - np.sum(flattened)
        defection_rate = defection_count / total_actions
        if defection_rate < 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_183(BaseStrategy):
    """
    Adaptive Exploitation Based on Stock and Defection Trends.
    
    This strategy balances immediate payoffs with long-term stock sustainability.
    It cooperates initially to observe behavior and adapts based on recent stock levels and defection rates.
    Defects when stock is sufficient, especially in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.stock_history.append(state.current_stock)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        stock_history = self.stock_history
        n_stocks = len(stock_history)
        avg_stock = sum(stock_history[-3:]) / min(3, n_stocks) if n_stocks > 0 else 0.0
        capacity = self.game_description.capacity
        avg_stock_ratio = avg_stock / capacity
        total_defections = 0
        if history is not None:
            max_rounds_to_consider = 3
            start_round = max(0, len(history.opponent_actions) - max_rounds_to_consider)
            for i in range(start_round, len(history.opponent_actions)):
                round_actions = history.opponent_actions[i]
                defects = sum((1 for a in round_actions if a is False))
                total_defections += defects
            num_rounds = min(max_rounds_to_consider, len(history.opponent_actions))
            avg_defection_rate = total_defections / (self.game_description.n_players * num_rounds) if num_rounds > 0 else 0.0
        else:
            avg_defection_rate = 0.0
        if avg_stock_ratio < 0.5 and avg_defection_rate > 0.5:
            return Action.C
        elif state.current_stock >= 0.5 * capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_184(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that
    balances cooperation and defection based on opponents' actions,
    stock levels, and personal payoff performance.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= 0.9 * self.game_description.n_rounds:
            return Action.D
        last_opponent_actions = history.opponent_actions[-1, :]
        n_opponents = self.game_description.n_players - 1
        defectors = (~last_opponent_actions).sum()
        if defectors / n_opponents > 0.5:
            return Action.D
        if state.current_stock < 0.2 * self.game_description.capacity:
            return Action.D
        my_avg_payoff = np.mean(history.my_payoffs)
        others_avg_payoff = np.mean(history.opponent_payoffs)
        if my_avg_payoff < others_avg_payoff:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_185(BaseStrategy):
    """
    Exploitative strategy for the Common Pool Resource game, balancing initial cooperation with adaptive responses.
    Implements a threshold-based approach considering stock levels, cooperation rates, and relative payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.adaptive_threshold = 0.25
        self.stock_trend = []
        self.coop_trend = []
        self.my_payoff_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_trend.append(state.current_stock)
            return Action.C
        if state.round_number == self.n_rounds - 1:
            self.stock_trend.append(state.current_stock)
            if len(self.stock_trend) >= 2:
                if self.stock_trend[-1] < self.stock_trend[-2]:
                    self.adaptive_threshold = max(0.1, self.adaptive_threshold - 0.05)
            return Action.D
        self.stock_trend.append(state.current_stock)
        if len(self.stock_trend) >= 2:
            if self.stock_trend[-1] < self.stock_trend[-2]:
                self.adaptive_threshold = max(0.1, self.adaptive_threshold - 0.05)
        if state.current_stock < self.capacity * self.adaptive_threshold:
            return Action.D
        my_last_action = history.my_actions[-1]
        opponents_last_actions = history.opponent_actions[-1, :]
        total_cooperators = (1 if my_last_action else 0) + int(opponents_last_actions.sum())
        defectors = self.n_players - total_cooperators
        if defectors > self.n_players / 2:
            return Action.D
        else:
            my_avg = np.mean(history.my_payoffs) if len(history.my_payoffs) > 0 else 0.0
            opponents_avg = np.mean(history.opponent_payoffs) if len(history.opponent_payoffs) > 0 else 0.0
            if my_avg < opponents_avg:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_310(BaseStrategy):
    """
    Adaptive Cooperate-Punish Strategy for the Common Pool Resource Game.
    Cooperates initially, punishes when defections exceed 25%, and prioritizes
    stock regrowth when levels are low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        capacity = self.game_description.capacity
        if state.current_stock < capacity / 2:
            return Action.C
        last_round_actions = history.opponent_actions[-1]
        n_defectors = len(last_round_actions) - np.sum(last_round_actions)
        threshold = self.game_description.n_players * 0.25
        if n_defectors > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_344(BaseStrategy):
    """
    Adaptive Sustainability with Punishment (ASP) strategy.
    Cooperates initially, defects in the last round, and adapts based on stock level and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        my_defect = not my_prev_action
        opponent_defect_count = np.count_nonzero(~opponent_actions_prev)
        total_defectors = int(my_defect) + opponent_defect_count
        defect_rate = total_defectors / self.n_players
        stock_ratio = state.current_stock / self.capacity
        THRESHOLD_LOW_STOCK = 0.05
        if stock_ratio <= THRESHOLD_LOW_STOCK:
            if state.round_number < self.n_rounds - 1:
                return Action.C
            else:
                return Action.D
        elif stock_ratio > 0.5 and defect_rate < 0.25:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_370(BaseStrategy):
    """
    A strategy that adaptively cooperates or defects based on stock levels and game progress.
    It starts with cooperation, then uses stock-level thresholds to decide actions, 
    with special handling for endgame scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.past_stock_levels = []
        self.defecting = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.past_stock_levels.append(state.current_stock)
        total_rounds = self.game_description.n_rounds
        is_endgame = state.round_number >= 0.9 * total_rounds
        is_critical_stock = state.current_stock <= 0.25 * self.game_description.capacity
        if is_endgame or is_critical_stock:
            return Action.D
        avg_window_size = min(3, len(self.past_stock_levels))
        stock_history = self.past_stock_levels[-avg_window_size:]
        current_avg = sum(stock_history) / avg_window_size
        threshold = 0.75 * self.game_description.capacity
        if not self.defecting:
            if current_avg >= threshold:
                return Action.C
            else:
                self.defecting = True
                return Action.D
        elif current_avg >= threshold:
            self.defecting = False
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_395(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation with strategic defection.
    It adapts based on collective behavior and stock health to maintain sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.rounds_to_cooperate = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > self.capacity / 2:
                return Action.C
        if self.rounds_to_cooperate > 0:
            self.rounds_to_cooperate -= 1
            return Action.C
        if state.current_stock < self.capacity / 2:
            self.rounds_to_cooperate = 2
            return Action.C
        my_coop = sum(history.my_actions)
        opp_coop = history.opponent_actions.sum()
        total_coop = my_coop + opp_coop
        total_actions = state.round_number * self.n_players
        avg_coop = total_coop / total_actions if total_actions != 0 else 0.0
        if avg_coop < 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_428(BaseStrategy):
    """
    Adaptive Cooperation with Punishment and Forgiveness (ACPF) strategy.
    Balances cooperation with strategic defection to maintain resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round >= 0.9 * self.n_rounds:
            return Action.D
        prev_round = current_round - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_actions = history.opponent_actions[prev_round, :]
        sum_payoffs_prev = history.my_payoffs[prev_round] + np.sum(history.opponent_payoffs[prev_round])
        C_prev = (1 if my_prev_action else 0) + np.sum(opponent_actions)
        denominator = 1 - C_prev / (2 * self.n_players)
        if denominator <= 0:
            S_prev = sum_payoffs_prev
        else:
            S_prev = sum_payoffs_prev / denominator
        if S_prev == 0:
            excess_fraction = 0.0
        else:
            sustainable = S_prev / 2
            excess = max(0.0, sum_payoffs_prev - sustainable)
            excess_fraction = excess / sustainable if sustainable != 0 else 0.0
        stock_recovery_threshold = self.capacity / 2.0
        if S_prev < stock_recovery_threshold and excess_fraction > 0.25:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_433(BaseStrategy):
    """
    A strategy that begins with cooperation and adapts based on stock levels.
    Cooperates if stock is above a threshold, defects if the trend shows consecutive decreases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.threshold = 0.9 * self.capacity
        self.past_stocks = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.past_stocks.append(state.current_stock)
            return Action.C
        self.past_stocks.append(state.current_stock)
        if state.current_stock >= self.threshold:
            return Action.C
        if len(self.past_stocks) >= 2 and self.past_stocks[-1] < self.past_stocks[-2]:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_465(BaseStrategy):
    """
    A strategy designed for the Common Pool Resource Game that balances cooperation with punishment,
    adapts to stock levels, and evaluates overall cooperation in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return self._handle_final_round(history)
        current_stock = state.current_stock
        half_capacity = self.capacity * 0.5
        if current_stock < half_capacity:
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        opponents_last_round = history.opponent_actions[prev_round, :]
        I_defected = 0 if prev_my_action else 1
        opponent_defectors = (~opponents_last_round).sum()
        D_count = I_defected + opponent_defectors
        threshold = self.n_players / 4
        if D_count <= threshold:
            return Action.C
        else:
            return Action.D

    def _handle_final_round(self, history: PlayerHistory) -> Action:
        total_my_c = sum(history.my_actions[:self.n_rounds - 1])
        total_opponent_c = history.opponent_actions[:self.n_rounds - 1, :].sum()
        total_coop = total_my_c + total_opponent_c
        total_possible = (self.n_rounds - 1) * self.n_players
        if total_coop / total_possible >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_19(BaseStrategy):
    """
    An adaptive strategy that balances cooperation and defection based on stock levels and opponent behavior.
    Cooperates initially, defects if stock falls below a threshold, defects in the last round, and responds to opponent defections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        threshold = 0.5 * self.capacity
        current_stock = state.current_stock
        current_round = state.round_number
        total_rounds = self.n_rounds
        if current_round == total_rounds - 1:
            return Action.D
        if current_stock < threshold:
            return Action.D
        n_defectors_prev = np.sum(1 - history.opponent_actions[-1, :])
        if n_defectors_prev > (self.n_players - 1) / 2:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_21(BaseStrategy):
    """
    Exploitative Strategy for Common Pool Resource Game.
    Cooperates initially and when stock is high, defects when stock is low or in last round.
    Adapts based on opponent actions and monitors stock levels to avoid depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.min_stock_threshold = 0.3 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.min_stock_threshold:
            return Action.C
        if current_stock > 0.5 * self.capacity:
            if history is not None:
                opp_acts = history.opponent_actions[-1]
                n_defectors = np.count_nonzero(~opp_acts)
                n_opponents = self.n_players - 1
                if n_defectors > n_opponents / 2:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_60(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances exploitation and sustainability.
    Cooperates initially, defects in the last round, and adapts based on others' cooperation and stock health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.n_players
        capacity = self.capacity
        total_rounds = self.game_description.n_rounds
        if state.round_number == total_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        stock_level = current_stock / capacity
        if stock_level < 0.25:
            return Action.C
        my_prev_action = history.my_actions[-1]
        opp_prev_actions = history.opponent_actions[-1, :]
        opp_coop = opp_prev_actions.sum()
        cooperation_count = int(my_prev_action) + opp_coop
        cooperation_rate = cooperation_count / n
        if cooperation_rate > 0.75:
            return Action.D
        elif cooperation_rate < 0.5:
            return Action.C
        else:
            p_coop = (cooperation_rate - 0.5) / (0.75 - 0.5)
            if random.random() < p_coop:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_77(BaseStrategy):
    """
    A strategy that adapts based on stock trends and opponent defection rates.
    Cooperates initially, defects if stock trends down or if many opponents defect,
    and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_levels = []

    def _calculate_stock_trend(self, stock_levels: list[float]) -> str:
        if len(stock_levels) < 2:
            return 'stable'
        current = stock_levels[-1]
        previous = stock_levels[-2]
        return 'declining' if current < previous else 'stable'

    def _calculate_defect_rate(self, history: PlayerHistory | None) -> float:
        if history is None:
            return 0.0
        n_players = self.game_description.n_players
        round_number = history.my_actions.size
        if round_number == 0:
            return 0.0
        opponent_actions = history.opponent_actions[:round_number, :]
        defect_count = np.sum(opponent_actions == 0)
        total_actions = (n_players - 1) * round_number
        return defect_count / total_actions if total_actions > 0 else 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_levels.append(state.current_stock)
            return Action.C
        else:
            self.stock_levels.append(state.current_stock)
            current_round = state.round_number
            n_rounds = self.game_description.n_rounds
            capacity = self.game_description.capacity
            if current_round == n_rounds - 1:
                return Action.D
            else:
                trend = self._calculate_stock_trend(self.stock_levels)
                defection_rate = self._calculate_defect_rate(history)
                stock_threshold = 0.5 * capacity
                if state.current_stock < stock_threshold and defection_rate > 0.5:
                    return Action.D
                elif trend == 'declining':
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_94(BaseStrategy):
    """
    Adaptive Exploitation Strategy based on historical behavior and stock levels.
    Cooperates initially, defects in last round, and adapts based on others' actions and stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            t = state.round_number
            n = self.game_description.n_players
            capacity = self.game_description.capacity
            sum_defectors = 0.0
            for k in range(t):
                opponent_defectors = np.sum(~history.opponent_actions[k])
                my_defection = 1 if not history.my_actions[k] else 0
                sum_defectors += opponent_defectors + my_defection
            average_defectors = sum_defectors / t
            if state.current_stock < 0.1 * capacity:
                if average_defectors > n / 2:
                    return Action.D
                else:
                    return Action.C
            elif average_defectors > n / 2:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_157(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on stock levels and historical defections.
    Cooperates initially, defects if stock is low or many defections, cooperates penultimately, and defects finally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        t = state.round_number
        n = self.n_players
        r = self.n_rounds
        capacity = self.capacity
        if t == 0:
            return Action.C
        elif t == r - 1:
            return Action.D
        elif t == r - 2:
            return Action.C
        else:
            window_start = max(0, t - 3)
            total_defectors = 0.0
            for round in range(window_start, t):
                opponent_actions = history.opponent_actions[round]
                opponent_defectors = len(opponent_actions) - np.sum(opponent_actions)
                my_defection = 0 if history.my_actions[round] else 1
                total_defectors += opponent_defectors + my_defection
            window_size = t - window_start
            avg_defectors = total_defectors / window_size if window_size > 0 else 0.0
            stock = state.current_stock
            stock_threshold = 0.3 * capacity
            if avg_defectors > n / 2 or stock < stock_threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_158(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that dynamically adjusts
    between cooperation and defection based on the stock level and other players' actions.
    Cooperates initially, defects if the stock is scarce or if most others defected,
    and always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_depleted = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock <= 0:
            self.stock_depleted = True
            return Action.D
        if self.stock_depleted:
            return Action.D
        if state.round_number == self.n_rounds - 1:
            return Action.D
        threshold = 0.25 * self.capacity
        if state.current_stock < threshold:
            return Action.D
        last_round_opp_actions = history.opponent_actions[-1]
        opp_defections = np.count_nonzero(~last_round_opp_actions)
        my_last_action = history.my_actions[-1]
        if not my_last_action:
            opp_defections += 1
        count_defections = opp_defections
        n_players = self.game_description.n_players
        if count_defections > n_players / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_166(BaseStrategy):
    """
    Adaptive Cooperation with Stock Threshold Strategy.
    
    This strategy starts with cooperation in the first round, defects in the last round,
    and adapts based on the stock level and opponents' cooperation rate in intermediate rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock < 0.5 * capacity:
            return Action.C
        rates = []
        for r in range(len(history.opponent_actions)):
            opponent_actions_r = history.opponent_actions[r]
            coop_count = sum(opponent_actions_r)
            n_opponents = len(opponent_actions_r)
            rate = coop_count / n_opponents if n_opponents > 0 else 0.0
            rates.append(rate)
        m = len(rates)
        if m == 0:
            return Action.D
        weights = [0.9 ** (m - 1 - i) for i in range(m)]
        sum_weights = sum(weights)
        if sum_weights == 0:
            return Action.D
        weighted_sum = 0.0
        for i, rate in enumerate(rates):
            weighted_sum += rate * weights[i]
        avg_coop = weighted_sum / sum_weights
        if avg_coop > 0.7:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_180(BaseStrategy):
    """
    A strategy that starts with cooperation and adapts based on stock levels and others' behavior.
    Cooperates unless stock falls below 50% of capacity or majority defected recently.
    Defects in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.cooperate_next = True
        self.defecting = False

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        defector_counts = []
        for r in range(current_round):
            if r >= len(history.my_actions):
                break
            player_defected = history.my_actions[r] == Action.D
            opponents_defected = sum((1 for action in history.opponent_actions[r] if action == Action.D))
            total_defectors = int(player_defected) + opponents_defected
            defector_counts.append(total_defectors)
        if defector_counts:
            recent_defectors = defector_counts[-3:]
            avg_defectors = sum(recent_defectors) / len(recent_defectors)
        else:
            avg_defectors = 0.0
        current_stock = state.current_stock
        stock_threshold = 0.5 * self.capacity
        stock_below_half = current_stock < stock_threshold
        defectors_exceed_half = avg_defectors > self.n_players / 2
        if self.defecting:
            if current_stock >= stock_threshold and avg_defectors <= self.n_players / 2:
                self.cooperate_next = True
                self.defecting = False
                return Action.C
            else:
                self.cooperate_next = False
                self.defecting = True
                return Action.D
        elif stock_below_half or defectors_exceed_half:
            self.cooperate_next = False
            self.defecting = True
            return Action.D
        else:
            self.cooperate_next = True
            self.defecting = False
            return Action.C

class Strategy_EXPLOITATIVE_186(BaseStrategy):
    """
    An adaptive strategy that balances cooperation and defection based on stock levels, remaining rounds, and opponent behavior.
    Cooperates initially to preserve stock and gather information, then adapts based on observed opponent actions and stock trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < 5:
            return Action.C
        recent_defection_rate = 0.0
        n_opponents = self.n_players - 1
        if history is not None:
            recent_rounds = 3
            start_round = max(0, state.round_number - recent_rounds)
            opponent_defections = 0
            total_opponents = 0
            for r in range(start_round, state.round_number):
                if r >= len(history.opponent_actions):
                    continue
                count = sum((1 for action in history.opponent_actions[r] if action is False))
                opponent_defections += count
                total_opponents += n_opponents
            if total_opponents > 0:
                recent_defection_rate = opponent_defections / total_opponents
        sustainability_threshold = 0.5 * (1 - max(0, self.n_rounds - state.round_number - 1) / self.n_rounds) * self.capacity
        current_stock = state.current_stock
        if current_stock < sustainability_threshold:
            return Action.C
        elif recent_defection_rate > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_187(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game balancing cooperation and defection based on stock levels and historical cooperation rates.
    Implements initial cooperation, stock monitoring, endgame strategy, adaptive thresholds, robustness, and mixed strategies.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold = (self.n_players // 2 + 1) / self.n_players
        self.depletion_threshold = -0.2
        self.mixing_probability = 0.05
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
            self.stock_history.append(state.current_stock)
        else:
            self.stock_history.append(state.current_stock)
            if state.round_number == self.n_rounds - 1:
                if state.current_stock > 0.5 * self.capacity:
                    action = Action.D
                else:
                    action = Action.C
            else:
                if state.current_stock < 0.2 * self.capacity:
                    action = Action.C
                else:
                    t = state.round_number
                    my_C = sum(history.my_actions[:t])
                    opponent_C = 0
                    for rnd in range(t):
                        opponent_C += np.sum(history.opponent_actions[rnd, :])
                    total_C = my_C + opponent_C
                    total_actions = t * self.n_players
                    cooperation_rate = total_C / total_actions
                    if cooperation_rate > self.cooperation_threshold:
                        action = Action.C
                    else:
                        action = Action.D
                if len(self.stock_history) >= 2:
                    prev_stock = self.stock_history[-2]
                    current_stock = self.stock_history[-1]
                    if prev_stock == 0:
                        rate = -1.0
                    else:
                        rate = (current_stock - prev_stock) / prev_stock
                    if rate < self.depletion_threshold:
                        action = Action.D
                if random.random() < self.mixing_probability:
                    action = Action.C if action == Action.D else Action.D
        return action

class Strategy_EXPLOITATIVE_188(BaseStrategy):
    """
    Adaptive Exploitation with Hysteresis strategy for Common Pool Resource Game.
    Cooperates initially, defects when stock is high, switches based on previous actions
    when stock is moderate, and always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        stock_percent = current_stock / capacity
        if stock_percent >= 0.75:
            return Action.D
        elif stock_percent <= 0.5:
            return Action.C
        else:
            previous_round = state.round_number - 1
            my_previous_action = history.my_actions[previous_round]
            return Action.C if my_previous_action else Action.D

class Strategy_EXPLOITATIVE_189(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and defection.
    It considers current stock, remaining rounds, and opponents' historical actions to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number + 1
        if t == self.n_rounds:
            return Action.D
        stock = state.current_stock
        stock_threshold = self.capacity / self.n_players
        if stock < stock_threshold:
            return Action.D
        if history is None:
            defection_rate = 0.5
        else:
            total_defections = 0
            num_opponents = self.n_players - 1
            num_rounds = state.round_number
            for prev_round in range(num_rounds):
                opponent_actions = history.opponent_actions[prev_round, :]
                count = np.count_nonzero(~opponent_actions)
                total_defections += count
            total_possible = num_rounds * num_opponents
            if total_possible == 0:
                defection_rate = 0.5
            else:
                defection_rate = total_defections / total_possible
        remaining_rounds = self.n_rounds - t + 1
        if remaining_rounds <= self.n_rounds // 2 or defection_rate > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_190(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation to sustain the resource and 
    strategic defection to maximize payoffs when necessary. It follows a mix of cooperative and defecting 
    actions based on the game's state and opponents' previous actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C
        if state.round_number == n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * capacity:
            return Action.C
        opponent_actions = history.opponent_actions
        n_previous_rounds = opponent_actions.shape[0]
        n_opponent_players = opponent_actions.shape[1]
        total_defections = 0
        for r in range(n_previous_rounds):
            round_actions = opponent_actions[r, :]
            n_ds = len(round_actions) - np.sum(round_actions)
            total_defections += n_ds
        total_possible = n_previous_rounds * n_opponent_players
        if total_possible == 0:
            return Action.C
        defec_ratio = total_defections / total_possible
        if defec_ratio > 0.3:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_191(BaseStrategy):
    """
    Adaptive Exploitation Strategy for the Common Pool Resource Game.
    Cooperates initially, defects in the last round, and adapts based on stock level and opponents' past actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.k = 3

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < 0.5 * self.capacity:
            return Action.C
        else:
            start = max(0, state.round_number - self.k)
            considered_rounds = state.round_number - start
            opponent_actions_slice = history.opponent_actions[start:state.round_number, :]
            sum_ds = np.count_nonzero(~opponent_actions_slice)
            total_possible = (self.n_players - 1) * considered_rounds
            average_defection = sum_ds / total_possible
            if average_defection > 0.5:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_192(BaseStrategy):
    """
    A strategy that determines actions based on a dynamic threshold.
    Cooperates when the stock level is above the threshold, defects otherwise,
    and always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        t = state.round_number + 1
        remaining_rounds = self.n_rounds - t
        threshold = self.capacity * (remaining_rounds / self.n_rounds)
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_193(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Common Pool Resource Game.

    This strategy dynamically adapts to the evolving game state and opponents' behaviors,
    balancing immediate gains with long-term sustainability through informed decision-making.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < 0.3 * self.capacity:
            return Action.C
        opponent_actions_prev = history.opponent_actions[-1, :]
        D_opponents = sum(~opponent_actions_prev)
        my_prev_action = history.my_actions[-1]
        D_count = D_opponents + (0 if my_prev_action else 1)
        n = self.n_players
        if D_count / n > 0.5 and current_stock < 0.3 * self.capacity:
            return Action.C
        elif D_count / n < 0.3 and current_stock > 0.7 * self.capacity:
            return Action.D
        elif D_count > n / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_194(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_stock < 0.25 * capacity:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round]
        k_c = sum(opp_prev_actions) + (1 if my_prev_action else 0)
        n_players = self.game_description.n_players
        if k_c / n_players > 0.5 and current_stock > 0.75 * capacity:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_195(BaseStrategy):
    """
    A strategy that adapts based on the game's history and current stock level, 
    balancing cooperation with self-interest to avoid exploitation while maintaining sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        capacity = self.capacity
        current_stock = state.current_stock
        stock_low = current_stock < 0.2 * capacity
        if history is None:
            return Action.C
        prev_actions = history.opponent_actions[-1]
        sum_coop = np.sum(prev_actions)
        defectors_prev = self.n_players - sum_coop
        half = self.n_players / 2
        if defectors_prev > half:
            action = Action.D
        else:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_196(BaseStrategy):
    """
    This strategy Cooperates if all other players Cooperated in the previous round;
    otherwise, it Defects to prevent being exploited.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            opponent_actions = history.opponent_actions[-1, :]
            n_coop = np.sum(opponent_actions)
            if n_coop == self.n_players - 1:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_197(BaseStrategy):
    """
    Adaptive Reciprocity Strategy with Stock Preservation.
    Cooperates initially, defects if stock is critically low, and reciprocates based on recent opponent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        threshold = 0.25 * capacity if capacity > 0 else 0
        current_stock = state.current_stock
        round_number = state.round_number
        if current_stock < threshold:
            if round_number == r - 1:
                return Action.D
            else:
                return Action.D
        window = 3
        start_round = max(0, round_number - window + 1)
        recent_opponent_actions = history.opponent_actions[start_round:round_number + 1]
        sum_D = 0
        for round_data in recent_opponent_actions:
            sum_D += np.sum(~round_data)
        total_actions = recent_opponent_actions.shape[0] * (n - 1)
        cooperation_rate = 1.0 - sum_D / total_actions if total_actions != 0 else 1.0
        if cooperation_rate > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_198(BaseStrategy):
    """
    Adaptive strategy for Common Pool Resource Game. Cooperates initially, 
    defects when stock is high, and always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.current_stock > 0.8 * self.capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_199(BaseStrategy):
    """
    Exploitative Strategy for the Common Pool Resource Game. 
    Cooperates initially, then adapts based on previous cooperation rates and stock levels, 
    defecting in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        sum_C = sum(opponent_prev_actions) + (1 if my_prev_action else 0)
        cooperation_rate = sum_C / self.n_players
        if cooperation_rate > 0.5 and state.current_stock >= 0.3 * self.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_200(BaseStrategy):
    """
    Implements an exploitative strategy for the Common Pool Resource Game.
    The strategy adapts based on opponents' actions, stock levels, and trends,
    balancing exploitation with sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_history = []
        self.next_alternate = True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < 0.25 * self.capacity:
            return Action.D
        self.stock_history.append(current_stock)
        defectors_prev = sum((not action for action in history.opponent_actions[-1]))
        if defectors_prev > self.n_players // 2:
            return Action.D
        pct = current_stock / self.capacity * 100
        if pct > 75:
            return Action.C
        elif 50 <= pct <= 75:
            action = Action.C if self.next_alternate else Action.D
            self.next_alternate = not self.next_alternate
            return action
        elif pct < 50:
            if len(self.stock_history) >= 2:
                prev_stock = self.stock_history[-2]
                current = self.stock_history[-1]
                if current > prev_stock:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_201(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource game that balances cooperation 
    and strategic defection to maintain stock sustainability while maximizing payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.threshold = self.capacity * 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        n_opp = self.game_description.n_players - 1
        opp_prev_actions = history.opponent_actions[prev_round, :]
        sum_opp_coop = np.sum(opp_prev_actions)
        n_opp_defections = n_opp - sum_opp_coop
        my_defection = 0 if my_prev_action else 1
        sum_defectors_prev = my_defection + n_opp_defections
        n_players = self.game_description.n_players
        stock = state.current_stock
        if sum_defectors_prev > n_players / 2 or stock < self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_202(BaseStrategy):
    """
    Adaptive Exploitative Approach (AEA) strategy for the Common Pool Resource Game.
    It balances cooperation and defection dynamically to maximize individual payoffs while promoting sustainable resource use.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if self.punishment_remaining > 0:
            action = Action.D
            self.punishment_remaining -= 1
        elif state.current_stock < self.game_description.capacity / 2:
            action = Action.D
        else:
            k = 3
            start_round = max(0, state.round_number - k)
            opponent_actions_slice = history.opponent_actions[start_round:state.round_number, :]
            total_coop = np.sum(opponent_actions_slice)
            total_possible = opponent_actions_slice.size
            avg_coop = total_coop / total_possible
            if avg_coop > 0.5:
                action = Action.C
            else:
                action = Action.D
                self.punishment_remaining = 3
        return action

class Strategy_EXPLOITATIVE_203(BaseStrategy):
    """
    A strategy that starts by cooperating and adapts based on the stock level.
    Cooperates if stock is above two-thirds of capacity, otherwise defects.
    Defects in the last round and when stock is zero.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock == 0:
            return Action.D
        threshold = 2.0 / 3.0 * self.capacity
        if state.current_stock >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_204(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances exploitation and conservation.
    It cooperates initially, defects in the last round, and adapts based on stock level and previous actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        if current_round == n_rounds - 1:
            return Action.D
        if history is None:
            return Action.C
        if current_round <= 1:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock < capacity / 2.0:
            return Action.C
        prev_round_idx = current_round - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_actions_prev = history.opponent_actions[prev_round_idx]
        self_defect = 0 if my_prev_action else 1
        opponent_defects = np.sum(~opponent_actions_prev)
        total_defects = self_defect + opponent_defects
        n_players = self.game_description.n_players
        if total_defects > n_players / 2.0:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_205(BaseStrategy):
    """
    Adaptive Exploitation strategy for the Common Pool Resource Game.
    Cooperates initially, then adapts based on stock dynamics, defects if stock is low or decreasing, 
    and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_stock = state.current_stock
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            self.previous_stock = state.current_stock
            return Action.D
        elif state.current_stock < 0.25 * self.capacity:
            self.previous_stock = state.current_stock
            return Action.D
        elif state.current_stock >= self.previous_stock:
            self.previous_stock = state.current_stock
            return Action.C
        else:
            self.previous_stock = state.current_stock
            return Action.D

class Strategy_EXPLOITATIVE_206(BaseStrategy):
    """
    Strategy for the Common Pool Resource game that starts with cooperation, 
    defects when stock is low, and adapts based on stock trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = [game_description.capacity]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            self.stock_history.append(current_stock)
            if current_stock > 0.75 * capacity:
                return Action.C
            elif current_stock < 0.5 * capacity:
                return Action.D
            else:
                if history.my_actions.size == 0:
                    return Action.C
                last_action = history.my_actions[-1]
                if last_action and len(self.stock_history) >= 2:
                    s_prev = self.stock_history[-2]
                    s_current = self.stock_history[-1]
                    if s_current < s_prev:
                        return Action.D
                return Action.C

class Strategy_EXPLOITATIVE_207(BaseStrategy):
    """
    Adaptive Exploitation Based on Stock Trends Strategy.

    This strategy starts with cooperation to gauge others' behavior, then adapts based on stock trends.
    It defects if the stock level is below a threshold, shows a downward trend, or is critically low.
    It always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        capacity = self.game_description.capacity
        if current_round == 0:
            return Action.C
        self.stock_history.append(state.current_stock)
        if current_round == self.game_description.n_rounds - 1:
            return Action.D
        prev_stock = self.stock_history[-1]
        if prev_stock < 0.2 * capacity:
            return Action.D
        threshold = 0.5 * capacity
        if prev_stock < threshold:
            return Action.D
        k = 2
        if len(self.stock_history) >= k:
            recent_stocks = self.stock_history[-k:]
            is_trend_downward = True
            for i in range(1, len(recent_stocks)):
                if recent_stocks[i] >= recent_stocks[i - 1]:
                    is_trend_downward = False
                    break
            if is_trend_downward:
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_208(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource game that balances cooperation and defection.
    Cooperates initially, defects in the last round, and adapts based on stock levels and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_round = state.round_number - 1
        my_actions_prev = history.my_actions[previous_round]
        opponents_actions_prev = history.opponent_actions[previous_round]
        my_defect_prev = not my_actions_prev
        opponent_defect_count = np.sum(opponents_actions_prev == False)
        total_defectors_prev = (1 if my_defect_prev else 0) + opponent_defect_count
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_stock <= 0.1 * capacity:
            return Action.D
        elif total_defectors_prev > n_players / 2 or current_stock < 2 / 3 * capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_209(BaseStrategy):
    """
    Adaptive Exploitation strategy for the Common Pool Resource game.
    Cooperates initially, defects in the last round, and adapts based on stock level and recent defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            n = self.game_description.n_players
            capacity = self.game_description.capacity
            if history is not None:
                start = max(0, state.round_number - 3)
                sum_defectors = 0
                for round in range(start, state.round_number):
                    my_action = history.my_actions[round]
                    my_defect = 0 if my_action else 1
                    opponent_actions = history.opponent_actions[round]
                    op_defect = np.count_nonzero(opponent_actions == False)
                    sum_defectors += my_defect + op_defect
                k = state.round_number - start
                if k == 0:
                    recent_defect_rate = 0.0
                else:
                    recent_defect_rate = sum_defectors / (k * n)
                if state.current_stock < 0.2 * capacity:
                    return Action.C
                elif recent_defect_rate > 0.5:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C

class Strategy_EXPLOITATIVE_210(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.2 * game_description.capacity
        self.forgiveness_prob = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        is_last_round = state.round_number == self.game_description.n_rounds - 1
        if is_last_round:
            if state.current_stock < self.stock_threshold:
                action = Action.D
            else:
                action = Action.C
        else:
            previous_defections = sum(~history.opponent_actions[state.round_number - 1])
            defection_ratio = previous_defections / self.game_description.n_players
            if defection_ratio >= 0.5 or state.current_stock < self.stock_threshold:
                action = Action.D
            else:
                action = Action.C
            if random.random() < self.forgiveness_prob:
                action = Action.D if action == Action.C else Action.C
        return action

class Strategy_EXPLOITATIVE_211(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and defection
    based on opponents' behavior and the current stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        stock_threshold = 0.5 * self.game_description.capacity
        if state.current_stock < stock_threshold:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round]
        prev_defectors = 0
        if not my_prev_action:
            prev_defectors += 1
        prev_defectors += sum((1 for action in opponent_prev_actions if not action))
        n_players = self.game_description.n_players
        if prev_defectors > n_players / 2:
            return Action.D
        sum_coop = 0
        min_round = max(0, prev_round - 2)
        for r in range(min_round, prev_round + 1):
            my_action = history.my_actions[r]
            opp_actions = history.opponent_actions[r]
            coop_count = 0
            if my_action:
                coop_count += 1
            coop_count += sum(opp_actions)
            sum_coop += coop_count
        if sum_coop >= 0.7 * n_players and state.current_stock > stock_threshold:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_212(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection based on historical actions and stock levels.
    Cooperates initially, reciprocates based on others' actions, and conserves when the stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        critical_threshold = 0.2 * self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if state.round_number == n_rounds - 1:
            if state.current_stock < critical_threshold:
                return Action.C
            else:
                return Action.D
        elif state.current_stock < critical_threshold:
            return Action.C
        else:
            opponent_actions_last = history.opponent_actions[-1, :]
            cooperators = np.sum(opponent_actions_last)
            if cooperators > n_players / 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_213(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that balances cooperation and defection.
    It cooperates initially, defects in the last round, and adjusts based on stock levels and others' actions.
    The strategy switches to defection if the stock is critically low, shows a decreasing trend, or if others defect frequently.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        elif current_round == self.r - 1:
            return Action.D
        stock_levels = [self.capacity]
        if history is not None:
            my_actions = history.my_actions
            my_payoffs = history.my_payoffs
            for t in range(len(my_actions)):
                action = my_actions[t]
                payoff = my_payoffs[t]
                if action:
                    s = payoff * 2 * self.n
                else:
                    s = payoff * self.n
                stock_levels.append(s)
            stock_levels.append(state.current_stock)
        if state.current_stock < 0.3 * self.capacity:
            return Action.D
        if len(stock_levels) >= 2 and stock_levels[-1] < stock_levels[-2]:
            return Action.D
        if history is not None:
            opponent_actions = history.opponent_actions
            if opponent_actions.size == 0:
                avg_coop = 0.0
            else:
                total_coop = np.sum(opponent_actions)
                total_players_rounds = opponent_actions.shape[0] * opponent_actions.shape[1]
                if total_players_rounds == 0:
                    avg_coop = 0.0
                else:
                    avg_coop = total_coop / total_players_rounds
            if avg_coop >= 0.7:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_214(BaseStrategy):
    """
    Adaptive Cooperation with Stock Protection Strategy for the Common Pool Resource Game.
    Cooperates initially, then adapts based on previous cooperation rates and stock levels,
    and defects in the last round to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = int(history.my_actions[prev_round])
            opponents_prev_actions = history.opponent_actions[prev_round, :]
            total_coop = my_prev_action + np.sum(opponents_prev_actions)
            avg_coop = total_coop / self.game_description.n_players
            half_capacity = self.game_description.capacity / 2
            current_stock = state.current_stock
            if avg_coop >= 0.7 and current_stock > half_capacity:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_215(BaseStrategy):
    """
    Adaptive Exploitation Strategy:
    - Cooperate in the first round.
    - Defect if the stock is above half capacity, otherwise Cooperate in intermediate rounds.
    - Always Defect in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            threshold = 0.5 * self.capacity
            if state.current_stock > threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_216(BaseStrategy):
    """
    Adaptive strategy that cooperates initially and defects if excess consumption is detected.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        t_prev = state.round_number - 1
        my_action_prev = history.my_actions[t_prev]
        my_payoff_prev = history.my_payoffs[t_prev]
        n_players = self.game_description.n_players
        if my_action_prev:
            S_prev = 2 * n_players * my_payoff_prev
        else:
            S_prev = n_players * my_payoff_prev
        expected_consumption = S_prev / 2
        actual_consumption = my_payoff_prev + history.opponent_payoffs[t_prev, :].sum()
        if actual_consumption - expected_consumption > 1e-08:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_217(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels and opponent behavior.
    Cooperates initially, defects in the final round, and adapts based on the stock and historical actions of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            threshold = 0.5 * self.game_description.capacity
            if state.current_stock < threshold:
                return Action.C
            else:
                t = state.round_number
                total_defectors = 0.0
                for r in range(t):
                    defectors = np.sum(~history.opponent_actions[r, :])
                    total_defectors += defectors
                avg_defectors = total_defectors / t
                if avg_defectors > 0.5:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_218(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and exploitation.
    Cooperates initially, defects if the stock decreases, and temporarily cooperates if the stock is low.
    Defects in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_stock = None
        self.recovery_mode = False
        self.coop_rounds_left = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
            self.prev_stock = state.current_stock
        elif state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        else:
            capacity = self.game_description.capacity
            threshold = 0.5 * capacity
            current_stock = state.current_stock
            if current_stock < threshold and (not self.recovery_mode):
                self.recovery_mode = True
                self.coop_rounds_left = 2
                action = Action.C
            elif self.recovery_mode:
                if self.coop_rounds_left > 0:
                    action = Action.C
                    self.coop_rounds_left -= 1
                else:
                    self.recovery_mode = False
                    if current_stock >= self.prev_stock:
                        action = Action.C
                    else:
                        action = Action.D
            elif current_stock >= self.prev_stock:
                action = Action.C
            else:
                action = Action.D
            self.prev_stock = current_stock
        return action

class Strategy_EXPLOITATIVE_219(BaseStrategy):
    """
    A strategy that balances cooperation with strategic defection based on stock levels and opponent actions.
    Cooperates initially and in high stock conditions, defects when stock is low or many defected previously,
    and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        stock_percent = current_stock / capacity
        if stock_percent > 0.75:
            return Action.C
        elif stock_percent < 0.5:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev = history.my_actions[prev_round]
            others_coop = history.opponent_actions[prev_round, :].sum()
            total_coops = others_coop + (1 if my_prev else 0)
            n_players = self.game_description.n_players
            threshold = n_players // 2 + 1
            if total_coops >= threshold:
                return Action.C
            return Action.D

class Strategy_EXPLOITATIVE_220(BaseStrategy):
    """
    Adaptive Exploitation Strategy for the Common Pool Resource Game.
    Cooperates initially, then adapts based on stock level and previous round's defections.
    Defects in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round]
        defectors = 0
        if not my_prev_action:
            defectors += 1
        defectors += sum((1 for action in opponents_prev_actions if not action))
        half = self.n_players / 2
        if defectors > half:
            return Action.D
        current_stock = state.current_stock
        two_thirds = 2.0 / 3.0 * self.capacity
        one_third = 1.0 / 3.0 * self.capacity
        if current_stock > two_thirds:
            return Action.D
        elif current_stock < one_third:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_221(BaseStrategy):
    """
    Strategy that defects when the stock exceeds 50% of capacity and cooperates otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        threshold = self.capacity / 2
        current_stock = state.current_stock
        if current_stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_222(BaseStrategy):
    """
    Adaptive Cooperation with Endgame Defection strategy.

    This strategy starts by cooperating in the initial rounds, switches to defection 
    if the stock level drops below 50% of capacity in the middle rounds, and defects 
    consistently in the endgame (last 30% of rounds).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if round_num < 3:
            return Action.C
        endgame_start = n_rounds * 0.7
        if round_num >= endgame_start:
            return Action.D
        if state.current_stock < 0.5 * capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_223(BaseStrategy):
    """
    This strategy begins by Cooperating in the first round, defects in the last round, 
    and adapts based on the current stock level and the historical behavior of other players.
    Cooperates if the stock is below 50% capacity, otherwise defects if more than half of 
    other players have defected on average in previous rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock < 0.5 * capacity:
            return Action.C
        n_prev_rounds = state.round_number
        n_opponents = self.game_description.n_players - 1
        total_defects = 0
        for t in range(n_prev_rounds):
            opponent_actions_t = history.opponent_actions[t]
            defects_t = sum((not action for action in opponent_actions_t))
            total_defects += defects_t
        total_possible = n_prev_rounds * n_opponents
        avg_defect = total_defects / total_possible if total_possible != 0 else 0
        if avg_defect > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_224(BaseStrategy):
    """
    This strategy starts by Cooperating in the first round. In the final round, it Defects.
    Otherwise, it Defects if the stock is below 25% of capacity.
    If the stock is sufficient, it examines the previous round's actions: if more than 50% of players Defected, it Defects; otherwise Cooperates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            threshold = 0.25 * capacity
            if current_stock < threshold:
                return Action.D
            else:
                prev_round = state.round_number - 1
                my_prev_action = history.my_actions[prev_round]
                my_d = 0 if my_prev_action else 1
                opponents_prev = history.opponent_actions[prev_round]
                opponents_d = np.sum(~opponents_prev)
                total_d = my_d + opponents_d
                n_players = self.game_description.n_players
                if total_d / n_players > 0.5:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_225(BaseStrategy):
    """
    Exploitative Strategy for the Common Pool Resource Game.

    This strategy starts with cooperation in the first round and defects in the last round.
    In subsequent rounds, it cooperates if the stock is above 75% of capacity, defects if below 25%,
    and uses trend analysis in between these thresholds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.past_stocks = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.past_stocks.append(state.current_stock)
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        self.past_stocks.append(current_stock)
        if len(self.past_stocks) > 3:
            self.past_stocks = self.past_stocks[-3:]
        threshold_high = 0.75 * capacity
        threshold_low = 0.25 * capacity
        if current_stock > threshold_high:
            return Action.C
        elif current_stock < threshold_low:
            return Action.D
        else:
            if len(self.past_stocks) > 1:
                past_stocks = self.past_stocks[:-1]
                if len(past_stocks) > 3:
                    past_stocks = past_stocks[-3:]
                if len(past_stocks) == 0:
                    average_past = current_stock
                else:
                    average_past = np.mean(past_stocks)
            else:
                average_past = current_stock
            if current_stock > average_past:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_226(BaseStrategy):
    """
    Exploitative Strategy for the Common Pool Resource Game.

    This strategy adapts based on the stock level and opponents' defection rates.
    It defects in the last round, cooperates when stock is low, defects when stock is high,
    and adapts based on opponents' behavior with a 50% threshold on their average defection rate.
    In the first round, it chooses randomly between Cooperate and Defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        critical_threshold = 0.3 * capacity
        high_threshold = 0.7 * capacity
        current_stock = state.current_stock
        if current_stock < critical_threshold:
            return Action.C
        elif current_stock >= high_threshold:
            return Action.D
        elif history is None:
            return random.choice([Action.C, Action.D])
        else:
            last_round_actions = history.opponent_actions[-1, :]
            n_opponents = len(last_round_actions)
            n_d = n_opponents - np.sum(last_round_actions)
            avg_defection = n_d / n_opponents
            if avg_defection > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_228(BaseStrategy):
    """
    Adaptive Exploitation with Stock Threshold Strategy.
    Cooperates initially, then defects if defection rate exceeds 30% or stock is below 50% of capacity.
    Defects in the last 10% of rounds regardless of other conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        r = self.game_description.n_rounds
        last_rounds_cutoff = int(r * 0.9)
        if state.round_number >= last_rounds_cutoff:
            return Action.D
        sum_d = np.sum(~history.opponent_actions[:state.round_number, :])
        t = state.round_number
        denominator = (self.game_description.n_players - 1) * t
        average_defection = sum_d / denominator if denominator != 0 else 0.0
        stock = state.current_stock
        capacity = self.game_description.capacity
        stock_threshold = 0.5 * capacity
        if average_defection > 0.3 or stock < stock_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_229(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game, balancing cooperation and defection based on resource stock levels.
    - Cooperates in the first round.
    - Cooperates in intermediate rounds if stock is above half capacity.
    - Defects in the last round to maximize immediate gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        game = self.game_description
        capacity = game.capacity
        n_rounds = game.n_rounds
        if state.round_number == 0:
            return Action.C
        elif state.round_number == n_rounds - 1:
            return Action.D
        else:
            threshold = 0.5 * capacity
            if state.current_stock >= threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_230(BaseStrategy):
    """
    A strategy that initially cooperates, then adapts based on the stock level and average defection rate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock < capacity / 2:
            return Action.C
        n_players = self.game_description.n_players
        t = state.round_number
        total_defections = 0
        for r in range(t):
            my_action = history.my_actions[r]
            my_defected = 0 if my_action else 1
            opponents = history.opponent_actions[r]
            opponents_defected = 0
            for opponent in opponents:
                if not opponent:
                    opponents_defected += 1
            total_defections += my_defected + opponents_defected
        avg_defection = total_defections / (n_players * t)
        if avg_defection > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_231(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.prev_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
            self.prev_stock = state.current_stock
        else:
            current_stock = state.current_stock
            prev_stock = self.prev_stock
            if prev_stock == 0:
                if current_stock == 0:
                    stock_change = 0.0
                else:
                    stock_change = 100.0
            else:
                stock_change = (current_stock - prev_stock) / prev_stock * 100.0
            last_round = state.round_number == self.n_rounds - 1
            below_threshold = current_stock < 0.2 * self.capacity
            if last_round or below_threshold:
                action = Action.D
            elif stock_change < -10.0:
                action = Action.D
            else:
                action = Action.C
            self.prev_stock = current_stock
        return action

class Strategy_EXPLOITATIVE_232(BaseStrategy):
    """
    A strategy that initially cooperates and then responds to changes in the common pool stock level.
    Cooperates if the stock remains stable or increases, and defects if the stock decreases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.prev_stock = state.current_stock
            return Action.C
        current_stock = state.current_stock
        if current_stock < self.prev_stock:
            action = Action.D
        else:
            action = Action.C
        self.prev_stock = current_stock
        return action

class Strategy_EXPLOITATIVE_233(BaseStrategy):
    """
    This strategy for the Common Pool Resource Game balances cooperation and defection based on stock levels and opponents' actions.
    It cooperates in the first round, defects in the last round, and adapts based on stock and previous defections in intermediate rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            opp_actions_last_round = history.opponent_actions[-1]
            my_previous_action = history.my_actions[state.round_number - 1]
            my_defection = 0 if my_previous_action else 1
            defectors = sum(1 - opp_actions_last_round) + my_defection
            threshold = 0.75 * self.game_description.capacity
            if state.current_stock > threshold and defectors < self.game_description.n_players / 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_235(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and defection based on opponents' behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_stock < 0.2 * capacity:
            return Action.C
        if state.round_number >= total_rounds - 2:
            if current_stock < 0.2 * capacity:
                return Action.C
            else:
                return Action.D
        opponent_actions = history.opponent_actions[:state.round_number]
        total_opponent_actions = state.round_number * (n_players - 1)
        if total_opponent_actions == 0:
            cooperation_rate = 0.0
        else:
            cooperation_rate = np.sum(opponent_actions) / total_opponent_actions
        if cooperation_rate < 0.3 and current_stock < 0.4 * capacity:
            return Action.D
        if cooperation_rate > 0.75:
            if random.random() < 0.2:
                return Action.D
            else:
                return Action.C
        elif 0.5 <= cooperation_rate <= 0.75:
            if current_stock > 0.7 * capacity:
                return Action.D
            else:
                return Action.C
        elif random.random() < 0.8:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_236(BaseStrategy):
    """
    Adaptive Cooperation with Punishment (ACP) strategy for the Common Pool Resource Game.
    It encourages cooperation but punishes defectors while considering stock levels and endgame rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishing = False
        self.punishment_remaining = 0
        self.cooperation_threshold = 0.7
        self.punishment_duration = 3
        self.cooperation_history_length = 5
        self.critical_stock_threshold = 0.3
        self.endgame_rounds = 3
        self.endgame_threshold = max(0, game_description.n_rounds - self.endgame_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.endgame_threshold:
            return Action.D
        if state.current_stock < self.critical_stock_threshold * self.game_description.capacity:
            return Action.C
        if self.punishing:
            self.punishment_remaining -= 1
            if self.punishment_remaining <= 0:
                self.punishing = False
            return Action.D
        k = self.cooperation_history_length
        t = state.round_number
        start_round = max(0, t - k)
        cooperation_sum = 0.0
        for i in range(start_round, t):
            if i >= len(history.my_actions):
                continue
            my_action = history.my_actions[i]
            opponents = history.opponent_actions[i]
            total = my_action + np.sum(opponents)
            rate = total / self.game_description.n_players
            cooperation_sum += rate
        num_rounds = t - start_round
        if num_rounds == 0:
            avg_coop = 1.0
        else:
            avg_coop = cooperation_sum / num_rounds
        if avg_coop < self.cooperation_threshold:
            self.punishing = True
            self.punishment_remaining = self.punishment_duration
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_237(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels.
    Cooperates in the first round, defects when stock is high in middle rounds, and maximizes gain in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity * 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock > self.threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_238(BaseStrategy):
    """
    A strategy that starts with cooperation and adapts based on others' actions and the current stock level.
    Cooperates initially, then defects if more than half of players defected last round. Otherwise, cooperates if stock is low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_actions = history.opponent_actions[-1, :]
        defector_count = sum((1 for action in prev_actions if not action))
        threshold = self.game_description.n_players / 2
        if defector_count > threshold:
            return Action.D
        else:
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            return Action.C

class Strategy_EXPLOITATIVE_239(BaseStrategy):
    """
    Adaptive strategy balancing cooperation and defection to maximize personal payoff while maintaining resource sustainability.
    Cooperates initially, defects if others exploit, and recovers cooperation when the stock rebounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.is_defecting = False
        self.defecting_stock = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if history is None or history.my_payoffs.size <= state.round_number - 1:
            prev_total = 0.0
        else:
            previous_round = state.round_number - 1
            my_prev = history.my_payoffs[previous_round]
            opponent_prev = history.opponent_payoffs[previous_round, :]
            prev_total = my_prev + opponent_prev.sum()
        threshold = self.capacity / 2.0
        if prev_total >= threshold:
            self.is_defecting = True
            self.defecting_stock = state.current_stock
            return Action.D
        if state.current_stock < self.capacity * 0.25:
            return Action.C
        if self.is_defecting:
            if state.current_stock > self.defecting_stock:
                self.is_defecting = False
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_240(BaseStrategy):
    """
    An adaptive strategy that initially cooperates and switches to defecting 
    if the common pool stock depletes significantly for two consecutive rounds.
    Always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.defect_rest = False
        self.consecutive_decreases = 0
        self.threshold_decrease = -0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        if history is None and t == 0:
            self.stock_history.append(state.current_stock)
        elif t > 0:
            if len(self.stock_history) <= t:
                self.stock_history.append(state.current_stock)
        if t == 0:
            return Action.C
        elif t == self.game_description.n_rounds - 1:
            return Action.D
        else:
            if len(self.stock_history) < t + 1:
                action = Action.C
            else:
                current_stock = self.stock_history[t]
                prev_stock = self.stock_history[t - 1]
                if prev_stock == 0:
                    delta = 0.0
                else:
                    delta = (current_stock - prev_stock) / prev_stock
                if delta < self.threshold_decrease:
                    self.consecutive_decreases += 1
                else:
                    self.consecutive_decreases = 0
                if self.consecutive_decreases >= 2:
                    self.defect_rest = True
                if self.defect_rest:
                    action = Action.D
                else:
                    action = Action.C
            return action

class Strategy_EXPLOITATIVE_241(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels.
    Cooperates in the first round, defects in the last round, and uses a stock threshold to decide in between.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            half_capacity = 0.5 * self.game_description.capacity
            if state.current_stock > half_capacity:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_242(BaseStrategy):
    """
    A strategy that adapts based on the stock level relative to capacity. 
    Cooperates initially, defects if stock falls below 50% of capacity, and always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.round_number == 0:
            return Action.C
        else:
            half_capacity = 0.5 * self.capacity
            if state.current_stock < half_capacity:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_244(BaseStrategy):
    """
    Adaptive Exploitation Strategy for the Common Pool Resource Game.
    Balances cooperation with strategic exploitation based on observed behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.initial_coop_rounds = 3
        self.endgame_rounds = 5
        self.defect_threshold = 0.3
        self.stock_critical = 0.2
        self.punishment_length = 2
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number < self.initial_coop_rounds:
            return Action.C
        if state.round_number >= self.n_rounds - self.endgame_rounds:
            return Action.D
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        if state.current_stock < self.capacity * self.stock_critical:
            return Action.C
        if history is None or len(history.my_actions) == 0:
            return Action.C
        avg_defection = self._calculate_avg_defection(history)
        if avg_defection > self.defect_threshold:
            self.punishment_remaining = self.punishment_length
            return Action.D
        return Action.C

    def _calculate_avg_defection(self, history: PlayerHistory) -> float:
        len_history = len(history.my_actions)
        if len_history == 0:
            return 0.0
        start_round = max(0, len_history - 5)
        total_defectors = 0.0
        for r in range(start_round, len_history):
            n_coop = sum(history.opponent_actions[r, :])
            if history.my_actions[r]:
                n_coop += 1
            n_defectors = self.n_players - n_coop
            defect_rate = n_defectors / self.n_players
            total_defectors += defect_rate
        avg_defection = total_defectors / (len_history - start_round)
        return avg_defection

class Strategy_EXPLOITATIVE_245(BaseStrategy):
    """
    Implements the Adaptive Reciprocal Conservation (ARC) strategy:
    - Cooperates in the first round.
    - Defects in the last round.
    - Switches to defecting if either the number of defectors exceeds 30% of players 
      or the stock level drops below 20% of capacity.
    - Cooperates if the stock level is critically low (below 10% of capacity).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock < 0.1 * capacity:
            return Action.C
        my_last_action = history.my_actions[-1]
        my_defected = 0 if my_last_action else 1
        opponent_last_actions = history.opponent_actions[-1, :]
        opponent_defected = sum((1 for action in opponent_last_actions if not action))
        d_count = my_defected + opponent_defected
        threshold_defection = 0.3 * self.game_description.n_players
        stock_ratio = current_stock / capacity
        conservation_threshold = 0.2
        if d_count > threshold_defection or stock_ratio < conservation_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_246(BaseStrategy):
    """
    Adaptive Exploitation Based on Stock Level Strategy: Cooperates in the first round,
    defects in the last round, and adapts based on the stock level relative to capacity.
    Defects if stock is above 66% of capacity, otherwise cooperates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        threshold = 0.66 * capacity
        if state.current_stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_247(BaseStrategy):
    """
    Adaptive Exploitation Strategy for the Common Pool Resource Game.
    Cooperates initially, defects in the last round, and adapts based on stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            if current_stock < 0.2 * capacity:
                return Action.D
            elif current_stock > 0.5 * capacity:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_248(BaseStrategy):
    """
    A threshold-based strategy for the Common Pool Resource Game, balancing cooperation and defection.
    Cooperates initially and when the stock is high, defects when stock is low or in the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_rounds = self.game_description.n_rounds
        rounds_remaining_after = total_rounds - 1 - state.round_number
        if rounds_remaining_after < 5:
            return Action.D
        else:
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            threshold = 0.5 * capacity
            if current_stock > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_249(BaseStrategy):
    """
    Heuristic-based strategy that reacts to stock level changes by defecting if the stock decreases by more than 10% from the previous round.
    Cooperates initially, defects in the final round, and adapts based on observed stock changes.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
            self.prev_stock = state.current_stock
        elif state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        else:
            current_stock = state.current_stock
            if self.prev_stock is None:
                action = Action.C
            else:
                if self.prev_stock == 0:
                    decrease = 0.0
                else:
                    decrease = (self.prev_stock - current_stock) / self.prev_stock
                if decrease > 0.1:
                    action = Action.D
                else:
                    action = Action.C
            self.prev_stock = current_stock
        return action

class Strategy_EXPLOITATIVE_250(BaseStrategy):
    """
    Adaptive Exploitation Strategy for the Common Pool Resource Game.
    
    This strategy begins by Cooperating to sustain the resource but dynamically shifts to Defecting
    when significant defection is detected, stock levels are critically low, or in the final rounds.
    It estimates cooperation based on opponents' actions and adjusts decisions to balance exploitation
    with sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = [game_description.capacity]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        if state.current_stock <= 0.2 * capacity:
            return Action.D
        if state.round_number >= total_rounds - 2:
            return Action.D
        my_prev_action = history.my_actions[state.round_number - 1]
        opponent_prev_actions = history.opponent_actions[state.round_number - 1, :]
        C_count = sum(opponent_prev_actions) + (1 if my_prev_action else 0)
        estimated_cooperation = C_count / n_players
        if estimated_cooperation > 0.7:
            return Action.C
        else:
            if len(self.stock_history) >= 2:
                prev_stock = self.stock_history[-2]
                current_stock = self.stock_history[-1]
                if current_stock < prev_stock:
                    return Action.D
            return Action.D

class Strategy_EXPLOITATIVE_251(BaseStrategy):
    """
    An adaptive strategy that balances cooperation and defection based on stock levels, remaining rounds, and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        t = state.round_number
        round_1based = t + 1
        n_rounds = self.game_description.n_rounds
        if round_1based == n_rounds:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        stock_ratio = current_stock / capacity
        remaining = n_rounds - round_1based
        remaining_ratio = remaining / n_rounds
        n_opponents = self.game_description.n_players - 1
        if history is None:
            return Action.D
        opponent_actions = history.opponent_actions
        n_available = opponent_actions.shape[0]
        k = 5
        start = max(0, n_available - k)
        recent = opponent_actions[start:n_available, :]
        total_defections = 0
        for r in recent:
            coop_sum = np.sum(r)
            defects = n_opponents - coop_sum
            total_defections += defects
        total_round_def = recent.shape[0] * n_opponents
        average_defection = total_defections / total_round_def if total_round_def != 0 else 0.0
        if stock_ratio > 0.7 and remaining_ratio > 0.5 and (average_defection < 0.3):
            return Action.C
        elif stock_ratio <= 0.7 or average_defection >= 0.3:
            return Action.D
        elif stock_ratio < 0.4:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_252(BaseStrategy):
    """
    A strategy that balances individual gain with resource preservation by cooperating
    when the resource is depleted or its stock is decreasing, and defecting otherwise,
    especially in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        if state.round_number == 0 and history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        recent_stocks = self.stock_history[-2:]
        if len(recent_stocks) == 1:
            previous_stock = recent_stocks[0]
        else:
            avg_recent = sum(recent_stocks) / len(recent_stocks)
            if len(self.stock_history) >= 3:
                previous_stock = self.stock_history[-3]
            else:
                previous_stock = avg_recent
        current_trend = state.current_stock > previous_stock
        if not current_trend:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_253(BaseStrategy):
    """
    A strategy that balances maximizing immediate gain with maintaining a sustainable stock level.
    Always Cooperates in the first round, Defects in the last round. For other rounds, 
    Defects if the previous round's consumption exceeded half the initial stock; otherwise Cooperates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.last_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_stock = state.current_stock
            return Action.C
        else:
            is_last_round = state.round_number == self.r - 1
            if is_last_round:
                self.last_stock = state.current_stock
                return Action.D
            else:
                prev_round_index = state.round_number - 1
                my_prev_action = history.my_actions[prev_round_index]
                c_my = 1 if my_prev_action else 0
                opp_prev_actions = history.opponent_actions[prev_round_index]
                c_opp = sum(opp_prev_actions)
                c_total = c_my + c_opp
                start_stock_prev = self.last_stock
                if start_stock_prev == 0:
                    consumption = 0.0
                else:
                    consumption = c_total * (start_stock_prev / (2 * self.n)) + (self.n - c_total) * (start_stock_prev / self.n)
                threshold = 0.5 * start_stock_prev
                if consumption > threshold:
                    action = Action.D
                else:
                    action = Action.C
                self.last_stock = state.current_stock
                return action

class Strategy_EXPLOITATIVE_254(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that balances cooperation and defection.
    Cooperates initially, defects if others exploit or stock is low, and always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            me_last = history.my_actions[state.round_number - 1]
            opponents_last = history.opponent_actions[state.round_number - 1]
            i_defected = 0 if me_last else 1
            opponents_defected = sum(1 - opponents_last)
            total_defectors = i_defected + opponents_defected
            threshold = self.game_description.n_players / 2
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            half_capacity = 0.5 * capacity
            if total_defectors > threshold or current_stock < half_capacity:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_255(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation 
    and self-interest by monitoring stock levels and strategically choosing actions.
    Cooperates initially, defects if stock drops below 50% of capacity, and defects 
    in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.should_defect = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif self.should_defect:
            return Action.D
        else:
            threshold = 0.5 * self.game_description.capacity
            if state.current_stock < threshold:
                self.should_defect = True
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_256(BaseStrategy):
    """
    A strategy that adapts based on the stock level relative to capacity and handles the first and last rounds specially.
    Cooperates when the stock is at or below 50% of capacity and defects otherwise, except for defecting in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            threshold = 0.5 * self.capacity
            if state.current_stock > threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_257(BaseStrategy):
    """
    A threshold-based strategy to balance resource exploitation and preservation.
    Cooperates initially, then uses dynamic thresholds based on stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.upper_threshold = 0.8 * self.capacity
        self.lower_threshold = 0.6 * self.capacity
        self.previous_stock = None
        self.previous_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
            self.previous_stock = state.current_stock
            self.previous_action = action
            return action
        current_stock = state.current_stock
        prev_stock = self.previous_stock
        if current_stock > prev_stock:
            trend = 'increasing'
        elif current_stock < prev_stock:
            trend = 'decreasing'
        else:
            trend = 'steady'
        if self.previous_action == Action.C:
            if trend == 'decreasing':
                self.upper_threshold *= 0.95
            elif trend == 'increasing':
                self.lower_threshold *= 1.05
        if self.upper_threshold < self.lower_threshold:
            self.upper_threshold, self.lower_threshold = (self.lower_threshold, self.upper_threshold)
        if current_stock > self.upper_threshold:
            action = Action.D
        elif current_stock < self.lower_threshold:
            action = Action.C
        else:
            action = self.previous_action
        self.previous_stock = current_stock
        self.previous_action = action
        return action

class Strategy_EXPLOITATIVE_258(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and defection.
    It cooperates to sustain the resource but defects when necessary to protect against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        half_capacity = capacity / 2
        if current_stock < half_capacity:
            return Action.C
        else:
            my_prev_action = history.my_actions[-1]
            my_defect = 0 if my_prev_action else 1
            opponent_actions = history.opponent_actions[-1, :]
            opponent_defect = sum(opponent_actions == False)
            total_defectors = my_defect + opponent_defect
            n_players = self.game_description.n_players
            half_players = n_players // 2
            if total_defectors > half_players:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_259(BaseStrategy):
    """
    A strategy that balances cooperation and defection by considering stock levels, 
    previous players' actions, and the game's progression. It starts with cooperation,
    defects in the final round, conserves stock when low, and reciprocates based on 
    previous cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock <= 0.5 * self.game_description.capacity:
            return Action.C
        my_action = history.my_actions[state.round_number - 1]
        opponent_actions = history.opponent_actions[state.round_number - 1, :]
        num_cooperate = 1 if my_action else 0
        num_cooperate += sum(opponent_actions)
        total_players = self.game_description.n_players
        if num_cooperate / total_players >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_260(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection.
    It cooperates initially, defects in the endgame, cooperates when stock is low, 
    and reciprocates based on past actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        number_endgame_rounds = math.ceil(game_description.n_rounds * 0.1)
        self.endgame_cutoff = game_description.n_rounds - number_endgame_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        elif state.round_number >= self.endgame_cutoff:
            return Action.D
        elif state.current_stock < self.capacity / 2:
            return Action.C
        else:
            my_coop = history.my_actions.sum()
            opponent_coop = history.opponent_actions.sum()
            total_coop = my_coop + opponent_coop
            t = state.round_number
            total_actions = t * self.game_description.n_players
            proportion_c = total_coop / total_actions
            if proportion_c >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_261(BaseStrategy):
    """
    A strategy that adapts based on the current stock level, its trend, and opponents' actions.
    Cooperates to conserve resources when necessary and defects to exploit when possible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        current_stock = state.current_stock
        t = state.round_number
        if t == 0:
            self.stock_history.append(current_stock)
            return Action.C
        if t == self.r - 1:
            self.stock_history.append(current_stock)
            return Action.D
        is_decreasing = False
        if len(self.stock_history) >= 3:
            last_three = self.stock_history[-3:]
            avg_last_three = sum(last_three) / 3
            if current_stock < avg_last_three:
                is_decreasing = True
        threshold = 0.5 * self.capacity
        if current_stock < threshold or is_decreasing:
            action = Action.C
        else:
            action = Action.D
        self.stock_history.append(current_stock)
        return action

class Strategy_EXPLOITATIVE_262(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game. 
    It starts by cooperating, then adapts based on others' cooperation rate and stock health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        others_coop = np.mean(history.opponent_actions[:state.round_number])
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        health_ok = current_stock > 0.75 * capacity
        if others_coop >= 0.5 and health_ok:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_263(BaseStrategy):
    """
    Adaptive Cooperation with Stock Sustainability Strategy.

    This strategy begins by cooperating in the first round to establish trust. In subsequent rounds, it adapts based on the cooperation rate of other players and the stock level. It defects if cooperation falls below 50% or the stock drops below 80% of capacity. Otherwise, it mirrors the majority's previous action. In the final round, it cooperates if the stock is above 50% of capacity; otherwise, it defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > 0.5 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        prev_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round, :]
        my_prev_action = history.my_actions[prev_round]
        total_c = sum(opponent_actions_prev) + (1 if my_prev_action else 0)
        n_players = self.game_description.n_players
        coop_rate = total_c / n_players
        capacity = self.game_description.capacity
        if coop_rate < 0.5 or state.current_stock < 0.8 * capacity:
            return Action.D
        elif total_c > n_players / 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_264(BaseStrategy):
    """
    Adaptive Exploitation Based on Stock Level Strategy.
    
    This strategy cooperates initially, defects when the stock is above 70% of capacity, 
    cooperates when below, and defects in the final round to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            threshold = 0.7 * self.game_description.capacity
            if state.current_stock > threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_265(BaseStrategy):
    """
    A strategy that dynamically decides to Cooperate or Defect based on current stock levels
    and players' previous actions, with an endgame heuristic.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None or state.round_number == 0:
            return Action.C
        current_round = state.round_number
        current_stock = state.current_stock
        if current_stock <= 0:
            return Action.D
        if current_round >= self.n_rounds - 2:
            return Action.D
        previous_actions = history.opponent_actions[-1]
        num_defectors = sum((not action for action in previous_actions))
        threshold = self.n_players / 2
        stock_ratio = current_stock / self.capacity
        if stock_ratio > 0.75 and num_defectors >= threshold:
            return Action.D
        elif stock_ratio < 0.25:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_267(BaseStrategy):
    """
    Exploitative Strategy for Common Pool Resource Game.
    This strategy balances immediate payoffs with long-term sustainability by
    cooperating when the stock is above 50% of capacity and defecting otherwise.
    It always cooperates in the first round and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        threshold = self.capacity * 0.5
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_268(BaseStrategy):
    """
    An adaptive strategy that balances cooperation and defection in the Common Pool Resource Game.
    Cooperates initially and when the stock is healthy, defects when the stock drops below 80% of capacity, 
    and always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        threshold = 0.8 * self.game_description.capacity
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_269(BaseStrategy):
    """
    A strategy that begins by cooperating, defects in the final round, and adapts based on stock levels and cooperation rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        my_last_action = history.my_actions[-1]
        opponents_last_actions = history.opponent_actions[-1, :]
        total_coop = sum(opponents_last_actions) + (1 if my_last_action else 0)
        avg_coop = total_coop / self.game_description.n_players
        previous_stock = state.current_stock
        if previous_stock < 0.5 * self.game_description.capacity or avg_coop < 0.5:
            return Action.D
        if previous_stock < 0.2 * self.game_description.capacity:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_270(BaseStrategy):
    """
    Adaptive Exploitation Strategy in the Common Pool Resource Game.
    
    This strategy adapts based on the game history and current stock level:
    - Cooperates on the first round.
    - Defects in the last round.
    - Cooperates if the stock is critically low.
    - Adjusts cooperation probability based on the average cooperation rate of all players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * capacity:
            return Action.C
        my_actions = history.my_actions
        opponent_actions = history.opponent_actions
        sum_coop = np.sum(my_actions) + np.sum(opponent_actions)
        rounds_so_far = my_actions.size
        total_actions = rounds_so_far * self.game_description.n_players
        avg_coop = sum_coop / total_actions
        if avg_coop > 0.5:
            if random.random() < 0.6:
                return Action.D
            else:
                return Action.C
        elif random.random() < 0.7:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_271(BaseStrategy):
    """
    A strategy that balances cooperation with strategic exploitation to maximize payoffs while maintaining resource sustainability.
    Cooperates initially, defects in the last round, and adapts based on stock level and others' cooperation history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < 0.3 * self.capacity:
            return Action.C
        total_cooperations = 0
        n_opponents = self.n_players - 1
        for rnd in range(state.round_number):
            round_actions = history.opponent_actions[rnd]
            total_cooperations += np.count_nonzero(round_actions)
        possible_actions = state.round_number * n_opponents
        average_coop_rate = total_cooperations / possible_actions
        if average_coop_rate > 0.7:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_272(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Common Pool Resource Game.
    Cooperates initially, defects in the final round, and adapts based on stock levels and opponents' recent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.m = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.2 * self.game_description.capacity:
            return Action.C
        else:
            current_t = state.round_number
            start = max(0, current_t - self.m)
            max_rounds = current_t - start
            if max_rounds == 0:
                return Action.C
            n_opponents = self.game_description.n_players - 1
            opponent_actions = history.opponent_actions[start:current_t, :]
            sum_C = np.sum(opponent_actions)
            total_possible = max_rounds * n_opponents
            rate = sum_C / total_possible
            if rate >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_273(BaseStrategy):
    """
    Exploitative strategy for the Common Pool Resource Game.
    Cooperates initially to establish trust, then adapts based on the stock level and others' past actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = self.stock_history[-1]
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if len(self.stock_history) >= 2:
            previous_stock = self.stock_history[-2]
            if current_stock < 0.5 * capacity or current_stock < previous_stock:
                return Action.C
        last_round = state.round_number - 1
        opponent_actions_last_round = history.opponent_actions[last_round]
        defectors_last_round = np.sum(1 - opponent_actions_last_round)
        majority_defected = defectors_last_round > n_players / 2
        if majority_defected and current_stock > 0.5 * capacity:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_274(BaseStrategy):
    """
    A threshold-based strategy that cooperates until the common pool stock drops below 50% of capacity, then defects indefinitely.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.defecting = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        threshold = 0.5 * self.capacity
        if self.defecting:
            return Action.D
        if state.current_stock < threshold:
            self.defecting = True
        return Action.D if self.defecting else Action.C

class Strategy_EXPLOITATIVE_276(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that balances 
    immediate gains with long-term sustainability by adapting based on the 
    current stock level and round number.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            threshold = 2.0 / 3 * self.capacity
            if state.current_stock > threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_277(BaseStrategy):
    """
    A threshold-based strategy where the player cooperates if the current stock is at or below 50% of capacity and defects otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        threshold = 0.5 * self.capacity
        if state.current_stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_278(BaseStrategy):
    """
    Adaptive Cooperation with Stock Conservation strategy.
    Cooperates initially, defects in the last round, conserves stock when low,
    and adapts based on opponents' recent cooperation rate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            total_rounds = self.game_description.n_rounds
            if state.round_number == total_rounds - 1:
                return Action.D
            elif state.current_stock < 0.25 * self.game_description.capacity:
                return Action.C
            else:
                n_players = self.game_description.n_players
                r = state.round_number
                k = min(r, 3)
                total_coop = 0
                for t in range(r - k, r):
                    my_act = history.my_actions[t]
                    opp_acts = history.opponent_actions[t]
                    my_coop = 1 if my_act else 0
                    opp_coop = opp_acts.sum()
                    total_coop += my_coop + opp_coop
                avg_coop = total_coop / (n_players * k)
                if avg_coop >= 0.5:
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_279(BaseStrategy):
    """
    Adaptive Exploitation with Stock Conservation (AES) strategy for the Common Pool Resource game.
    Cooperates initially, defects in the last round, and adapts based on stock level and defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        n = self.game_description.n_players
        t = state.round_number
        total_defects = 0
        for prev_round in range(t):
            my_defect = 0 if history.my_actions[prev_round] else 1
            opponent_defects = sum((0 if action else 1 for action in history.opponent_actions[prev_round]))
            total_defects += my_defect + opponent_defects
        avg_defection = total_defects / (n * t)
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock < capacity / 2 or avg_defection > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_280(BaseStrategy):
    """
    This strategy adapts its behavior based on the game state and opponents' actions.
    It starts by cooperating, then uses a combination of majority rule, payoff evaluation,
    and stock level considerations to decide actions, defecting in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if history is None:
            return Action.C
        current_stock = state.current_stock
        if current_stock < 0.05 * self.capacity:
            return Action.D
        if current_stock < self.capacity / 2:
            return Action.C
        if len(history.my_payoffs) < 1:
            pass
        else:
            opponent_actions = history.opponent_actions
            if len(opponent_actions.shape) == 2 and opponent_actions.shape[0] > 0:
                last_round_opponent_actions = opponent_actions[-1]
                cooperators_last_round = sum(last_round_opponent_actions)
                defectors_last_round = self.n_players - 1 - int(cooperators_last_round)
                if defectors_last_round > (self.n_players - 1) / 2:
                    return Action.D
        sum_c = 0.0
        sum_d = 0.0
        count_c = 0
        count_d = 0
        num_payoff_rounds = len(history.my_payoffs)
        start_round = max(0, num_payoff_rounds - 3)
        for i in range(start_round, num_payoff_rounds):
            action = history.my_actions[i]
            payoff = history.my_payoffs[i]
            if action:
                sum_c += payoff
                count_c += 1
            else:
                sum_d += payoff
                count_d += 1
        c_avg = sum_c / count_c if count_c != 0 else 0.0
        d_avg = sum_d / count_d if count_d != 0 else 0.0
        action = Action.D if d_avg > c_avg else Action.C
        if current_stock >= self.capacity:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_281(BaseStrategy):
    """
    Exploitative Stock Conservation (ESC) strategy for the Common Pool Resource Game.
    Cooperates in the first round, defects in the last, and cooperates when stock is below 30% capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.3 * self.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_283(BaseStrategy):
    """
    Adaptive Exploitation with Sustainability (AES) strategy for the Common Pool Resource game.
    This strategy balances cooperation and defection based on stock levels and opponents' actions.
    It cooperates when the stock is high, defects when the stock is low, and adapts based on others' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        elif current_round == r - 1:
            return Action.D
        else:
            defects = 0
            if history is not None:
                for round_number in range(current_round):
                    round_actions = history.opponent_actions[round_number, :]
                    defects_in_round = np.sum(~round_actions)
                    defects += defects_in_round
                total_actions = current_round * n
                if total_actions == 0:
                    defector_proportion = 0.0
                else:
                    defector_proportion = defects / total_actions
            else:
                defector_proportion = 0.0
            if current_stock > 0.7 * capacity:
                return Action.C
            elif current_stock < 0.3 * capacity or defector_proportion > 0.5:
                return Action.D
            elif random.random() < 0.7:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_284(BaseStrategy):
    """
    A strategy that adapts based on stock trends, cooperating when stock is low 
    to conserve resources and defecting when stock is plentiful, with a final 
    round defect to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            threshold = 0.8 * self.capacity
            if current_stock < threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_285(BaseStrategy):
    """
    Strategy for the Common Pool Resource Game that balances initial cooperation 
    with adaptive decision-making based on stock levels and opponent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        threshold_stock = 0.7 * self.game_description.capacity
        if state.current_stock < threshold_stock:
            return Action.D
        else:
            last_round_opponents = history.opponent_actions[-1, :]
            n_coop = np.sum(last_round_opponents)
            threshold_coop = self.game_description.n_players // 2
            if n_coop < threshold_coop:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_286(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on observed behavior and stock trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = [game_description.capacity]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if len(self.stock_history) <= t:
            self.stock_history.append(state.current_stock)
        else:
            pass
        if t == 0:
            return Action.C
        elif t == r - 1:
            return Action.D
        else:
            prev_round = t - 1
            if history is None:
                defectors = 0
            else:
                my_prev_action = history.my_actions[prev_round]
                opponent_prev_actions = history.opponent_actions[prev_round]
                defectors = 0
                if not my_prev_action:
                    defectors += 1
                for action in opponent_prev_actions:
                    if not action:
                        defectors += 1
            if defectors > n / 2:
                return Action.D
            if prev_round + 1 >= len(self.stock_history) or t >= len(self.stock_history):
                return Action.C
            else:
                prev_stock = self.stock_history[prev_round + 1]
                current_stock = self.stock_history[t]
                if current_stock < prev_stock:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_287(BaseStrategy):
    """
    Adaptive Exploitation with Conservation (AEC) strategy for the Common Pool Resource Game.
    This strategy balances cooperation and defection to maximize individual payoff while considering
    stock levels and opponents' historical behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < 0.5 * self.capacity:
            return Action.C
        sum_defections = np.sum(~history.opponent_actions[:state.round_number])
        total_actions = state.round_number * (self.n_players - 1)
        avg_defection = sum_defections / total_actions
        if avg_defection > 0.5:
            return Action.D
        elif random.random() <= avg_defection:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_288(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection.
    It cooperates to establish trust initially, defects in the last round to maximize payoff,
    and adapts based on stock levels and others' cooperation rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.5 * self.capacity:
            return Action.C
        prev_round = current_round - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round]
        total_coop = int(my_prev_action) + np.count_nonzero(opponents_prev_actions)
        cooperation_rate = total_coop / self.n_players
        if cooperation_rate >= 0.75 or cooperation_rate <= 0.25:
            return Action.D
        else:
            majority_coop = total_coop > self.n_players / 2
            return Action.C if majority_coop else Action.D

class Strategy_EXPLOITATIVE_289(BaseStrategy):
    """
    An adaptive strategy that balances cooperation and exploitation based on observed behavior and stock levels.
    Cooperates initially, then defects if a significant portion of players defect, if stock is low, or in endgame rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_last_action = history.my_actions[prev_round]
        opponent_actions_prev = history.opponent_actions[prev_round]
        my_defectors = 0 if my_last_action else 1
        opponent_defectors = np.count_nonzero(~opponent_actions_prev)
        defectors_prev = my_defectors + opponent_defectors
        D = defectors_prev / self.game_description.n_players
        S_current = state.current_stock
        capacity = self.game_description.capacity
        low_stock = S_current < 0.5 * capacity
        r = self.game_description.n_rounds
        cutoff = 0.8 * (r - 1)
        is_endgame = state.round_number >= cutoff
        if D > 0.3 or low_stock or is_endgame:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_290(BaseStrategy):
    """
    Adaptive Exploitation strategy for the Common Pool Resource Game.
    Cooperates initially, then adapts based on stock levels and others' defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.in_defect_mode = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number < 3:
            return Action.C
        if self.in_defect_mode:
            if state.current_stock > 0.5 * self.game_description.capacity:
                prev_round = state.round_number - 1
                opponents_defect = sum(history.opponent_actions[prev_round, :] == False)
                my_defect = not history.my_actions[prev_round]
                total_defectors = opponents_defect + (1 if my_defect else 0)
                n_players = self.game_description.n_players
                if total_defectors <= n_players / 2:
                    self.in_defect_mode = False
                    return Action.C
            return Action.D
        elif state.current_stock < 0.5 * self.game_description.capacity:
            self.in_defect_mode = True
            return Action.D
        else:
            prev_round = state.round_number - 1
            opponents_defect = sum(history.opponent_actions[prev_round, :] == False)
            my_defect = not history.my_actions[prev_round]
            total_defectors = opponents_defect + (1 if my_defect else 0)
            n_players = self.game_description.n_players
            if total_defectors > n_players / 2:
                self.in_defect_mode = True
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_291(BaseStrategy):
    """
    Adaptive Exploitation with Stock Sustainability Strategy.
    Cooperates initially, defects in the last round, and adjusts based on stock levels and opponents' previous actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        round_num = state.round_number
        if round_num == r - 1:
            return Action.D
        if current_stock < 0.1 * capacity:
            return Action.C
        prev_round = round_num - 1
        opponent_prev_actions = history.opponent_actions[prev_round]
        my_prev_action = history.my_actions[prev_round]
        num_other_defectors = sum((1 for action in opponent_prev_actions if not action))
        num_defectors = num_other_defectors + (not my_prev_action)
        half_n = n * 0.5
        stock_critical = 0.3 * capacity
        if num_defectors > half_n or current_stock < stock_critical:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_292(BaseStrategy):
    """
    Adaptive Exploitation with Stock Management Strategy (AESM) for the Common Pool Resource Game.
    - Cooperates in the first round.
    - Defects in the last round.
    - Adjusts based on the cooperation rate and stock level in intermediate rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            last_opponents = history.opponent_actions[-1, :]
            sum_opponents_coop = np.sum(last_opponents)
            my_last_action = history.my_actions[-1]
            total_coop = sum_opponents_coop + (1 if my_last_action else 0)
            cooperation_rate = total_coop / self.n_players
            if cooperation_rate > 0.75:
                action = Action.C
            elif cooperation_rate < 0.5:
                action = Action.D
            elif state.current_stock < self.capacity / 2:
                action = Action.C
            else:
                action = Action.D
            return action

class Strategy_EXPLOITATIVE_293(BaseStrategy):
    """
    A strategy that adapts based on opponents' cooperation rates and stock levels.
    Starts by cooperating, then dynamically adjusts based on game state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock < 0.25 * capacity:
            return Action.C
        elif current_stock > 0.75 * capacity:
            return Action.D
        else:
            opponent_actions = history.opponent_actions
            n_opponents = self.game_description.n_players - 1
            n_rounds_processed = state.round_number
            total_actions = n_opponents * n_rounds_processed
            coop_count = np.sum(opponent_actions)
            if total_actions == 0:
                coop_rate = 0.0
            else:
                coop_rate = coop_count / total_actions
            if coop_rate > 0.5:
                return Action.D
            elif coop_rate < 0.3:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_294(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        self.stock_history.append(state.current_stock)
        n_rounds = self.game_description.n_rounds
        if state.round_number >= 0.9 * n_rounds:
            return Action.D
        capacity = self.game_description.capacity
        if state.current_stock < 0.2 * capacity:
            return Action.D
        prior_round = state.round_number - 1
        my_defect = 0
        if history is not None and prior_round < len(history.my_actions):
            my_prior_action = history.my_actions[prior_round]
            if not my_prior_action:
                my_defect = 1
        opponent_defectors = 0
        if history is not None and prior_round < history.opponent_actions.shape[0]:
            opponent_actions_last = history.opponent_actions[prior_round, :]
            opponent_defectors = len(opponent_actions_last) - np.sum(opponent_actions_last)
        total_defectors = my_defect + opponent_defectors
        proportion_defectors = total_defectors / self.game_description.n_players
        recent_defector_exceeded = proportion_defectors > 0.5
        stock_trend = False
        if state.current_stock < 0.8 * capacity:
            if len(self.stock_history) >= 3:
                recent_stocks = self.stock_history[-3:]
                avg_recent = np.mean(recent_stocks)
                stock_trend = state.current_stock < avg_recent
        if recent_defector_exceeded or stock_trend:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_295(BaseStrategy):
    """
    Adaptive Exploitation with Stock Conservation Strategy.
    
    This strategy starts by cooperating in the first round. In subsequent rounds,
    it adapts based on the previous round's defection rate and the current stock level.
    It defects if the previous defection rate exceeds 30%, cooperates if the stock is 
    below 50% of capacity, otherwise continues to cooperate. It always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round]
        my_defected = 0 if my_prev_action else 1
        opponents_defected = np.sum(opponents_prev_actions == False)
        D_prev = my_defected + opponents_defected
        D_prev_ratio = D_prev / self.n_players
        current_stock = state.current_stock
        if D_prev_ratio > 0.3:
            return Action.D
        elif current_stock < 0.5 * self.capacity:
            return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_296(BaseStrategy):
    """
    Adaptive Exploitative Approach for the Common Pool Resource Game.
    Cooperates initially, then adapts based on others' actions and stock level.
    Defects when others defect excessively, stock is low, or in the last three rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[previous_round, :]
        opponent_defectors = (opponent_actions_prev == False).sum()
        player_prev_action = history.my_actions[previous_round]
        player_defected = player_prev_action == False
        total_defectors = opponent_defectors + (1 if player_defected else 0)
        n_players = self.game_description.n_players
        stock_threshold = 0.25 * self.game_description.capacity
        current_stock = state.current_stock
        if total_defectors > n_players / 2 or current_stock < stock_threshold:
            return Action.D
        elif state.round_number >= self.game_description.n_rounds - 3:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_297(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Common Pool Resource Game.

    This strategy balances cooperation and defection based on observed behavior and stock levels.
    It cooperates initially, defects in the last round, and adapts decisions based on majority behavior
    and critical stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        stock_threshold = 0.2 * capacity
        if state.current_stock < stock_threshold:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        my_defection = 0 if my_prev_action else 1
        opponents_actions = history.opponent_actions[prev_round]
        opponent_defections = np.sum(~opponents_actions)
        total_defectors = my_defection + opponent_defections
        n_players = self.game_description.n_players
        majority_threshold = n_players / 2
        if total_defectors > majority_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_299(BaseStrategy):
    """
    A strategy that adapts based on opponents' cooperation rates, 
    considers stock levels, and employs periodic randomness to test opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.n_rounds - 1:
            if current_stock > 0.5 * self.capacity:
                action = Action.C
            else:
                action = Action.D
        else:
            last_round = round_number - 1
            my_prev_action = history.my_actions[last_round]
            opponent_prev_actions = history.opponent_actions[last_round]
            cooperators = 1 if my_prev_action else 0
            cooperators += sum(opponent_prev_actions)
            coop_rate = cooperators / self.n_players
            if current_stock < 0.5 * self.capacity:
                action = Action.C
            elif coop_rate >= 0.75:
                action = Action.C
            else:
                action = Action.D
        if action == Action.C and random.random() < 0.1:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_301(BaseStrategy):
    """Exploitative Strategy for Common Pool Resource Game.
    Cooperates initially, then adapts based on others' cooperation, stock level, and trend,
    defecting in endgame rounds and when stock is decreasing despite cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        self.stock_history.append(state.current_stock)
        total_rounds = self.game_description.n_rounds
        current_round = state.round_number
        endgame_threshold = 0.9 * total_rounds
        if current_round >= endgame_threshold:
            return Action.D
        k = 3
        if len(self.stock_history) >= k:
            recent_stocks = self.stock_history[-k:]
            is_decreasing = True
            for i in range(k - 1):
                if recent_stocks[i] < recent_stocks[i + 1]:
                    is_decreasing = False
                    break
            if is_decreasing:
                return Action.D
        opponent_actions_last_round = history.opponent_actions[-1, :]
        n_prev = self.game_description.n_players - 1
        others_coop = sum(opponent_actions_last_round) / n_prev
        capacity = self.game_description.capacity
        if others_coop > 0.7 and state.current_stock > 0.7 * capacity:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_302(BaseStrategy):
    """
    This strategy for the Common Pool Resource Game is designed to balance cooperation and defection based on observed behavior.
    It adapts by evaluating cooperation rates, conserves stock when necessary, and maximizes payoff in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.moderate_state = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        final_round = state.round_number == self.game_description.n_rounds - 1
        if final_round:
            return Action.D
        stock_low = state.current_stock < 2 * n
        if stock_low:
            return Action.C
        opponent_actions = history.opponent_actions
        cooperation_count = np.sum(opponent_actions)
        s_rounds = state.round_number
        n_opponents = n - 1
        cooperation_rate = cooperation_count / (s_rounds * n_opponents)
        if cooperation_rate >= 0.75:
            return Action.C
        elif 0.5 <= cooperation_rate < 0.75:
            if not self.moderate_state:
                self.moderate_state = True
                return Action.C
            else:
                self.moderate_state = False
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_303(BaseStrategy):
    """
    An adaptive strategy that cooperates initially, defects if more than half of the players defected in the previous round, 
    and defects in the last round to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_my_action = history.my_actions[-1]
            prev_others_actions = history.opponent_actions[-1, :]
            prev_defections = 0
            if not prev_my_action:
                prev_defections += 1
            prev_defections += np.sum(~prev_others_actions)
            if prev_defections > self.n_players / 2:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_304(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Common Pool Resource Game.

    This strategy begins with cooperation for the first two rounds. It then
    adapts based on the cooperation rate of other players, the current stock level,
    and includes mechanisms for punishing defectors and handling edge cases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_level = 0.25 * game_description.capacity
        self.severe_stock_level = 0.1 * game_description.capacity
        self.cooperation_threshold = 0.5
        self.punishment_length = 3
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == 1:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock <= self.severe_stock_level:
            return Action.D
        if state.current_stock <= self.critical_stock_level:
            return Action.D
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        last_round = state.round_number - 1
        opponent_actions = history.opponent_actions[last_round]
        sum_others = sum(opponent_actions)
        my_last_action = history.my_actions[last_round]
        total_coop = sum_others + (1 if my_last_action else 0)
        cooperation_rate = total_coop / self.game_description.n_players
        if cooperation_rate < self.cooperation_threshold:
            self.punishment_remaining = self.punishment_length
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_305(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource game that balances cooperation and temptation to defect, while conserving stock and maximizing individual payoffs.
    - Cooperates in the first round.
    - Defects in the final round.
    - Cooperates if stock falls below 25% of capacity.
    - Defects if the average defection rate of opponents exceeds 50%.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        conservation_threshold = 0.25 * capacity
        if state.current_stock < conservation_threshold:
            return Action.C
        n_previous_rounds = state.round_number
        total_defectors = 0.0
        for r in range(n_previous_rounds):
            round_actions = history.opponent_actions[r]
            n_players = self.game_description.n_players
            n_defectors = n_players - 1 - np.sum(round_actions)
            total_defectors += n_defectors
        avg_defect = total_defectors / n_previous_rounds
        if avg_defect > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_306(BaseStrategy):
    """
    Implementation of the Adaptive Exploitation strategy for the Common Pool Resource Game.
    The strategy balances immediate gains with long-term sustainability based on stock levels and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            count_defectors = np.sum(1 - opponent_actions_prev.astype(int))
            condition1 = state.current_stock > 0.75 * self.game_description.capacity
            condition2 = count_defectors < self.game_description.n_players / 2
            if condition1 and condition2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_307(BaseStrategy):
    """
    This strategy combines cooperation with punishment for defectors, adapting based on stock levels and opponent actions.
    It starts by cooperating, punishes when others defect excessively, adjusts based on stock sustainability, and defects near the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = 0.8 * (self.capacity / (2 * self.n_players))
        self.punishment_rounds_left = 0
        self.recent_stock_levels = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        self.recent_stock_levels.append(current_stock)
        if len(self.recent_stock_levels) > 3:
            self.recent_stock_levels.pop(0)
        if state.round_number == 0:
            return Action.C
        if state.round_number > self.n_rounds - 3:
            return Action.D
        if self.punishment_rounds_left > 0:
            self.punishment_rounds_left -= 1
            return Action.D
        avg_payoff = 0.0
        if history is not None and history.my_payoffs.size > 0:
            window = min(5, history.my_payoffs.size)
            recent_payoffs = history.my_payoffs[-window:]
            avg_payoff = np.mean(recent_payoffs)
        is_low_payoff = avg_payoff < self.threshold
        is_low_stock = current_stock < 0.5 * self.capacity
        if is_low_payoff and is_low_stock:
            self.punishment_rounds_left = 3
            return Action.D
        else:
            if history is None or history.opponent_actions.size == 0:
                opp_actions = np.array([], dtype=bool)
            else:
                opp_actions = history.opponent_actions[-1, :]
            n_coop_opponents = np.count_nonzero(opp_actions == 1)
            total_opponents = self.n_players - 1
            if n_coop_opponents / total_opponents >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_308(BaseStrategy):
    """
    Adaptive Exploitation Strategy for the Common Pool Resource Game.
    This strategy begins by cooperating, then adapts based on the number of defectors and remaining stock.
    It defects in the last round to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock = 0.5 * game_description.capacity
        self.threshold_defectors = 0.5 * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < self.critical_stock:
            return Action.D
        t_prev = state.round_number - 1
        my_prev_action = history.my_actions[t_prev]
        my_defected = 0 if my_prev_action else 1
        opponent_prev_actions = history.opponent_actions[t_prev]
        opponent_defected = sum((1 for action in opponent_prev_actions if action is False))
        total_defectors = my_defected + opponent_defected
        if total_defectors > self.threshold_defectors:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_309(BaseStrategy):
    """
    Adaptive Exploitation with Punishment strategy.

    Cooperates initially, punishes when many defect, exploits when stock is healthy,
    and switches to cooperation when stock is low. Cooperates in the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        stock_level = current_stock / capacity
        if stock_level < 0.25:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        prev_round = state.round_number - 1
        prev_my_action = history.my_actions[prev_round]
        prev_opponents = history.opponent_actions[prev_round]
        prev_coop = 1 if prev_my_action else 0
        prev_coop += np.sum(prev_opponents)
        prev_defectors = n_players - prev_coop
        if prev_defectors > n_players / 2:
            return Action.D
        if stock_level > 0.5 and prev_defectors <= n_players / 2:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_310(BaseStrategy):
    """
    A strategy that adapts based on cooperation rates and stock levels in a common pool resource game.
    Cooperates initially, then uses history and stock levels to decide actions, defecting in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            capacity = self.capacity
            if current_stock < 0.25 * capacity:
                return Action.C
            elif current_stock > 0.75 * capacity:
                return Action.D
            else:
                prev_round = state.round_number - 1
                my_prev_action = history.my_actions[prev_round]
                opponents_prev_actions = history.opponent_actions[prev_round]
                n_cooperators = int(my_prev_action) + sum(opponents_prev_actions)
                cooperation_rate = n_cooperators / self.n_players * 100
                if cooperation_rate >= 50:
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_311(BaseStrategy):
    """
    This strategy starts by Cooperating in the first round. 
    In subsequent rounds, it defects if more than half of the players defected 
    in the previous round or if the stock level has dropped below half of the capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_prev_action = history.my_actions[-1]
        my_defection = 0 if my_prev_action else 1
        opponent_actions = history.opponent_actions[-1, :]
        op_defections = np.sum(opponent_actions == False)
        d_prev = my_defection + op_defections
        s_prev = state.current_stock
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        if d_prev > n / 2 or s_prev < capacity / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_312(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels and opponents' past actions.
    Cooperates initially, defects if stock is critically low, defects if a majority defected in the last round, and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        if current_round == n_rounds - 1:
            return Action.D
        stock_last = state.current_stock
        if stock_last < 0.25 * capacity:
            return Action.D
        my_last_action = history.my_actions[-1]
        defectors = 0
        if not my_last_action:
            defectors += 1
        others_actions = history.opponent_actions[-1]
        others_defectors = np.count_nonzero(~others_actions)
        defectors += others_defectors
        if defectors > n_players / 2:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_313(BaseStrategy):
    """
    Adaptive Exploitation with Sustainability (AES) strategy for the Common Pool Resource Game.
    Cooperates initially, defects in the last round, cooperates when stock is critically low,
    and defects when more than half the players defected previously.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            recovery_threshold = 0.2 * self.game_description.capacity
            if state.current_stock < recovery_threshold:
                return Action.C
            else:
                prev_my_action = history.my_actions[-1]
                opponent_prev_actions = history.opponent_actions[-1]
                defectors = 0
                if not prev_my_action:
                    defectors += 1
                for action in opponent_prev_actions:
                    if not action:
                        defectors += 1
                if defectors > self.game_description.n_players / 2:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_314(BaseStrategy):
    """
    Strategy that cooperates initially, defects if more than 50% defected last round,
    and cooperates if stock is below 25% of capacity. Defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        if current_round == 0:
            return Action.C
        elif current_round == self.game_description.n_rounds - 1:
            return Action.D
        else:
            if history is None:
                return Action.C
            opponent_actions_prev = history.opponent_actions[-1]
            opponent_defectors = np.sum(~opponent_actions_prev)
            my_prev_action = history.my_actions[-1]
            if not my_prev_action:
                defectors = opponent_defectors + 1
            else:
                defectors = opponent_defectors
            threshold = n_players / 2.0
            if defectors > threshold:
                return Action.D
            elif state.current_stock < 0.25 * capacity:
                return Action.C
            else:
                return Action.C

class Strategy_EXPLOITATIVE_315(BaseStrategy):
    """
    An adaptive strategy that balances exploitation and cooperation to sustain the common pool resource.
    - Defects in the first and last rounds to maximize immediate gain.
    - Cooperates if the stock level falls below 50% of capacity to allow regeneration.
    - Cooperates if the average cooperation rate of all players is at least 50%; otherwise, defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < 0.5 * self.capacity:
            return Action.C
        else:
            t = state.round_number
            my_actions = history.my_actions
            opponent_actions = history.opponent_actions
            my_coops = sum(my_actions[:t])
            opponent_coops = opponent_actions[:t, :].sum()
            total_coops = my_coops + opponent_coops
            total_actions = t * self.n_players
            avg_coop = total_coops / total_actions
            return Action.C if avg_coop >= 0.5 else Action.D

class Strategy_EXPLOITATIVE_316(BaseStrategy):
    """
    An adaptive strategy that balances cooperation and defection based on stock level and opponents' historical actions.
    Cooperates initially, defects if the stock is critically low, and adapts based on others' previous actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * self.capacity:
            return Action.C
        previous_round_actions = history.opponent_actions[state.round_number - 1]
        num_defectors = np.sum(previous_round_actions == False)
        if num_defectors > self.n_players / 2:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_317(BaseStrategy):
    """
    Adaptive Exploitation Strategy for the Common Pool Resource Game.
    Cooperates initially, then adaptively decides based on stock level and opponents' cooperation rate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.stock_critical = 0.25 * self.capacity
        self.cooperation_threshold = 0.5
        self.recent_rounds_window = 3

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if current_stock < self.stock_critical:
            return Action.D
        t = state.round_number
        min_r = max(0, t - self.recent_rounds_window)
        max_r = t - 1
        if history is None:
            return Action.C
        opp_actions_slice = history.opponent_actions[min_r:max_r + 1, :]
        sum_coop = np.sum(opp_actions_slice)
        n_opponents = self.game_description.n_players - 1
        total_rounds = max_r - min_r + 1
        if total_rounds == 0:
            return Action.C
        avg_coop = sum_coop / (total_rounds * n_opponents)
        if avg_coop < self.cooperation_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_318(BaseStrategy):
    """
    Adaptive Exploitation Based on Stock and History (AEBH)
    Balances immediate gains with long-term resource sustainability by adapting to stock levels and opponent actions.
    Cooperates initially, defects in the last round, and retaliates based on opponent behavior in between.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            half_capacity = 0.5 * capacity
            if current_stock > half_capacity:
                last_round_opp_actions = history.opponent_actions[-1]
                other_defectors = np.count_nonzero(~last_round_opp_actions)
                n_players = self.game_description.n_players
                if other_defectors < n_players / 2:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_319(BaseStrategy):
    """
    Adaptive Exploitation with Retaliation and Sustainability (AERS) strategy.
    Cooperates initially, then adapts based on others' actions and stock levels.
    Retaliates against frequent defection and ensures stock sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.initial_threshold = game_description.n_rounds // 2
        self.stock_threshold = 0.25 * game_description.capacity
        self.final_threshold = 2

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round < self.initial_threshold:
            return Action.C
        final_start = self.n_rounds - self.final_threshold
        if current_round >= final_start and current_stock >= 0.9 * self.capacity:
            return Action.D
        if current_stock < self.stock_threshold:
            return Action.C
        opponent_actions_prev = history.opponent_actions[-1]
        your_prev_action = history.my_actions[-1]
        n_cooperators = sum(opponent_actions_prev) + (1 if your_prev_action else 0)
        cooperation_rate = n_cooperators / self.n_players
        action = Action.D
        if cooperation_rate >= 0.5 and current_stock > self.stock_threshold:
            action = Action.C
        n_opponents = len(opponent_actions_prev)
        if n_opponents > 0:
            opponents_defect = sum((1 for a in opponent_actions_prev if not a))
            defect_rate = opponents_defect / n_opponents
            if defect_rate >= 0.5:
                action = Action.D
        return action

class Strategy_EXPLOITATIVE_320(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource game that balances cooperation with retaliation,
    stock conservation, and endgame maximizing. Cooperates initially, retaliates against excessive defectors,
    conserves stock when necessary, and defects in endgame rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold = 0.5
        self.stock_threshold = 0.5
        self.endgame_rounds = 2

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        elif round_num == 1:
            return Action.C
        if round_num >= self.n_rounds - self.endgame_rounds:
            return Action.D
        prev_round = round_num - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev = history.opponent_actions[prev_round]
        total_defectors = 0
        if not my_prev_action:
            total_defectors += 1
        total_defectors += np.count_nonzero(~opponents_prev)
        proportion_defected = total_defectors / self.n_players
        if proportion_defected > self.cooperation_threshold:
            return Action.D
        stock_level = state.current_stock / self.capacity
        if stock_level < self.stock_threshold:
            window = 3
            start_round = max(0, round_num - window)
            sum_coop = 0
            total_obs = 0
            for r in range(start_round, round_num):
                opp_actions = history.opponent_actions[r]
                sum_coop += np.sum(opp_actions)
                total_obs += len(opp_actions)
            if total_obs == 0:
                recent_rate = 0.0
            else:
                recent_rate = sum_coop / total_obs
            if recent_rate <= 0.5:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_321(BaseStrategy):
    """
    Exploitative Strategy for Common Pool Resource Game.

    This strategy begins by cooperating to observe opponents' actions.
    It then calculates the average defection rate of opponents over the last few rounds.
    If the defection rate is high, it defects to exploit. If the stock is critically low, it cooperates to sustain the resource.
    In the last round, it always defects to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == n_rounds - 1:
            return Action.D
        t = len(history.my_actions)
        max_rounds = 5
        k = min(max_rounds, t)
        start = max(0, t - k)
        end = t - 1
        if start > end:
            return Action.C
        total_defections = 0
        opponent_actions = history.opponent_actions
        for round_idx in range(start, end + 1):
            round_defections = sum((1 for action in opponent_actions[round_idx, :] if action is False))
            total_defections += round_defections
        average_defect = total_defections / (k * (n_players - 1))
        threshold_defect = 0.5
        if average_defect > threshold_defect:
            return Action.D
        threshold_stock = 0.25 * capacity
        if state.current_stock < threshold_stock:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_322(BaseStrategy):
    """
    Exploitative Strategy for Common Pool Resource Game:
    This strategy adapts based on observed behavior and current state,
    aiming to exploit others' cooperation while avoiding exploitation.
    It balances immediate gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold_reached = False
        self.decline_count = 0
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_stock = state.current_stock
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if not self.critical_threshold_reached:
            if current_stock < 0.25 * self.capacity:
                self.critical_threshold_reached = True
        if self.critical_threshold_reached:
            return Action.D
        last_round = state.round_number - 1
        my_last_action = history.my_actions[last_round]
        opponent_actions_last_round = history.opponent_actions[last_round, :]
        defectors = 0
        if not my_last_action:
            defectors += 1
        defectors += np.sum(opponent_actions_last_round == 0)
        half = self.n_players / 2
        if defectors > half:
            return Action.D
        if current_stock < 0.5 * self.capacity:
            return Action.D
        if self.previous_stock is not None:
            if current_stock < self.previous_stock:
                self.decline_count += 1
            else:
                self.decline_count = 0
        else:
            self.decline_count = 0
        if self.decline_count >= 2:
            return Action.D
        self.previous_stock = current_stock
        return Action.C

class Strategy_EXPLOITATIVE_323(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts based on opponents' actions and stock levels.
    Cooperates initially, defects if historical consumption exceeds a threshold or stock is low, and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        round_t = state.round_number
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        if round_t == 0 and history is None:
            return Action.C
        elif round_t == self.game_description.n_rounds - 1:
            return Action.D
        else:
            sum_fractions = 0.0
            count_rounds = 0
            for i in range(max(0, round_t - 3), round_t):
                count_C = 0
                if history.my_actions[i]:
                    count_C += 1
                for j in range(n - 1):
                    if history.opponent_actions[i, j]:
                        count_C += 1
                count_D = n - count_C
                fraction = (count_C + 2 * count_D) / (2 * n)
                sum_fractions += fraction
                count_rounds += 1
            average = sum_fractions / count_rounds if count_rounds else 0.0
            if average > 0.5 or state.current_stock < capacity / 2:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_324(BaseStrategy):
    """
    Dynamic Threshold Strategy for the Common Pool Resource Game.
    Cooperates initially, defects in the last round, and dynamically adjusts based on a threshold calculated from the remaining rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            current_round_t = state.round_number + 1
            threshold = self.capacity * (1 - current_round_t / self.n_rounds)
            if state.current_stock > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_325(BaseStrategy):
    """
    Adaptive Exploitation Strategy for the Common Pool Resource Game.
    This strategy balances short-term gains with long-term sustainability by
    dynamically adjusting actions based on the current stock level and
    observed cooperation from other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        round_num = state.round_number
        capacity = self.game_description.capacity
        if round_num == 0:
            return Action.C
        elif round_num == n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            stock_ratio = current_stock / capacity
            opponent_actions = history.opponent_actions[:round_num, :]
            sum_coop = np.sum(opponent_actions)
            total_actions = round_num * (self.game_description.n_players - 1)
            if total_actions == 0:
                avg_coop = 0.0
            else:
                avg_coop = sum_coop / total_actions
            if stock_ratio < 0.5:
                return Action.C
            elif avg_coop >= 0.7 and stock_ratio > 0.3:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_326(BaseStrategy):
    """
    Adaptive Exploitative Strategy with Stock Conservation and Punishment.
    Cooperates initially, defects in the last round, and adapts based on stock level and previous cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.r - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < 0.5 * self.capacity:
            return Action.C
        prev_round = current_round - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        coop_count = my_prev_action + np.sum(opponent_prev_actions)
        half_players = math.ceil(self.n / 2)
        if coop_count >= half_players:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_327(BaseStrategy):
    """
    Adaptive Exploitation Strategy in Common Pool Resource Game.
    
    - Cooperates initially to establish trust and maximize payoffs.
    - Monitors the stock level and the number of defectors in the previous round.
    - Switches to defecting if the stock is low or if enough others are defecting.
    - Punishes for a set number of rounds before reverting to cooperation.
    - Defects in the last round or when the stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.is_defecting = False
        self.defecting_rounds_left = 0
        self.punishment_duration = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if history is not None:
                prev_actions = history.opponent_actions[-1]
                n_opponents = len(prev_actions)
                num_defectors_prev = n_opponents - sum(prev_actions)
                if num_defectors_prev >= n_opponents // 2:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        if self.is_defecting:
            self.defecting_rounds_left -= 1
            if self.defecting_rounds_left <= 0:
                self.is_defecting = False
            return Action.D
        elif history is not None:
            prev_actions = history.opponent_actions[-1]
            n_opponents = len(prev_actions)
            num_defectors_prev = n_opponents - sum(prev_actions)
            trigger_defectors = num_defectors_prev > n_opponents * 0.5
            trigger_stock = state.current_stock < 0.5 * self.game_description.capacity
            if trigger_defectors or trigger_stock:
                self.is_defecting = True
                self.defecting_rounds_left = self.punishment_duration
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_328(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection based on current stock level and opponents' past actions.
    Cooperates initially, defects in the last round, protects stock when low, and responds to high defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        current_round = state.round_number
        if current_round == n_rounds - 1:
            return Action.D
        stock = state.current_stock
        capacity = self.game_description.capacity
        stock_threshold = 0.2 * capacity
        if stock < stock_threshold:
            return Action.C
        n_players = self.game_description.n_players
        previous_rounds = current_round
        total_defections = 0
        for r in range(previous_rounds):
            my_defection = 0 if history.my_actions[r] else 1
            opponent_defections = np.sum(1 - history.opponent_actions[r])
            total_defections += my_defection + opponent_defections
        avg_defect = total_defections / (previous_rounds * n_players)
        if avg_defect > 0.3:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_329(BaseStrategy):
    """
    An adaptive exploitative strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels and others' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            critical_threshold = 0.2 * self.game_description.capacity
            if state.current_stock <= critical_threshold:
                return Action.C
            else:
                my_last = history.my_actions[-1]
                opponent_last = history.opponent_actions[-1]
                cooperation_count = int(my_last) + sum(opponent_last)
                cooperation_rate = cooperation_count / self.game_description.n_players * 100.0
                if cooperation_rate > 50:
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_330(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and strategic defection.
    It cooperates initially, punishes high defection rates, monitors stock trends, and shifts focus in the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        n_rounds = self.game_description.n_rounds
        r = state.round_number
        rounds_remaining = n_rounds - r
        threshold = max(1, math.ceil(0.2 * n_rounds))
        if rounds_remaining <= threshold:
            return Action.D
        if self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        self.stock_history.append(state.current_stock)
        if history is not None and len(history.opponent_actions) > 0:
            total_defectors = 0
            for round_actions in history.opponent_actions:
                defectors = sum(~round_actions)
                total_defectors += defectors
            avg_defections = total_defectors / len(history.opponent_actions)
            if avg_defections > self.game_description.n_players / 2:
                self.punishment_remaining = 2
                return Action.D
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if len(self.stock_history) >= 3:
            last_three = self.stock_history[-3:]
            decreasing = True
            for i in range(1, len(last_three)):
                if last_three[i] >= last_three[i - 1]:
                    decreasing = False
                    break
            if decreasing and current_stock < 0.75 * capacity:
                self.punishment_remaining = 2
                return Action.D
        if current_stock < 0.1 * capacity and n_rounds - r > 1:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_331(BaseStrategy):
    """
    A strategy that adapts based on the level of cooperation and resource sustainability.
    Cooperates initially, defects if more than half of players defect or if stock drops below 50% of capacity,
    and defects in the final round to maximize immediate gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            previous_round = state.round_number - 1
            my_actions = history.my_actions
            my_defected = not my_actions[previous_round]
            n_defectors = int(my_defected)
            opponent_actions = history.opponent_actions[previous_round]
            for action in opponent_actions:
                if not action:
                    n_defectors += 1
            if n_defectors > self.n_players / 2 or state.current_stock < 0.5 * self.capacity:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_332(BaseStrategy):
    """
    Exploitative Strategy for Common Pool Resource Game.
    Cooperates to establish cooperation and sustain stock, defects when beneficial.
    Usesaverage past cooperation and stock levels to decide actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            return Action.D
        t = state.round_number
        opponent_actions = history.opponent_actions[:t, :]
        sum_C = np.sum(opponent_actions)
        num_actions = opponent_actions.size
        avg_coop = sum_C / num_actions if num_actions > 0 else 0.0
        capacity = self.game_description.capacity
        stock = state.current_stock
        if stock <= 0.2 * capacity:
            return Action.C
        elif avg_coop > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_333(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation to sustain resources 
    with strategic defection to exploit others' actions, ensuring adaptability and maximizing 
    long-term payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.25 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            return Action.D
        if state.current_stock < self.threshold:
            return Action.C
        prev_round = state.round_number - 1
        my_last_action = history.my_actions[prev_round]
        op_actions_last_round = history.opponent_actions[prev_round, :]
        n_opponents = op_actions_last_round.size
        n_coop = sum(op_actions_last_round) + (1 if my_last_action else 0)
        total_players = self.game_description.n_players
        if n_coop >= total_players / 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_334(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on stock level, previous defectors, and endgame proximity.
    Cooperates initially, defects when stock is low, or when more than half defected previously, or in the last 20% of rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        r = self.n_rounds
        if (state.round_number + 1) / r >= 0.8:
            return Action.D
        if state.current_stock < self.capacity / 2.0:
            return Action.D
        if history is not None:
            prev_round = state.round_number - 1
            if prev_round >= 0:
                my_prev_action = history.my_actions[prev_round]
                prev_opponents = history.opponent_actions[prev_round]
                my_defected = 0 if my_prev_action else 1
                opp_defected = np.sum(prev_opponents == False)
                total_defected = my_defected + opp_defected
                if total_defected > self.n_players / 2:
                    return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_335(BaseStrategy):
    """
    A strategy that combines initial cooperation with adaptive defection based on observed behavior and resource levels.
    Cooperates initially, then switches to defecting if the average defection rate exceeds 30% or stock falls below 60% of capacity.
    Always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        t = state.round_number
        opponent_actions = history.opponent_actions[0:t, :]
        n_trues = np.sum(opponent_actions)
        total_actions = t * (self.game_description.n_players - 1)
        sum_ds = total_actions - n_trues
        average_defection = sum_ds / total_actions if total_actions != 0 else 0.0
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if average_defection > 0.3 or current_stock < 0.6 * capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_336(BaseStrategy):
    """
    Adaptive Exploitation Strategy for the Common Pool Resource Game.
    Cooperates initially, adapts based on stock level and others' past actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        game_desc = self.game_description
        n_rounds = game_desc.n_rounds
        if state.round_number == n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = game_desc.capacity
        half_cap = capacity / 2
        if current_stock > half_cap:
            t_prev = state.round_number - 1
            my_prev_act = history.my_actions[t_prev]
            opp_prev_acts = history.opponent_actions[t_prev]
            my_defect = 0 if my_prev_act else 1
            n_opp_defectors = len(opp_prev_acts) - np.sum(opp_prev_acts)
            total_defectors = my_defect + n_opp_defectors
            total_players = game_desc.n_players
            if total_defectors > total_players / 2:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_337(BaseStrategy):
    """
    A strategy that cooperates if the current stock level is above half the capacity, 
    otherwise defects. This promotes sustainability when stock is high and exploitation 
    when stock is low, without considering opponents' past actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        threshold = self.capacity / 2
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_338(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource game. It starts with cooperation, 
    defects if the majority defected in the previous round or if the stock falls below 
    half of the capacity, and always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        my_defect = 0 if my_prev_action else 1
        opponent_defect_count = len(opponent_prev_actions) - np.sum(opponent_prev_actions)
        total_defectors = my_defect + opponent_defect_count
        majority_defected = total_defectors > self.game_description.n_players / 2
        stock_threshold = 0.5 * self.game_description.capacity
        if state.current_stock < stock_threshold or majority_defected:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_339(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that adapts based on stock levels and trends.
    Cooperates initially, defects in the last round, and switches based on stock thresholds and trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.stock_history = [self.capacity]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is not None:
            pass
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            self.stock_history.append(state.current_stock)
            current_stock = state.current_stock
            threshold = 0.5 * self.capacity
            if current_stock < threshold:
                return Action.D
            elif len(self.stock_history) >= 2:
                previous_stock = self.stock_history[-2]
                if current_stock < previous_stock:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C

class Strategy_EXPLOITATIVE_340(BaseStrategy):
    """
    A strategy for the Common Pool Resource game that balances cooperation and defection based on stock levels and opponents' behavior.
    Cooperates initially, defects in the last round, and adapts based on previous defections and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            last_actions = history.opponent_actions[-1, :]
            n_defectors = np.sum(~last_actions)
            threshold_defect = self.n_players / 2
            if n_defectors > threshold_defect:
                return Action.D
            elif state.current_stock > self.capacity / 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_341(BaseStrategy):
    """
    A strategy that adapts based on previous actions and stock levels.
    Cooperate initially, then use stock levels and opponents' previous actions to decide.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == n_rounds - 1:
            return Action.D
        if state.current_stock <= 0.01 * capacity:
            return Action.D
        if state.current_stock < 0.5 * capacity:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        total_cooperators = my_prev_action + np.sum(opponent_prev_actions)
        n_players = self.game_description.n_players
        if total_cooperators > n_players / 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_342(BaseStrategy):
    """
    Adaptive Exploitation Strategy (AES) for the Common Pool Resource Game.
    Balances cooperation and defection based on observed behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            previous_round = state.round_number - 1
            prev_total_consumption = history.my_payoffs[previous_round] + history.opponent_payoffs[previous_round, :].sum()
            capacity = self.game_description.capacity
            if prev_total_consumption > 0.75 * capacity:
                action = Action.D
            else:
                action = Action.C
            if state.current_stock < 0.25 * capacity:
                action = Action.C
            if state.round_number == self.game_description.n_rounds - 1:
                action = Action.D
            return action

class Strategy_EXPLOITATIVE_343(BaseStrategy):
    """
    Adaptive strategy for the Common Pool Resource Game balancing cooperation and defection based on stock levels, 
    opponents' actions, and remaining rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.weight_factor = 0.9
        self.stock_threshold = game_description.capacity / 2
        self.cooperation_threshold = 0.5
        self.trend_window = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        self.stock_history.append(state.current_stock)
        n_opponents = self.game_description.n_players - 1
        if history is None:
            return Action.D
        opponent_actions = history.opponent_actions
        t = state.round_number
        cooperation_rates = []
        for i in range(t):
            num_C = np.count_nonzero(opponent_actions[i, :])
            rate = num_C / n_opponents
            cooperation_rates.append(rate)
        sum_weights = 0.0
        sum_weighted = 0.0
        for i in range(len(cooperation_rates)):
            round_distance = t - 1 - i
            weight = self.weight_factor ** round_distance
            sum_weights += weight
            sum_weighted += cooperation_rates[i] * weight
        avg_coop_rate = sum_weighted / sum_weights if sum_weights != 0 else 0.0
        remaining_rounds = self.game_description.n_rounds - state.round_number
        max_rounds = self.game_description.n_rounds
        adjusted_threshold = self.cooperation_threshold * (1 - state.round_number / max_rounds)
        high_stock = state.current_stock > self.stock_threshold
        trend_decreasing = False
        if len(self.stock_history) >= self.trend_window:
            current = state.current_stock
            prev = self.stock_history[-2] if len(self.stock_history) >= 2 else current
            trend_decreasing = current < prev
        end_game = remaining_rounds <= max_rounds * 0.2
        if end_game:
            return Action.D
        if high_stock and avg_coop_rate > adjusted_threshold and (not trend_decreasing):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_344(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts based on observed behavior.
    Cooperates when the stock is above a dynamically adjusted threshold, defects otherwise.
    Adjusts the threshold based on the proportion of defectors in previous rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.threshold = 0.5 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock > self.threshold:
            chosen_action = Action.C
        else:
            chosen_action = Action.D
        previous_round = state.round_number - 1
        if history is not None:
            opponent_actions_prev = history.opponent_actions[previous_round, :]
            defectors = sum((1 - action for action in opponent_actions_prev))
            proportion_defectors = defectors / self.n_players
            if proportion_defectors > 0.5:
                adjustment = (proportion_defectors - 0.5) * 0.1 * self.capacity
                self.threshold -= adjustment
            elif proportion_defectors < 0.5:
                adjustment = (0.5 - proportion_defectors) * 0.1 * self.capacity
                self.threshold += adjustment
            self.threshold = max(0.0, min(self.threshold, self.capacity))
        return chosen_action

class Strategy_EXPLOITATIVE_345(BaseStrategy):
    """A strategy that balances cooperation and defection based on stock levels and historical cooperation."""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.game_description.capacity / 2:
            return Action.C
        sum_opp_coop = 0
        round_count = 0
        start_round = max(0, state.round_number - 3)
        for r in range(start_round, state.round_number):
            opp_actions = history.opponent_actions[r]
            sum_round = sum(opp_actions)
            sum_opp_coop += sum_round
            round_count += 1
        avg_coop = sum_opp_coop / (round_count * (self.game_description.n_players - 1))
        if avg_coop > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_346(BaseStrategy):
    """
    A strategic approach balancing cooperation and exploitation in a Common Pool Resource Game.
    Cooperates initially, follows majority actions, ensures stock sustainability, and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if current_stock < 0.2 * self.capacity:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round]
        opponents_defected = np.sum(opponent_actions_prev == False)
        my_prev_action = history.my_actions[prev_round]
        my_defect = 1 if my_prev_action == False else 0
        total_defected = opponents_defected + my_defect
        if total_defected > self.n_players / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_347(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that adapts based on others' cooperation and stock levels.
    Cooperates initially, defects when stock is healthy and others cooperate, and always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        n_players = self.game_description.n_players
        required = 0.5 * (n_players - 1)
        count = 0
        total_rounds = len(history.my_actions)
        for round in range(total_rounds):
            sum_C = np.sum(history.opponent_actions[round])
            if sum_C >= required:
                count += 1
        avg_cooperation = count / total_rounds
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio > 0.5 and avg_cooperation > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_348(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts based on opponents' past actions and current stock levels.
    - Cooperates in the first round to observe others.
    - Defects in the last round to maximize immediate payoff.
    - Uses stock level thresholds and opponents' average cooperation rate to decide actions in other rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        sum_C = 0
        n_opponents = n_players - 1
        for r in range(state.round_number):
            for opp in range(n_opponents):
                if history.opponent_actions[r, opp]:
                    sum_C += 1
        total_actions = state.round_number * n_opponents
        average_C = sum_C / total_actions if total_actions != 0 else 0.0
        current_stock = state.current_stock
        stock_threshold_low = 0.2 * capacity
        if current_stock < stock_threshold_low:
            return Action.C
        elif average_C >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_349(BaseStrategy):
    """
    Adaptive Cooperation with Forgiveness (ACF) strategy for the Common Pool Resource Game.
    This strategy balances short-term gains with long-term sustainability by adapting to others' behaviors and the game's state.
    It promotes cooperation while protecting against exploitation by dynamically adjusting based on recent actions and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            high_stock_threshold = 0.8 * capacity
            low_stock_threshold = 0.2 * capacity
            high_stock = current_stock > high_stock_threshold
            low_stock = current_stock < low_stock_threshold
            if high_stock or low_stock:
                return Action.C
            else:
                n_opponents = self.game_description.n_players - 1
                count_coop = 0
                recent_window = min(state.round_number, 3)
                for j in range(n_opponents):
                    start = max(0, state.round_number - recent_window)
                    slice = history.opponent_actions[start:state.round_number, j]
                    coop_count = np.sum(slice)
                    ratio = coop_count / recent_window if recent_window != 0 else 0
                    if ratio >= 0.7:
                        count_coop += 1
                threshold = n_opponents // 2 + 1
                if count_coop >= threshold:
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_350(BaseStrategy):
    """
    Exploitative strategy for Common Pool Resource Game.
    Cooperates in the first round, defects if enough opponents defected previously or the stock is low.
    In the last round, defects if the stock is sufficient otherwise cooperates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == n_rounds - 1:
            if capacity == 0:
                stock_ratio = 0.0
            else:
                stock_ratio = current_stock / capacity
            if stock_ratio > 0.25:
                return Action.D
            else:
                return Action.C
        elif round_number == 0:
            return Action.C
        else:
            prev_round = round_number - 1
            prev_actions = history.opponent_actions[prev_round, :]
            n_players = self.game_description.n_players
            n_defectors = n_players - prev_actions.sum()
            proportion = n_defectors / n_players
            if capacity == 0:
                stock_ratio = 0.0
            else:
                stock_ratio = current_stock / capacity
            if stock_ratio < 0.5 or proportion > 0.5:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_351(BaseStrategy):
    """
    A strategy that adapts based on the common pool's stock level and opponents' previous actions.
    Cooperates initially, defects to prevent depletion when stock is low, and defects in the last round.
    punishes defection by others while balancing cooperation for sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        half_capacity = 0.5 * self.capacity
        if current_stock < half_capacity:
            return Action.D
        if current_stock == self.capacity:
            if history is None:
                return Action.C
            if self.n_players == 2:
                opponent_defected = not history.opponent_actions[-1][0]
                return Action.D if opponent_defected else Action.C
            else:
                prev_actions = history.opponent_actions[-1]
                defectors = sum((1 for action in prev_actions if not action))
                if defectors > self.n_players // 2:
                    return Action.D
                else:
                    return Action.C
        elif self.n_players == 2:
            if history is None:
                return Action.C
            opponent_defected = not history.opponent_actions[-1][0]
            return Action.D if opponent_defected else Action.C
        else:
            prev_actions = history.opponent_actions[-1]
            defectors = sum((1 for action in prev_actions if not action))
            if defectors > self.n_players // 2:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_352(BaseStrategy):
    """
    Strategy that Cooperates initially, then punishes if stock drops more than 10% from previous.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_stock = state.current_stock
            return Action.C
        else:
            current_stock = state.current_stock
            prev_stock = self.previous_stock
            if prev_stock <= 0:
                action = Action.C
            elif current_stock < 0.9 * prev_stock:
                action = Action.D
            else:
                action = Action.C
            self.previous_stock = current_stock
            return action

class Strategy_EXPLOITATIVE_353(BaseStrategy):
    """
    A strategy that adapts based on reciprocity, stock levels, and future discounting.
    Cooperates initially, then reciprocates based on others' actions, manages stock, 
    and introduces randomness to avoid predictability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_actions = history.opponent_actions[state.round_number - 1, :]
        num_defectors = prev_actions.size - prev_actions.sum()
        if num_defectors > self.n_players / 2:
            current_strategy = Action.D
        else:
            current_strategy = Action.C
        stock_ratio = state.current_stock / self.capacity
        if stock_ratio >= 0.75:
            current_strategy = Action.C
        elif stock_ratio <= 0.25:
            current_strategy = Action.D
        if (state.round_number + 1) / self.n_rounds > 0.75:
            if random.random() < 0.1:
                current_strategy = Action.D
        if random.random() < 0.1:
            current_strategy = Action.D if current_strategy == Action.C else Action.C
        return current_strategy

class Strategy_EXPLOITATIVE_354(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.game_description.n_rounds - 1:
            return Action.D
        defect_count = (history.opponent_actions[-1, :] == 0).sum()
        current_stock = state.current_stock
        threshold_defect = 0.5 * self.game_description.n_players
        capacity = self.game_description.capacity
        if defect_count > threshold_defect or current_stock < 0.25 * capacity:
            return Action.D
        gradual_coop_rounds = 2
        if (current_round + 1) % gradual_coop_rounds == 0:
            return Action.C
        return Action.C if defect_count <= threshold_defect else Action.D

class Strategy_EXPLOITATIVE_355(BaseStrategy):
    """
    An adaptive strategy that starts with cooperation and switches to defection based on observed behavior.
    Cooperates initially, defects in the last round, and switches to defection if others defect excessively.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        recent_rounds = 3
        start = max(0, state.round_number - recent_rounds)
        defect_count = 0
        for k in range(start, state.round_number):
            action_k = history.my_actions[k]
            payoff_k = history.my_payoffs[k]
            if action_k:
                S_k = 2 * self.n_players * payoff_k
            else:
                S_k = self.n_players * payoff_k
            expected = S_k / 2
            total_actual = 0.0
            self_action = action_k
            others_actions = history.opponent_actions[k]
            all_actions = np.append(self_action, others_actions)
            for act in all_actions:
                if act:
                    total_actual += S_k / (2 * self.n_players)
                else:
                    total_actual += S_k / self.n_players
            if total_actual > expected:
                defect_count += 1
        total_rounds = state.round_number - start
        if total_rounds == 0:
            return Action.C
        proportion = defect_count / total_rounds
        if proportion > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_356(BaseStrategy):
    """
    An adaptive strategy that cooperates if the stock is stable or increasing, 
    and defects if the stock significantly decreases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.prev_stock = state.current_stock
            return Action.C
        else:
            current_stock = state.current_stock
            if current_stock >= self.prev_stock:
                action = Action.C
            else:
                action = Action.D
            self.prev_stock = current_stock
            return action

class Strategy_EXPLOITATIVE_357(BaseStrategy):
    """
    Adaptive Exploitation Based on Stock Levels Strategy.
    
    This strategy adapts based on the current stock level and opponents' actions.
    It aims to balance immediate gains with long-term sustainability of the common resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C
        elif state.round_number == r - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            depletion = (capacity - current_stock) / capacity
            if depletion <= 0.25:
                last_round = state.round_number - 1
                my_last_action = history.my_actions[last_round]
                I_defected = not my_last_action
                opponents_last_round = history.opponent_actions[last_round]
                opponent_defectors = np.count_nonzero(~opponents_last_round)
                total_defectors = opponent_defectors + (1 if I_defected else 0)
                threshold = n * 0.5
                if total_defectors > threshold:
                    return Action.D
                else:
                    return Action.C
            elif 0.25 < depletion <= 0.5:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_359(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that Cooperates initially, 
    Defects if stock decreases, and Defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.previous_stock = state.current_stock
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            if state.current_stock < self.previous_stock:
                action = Action.D
            else:
                action = Action.C
            self.previous_stock = state.current_stock
            return action

class Strategy_EXPLOITATIVE_362(BaseStrategy):
    """
    Balances exploitation and conservation by adapting to opponents' past actions and current stock levels.
    Cooperates initially, defects in the final round, and dynamically adjusts based on previous defections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            return Action.D
        critical_stock = 0.25 * self.game_description.capacity
        if state.current_stock <= critical_stock:
            return Action.C
        prev_round = state.round_number - 1
        opponent_actions_prev = history.opponent_actions[prev_round]
        k = len(opponent_actions_prev) - sum(opponent_actions_prev)
        threshold_defect = 0.5
        if k / self.game_description.n_players > threshold_defect:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_363(BaseStrategy):
    """
    Exploitative Strategy for the Common Pool Resource Game.

    Uses a dynamic approach based on previous rounds' cooperation rate and current stock level.
    Cooperates initially, defects in the last round, and adapts based on stock and cooperation history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            capacity = self.game_description.capacity
            if state.current_stock < 0.5 * capacity:
                return Action.D
            else:
                total_coop = 0
                for r in range(state.round_number):
                    my_coop = int(history.my_actions[r])
                    opp_coop = np.sum(history.opponent_actions[r])
                    total_coop += my_coop + opp_coop
                avg_coop_rate = total_coop / (state.round_number * self.game_description.n_players)
                if avg_coop_rate > 0.5:
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_364(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances individual payoffs
    with stock sustainability by adapting to the game's state and players' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round < 0.1 * self.n_rounds:
            return Action.C
        endgame_cutoff = 0.9 * self.n_rounds
        if current_round >= endgame_cutoff:
            return Action.D
        if current_stock <= 0:
            return Action.D
        if current_stock < 0.5 * self.capacity:
            return Action.C
        S_remaining = current_stock
        growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
        if growth <= 0:
            return Action.D
        if history is None:
            return Action.C
        total_rounds = current_round
        if total_rounds == 0:
            return Action.C
        total_coops = 0
        for r in range(total_rounds):
            my_coop = history.my_actions[r]
            opp_coop = np.count_nonzero(history.opponent_actions[r, :])
            total_coops += (1 if my_coop else 0) + opp_coop
        avg_coop = total_coops / (total_rounds * self.n_players)
        if total_coops == 0:
            return Action.D
        if avg_coop > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_365(BaseStrategy):
    """
    A strategy that adapts to the game's state and history, balancing exploitation and sustainability.
    - Cooperates in the first round.
    - Defects in the final round.
    - Cooperates when stock is high, defects when stock is low, and mirrors previous majority actions for moderate stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        stock = state.current_stock
        stock_pct = stock / capacity if capacity != 0 else 0.0
        if stock_pct < 0.2:
            return Action.D
        elif stock_pct > 0.8:
            return Action.C
        else:
            last_my_action = history.my_actions[-1]
            my_coop = 1 if last_my_action else 0
            opponent_actions = history.opponent_actions[-1]
            opponent_coop = opponent_actions.sum()
            last_round_coop = my_coop + opponent_coop
            n_players = self.game_description.n_players
            if last_round_coop > n_players / 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_366(BaseStrategy):
    """
    Adaptive Exploitation with Stock Preservation Strategy for the Common Pool Resource Game.
    Cooperates initially, then adapts based on previous actions and current stock levels.
    Defects in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            my_last_action = history.my_actions[-1]
            opp_last_actions = history.opponent_actions[-1, :]
            defectors = 0
            if not my_last_action:
                defectors += 1
            defectors += np.count_nonzero(~opp_last_actions)
            if defectors > self.game_description.n_players / 2:
                return Action.D
            else:
                stock_ratio = state.current_stock / self.game_description.capacity
                if stock_ratio < 0.5:
                    return Action.C
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_367(BaseStrategy):
    """
    A strategy that balances exploiting current gains through defection while conserving the stock for future rounds.
    It cooperates initially, defects in the last round, conserve when stock is low, and adapts based on opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        round_number = state.round_number
        n_rounds = self.game_description.n_rounds
        if round_number == n_rounds - 1:
            return Action.D
        cap = self.game_description.capacity
        stock = state.current_stock
        if stock < 0.5 * cap:
            return Action.C
        else:
            opponent_actions = history.opponent_actions
            n_prev_rounds, n_players = opponent_actions.shape
            ds_per_round = n_players - opponent_actions.sum(axis=1)
            total_ds = ds_per_round.sum()
            proportion = total_ds / (n_players * n_prev_rounds)
            if proportion > 0.5:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_368(BaseStrategy):
    """
    Adaptive Cooperation Strategy that balances cooperation with self-interest by responding to previous actions and stock levels.
    Cooperates unless more than half defected last round or stock is critically low, then defects. Defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.r - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev = history.my_actions[prev_round]
        opp_prev = history.opponent_actions[prev_round]
        all_prev = np.zeros(self.n, dtype=bool)
        all_prev[0] = my_prev
        all_prev[1:] = opp_prev
        k = np.count_nonzero(~all_prev)
        stock_threshold = 0.5 * self.capacity
        if k > self.n / 2 or state.current_stock < stock_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_369(BaseStrategy):
    """
    A strategy that balances cooperation and strategic defection in a Common Pool Resource Game.
    It adapts based on the current stock level and opponents' previous actions to maximize payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            stock = state.current_stock
            capacity = self.game_description.capacity
            stock_percent = stock / capacity * 100
            if stock_percent < 50:
                return Action.D
            else:
                last_actions = history.opponent_actions[-1, :]
                n_defectors = sum(1 - last_actions)
                if 4 * n_defectors > self.game_description.n_players - 1:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_370(BaseStrategy):
    """
    A strategy that starts with cooperation, adapts based on opponents' previous actions,
    defects when a majority defected the last round, and defects in the final round.
    Cooperates if stock is critically low to allow recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_opp_actions = history.opponent_actions[state.round_number - 1, :]
            num_defectors = np.sum(~prev_opp_actions)
            total_opponents = len(prev_opp_actions)
            proportion_defectors = num_defectors / total_opponents
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            stock_threshold = 0.25 * capacity
            if proportion_defectors >= 0.5:
                if current_stock < stock_threshold:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_371(BaseStrategy):
    """
    Adaptive Exploitation with Conservation strategy for Common Pool Resource Game.
    The strategy combines initial cooperation, adaptive exploitation based on cooperation levels, 
    and conservation when the stock is low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C
        if state.round_number == n_rounds - 1:
            return Action.D
        ratios = []
        for r in range(0, state.round_number):
            if r < len(history.my_actions):
                my_action = history.my_actions[r]
                my_payoff = history.my_payoffs[r]
                if my_action:
                    S_r = 2 * n_players * my_payoff
                else:
                    S_r = n_players * my_payoff
                if history.opponent_payoffs is not None and history.opponent_payoffs.shape[0] > r:
                    op_payoffs = history.opponent_payoffs[r, :] if history.opponent_payoffs.ndim == 2 else history.opponent_payoffs
                else:
                    op_payoffs = np.array([], dtype=np.float64)
                total_payoff = my_payoff + np.sum(op_payoffs)
                actual_avg = total_payoff / n_players if n_players != 0 else 0.0
                max_avg = S_r / (2 * n_players) if n_players != 0 else 0.0
                if max_avg == 0:
                    if actual_avg == 0:
                        ratio = 1.0
                    else:
                        ratio = 0.0
                else:
                    ratio = actual_avg / max_avg
                ratios.append(ratio)
        avg_ratio = np.mean(ratios) if ratios else 0.0
        if avg_ratio > 0.8:
            return Action.D
        if state.current_stock < 0.2 * capacity:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_372(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation with strategic exploitation,
    including mechanisms for punishing defectors and preserving stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == n_rounds - 1:
            return Action.C
        current_stock = state.current_stock
        if current_stock < 0.5 * capacity:
            return Action.D
        last_round_opponent_actions = history.opponent_actions[-1]
        defector_count = (~last_round_opponent_actions).sum()
        n_players = self.game_description.n_players
        threshold = math.ceil((n_players - 1) / 3)
        if defector_count >= threshold:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_374(BaseStrategy):
    """
    Adaptive Exploitation Based on Stock and Round Progression.
    Cooperates initially, then defects when stock is low or near the end of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.r - 1:
            return Action.D
        elif state.current_stock <= self.capacity * 0.5 or state.round_number + 1 > 0.8 * self.r:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_375(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts based on cooperation rates and stock levels.
    Cooperates initially, assesses others' behavior, and defects when beneficial while sustaining resource levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.lower_threshold = 0.25 * self.capacity
        self.upper_threshold = 0.75 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round]
        cooperation_count = sum(opponents_prev_actions) + (1 if my_prev_action else 0)
        cooperation_rate = cooperation_count / self.n_players
        current_stock = state.current_stock
        lower = self.lower_threshold
        upper = self.upper_threshold
        if current_stock <= lower:
            return Action.C
        elif current_stock >= upper:
            return Action.D
        else:
            return Action.C if cooperation_rate > 0.5 else Action.D

class Strategy_EXPLOITATIVE_376(BaseStrategy):
    """
    Adaptive Exploitation Strategy based on Stock and Opponent Behavior.
    Cooperates initially, defects in the last round, and adapts based on previous defection levels and current stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            if history is None:
                return Action.C
            prev_round = state.round_number - 1
            prev_opponent_actions = history.opponent_actions[prev_round]
            my_prev_action = history.my_actions[prev_round]
            opponent_defectors = np.sum(~prev_opponent_actions)
            my_defected = 0 if my_prev_action else 1
            total_defectors = opponent_defectors + my_defected
            if total_defectors > self.n_players / 2:
                return Action.D
            elif state.current_stock > self.capacity / 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_377(BaseStrategy):
    """
    Adaptive Exploitation strategy for the Common Pool Resource game.
    This strategy balances cooperation and defection based on the current stock level,
    opponents' past actions, and the game's progression.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock = state.current_stock
        capacity = self.game_description.capacity
        round_number = state.round_number
        n_rounds = self.game_description.n_rounds
        action = None
        stock_ratio = stock / capacity if capacity != 0 else 0.0
        if stock_ratio > 0.75:
            action = Action.D
        elif stock_ratio < 0.25:
            action = Action.C
        else:
            opponent_actions = history.opponent_actions[:round_number, :]
            n_opponents = self.game_description.n_players - 1
            total_possible_actions = round_number * n_opponents
            sum_cooperation = np.sum(opponent_actions)
            total_defections = total_possible_actions - sum_cooperation
            avg_defection_rate = total_defections / total_possible_actions if total_possible_actions != 0 else 0.0
            if avg_defection_rate > 0.5:
                action = Action.D
            else:
                action = Action.C
        if round_number >= 0.8 * n_rounds:
            action = Action.D
        if stock == 0:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_378(BaseStrategy):
    """
    This strategy employs a mixed approach of cooperation and defection, adapting
    based on stock levels and opponents' past actions. It starts with cooperation,
    defects when stock is low, punishes frequent defectors, and maximizes payoffs
    in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        if state.current_stock < 0.5 * capacity:
            return Action.D
        if history is not None:
            last_opponent_actions = history.opponent_actions[-1]
            num_opponents = len(last_opponent_actions)
            if num_opponents > 0:
                num_defecting = sum((not action for action in last_opponent_actions))
                if num_defecting / num_opponents > 0.5:
                    return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_379(BaseStrategy):
    """
    Adaptive strategy for the Common Pool Resource Game that balances cooperation and defection based on historical cooperation rates and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        endgame_threshold = 0.9 * total_rounds
        if state.round_number >= endgame_threshold:
            return Action.D
        critical_stock = 0.2 * capacity
        if state.current_stock < critical_stock:
            return Action.D
        window_size = 5
        start_round = max(0, state.round_number - window_size)
        cooperation_rates = []
        for t in range(start_round, state.round_number):
            my_action = history.my_actions[t]
            opponents = history.opponent_actions[t, :]
            total_coop = (1 if my_action else 0) + int(opponents.sum())
            rate = total_coop / n_players
            cooperation_rates.append(rate)
        if not cooperation_rates:
            return Action.D
        avg_rate = np.mean(cooperation_rates)
        stock_threshold = 0.25 * capacity
        if avg_rate > 0.5 and state.current_stock > stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_380(BaseStrategy):
    """
    Exploitative strategy for the Common Pool Resource Game that adapts based on opponents' previous actions and current stock levels.
    Cooperates initially, defects if others defect excessively or if the stock is low, and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        stock_threshold = 0.3 * capacity
        if current_stock < stock_threshold:
            return Action.D
        last_round = state.round_number - 1
        opponents_prev_actions = history.opponent_actions[last_round, :]
        defect_opponents = np.count_nonzero(~opponents_prev_actions)
        my_last_action = history.my_actions[last_round]
        if not my_last_action:
            total_prev_defectors = defect_opponents + 1
        else:
            total_prev_defectors = defect_opponents
        n_players = self.game_description.n_players
        cooperation_threshold = n_players / 2
        if total_prev_defectors >= cooperation_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_381(BaseStrategy):
    """
    This strategy starts by cooperating, defects in the last round, and adapts based on previous actions and stock levels.
    It defects if most players defected last round or if the stock is critically low (below 25% of capacity).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            last_round = state.round_number - 1
            my_last_action = history.my_actions[last_round]
            opponent_last_actions = history.opponent_actions[last_round, :]
            opponent_defectors = np.count_nonzero(~opponent_last_actions)
            my_defector = 0 if my_last_action else 1
            defectors_last_round = my_defector + opponent_defectors
            cooperation_threshold = self.n_players / 2
            if defectors_last_round > cooperation_threshold:
                return Action.D
            else:
                stock_threshold = 0.25 * self.capacity
                if state.current_stock < stock_threshold:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_382(BaseStrategy):
    """
    Exploitative Strategy for Common Pool Resource Game.
    Adapts based on stock levels, opponents' cooperation, and employs tit-for-tat.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        stock_ratio = state.current_stock / self.game_description.capacity
        base_action = None
        if stock_ratio > 0.75:
            base_action = Action.C
        elif 0.5 <= stock_ratio <= 0.75:
            if random.random() < 0.6:
                base_action = Action.C
            else:
                base_action = Action.D
        elif stock_ratio < 0.5:
            base_action = Action.D
        else:
            base_action = Action.C
        if history is not None:
            opponent_actions = history.opponent_actions
            n_opponents = opponent_actions.shape[1]
            last_round = opponent_actions[-1]
            cooperation_count = sum(last_round)
            if cooperation_count < 0.5 * n_opponents:
                return Action.D
            for i in range(n_opponents):
                n_rounds = opponent_actions.shape[0]
                defection_count = sum((1 for t in range(n_rounds) if not opponent_actions[t, i]))
                if n_rounds == 0:
                    defection_rate = 0.0
                else:
                    defection_rate = defection_count / n_rounds
                    if defection_rate > 0.7:
                        return Action.D
        return base_action

class Strategy_EXPLOITATIVE_383(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and strategic defection.
    It starts with cooperation, adapts based on stock trends and defection rates, and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        prev_round = current_round - 1
        my_action = history.my_actions[prev_round]
        my_payoff = history.my_payoffs[prev_round]
        if my_action:
            S_prev = my_payoff * 2 * self.n_players
        else:
            S_prev = my_payoff * self.n_players
        S_current = state.current_stock
        trend_decreasing = S_current < S_prev
        opponent_actions_prev = history.opponent_actions[prev_round]
        num_opponent_defectors = np.count_nonzero(opponent_actions_prev == False)
        if not my_action:
            num_opponent_defectors += 1
        majority_defected = num_opponent_defectors > self.n_players / 2
        if majority_defected and trend_decreasing:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_384(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection
    based on stock levels and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock > 0.5 * self.capacity:
            prev_round = state.round_number - 1
            my_last_action = history.my_actions[prev_round]
            opp_last_actions = history.opponent_actions[prev_round]
            total_coop = my_last_action + opp_last_actions.sum()
            if total_coop >= self.n_players / 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_385(BaseStrategy):
    """
    Exploitative Strategy for Common Pool Resource Game balancing cooperation and exploitation.
    Cooperates initially, defects in the last round, and adapts based on opponents' behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        game_info = self.game_description
        n_rounds_total = game_info.n_rounds
        round_number = state.round_number
        capacity = game_info.capacity
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        if round_number == n_rounds_total - 1:
            return Action.D
        if current_stock / capacity < 0.2:
            return Action.D
        if history is None:
            return Action.C
        opponent_actions = history.opponent_actions
        n_opponents = opponent_actions.shape[1]
        current_round = round_number
        for opponent_idx in range(n_opponents):
            count_defect = np.sum(~opponent_actions[:current_round, opponent_idx])
            rate_defect = count_defect / current_round
            if rate_defect > 0.3:
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_386(BaseStrategy):
    """
    Adaptive Cooperate or Defect (ACD) strategy. Cooperates initially and 
    adapts based on others' defection rate and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_opponents = self.n_players - 1
        self.thresh_defect = 0.5
        self.stock_thresh = 0.2 * self.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions_last_round = history.opponent_actions[-1]
        sum_coop = np.sum(opponent_actions_last_round)
        num_defectors = self.n_opponents - sum_coop
        prop_defectors = num_defectors / self.n_opponents
        current_stock = state.current_stock
        if prop_defectors > self.thresh_defect and current_stock > self.stock_thresh:
            return Action.D
        elif current_stock <= self.stock_thresh:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_387(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.recovery_mode = False
        self.consecutive_coop = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.r - 1:
            return Action.D
        if self.recovery_mode:
            self.consecutive_coop += 1
            if self.consecutive_coop >= 2:
                self.recovery_mode = False
                self.consecutive_coop = 0
            return Action.C
        current_stock = state.current_stock
        if current_stock < 0.3 * self.capacity:
            self.recovery_mode = True
            self.consecutive_coop = 1
            return Action.C
        if state.round_number == 0:
            return Action.C
        if state.round_number < self.r // 2:
            return Action.C
        if state.round_number >= 3 * self.r // 4:
            return Action.D
        if current_stock < 0.5 * self.capacity:
            return Action.C
        if history is None:
            return Action.D
        my_last_action = history.my_actions[state.round_number - 1]
        defector_count = 0
        if not my_last_action:
            defector_count += 1
        last_opponents = history.opponent_actions[state.round_number - 1, :]
        for a in last_opponents:
            if not a:
                defector_count += 1
        if defector_count > self.n / 2 or current_stock < 0.75 * self.capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_388(BaseStrategy):
    """
    A strategy that cooperates in the first round and then cooperates if the stock is below 50% 
    of capacity, otherwise defects to maximize personal gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            threshold = self.capacity * 0.5
            if state.current_stock < threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_389(BaseStrategy):
    """
    A strategy that cooperates initially, then defects in the last round, 
    cooperates if the current stock is above a certain threshold before the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            total_rounds = self.game_description.n_rounds
            current_round = state.round_number
            remaining_rounds = total_rounds - current_round
            threshold = self.game_description.capacity * (remaining_rounds / total_rounds)
            if state.current_stock > threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_390(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if state.round_number == n_rounds - 1:
            return Action.D
        if state.current_stock < 0.3 * capacity:
            return Action.C
        if state.round_number < 2:
            return Action.C
        prev_round = state.round_number - 1
        opponents_last_round = history.opponent_actions[prev_round]
        n_defectors = np.count_nonzero(opponents_last_round == False)
        above_70 = state.current_stock > 0.7 * capacity
        fewer_than_half = n_defectors < n_players / 2
        if above_70 and fewer_than_half:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_391(BaseStrategy):
    """
    Exploitative Strategy for Common Pool Resource Game.
    Cooperates initially and adapts based on stock levels and cooperation rates.
    Defects in the endgame if stock is sufficient.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_r = self.game_description.n_rounds
        endgame_threshold = int(0.1 * n_r)
        endgame = endgame_threshold > 0 and state.round_number >= n_r - endgame_threshold
        if endgame:
            capacity = self.game_description.capacity
            if state.current_stock > 0.3 * capacity:
                return Action.D
        t_prev = state.round_number - 1
        my_action_prev = history.my_actions[t_prev]
        opponent_actions_prev = history.opponent_actions[t_prev]
        n_players = self.game_description.n_players
        total_coop_prev = sum(opponent_actions_prev) + (1 if my_action_prev else 0)
        coop_condition = total_coop_prev * 2 >= n_players
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        stock_condition_high = current_stock > 0.7 * capacity
        stock_condition_low = current_stock < 0.3 * capacity
        if stock_condition_high and coop_condition:
            return Action.C
        elif stock_condition_low or not coop_condition:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_393(BaseStrategy):
    """
    A strategy designed for the Common Pool Resource game that adapts to both the actions of other players and the current stock level.
    It cooperates initially, defects in the final rounds, and switches based on recent defection levels and stock sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        r = self.game_description.n_rounds
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        if state.round_number >= r - 2:
            return Action.D
        previous_round = state.round_number - 1
        previous_actions = history.opponent_actions[previous_round, :]
        defectors = np.sum(~previous_actions)
        stock_threshold = 0.5 * capacity
        if defectors / n > 0.5 or state.current_stock < stock_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_394(BaseStrategy):
    """
    An adaptive exploitation strategy for the Common Pool Resource Game.
    Cooperates initially and in low stock conditions, defects in the last round, 
    and uses a modified Tit-for-Tat with forgiveness otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = 0.2 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.current_stock <= self.threshold:
            return Action.C
        else:
            opponent_actions = history.opponent_actions[-1, :]
            cooperators = np.sum(opponent_actions)
            if cooperators > self.n_players / 2:
                return Action.C
            elif random.random() < 0.2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_395(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels and opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        half_capacity = self.game_description.capacity / 2.0
        current_stock = state.current_stock
        if current_stock > half_capacity:
            my_last_action = history.my_actions[-1]
            my_defect = 0 if my_last_action else 1
            opponent_actions_last_round = history.opponent_actions[-1]
            opponent_defects = sum((1 for action in opponent_actions_last_round if not action))
            total_defectors = my_defect + opponent_defects
            n_players = self.game_description.n_players
            if total_defectors >= n_players / 2:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_396(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        threshold = capacity / n_players
        current_stock = state.current_stock
        if current_stock < threshold:
            return Action.D
        current_round = state.round_number
        if history is not None:
            all_prev_opp = history.opponent_actions[:current_round]
            n_opp = all_prev_opp.shape[1] if all_prev_opp.size > 0 else 0
            if n_opp > 0:
                sum_coop = np.sum(all_prev_opp)
                sum_defec = n_opp * current_round - sum_coop
                if sum_defec > n_opp * current_round * 0.5:
                    return Action.D
        if len(self.stock_history) >= 2:
            last_stock = self.stock_history[-1]
            prev_stock = self.stock_history[-2]
            if last_stock < prev_stock:
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_397(BaseStrategy):
    """
    Adaptive Exploitation with Stock Sustainability Strategy.

    This strategy balances exploiting high stock levels with conserving when necessary,
    ensuring long-term sustainability while adapting to others' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            stock_pct = current_stock / self.capacity
            if stock_pct > 0.75:
                return Action.D
            elif stock_pct < 0.5:
                return Action.C
            else:
                prev_round = state.round_number - 1
                my_prev_action = bool(history.my_actions[prev_round])
                opponent_actions_prev = history.opponent_actions[prev_round]
                my_coop = 1 if my_prev_action else 0
                opponent_coop_sum = sum(opponent_actions_prev)
                total_coop = my_coop + opponent_coop_sum
                half_players = self.n_players / 2
                if total_coop < half_players:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_398(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that dynamically reacts to stock levels and opponents' actions.
    It seeks to balance immediate gains with sustainability by adaptively choosing between cooperation and defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_stock = 0.25 * self.capacity
        self.consecutive_d_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            if current_stock < self.threshold_stock:
                action = Action.C
            else:
                last_round_actions = history.opponent_actions[-1]
                n_opponents = len(last_round_actions)
                sum_coop = np.sum(last_round_actions)
                n_defect = n_opponents - sum_coop
                percent_defect = n_defect / n_opponents
                if percent_defect > 0.5:
                    action = Action.D
                else:
                    action = Action.C
            if action == Action.D:
                self.consecutive_d_count += 1
                if self.consecutive_d_count > 2:
                    action = Action.C
                    self.consecutive_d_count = 0
            else:
                self.consecutive_d_count = 0
            return action

class Strategy_EXPLOITATIVE_399(BaseStrategy):
    """
   Strategy that adapts based on historical actions and current stock level.
    Cooperates initially, defects if many others defected previously or if stock is low, and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            my_last_action = history.my_actions[-1]
            my_defection = 1 if my_last_action is False else 0
            opponent_last_round = history.opponent_actions[-1, :]
            opponent_defections = opponent_last_round.size - np.sum(opponent_last_round)
            D_prev = my_defection + opponent_defections
            threshold = self.game_description.capacity / 2
            if D_prev >= self.game_description.n_players / 2:
                return Action.D
            elif state.current_stock < threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_401(BaseStrategy):
    """Adaptive strategy balancing cooperation and defection based on stock level and others' behavior."""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            threshold = 0.2 * capacity
            if current_stock < threshold:
                return Action.C
            t = len(history.opponent_actions)
            n_opponents = self.game_description.n_players - 1
            max_possible = t * n_opponents
            sum_defects = 0
            for round_idx in range(t):
                for opp_idx in range(n_opponents):
                    if not history.opponent_actions[round_idx, opp_idx]:
                        sum_defects += 1
            avg_defect = sum_defects / max_possible if max_possible != 0 else 0.0
            if avg_defect > 0.5:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_402(BaseStrategy):
    """
    Exploitative Strategy for Common Pool Resource Game:
    - Cooperates to sustain resources initially.
    - Defects when beneficial or in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            capacity = self.game_description.capacity
            threshold = 0.3 * capacity
            current_stock = state.current_stock
            if current_stock < threshold:
                return Action.C
            else:
                previous_round = state.round_number - 1
                prev_my_action = history.my_actions[previous_round]
                my_defected = 0 if prev_my_action else 1
                prev_opponent_actions = history.opponent_actions[previous_round, :]
                n_cooperators_opponents = sum(prev_opponent_actions)
                n_defectors_opponents = len(prev_opponent_actions) - n_cooperators_opponents
                total_defectors = n_defectors_opponents + my_defected
                n_players = self.game_description.n_players
                if total_defectors > n_players / 2:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_403(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on others' recent actions 
    and the current stock level in a Common Pool Resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_stock = None
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
            self.prev_stock = state.current_stock
        elif state.round_number == self.n_rounds - 1:
            action = Action.D
            self.prev_stock = state.current_stock
        elif self.prev_stock is None:
            action = Action.C
        else:
            S_prev = self.prev_stock
            if history is None or len(history.opponent_payoffs) == 0:
                action = Action.C
            else:
                payoffs_last_round = history.opponent_payoffs[-1]
                defectors = 0
                for payoff in payoffs_last_round:
                    expected_defect = S_prev / self.n_players
                    if abs(payoff - expected_defect) < 1e-09:
                        defectors += 1
                total_opponents = len(payoffs_last_round)
                if total_opponents == 0:
                    action = Action.C
                else:
                    defector_ratio = defectors / total_opponents
                    current_stock_percent = state.current_stock / self.capacity
                    if defector_ratio > 0.5:
                        action = Action.D
                    elif current_stock_percent > 0.7:
                        action = Action.D
                    elif current_stock_percent < 0.2:
                        action = Action.C
                    else:
                        action = Action.C
            self.prev_stock = state.current_stock
        return action

class Strategy_EXPLOITATIVE_404(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game, balancing between cooperation
    and defection based on previous actions and current stock levels to maximize long-term payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            previous_round_num = state.round_number - 1
            my_prev_action = history.my_actions[previous_round_num]
            opp_prev_actions = history.opponent_actions[previous_round_num]
            defectors = 0
            if not my_prev_action:
                defectors += 1
            defectors += np.sum(opp_prev_actions == False)
            threshold = self.game_description.n_players / 2
            if defectors > threshold:
                return Action.D
            elif state.current_stock < 0.2 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_405(BaseStrategy):
    """
    A hybrid strategy combining exploitative and conservative behaviors in a Common Pool Resource game.
    It adapts decisions based on stock levels, past opponent actions, and dynamic thresholds to balance exploitation and conservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.stock_threshold = 0.75
        self.punishment_threshold = 0.5
        self.stock_history = []
        self.last_defectors_count = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.D
        if state.round_number == self.n_rounds - 1:
            self.stock_history.append(state.current_stock)
            return Action.D
        current_stock = state.current_stock
        self.stock_history.append(current_stock)
        if len(self.stock_history) >= 2:
            change = current_stock - self.stock_history[-2]
            if change < 0:
                self.stock_threshold *= 0.99
            else:
                self.stock_threshold = min(0.75, self.stock_threshold * 1.01)
            self.stock_threshold = max(0.25, self.stock_threshold)
        last_round = state.round_number - 1
        last_opponent_actions = history.opponent_actions[last_round]
        num_defectors_last = len(last_opponent_actions) - np.count_nonzero(last_opponent_actions)
        self.last_defectors_count = num_defectors_last
        n_opponents = self.n_players - 1
        threshold_defectors = self.punishment_threshold * n_opponents
        if current_stock < 0.25 * self.capacity:
            return Action.C
        if num_defectors_last > threshold_defectors:
            return Action.D
        if current_stock < self.stock_threshold * self.capacity:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_406(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on cooperation rates and stock levels.
    Cooperates initially, defects in the last round, and adapts based on previous actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        sum_C = 0
        for r in range(state.round_number):
            my_C = 1 if history.my_actions[r] else 0
            opponents_C = history.opponent_actions[r, :].sum()
            sum_C += my_C + opponents_C
        t_prev = state.round_number
        n_players = self.game_description.n_players
        C_rate = sum_C / (n_players * t_prev)
        capacity_half = self.game_description.capacity / 2.0
        if C_rate > 0.5 and state.current_stock > capacity_half:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_407(BaseStrategy):
    """
    Implements the Adaptive Exploitation strategy for the Common Pool Resource Game.
    Cooperates initially, then adapts based on stock trends, defecting in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        self.stock_history.append(state.current_stock)
        recent_stocks = self.stock_history[-2:]
        decreasing = recent_stocks[0] > recent_stocks[1]
        below_threshold = recent_stocks[-1] < 0.5 * self.game_description.capacity
        if decreasing and below_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_408(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation with strategic defection.
    It cooperates initially, defects if the majority of players defected previously, defects if stock is below half capacity, and always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        stock_threshold = capacity / 2
        current_stock = state.current_stock
        if current_stock < stock_threshold:
            return Action.D
        my_last_action = history.my_actions[-1]
        opponent_actions_last = history.opponent_actions[-1]
        my_defection = 0 if my_last_action else 1
        opponent_defections = np.count_nonzero(~opponent_actions_last)
        total_defections = my_defection + opponent_defections
        n_players = self.game_description.n_players
        if total_defections > n_players / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_409(BaseStrategy):
    """Exploitative Strategy for Common Pool Resource Game.

    This strategy aims to maximize total payoff by balancing immediate gains with sustainable stock management.
    It cooperates in the first round, defects in the last round, and uses a threshold-based approach with historical
    adaptation in subsequent rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        if t == 0:
            return Action.C
        elif t == n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            if current_stock < 0.3 * capacity:
                return Action.C
            total_defectors = 0
            for round in range(t):
                my_defection = not history.my_actions[round]
                opp_defectors = np.count_nonzero(history.opponent_actions[round] == False)
                total_defectors += my_defection + opp_defectors
            average_defection = total_defectors / t
            defect_threshold = 0.7 * capacity
            if current_stock > defect_threshold and average_defection < 0.5:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_410(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        elif state.current_stock <= 0.2 * self.game_description.capacity:
            return Action.C
        else:
            previous_round = state.round_number - 1
            my_coop = history.my_actions[previous_round]
            opponent_coop = np.sum(history.opponent_actions[previous_round])
            sum_coop = my_coop + opponent_coop
            threshold = self.game_description.n_players / 2
            if sum_coop < threshold:
                self.punishment_remaining = 2
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_411(BaseStrategy):
    """
    A dynamic strategy balancing cooperation and defection based on stock levels and historical consumption.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        self.stock_history.append(state.current_stock)
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if current_round == 0:
            return Action.C
        if current_round == total_rounds - 1:
            return Action.D
        if state.current_stock < 0.2 * capacity:
            return Action.D
        prev_round = current_round - 1
        prev_stock = self.stock_history[prev_round]
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        k_cooperate = sum(opponent_prev_actions) + (1 if my_prev_action else 0)
        total_consumption = k_cooperate * (prev_stock / (2 * n)) + (n - k_cooperate) * (prev_stock / n)
        if total_consumption > prev_stock / 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_413(BaseStrategy):
    """
    A strategy that adapts based on the current stock level to balance cooperation and defection in a common pool resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.round_number == 0:
            return Action.C
        else:
            stock = state.current_stock
            threshold_high = 0.75 * self.capacity
            threshold_mid = 0.5 * self.capacity
            if stock > threshold_high:
                return Action.D
            elif stock >= threshold_mid:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_415(BaseStrategy):
    """
    This strategy implements a dynamic approach to the Common Pool Resource Game.
    It starts by cooperating in the first round, defects in the last round, and
    uses the average cooperation rate of other players in previous rounds to decide
    whether to cooperate or defect in intermediate rounds. If the average cooperation
    rate exceeds 0.5, it defects to exploit others' cooperation; otherwise, it
    cooperates to maintain or increase the stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        total_coop = 0
        for prev_round in range(state.round_number):
            coops = np.sum(history.opponent_actions[prev_round])
            total_coop += coops
        avg_coop = total_coop / (state.round_number * (self.game_description.n_players - 1))
        if avg_coop > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_416(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Common Pool Resource Game.
    Cooperates initially, then dynamically adjusts based on stock level and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        s = state.round_number
        r = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n = self.game_description.n_players
        if s == r - 1:
            if current_stock > 0:
                return Action.D
            else:
                return Action.C
        remaining_rounds = r - s
        threshold = 0.75 * (remaining_rounds / r) * capacity
        defect_due_to_stock = current_stock < threshold
        total_opponents = n - 1
        opponent_actions = history.opponent_actions if history is not None else None
        if opponent_actions is not None and len(opponent_actions) > 0:
            opponent_defections = []
            for t in range(s):
                round_actions = opponent_actions[t]
                round_defections = sum((1 for action in round_actions if not action))
                opponent_defections.append(round_defections)
            total_defections = sum(opponent_defections)
            total_possible = len(opponent_defections) * total_opponents
            avg_defection = total_defections / total_possible if total_possible > 0 else 0.0
            defect_due_to_opponents = avg_defection >= 0.5
        else:
            defect_due_to_opponents = False
        if defect_due_to_stock or defect_due_to_opponents:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_417(BaseStrategy):
    """
    A strategy that begins by cooperating, then uses recent stock levels to decide.
    It defects when the average stock level of the past three rounds is below half the capacity
    or in the last two rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_levels = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_levels.append(state.current_stock)
        if state.round_number == 0:
            return Action.C
        else:
            if state.round_number >= self.game_description.n_rounds - 2:
                return Action.D
            if len(self.stock_levels) >= 3:
                average = sum(self.stock_levels[-3:]) / 3
                if average < self.game_description.capacity / 2:
                    return Action.D
            return Action.C

class Strategy_EXPLOITATIVE_418(BaseStrategy):
    """
    A strategy for the Common Pool Resource game that balances cooperation and defection.
    It adapts based on the stock level, opponents' actions, and the stage of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number in (0, 1):
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_stock < 0.3 * capacity:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 3 and current_stock > 0.5 * capacity:
            return Action.D
        prev_opponent_actions = history.opponent_actions[-1, :]
        n_players = self.game_description.n_players
        defectors = np.sum(~prev_opponent_actions)
        if defectors > n_players / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_420(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource game that balances cooperation and defection.
    Cooperates initially, defects in the final rounds, and adapts based on others' actions and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == 1:
            return Action.C
        elif state.round_number >= self.n_rounds - 2:
            return Action.D
        else:
            if history is None:
                return Action.C
            my_last_action = history.my_actions[-1]
            opp_last_actions = history.opponent_actions[-1, :]
            total_coop = np.sum(opp_last_actions) + (1 if my_last_action else 0)
            coop_percent = total_coop / self.n_players
            stock = state.current_stock
            if coop_percent >= 0.8 and stock > 0.25 * self.capacity:
                return Action.C
            elif stock <= 0.25 * self.capacity:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_421(BaseStrategy):
    """
    Adaptive Exploitation strategy for the Common Pool Resource game.
    Balances cooperation and defection based on observed behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        is_last_two_rounds = current_round >= n_rounds - 2
        k = 3
        start_round = max(0, current_round - 1 - (k - 1))
        end_round = current_round - 1
        n_opponents = n_players - 1
        is_any_cdefector = False
        for opponent in range(n_opponents):
            selected = history.opponent_actions[start_round:end_round + 1, opponent]
            coop_count = selected.sum()
            total_rounds_analyzed = end_round - start_round + 1
            if total_rounds_analyzed == 0:
                continue
            coop_rate = coop_count / total_rounds_analyzed
            if coop_rate < 0.2:
                is_any_cdefector = True
                break
        if is_any_cdefector:
            return Action.D
        if not is_last_two_rounds:
            start_middle = max(0, current_round - 3)
            end_middle = current_round - 1
            coop_rounds = history.my_actions[start_middle:end_middle + 1].sum()
            opp_coop = history.opponent_actions[start_middle:end_middle + 1].sum(axis=1).sum()
            total_coop = coop_rounds + opp_coop
            avg_coop = total_coop / ((end_middle - start_middle + 1) * n_players) if end_middle - start_middle + 1 > 0 else 0
            return Action.C if avg_coop >= 0.5 else Action.D
        elif state.current_stock / capacity >= 0.9:
            return Action.D
        else:
            my_prev_action = history.my_actions[current_round - 1]
            opp_prev_actions = history.opponent_actions[current_round - 1]
            total_prev_coop = my_prev_action + opp_prev_actions.sum()
            prev_coop_rate = total_prev_coop / n_players
            return Action.C if prev_coop_rate >= 0.5 else Action.D

class Strategy_EXPLOITATIVE_422(BaseStrategy):
    """
    Adaptive Threshold Exploitation (ATE) strategy for the Common Pool Resource Game.
    This strategy balances immediate gains with long-term sustainability by adapting to the current stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        ratio = state.current_stock / capacity
        if ratio > 0.75:
            return Action.D
        elif 0.5 <= ratio <= 0.75:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_425(BaseStrategy):
    """
    Exploitative Strategy for the Common Pool Resource game. 
    This strategy cooperates initially to encourage cooperation, defects in critical situations, 
    and adapts based on stock levels and previous actions. It always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        if current_round == self.n_rounds - 1:
            return Action.D
        stock = state.current_stock
        if stock < 0.2 * self.capacity:
            return Action.D
        if stock > 0.5 * self.capacity:
            opponent_actions = history.opponent_actions[-1, :]
            n_cooperators = np.sum(opponent_actions)
            if n_cooperators >= self.n_players / 2:
                return Action.C
            else:
                return Action.D
        else:
            my_payoff = history.my_payoffs[-1]
            opponent_payoffs = history.opponent_payoffs[-1, :]
            sum_opponents = np.sum(opponent_payoffs)
            total = my_payoff + sum_opponents
            avg_payoff = total / self.n_players
            if my_payoff < avg_payoff:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_426(BaseStrategy):
    """
    A strategy combining initial cooperation, reactive adjustments based on resource consumption, 
    and endgame exploitation to balance individual gains and resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        endgame_cutoff = 0.9 * (self.n_rounds - 1)
        if state.round_number >= endgame_cutoff:
            return Action.D
        previous_round = state.round_number - 1
        my_prev_payoff = history.my_payoffs[previous_round]
        opp_prev_payoffs = history.opponent_payoffs[previous_round]
        total_consumption = my_prev_payoff + opp_prev_payoffs.sum()
        if total_consumption > self.capacity / 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_427(BaseStrategy):
    """
    Trends-following strategy with hysteresis. Starts by cooperating, switches to defecting 
    after two consecutive stock decreases, and reverts to cooperating after two consecutive 
    stock increases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_stock = None
        self.current_mode = 'C'
        self.consecutive_decreases = 0
        self.consecutive_increases = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.prev_stock = state.current_stock
            return Action.C
        current_stock = state.current_stock
        delta = current_stock - self.prev_stock
        if delta < 0:
            self.consecutive_decreases += 1
            self.consecutive_increases = 0
        elif delta > 0:
            self.consecutive_increases += 1
            self.consecutive_decreases = 0
        else:
            self.consecutive_decreases = 0
            self.consecutive_increases = 0
        if self.current_mode == 'C':
            if self.consecutive_decreases >= 2:
                self.current_mode = 'D'
                self.consecutive_decreases = 0
                self.consecutive_increases = 0
        elif self.current_mode == 'D':
            if self.consecutive_increases >= 2:
                self.current_mode = 'C'
                self.consecutive_decreases = 0
                self.consecutive_increases = 0
        action = Action.C if self.current_mode == 'C' else Action.D
        self.prev_stock = current_stock
        return action

class Strategy_EXPLOITATIVE_428(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection.
    It cooperates initially, defects in the last round, and adjusts based on stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        elif state.current_stock < 0.25 * self.game_description.capacity:
            action = Action.C
        elif state.round_number == 0:
            action = Action.C
        elif self.last_stock is None:
            action = Action.C
        elif state.current_stock < self.last_stock:
            action = Action.D
        else:
            action = Action.C
        self.last_stock = state.current_stock
        return action

class Strategy_EXPLOITATIVE_429(BaseStrategy):
    """
    Adaptive Cooperation with Triggered Defection Strategy.

    Cooperates initially, then defects if others' actions result in a lower stock than expected under full cooperation.
    Defects in the last round regardless.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.triggered_defection = False
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
            self.previous_stock = state.current_stock
        elif state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
            self.previous_stock = state.current_stock
        else:
            if self.triggered_defection:
                action = Action.D
            else:
                if self.previous_stock is not None:
                    n = self.game_description.n_players
                    capacity = self.game_description.capacity
                    S_prev = self.previous_stock
                    expected_total_C = S_prev / 2
                    S_remaining = S_prev - expected_total_C
                    growth = 2 * S_remaining * (1 - S_remaining / capacity)
                    expected_new_stock = min(S_remaining + growth, capacity)
                    actual_new_stock = state.current_stock
                    if actual_new_stock < expected_new_stock:
                        self.triggered_defection = True
                action = Action.D if self.triggered_defection else Action.C
            self.previous_stock = state.current_stock
        return action

class Strategy_EXPLOITATIVE_430(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation with strategic defection.
    Cooperates initially, adapts based on stock levels and previous cooperation rates, and defects in the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        prev_actions = history.opponent_actions[prev_round, :]
        prev_coop_count = np.sum(prev_actions)
        prev_coop_rate = prev_coop_count / self.game_description.n_players
        if state.round_number >= 0.75 * self.game_description.n_rounds:
            return Action.D
        stock = state.current_stock
        capacity = self.game_description.capacity
        stock_threshold_high = 0.75 * capacity
        stock_threshold_low = 0.5 * capacity
        if stock > stock_threshold_high and prev_coop_rate >= 0.5:
            return Action.C
        elif stock < stock_threshold_low:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_431(BaseStrategy):
    """
    A strategy that adapts based on the stock trends, cooperating initially, then defecting if the stock shows a declining trend or drops below 80% of capacity, while defecting in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        round_number = state.round_number
        capacity = self.game_description.capacity
        if round_number == 0:
            return Action.C
        elif round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            if current_stock < 0.8 * capacity:
                return Action.D
            stock_history_len = len(self.stock_history)
            if stock_history_len >= 3:
                s_prev = self.stock_history[-2]
                s_prev_prev = self.stock_history[-3]
                s_current = self.stock_history[-1]
                if s_current < s_prev and s_prev < s_prev_prev:
                    return Action.D
            elif stock_history_len >= 2:
                s_prev = self.stock_history[-2]
                s_current = self.stock_history[-1]
                if s_current < s_prev:
                    return Action.D
            return Action.C

class Strategy_EXPLOITATIVE_432(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that dynamically adapts based on stock levels and opponent cooperation.
    - Cooperates in the first round.
    - Defects in the last round.
    - Defects if the stock falls below 25% of capacity.
    - Cooperates if opponents' average cooperation rate exceeds 50%.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        capacity = self.game_description.capacity
        if state.current_stock < 0.25 * capacity:
            return Action.D
        total_coop = history.opponent_actions.sum()
        total_possible = history.opponent_actions.size
        avg_coop = total_coop / total_possible
        if avg_coop > 0.5:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_433(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on stock levels and remaining rounds.
    Cooperates when the stock is low, defects when stock is high, and always defects in the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        threshold_rounds = n_rounds * 0.2
        remaining = n_rounds - state.round_number
        if remaining <= threshold_rounds:
            return Action.D
        else:
            capacity = self.game_description.capacity
            half_capacity = 0.5 * capacity
            if state.current_stock > half_capacity:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_434(BaseStrategy):
    """
    Adaptive Exploitation with Conservation (AEC) strategy for the Common Pool Resource Game.
    This strategy cooperates in the first round, defects in the last round, and adapts based on 
    previous actions and stock levels to balance exploitation and resource conservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_actions = history.opponent_actions[-1, :]
        defectors = sum((1 for action in prev_actions if action == Action.D))
        avg_defect = defectors / self.game_description.n_players
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if avg_defect > 0.5:
            if current_stock / capacity < 0.25 and state.round_number != self.game_description.n_rounds - 1:
                return Action.C
            else:
                return Action.D
        elif current_stock / capacity > 0.75:
            if current_stock / capacity < 0.9:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_435(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances immediate gains with long-term sustainability.
    Cooperates in the first round, defects in the last round, and adapts based on others' behavior and stock levels in middle rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        prev_actions = history.opponent_actions[prev_round, :]
        n_defectors = sum((1 for a in prev_actions if not a))
        n_opponents = len(prev_actions)
        proportion_defect = n_defectors / n_opponents
        if proportion_defect > 0.5:
            return Action.D
        else:
            stock_threshold = 0.3 * self.game_description.capacity
            if state.current_stock < stock_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_436(BaseStrategy):
    """
    Adaptive Reciprocal Conservation Strategy (ARC).
    Cooperates initially, reciprocates based on others' actions, 
    conserves when stock is low or depleting, and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            self.stock_history.append(state.current_stock)
            current_stock = state.current_stock
            if history:
                prev_opp_actions = history.opponent_actions[-1, :]
                n_coop_prev = sum(prev_opp_actions)
                opponents_count = self.game_description.n_players - 1
                if n_coop_prev <= opponents_count / 2:
                    return Action.D
                else:
                    capacity = self.game_description.capacity
                    if current_stock < 0.2 * capacity:
                        return Action.C
                    if len(self.stock_history) >= 2:
                        prev_stock = self.stock_history[-2]
                        if current_stock < prev_stock:
                            return Action.C
                        elif current_stock >= 0.8 * capacity:
                            return Action.D
                        else:
                            return Action.C
                    else:
                        return Action.C
            else:
                return Action.C

class Strategy_EXPLOITATIVE_437(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances 
    cooperation with exploitation based on observed game outcomes.
    It starts with cooperation, adapts based on moving average of payoffs, 
    and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.window_size = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        if round_number == 0:
            return Action.C
        if round_number == total_rounds - 1:
            return Action.D
        if history is None:
            return Action.C
        my_payoffs = history.my_payoffs
        if len(my_payoffs) == 0:
            return Action.C
        current_payoff = my_payoffs[-1]
        window_start = max(0, len(my_payoffs) - self.window_size)
        recent_payoffs = my_payoffs[window_start:]
        if len(recent_payoffs) == 0:
            return Action.C
        average = np.mean(recent_payoffs)
        threshold = 0.8 * average
        if current_payoff < threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_438(BaseStrategy):
    """
    This strategy starts by cooperating to observe others, then adapts based on stock level, 
    opponents' defection rate, and stock trend, defecting in the last round to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C
        elif state.round_number == n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            threshold = 0.5 * capacity
            if current_stock < threshold:
                return Action.C
            t = state.round_number
            opponent_actions = history.opponent_actions[:t, :]
            inverted = ~opponent_actions
            total_defections = np.sum(inverted)
            average_defection_rate = total_defections / (t * (n_players - 1)) if t != 0 else 0.0
            if average_defection_rate > 0.5:
                return Action.D
            if len(self.stock_history) >= 3:
                s0 = self.stock_history[-3]
                s1 = self.stock_history[-2]
                s2 = self.stock_history[-1]
                if s1 < s0 and s2 < s1:
                    return Action.C
            return Action.D

class Strategy_EXPLOITATIVE_439(BaseStrategy):
    """
    Exploitative Strategy for Common Pool Resource Game.

    Cooperate initially to observe opponents, then adapt based on stock trends and opponents' historical actions.
    Defects if stock is low, decreasing, or many opponents have defected historically.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_levels = []
        self.threshold = game_description.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_levels.append(state.current_stock)
        t = state.round_number
        if t == 0:
            return Action.C
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        threshold = self.threshold
        if t == n_rounds - 1:
            if current_stock < threshold:
                return Action.D
            else:
                pass
        current_below_threshold = current_stock < threshold
        if len(self.stock_levels) >= 2:
            stock_down = self.stock_levels[-1] < self.stock_levels[-2]
        else:
            stock_down = False
        if history is not None and history.my_actions.size > 0:
            n_prev_rounds = history.my_actions.shape[0]
            sum_defectors = 0.0
            for r in range(n_prev_rounds):
                num_C = sum(history.opponent_actions[r, :])
                num_D = n_players - 1 - num_C
                sum_defectors += num_D
            avg_defectors = sum_defectors / n_prev_rounds
        else:
            avg_defectors = 0.0
        avg_defector_threshold = (n_players - 1) * 0.5
        avg_high = avg_defectors > avg_defector_threshold
        if current_below_threshold or stock_down or avg_high:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_440(BaseStrategy):
    """
    Adaptive Reciprocal Exploitation Strategy (ARES)
    This strategy balances cooperation and defection based on observed behavior,
    promoting reciprocity while maintaining stock sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if history is None:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock < 0.25 * capacity:
            return Action.C
        last_round_index = len(history.my_actions) - 1
        opp_actions_last_round = history.opponent_actions[last_round_index, :]
        avg_coop_last = opp_actions_last_round.sum() / self.game_description.n_players
        if avg_coop_last > 0.5:
            return Action.C
        trend = 0.0
        if len(history.my_actions) >= 2:
            second_last_index = last_round_index - 1
            opp_actions_second_last = history.opponent_actions[second_last_index, :]
            avg_coop_second = opp_actions_second_last.sum() / self.game_description.n_players
            trend = avg_coop_last - avg_coop_second
        if trend > 0:
            if random.random() < 0.2:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_441(BaseStrategy):
    """
    Adaptive strategy for the Common Pool Resource Game that balances cooperation and exploitation based on stock levels and historical player behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        stock_threshold = capacity / 2
        if current_stock < stock_threshold:
            return Action.C
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opponents_prev_actions = history.opponent_actions[previous_round, :]
        total_coop = 1 if my_prev_action else 0
        total_coop += opponents_prev_actions.sum()
        cooperation_rate = total_coop / self.game_description.n_players
        if cooperation_rate > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_443(BaseStrategy):
    """
    A strategy that adapts based on the stock level and previous cooperation rates,
    defecting in the final round to maximize immediate payoff while encouraging cooperation
    in earlier rounds to maintain a sustainable stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        required_cooperators = (self.game_description.n_players + 1) // 2
        my_previous_action = history.my_actions[-1]
        my_coop = 1 if my_previous_action else 0
        opponent_actions_last_round = history.opponent_actions[-1]
        opponent_coops = np.sum(opponent_actions_last_round)
        total_cooperators = my_coop + opponent_coops
        current_stock = state.current_stock
        stock_threshold = 0.25 * self.game_description.capacity
        if current_stock > stock_threshold:
            if total_cooperators >= required_cooperators:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_444(BaseStrategy):
    """
    A strategy that adapts based on stock levels and opponents' cooperation rates.
    Cooperates initially, then uses thresholds to decide actions in subsequent rounds.
    Prioritizes sustainability when stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock < 0.3 * capacity:
            return Action.C
        elif current_stock <= 0.5 * capacity:
            return Action.D
        else:
            prev_round = state.round_number - 1
            opponent_actions_last_round = history.opponent_actions[prev_round, :]
            n_opponents = self.game_description.n_players - 1
            avg_coop = opponent_actions_last_round.sum() / n_opponents
            if avg_coop > 0.7:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_449(BaseStrategy):
    """
    Adaptive Threshold Exploitation Strategy for Common Pool Resource Game.
    
    This strategy balances cooperation with self-interest by adapting based on the stock level and the proportion of defecting opponents.
    It cooperates initially, defects in the last round, and switches to defecting if the stock is too low or if more than half of the opponents have defected historically.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock <= 0.25 * self.capacity:
            return Action.D
        prev_rounds = state.round_number
        if prev_rounds == 0:
            return Action.C
        total_D = 0
        for r in range(prev_rounds):
            round_actions = history.opponent_actions[r]
            sum_actions = np.sum(round_actions)
            D_count = len(round_actions) - sum_actions
            total_D += D_count
        threshold = 0.5 * self.n_players * prev_rounds
        if total_D > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_450(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Common Pool Resource Game.
    Balances exploitation and conservation based on cooperation rates and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        round_number = state.round_number
        total_coop = 0.0
        for t in range(round_number):
            my_action = history.my_actions[t]
            opponent_actions = history.opponent_actions[t, :]
            coop_count = int(my_action) + np.sum(opponent_actions)
            total_coop += coop_count
        average_coop = total_coop / round_number
        n = self.game_description.n_players
        stock = state.current_stock
        if average_coop > n / 2:
            return Action.D
        stock_pct = stock / self.capacity * 100
        if stock_pct < 30:
            return Action.C
        elif stock_pct > 70:
            return Action.D
        else:
            cooperate_prob = average_coop / n
            if random.random() < cooperate_prob:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_451(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.threshold = 0.75 * self.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            current_stock = state.current_stock
            if current_stock > self.threshold:
                return Action.D
            else:
                prev_round = state.round_number - 1
                my_prev_action = history.my_actions[prev_round]
                my_defect = 0 if my_prev_action else 1
                opponent_prev_actions = history.opponent_actions[prev_round]
                opponent_defects = (1 - opponent_prev_actions.astype(int)).sum()
                total_defectors = my_defect + opponent_defects
                half_players = self.n_players // 2
                if total_defectors > half_players:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_452(BaseStrategy):
    """
    A strategy combining reciprocity with opportunistic exploitation, adapting to stock levels and others' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.endgame_start = 0.8 * self.n_rounds
        self.threshold_stock_high = 0.8 * self.capacity
        self.threshold_stock_low = 0.1 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        current_round = state.round_number
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round >= self.endgame_start:
            return Action.D
        my_prev_action = history.my_actions[current_round - 1]
        my_prev_payoff = history.my_payoffs[current_round - 1]
        if my_prev_action:
            S_prev = 2 * self.n_players * my_prev_payoff
        else:
            S_prev = self.n_players * my_prev_payoff
        if my_prev_action:
            my_c = S_prev / (2 * self.n_players)
        else:
            my_c = S_prev / self.n_players
        op_actions = history.opponent_actions[current_round - 1, :]
        num_C_op = sum(op_actions)
        num_D_op = op_actions.size - num_C_op
        op_contrib_total = num_C_op * (S_prev / (2 * self.n_players)) + num_D_op * (S_prev / self.n_players)
        total_consumption_prev = my_c + op_contrib_total
        avg_consumption_prev = total_consumption_prev / self.n_players
        max_avg = S_prev / self.n_players
        threshold_avg = 0.75 * max_avg
        if avg_consumption_prev > threshold_avg:
            return Action.D
        my_c_prev = 1 if my_prev_action else 0
        op_c_prev = num_C_op
        proportion_c = (my_c_prev + op_c_prev) / self.n_players
        current_stock = state.current_stock
        if current_stock < self.threshold_stock_low:
            if proportion_c >= 0.5:
                return Action.C
            else:
                return Action.D
        elif current_stock > self.threshold_stock_high:
            if proportion_c < 0.5:
                return Action.D
            else:
                return Action.C
        elif proportion_c >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_453(BaseStrategy):
    """
    Implement an adaptive strategy for the Common Pool Resource game.
    Cooperates initially, then adapts based on stock levels, others' defection rates, and endgame proximity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.initial_coop_rounds = 2
        self.endgame_threshold = 3
        self.x_rounds = 2

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        elif round_num <= self.initial_coop_rounds:
            return Action.C
        else:
            current_stock = state.current_stock
            threshold = 0.75 * self.capacity
            if current_stock > threshold:
                return Action.C
            else:
                if round_num >= self.n_rounds - self.endgame_threshold:
                    return Action.D
                x = self.x_rounds
                start_round = max(0, round_num - x)
                total_defects = 0
                for r in range(start_round, round_num):
                    opponent_actions = history.opponent_actions[r]
                    defects = self.n_players - np.sum(opponent_actions)
                    total_defects += defects
                defect_rate = total_defects / (self.n_players * x)
                if defect_rate > 0.5:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_454(BaseStrategy):
    """
    A strategy that begins with initial rounds of cooperation, adapts based on stock levels and opponent cooperation rates,
    and defects in the final round to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.STOCK_THRESHOLD = 0.5 * self.capacity
        self.COOPERATION_THRESHOLD = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number < 3:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.STOCK_THRESHOLD:
            return Action.C
        if history is None:
            return Action.C
        prev_rounds = state.round_number
        total_coop = 0
        for round in range(prev_rounds):
            coop = np.sum(history.opponent_actions[round, :])
            total_coop += coop
        total_possible = prev_rounds * (self.n_players - 1)
        avg_coop = total_coop / total_possible if total_possible != 0 else 1.0
        if avg_coop > self.COOPERATION_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_455(BaseStrategy):
    """
    A strategy designed for the Common Pool Resource Game that balances cooperation 
    and defection based on the stock level and opponents' previous actions.
    It cooperates in the first round, defects in the last round, and uses a 
    threshold-based approach in intermediate rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        round_number = state.round_number
        if round_number == n_rounds - 1:
            return Action.D
        if round_number == 0:
            return Action.C
        previous_round = round_number - 1
        opponent_actions_prev = history.opponent_actions[previous_round]
        sum_coop = np.sum(opponent_actions_prev)
        n_opponents = self.game_description.n_players - 1
        cooperation_rate = sum_coop / n_opponents
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if cooperation_rate > 0.5 and current_stock > capacity / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_456(BaseStrategy):
    """
    A strategy that adapts based on previous round's defections and current stock level.
    Cooperates in the first round, defects in the last, and adjusts based on others' actions and stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            opponent_defectors = np.sum(opponent_actions_prev == False)
            my_prev_action = history.my_actions[prev_round]
            my_defection = 0 if my_prev_action else 1
            total_defectors = opponent_defectors + my_defection
            if total_defectors > self.n_players // 2:
                return Action.D
            else:
                stock_ratio = state.current_stock / self.capacity
                if stock_ratio > 0.75:
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_457(BaseStrategy):
    """
    Adaptive Cooperation with Stock Threshold strategy.
    Cooperates initially, then adapts based on majority actions and stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_threshold = 0.2 * self.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            my_prev = history.my_actions[-1]
            opp_prev = history.opponent_actions[-1, :]
            total_defectors = (0 if my_prev else 1) + np.sum(opp_prev == False)
            if state.current_stock > self.stock_threshold and total_defectors < self.n_players / 2:
                return Action.C
            else:
                return Action.D
        elif state.current_stock < self.stock_threshold:
            return Action.C
        else:
            my_prev = history.my_actions[-1]
            opp_prev = history.opponent_actions[-1, :]
            total_defectors = (0 if my_prev else 1) + np.sum(opp_prev == False)
            if total_defectors > self.n_players / 2:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_326(BaseStrategy):
    """
    A strategy that balances cooperation with stock preservation in a Common Pool Resource Game.
    It adapts dynamically based on the game's state and historical player actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        t = state.round_number
        if t == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        if t >= len(self.stock_history):
            self.stock_history.append(state.current_stock)
        if t == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        stock_pct = current_stock / capacity
        stock_decreasing = False
        if len(self.stock_history) >= 2:
            stock_decreasing = current_stock < self.stock_history[-2]
        prev_round = t - 1
        opp_actions_prev = history.opponent_actions[prev_round, :]
        cooperators_last = np.sum(opp_actions_prev)
        majority_last = cooperators_last >= self.game_description.n_players / 2
        if stock_pct > 0.75 and majority_last:
            return Action.C
        condition2 = False
        if stock_pct < 0.5:
            condition2 = True
        elif stock_decreasing and cooperators_last < self.game_description.n_players / 2:
            condition2 = True
        if condition2:
            return Action.D
        all_prev_actions = history.opponent_actions[:t, :]
        all_prev_actions = all_prev_actions.reshape(-1)
        total_coop = np.sum(all_prev_actions)
        total_actions = len(all_prev_actions)
        if total_actions == 0:
            avg_coop = 1.0
        else:
            avg_coop = total_coop / total_actions
        if avg_coop > 0.7:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_41(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Level Adjustment strategy.
    Cooperates initially, then adapts based on others' cooperation rate and stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        if capacity == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        threshold_low = 0.25 * capacity
        threshold_high = 0.9 * capacity
        if current_stock < threshold_low:
            return Action.C
        elif current_stock > threshold_high:
            return Action.D
        n_opponents = self.game_description.n_players - 1
        sum_coop = 0
        for j in range(n_opponents):
            for r in range(state.round_number):
                if history.opponent_actions[r, j]:
                    sum_coop += 1
        total_possible = state.round_number * n_opponents
        if total_possible == 0:
            avg_coop = 0.0
        else:
            avg_coop = sum_coop / total_possible
        if avg_coop > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_227(BaseStrategy):
    """
    Adaptive Exploitation Strategy for the Common Pool Resource Game.
    This strategy balances cooperation and defection by considering historical behavior,
    stock levels, and critical rounds to maximize payoffs while maintaining resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.3 * self.capacity:
            return Action.C
        if state.current_stock < 0.1 * self.capacity:
            return Action.C
        opponent_actions = history.opponent_actions
        n_opp = self.n_players - 1
        defection_rates = []
        for r in range(state.round_number):
            opp_defections = sum((1 for opp in range(opponent_actions.shape[1]) if not opponent_actions[r, opp]))
            rate = opp_defections / n_opp
            defection_rates.append(rate)
        weights = [0.5 ** (state.round_number - r - 1) for r in range(len(defection_rates))]
        total_weight = sum(weights)
        weighted_avg = sum((dr * w for dr, w in zip(defection_rates, weights))) / total_weight
        if weighted_avg > 0.5:
            return Action.D
        elif state.round_number % 3 == 0:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_243(BaseStrategy):
    """
    Strategy that adapts based on stock levels and others' cooperation rates.
    Cooperates initially, defects if stock is low or others defect frequently.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        stock_threshold = 0.7 * self.game_description.capacity
        current_stock = state.current_stock
        if current_stock < stock_threshold:
            return Action.D
        opponent_actions = history.opponent_actions
        n_opponents = self.game_description.n_players - 1
        total_rounds = state.round_number
        sum_C = 0
        for r in range(total_rounds):
            sum_C += np.sum(opponent_actions[r, :])
        total_possible_C = n_opponents * total_rounds if total_rounds > 0 else 1
        average_coop = sum_C / total_possible_C
        cooperation_threshold = 0.5
        if average_coop >= cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_266(BaseStrategy):
    """
    Adaptive Exploitation-Conservation Balance Strategy.
    Cooperates initially, then adapts based on stock levels and cooperation history.
    Defects in the final round to maximize immediate gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self._history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.round_number < 3:
            return Action.C
        else:
            current_stock = state.current_stock
            s_percent = current_stock / self.capacity * 100 if self.capacity != 0 else 0.0
            my_last = history.my_actions[-1]
            opp_last = history.opponent_actions[-1, :]
            coops_last = 1 if my_last else 0
            coops_last += sum(opp_last)
            coop_rate_last = coops_last / self.n_players
            if s_percent > 75 and coop_rate_last > 0.5:
                return Action.D
            elif s_percent < 50 or coop_rate_last < 0.4:
                return Action.C
            else:
                total_coop = 0.0
                for t in range(state.round_number):
                    my_action = history.my_actions[t]
                    opp_actions = history.opponent_actions[t, :]
                    coops = 1 if my_action else 0
                    coops += sum(opp_actions)
                    coop_rate = coops / self.n_players
                    total_coop += coop_rate
                average_coop = total_coop / state.round_number if state.round_number else 0.0
                return Action.C if average_coop > 0.5 else Action.D

class Strategy_EXPLOITATIVE_275(BaseStrategy):
    """
    Adaptive strategy based on stock trends and game progression.
    Cooperates initially, switches to defecting based on stock levels and trends, 
    and defects in the final rounds to maximize immediate gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = [game_description.capacity]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        self.stock_history.append(current_stock)
        if current_round >= total_rounds - 3:
            return Action.D
        capacity = self.game_description.capacity
        if current_stock < 0.01 * capacity:
            return Action.D
        if len(self.stock_history) >= 2:
            previous_stock = self.stock_history[-2]
        else:
            previous_stock = capacity
        if current_stock < previous_stock:
            trend = 'decreasing'
        else:
            trend = 'stable/increasing'
        if current_stock > 0.5 * capacity and trend != 'decreasing':
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_361(BaseStrategy):
    """
    Adaptive strategy for the Common Pool Resource Game that alternates between cooperation and defection based on observed behavior and stock levels.
    Cooperates initially, defects in the last round, and adapts based on the rate of cooperation and stock health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opponents_prev_actions = history.opponent_actions[prev_round, :]
        total_coop_prev = my_prev_action + sum(opponents_prev_actions)
        coop_rate_prev = total_coop_prev / self.n_players
        current_stock = state.current_stock
        if current_stock < self.n_players:
            return Action.D
        if coop_rate_prev < 0.25:
            return Action.D
        if coop_rate_prev >= 0.5:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_373(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game. 
    Cooperates initially to maximize payoffs and switches to defection 
    based on average payoffs and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        n_players = self.n_players
        capacity = self.capacity
        my_sum = np.sum(history.my_payoffs)
        opponent_sum = np.sum(history.opponent_payoffs)
        sum_total = my_sum + opponent_sum
        total_rounds = state.round_number
        average_payoff = sum_total / (total_rounds * n_players) if total_rounds != 0 else 0.0
        threshold = 0.75 * (capacity / n_players)
        stock_threshold = 0.25 * capacity
        if average_payoff <= threshold or state.current_stock < stock_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_392(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game.
    Cooperates when stock is sufficient and enough rounds remain; defects otherwise.
    Adapts by lowering cooperation threshold if stock trend is decreasing.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.round_stock = [game_description.capacity]
        self.cooperation_threshold = 0.5
        self.trend_down_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.round_stock.append(state.current_stock)
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.2 * self.capacity:
            return Action.D
        rounds_remain = self.n_rounds - state.round_number - 1
        total_rounds = self.n_rounds
        if rounds_remain > 0.25 * total_rounds:
            if state.current_stock > self.cooperation_threshold * self.capacity:
                base_decision = Action.C
            else:
                base_decision = Action.D
        else:
            base_decision = Action.D
        if len(self.round_stock) >= 2:
            prev_stock = self.round_stock[-2]
            current_stock = self.round_stock[-1]
            if current_stock < prev_stock:
                self.trend_down_count += 1
            else:
                self.trend_down_count = 0
            if self.trend_down_count >= 2:
                if self.cooperation_threshold > 0.2:
                    self.cooperation_threshold = max(0.2, self.cooperation_threshold - 0.1)
                return Action.D
        return base_decision

class Strategy_EXPLOITATIVE_400(BaseStrategy):
    """
    This strategy balances cooperation and defection based on stock trends and endgame factors.
    It cooperates initially, defects if the stock decreases, and defects in the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.prev_stock = state.current_stock
            return Action.C
        total_rounds = self.game_description.n_rounds
        endgame_threshold = 0.9 * total_rounds
        if state.round_number >= endgame_threshold:
            return Action.D
        if state.current_stock < self.prev_stock:
            return Action.D
        else:
            return Action.C
        self.prev_stock = state.current_stock

class Strategy_EXPLOITATIVE_412(BaseStrategy):
    """
    Adaptive Exploitation Strategy for the Common Pool Resource Game.

    This strategy balances exploiting opponents' cooperative behavior while maintaining sustainable stock levels.
    It adapts based on the current stock level, historical cooperation rates of opponents, and recent stock trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.recent_stock_levels = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.recent_stock_levels.append(state.current_stock)
        if len(self.recent_stock_levels) > 3:
            self.recent_stock_levels = self.recent_stock_levels[-3:]
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        if history is not None:
            n_rounds = state.round_number
            start_round = max(0, n_rounds - 3)
            selected_rounds = history.opponent_actions[start_round:n_rounds]
            sum_coop = np.sum(selected_rounds)
            total_actions = selected_rounds.size
            opponent_coop_rate = sum_coop / total_actions if total_actions > 0 else 0.0
            if opponent_coop_rate >= 0.5:
                return Action.D
            elif len(self.recent_stock_levels) >= 3:
                first_stock = self.recent_stock_levels[-3]
                current_stock = self.recent_stock_levels[-1]
                if current_stock <= first_stock:
                    return Action.C
                else:
                    opp_defection_rate = 1 - opponent_coop_rate
                    if opp_defection_rate >= 0.5:
                        return Action.D
                    else:
                        return Action.C
            elif len(self.recent_stock_levels) >= 2 and state.current_stock < self.recent_stock_levels[-2]:
                return Action.C
            else:
                return Action.D
        elif state.round_number == 0:
            return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_414(BaseStrategy):
    """
    Adaptive Exploitation Strategy for the Common Pool Resource Game.
    Cooperates initially, then adapts based on opponent behavior and stock levels.
    Defects in the last round to maximize immediate payoff.
    Switches to cooperation if stock falls below 50% of capacity.
    Defects if average defectors exceed 50% of players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        sum_defectors = 0
        for round in range(state.round_number):
            my_action = history.my_actions[round]
            my_defected = 0 if my_action else 1
            opponents_defected = sum((1 for action in history.opponent_actions[round] if not action))
            sum_defectors += my_defected + opponents_defected
        average_defectors = sum_defectors / state.round_number
        if state.current_stock < 0.5 * self.capacity:
            return Action.C
        if average_defectors > self.n_players * 0.5:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_419(BaseStrategy):
    """
    Exploitative Strategy for Common Pool Resource Game balancing short-term gains 
    with long-term sustainability by dynamically adjusting cooperation based on 
    others' behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.coop_history = []
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.2 * self.capacity:
            return Action.C
        if history is None:
            return Action.C
        my_last_action = history.my_actions[-1]
        sum_my = 1 if my_last_action else 0
        others_last_actions = history.opponent_actions[-1]
        sum_others = np.sum(others_last_actions)
        total_coop = sum_my + sum_others
        prev_coop = total_coop / self.n_players
        self.coop_history.append(prev_coop)
        if prev_coop >= 0.75:
            if random.random() < 0.8:
                return Action.D
            else:
                return Action.C
        elif prev_coop < 0.5:
            return Action.C
        else:
            mix = 0.6
            if len(self.coop_history) >= 2:
                trend = self.coop_history[-1] - self.coop_history[-2]
                if trend > 0:
                    mix = 0.5
                else:
                    mix = 0.7
            if random.random() < mix:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_423(BaseStrategy):
    """
    Adaptive strategy for the Common Pool Resource Game balancing cooperation and self-interest.
    - Cooperates initially.
    - Defects if stock is critically low or in endgame.
    - Defects if most opponents defected previously.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 3:
            return Action.D
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        last_round_actions = history.opponent_actions[-1]
        n_opponents = len(last_round_actions)
        sum_C = last_round_actions.sum()
        sum_D = n_opponents - sum_C
        if sum_D > n_opponents / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_424(BaseStrategy):
    """
    An adaptive exploitation strategy for the Common Pool Resource Game that 
    balances cooperation and defection based on stock levels and previous 
    cooperation rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        is_final_round = state.round_number == self.n_rounds - 1
        if is_final_round:
            if current_stock < 0.25 * self.capacity:
                return Action.D
        if current_stock > 0.75 * self.capacity:
            return Action.C
        elif current_stock < 0.25 * self.capacity:
            return Action.D
        else:
            previous_round = state.round_number - 1
            if previous_round < 0:
                return Action.C
            n_cooperators = sum(history.opponent_actions[previous_round, :])
            majority_size = (self.n_players + 1) // 2
            if n_cooperators >= majority_size:
                if current_stock > 0.5 * self.capacity:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_442(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and defection
    based on observed behavior and stock levels. It initially cooperates, then monitors defection
    rates and stock levels to decide actions, defecting in endgame rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        n = self.game_description.n_players
        if state.round_number < 3:
            return Action.C
        if state.round_number >= r - 2:
            return Action.D
        def_count = 0
        for prev_round in range(state.round_number):
            opponent_actions = history.opponent_actions[prev_round]
            def_count += sum((1 for action in opponent_actions if not action))
        total_actions = state.round_number * (n - 1)
        avg_def_rate = def_count / total_actions if total_actions > 0 else 0.0
        if state.current_stock < 0.5 * capacity:
            cooperation_threshold = 0.7
        else:
            cooperation_threshold = 0.3
        if avg_def_rate > cooperation_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_234(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        r = self.game_description.n_rounds
        n_initial = int(0.25 * r)
        if state.round_number < n_initial:
            return Action.C
        n_final = int(0.75 * r)
        if state.round_number >= n_final:
            progress = (state.round_number - n_final) / (r - n_final)
            probability_defect = min(progress, 1.0)
            if random.random() < probability_defect:
                return Action.D
            else:
                return Action.C
        stock = state.current_stock
        capacity = self.capacity
        if stock <= 0.01 * capacity:
            return Action.D
        if stock >= 0.8 * capacity:
            return Action.C
        elif stock >= 0.5 * capacity:
            if not history:
                return Action.C
            prev_round = state.round_number - 1
            if prev_round >= 0:
                opponent_actions_prev = history.opponent_actions[prev_round]
                defected_prev = np.sum(opponent_actions_prev == False)
                threshold_defections = (self.n_players - 1) / 2
                if defected_prev >= threshold_defections:
                    return Action.D
            return Action.C
        elif stock >= 0.3 * capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_445(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Common Pool Resource Game.

    This strategy starts by cooperating in the first three rounds to build the stock.
    Beyond that, it adapts based on the current stock level and opponents' previous actions.
    It defects when the stock is high and few opponents defected last round,
    and cooperates when the stock is low or if opponents defected more last round.
    It always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < 3:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        cooperation_threshold = 0.6 * self.game_description.capacity
        low_stock_threshold = 0.4 * self.game_description.capacity
        last_round = state.round_number - 1
        opponent_actions_last_round = history.opponent_actions[last_round, :]
        num_defectors = np.count_nonzero(~opponent_actions_last_round)
        n_players = self.game_description.n_players
        if current_stock > cooperation_threshold and num_defectors < n_players / 2:
            return Action.D
        elif current_stock < low_stock_threshold or (current_stock >= low_stock_threshold and num_defectors >= n_players / 2):
            return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_282(BaseStrategy):
    """
    Cooperative Exploiter Strategy for Common Pool Resource Game.
    Cooperates initially, then switches to defecting based on stock level and trend.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.5 * game_description.capacity
        self.past_stocks = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        self.past_stocks.append(current_stock)
        if len(self.past_stocks) > 3:
            self.past_stocks = self.past_stocks[-3:]
        if current_round == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        if current_round == n_rounds - 1:
            return Action.D
        elif current_round >= n_rounds - 2:
            return Action.D
        if current_stock < self.threshold:
            return Action.D
        if len(self.past_stocks) >= 2:
            changes = []
            for i in range(1, len(self.past_stocks)):
                changes.append(self.past_stocks[i] - self.past_stocks[i - 1])
            if changes:
                avg_change = sum(changes) / len(changes)
                if avg_change < 0:
                    return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_298(BaseStrategy):
    """
    A strategy for the Common Pool Resource game that balances exploiting opponents' cooperation 
    with maintaining stock levels for sustained benefits. The strategy involves initial cooperation, 
    mirroring opponents' defection, preserving stock when low, and defecting in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        current_stock = state.current_stock
        n_players = self.n_players
        capacity = self.capacity
        total_rounds = self.n_rounds
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        opponent_defections = (opponent_prev_actions == False).sum()
        my_defection = 0 if my_prev_action else 1
        total_D_prev = opponent_defections + my_defection
        if state.round_number == total_rounds - 1:
            return Action.D
        elif current_stock < 0.25 * capacity:
            return Action.C
        elif total_D_prev > n_players / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_300(BaseStrategy):
    """
    Adaptive Exploitation Strategy based on stock health.
    Defects initially and in the last round, cooperates when stock falls below a threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.D
        else:
            self.stock_history.append(state.current_stock)
            if state.round_number == self.game_description.n_rounds - 1:
                return Action.D
            else:
                n_stocks = len(self.stock_history)
                if n_stocks < 3:
                    avg_stock = self.stock_history[-1]
                else:
                    start = max(0, n_stocks - 3)
                    avg_stock = sum(self.stock_history[start:]) / 3
                threshold = 0.75 * self.game_description.capacity
                if avg_stock > threshold:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_358(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that balances cooperation and defection
    based on observed behavior and stock levels to maximize long-term payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        is_last_two = state.round_number >= self.n_rounds - 2
        if is_last_two:
            return Action.D
        current_stock = state.current_stock
        stock_threshold = self.capacity / 2.0
        if current_stock < stock_threshold:
            return Action.C
        my_coop = history.my_actions.sum()
        opponent_coop = history.opponent_actions.sum()
        total_coop = my_coop + opponent_coop
        num_rounds = state.round_number
        avg_cooperation = total_coop / (self.n_players * num_rounds)
        if avg_cooperation > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_360(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that adapts based on opponents' cooperation rates and stock levels,
    aiming to maximize individual payoff while maintaining sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        current_stock_percent = current_stock / self.capacity
        is_last_round = state.round_number == self.n_rounds - 1
        if is_last_round:
            if current_stock < 0.25 * self.capacity:
                return Action.D
            else:
                return Action.C
        total_coop = 0.0
        for r in range(state.round_number):
            my_action = history.my_actions[r]
            opponent_actions = history.opponent_actions[r, :].sum()
            sum_C = opponent_actions + (1 if my_action else 0)
            rate = sum_C / self.n_players
            total_coop += rate
        cooperation_rate = total_coop / state.round_number
        if cooperation_rate > 0.7:
            action = Action.C
        elif cooperation_rate <= 0.5:
            action = Action.D
        else:
            start_index = max(0, state.round_number - 2)
            sum_recent = 0.0
            for r in range(start_index, state.round_number):
                my_action = history.my_actions[r]
                opponent_actions = history.opponent_actions[r, :].sum()
                sum_C = opponent_actions + (1 if my_action else 0)
                rate = sum_C / self.n_players
                sum_recent += rate
            n_recent_rounds = state.round_number - start_index
            if n_recent_rounds == 0:
                recent_coop_rate = 0.0
            else:
                recent_coop_rate = sum_recent / n_recent_rounds
            if recent_coop_rate > 0.6 and current_stock_percent > 0.7:
                action = Action.C
            else:
                action = Action.D
        return action

class Strategy_EXPLOITATIVE_447(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game, balancing cooperation and defection based on observed behavior.
    Cooperates initially, defects if others defect excessively, and maximizes payoff in final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if current_round == 0:
            return Action.C
        t = current_round + 1
        if current_stock < n:
            return Action.D
        if t >= r - 1:
            return Action.D
        prev_round = current_round - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round]
        my_defect = 0 if my_prev_action else 1
        opp_defect_count = np.sum(~opp_prev_actions)
        total_defectors = my_defect + opp_defect_count
        if total_defectors > n / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_448(BaseStrategy):
    """
    Adaptive Exploitation strategy for the Common Pool Resource game.
    Cooperates initially, defects in the last round, and adapts based on stock levels and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_stock = state.current_stock
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            self.last_stock = state.current_stock
            return Action.D
        else:
            current_stock = state.current_stock
            last_stock = self.last_stock
            if last_stock == 0:
                stock_change = 0
            else:
                stock_change = (current_stock - last_stock) / last_stock * 100
            defect_conditions = stock_change < -10 or current_stock < 0.2 * self.game_description.capacity
            if defect_conditions:
                action = Action.D
            else:
                prev_round = state.round_number - 1
                prev_opp_actions = history.opponent_actions[prev_round, :]
                cooperators = np.sum(prev_opp_actions)
                if cooperators >= self.game_description.n_players // 2:
                    action = Action.C
                else:
                    action = Action.D
            self.last_stock = current_stock
            return action

class Strategy_EXPLOITATIVE_458(BaseStrategy):
    """
    Adaptive Exploitation strategy for the Common Pool Resource Game.
    This strategy balances cooperation and defection based on stock levels and opponents' past actions.
    Cooperates initially and in sustainable stock conditions, defects when stock is critically low or when opponents exploit excessively.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        stock = state.current_stock
        lower_threshold = 0.25 * self.capacity
        upper_threshold = 0.75 * self.capacity
        if stock < lower_threshold:
            return Action.D
        if stock > upper_threshold:
            prev_round = round_number - 1
            my_prev_action = history.my_actions[prev_round]
            my_defect = not my_prev_action
            opp_defects = 0
            for opponent_action in history.opponent_actions[prev_round]:
                if not opponent_action:
                    opp_defects += 1
            total_defectors = int(my_defect) + opp_defects
            half_players = self.n_players / 2
            if total_defectors < half_players:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_442(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and defection based on observed behavior and stock levels.
    Cooperates initially, then adapts based on defection rates and stock conditions, defecting more in the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num < 3:
            return Action.C
        if round_num >= self.n_rounds - 2:
            return Action.D
        if history is None:
            return Action.C
        opponent_actions = history.opponent_actions
        n_opp = self.n_players - 1
        total_defections = 0
        for round in opponent_actions:
            total_defections += (~round).sum()
        total_actions = len(opponent_actions) * n_opp
        avg_defection = total_defections / total_actions if total_actions != 0 else 0.0
        if current_stock < 0.5 * self.capacity:
            cooperation_threshold = 0.3
        else:
            cooperation_threshold = 0.7
        if avg_defection > cooperation_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_459(BaseStrategy):
    """
    Adaptive Exploitation Strategy with Stock Protection.
    Cooperates initially, defects in the last round, and adapts based on recent defections and stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        if t == 0:
            return Action.C
        if t == self.n_rounds - 1:
            return Action.D
        recent_rounds = range(max(0, t - 5), t)
        sum_defectors = 0
        for r in recent_rounds:
            if r >= len(history.my_actions) or r >= history.opponent_actions.shape[0]:
                continue
            my_action = history.my_actions[r]
            my_defect = 0 if my_action else 1
            opponent_defect = 0
            for opp_action in history.opponent_actions[r]:
                if not opp_action:
                    opponent_defect += 1
            sum_defectors += my_defect + opponent_defect
        total_rounds = len(recent_rounds)
        if total_rounds == 0:
            defect_rate = 0.0
        else:
            defect_rate = sum_defectors / (total_rounds * self.n_players)
        stock = state.current_stock
        stock_threshold = 0.2 * self.capacity
        if defect_rate > 0.3 or stock < stock_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_460(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that initially cooperates, 
    adapts based on stock levels, and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            threshold = self.capacity / 2.0
            if state.current_stock < threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_461(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.current_stock > 0.8 * self.capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_445(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource game that balances exploitation and cooperation based on stock levels and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == n_rounds - 1:
            return Action.D
        if round_number < 3:
            return Action.C
        cooperation_threshold = 0.6 * capacity
        low_stock_threshold = 0.4 * capacity
        last_round_idx = round_number - 1
        last_opponent_actions = history.opponent_actions[last_round_idx, :]
        opponent_defectors = len(last_opponent_actions) - sum(last_opponent_actions)
        my_last_action = history.my_actions[last_round_idx]
        total_defectors = opponent_defectors + (0 if my_last_action else 1)
        if current_stock > cooperation_threshold and total_defectors < n_players / 2:
            return Action.D
        elif current_stock < low_stock_threshold or (current_stock >= low_stock_threshold and total_defectors >= n_players / 2):
            return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_446(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game balancing cooperation and strategic defection.
    Cooperates initially, then adapts based on others' actions and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stocks = []
        self.punishment_remaining = 0
        self.high_stock_threshold = 0.8 * self.capacity
        self.critical_stock_threshold = 0.2 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stocks.append(state.current_stock)
            return Action.C
        self.stocks.append(state.current_stock)
        t_prev = state.round_number - 1
        S_prev = self.stocks[t_prev]
        my_payoff_prev = history.my_payoffs[t_prev]
        opponent_payoffs_prev = history.opponent_payoffs[t_prev]
        total_consumption_prev = my_payoff_prev + sum(opponent_payoffs_prev)
        average_consumption_prev = total_consumption_prev / self.n
        cooperative_threshold_prev = S_prev / (2 * self.n)
        current_stock = state.current_stock
        if current_stock <= self.critical_stock_threshold:
            return Action.D
        elif state.round_number == self.r - 1:
            return Action.D
        elif self.punishment_remaining > 0:
            self.punishment_remaining -= 1
            return Action.D
        else:
            if current_stock > self.high_stock_threshold:
                tolerance = 0.2
            else:
                tolerance = 0.1
            if average_consumption_prev > cooperative_threshold_prev * (1 + tolerance):
                self.punishment_remaining = 2
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_462(BaseStrategy):
    """
    Adaptive Cooperation-Defection Strategy for the Common Pool Resource Game.
    Cooperates initially, defects in the last round, conserves stock when low, and strategically defects when beneficial.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_stock <= capacity / 4:
            return Action.C
        if current_stock < capacity / 2:
            return Action.C
        if state.round_number >= self.game_description.n_rounds / 2:
            return Action.D
        total_defections = 0
        for round_num in range(len(history.my_actions)):
            if history.my_actions[round_num] is False:
                total_defections += 1
            opponent_actions = history.opponent_actions[round_num]
            opp_defections = (~opponent_actions).sum()
            total_defections += opp_defections
        avg_defections_per_round = total_defections / state.round_number
        if avg_defections_per_round > self.game_description.n_players / 2:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_447(BaseStrategy):
    """
    Exploitative Strategy for Common Pool Resource Game.
    Adapts based on observed behavior, switching to defection when exploited or in final rounds.
    Cooperates initially to maintain stock, defects when necessary or in the end.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.current_stock < self.n:
            return Action.D
        if state.round_number == 0:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round]
        sum_opp_coop = np.sum(opp_prev_actions)
        opp_defectors = len(opp_prev_actions) - sum_opp_coop
        my_defection = 0 if my_prev_action else 1
        total_defectors = opp_defectors + my_defection
        if state.round_number >= self.r - 2:
            return Action.D
        if state.round_number < self.r // 2:
            if total_defectors > self.n / 2:
                return Action.D
            else:
                return Action.C
        elif total_defectors > self.n / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_463(BaseStrategy):
    """Exploitative Strategy for the Common Pool Resource Game."""

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.3 * self.capacity:
            return Action.C
        else:
            total_defectors = 0
            for round_prev in range(state.round_number):
                my_action = history.my_actions[round_prev]
                if not my_action:
                    total_defectors += 1
                opponent_actions_prev = history.opponent_actions[round_prev]
                opponent_defectors = np.sum(~opponent_actions_prev)
                total_defectors += opponent_defectors
            D_avg = total_defectors / state.round_number
            threshold = self.n_players / 2
            if D_avg > threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_464(BaseStrategy):
    """
    A strategy that starts by cooperating, then defects in the last round.
    In middle rounds, it tracks the stock trend, switching to defect if the stock decreases consistently.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        round_number = state.round_number
        n_rounds = self.game_description.n_rounds
        if round_number == 0:
            return Action.C
        if round_number == n_rounds - 1:
            return Action.D
        window_size = 3
        stock_history_len = len(self.stock_history)
        if stock_history_len < 2:
            return Action.C
        start_index = max(0, stock_history_len - window_size)
        recent_stocks = self.stock_history[start_index:]
        negative_transitions = 0
        for i in range(len(recent_stocks) - 1):
            if recent_stocks[i + 1] - recent_stocks[i] < 0:
                negative_transitions += 1
        total_transitions = len(recent_stocks) - 1
        if negative_transitions > total_transitions / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_448(BaseStrategy):
    """
    Adaptive exploitation strategy for the Common Pool Resource game.
    Cooperates initially, then adapts to stock levels and opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.round_number = 0
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.round_number = state.round_number
            self.previous_stock = state.current_stock
            return Action.C
        if state.round_number == self.n_rounds - 1:
            self.round_number = state.round_number
            self.previous_stock = state.current_stock
            return Action.D
        current_stock = state.current_stock
        if current_stock < 0.2 * self.capacity:
            self.previous_stock = current_stock
            return Action.D
        delta = current_stock - self.previous_stock
        if delta < -0.1 * self.previous_stock:
            self.previous_stock = current_stock
            return Action.D
        opp_actions_last = history.opponent_actions[-1, :]
        n_coop_opponents = np.sum(opp_actions_last)
        if n_coop_opponents >= (self.n_players - 1) // 2:
            self.previous_stock = current_stock
            return Action.C
        else:
            self.previous_stock = current_stock
            return Action.D

class Strategy_EXPLOITATIVE_465(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances immediate payoff maximization with long-term sustainability.
    It uses a combination of conservation thresholds, cooperation incentives, and probabilistic decisions based on historical behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            current_round = state.round_number
            n_players = self.game_description.n_players
            capacity = self.game_description.capacity
            current_stock = state.current_stock
            total_C = 0
            for round in range(current_round):
                if history.my_actions[round]:
                    total_C += 1
                for opponent in range(n_players - 1):
                    if history.opponent_actions[round, opponent]:
                        total_C += 1
            total_possible = n_players * current_round
            avg_coop = total_C / total_possible if total_possible != 0 else 0.0
            if current_stock <= 0.5 * capacity:
                action = Action.C
            elif avg_coop >= 0.5:
                action = Action.C
            else:
                action = Action.D
            defectors = set()
            for opponent in range(n_players - 1):
                coop_count = 0
                for round in range(current_round):
                    if history.opponent_actions[round, opponent]:
                        coop_count += 1
                coop_rate = coop_count / current_round
                if coop_rate < 0.3:
                    defectors.add(opponent)
            if len(defectors) > 0 and avg_coop < 0.5:
                action = Action.D
            cooperation_prob = max(0.2, min(avg_coop, 1.0))
            if random.random() < cooperation_prob:
                action = Action.C
            else:
                action = Action.D
            return action

class Strategy_EXPLOITATIVE_458(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Common Pool Resource Game.
    
    This strategy balances cooperation for resource sustainability with timely defection 
    to exploit resources when necessary. It adapts based on stock levels and opponents' 
    previous actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        if current_stock == 0:
            return Action.D
        upper_threshold = 0.75 * self.capacity
        lower_threshold = 0.25 * self.capacity
        if current_stock > upper_threshold:
            prev_actions = history.opponent_actions[-1]
            num_defectors = prev_actions.shape[0] - np.count_nonzero(prev_actions)
            half_players = self.n_players / 2
            if num_defectors < half_players:
                return Action.C
            else:
                return Action.D
        elif current_stock < lower_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_466(BaseStrategy):
    """
    A strategy that adapts based on the current stock level, the number of remaining rounds, 
    and past actions. It balances cooperation and defection to maximize individual payoff 
    while maintaining resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        n_players = self.game_description.n_players
        r = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round == r - 1:
            return Action.D
        if current_stock < 0.25 * capacity:
            return Action.D
        last_round = current_round - 1
        last_opponent_actions = history.opponent_actions[last_round]
        opponent_defectors = len(last_opponent_actions) - np.sum(last_opponent_actions)
        my_last_action = history.my_actions[last_round]
        total_defectors_last = opponent_defectors + (0 if my_last_action else 1)
        threshold = 0.75 * capacity
        initial_action = Action.D
        if current_stock > threshold:
            if total_defectors_last <= n_players / 2:
                initial_action = Action.C
            else:
                initial_action = Action.D
        if total_defectors_last > 0:
            return Action.D
        else:
            return initial_action

class Strategy_EXPLOITATIVE_459(BaseStrategy):
    """
    Adaptive Exploitation with Stock Protection strategy for Common Pool Resource Game.
    Cooperates initially, adapts based on recent defections and stock level, and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            t = state.round_number
            start = max(0, t - 5)
            recent_rounds = history.opponent_actions[start:t]
            sum_defectors = 0
            for round in recent_rounds:
                for action in round:
                    if not action:
                        sum_defectors += 1
            n_rounds = len(recent_rounds)
            if n_rounds == 0:
                recent_defect_rate = 0.0
            else:
                recent_defect_rate = sum_defectors / (n_rounds * (self.game_description.n_players - 1))
            stock_threshold = 0.2 * self.game_description.capacity
            if recent_defect_rate > 0.3 or state.current_stock < stock_threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_467(BaseStrategy):
    """
    A dynamic strategy for the Common Pool Resource Game that balances exploitation and conservation.
    It cooperates initially, defects in the final round, conserves when stock is low, exploits when opponents
    are more cooperative, and periodically tests exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_test_round = -1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        capacity = self.game_description.capacity
        if round_num == 0:
            return Action.C
        if round_num == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock <= 0.3 * capacity:
            return Action.C
        if round_num - self.last_test_round >= 3:
            self.last_test_round = round_num
            return Action.D
        opp_actions = history.opponent_actions[:round_num, :]
        n_opponents = self.game_description.n_players - 1
        total_coop = opp_actions.sum()
        total_possible = round_num * n_opponents
        if total_possible == 0:
            avg_coop = 0.0
        else:
            avg_coop = total_coop / total_possible
        if avg_coop > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_460(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that starts with cooperation, 
    switches to defection if the stock falls below a threshold, and defects 
    in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            current_round = state.round_number
            capacity = self.game_description.capacity
            threshold = capacity / 2.0
            if current_round == self.game_description.n_rounds - 1:
                return Action.D
            elif state.current_stock < threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_461(BaseStrategy):
    """
    This strategy balances cooperation and defection based on the current stock level and round number.
    It cooperates on the first round, defects when the stock is above 80% of capacity until the penultimate round,
    and always defects in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock > 0.8 * self.game_description.capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_468(BaseStrategy):
    """
    Adaptive Exploitation and Sustainability Strategy for the Common Pool Resource game.
    
    This strategy balances immediate gains with long-term sustainability by adapting to the dynamics 
    of other players' actions while safeguarding against stock depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.initial_phase_rounds = int(game_description.n_rounds * 0.1)
        self.endgame_threshold = game_description.n_rounds - self.initial_phase_rounds
        self.punishment_rounds_left = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number < self.initial_phase_rounds:
            return Action.C
        if state.round_number >= self.endgame_threshold:
            if state.current_stock >= 0.8 * self.capacity:
                return Action.D
            else:
                return Action.C
        if self.punishment_rounds_left > 0:
            self.punishment_rounds_left -= 1
            return Action.C
        if state.current_stock < 0.2 * self.capacity:
            self.punishment_rounds_left = 3
            return Action.C
        last_round = state.round_number - 1
        my_last_action = history.my_actions[last_round]
        opponent_last_actions = history.opponent_actions[last_round, :]
        total_coop = my_last_action + np.sum(opponent_last_actions)
        cooperation_rate = total_coop / self.n_players
        if cooperation_rate > 0.5 and state.current_stock >= 0.8 * self.capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_462(BaseStrategy):
    """
    Adaptive Cooperation-Defection Strategy

    This strategy balances cooperation and defection based on the current stock level,
    remaining rounds, and past actions of all players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == r - 1:
            return Action.D
        if current_stock <= capacity / 4:
            return Action.C
        if current_stock < capacity / 2:
            return Action.C
        remaining_rounds = r - current_round
        if remaining_rounds <= r / 2:
            return Action.D
        past_defections = 0
        if history is not None:
            t = history.my_actions.shape[0]
            for i in range(t):
                if not history.my_actions[i]:
                    past_defections += 1
                opp_actions = history.opponent_actions[i]
                opp_d_count = opp_actions.shape[0] - np.sum(opp_actions)
                past_defections += opp_d_count
            threshold = n * t / 2.0
            if past_defections > threshold:
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_469(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts based on other players' actions and the current stock level.
    Cooperates initially, then decides based on others' cooperation and stock sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        opponent_prev_actions = history.opponent_actions[prev_round]
        my_prev_action = history.my_actions[prev_round]
        sum_opponent_C = np.sum(opponent_prev_actions)
        sum_total_C = sum_opponent_C + int(my_prev_action)
        n_players = self.game_description.n_players
        most_cooperated = sum_total_C > n_players / 2
        current_stock = state.current_stock
        threshold = 0.7 * self.game_description.capacity
        stock_good = current_stock >= threshold
        if most_cooperated and stock_good:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_463(BaseStrategy):
    """
    Exploitative Strategy for the Common Pool Resource Game.
    Cooperates initially, defects on last round. In between, defects if average defectors exceed n/2 or if stock is low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.3 * self.capacity:
            return Action.C
        t = state.round_number
        D_total = 0
        for i in range(t):
            my_defect = 0 if history.my_actions[i] else 1
            opponent_defect = np.sum(history.opponent_actions[i] == False)
            D_total += my_defect + opponent_defect
        D_avg = D_total / t
        if D_avg > self.n_players / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_470(BaseStrategy):
    """
    Adaptive Exploitation with Punishment (AEP) strategy for the Common Pool Resource Game.
    This strategy balances exploitation with sustainable resource management by dynamically
    adapting to opponent behaviors and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 2:
            stock_percent = state.current_stock / self.game_description.capacity
            if stock_percent > 0.75:
                return Action.D
            else:
                return Action.C
        else:
            len_history = len(history.opponent_actions)
            start_round = max(0, len_history - 3)
            total_defections = 0
            for r in range(start_round, len_history):
                opponent_defections = sum((1 for opponent in history.opponent_actions[r] if opponent == 0))
                my_defection = 0 if history.my_actions[r] else 1
                total_defections += opponent_defections + my_defection
            average_defection = total_defections / (3 * self.game_description.n_players)
            threshold = 0.675 if average_defection < 0.5 else 0.825
            stock_percent = state.current_stock / self.game_description.capacity
            if stock_percent > threshold:
                return Action.D
            else:
                my_last_action = history.my_actions[-1]
                my_defected_last = 0 if my_last_action else 1
                opponent_defections_last = sum((1 for opponent in history.opponent_actions[-1] if opponent == 0))
                total_defectors_last = my_defected_last + opponent_defections_last
                half_players = self.game_description.n_players / 2
                if total_defectors_last > half_players:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_471(BaseStrategy):
    """
    A strategy that balances cooperation and defection based on recent behavior and resource levels.
    It starts with initial cooperation, defects if others defect excessively or the stock is low,
    and defects in the final rounds to maximize payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < 3:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 3:
            return Action.D
        r = state.round_number
        start = max(0, r - 3)
        recent_opponent_actions = history.opponent_actions[start:r]
        defect_counts = np.sum(~recent_opponent_actions, axis=1)
        avg_defectors = np.mean(defect_counts) if defect_counts.size > 0 else 0
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if avg_defectors > n_players / 2 or current_stock < 0.5 * capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_464(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation with defection based on observed stock trends.
    Cooperates initially, defects in the last round, and switches to defection if the stock has been decreasing in the majority of recent rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        current_t = state.round_number
        if current_t == 0:
            return Action.C
        elif current_t == self.r - 1:
            return Action.D
        else:
            if len(self.stock_history) < 2:
                return Action.C
            deltas = []
            for i in range(1, len(self.stock_history)):
                delta = self.stock_history[i] - self.stock_history[i - 1]
                if delta < 0:
                    deltas.append(True)
                else:
                    deltas.append(False)
            k = min(3, len(deltas))
            recent_deltas = deltas[-k:] if k > 0 else []
            num_decreases = sum(recent_deltas)
            if num_decreases >= 2:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_472(BaseStrategy):
    """
    This strategy balances cooperation and defection based on stock level and opponents' previous actions.
    It cooperates in the first round, defects in the last round, and adapts in intermediate rounds
    by considering both the stock level and the number of defectors in the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            my_prev_action = history.my_actions[prev_round]
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            num_defect_opponents = len(opponent_actions_prev) - np.count_nonzero(opponent_actions_prev)
            num_defectors = num_defect_opponents + (0 if my_prev_action else 1)
            if num_defectors > self.game_description.n_players / 2:
                return Action.D
            else:
                half_capacity = 0.5 * self.game_description.capacity
                if state.current_stock < half_capacity:
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_465(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances immediate payoff with long-term sustainability.
    It uses a combination of conservation, cooperation incentives, defector punishment, and smooth transitions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        if t == 0:
            return Action.C
        if t == self.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        n_players = self.n_players
        t_prev = t
        total_coop = 0
        for round in range(t_prev):
            my_action = history.my_actions[round]
            opponents_actions = history.opponent_actions[round]
            coop = 1 if my_action else 0
            coop += sum(opponents_actions)
            total_coop += coop
        avg_coop = total_coop / (t_prev * n_players)
        if current_stock <= 0.5 * self.capacity:
            action = Action.C
        elif avg_coop >= 0.5:
            action = Action.C
        else:
            action = Action.D
        defectors = []
        for opponent_idx in range(n_players - 1):
            opp_actions = history.opponent_actions[:, opponent_idx]
            opp_coop = sum(opp_actions)
            opp_avg = opp_coop / t_prev if t_prev > 0 else 0.0
            if opp_avg < 0.3:
                defectors.append(opponent_idx)
        if len(defectors) > 0 and avg_coop < 0.5:
            action = Action.D
        cooperation_prob = max(0.2, min(avg_coop, 1.0))
        if random.random() < cooperation_prob:
            action = Action.C
        else:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_473(BaseStrategy):
    """
    A strategy that starts with cooperation and adapts based on stock levels and estimated defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        my_defected = 0 if my_prev_action else 1
        opponents_prev = history.opponent_actions[prev_round]
        num_opponents_d = np.sum(~opponents_prev)
        total_defectors = my_defected + num_opponents_d
        threshold = 0.5 * self.game_description.capacity
        current_stock = state.current_stock
        if current_stock < threshold or total_defectors > 0.5 * self.game_description.n_players:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_474(BaseStrategy):
    """
    Adaptive Exploitation Strategy for maximizing individual payoff in a Common Pool Resource Game.
    The strategy balances cooperation and defection based on observed behavior and resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        if self.n_players <= 2:
            self.stock_threshold = 0.4 * self.capacity
        else:
            self.stock_threshold = 0.3 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if history is None:
            return Action.C
        sum_payoff = history.opponent_payoffs.sum()
        count = history.opponent_payoffs.size
        if count == 0:
            return Action.C
        avg_opponent_payoff = sum_payoff / count
        current_stock = state.current_stock
        coop_payoff = current_stock / (2 * self.n_players)
        if avg_opponent_payoff > coop_payoff or current_stock < self.stock_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_467(BaseStrategy):
    """
    This strategy balances exploitation and conservation in a Common Pool Resource Game.
    It cooperates initially, defects in the final round, and adapts based on stock level and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.last_test_round = -1
        self.test_interval = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        cap = self.capacity
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.3 * cap:
            return Action.C
        if current_round - self.last_test_round >= self.test_interval:
            self.last_test_round = current_round
            return Action.D
        opp_actions = history.opponent_actions
        total_coops = np.sum(opp_actions)
        total_possible = opp_actions.size
        coop_rate = total_coops / total_possible
        if coop_rate > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_469(BaseStrategy):
    """
    Exploitative Strategy for the Common Pool Resource Game.
    
    The strategy starts by Cooperating in the first round to establish a baseline.
    Subsequent rounds adapt based on the stock level and others' actions.
    Always Defects in the last round to maximize immediate payoff.
    Cooperates if the stock is above 70% of capacity and most players Cooperated in the previous round;
    otherwise, Defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.round_number == 0:
            return Action.C
        else:
            previous_round = state.round_number - 1
            my_prev_action = history.my_actions[previous_round]
            opp_prev_actions = history.opponent_actions[previous_round]
            defectors = 0
            if not my_prev_action:
                defectors += 1
            defectors += sum((1 for a in opp_prev_actions if not a))
            half_players = self.game_description.n_players / 2
            most_defected = defectors > half_players
            stock = state.current_stock
            capacity = self.game_description.capacity
            stock_threshold = 0.7 * capacity
            stock_ok = stock >= stock_threshold
            if stock_ok and (not most_defected):
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_470(BaseStrategy):
    """
    Adaptive Exploitation with Punishment (AEP) Strategy.
    
    This strategy balances cooperation and exploitation by dynamically adjusting decisions based on stock levels, 
    opponent behavior, and current game phase. It cooperates initially, defects when stock is plentiful, punishes 
    excessive defection, and adapts thresholds based on observed cooperation rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        current_round = state.round_number
        is_endgame = current_round >= max(0, n_rounds - 3)
        if is_endgame:
            if state.current_stock / capacity <= 0.25:
                return Action.C
            else:
                return Action.D
        else:
            start_round = max(0, current_round - 3)
            recent_actions = history.opponent_actions[start_round:current_round, :]
            total_coop = np.sum(recent_actions)
            avg_coop = total_coop / (recent_actions.shape[0] * (n_players - 1)) if recent_actions.shape[0] > 0 else 0.5
            if avg_coop >= 0.7:
                stock_threshold = 0.65
            elif avg_coop <= 0.3:
                stock_threshold = 0.8
            else:
                stock_threshold = 0.75
            if state.current_stock / capacity > stock_threshold:
                return Action.D
            else:
                lastactions = history.opponent_actions[-1, :]
                defectors = len(lastactions) - np.sum(lastactions)
                if defectors > (n_players - 1) / 2:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_476(BaseStrategy):
    """
    Adaptive Cooperation Strategy with Stock Threshold and Historical Defection Response.

    This strategy starts by cooperating in the first round. In the last round, it always defects.
    In intermediate rounds, it defects if the stock is below 50% of capacity or if more than half
    of the players defected in the previous round. Otherwise, it continues to cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            n_players = self.game_description.n_players
            capacity = self.game_description.capacity
            threshold = capacity / 2
            current_stock = state.current_stock
            if current_stock < threshold:
                return Action.D
            else:
                previous_round = state.round_number - 1
                my_prev_action = history.my_actions[previous_round]
                opponent_actions_prev = history.opponent_actions[previous_round, :]
                opponent_defectors = np.sum(~opponent_actions_prev)
                my_defector = 0 if my_prev_action else 1
                total_defectors = my_defector + opponent_defectors
                if total_defectors > n_players / 2:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_471(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number < 3:
            return Action.C
        else:
            n_rounds = self.game_description.n_rounds
            if state.round_number >= n_rounds - 3:
                return Action.D
            else:
                n = self.game_description.n_players
                sum_defectors = 0
                for r in range(max(0, state.round_number - 3), state.round_number):
                    my_defect = 0 if history.my_actions[r] else 1
                    opponent_defectors = np.count_nonzero(~history.opponent_actions[r])
                    sum_defectors += my_defect + opponent_defectors
                avg_defectors = sum_defectors / 3
                current_stock = state.current_stock
                capacity = self.game_description.capacity
                if avg_defectors > n / 2 or current_stock < 0.5 * capacity:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_477(BaseStrategy):

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.threshold = 0.2 * self.capacity
        self.high_stock = 0.8 * self.capacity
        self.last_round_threshold = 0.2 * self.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            if state.current_stock > self.last_round_threshold:
                return Action.C
            else:
                return Action.D
        else:
            current_stock = state.current_stock
            if current_stock < self.threshold:
                return Action.C
            elif current_stock > self.high_stock:
                return Action.D
            else:
                previous_round = state.round_number - 1
                my_last_action = history.my_actions[previous_round]
                opponent_actions_last_round = history.opponent_actions[previous_round]
                n_coop = sum(opponent_actions_last_round) + (1 if my_last_action else 0)
                cooperation_rate = n_coop / self.n_players
                if cooperation_rate >= 0.5:
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_472(BaseStrategy):
    """
    This strategy balances immediate gains with long-term sustainability by adapting based on the current stock level and opponents' past actions. It employs a mix of cooperation and defection to exploit high stock levels while preserving the resource for future rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            last_round_actions = history.opponent_actions[-1]
            num_defectors = self.game_description.n_players - last_round_actions.sum()
            threshold = self.game_description.n_players / 2
            if num_defectors > threshold:
                return Action.D
            elif state.current_stock < 0.5 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_473(BaseStrategy):
    """
    Adaptive Exploitation Strategy for the Common Pool Resource Game.

    This strategy starts by Cooperating and then adapts based on the stock level
    and estimated number of defectors. It defects if the stock falls below 50%
    of capacity or if more than half of the players are estimated to be defecting.
    It always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold = 0.5 * self.capacity
        self.last_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            action = Action.C
            self.last_stock = state.current_stock
            return action
        current_round = state.round_number
        if current_round == self.n_rounds - 1:
            action = Action.D
            self.last_stock = state.current_stock
            return action
        S_prev = self.last_stock
        S_current = state.current_stock
        if S_current < self.capacity:
            a = 2
            b = -3 * self.capacity
            c = self.capacity * S_current
            discriminant = (3 * self.capacity) ** 2 - 4 * a * c
            if discriminant < 0:
                S_after_prev = 0.0
            else:
                sqrt_discriminant = math.sqrt(discriminant)
                S_after1 = (3 * self.capacity + sqrt_discriminant) / (4 * 2)
                S_after2 = (3 * self.capacity - sqrt_discriminant) / (4 * 2)
                candidates = []
                if S_after1 <= S_prev and S_after1 >= 0:
                    candidates.append(S_after1)
                if S_after2 <= S_prev and S_after2 >= 0:
                    candidates.append(S_after2)
                if not candidates:
                    S_after_prev = 0.0
                else:
                    S_after_prev = min(candidates)
        elif S_current == self.capacity:
            S_after_prev = self.capacity / 2
        else:
            S_after_prev = S_prev
        total_consumption_prev = S_prev - S_after_prev
        my_prev_action = history.my_actions[-1]
        if my_prev_action:
            my_consume = S_prev / (2 * self.n_players)
        else:
            my_consume = S_prev / self.n_players
        others_cons = total_consumption_prev - my_consume
        if S_prev == 0:
            x = 0.0
        else:
            x_numerator = others_cons * 2 * self.n_players / S_prev
            x = x_numerator - (self.n_players - 1)
        x = max(0.0, min(x, float(self.n_players - 1)))
        my_defection = 0 if my_prev_action else 1
        total_defectors = my_defection + int(round(x))
        if state.current_stock < self.cooperation_threshold or total_defectors > 0.5 * self.n_players:
            action = Action.D
        else:
            action = Action.C
        self.last_stock = S_current
        return action

class Strategy_EXPLOITATIVE_475(BaseStrategy):
    """
    This strategy combines cooperation with adaptive defection based on several factors, including stock levels,
    opponents' historical actions, and recent payoffs. It aims to maximize individual payoff while maintaining resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defect_next_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        game = self.game_description
        capacity = game.capacity
        n_rounds = game.n_rounds
        if state.round_number == n_rounds - 1:
            return Action.D
        if state.current_stock < 0.2 * capacity:
            return Action.D
        if self.defect_next_round:
            self.defect_next_round = False
            return Action.D
        if history is not None:
            opponent_actions = history.opponent_actions
            rounds_so_far = state.round_number
            total_opponents = game.n_players - 1
            d_total = np.sum(~opponent_actions)
            if rounds_so_far > 0 and d_total / (rounds_so_far * total_opponents) > 0.5:
                return Action.D
        if history is not None and state.round_number < n_rounds - 1:
            rounds_so_far = state.round_number
            threshold = 2.0 / 3.0 * (capacity / n_rounds)
            my_actions = history.my_actions
            my_d = np.sum(~my_actions)
            my_avg = my_d / rounds_so_far if rounds_so_far > 0 else 0.0
            if my_avg > threshold:
                self.defect_next_round = True
            opponent_d = np.sum(~history.opponent_actions, axis=0)
            if rounds_so_far > 0:
                for d in opponent_d:
                    avg = d / rounds_so_far
                    if avg > threshold:
                        self.defect_next_round = True
                        break
        if history is not None:
            my_payoffs = history.my_payoffs
            if len(my_payoffs) > 0:
                k = min(3, len(my_payoffs))
                recent_avg = np.mean(my_payoffs[-k:])
                threshold_payoff = capacity / (2 * game.n_players) / 2
                if recent_avg < threshold_payoff:
                    return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_478(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that dynamically adapts based on stock levels and opponent behavior.
    Cooperates initially and in low stock conditions, defects if excessive opposition defection is observed, and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock < 0.5 * capacity:
            return Action.C
        else:
            n_players = self.game_description.n_players
            sum_defectors = 0
            for r in range(state.round_number):
                round_actions = history.opponent_actions[r, :]
                defectors_in_round = n_players - np.sum(round_actions)
                sum_defectors += defectors_in_round
            avg_defector_ratio = sum_defectors / (state.round_number * n_players)
            if avg_defector_ratio > 0.3:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_479(BaseStrategy):
    """
    A strategy that adapts dynamically based on the game state and history.
    It balances cooperation to sustain the resource while exploiting opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_stock < 0.2 * self.capacity:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        prev_my_action = history.my_actions[current_round - 1]
        prev_opp_actions = history.opponent_actions[current_round - 1, :]
        my_defected = 0 if prev_my_action else 1
        opp_defected = np.sum(np.invert(prev_opp_actions))
        total_defectors = my_defected + opp_defected
        defection_rate = total_defectors / self.n_players
        if defection_rate > 0.5:
            return Action.D
        if current_stock >= 0.2 * self.capacity and defection_rate <= 0.5:
            return Action.C
        if current_round % 3 == 0:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_480(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that adapts based on stock levels and opponents' past behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        if state.round_number == total_rounds - 1:
            return Action.D
        threshold = capacity / (2 * n)
        current_stock = state.current_stock
        if current_stock < threshold:
            return Action.D
        my_prev_action = history.my_actions[state.round_number - 1]
        my_defected = not my_prev_action
        opponent_prev_actions = history.opponent_actions[state.round_number - 1, :]
        opponent_defected = sum((not action for action in opponent_prev_actions))
        total_defectors = (1 if my_defected else 0) + opponent_defected
        defection_rate = total_defectors / n
        if defection_rate > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_481(BaseStrategy):
    """
    A strategy that adaptively switches between cooperation and defection based on the remaining rounds and current stock level.
    Cooperates if the stock is above a dynamically calculated threshold to sustain future rounds, otherwise defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number + 1
        r = self.n_rounds
        if t == r:
            return Action.D
        remaining = r - t
        threshold = self.capacity * (remaining / r)
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_482(BaseStrategy):
    """
    Adaptive Exploitation Based on Cooperation and Stock Levels strategy.
    Cooperates initially, then adapts based on others' recent actions and stock levels.
    Defects in the last two rounds and when recent behavior or stock levels indicate insufficient cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.n_rounds - 2:
            return Action.D
        sum_defect_proportion = 0.0
        max_rounds = min(state.round_number, 3)
        for r in range(state.round_number - max_rounds, state.round_number):
            my_defect = 0 if history.my_actions[r] else 1
            opponent_defects = np.sum(history.opponent_actions[r, :] == False)
            total_defects = my_defect + opponent_defects
            proportion = total_defects / self.n_players
            sum_defect_proportion += proportion
        avg_defect = sum_defect_proportion / max_rounds if max_rounds else 0.0
        stock = state.current_stock
        stock_threshold_high = 0.5 * self.capacity
        stock_threshold_low = 0.3 * self.capacity
        if avg_defect > 0.5 or stock < stock_threshold_low:
            return Action.D
        elif stock > stock_threshold_high:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_484(BaseStrategy):
    """
    Adaptive strategy based on stock level and historical defection rates.
    Cooperates by default unless certain thresholds are met.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        threshold = 0.5 * self.capacity
        if state.current_stock < threshold:
            return Action.D
        opponent_actions = history.opponent_actions
        total_defections = np.sum(~opponent_actions)
        n_rounds = state.round_number
        n_opponents = self.n_players - 1
        average_defection_rate = total_defections / (n_rounds * n_opponents)
        if average_defection_rate > 0.5:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_485(BaseStrategy):
    """
    Implements the Adaptive Exploitation with Conservation (AEC) strategy.
    Cooperates initially, defects in the last round, and adapts based on stock levels and others' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.decay_factor = 0.9
        self.defection_rate = 0.5
        self.stock_threshold_high = 0.75 * self.capacity
        self.stock_threshold_low = 0.5 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        n_players = self.n_players
        if history is None:
            return Action.C
        last_round = history.opponent_actions.shape[0] - 1
        last_round_actions = history.opponent_actions[last_round, :]
        count_defectors = n_players - np.sum(last_round_actions)
        current_defect_proportion = count_defectors / n_players
        new_defect_rate = self.decay_factor * self.defection_rate + (1 - self.decay_factor) * current_defect_proportion
        if current_stock > self.stock_threshold_high:
            if new_defect_rate > 0.5:
                action = Action.D
            else:
                action = Action.C
        elif current_stock > self.stock_threshold_low:
            trend_increasing = new_defect_rate > self.defection_rate
            if trend_increasing:
                action = Action.D
            else:
                action = Action.C
        else:
            action = Action.C
        self.defection_rate = new_defect_rate
        return action

class Strategy_EXPLOITATIVE_486(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and reciprocity.
    It encourages initial cooperation, conserves the stock when necessary, and switches to defection
    based on others' previous actions, while maximizing payoff in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        if current_round == 0:
            return Action.C
        if current_round == total_rounds - 1:
            if state.current_stock > capacity / 2:
                return Action.D
            else:
                return Action.C
        elif state.current_stock < capacity / 2:
            return Action.C
        else:
            previous_round = current_round - 1
            my_previous_action = history.my_actions[previous_round]
            opponent_actions = history.opponent_actions[previous_round]
            my_defect = 0 if my_previous_action else 1
            opponent_defectors = np.sum(~opponent_actions)
            total_defectors = my_defect + opponent_defectors
            if total_defectors > n_players / 2:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_487(BaseStrategy):
    """
    This strategy implements an adaptive approach in the Common Pool Resource Game.
    It starts with cooperation, then adapts based on stock levels and opponents' actions.
    In the endgame phase, it shifts towards defecting to maximize immediate payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.last_stock = None
        self.stock_threshold = 0.5 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.last_stock = state.current_stock
            return Action.C
        else:
            endgame_phase = int(0.2 * self.n_rounds)
            endgame_phase_start = self.n_rounds - endgame_phase
            if state.round_number >= endgame_phase_start:
                self.last_stock = state.current_stock
                return Action.D
            else:
                current_stock = state.current_stock
                if current_stock < self.stock_threshold:
                    self.last_stock = current_stock
                    return Action.D
                else:
                    prev_round = state.round_number - 1
                    if prev_round < 0:
                        stock_change = current_stock - self.last_stock
                        if stock_change < 0:
                            self.last_stock = current_stock
                            return Action.D
                        else:
                            self.last_stock = current_stock
                            return Action.C
                    else:
                        my_prev_action = history.my_actions[prev_round]
                        opp_prev_actions = history.opponent_actions[prev_round, :]
                        num_coop = sum(opp_prev_actions) + (1 if my_prev_action else 0)
                        num_defectors = self.n_players - num_coop
                        stock_change = current_stock - self.last_stock
                        if num_defectors >= self.n_players / 2 or stock_change < 0:
                            self.last_stock = current_stock
                            return Action.D
                        else:
                            self.last_stock = current_stock
                            return Action.C

class Strategy_EXPLOITATIVE_488(BaseStrategy):
    """
    Adaptive Exploitation with Sustainability (AES) strategy for the Common Pool Resource Game.
    Balances cooperation and defection based on historical behavior and current stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        t = state.round_number
        current_stock = state.current_stock
        if current_stock < 0.25 * self.capacity:
            return Action.D
        opponent_actions = history.opponent_actions[:t, :]
        opponent_count = self.n_players - 1
        total_possible_actions = t * opponent_count
        sum_true = np.sum(opponent_actions)
        total_defections = total_possible_actions - sum_true
        avg_defection_rate = total_defections / total_possible_actions if total_possible_actions != 0 else 0.0
        if avg_defection_rate > 0.5:
            return Action.D
        if t > 2:
            if t - 2 >= 0:
                action_two_rounds_ago = history.my_actions[t - 2]
                if not action_two_rounds_ago:
                    return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_489(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts based on stock levels, 
    historical cooperation rates, and round position to balance immediate gains and sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        stock_threshold = 0.5 * self.game_description.capacity
        if current_stock < stock_threshold:
            return Action.C
        else:
            total_cooperations = 0
            for r in range(state.round_number):
                total_cooperations += int(history.my_actions[r])
                total_cooperations += history.opponent_actions[r, :].sum()
            avg_coop = total_cooperations / (state.round_number * self.game_description.n_players)
            if avg_coop > 0.5:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_490(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that adapts based on cooperation levels and stock sustainability.
    It starts by cooperating, then uses past actions and current stock levels to decide whether to defect or cooperate.
    The strategy prioritizes stock recovery when levels are critically low and defects in the final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.initial_stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.initial_stock_history.append(state.current_stock)
            return Action.C
        if len(self.initial_stock_history) < state.round_number + 1:
            self.initial_stock_history.append(state.current_stock)
        prev_round = state.round_number - 1
        prev_initial_stock = self.initial_stock_history[prev_round]
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        all_actions = [my_prev_action] + opponent_prev_actions.tolist()
        total = 0.0
        for action in all_actions:
            if action:
                total += prev_initial_stock / (2 * self.n)
            else:
                total += prev_initial_stock / self.n
        average = total / self.n
        benchmark = prev_initial_stock / (2 * self.n)
        last_few = self.r - state.round_number
        if last_few <= 2:
            return Action.D
        critical_threshold = self.capacity / 2.0
        current_initial_stock = self.initial_stock_history[prev_round + 1]
        if current_initial_stock < critical_threshold:
            return Action.C
        if average > benchmark:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_491(BaseStrategy):
    """
    An adaptive strategy that balances cooperation and defection based on observed behavior and stock dynamics.
    Cooperates initially, defects in the last round, and adjusts cooperation threshold dynamically.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory):
        round_num = state.round_number
        current_stock = state.current_stock
        if round_num == 0:
            return Action.C
        if round_num == self.n_rounds - 1:
            return Action.D
        prev_round = round_num - 1
        my_prev_action = history.my_actions[prev_round]
        others_prev_actions = history.opponent_actions[prev_round, :]
        previous_coop = (1 if my_prev_action else 0) + sum(others_prev_actions)
        if current_stock <= 0.2 * self.capacity:
            critical_threshold = self.n_players // 2
            if previous_coop >= critical_threshold:
                return Action.C
            else:
                return Action.D
        else:
            threshold_base = (self.n_players - 1) / 2
            if current_stock < 0.5 * self.capacity:
                adjusted_threshold = threshold_base + 1
            else:
                adjusted_threshold = threshold_base
            if previous_coop >= adjusted_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_492(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection
    based on the observed actions of other players and the current stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_rounds = game_description.n_rounds
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.critical_threshold = 0.2 * self.capacity
        self.initial_coop_rounds = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.total_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.C
        if state.round_number < self.initial_coop_rounds:
            return Action.C
        if state.current_stock < self.critical_threshold:
            return Action.C
        total_coop = 0
        for t in range(state.round_number):
            my_action = 1 if history.my_actions[t] else 0
            opponents_coop = np.sum(history.opponent_actions[t, :])
            total_coop += my_action + opponents_coop
        total_actions = self.n_players * state.round_number
        if total_actions == 0:
            average_coop = 0.0
        else:
            average_coop = total_coop / total_actions
        if average_coop > 0.7:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_493(BaseStrategy):
    """
    Exploitative Strategy for Common Pool Resource Game.
    
    This strategy involves conditional cooperation based on stock levels, 
    average cooperation rates, and a punishment mechanism to counter defectors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.stock_history = []
        self.punishment_active = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        self.stock_history.append(state.current_stock)
        if state.round_number == self.n_rounds - 1:
            if state.current_stock > 0.5 * self.capacity:
                return Action.D
            else:
                return Action.C
        if self.punishment_active > 0:
            self.punishment_active -= 1
            return Action.D
        if state.current_stock < 0.5 * self.capacity:
            return Action.C
        if history is None:
            return Action.C
        n_history_rounds = history.opponent_actions.shape[0]
        if n_history_rounds == 0:
            average_cooperation = 0.0
        else:
            cooperative_actions = np.sum(history.opponent_actions)
            total_possible = n_history_rounds * (self.n_players - 1)
            average_cooperation = cooperative_actions / total_possible
        if average_cooperation > 0.5 and state.current_stock > 0.75 * self.capacity:
            return Action.C
        else:
            if len(self.stock_history) >= 3:
                delta1 = self.stock_history[-1] - self.stock_history[-2]
                delta2 = self.stock_history[-2] - self.stock_history[-3]
                if delta1 < 0 and delta2 < 0:
                    self.punishment_active = 2
            return Action.D

class Strategy_EXPLOITATIVE_494(BaseStrategy):
    """
    Balances cooperation and defection based on current stock levels and historical defection rates.
    Cooperates initially, defects in last round, adapts based on stock and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        sum_defe = 0.0
        count = 0
        n_players = self.game_description.n_players
        past_rounds = range(max(0, state.round_number - 3), state.round_number)
        for r in past_rounds:
            my_def = 0 if history.my_actions[r] else 1
            opp_actions = history.opponent_actions[r]
            opp_def = sum((0 if a else 1 for a in opp_actions))
            total = my_def + opp_def
            rate = total / n_players
            sum_defe += rate
            count += 1
        avg_defe = sum_defe / count if count else 0.0
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio < 0.3:
            return Action.C
        elif stock_ratio > 0.7:
            return Action.D
        else:
            return Action.D if avg_defe >= 0.5 else Action.C

class Strategy_EXPLOITATIVE_495(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances cooperation and defection based on stock levels and opponent behavior.
    Cooperates initially, defects in the last round, and adapts based on previous round's stock and defection percentage.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if round_number == 0:
            return Action.C
        if round_number == n_rounds - 1:
            return Action.D
        previous_round = round_number - 1
        my_prev_action = history.my_actions[previous_round]
        my_prev_payoff = history.my_payoffs[previous_round]
        if my_prev_action:
            s_prev = my_prev_payoff * 2 * n_players
        else:
            s_prev = my_prev_payoff * n_players
        total_consumption = 0.0
        if my_prev_action:
            my_consumption = s_prev / (2 * n_players)
        else:
            my_consumption = s_prev / n_players
        total_consumption += my_consumption
        for opponent_action in history.opponent_actions[previous_round]:
            if opponent_action:
                op_consumption = s_prev / (2 * n_players)
            else:
                op_consumption = s_prev / n_players
            total_consumption += op_consumption
        s_remaining = s_prev - total_consumption
        if s_remaining < 0.5 * capacity:
            return Action.D
        else:
            my_defect = 0 if my_prev_action else 1
            opponent_defectors = sum((1 for action in history.opponent_actions[previous_round] if not action))
            total_defectors = my_defect + opponent_defectors
            percent_defectors = total_defectors / n_players
            if percent_defectors > 0.3:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_496(BaseStrategy):
    """
    Adaptive Exploitation with Sustainability (AES) strategy for the Common Pool Resource Game.
    This strategy balances exploitation and sustainability by cooperating initially, defecting when safe, and preserving the resource when necessary.
    It adapts based on recent defection rates and stock levels to maximize long-term payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.low_stock_coop_remaining = 0

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == 1:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            if state.current_stock < 0.2 * self.capacity:
                self.low_stock_coop_remaining = 3
            if self.low_stock_coop_remaining > 0:
                self.low_stock_coop_remaining -= 1
                return Action.C
            else:
                start_round = max(0, state.round_number - 3)
                total_defects = 0
                for r in range(state.round_number - 1, start_round - 1, -1):
                    opp_actions_r = history.opponent_actions[r]
                    defects_r = self.n_players - np.sum(opp_actions_r)
                    total_defects += defects_r
                num_rounds = state.round_number - start_round
                proportion_defect = total_defects / (num_rounds * self.n_players)
                if proportion_defect > 0.5 or state.current_stock < 0.3 * self.capacity:
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_497(BaseStrategy):
    """
    A dynamic threshold strategy for the Common Pool Resource Game.
    Cooperates when the stock is below a threshold decreasing with time,
    defects otherwise, and always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        rem = total_rounds - current_round
        if total_rounds == 0:
            threshold = 0.0
        else:
            threshold = self.game_description.capacity * (rem / total_rounds)
        if state.current_stock > threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_498(BaseStrategy):
    """
    A strategy that cooperates until the stock falls below 50% of the capacity, then defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.current_stock < 0.5 * self.capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_499(BaseStrategy):
    """
    Adaptive Exploitation with Sustainability (AES) Strategy.

    Cooperates initially to encourage others to cooperate, then adapts based on 
    the number of cooperators in the previous round. Defects if fewer than half 
    cooperated or in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            return Action.D
        previous_round = state.round_number - 1
        my_prev_action = history.my_actions[previous_round]
        opp_actions_prev = history.opponent_actions[previous_round, :]
        opp_coop = sum(opp_actions_prev)
        total_coop = opp_coop + (1 if my_prev_action else 0)
        threshold = (n_players + 1) // 2
        if total_coop >= threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_500(BaseStrategy):
    """
    Adaptive Exploitation with Conservation (AEC) strategy for the Common Pool Resource Game.
    This strategy balances immediate gains with long-term sustainability by adapting to the current stock level and opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock < 0.2 * capacity:
            return Action.C
        if current_stock < 0.5 * capacity:
            return Action.C
        avg_payoff = np.mean(history.my_payoffs)
        max_payoff = capacity / self.game_description.n_players
        threshold_payoff = 0.2 * max_payoff
        recent_rounds = len(history.opponent_actions)
        start = max(0, recent_rounds - 3)
        recent_actions = history.opponent_actions[start:]
        recent_defection_count = np.sum(~recent_actions)
        threshold_defection = 0.5 * (self.game_description.n_players - 1)
        if avg_payoff < threshold_payoff or recent_defection_count > threshold_defection:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_501(BaseStrategy):
    """
    Adaptive Exploitation with Conservation Strategy.
    - Cooperates initially to observe others.
    - Defects if average defection is high or stock is low.
    - Punishes excessive defection by others.
    - Defects in the final round to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock < 0.25 * capacity:
            return Action.C
        total_defectors = 0.0
        for prev_round in range(state.round_number):
            my_action = history.my_actions[prev_round]
            my_defect = 0 if my_action else 1
            opponent_actions_prev = history.opponent_actions[prev_round, :]
            opponent_defects = np.sum(~opponent_actions_prev)
            total_defectors += my_defect + opponent_defects
        avg_defectors = total_defectors / state.round_number
        n_players = self.game_description.n_players
        if avg_defectors >= 0.5 * n_players:
            return Action.D
        last_round = state.round_number - 1
        my_last_action = history.my_actions[last_round]
        my_defect_last = 0 if my_last_action else 1
        opponent_last_round = history.opponent_actions[last_round, :]
        opponent_defect_last = np.sum(~opponent_last_round)
        total_defect_last = my_defect_last + opponent_defect_last
        if total_defect_last > n_players / 2:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_502(BaseStrategy):
    """
    Adaptive Exploitation Strategy for the Common Pool Resource Game.
    Balances immediate gains with long-term resource sustainability by considering stock levels and opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        n_players = self.n_players
        capacity = self.capacity
        current_stock = self.capacity
        for round_num in range(current_round):
            my_action = history.my_actions[round_num]
            opponents_actions = history.opponent_actions[round_num, :]
            if my_action:
                my_consume = current_stock / (2 * n_players)
            else:
                my_consume = current_stock / n_players
            opponents_consume = 0.0
            for opponent_action in opponents_actions:
                if opponent_action:
                    consume = current_stock / (2 * n_players)
                else:
                    consume = current_stock / n_players
                opponents_consume += consume
            total_consume = my_consume + opponents_consume
            s_remaining = current_stock - total_consume
            if s_remaining < 0:
                s_remaining = 0.0
            growth = 2 * s_remaining * (1 - s_remaining / capacity)
            new_stock = s_remaining + growth
            if new_stock > capacity:
                new_stock = capacity
            current_stock = new_stock
        half_capacity = 0.5 * capacity
        if current_stock < half_capacity:
            return Action.C
        prev_round = current_round - 1
        my_prev = history.my_actions[prev_round]
        opponents_prev = history.opponent_actions[prev_round, :]
        defectors = 0
        if not my_prev:
            defectors += 1
        for opponent in opponents_prev:
            if not opponent:
                defectors += 1
        half_players = self.n_players / 2
        if defectors > half_players:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_503(BaseStrategy):
    """
    Adaptive Exploitation with Stock Conservation (AECS) strategy.
    Balances exploiting opportunities with maintaining stock sustainability,
    punishing excessive defection, and adapting based on stock levels and opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.endgame_threshold = math.ceil(0.9 * self.n_rounds)
        self.punishment_active = False
        self.punishment_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.capacity
        is_endgame = state.round_number >= self.endgame_threshold
        if is_endgame:
            if current_stock > 0.5 * capacity:
                return Action.D
            else:
                return Action.C
        if self.punishment_active:
            self.punishment_rounds_remaining -= 1
            if self.punishment_rounds_remaining <= 0:
                self.punishment_active = False
            return Action.D
        else:
            last_opponent_actions = history.opponent_actions[-1, :]
            defectors = sum((1 - action for action in last_opponent_actions))
            if defectors > self.n_players // 2:
                self.punishment_active = True
                self.punishment_rounds_remaining = random.choice([2, 3])
                return Action.D
            stock_fraction = current_stock / capacity
            if stock_fraction < 0.25:
                return Action.C
            elif stock_fraction > 0.75:
                return Action.C
            else:
                defectors_prev = sum((1 - action for action in last_opponent_actions))
                if defectors_prev > 0:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_504(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that combines initial cooperation with adaptive decision-making based on stock levels and opponent cooperation rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C
        if state.round_number == r - 1:
            return Action.D
        last_round = state.round_number - 1
        my_last_action = history.my_actions[last_round]
        opponents_last_actions = history.opponent_actions[last_round]
        my_c = my_last_action
        opponents_c = opponents_last_actions.sum()
        c_rate = (my_c + opponents_c) / n
        s_threshold = 0.5 * capacity
        current_stock = state.current_stock
        if current_stock >= s_threshold and c_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_505(BaseStrategy):
    """
    Adaptive Exploitation Based on Stock and Behavior strategy for Common Pool Resource Game.
    Cooperates initially, then decides based on previous defections and stock level, and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.half_players = self.n_players // 2

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            prev_round = state.round_number - 1
            opponent_actions_last_round = history.opponent_actions[prev_round]
            n_defectors = np.sum(1 - opponent_actions_last_round)
            stock_threshold = 0.75 * self.capacity
            if n_defectors < self.half_players and state.current_stock > stock_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_507(BaseStrategy):
    """
    The Adaptive Cooperate-to-Defect strategy balances cooperation and defection based on stock trends and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.history_stock = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.history_stock.append(state.current_stock)
        if state.round_number == 0:
            return Action.C
        elif len(self.history_stock) < 3:
            return Action.C
        else:
            if state.round_number == self.n_rounds - 1:
                return Action.D
            current_stock = state.current_stock
            if current_stock < 0.25 * self.capacity:
                return Action.D
            else:
                avg_stock = sum(self.history_stock[-3:]) / 3.0
                if avg_stock > 0.75 * self.capacity:
                    prev_my_action = history.my_actions[-1]
                    prev_opponent_actions = history.opponent_actions[-1, :]
                    total_C = prev_my_action + prev_opponent_actions.sum()
                    cooperation_rate = total_C / self.n_players
                    if cooperation_rate > 0.5:
                        return Action.C
                    else:
                        return Action.D
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_508(BaseStrategy):
    """
    A strategy that adapts based on opponents' cooperation, stock levels, and endgame situations.
    
    The strategy begins by cooperating to observe initial behaviors. It defects in the last two rounds.
    It switches to defecting if the average defection rate among players is 50% or higher but cooperates
    to conserve the stock if it falls below half the capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        if state.current_stock < self.game_description.capacity / 2:
            return Action.C
        total_defections = 0
        n_players = self.game_description.n_players
        n_rounds_analyzed = state.round_number
        for t in range(n_rounds_analyzed):
            my_defection = 0 if history.my_actions[t] else 1
            opponent_defections = history.opponent_actions[t].shape[0] - sum(history.opponent_actions[t])
            total_defections += my_defection + opponent_defections
        average_defection_rate = total_defections / (n_players * n_rounds_analyzed)
        if average_defection_rate >= 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_509(BaseStrategy):
    """
    Adaptive Exploitation Strategy for Common Pool Resource Game.
    Balances cooperation and exploitation based on game state and opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishing = False
        self.punishment_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1 or state.current_stock < 0.3 * self.game_description.capacity:
            return Action.D
        if state.current_stock < 0.7 * self.game_description.capacity:
            return Action.D
        if self.punishing and self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            return Action.D
        if self.punishing and self.punishment_rounds_remaining == 0:
            self.punishing = False
        if history is not None:
            last_round = history.my_actions.size - 1
            opponent_actions_last = history.opponent_actions[last_round, :]
            opponent_coop = sum(opponent_actions_last)
            player_coop = history.my_actions[last_round]
            total_coop = opponent_coop + (1 if player_coop else 0)
            percent_coop = total_coop / self.game_description.n_players
            if percent_coop > 0.5:
                return Action.C
            else:
                self.punishing = True
                self.punishment_rounds_remaining = 2
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_510(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts based on cooperation history, 
    stock levels, and round number to maximize total payoff while maintaining resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        sum_C = history.my_actions.sum() + history.opponent_actions.sum()
        cooperation_rate = sum_C / (state.round_number * n_players)
        stock_threshold_low = 0.25 * capacity
        if state.current_stock < stock_threshold_low:
            return Action.C
        if state.round_number == total_rounds - 1:
            stock_threshold_last = 0.5 * capacity
            if state.current_stock > stock_threshold_last:
                return Action.D
            else:
                return Action.C
        if cooperation_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_511(BaseStrategy):
    """
    Adaptive strategy for the Common Pool Resource Game that balances cooperation with strategic defection.
    Cooperates initially, monitors stock trends, and defects when necessary to maximize payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.initial_coop_rounds = 2
        self.trigger_threshold = 0.2
        self.critical_stock_level = 0.3
        self.endgame_threshold = 2
        self.stock_history = [self.capacity]
        self.triggered = False
        self.consecutive_decreases = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        self.stock_history.append(current_stock)
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        if current_stock < self.critical_stock_level * self.capacity:
            return Action.D
        if self.triggered:
            return Action.D
        if round_number >= self.n_rounds - self.endgame_threshold:
            return Action.D
        if round_number >= self.initial_coop_rounds:
            if len(self.stock_history) >= 2:
                prev_stock = self.stock_history[-2]
                if prev_stock == 0:
                    change = 0.0
                else:
                    change = (prev_stock - current_stock) / prev_stock
                if change > self.trigger_threshold:
                    self.consecutive_decreases += 1
                else:
                    self.consecutive_decreases = 0
                if self.consecutive_decreases >= 2:
                    self.triggered = True
                else:
                    self.triggered = False
        return Action.C

class Strategy_EXPLOITATIVE_483(BaseStrategy):
    """
    Adaptive Exploitation Strategy (AES) for the Common Pool Resource game.
    Cooperates initially, then dynamically adapts based on observed defection rates and stock levels.
    Defects in the last round to maximize final payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if history is None or len(history.opponent_actions) == 0:
            return Action.C
        n_opp = self.game_description.n_players - 1
        recent_start = max(0, len(history.opponent_actions) - self.k)
        recent_actions = history.opponent_actions[recent_start:]
        recent_rounds = recent_actions.shape[0]
        if recent_rounds == 0:
            avg_defectors = 0.0
        else:
            defectors = np.sum(recent_actions == False, axis=1)
            total_defectors = np.sum(defectors)
            avg_defectors = total_defectors / (recent_rounds * n_opp)
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock < capacity / 2:
            return Action.C
        elif avg_defectors > 0.3:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_506(BaseStrategy):
    """
    Adaptive Exploitation strategy for the Common Pool Resource Game.
    Switches between cooperation and defection based on stock level, others' cooperation, and personal payoff history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.expected_payoff = game_description.capacity / (2 * self.n_players)

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round == 0:
            return Action.C
        elif current_round == total_rounds - 1:
            return Action.D
        else:
            if state.current_stock < 0.3 * self.capacity:
                return Action.C
            avg_coop = 0.0
            total_rounds_so_far = current_round
            for t in range(total_rounds_so_far):
                my_action = history.my_actions[t]
                opponents_actions = history.opponent_actions[t]
                coop_count = int(my_action) + int(opponents_actions.sum())
                avg_coop += coop_count / self.n_players
            avg_coop /= total_rounds_so_far
            if avg_coop > 0.7:
                return Action.D
            past_payoff_sum = history.my_payoffs.sum()
            avg_payoff = past_payoff_sum / total_rounds_so_far
            if avg_payoff < self.expected_payoff:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_512(BaseStrategy):
    """
    Adaptive Exploitation for Sustainable Gain strategy.
    Cooperates initially to conserve stock, exploits when conditions are favorable,
    and defects in the endgame. Also cooperates if stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if state.round_number >= n_rounds - 2:
            return Action.D
        if state.current_stock < 0.2 * capacity:
            return Action.C
        prev_round = state.round_number - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round]
        cooperators = sum(opp_prev_actions) + (1 if my_prev_action else 0)
        stock_above_threshold = state.current_stock > 0.5 * capacity
        majority = cooperators > n_players / 2
        if stock_above_threshold and majority:
            return Action.D
        else:
            return Action.C