"""
Generated LLM strategies for social dilemma games.

This file contains strategy classes generated by LLMs for game theory experiments.
Each strategy is a callable class that implements a specific approach to the game.

Generated with:
- Provider: Client
- Model: gemini-2.5-flash-lite
- Game: CommonPoolDescription
"""

from emergent_llm.players import BaseStrategy
from emergent_llm.games import PublicGoodsDescription, CollectiveRiskDescription, CommonPoolDescription, CommonPoolState
from emergent_llm.common import Action, C, D, PlayerHistory, GameState
import numpy as np
from numpy.typing import NDArray
import math
import random



class Strategy_COOPERATIVE_1(BaseStrategy):
    """
    Adaptive Sustainability Strategy:
    This strategy aims to maximize long-term cumulative payoff by prioritizing
    the sustainability of the common resource. It defaults to cooperation but
    adapts based on stock levels and game progression.

    - Always cooperates in the first round.
    - Always defects in the last round to maximize individual payoff.
    - Cooperates when the stock is abundant or moderately healthy.
    - Cooperates even when the stock is critically low to give it a chance to recover,
      unless it's near complete depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.ABUNDANT_THRESHOLD_RATIO = 0.75
        self.CRITICAL_THRESHOLD_RATIO = 0.25
        self.NEAR_COLLAPSE_THRESHOLD = 1.0

    def _is_cooperate(self, current_stock: float) -> bool:
        """Determines if the player should cooperate based on current stock."""
        if current_stock < self.NEAR_COLLAPSE_THRESHOLD:
            return True
        if current_stock > self.capacity * self.ABUNDANT_THRESHOLD_RATIO:
            return True
        if current_stock > self.capacity * self.CRITICAL_THRESHOLD_RATIO:
            return True
        if current_stock <= self.capacity * self.CRITICAL_THRESHOLD_RATIO:
            return True
        return True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if self._is_cooperate(current_stock):
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_2(BaseStrategy):
    """
    The "Sustainable Harvester" strategy.

    This strategy aims to maximize long-term collective payoff by fostering a
    sustainable stock level. It cooperates by default when the stock is healthy
    and other players appear cooperative. It defects only when the stock is
    critically low, when other players are predominantly defecting, or in the
    final round to maximize immediate gains. The strategy adaptively adjusts
    its cooperative threshold based on the game's trajectory.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.my_player_index = -1
        self.cooperative_threshold_pct = 0.6
        self.critical_threshold_pct = 0.2
        self.average_cooperation_threshold = 0.5
        self.adjustment_window = 5
        self.adjustment_rate = 0.05
        self.stock_changes = []
        self.other_cooperation_ratios = []
        self.initial_cooperative_threshold = self.cooperative_threshold_pct * self.capacity
        self.current_cooperative_threshold = self.initial_cooperative_threshold
        self.critical_threshold = self.critical_threshold_pct * self.capacity

    def _get_my_index(self, state: CommonPoolState, history: PlayerHistory):
        """
        Helper to determine this player's index. This is typically provided
        by the environment but can be inferred if needed for custom setups.
        For this problem, we assume it's not directly available and we might need
        to infer it or assume it's managed by the environment.
        However, standard `BaseStrategy` implementations often have a way to get it.
        Assuming we don't have it directly, we'll have to work around it or make
        assumptions if history.opponent_actions is structured such that we can infer.
        Given the provided PlayerHistory structure, `my_actions` is indexed first,
        and `opponent_actions` are indexed by [round, player]. The environment usually
        ensures `my_actions` corresponds to this player and `opponent_actions` are
        all *other* players. We will assume `history.my_actions` correctly maps to
        this player's actions in past rounds.
        """
        if self.my_player_index == -1:
            pass

    def _calculate_average_other_cooperation(self, history: PlayerHistory) -> float:
        """Calculates the average cooperation ratio of other players."""
        if history.round_number == 0 or self.n_players == 1:
            return 1.0
        if history.opponent_actions.shape[0] == 0:
            return 1.0
        last_round_opponent_actions = history.opponent_actions[-1, :]
        cooperators = np.sum(last_round_opponent_actions)
        num_opponents = len(last_round_opponent_actions)
        if num_opponents == 0:
            return 1.0
        return cooperators / num_opponents

    def _adjust_thresholds(self, state: CommonPoolState, history: PlayerHistory):
        """Dynamically adjusts cooperative_threshold based on game trajectory."""
        if history.round_number < 2:
            return
        previous_stock = self.previous_stock_level
        current_stock = state.current_stock
        stock_change = current_stock - previous_stock
        self.stock_changes.append(stock_change)
        if len(self.stock_changes) > self.adjustment_window:
            self.stock_changes.pop(0)
        avg_stock_change = np.mean(self.stock_changes)
        avg_other_cooperation = np.mean(self.other_cooperation_ratios[-self.adjustment_window:]) if self.other_cooperation_ratios else 1.0
        if avg_stock_change > 0.05 * self.capacity and avg_other_cooperation > 0.7:
            self.current_cooperative_threshold = max(self.critical_threshold * 1.5, self.current_cooperative_threshold - self.adjustment_rate * self.capacity)
        elif avg_stock_change < -0.05 * self.capacity and avg_other_cooperation < 0.3:
            self.current_cooperative_threshold = min(self.capacity * 0.9, self.current_cooperative_threshold + self.adjustment_rate * self.capacity)
        self.current_cooperative_threshold = max(self.critical_threshold * 1.5, self.current_cooperative_threshold)
        self.current_cooperative_threshold = min(self.capacity * 0.9, self.current_cooperative_threshold)

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        total_rounds = self.n_rounds
        if history is None:
            self.previous_stock_level = current_stock
            return Action.C
        avg_other_coop = self._calculate_average_other_cooperation(history)
        self.other_cooperation_ratios.append(avg_other_coop)
        self._adjust_thresholds(state, history)
        self.previous_stock_level = current_stock
        if current_stock < self.critical_threshold:
            return Action.D
        if round_num == total_rounds:
            return Action.D
        if current_stock >= self.current_cooperative_threshold:
            if avg_other_coop >= self.average_cooperation_threshold:
                return Action.C
            else:
                return Action.D
        elif avg_other_coop >= self.average_cooperation_threshold + 0.2:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_3(BaseStrategy):
    """
    Cooperative Strategy: "Sustainable Harvest with Adaptive Restraint"

    This strategy prioritizes maintaining a healthy stock level for sustained harvests,
    viewing defection as a last resort when cooperation becomes unsustainable or is
    clearly being exploited. It aims to adapt to the current stock level and the
    end-game dynamics.

    Core Principles:
    1. Maintain a "Cooperative Target Stock": Aims to keep stock above capacity / 2.
    2. Cooperate by Default: Chooses C unless specific conditions trigger D.
    3. Punish Exploitation (implicitly): If defecting would exceed sustainable limits,
       it defaults to C, thus not contributing to over-consumption.
    4. Acknowledge End-Game Dynamics: Defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.n_float = float(game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == self.n_rounds:
            return Action.D
        if current_stock < 1e-06:
            return Action.C
        target_next_round_stock = self.capacity / 2.0
        sustainable_total_consumption_threshold = current_stock - target_next_round_stock
        sustainable_total_consumption_threshold = max(0.0, sustainable_total_consumption_threshold)
        my_cooperative_consumption = current_stock / (2.0 * self.n_float)
        my_defect_consumption = current_stock / self.n_float
        if current_stock < self.capacity / 2.0:
            return Action.C
        expected_others_cooperative_consumption = (self.n_float - 1.0) * my_cooperative_consumption
        max_individual_consumption_if_others_coop = sustainable_total_consumption_threshold - expected_others_cooperative_consumption
        if my_defect_consumption <= max_individual_consumption_if_others_coop:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_4(BaseStrategy):
    """
    Adaptive Sustainer strategy for the Common Pool Resource Game.

    This strategy defaults to cooperation but retaliates proportionally and temporarily
    when defection is detected. It aims to maximize long-term collective payoff
    by prioritizing resource regeneration and responding adaptively to the
    behavior of other players and the state of the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Sustainer strategy.

        Args:
            game_description: An object containing game parameters like n_players,
                              n_rounds, and capacity.
        """
        self.game_description = game_description
        self.RETALIATION_DEFECT_FRACTION = 0.4
        self.STOCK_HEALTH_THRESHOLD_FRACTION = 0.3
        self.STOCK_RECOVERY_THRESHOLD_FRACTION = 0.5

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: Current state of the game, including round number and stock.
            history: Historical data of actions and payoffs, or None if it's the
                     first round.

        Returns:
            The chosen Action (Action.C or Action.D).
        """
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 1:
            return Action.C
        if round_number == r:
            return Action.C
        if current_stock <= 0:
            return Action.C
        if history is None or history.round_number == 0:
            return Action.C
        our_previous_action_cooperated = history.my_actions[history.round_number - 1]
        num_defect_prev_round = n - 1 - np.sum(history.opponent_actions[history.round_number - 1, :])
        if not our_previous_action_cooperated:
            num_defect_prev_round += 1
        decision = Action.C
        retaliation_triggered = False
        if num_defect_prev_round / n >= self.RETALIATION_DEFECT_FRACTION:
            retaliation_triggered = True
        if current_stock < capacity * self.STOCK_HEALTH_THRESHOLD_FRACTION and num_defect_prev_round > 0:
            retaliation_triggered = True
        if retaliation_triggered:
            should_forgive_and_cooperate = False
            if num_defect_prev_round == 0:
                should_forgive_and_cooperate = True
            if current_stock >= capacity * self.STOCK_RECOVERY_THRESHOLD_FRACTION:
                if num_defect_prev_round > 0:
                    should_forgive_and_cooperate = True
            if not should_forgive_and_cooperate:
                decision = Action.D
        return decision

class Strategy_COOPERATIVE_5(BaseStrategy):
    """
    The "Sustainable Stock Guardian" strategy aims to maximize long-term collective well-being
    while ensuring individual survival in the Common Pool Resource Game. It prioritizes
    cooperation when the resource is abundant and shifts towards a more cautious approach
    as the resource depletes.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.s_threshold = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if history is None:
            return Action.C
        if current_round == self.r:
            return Action.D
        if current_stock < 1e-06:
            return Action.C
        if current_stock > self.s_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_6(BaseStrategy):
    """
    Adaptive Sustainable Consumption (ASC) Strategy for the Common Pool Resource Game.

    This strategy aims to balance short-term individual gain with long-term collective
    sustainability. It monitors the stock level relative to its capacity and adapts
    its behavior based on defined thresholds and observed opponent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the ASC strategy.

        Args:
            game_description: An object containing game parameters like n_players,
                              n_rounds, and capacity.
        """
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.memory_window = 5
        self.cooperation_threshold_medium = 0.7
        self.T_high = 0.8
        self.T_medium_low = 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: Current state of the game, including round_number and current_stock.
            history: History of actions and payoffs for all players if available
                     (None for the first round).

        Returns:
            The chosen action: Action.C (Cooperate) or Action.D (Defect).
        """
        current_round = state.round_number
        current_stock = float(state.current_stock)
        if history is None:
            return Action.C
        if current_round == self.n_rounds:
            return Action.D
        if current_stock <= 0:
            return Action.C
        stock_ratio = current_stock / self.capacity
        if stock_ratio >= self.T_high:
            return Action.C
        elif stock_ratio >= self.T_medium_low:
            previous_round_index = history.round_number - 1
            if previous_round_index >= 0:
                cooperators_prev_round = np.sum(history.opponent_actions[previous_round_index, :])
                num_opponents_prev_round = self.n_players - 1
                if num_opponents_prev_round > 0:
                    observed_cooperation_rate = cooperators_prev_round / num_opponents_prev_round
                    if observed_cooperation_rate >= self.cooperation_threshold_medium:
                        return Action.C
                    else:
                        return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        else:
            recent_exploitation_detected = False
            start_index = max(0, history.round_number - self.memory_window)
            for i in range(start_index, history.round_number):
                if not np.all(history.opponent_actions[i, :]):
                    recent_exploitation_detected = True
                    break
            if recent_exploitation_detected:
                return Action.D
            else:
                return Action.C

class Strategy_COOPERATIVE_7(BaseStrategy):
    """
    Cooperative but Cautious Strategy for Common Pool Resource Game.

    This strategy prioritizes long-term sustainability through cooperation but
    is designed to adapt to and counter exploitative behavior. It aims to
    maintain a healthy stock level by cooperating when the resource is abundant
    and conserving when it is scarce. It also monitors collective consumption
    patterns and will defect if it detects aggressive exploitation by other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.k_window_size = 4
        self.history_total_consumption = []

    def _calculate_thresholds(self) -> tuple[float, float]:
        """Calculates dynamic healthy and danger stock thresholds."""
        s_healthy = 0.7 * self.capacity
        s_danger = 0.3 * self.capacity
        return (s_healthy, s_danger)

    def _get_current_total_consumption(self, history: PlayerHistory) -> float:
        """Calculates the total consumption in the last completed round."""
        if history is None:
            return 0.0
        my_consumption = self.current_stock / (2.0 * self.n_players) if history.my_actions[-1] == Action.C.value else self.current_stock / self.n_players
        opponent_consumption_last_round = 0.0
        if history.opponent_actions.shape[0] > 0:
            for i in range(self.n_players - 1):
                opponent_action = history.opponent_actions[-1, i]
                opponent_consumption_last_round += self.current_stock / (2.0 * self.n_players) if opponent_action == Action.C.value else self.current_stock / self.n_players
        return my_consumption + opponent_consumption_last_round

    def _is_aggressive_defection_detected(self, current_stock: float, history: PlayerHistory) -> bool:
        """Detects if other players have been aggressively exploiting the resource."""
        if len(self.history_total_consumption) < self.k_window_size:
            return False
        expected_all_cooperate_total_consumption = current_stock / 2.0
        avg_past_total_consumption = np.mean(self.history_total_consumption)
        aggressive_defection_trigger_level = 1.1 * expected_all_cooperate_total_consumption
        return avg_past_total_consumption > aggressive_defection_trigger_level

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        self.current_stock = current_stock
        if current_round == self.n_rounds:
            return Action.D
        if current_stock <= 0:
            return Action.C
        if history is not None and len(history.my_actions) > 0:
            if history.round_number > 0:
                total_consumption_last_round = self._calculate_inferred_total_consumption_from_history(history)
                self.history_total_consumption.append(total_consumption_last_round)
                if len(self.history_total_consumption) > self.k_window_size:
                    self.history_total_consumption.pop(0)
        s_healthy, s_danger = self._calculate_thresholds()
        is_aggressive_defection = self._is_aggressive_defection_detected(current_stock, history)
        if current_stock > s_healthy:
            if is_aggressive_defection:
                return Action.D
            else:
                return Action.C
        elif s_danger <= current_stock <= s_healthy:
            if is_aggressive_defection:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

    def _calculate_inferred_total_consumption_from_history(self, history: PlayerHistory) -> float:
        """
        Infers total consumption for the *last completed round* from history.
        This is a critical part that's hard to implement perfectly without
        previous round's stock state. This is an approximation.
        """
        if history is None or history.round_number == 0:
            return 0.0
        my_action_last_round = history.my_actions[-1]
        opponent_actions_last_round = history.opponent_actions[-1, :]
        stock_proxy_for_last_round = self.current_stock
        my_consumption = 0.0
        if my_action_last_round == Action.C.value:
            my_consumption = stock_proxy_for_last_round / (2.0 * self.n_players)
        else:
            my_consumption = stock_proxy_for_last_round / self.n_players
        opponent_consumption_total = 0.0
        for action in opponent_actions_last_round:
            if action == Action.C.value:
                opponent_consumption_total += stock_proxy_for_last_round / (2.0 * self.n_players)
            else:
                opponent_consumption_total += stock_proxy_for_last_round / self.n_players
        return my_consumption + opponent_consumption_total

class Strategy_COOPERATIVE_8(BaseStrategy):
    """
    "Sustained Bounty" Strategy:
    Aims to maintain a target stock level by cooperating when the stock is healthy
    and no defection was observed in the previous round. It retaliates against
    defection and defects if the stock dips below a critical threshold, prioritizing
    resource regeneration and long-term collective payoffs, while also accounting
    for the end-game incentive to defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.target_stock_level = game_description.capacity / 2.0
        self.previous_round_anyone_defected = False
        self.current_round_tracker = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        self.current_round_tracker = state.round_number - 1
        if self.current_round_tracker == n_rounds - 1:
            return Action.D
        if self.current_round_tracker == 0:
            self.previous_round_anyone_defected = False
            return Action.C
        if history is not None:
            if history.round_number > 0:
                last_round_opponent_actions = history.opponent_actions[history.round_number - 1, :]
                if np.any(last_round_opponent_actions == Action.D.value):
                    self.previous_round_anyone_defected = True
                else:
                    self.previous_round_anyone_defected = False
            else:
                self.previous_round_anyone_defected = False
        else:
            self.previous_round_anyone_defected = False
        if current_stock < self.target_stock_level:
            return Action.D
        elif self.previous_round_anyone_defected:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_9(BaseStrategy):
    """
    A cooperative strategy for the Common Pool Resource Game that aims to maximize
    long-term cumulative payoff by fostering sustainable resource management.
    It defaults to cooperation but incorporates a punishment mechanism for
    significant stock depletion or widespread defection by opponents. It also
    includes a forgiveness mechanism to return to cooperation after a period
    of punishment, provided conditions are favorable.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold_ratio = 0.2
        self.punishment_activation_threshold_ratio = 0.5
        self.forgiveness_stock_ratio = 0.7
        self.forgiveness_cooperation_min_rounds = 2
        self.punishing = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if history is None:
            return Action.C
        if current_round == self.r:
            return Action.D
        critical_stock_level = self.capacity * self.critical_stock_threshold_ratio
        punishment_activation_threshold = math.ceil(self.n * self.punishment_activation_threshold_ratio)
        is_punishing_due_to_stock = current_stock < critical_stock_level
        num_opponents_defected_last_round = 0
        if history.opponent_actions.shape[0] > 0:
            num_opponents_defected_last_round = np.sum(history.opponent_actions[-1, :] == Action.D.value)
        is_punishing_due_to_defection = num_opponents_defected_last_round >= punishment_activation_threshold
        should_punish = is_punishing_due_to_stock or is_punishing_due_to_defection
        attempting_forgiveness = False
        if current_stock >= self.capacity * self.forgiveness_stock_ratio:
            cooperative_rounds_count = 0
            if history.round_number >= self.forgiveness_cooperation_min_rounds:
                for i in range(1, self.forgiveness_cooperation_min_rounds + 1):
                    recent_opp_actions = history.opponent_actions[-i, :]
                    my_recent_action = history.my_actions[-i]
                    if np.all(recent_opp_actions == Action.C.value) and my_recent_action == Action.C.value:
                        cooperative_rounds_count += 1
            if cooperative_rounds_count >= self.forgiveness_cooperation_min_rounds:
                attempting_forgiveness = True
        if should_punish and (not attempting_forgiveness):
            return Action.D
        elif attempting_forgiveness:
            return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_10(BaseStrategy):
    """
    Adaptive Sustainable Cooperation (ASC) strategy for the Common Pool Resource Game.

    This strategy prioritizes the long-term sustainability of the common pool resource.
    It generally cooperates when the resource is healthy and adapts its behavior based
    on the stock level and recent opponent defection history.
    It defects in the last round to maximize immediate payoff and cooperates in the
    first round to establish a cooperative norm.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_healthy = 0.75 * self.capacity
        self.threshold_low = 0.25 * self.capacity

    def _get_last_round_any_defection(self, history: PlayerHistory) -> bool:
        """
        Checks if any opponent defected in the most recent completed round.
        Returns True if at least one opponent defected, False otherwise.
        """
        if history.round_number == 0:
            return False
        last_round_actions = history.opponent_actions[-1, :]
        return not np.all(last_round_actions)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.n_rounds:
            return Action.D
        if history is None:
            return Action.C
        last_round_any_defect = self._get_last_round_any_defection(history)
        if current_stock >= self.threshold_healthy:
            return Action.C
        elif current_stock > self.threshold_low:
            if last_round_any_defect:
                return Action.D
            else:
                return Action.C
        elif last_round_any_defect:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_11(BaseStrategy):
    """
    The "Adaptive Sustainer" strategy.

    This strategy prioritizes long-term resource sustainability while
    adapting to the behavior of other players. It aims to cooperate when
    the resource is abundant and when others cooperate, but will defect
    to secure immediate gains or as a defensive measure when the resource
    is scarce or when others are perceived to be exploiting it.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.HIGH_STOCK_THRESHOLD = 0.75 * self.capacity
        self.LOW_STOCK_THRESHOLD = 0.25 * self.capacity
        self.OVERCONSUMPTION_FACTOR = 1.2

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if current_stock <= 0:
            return Action.C
        implied_defection_response = Action.C
        if history is not None and history.round_number > 0:
            previous_stock = current_stock + np.sum(history.my_actions[-1] * (current_stock / (2 * self.n)) + (1 - history.my_actions[-1]) * (current_stock / self.n))
            if hasattr(self, 'previous_round_stock') and self.previous_round_stock is not None:
                prev_stock = self.previous_round_stock
                estimated_total_consumption_last_round = 0
                my_prev_action = history.my_actions[-1]
                if my_prev_action:
                    estimated_total_consumption_last_round += prev_stock / (2 * self.n)
                else:
                    estimated_total_consumption_last_round += prev_stock / self.n
                for i in range(self.n - 1):
                    opp_prev_action = history.opponent_actions[-1, i]
                    if opp_prev_action:
                        estimated_total_consumption_last_round += prev_stock / (2 * self.n)
                    else:
                        estimated_total_consumption_last_round += prev_stock / self.n
                expected_coop_consumption_last_round = self.n * (prev_stock / (2 * self.n))
                if estimated_total_consumption_last_round > self.OVERCONSUMPTION_FACTOR * expected_coop_consumption_last_round:
                    implied_defection_response = Action.D
                elif prev_stock > self.HIGH_STOCK_THRESHOLD and estimated_total_consumption_last_round > expected_coop_consumption_last_round:
                    implied_defection_response = Action.D
        if current_stock > self.HIGH_STOCK_THRESHOLD:
            return Action.C
        elif self.LOW_STOCK_THRESHOLD <= current_stock <= self.HIGH_STOCK_THRESHOLD:
            if implied_defection_response == Action.C:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.HIGH_STOCK_THRESHOLD = 0.75 * self.capacity
        self.LOW_STOCK_THRESHOLD = 0.25 * self.capacity
        self.OVERCONSUMPTION_FACTOR = 1.2
        self.stock_at_start_of_previous_round = None

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if current_stock <= 0:
            return Action.C
        implied_defection_response = Action.C
        if history is not None and history.round_number > 0:
            prev_stock_start = self.stock_at_start_of_previous_round
            if prev_stock_start is not None:
                estimated_total_consumption_last_round = 0
                my_prev_action = history.my_actions[-1]
                if my_prev_action:
                    estimated_total_consumption_last_round += prev_stock_start / (2 * self.n)
                else:
                    estimated_total_consumption_last_round += prev_stock_start / self.n
                for i in range(self.n - 1):
                    opp_prev_action = history.opponent_actions[-1, i]
                    if opp_prev_action:
                        estimated_total_consumption_last_round += prev_stock_start / (2 * self.n)
                    else:
                        estimated_total_consumption_last_round += prev_stock_start / self.n
                expected_coop_consumption_last_round = self.n * (prev_stock_start / (2 * self.n))
                if estimated_total_consumption_last_round > self.OVERCONSUMPTION_FACTOR * expected_coop_consumption_last_round:
                    implied_defection_response = Action.D
                elif prev_stock_start > self.HIGH_STOCK_THRESHOLD and estimated_total_consumption_last_round > expected_coop_consumption_last_round:
                    implied_defection_response = Action.D
        if current_stock > self.HIGH_STOCK_THRESHOLD:
            return Action.C
        elif self.LOW_STOCK_THRESHOLD <= current_stock <= self.HIGH_STOCK_THRESHOLD:
            if implied_defection_response == Action.C:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_12(BaseStrategy):
    """
    The "Sustainable Harvester" strategy.
    This strategy prioritizes long-term resource sustainability by cooperating under
    most conditions. It switches to conditional defection only when the resource
    is critically low AND there are strong indications of aggressive play by others
    in the previous round. It aims to maximize cumulative payoff by ensuring the
    resource remains healthy for future extraction, while defending against
    exploitation when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.previous_stock_after_consumption = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if history is None:
            self.previous_stock_after_consumption = None
            return Action.C
        if current_stock <= 0:
            return Action.C
        critical_low_stock_threshold = 0.25 * self.capacity
        moderate_low_stock_threshold = 0.5 * self.capacity
        high_stock_threshold = 0.75 * self.capacity
        if current_stock > high_stock_threshold:
            action = Action.C
        elif current_stock > moderate_low_stock_threshold:
            action = Action.C
        elif current_stock > critical_low_stock_threshold:
            action = Action.C
        elif self.previous_stock_after_consumption is not None and self.previous_stock_after_consumption < 0.1 * self.capacity:
            action = Action.D
        else:
            action = Action.C
        if len(history.my_actions) > 0:
            prev_round_num = len(history.my_actions) - 1
            self.previous_stock_after_consumption = current_stock
        return action

class Strategy_COOPERATIVE_13(BaseStrategy):
    """
    The "Sustainable Stock Guardian" strategy for the Common Pool Resource Game.
    This strategy prioritizes the long-term health of the common pool by adapting
    its cooperation level based on the current stock, remaining rounds, and the
    game's capacity. It aims to maximize collective payoff by ensuring the stock
    remains at a sustainable level, defecting only in the final round to maximize
    individual payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with the game's parameters.

        Args:
            game_description: An object containing game parameters (n_players, n_rounds, capacity).
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game (round_number, current_stock).
            history: The history of actions and payoffs if not the first round, None otherwise.

        Returns:
            The action to take: Action.C (Cooperate) or Action.D (Defect).
        """
        current_stock = state.current_stock
        current_round = state.round_number
        rounds_remaining = self.r - current_round
        if history is None:
            if current_stock > self.capacity * 0.75:
                return Action.C
            else:
                return Action.C
        if rounds_remaining == 1:
            return Action.D
        if current_stock <= 0.01:
            return Action.C
        if current_stock > self.capacity * 0.75 and current_round < self.r * 0.75:
            return Action.C
        if current_stock > self.capacity * 0.4 and current_stock <= self.capacity * 0.75 and (rounds_remaining > 1):
            return Action.C
        if current_stock <= self.capacity * 0.4 and rounds_remaining > 1:
            return Action.C
        return Action.C

class Strategy_COOPERATIVE_14(BaseStrategy):
    """
    The "Sustainable Steward" strategy is designed to be a responsible and adaptive
    player in the Common Pool Resource Game. It prioritizes the long-term health
    of the resource, recognizing that a depleted stock benefits no one. However,
    it also incorporates mechanisms to protect itself from depletion due to
    exploitative behavior by others.

    Decision Rules:
    1. Prioritize Stock Replenishment (Cooperate by Default): If current_stock is
       above a defined "healthy threshold", Cooperate (C).
    2. Risk Aversion (Defect if Stock is Low): If current_stock falls below a
       defined "critical threshold", Defect (D).
    3. Adaptive Response to Opponent Behavior: If a significant number of players
       have consistently defected in recent rounds, lean towards Defection (D).
    4. "Forgiveness" and Re-cooperation: If an opponent returns to a cooperative
       pattern, gradually re-establish trust.

    Edge Cases:
    - First Round: Cooperate (C).
    - Last Round: Defect (D) to maximize immediate payoff.
    - Stock at Capacity: Cooperate (C).
    - Stock at Zero: Action is moot, but logically attempt to cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.HEALTHY_THRESHOLD_RATIO = 0.6
        self.CRITICAL_THRESHOLD_RATIO = 0.2
        self.DEFECTION_PROPORTION_TO_RETALIATE = 0.5
        self.MIN_CONSECUTIVE_DEFECTIONS_TO_CONSIDER_EXPLOITER = 3
        self.MIN_COOPERATIVE_ROUNDS_TO_FORGIVE = 3
        self.opponent_consecutive_defection_counts = np.zeros(self.game_description.n_players, dtype=int)
        self.opponent_last_action_was_cooperate = np.zeros(self.game_description.n_players, dtype=bool)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == r:
            return Action.D
        if history is None:
            self.opponent_consecutive_defection_counts = np.zeros(n, dtype=int)
            self.opponent_last_action_was_cooperate = np.zeros(n, dtype=bool)
            return Action.C
        if history.round_number > 0:
            last_round_idx = history.round_number - 1
            for i in range(n):
                if i < history.opponent_actions.shape[1]:
                    opponent_action_last_round = history.opponent_actions[last_round_idx, i]
                    if opponent_action_last_round:
                        self.opponent_consecutive_defection_counts[i] = 0
                        self.opponent_last_action_was_cooperate[i] = True
                    else:
                        self.opponent_consecutive_defection_counts[i] += 1
                        self.opponent_last_action_was_cooperate[i] = False
            for i in range(n):
                if self.opponent_consecutive_defection_counts[i] >= self.MIN_CONSECUTIVE_DEFECTIONS_TO_CONSIDER_EXPLOITER:
                    cooperative_streak = 0
                    for k in range(history.round_number - 1, -1, -1):
                        if k < history.opponent_actions.shape[1]:
                            if history.opponent_actions[k, i]:
                                cooperative_streak += 1
                            else:
                                break
                        else:
                            break
                    if cooperative_streak >= self.MIN_COOPERATIVE_ROUNDS_TO_FORGIVE:
                        self.opponent_consecutive_defection_counts[i] = 0
        healthy_threshold = capacity * self.HEALTHY_THRESHOLD_RATIO
        critical_threshold = capacity * self.CRITICAL_THRESHOLD_RATIO
        is_healthy_stock = current_stock >= healthy_threshold
        is_critical_stock = current_stock <= critical_threshold
        num_exploiters = 0
        for i in range(n):
            if self.opponent_consecutive_defection_counts[i] >= self.MIN_CONSECUTIVE_DEFECTIONS_TO_CONSIDER_EXPLOITER:
                num_exploiters += 1
        proportion_exploiters = num_exploiters / n
        if is_critical_stock:
            return Action.D
        elif is_healthy_stock:
            if proportion_exploiters >= self.DEFECTION_PROPORTION_TO_RETALIATE:
                return Action.D
            else:
                return Action.C
        elif proportion_exploiters >= self.DEFECTION_PROPORTION_TO_RETALIATE:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_15(BaseStrategy):
    """
    The Sustainable Cooperator strategy.

    This strategy prioritizes long-term sustainable resource management.
    It cooperates when the stock is healthy and defaults to defection
    when the stock is low or when other players exhibit sustained defection.
    It also has a strong inclination to defect in the final round to
    maximize immediate personal gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold_ratio = 0.6
        self.punishment_level_ratio = 0.5
        self.recooperation_grace_period = 3
        self.opponent_defect_count = 0
        self.consecutive_cooperative_rounds_from_opponents = 0

    def _calculate_consumption(self, stock: float, action: Action) -> float:
        if action == Action.C:
            return stock / (2 * self.n_players)
        else:
            return stock / self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if history is None:
            self.opponent_defect_count = 0
            self.consecutive_cooperative_rounds_from_opponents = 0
            return Action.C
        observed_defections_this_round = 0
        if history.opponent_actions.size > 0:
            observed_defections_this_round = np.sum(~history.opponent_actions[-1, :])
        self.opponent_defect_count += observed_defections_this_round
        if current_round_number == self.n_rounds:
            return Action.D
        cooperation_threshold = self.cooperation_threshold_ratio * self.capacity
        punishment_level = max(1, math.ceil(self.punishment_level_ratio * self.n_players))
        if current_stock > cooperation_threshold:
            if self.opponent_defect_count >= punishment_level:
                self.consecutive_cooperative_rounds_from_opponents = 0
                return Action.D
            else:
                self.consecutive_cooperative_rounds_from_opponents += 1
                return Action.C
        else:
            self.consecutive_cooperative_rounds_from_opponents = 0
            return Action.D

class Strategy_COOPERATIVE_16(BaseStrategy):
    """
    The "Sustainable Stock Manager" strategy.

    This strategy aims to maximize long-term cumulative payoff by prioritizing
    the sustainability of the common pool resource. It adapts its behavior based
    on the current stock level and the round number.

    Decision rules:
    - First Round (t=1): Always Cooperate (C) to set a cooperative tone.
    - Last Round (t=r): Always Defect (D) to maximize immediate payoff.
    - Intermediate Rounds (1 < t < r):
        - If stock >= cooperation_threshold: Cooperate (C).
        - If stock < cooperation_threshold: Defect (D).

    The cooperation_threshold is set as 70% of the capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold = 0.7 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if history is None:
            return Action.C
        if current_round == self.r:
            return Action.D
        if current_stock >= self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_17(BaseStrategy):
    """
    Cooperative-Adaptive Strategy: "Sustainable Yield with Rebalancing"

    This strategy aims to maximize long-term, cumulative payoff by fostering
    sustainable resource extraction. It prioritizes cooperation but incorporates
    conditional defection to protect its own gains if others are depleting
    the resource too aggressively.

    Decision Rule:
    - Cooperate (C) if the average consumption per player in the previous round
      was less than or equal to the per-player cooperative consumption target
      of that previous round.
    - Defect (D) otherwise.

    Special Cases:
    - First Round (t=1): Always Cooperate (C) to set a cooperative norm.
    - Last Round (t=r): Always Defect (D) to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        if current_round_number == self.r:
            return Action.D
        if history is None:
            return Action.C
        previous_round_index = history.round_number - 1
        if not hasattr(self, 'stock_at_start_of_previous_round'):
            self.stock_at_start_of_previous_round = self.capacity
        if not hasattr(self, 'actions_in_previous_round'):
            self.actions_in_previous_round = None
        current_round_num = state.round_number
        current_stock_for_this_round = state.current_stock
        if current_round_num == self.r:
            return Action.D
        if history is None:
            self.stock_at_start_of_previous_round = current_stock_for_this_round
            return Action.C
        actions_in_prev_round = []
        player_i_action_prev = Action.C if history.my_actions[current_round_num - 1] else Action.D
        actions_in_prev_round.append(player_i_action_prev)
        for i in range(self.n - 1):
            opponent_action_prev = Action.C if history.opponent_actions[current_round_num - 1, i] else Action.D
            actions_in_prev_round.append(opponent_action_prev)
        total_consumption_prev_round = 0
        for action in actions_in_prev_round:
            if action == Action.C:
                total_consumption_prev_round += self.stock_at_start_of_previous_round / (2.0 * self.n)
            else:
                total_consumption_prev_round += self.stock_at_start_of_previous_round / self.n
        average_consumption_per_player = total_consumption_prev_round / self.n
        cooperative_consumption_per_player_target = self.stock_at_start_of_previous_round / (2.0 * self.n)
        if average_consumption_per_player <= cooperative_consumption_per_player_target:
            my_action = Action.C
        else:
            my_action = Action.D
        self.stock_at_start_of_previous_round = current_stock_for_this_round
        return my_action

class Strategy_COOPERATIVE_18(BaseStrategy):
    """
    The "Cautious Steward" strategy.
    This strategy aims to maximize collective long-term gain by initially cooperating,
    but responding to defection with temporary punishment (one round of defection
    if stock is high, or sustained defection if stock is medium) until the stock recovers.
    It prioritizes resource preservation when the stock is low. Defection is employed
    in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.low_stock_threshold = 0.2 * self.capacity
        self.high_stock_threshold = 0.8 * self.capacity
        self._in_sustained_punishment = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.r:
            self._in_sustained_punishment = False
            return Action.D
        if current_stock <= 0:
            self._in_sustained_punishment = False
            return Action.C
        defections_in_previous_round = False
        if history is not None and history.round_number > 0:
            if not history.my_actions[-1]:
                defections_in_previous_round = True
            for opp_action in history.opponent_actions[-1]:
                if not opp_action:
                    defections_in_previous_round = True
                    break
        if self._in_sustained_punishment:
            if current_stock > self.high_stock_threshold:
                self._in_sustained_punishment = False
                if not defections_in_previous_round:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        if current_stock > self.high_stock_threshold:
            if not defections_in_previous_round:
                return Action.C
            else:
                return Action.D
        elif current_stock < self.low_stock_threshold:
            self._in_sustained_punishment = False
            return Action.C
        elif not defections_in_previous_round:
            return Action.C
        else:
            self._in_sustained_punishment = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_19(BaseStrategy):
    """
    Cooperative strategy focused on maximizing long-term harvestable surplus.
    Defaults to cooperation and defects only when unsustainable depletion is observed.
    Adaptively adjusts its depletion threshold based on stock health and past behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.initial_depletion_threshold = 0.7
        self.depletion_threshold = self.initial_depletion_threshold
        self.min_viable_stock = self.n_players
        self.stock_at_start_of_last_round = self.capacity
        self.total_consumption_last_round = 0.0
        self.last_action_was_defect = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if history is None:
            self.stock_at_start_of_last_round = current_stock
            self.total_consumption_last_round = 0.0
            self.last_action_was_defect = False
            self.depletion_threshold = self.initial_depletion_threshold
            return Action.C
        if current_stock < self.min_viable_stock:
            self.last_action_was_defect = False
            return Action.C
        relative_depletion = 0.0
        if self.stock_at_start_of_last_round > 0:
            relative_depletion = self.total_consumption_last_round / self.stock_at_start_of_last_round
        action = Action.C
        if relative_depletion > self.depletion_threshold:
            action = Action.D
        if self.last_action_was_defect and relative_depletion > self.depletion_threshold:
            self.depletion_threshold = max(0.1, self.depletion_threshold - 0.02)
        elif not self.last_action_was_defect and relative_depletion <= self.depletion_threshold:
            if current_stock > self.capacity * 0.8:
                self.depletion_threshold = min(0.9, self.depletion_threshold + 0.01)
        elif not self.last_action_was_defect and relative_depletion > self.depletion_threshold:
            self.depletion_threshold = max(0.1, self.depletion_threshold - 0.01)
        self.stock_at_start_of_last_round = current_stock
        my_consumption = 0.0
        if action == Action.C:
            my_consumption = current_stock / (2 * self.n_players)
        else:
            my_consumption = current_stock / self.n_players
        total_consumption_this_round = my_consumption
        if history.opponent_actions.shape[0] > 0:
            opponent_actions_last_round = history.opponent_actions[round_number - 1, :]
            for opp_action in opponent_actions_last_round:
                if opp_action == Action.C.value:
                    total_consumption_this_round += current_stock / (2 * self.n_players)
                else:
                    total_consumption_this_round += current_stock / self.n_players
        self.total_consumption_last_round = total_consumption_this_round
        self.last_action_was_defect = action == Action.D
        return action

class Strategy_COOPERATIVE_20(BaseStrategy):
    """
    'Sustainable Exploitation' Strategy for the Common Pool Resource Game.

    This strategy aims to maximize long-term collective well-being by maintaining
    the stock at a healthy level, while still extracting a reasonable amount for
    individual benefit. It balances the immediate temptation of defecting with
    the long-term consequences of stock depletion.

    The strategy operates on a principle similar to 'tit-for-tat', but adapted
    for a common pool resource. It starts cooperatively, retaliates against
    defection when the stock is healthy, but is forgiving if the stock can recover.
    It prioritizes the health of the resource, understanding that its own
    long-term payoff is inextricably linked to the sustainability of the common pool.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing n_players, n_rounds, and capacity.
        """
        self.n_players: int = game_description.n_players
        self.n_rounds: int = game_description.n_rounds
        self.capacity: float = float(game_description.capacity)
        self.k_threshold: float = 0.7

    def _get_cooperative_threshold(self) -> float:
        """Calculates the stock level considered healthy for cooperation."""
        return self.capacity * self.k_threshold

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: An object containing the current round number and stock level.
            history: An object containing past actions and payoffs, or None for the first round.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_stock: float = state.current_stock
        current_round: int = state.round_number
        if current_round == self.n_rounds:
            return Action.D
        if current_stock <= self.n_players:
            return Action.C
        cooperative_threshold: float = self._get_cooperative_threshold()
        if history is None:
            return Action.C
        else:
            my_last_action: bool = history.my_actions[-1]
            opponent_actions_last_round: NDArray[np.bool_] = history.opponent_actions[-1, :]
            any_opponent_defected_last_round: bool = np.any(~opponent_actions_last_round)
            all_cooperated_last_round: bool = np.all(np.concatenate(([my_last_action], opponent_actions_last_round)))
            if current_stock >= cooperative_threshold:
                if any_opponent_defected_last_round:
                    return Action.D
                else:
                    return Action.C
            elif all_cooperated_last_round:
                return Action.C
            else:
                return Action.D

class Strategy_COOPERATIVE_21(BaseStrategy):
    """
    Cooperative & Adaptive Strategy: "Sustainable Harvest"

    This strategy aims to maximize long-term collective payoff by promoting
    sustainable resource management while being resilient to opportunistic play.
    It's designed to be cooperative by default, but capable of defending the
    common pool when necessary.

    Decision Rules:
    - Cooperate (C): If current stock is above the Cooperation Threshold (CT).
    - Defect (D): If current stock is at or below the Conservation Threshold (ConsT).
    - Cooperate (C): If current stock is between ConsT and CT (uncertain zone).

    Thresholds:
    - Cooperation Threshold (CT): 0.75 * capacity
    - Conservation Threshold (ConsT): 0.25 * capacity

    Edge Cases:
    - First Round: Cooperate.
    - Last Round: Defect to maximize immediate gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like n_players,
                              n_rounds, and capacity.
        """
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold = 0.75 * self.capacity
        self.conservation_threshold = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Chooses an action (Cooperate or Defect) based on the current state and history.

        Args:
            state: The current state of the game, including round number and current stock.
            history: History of past actions and payoffs, or None if it's the first round.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.n_rounds:
            return Action.D
        if history is None:
            return Action.C
        if current_stock > self.cooperation_threshold:
            return Action.C
        elif current_stock <= self.conservation_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_22(BaseStrategy):
    """
    Sustainable Yield Maximizer (SYM) Strategy.

    This strategy aims to maximize cumulative payoff by prioritizing the long-term
    health of the common pool resource. It cooperates by default, but defects
    strategically when the stock is critically low or in the last round to
    maximize immediate gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold_fraction = 0.6
        self.critical_depletion_threshold_fraction = 0.2
        self.cooperation_threshold = self.cooperation_threshold_fraction * self.capacity
        self.critical_depletion_threshold = self.critical_depletion_threshold_fraction * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            coop_payoff = current_stock / (2.0 * self.n)
            defect_payoff = current_stock / self.n
            if defect_payoff > coop_payoff:
                return Action.D
            else:
                return Action.C
        if current_stock < self.critical_depletion_threshold:
            return Action.D
        if current_stock >= self.cooperation_threshold:
            return Action.C
        return Action.C

class Strategy_COOPERATIVE_23(BaseStrategy):
    """
    The "Sustainable Seeker" strategy.

    This strategy prioritizes the long-term sustainability of the common pool resource.
    It defaults to cooperating (C) but will strategically defect (D) if the stock
    drops below a critical threshold AND there is evidence of unsustainable depletion
    in the previous round. This defection serves as a signal to other players.
    It always cooperates in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.strategic_threshold_ratio = 0.5
        self.unsustainable_depletion_threshold_ratio = 0.05
        self.last_stock = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round = state.round_number
        if history is None:
            self.last_stock = current_stock
            return Action.C
        if current_round == r:
            return Action.C
        strategic_threshold = capacity * self.strategic_threshold_ratio
        action = Action.C
        if current_stock <= strategic_threshold:
            if self.last_stock > 0:
                depletion_amount = self.last_stock - current_stock
                if depletion_amount > capacity * self.unsustainable_depletion_threshold_ratio:
                    action = Action.D
        self.last_stock = current_stock
        return action

class Strategy_COOPERATIVE_24(BaseStrategy):
    """
    "Sustainable Grasp" Strategy for the Common Pool Resource Game.

    This strategy aims to maximize long-term collective well-being by prioritizing
    resource sustainability. It cooperates by default, but adapts by:
    1. Rewarding cooperation and punishing defection through a "cooperation score".
    2. Responding to critical stock levels by defecting to secure any remaining payoff.
    3. Adapting to opponent behavior, cooperating when opponents are cooperative and
       defecting when exploitation is observed or the resource is scarce.
    It also handles edge cases like the first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_LOW_RATIO = 0.2
        self.HEALTHY_STOCK_HIGH_RATIO = 0.7
        self.MIN_COOPERATION_SCORE_FOR_FULL_COOPERATION = 0.7
        self.MAX_DEFECTION_FOR_COOPERATION_AMIDST_HEALTHY_STOCK_RATIO = 1 / 3.0
        self.learning_rate_coop = 0.05
        self.learning_rate_defect = 0.02
        self.player_cooperation_scores = np.ones(self.game_description.n_players)

    def _update_cooperation_scores(self, history: PlayerHistory):
        """Updates cooperation scores based on the previous round's actions."""
        if history.round_number == 0:
            return
        last_round_opponent_actions = history.opponent_actions[-1, :]
        my_last_action = Action.C if history.my_actions[-1] else Action.D
        if my_last_action == Action.C:
            self.player_cooperation_scores[0] = self.player_cooperation_scores[0] * (1 + self.learning_rate_coop)
        else:
            self.player_cooperation_scores[0] = self.player_cooperation_scores[0] * (1 - self.learning_rate_defect)
        for i in range(1, self.game_description.n_players):
            opponent_action = Action.C if last_round_opponent_actions[i - 1] else Action.D
            if opponent_action == Action.C:
                self.player_cooperation_scores[i] = self.player_cooperation_scores[i] * (1 + self.learning_rate_coop)
            else:
                self.player_cooperation_scores[i] = self.player_cooperation_scores[i] * (1 - self.learning_rate_defect)
        self.player_cooperation_scores = np.clip(self.player_cooperation_scores, 0.0, 1.0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if history is None:
            self.player_cooperation_scores = np.ones(n)
            return Action.C
        if state.round_number == r:
            return Action.D
        self._update_cooperation_scores(history)
        last_round_opponent_actions = history.opponent_actions[-1, :]
        num_opponents_defected_last_round = np.sum(~last_round_opponent_actions)
        opponent_scores_excluding_self = np.delete(self.player_cooperation_scores, 0)
        avg_opponent_cooperation_score = np.mean(opponent_scores_excluding_self)
        critical_stock_threshold = capacity * self.CRITICAL_STOCK_LOW_RATIO
        healthy_stock_threshold = capacity * self.HEALTHY_STOCK_HIGH_RATIO
        max_defectors_for_cooperation = math.floor(n * self.MAX_DEFECTION_FOR_COOPERATION_AMIDST_HEALTHY_STOCK_RATIO)
        if current_stock < critical_stock_threshold:
            return Action.D
        if current_stock > healthy_stock_threshold:
            if avg_opponent_cooperation_score >= self.MIN_COOPERATION_SCORE_FOR_FULL_COOPERATION:
                return Action.C
            elif num_opponents_defected_last_round <= max_defectors_for_cooperation:
                return Action.C
            else:
                return Action.D
        if avg_opponent_cooperation_score >= self.MIN_COOPERATION_SCORE_FOR_FULL_COOPERATION:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_25(BaseStrategy):
    """
    "Sustainable Harvester" Strategy: A cooperative approach to the Common Pool Resource Game.

    This strategy prioritizes the long-term health and productivity of the common pool resource.
    It defaults to cooperation to ensure resource sustainability, only considering defection
    in the final round or under extreme, unrecoverable depletion scenarios where sustained
    cooperation is futile and actively harmful.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with the game's parameters.
        """
        self.game_description = game_description
        self.threshold_abundant = self.game_description.capacity * 0.75
        self.threshold_sufficient = self.game_description.capacity * 0.5
        self.threshold_concern = self.game_description.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game including round number and stock.
            history: Historical data of actions and payoffs if available (None for the first round).

        Returns:
            Action: The action to take (Action.C or Action.D).
        """
        if history is None:
            return Action.C
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.game_description.n_rounds - 1:
            return Action.D
        if current_stock <= 0:
            return Action.C
        if current_stock > self.threshold_abundant:
            return Action.C
        elif current_stock > self.threshold_sufficient:
            return Action.C
        elif current_stock > self.threshold_concern:
            return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_26(BaseStrategy):
    """
    The "Sustainable Stock Guardian" strategy aims to maximize long-term collective
    payoff by prioritizing the sustainability of the common pool resource.
    It maintains a "Safe Stock" threshold, cooperating when the stock is abundant
    and defecting defensively when it becomes scarce to extract maximum value
    before potential collapse. It also handles edge cases for the first and last rounds,
    and critically low stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.safe_stock_threshold = game_description.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == r:
            return Action.D
        if current_stock <= 1e-06:
            return Action.C
        if current_stock >= self.safe_stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_27(BaseStrategy):
    """
    Cooperative Strategy: "Sustainable Bounty"

    This strategy aims to maximize collective and individual long-term payoff by
    focusing on the sustainability of the common pool resource. It is designed to
    be cooperative, adaptive, and robust to varying player behaviors. The core idea
    is to maintain the stock at a level that allows for significant growth while
    also providing a reasonable individual payoff.

    Decision Rules:
    1. COOPERATE (C) if current_stock > 0.75 * capacity (Stock is abundant)
    2. COOPERATE (C) if current_stock <= 0.25 * capacity (Emergency stock rebuild)
    3. DEFECT (D) otherwise (0.25 * capacity < current_stock <= 0.75 * capacity)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.safe_stock_level = 0.75 * self.capacity
        self.critical_stock_level = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        if history is None:
            return Action.C
        if current_stock > self.safe_stock_level:
            return Action.C
        elif current_stock <= self.critical_stock_level:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_28(BaseStrategy):
    """
    The Adaptive Sustainer strategy aims to maximize long-term sustainable payoff
    by cooperating under favorable conditions and becoming more cautious or
    deterring exploitation when the common pool resource is threatened.
    It adapts based on the current stock level and recent stock dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.SAFE_STOCK_THRESHOLD_RATIO = 0.8
        self.MODERATE_STOCK_LOWER_RATIO = 0.4
        self.SEVERE_STOCK_DECLINE_THRESHOLD_RATIO = 0.05
        self.DEFECT_SIGNAL_ROUNDS = 2
        self.stock_change_history = []
        self.last_stock = self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 1:
            self.last_stock = current_stock
            return Action.C
        if round_number == self.game_description.n_rounds:
            return Action.D
        if current_stock <= 0:
            return Action.C
        stock_change = current_stock - self.last_stock
        self.stock_change_history.append(stock_change)
        if len(self.stock_change_history) > self.DEFECT_SIGNAL_ROUNDS:
            self.stock_change_history.pop(0)
        self.last_stock = current_stock
        safe_stock_threshold = self.SAFE_STOCK_THRESHOLD_RATIO * capacity
        moderate_stock_lower_threshold = self.MODERATE_STOCK_LOWER_RATIO * capacity
        severe_stock_decline_threshold = self.SEVERE_STOCK_DECLINE_THRESHOLD_RATIO * capacity
        if current_stock >= safe_stock_threshold:
            if stock_change >= 0:
                return Action.C
            else:
                if len(self.stock_change_history) >= self.DEFECT_SIGNAL_ROUNDS:
                    all_declines_significant = True
                    for change in self.stock_change_history:
                        if change >= 0:
                            all_declines_significant = False
                            break
                    if all_declines_significant:
                        return Action.D
                return Action.C
        elif current_stock >= moderate_stock_lower_threshold:
            if stock_change >= 0:
                return Action.C
            elif abs(stock_change) < severe_stock_decline_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_29(BaseStrategy):
    """
    Sustainable Harvest with Contingent Reciprocity (SHCR) Strategy.

    This strategy aims to achieve long-term collective well-being by
    prioritizing resource preservation. It defaults to cooperating, but
    will defect (punish) if it detects over-exploitation of the common
    resource. It attempts to return to cooperation once the resource
    recovers and sustainable harvest is evident.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.is_retaliating = False
        self.retaliation_recovery_threshold = 0.7 * self.capacity
        self.overexploitation_alpha = 0.45
        self.stock_at_start_of_last_round = float(self.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if self.is_retaliating:
            if current_stock >= self.retaliation_recovery_threshold:
                self.is_retaliating = False
                self.stock_at_start_of_last_round = current_stock
                return Action.C
            else:
                self.stock_at_start_of_last_round = current_stock
                return Action.D
        self.stock_at_start_of_last_round = current_stock
        if history is None:
            return Action.C
        return Action.C

class Strategy_COOPERATIVE_30(BaseStrategy):
    """
    Cooperative and Adaptive Strategy for Common Pool Resource Game.

    This strategy defaults to cooperation (C) to ensure long-term sustainability
    of the common resource. It adapts by switching to defection (D) under specific
    conditions:
    1. In the final round, to maximize immediate payoff.
    2. If the resource stock falls critically low, and there's evidence of
       exploitation (high past consumption leading to current low stock).
    3. If the resource stock becomes extremely low, as a fail-safe.

    It prioritizes long-term collective payoff by avoiding resource collapse,
    while retaining the ability to defect defensively or for final extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_fraction = 0.3
        self.very_low_stock_threshold_factor = 1.0
        self.exploitation_consumption_ratio_threshold = 0.5
        self.defection_cooldown_rounds = 2
        self.last_action_taken = Action.C
        self.recent_defection_rounds_left = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_number = state.round_number
        critical_stock_threshold = capacity * self.critical_stock_fraction
        very_low_stock_threshold = n * self.very_low_stock_threshold_factor
        if current_round_number == r:
            return Action.D
        if current_stock < very_low_stock_threshold:
            self.last_action_taken = Action.D
            self.recent_defection_rounds_left = 0
            return Action.D
        if self.recent_defection_rounds_left > 0:
            self.recent_defection_rounds_left -= 1
            self.last_action_taken = Action.C
            return Action.C
        if current_stock > critical_stock_threshold:
            self.last_action_taken = Action.C
            return Action.C
        if history is None or history.round_number == 0:
            self.last_action_taken = Action.C
            return Action.C
        prev_round_idx = history.round_number - 1
        prev_stock = history.my_payoffs[prev_round_idx] + np.sum(history.opponent_payoffs[prev_round_idx, :])
        if hasattr(self, 'stock_at_prev_round_start') and self.stock_at_prev_round_start is not None:
            stock_t_minus_1 = self.stock_at_prev_round_start
            total_consumption_t_minus_1 = 0.0
            my_action_t_minus_1 = Action.C if history.my_actions[prev_round_idx] else Action.D
            consumption_per_player_t_minus_1 = stock_t_minus_1 / (2 * n) if my_action_t_minus_1 == Action.C else stock_t_minus_1 / n
            total_consumption_t_minus_1 += consumption_per_player_t_minus_1
            for opp_idx in range(n - 1):
                opp_action_t_minus_1 = Action.C if history.opponent_actions[prev_round_idx, opp_idx] else Action.D
                consumption_per_player_t_minus_1 = stock_t_minus_1 / (2 * n) if opp_action_t_minus_1 == Action.C else stock_t_minus_1 / n
                total_consumption_t_minus_1 += consumption_per_player_t_minus_1
            if stock_t_minus_1 > 0 and total_consumption_t_minus_1 / stock_t_minus_1 > self.exploitation_consumption_ratio_threshold:
                self.last_action_taken = Action.D
                self.recent_defection_rounds_left = self.defection_cooldown_rounds
                return Action.D
            else:
                self.last_action_taken = Action.C
                return Action.C
        else:
            self.last_action_taken = Action.C
            return Action.C
        self.last_action_taken = Action.C
        return Action.C

    def update_state_for_next_round(self, current_stock: float):
        self.stock_at_prev_round_start = current_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock_for_state_update = state.current_stock
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_number = state.round_number
        critical_stock_threshold = capacity * self.critical_stock_fraction
        very_low_stock_threshold = n * self.very_low_stock_threshold_factor
        if current_round_number == r:
            action_to_take = Action.D
        elif current_stock < very_low_stock_threshold:
            action_to_take = Action.D
            self.recent_defection_rounds_left = 0
        elif self.recent_defection_rounds_left > 0:
            self.recent_defection_rounds_left -= 1
            action_to_take = Action.C
        elif current_stock > critical_stock_threshold:
            action_to_take = Action.C
        elif history is None or history.round_number == 0:
            action_to_take = Action.C
        else:
            prev_round_idx = history.round_number - 1
            stock_t_minus_1 = getattr(self, 'stock_at_prev_round_start', None)
            if stock_t_minus_1 is not None and stock_t_minus_1 > 0:
                total_consumption_t_minus_1 = 0.0
                my_action_t_minus_1_bool = history.my_actions[prev_round_idx]
                my_action_t_minus_1 = Action.C if my_action_t_minus_1_bool else Action.D
                consumption_per_player_t_minus_1 = stock_t_minus_1 / (2 * n) if my_action_t_minus_1 == Action.C else stock_t_minus_1 / n
                total_consumption_t_minus_1 += consumption_per_player_t_minus_1
                for opp_idx in range(n - 1):
                    opp_action_t_minus_1_bool = history.opponent_actions[prev_round_idx, opp_idx]
                    opp_action_t_minus_1 = Action.C if opp_action_t_minus_1_bool else Action.D
                    consumption_per_player_t_minus_1 = stock_t_minus_1 / (2 * n) if opp_action_t_minus_1 == Action.C else stock_t_minus_1 / n
                    total_consumption_t_minus_1 += consumption_per_player_t_minus_1
                if total_consumption_t_minus_1 / stock_t_minus_1 > self.exploitation_consumption_ratio_threshold:
                    action_to_take = Action.D
                    self.recent_defection_rounds_left = self.defection_cooldown_rounds
                else:
                    action_to_take = Action.C
            else:
                action_to_take = Action.C
        self.last_action_taken = action_to_take
        self.stock_at_prev_round_start = current_stock_for_state_update
        return action_to_take

class Strategy_COOPERATIVE_31(BaseStrategy):
    """
    The "Sustainable Steward" strategy.
    This strategy prioritizes the long-term health of the common pool.
    It defaults to cooperation but will defect if previous rounds indicate
    a tendency towards over-exploitation. It also defects in the last round
    to maximize immediate gain and cooperates when the stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.default_action = Action.C
        self.retaliation_action = Action.D

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return self.retaliation_action
        if current_stock < self.n:
            return Action.C
        if history is not None and history.round_number > 0:
            previous_round_idx = history.round_number - 1
            previous_round_idx = history.round_number - 1
            num_defectors_previous_round = 0
            if not history.my_actions[previous_round_idx]:
                num_defectors_previous_round += 1
            num_opponent_defections = np.sum(~history.opponent_actions[previous_round_idx, :])
            num_defectors_previous_round += num_opponent_defections
            if num_defectors_previous_round > self.n / 2:
                return self.retaliation_action
        return self.default_action

class Strategy_COOPERATIVE_32(BaseStrategy):
    """
    The "Sustainable Yield Tracker" strategy for the Common Pool Resource Game.

    This strategy aims to maximize long-term cumulative payoff by maintaining
    the stock at a level that supports a healthy growth rate, while being
    prepared to exploit immediate gains or protect the stock if depleted.
    It is cooperative at its core but resilient to defection.

    Core Principle:
    Seek to keep the stock level near a calculated "target_stock" that
    maximizes sustainable total consumption.

    Decision Rules:
    - If it's the last round, Defect (D) to maximize immediate payoff.
    - If the stock is critically low, Cooperate (C) to prevent collapse.
    - If the stock is above the target_stock, Cooperate (C) for sustainability.
    - If the stock is at or below the target_stock (but not critically low),
      Defect (D) to secure immediate gains.

    Target Stock Calculation:
    A heuristic target_stock of `capacity * 0.75` is used. This aims to balance
    extraction with regeneration.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy.

        Args:
            game_description: An object containing game parameters
                              (n_players, n_rounds, capacity).
        """
        self.game_description = game_description
        self.target_stock = self.game_description.capacity * 0.75
        self.critical_stock_threshold = self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        """
        Determines the action for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs if it's not the first round,
                     otherwise None.

        Returns:
            Action: The action (Action.C or Action.D) for the current round.
        """
        current_stock = state.current_stock
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        if current_round == n_rounds:
            return Action.D
        if current_stock < self.critical_stock_threshold:
            return Action.C
        if current_stock > self.target_stock:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_33(BaseStrategy):
    """
    The "Sustainable Guardian" strategy embodies a principle of cooperative
    behavior with a focus on long-term stock health. It prioritizes stock
    preservation by defaulting to cooperation but will defect if the stock
    level falls critically low and other players have a history of defection.
    It aims to maximize the total sum of payoffs over all rounds by creating
    a stable and growing common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.total_defection_count_prev_round = 0
        self.cooperation_reserve_threshold = self.capacity * 0.75
        self.base_critical_stock_level_multiplier = 0.5
        self.defection_penalty_multiplier = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if history is None:
            self.total_defection_count_prev_round = 0
            return Action.C
        prev_round_stock = self.capacity
        if round_number > 1:
            pass
        num_opponent_defections_prev_round = 0
        if round_number > 0:
            last_completed_round_idx = history.round_number - 1
            if last_completed_round_idx < len(history.opponent_actions):
                num_opponent_defections_prev_round = sum((1 for action in history.opponent_actions[last_completed_round_idx] if not action))
        total_defection_count_this_round = self.total_defection_count_prev_round + num_opponent_defections_prev_round
        total_defection_count_this_round = min(total_defection_count_this_round, self.n * self.r)
        depletion_penalty_factor = total_defection_count_this_round / (self.n * self.r) * self.defection_penalty_multiplier
        if round_number == self.r:
            return Action.D
        if current_stock > self.cooperation_reserve_threshold:
            self.total_defection_count_prev_round = total_defection_count_this_round
            return Action.C
        if current_stock <= self.cooperation_reserve_threshold and total_defection_count_this_round == 0:
            self.total_defection_count_prev_round = total_defection_count_this_round
            return Action.C
        if current_stock <= self.cooperation_reserve_threshold and total_defection_count_this_round > 0:
            critical_stock_level = self.capacity * (self.base_critical_stock_level_multiplier - depletion_penalty_factor)
            critical_stock_level = max(critical_stock_level, 0.0)
            if current_stock > critical_stock_level:
                self.total_defection_count_prev_round = total_defection_count_this_round
                return Action.C
            else:
                self.total_defection_count_prev_round = total_defection_count_this_round
                return Action.D
        self.total_defection_count_prev_round = total_defection_count_this_round
        return Action.C

class Strategy_COOPERATIVE_34(BaseStrategy):
    """
    The Sustainable Steward strategy is a cooperative, adaptive, and robust
    approach to the Common Pool Resource Game. It prioritizes the long-term
    health of the resource by cooperating by default, but with a clear mechanism
    to punish defection when observed and incentivize a return to cooperation.
    It uses stock levels and observed defection patterns to make decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.cooperation_threshold_high = 0.7 * self.capacity
        self.punishment_stock_threshold_low = 0.2 * self.capacity
        self.punishment_initiation_threshold = self.n_players / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        if history is None:
            return Action.C
        last_round_idx = history.round_number - 1
        num_cooperators_last_round = np.sum(history.opponent_actions[last_round_idx, :])
        num_defectors_last_round = self.n_players - num_cooperators_last_round
        if current_stock > self.cooperation_threshold_high:
            return Action.C
        if current_stock <= self.cooperation_threshold_high and num_defectors_last_round > self.punishment_initiation_threshold:
            if current_stock > self.punishment_stock_threshold_low:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_COOPERATIVE_35(BaseStrategy):
    """
    Adaptive Sustainable Yield Maximizer (ASYM) strategy for the Common Pool Resource Game.

    This strategy aims to maximize the total sustainable yield from the common pool
    resource over the long run by keeping the stock at a level that allows for significant
    regrowth, while still extracting a fair share.

    Decision Rule:
    - If current stock (S) > capacity / 2: Play Defect (D)
    - If current stock (S) <= capacity / 2: Play Cooperate (C)
    - Exception: In the last round, always play Defect (D) to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the ASYM strategy.

        Args:
            game_description: An object containing game parameters (n_players, n_rounds, capacity).
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.target_stock = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action for the current round.

        Args:
            state: An object containing the current round number and stock level.
            history: An object containing past actions and payoffs for all players.
                     If None, it's the first round of the game.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_stock = float(state.current_stock)
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if current_stock > self.target_stock:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_36(BaseStrategy):
    """
    Adaptive Sustainer Strategy:
    This strategy aims to maintain the resource stock at a sustainable level by
    prioritizing cooperation, retaliating against defection, and forgiving
    when cooperation is re-established. It adjusts its behavior based on
    current stock levels and recent player actions.

    Core Principles:
    1. Prioritize Stock Sustainability: Avoid actions leading to rapid depletion.
    2. Conditional Cooperation: Cooperate as long as others cooperate. Retaliate against defection.
    3. Forgiveness: Revert to cooperation if defectors return to cooperation.
    4. Resource Level Sensitivity: Consume less when the stock is low.

    Decision Logic:
    - Default to Cooperate unless:
        - It's the last round (always Defect).
        - Stock is critically low (Cooperate to conserve).
        - Retaliation mode is active (Defect).
    - Retaliation Mode is triggered if any other player defected in the previous round.
    - Retaliation Mode is exited if the player was in Retaliation Mode and all other players
      cooperated in the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punish_mode = False
        self.low_stock_threshold = self.capacity * 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if history is None:
            self.punish_mode = False
            return Action.C
        if round_number > 1:
            previous_round_idx = round_number - 2
            other_players_defected_last_round = False
            if previous_round_idx < len(history.my_actions):
                for player_idx in range(self.n - 1):
                    if not history.opponent_actions[previous_round_idx, player_idx]:
                        other_players_defected_last_round = True
                        break
            if other_players_defected_last_round:
                self.punish_mode = True
            elif self.punish_mode:
                all_others_cooperated = True
                if previous_round_idx < len(history.my_actions):
                    for player_idx in range(self.n - 1):
                        if not history.opponent_actions[previous_round_idx, player_idx]:
                            all_others_cooperated = False
                            break
                if all_others_cooperated:
                    self.punish_mode = False
        if round_number == self.r:
            return Action.D
        if current_stock <= 0:
            return Action.C
        if self.punish_mode:
            return Action.D
        elif current_stock < self.low_stock_threshold:
            return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_37(BaseStrategy):
    """
    The "Sustainable Harvestor" strategy aims to maximize long-term collective payoff
    by fostering cooperation while retaining the ability to retaliate against defection.
    It's an adaptive strategy that learns from the history of the game and adjusts
    its behavior accordingly.

    Core Decision Logic:
    - Defaults to Cooperate (C).
    - Initiates a "Punishment Phase" (switches to Defect) if total observed
      consumption in the previous round significantly exceeded a cooperative level.
    - Returns to cooperation ("Forgiveness Phase") if, while in punishment mode,
      the total observed consumption in the previous round dropped back to a
      cooperative level.
    - Defect (D) in the last round, regardless of state, to maximize individual gain.
    - Cooperate (C) if stock is critically low, to prevent collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.alpha = 0.6
        self.beta = 0.4
        self.low_stock_threshold_factor = 0.5
        self.punishment_mode = False
        self.stock_at_start_of_round = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if history is None:
            self.punishment_mode = False
            self.stock_at_start_of_round = current_stock
            return Action.C
        last_round_idx = history.round_number - 1
        observed_total_consumption_last_round = 0
        if last_round_idx >= 0:
            stock_at_start_of_prev_round_for_calc = self.stock_at_start_of_round
            my_last_action_is_C = history.my_actions[last_round_idx]
            if my_last_action_is_C:
                observed_total_consumption_last_round += stock_at_start_of_prev_round_for_calc / (2 * self.n)
            else:
                observed_total_consumption_last_round += stock_at_start_of_prev_round_for_calc / self.n
            for i in range(self.n - 1):
                opponent_last_action_is_C = history.opponent_actions[last_round_idx, i]
                if opponent_last_action_is_C:
                    observed_total_consumption_last_round += stock_at_start_of_prev_round_for_calc / (2 * self.n)
                else:
                    observed_total_consumption_last_round += stock_at_start_of_prev_round_for_calc / self.n
        if current_round == self.r:
            self.stock_at_start_of_round = current_stock
            return Action.D
        if current_stock < self.low_stock_threshold_factor * self.n:
            self.punishment_mode = False
            self.stock_at_start_of_round = current_stock
            return Action.C
        if self.punishment_mode:
            if observed_total_consumption_last_round <= self.beta * self.stock_at_start_of_round:
                self.punishment_mode = False
                decision = Action.C
            else:
                decision = Action.D
        elif observed_total_consumption_last_round > self.alpha * self.stock_at_start_of_round:
            self.punishment_mode = True
            decision = Action.D
        else:
            decision = Action.C
        self.stock_at_start_of_round = current_stock
        return decision

class Strategy_COOPERATIVE_38(BaseStrategy):
    """
    The "Sustainable Stock" Cooperative Strategy aims to maximize long-term
    collective payoff by maintaining a healthy resource stock. It prioritizes
    cooperation when the stock is abundant and adapts its behavior based on
    the current stock level and the observed defection rate of opponents in
    the previous round. It defects only in the final round or as a last resort
    when the stock is critically low and others are defecting heavily.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.cooperation_threshold_ratio = 0.75
        self.depletion_threshold_ratio = 0.25
        self.cooperation_threshold = self.capacity * self.cooperation_threshold_ratio
        self.depletion_threshold = self.capacity * self.depletion_threshold_ratio

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if history is None:
            return Action.C
        if current_round == self.n_rounds:
            return Action.D
        last_round_actions = history.opponent_actions[current_round - 1, :]
        num_defectors = np.sum(~last_round_actions)
        dr_prev = num_defectors / self.n_players
        if current_stock >= self.cooperation_threshold:
            if dr_prev <= 0.4:
                return Action.C
            else:
                return Action.C
        elif current_stock > self.depletion_threshold:
            if dr_prev <= 0.2:
                return Action.C
            else:
                return Action.D
        elif dr_prev >= 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_39(BaseStrategy):
    """
    Cooperative Strategy for the Common Pool Resource Game.

    This strategy prioritizes long-term sustainability of the common resource
    through cooperation, while employing punitive defection to deter overconsumption.
    It adapts its cooperation threshold based on stock levels and observed behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.initial_Tc_factor = 0.75
        self.initial_Td_factor = 0.3
        self.punishment_duration = 3
        self.depletion_trigger_threshold = 0.1
        self.punishment_cooldown_rounds = 5
        self.cooperation_threshold = self.capacity * self.initial_Tc_factor
        self.critical_threshold = self.capacity * self.initial_Td_factor
        self.punishment_active = False
        self.punishment_rounds_remaining = 0
        self.last_significant_depletion_round = -self.punishment_cooldown_rounds
        self.stock_trend = 0

    def _get_current_stock(self, state: CommonPoolState, history: PlayerHistory) -> float:
        """Helper to get current stock, handling the first round."""
        if history is None:
            return self.capacity
        return state.current_stock

    def _get_previous_stock(self, history: PlayerHistory) -> float:
        """Helper to get previous stock."""
        if history is None or history.round_number == 0:
            return self.capacity
        if history.round_number >= 2:
            pass
        return self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = self._get_current_stock(state, history)
        if state.round_number == self.n_rounds:
            return Action.D
        if current_stock <= self.critical_threshold:
            return Action.D
        if self.punishment_active:
            self.punishment_rounds_remaining -= 1
            if self.punishment_rounds_remaining <= 0:
                self.punishment_active = False
            return Action.D
        if history is not None and history.round_number >= 1:
            prev_round_idx = history.round_number - 1
            num_defectors_prev_round = np.sum(history.opponent_actions[prev_round_idx, :])
            stock_depleted_significantly = False
            if history.round_number >= 2:
                stock_t_minus_2 = self._get_stock_from_history_or_fallback(history, history.round_number - 2)
                stock_t_minus_1 = self._get_stock_from_history_or_fallback(history, history.round_number - 1)
                if stock_t_minus_1 is not None and stock_t_minus_2 is not None:
                    if stock_t_minus_1 > stock_t_minus_2:
                        self.stock_trend = 1
                    elif stock_t_minus_1 < stock_t_minus_2:
                        self.stock_trend = -1
                    else:
                        self.stock_trend = 0
                elif stock_t_minus_1 is not None:
                    if stock_t_minus_1 > current_stock:
                        self.stock_trend = -1
                    elif stock_t_minus_1 < current_stock:
                        self.stock_trend = 1
                    else:
                        self.stock_trend = 0
            if num_defectors_prev_round > self.n_players / 2:
                if current_stock < self.capacity * 0.5 and self.stock_trend == -1:
                    stock_depleted_significantly = True
            if stock_depleted_significantly:
                self.punishment_active = True
                self.punishment_rounds_remaining = self.punishment_duration
                self.last_significant_depletion_round = state.round_number
                return Action.D
        if current_stock > self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

    def _get_stock_from_history_or_fallback(self, history: PlayerHistory, round_idx: int) -> float | None:
        """
        Attempts to retrieve stock from a specific past round.
        This is a placeholder and might not work if history doesn't store stock.
        The provided `PlayerHistory` dataclass does *not* store stock levels.
        Thus, this method will likely return None or a fallback.
        
        Given the constraints, this is not implementable without modifying `PlayerHistory`.
        We will return `None` and adjust logic accordingly.
        """
        return None

class Strategy_COOPERATIVE_40(BaseStrategy):
    """
    The "Sustainable Harvester" strategy aims to maximize cooperative outcomes
    in the Common Pool Resource Game by prioritizing the long-term health of the
    resource. It defaults to cooperation, but adapts by defecting if others have
    defected and the stock is robust enough to sustain it.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.high_stock_threshold = self.capacity * 0.75
        self.mid_stock_threshold_upper = self.capacity * 0.75
        self.mid_stock_threshold_lower = self.capacity * 0.25
        self.low_stock_threshold = self.capacity * 0.25
        self.recovery_stock_threshold = self.capacity * 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        if history is None:
            return Action.C
        someone_defected_last_round = False
        if history.round_number > 0:
            if not history.my_actions[history.round_number - 1]:
                someone_defected_last_round = True
            if not someone_defected_last_round and history.opponent_actions.shape[1] > 0:
                if np.any(~history.opponent_actions[history.round_number - 1, :]):
                    someone_defected_last_round = True
        if someone_defected_last_round:
            if current_stock > self.recovery_stock_threshold:
                return Action.D
            else:
                return Action.C
        if current_stock > self.high_stock_threshold:
            return Action.C
        elif self.mid_stock_threshold_lower <= current_stock <= self.mid_stock_threshold_upper:
            return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_41(BaseStrategy):
    """
    Cooperative Resource Guardian Strategy for the Common Pool Resource Game.

    This strategy aims to maximize the long-term cumulative payoff for all players
    by ensuring the resource remains healthy and sustainable. It operates on a
    principle of cautious cooperation, gradually increasing extraction as the
    stock allows, and sharply reducing extraction when the stock is depleted.
    It prioritizes avoiding scenarios where the resource collapses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like n_players,
                              n_rounds, and capacity.
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.T_high = 0.75 * self.capacity
        self.T_medium = 0.5 * self.capacity
        self.T_low = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: An object containing the current round number and stock level.
            history: An object containing past actions and payoffs. None for the first round.

        Returns:
            Action: The chosen action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if current_stock >= self.T_high:
            return Action.C
        elif self.T_medium <= current_stock < self.T_high:
            return Action.C
        elif self.T_low <= current_stock < self.T_medium:
            return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_42(BaseStrategy):
    """
    The "Adaptive Sustainability" strategy aims to maximize long-term collective
    well-being by managing the common pool resource adaptively. It leans towards
    cooperation but adjusts its actions based on the estimated group cooperation
    level and the resource stock level. It prioritizes cooperation when conditions
    are favorable and switches to more defensive or self-interested actions when
    the resource or group cooperation is threatened.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.r = game_description.n_rounds
        self.COOPERATION_THRESHOLD = 0.7
        self.STOCK_HEALTH_THRESHOLD_FRACTION = 0.5
        self.CRITICAL_STOCK_THRESHOLD_FRACTION = 0.1
        self.RECENT_ROUNDS_WINDOW = 3

    def _calculate_group_cooperation_score(self, history: PlayerHistory) -> float:
        """
        Calculates the estimated group cooperation score from recent rounds.
        A score of 1 means everyone cooperated, 0 means everyone defected.
        """
        if history is None or history.round_number == 0:
            return 1.0
        start_round = max(0, history.round_number - self.RECENT_ROUNDS_WINDOW)
        end_round = history.round_number
        total_cooperators = 0
        total_decisions = 0
        for round_idx in range(start_round, end_round):
            if self.my_actions[round_idx]:
                total_cooperators += 1
            total_decisions += 1
        if history.opponent_actions.shape[0] > 0:
            opponent_actions_recent = history.opponent_actions[start_round:end_round, :]
            total_cooperators += np.sum(opponent_actions_recent)
            total_decisions += opponent_actions_recent.size
        if total_decisions == 0:
            return 1.0
        return total_cooperators / total_decisions

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if history is None:
            return Action.C
        if not hasattr(self, 'my_actions'):
            self.my_actions = np.zeros(self.r, dtype=np.bool_)
        if current_round > 0 and len(history.my_actions) == current_round:
            self.my_actions[:current_round] = history.my_actions
        elif current_round == 0:
            pass
        if current_round == self.r - 1:
            return Action.D
        stock_health_threshold = self.capacity * self.STOCK_HEALTH_THRESHOLD_FRACTION
        critical_stock_threshold = self.capacity * self.CRITICAL_STOCK_THRESHOLD_FRACTION
        group_cooperation_score = self._calculate_group_cooperation_score(history)
        if current_stock < critical_stock_threshold:
            return Action.C
        elif current_stock < stock_health_threshold:
            if group_cooperation_score >= self.COOPERATION_THRESHOLD:
                return Action.C
            else:
                return Action.D
        elif group_cooperation_score >= self.COOPERATION_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_43(BaseStrategy):
    """
    Sustainable Cooperator strategy for the Common Pool Resource Game.

    This strategy prioritizes the long-term health of the common pool resource.
    It cooperates when the stock is sufficiently high (>= capacity/2) to ensure
    sustainable regeneration. It defects when the stock is dangerously low
    (< capacity/2) as a measure to maximize immediate gain in a stressed situation
    or to signal the urgency of the resource's state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_was_low_in_previous_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        stock_threshold = capacity / 2.0
        current_decision = Action.C
        if current_stock < stock_threshold:
            current_decision = Action.D
        else:
            current_decision = Action.C
        if history is not None and history.round_number > 0:
            self.stock_was_low_in_previous_round = current_stock < stock_threshold
        return current_decision

class Strategy_COOPERATIVE_44(BaseStrategy):
    """
    A cooperative strategy for the Common Pool Resource Game that aims to maximize
    long-term collective well-being by promoting resource sustainability. It is
    adaptive, rewarding cooperation and punishing defection, with a bias towards
    resource preservation.

    Key Features:
    - Defaults to cooperation.
    - Retaliates against sustained majority defection by others.
    - Defects to preserve immediate gains if the resource stock is critically low.
    - Has a mechanism to return to cooperation after a punishment phase, provided
      others demonstrate sustained cooperation.
    - Always defects in the last round to maximize final individual payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_threshold = 2
        self.critical_stock_threshold = self.capacity / 4
        self.return_to_cooperation_rounds = 2
        self.defection_streak = 0
        self.punishment_phase = False

    def _count_defecting_in_round(self, round_actions: NDArray[np.bool_]) -> int:
        """Counts the number of players who defected (False) in a given round's actions."""
        return self.n - np.sum(round_actions)

    def _all_cooperated_for_rounds(self, history: PlayerHistory, num_rounds: int) -> bool:
        """Checks if all players cooperated in the last 'num_rounds'."""
        if history.round_number < num_rounds:
            return False
        for i in range(1, num_rounds + 1):
            if self._count_defecting_in_round(history.opponent_actions[-i, :]) > 0 or history.my_actions[-i] is False:
                return False
        return True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if history is None:
            self.defection_streak = 0
            self.punishment_phase = False
            return Action.C
        previous_round_actions = history.opponent_actions[round_num - 1, :]
        my_previous_action = history.my_actions[round_num - 1]
        num_defecting_last_round = self._count_defecting_in_round(previous_round_actions)
        majority_defected_last_round = num_defecting_last_round > self.n / 2
        if majority_defected_last_round:
            self.defection_streak += 1
        else:
            self.defection_streak = 0
            if self.punishment_phase:
                if self._all_cooperated_for_rounds(history, self.return_to_cooperation_rounds):
                    self.punishment_phase = False
        if round_num == self.r:
            return Action.D
        if current_stock < self.critical_stock_threshold:
            self.punishment_phase = True
            return Action.D
        if self.defection_streak >= self.defection_threshold and (not self.punishment_phase):
            self.punishment_phase = True
            return Action.D
        if self.punishment_phase:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_45(BaseStrategy):
    """
    The "Adaptive Sustainable Harvester" strategy aims to foster long-term cooperation
    in the Common Pool Resource Game by balancing immediate gains with the long-term
    health of the common pool. It adapts its consumption based on the stock level
    and the behavior of other players.

    Decision Logic:
    - Cooperate by default, especially when stock is healthy.
    - Defect if the stock is critically low to maximize immediate take.
    - Defect as retaliation if other players defected in the previous round,
      but only if the stock is not critically low.
    - Cooperate in the first round to establish a cooperative norm.
    - Defect in the last round to maximize personal gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainable_threshold_ratio = 0.6
        self.warning_threshold_ratio = 0.3
        self.critical_low_threshold_ratio = 0.2
        self.sustainable_threshold = self.capacity * self.sustainable_threshold_ratio
        self.warning_threshold = self.capacity * self.warning_threshold_ratio
        self.critical_low_threshold = self.capacity * self.critical_low_threshold_ratio

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == self.r:
            return Action.D
        if current_stock <= 0:
            return Action.C
        if history is None:
            return Action.C
        recent_defection = False
        if history.round_number > 0:
            last_round_idx = history.round_number - 1
            if last_round_idx < len(history.opponent_actions):
                if np.any(history.opponent_actions[last_round_idx, :] == Action.D.value):
                    recent_defection = True
        if recent_defection and current_stock > self.critical_low_threshold:
            return Action.D
        if current_stock > self.sustainable_threshold:
            return Action.C
        elif current_stock > self.warning_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_46(BaseStrategy):
    """
    "Sustainable Harvest" strategy for the Common Pool Resource Game.
    This strategy prioritizes cooperation as the default action, aiming for
    long-term sustainability of the common pool. It incorporates a dynamic
    'danger threshold' which triggers defection only when the stock level
    drops to a point where sustained cooperation becomes precarious.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs for all players.
                     None for the first round.

        Returns:
            Action: Action.C for Cooperate, Action.D for Defect.
        """
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if history is None:
            return Action.C
        danger_threshold = capacity / 2.0 * ((2.0 * n - 1.0) / (2.0 * n))
        if current_stock <= 0:
            return Action.C
        if current_stock < danger_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_47(BaseStrategy):
    """
    The "Sustainable Stock Manager" strategy.

    This strategy prioritizes long-term stock sustainability by defaulting to
    cooperation. It defects only when the stock level approaches a critical
    threshold, when the game is in its final round, or if sustained high
    consumption by opponents indicates an unsustainable environment.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold_ratio = 0.4
        self.aggression_indicator_threshold = 0.6
        self.aggression_window = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round = state.round_number
        cooperation_threshold = self.cooperation_threshold_ratio * capacity
        if current_round == r:
            return Action.D
        if history is None:
            return Action.C
        min_cooperative_consumption_per_player = current_stock / (2 * n) if n > 0 else 0
        total_min_cooperative_consumption = n * min_cooperative_consumption_per_player
        if current_stock - total_min_cooperative_consumption < 0:
            return Action.D
        if current_stock <= cooperation_threshold:
            return Action.D
        recent_consumption_ratios = []
        if len(history.my_actions) >= self.aggression_window:
            for i in range(len(history.my_actions) - self.aggression_window, len(history.my_actions)):
                stock_before_round = self.game_description.capacity
                total_players_defected_in_round = np.sum(history.my_actions[i] == Action.D) + np.sum(history.opponent_actions[i, :] == Action.D)
                proportion_defected = total_players_defected_in_round / n
                if proportion_defected > self.aggression_indicator_threshold:
                    recent_consumption_ratios.append(1.0)
                else:
                    recent_consumption_ratios.append(0.0)
        if recent_consumption_ratios:
            average_aggression_score = np.mean(recent_consumption_ratios)
            if average_aggression_score > 0.5:
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_48(BaseStrategy):
    """
    The "Sustainable Shepherd" strategy.

    This strategy acts as a careful steward of the common resource. It prioritizes
    maintaining a healthy stock level, especially when it's crucial for long-term
    sustainability, but can leverage opportunistic defection when the resource is
    abundant and the risk of depletion is low.

    Decision Rules:
    - Cooperate (C) if stock is low (stock < capacity / 2) or in the final round.
    - Cooperate (C) if stock is at a moderate high level (capacity / 2 <= stock <= capacity * 0.75)
      and it's not the final round.
    - Defect (D) if stock is very high (stock > capacity * 0.75) and it's not the final round.

    The strategy defaults to cooperation, only defecting when the resource is demonstrably
    abundant and there's no immediate risk of depletion. It also cooperates in the final
    round to avoid being the sole cause of resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        low_stock_threshold = self.capacity / 2.0
        very_high_stock_threshold = self.capacity * 0.75
        epsilon = 1e-06
        if current_stock <= epsilon:
            return Action.C
        if current_round == self.r:
            return Action.C
        if current_stock < low_stock_threshold:
            return Action.C
        elif current_stock > very_high_stock_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_49(BaseStrategy):
    """
    The "Sustainable Accumulator" strategy aims to maximize long-term cooperative
    outcomes in the Common Pool Resource Game. It prioritizes sustainability by
    initially cooperating and then adapting based on observed behavior and stock
    levels. It generally favors cooperation but may defect strategically to
    punish exploitation or capitalize on high stock levels when trust is low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.trust_score = 1.0
        self.opponent_coop_rates = {}
        self.total_actions_taken = {}
        self.coop_counts = {}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round = state.round_number
        if history is None:
            self.trust_score = 1.0
            self.opponent_coop_rates = {}
            self.total_actions_taken = {i: 0 for i in range(n - 1)}
            self.coop_counts = {i: 0 for i in range(n - 1)}
            return Action.C
        if current_round > 0:
            if current_round > 1:
                new_trust_sum = 0.0
                num_opponents_with_history = 0
                for i in range(n - 1):
                    if self.total_actions_taken[i] > 0:
                        coop_rate_i = self.coop_counts[i] / self.total_actions_taken[i]
                        self.opponent_coop_rates[i] = coop_rate_i
                        new_trust_sum += coop_rate_i
                        num_opponents_with_history += 1
                if num_opponents_with_history > 0:
                    self.trust_score = new_trust_sum / num_opponents_with_history
                else:
                    self.trust_score = 1.0
            for i in range(n - 1):
                self.total_actions_taken[i] += 1
                if history.opponent_actions[-1, i] == Action.C.value:
                    self.coop_counts[i] += 1
        if current_stock <= 0:
            return Action.C
        if current_round == r:
            return Action.D
        if current_stock < capacity / 4 and self.trust_score > 0.75:
            return Action.C
        elif capacity / 4 <= current_stock < capacity / 2 and self.trust_score > 0.5:
            return Action.C
        elif current_stock >= capacity / 2 and self.trust_score > 0.75:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_50(BaseStrategy):
    """
    Cooperative Resource Management Strategy (CRMS) for the Common Pool Resource Game.
    This strategy prioritizes long-term sustainability and cooperation. It adapts
    its behavior based on the current stock level and the historical actions of
    other players.

    Decision Logic:
    - Cooperate (C) when stock is high (> 80% of capacity).
    - Defect (D) when stock is low (< 30% of capacity).
    - In medium stock levels, cooperate unless there's strong evidence of
      widespread defection in the previous round (actual consumption > 1.2 * expected coop consumption).
    - Always cooperate in the first round to establish a cooperative norm.
    - Always defect in the last round to maximize individual payoff.
    - If stock is zero, 'cooperate' (action is moot but chosen defensively).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_high = 0.8 * self.capacity
        self.threshold_low = 0.3 * self.capacity
        self.defection_trigger_multiplier = 1.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if history is None:
            return Action.C
        if current_round_number == self.n_rounds:
            return Action.D
        if current_stock <= 0:
            return Action.C
        if current_stock > self.threshold_high:
            return Action.C
        elif current_stock < self.threshold_low:
            return Action.D
        else:
            stock_previous_round = self.capacity if history.round_number == 0 else state.current_stock if current_round_number == 1 else history.my_payoffs[history.round_number - 1]
            stock_previous_round = self.capacity
            if history.round_number > 0:
                stock_previous_round = None
                if history.round_number > 0:
                    pass
                if stock_previous_round is None:
                    return Action.C
                coop_consumption_per_player = stock_previous_round / (2.0 * self.n_players)
                expected_coop_total_consumption = self.n_players * coop_consumption_per_player
                actual_consumption_previous_round = stock_previous_round - current_stock
                if expected_coop_total_consumption > 0 and actual_consumption_previous_round > self.defection_trigger_multiplier * expected_coop_total_consumption:
                    return Action.D
                else:
                    return Action.C

class Strategy_COOPERATIVE_51(BaseStrategy):
    """
    The "Sustainable Growth Guardian" strategy. This strategy aims to be cooperative
    by default, prioritizing long-term sustainability and growth of the common
    resource. It defects opportunistically when the stock is abundant or
    defends against potential collapse by extracting gains before depletion.
    It always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.healthy_buffer_threshold_ratio = 0.6
        self.depletion_danger_threshold_ratio = 0.3
        self.cooperation_sustain_threshold_ratio = 0.5
        self.healthy_buffer_threshold = self.capacity * self.healthy_buffer_threshold_ratio
        self.depletion_danger_threshold = self.capacity * self.depletion_danger_threshold_ratio
        self.cooperation_sustain_threshold = self.capacity * self.cooperation_sustain_threshold_ratio

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if current_stock < self.n / 2.0:
            return Action.C
        if current_stock > self.healthy_buffer_threshold:
            return Action.D
        elif current_stock > self.cooperation_sustain_threshold:
            return Action.C
        elif current_stock > self.depletion_danger_threshold:
            return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_52(BaseStrategy):
    """
    "Sustainable Harvester" Strategy for the Common Pool Resource Game.

    This strategy aims to maximize long-term collective payoff by prioritizing
    the sustainability of the common pool resource. It adapts its behavior
    based on the current stock level relative to a 'sustainable harvest threshold'.
    It cooperates when the stock is healthy and defects when it is depleted
    as a signal or mild deterrent. Special handling for the first and last rounds
    ensures optimal play in those specific contexts.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like
                              number of players, rounds, and capacity.
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainable_harvest_threshold = 0.5 * self.capacity
        self.epsilon = 1e-09

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of past actions and payoffs for all players.
                     None for the first round.

        Returns:
            Action.C for Cooperate, Action.D for Defect.
        """
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == self.r:
            return Action.D
        if history is None:
            return Action.C
        if current_stock < self.epsilon:
            return Action.C
        if current_stock >= self.sustainable_harvest_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_53(BaseStrategy):
    """
    Cooperative Strategy: "Sustainable Growth"

    This strategy aims to maximize long-term collective payoff by prioritizing the
    health of the common pool resource, while still ensuring a reasonable
    individual return. It's designed to be adaptive and resilient, learning
    from the evolving state of the game and the implicit behavior of other players.

    The core principle of "Sustainable Growth" is to cooperate (play C) as long
    as the stock level allows for sustainable resource regeneration, and defect
    (play D) only when absolutely necessary to secure a minimal individual
    payoff before the resource is depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with the game description.

        Args:
            game_description: An object containing game parameters like the number
                              of players, rounds, and resource capacity.
        """
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_growth_factor = 2.0
        self.stock_growth_denominator = self.capacity
        self.safe_consumption_multiplier = 1.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including the round number and
                   the current stock level.
            history: An object containing the history of actions and payoffs for
                     all players. None for the first round.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_round = state.round_number
        current_stock = state.current_stock
        if current_stock <= 0:
            return Action.C
        payoff_C_per_player = current_stock / (2.0 * self.n)
        payoff_D_per_player = current_stock / self.n
        if payoff_D_per_player <= payoff_C_per_player * self.safe_consumption_multiplier:
            return Action.C
        elif current_round < self.r - 1:
            return Action.C
        elif current_round == self.r - 1:
            if current_stock > self.capacity / 2.0:
                return Action.C
            else:
                return Action.D
        elif current_round == self.r:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_54(BaseStrategy):
    """
    Cooperative, Adaptive, and Robust Strategy (CARS) for the Common Pool Resource Game.

    This strategy prioritizes the long-term health of the common pool by defaulting
    to cooperation when the stock is healthy or recovering. It adapts to perceived
    over-exploitation by switching to defection when the stock level falls below
    a target and is declining, acting as a self-preservation mechanism and a signal
    to other players. It handles edge cases like the first and last rounds explicitly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the CARS strategy.

        Args:
            game_description: An object containing game parameters such as
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.target_stock_percentage = 0.65
        self.critical_stock_percentage = 0.25
        self.target_stock = self.capacity * self.target_stock_percentage
        self.critical_stock = self.capacity * self.critical_stock_percentage
        self.previous_stock = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game (round_number, current_stock).
            history: The history of actions and payoffs from previous rounds,
                     or None if it's the first round.

        Returns:
            Action.C to Cooperate or Action.D to Defect.
        """
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.n_rounds:
            return Action.D
        if history is None:
            self.previous_stock = current_stock
            return Action.C
        is_stock_increasing = current_stock >= self.previous_stock
        if current_stock >= self.target_stock:
            self.previous_stock = current_stock
            return Action.C
        elif current_stock < self.target_stock and is_stock_increasing:
            self.previous_stock = current_stock
            return Action.C
        elif current_stock < self.target_stock and (not is_stock_increasing):
            self.previous_stock = current_stock
            return Action.D
        elif current_stock < self.critical_stock:
            self.previous_stock = current_stock
            return Action.D
        else:
            self.previous_stock = current_stock
            return Action.C

class Strategy_COOPERATIVE_55(BaseStrategy):
    """
    "Sustainable Harvest with Gradual Tit-for-Tat" Strategy.

    This strategy prioritizes resource sustainability by cooperating initially and
    aiming to maintain the stock above a defined threshold. It employs a
    tit-for-tat mechanism with a punishment phase and a gradual return to
    cooperation to deter exploitation while allowing for resource recovery.
    It also adopts a purely self-interested stance in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainable_threshold = self.capacity / 2.0
        self.punishment_level = 0

    def _calculate_total_consumption_from_actions(self, actions: NDArray[np.bool_], stock: float) -> float:
        """Calculates total consumption for a given set of player actions and current stock."""
        total_consumption = 0
        for action_val in actions:
            if action_val == Action.C.value:
                total_consumption += stock / (2.0 * self.n)
            else:
                total_consumption += stock / self.n
        return total_consumption

    def _infer_observed_cooperation_level(self, current_stock: float, total_consumption_prev_round: float) -> str:
        """
        Infers the level of cooperation based on total consumption relative to stock.
        Returns 'high_cooperation', 'mixed', or 'high_defection'.
        """
        cooperative_consumption_ideal = current_stock / 2.0
        exploitative_consumption_ideal = current_stock
        cooperation_tolerance = 0.1
        defection_tolerance = 0.1
        if total_consumption_prev_round <= cooperative_consumption_ideal * (1.0 + cooperation_tolerance):
            return 'high_cooperation'
        elif total_consumption_prev_round >= exploitative_consumption_ideal * (1.0 - defection_tolerance):
            return 'high_defection'
        else:
            return 'mixed'

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if history is None:
            self.punishment_level = 0
            return Action.C
        prev_round_number = current_round - 1
        all_my_actions_prev_round = history.my_actions
        all_opponent_actions_prev_round = history.opponent_actions
        actions_prev_round = np.append(all_my_actions_prev_round[-1], all_opponent_actions_prev_round[-1, :])
        my_action_prev = history.my_actions[prev_round_number]
        opponent_actions_prev = history.opponent_actions[prev_round_number, :]
        actions_prev = np.append(my_action_prev, opponent_actions_prev)
        approx_stock_for_prev_consumption = current_stock
        total_consumption_prev_round = 0
        for action_val in actions_prev:
            if action_val == Action.C.value:
                total_consumption_prev_round += approx_stock_for_prev_consumption / (2.0 * self.n)
            else:
                total_consumption_prev_round += approx_stock_for_prev_consumption / self.n
        observed_cooperation_level = self._infer_observed_cooperation_level(approx_stock_for_prev_consumption, total_consumption_prev_round)
        if current_stock < self.sustainable_threshold:
            if observed_cooperation_level == 'high_defection' or observed_cooperation_level == 'mixed':
                self.punishment_level = 0
                return Action.D
            else:
                self.punishment_level = 0
                return Action.D
        elif observed_cooperation_level == 'high_defection':
            if self.punishment_level < 3:
                self.punishment_level += 1
                return Action.D
            else:
                self.punishment_level = 0
                return Action.C
        elif observed_cooperation_level == 'mixed':
            self.punishment_level = 0
            return Action.C
        else:
            self.punishment_level = 0
            return Action.C
        if current_stock < self.sustainable_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_56(BaseStrategy):
    """
    Cooperative Strategy for the Common Pool Resource Game.

    This strategy aims to maximize long-term collective payoff by prioritizing
    the sustainability of the common pool resource. It dynamically calculates
    a cooperation threshold based on the current stock level and decides to
    cooperate if the stock is above this threshold, and defect otherwise.
    It handles the last round by always defecting to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game-specific parameters like
                              number of players, rounds, and capacity.
        """
        self.game_description = game_description
        self.k = 5.0
        self.threshold_level = 0.6

    def _calculate_cooperation_threshold(self, current_stock: float) -> float:
        """
        Calculates the dynamic cooperation threshold.

        The threshold is calculated using a logistic-like function that
        depends on the current stock relative to capacity.

        Args:
            current_stock: The current stock level of the common pool.

        Returns:
            The calculated cooperation threshold.
        """
        if self.game_description.capacity == 0:
            return 0.0
        stock_ratio = current_stock / self.game_description.capacity
        ct = self.game_description.capacity / (1.0 + math.exp(self.k * (stock_ratio - self.threshold_level)))
        return ct

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: Historical data of actions and payoffs. None if it's the first round.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        cooperation_threshold = self._calculate_cooperation_threshold(current_stock)
        if current_stock >= cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_57(BaseStrategy):
    """
    Cooperative Strategy: "Sustainable Harvest with a Contingency"
    This strategy prioritizes long-term resource sustainability by cooperating
    when the stock is healthy and becoming more conservative (or cautiously
    defecting) when the stock is depleted. It always cooperates in the first
    round and defects in the last round to maximize individual payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = float(self.n_players)
        self.safe_threshold_factor = 0.6

    def _calculate_safe_threshold(self) -> float:
        """Calculates the safe stock level based on capacity and factor."""
        return self.capacity * self.safe_threshold_factor

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.n_rounds:
            return Action.D
        if history is None:
            return Action.C
        if current_stock <= self.critical_threshold:
            return Action.C
        safe_threshold = self._calculate_safe_threshold()
        if current_stock > safe_threshold:
            return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_58(BaseStrategy):
    """
    Cooperative strategy: "Sustainable Stockkeeper"
    This strategy prioritizes maintaining the common pool stock at a healthy level,
    ensuring long-term sustainability for all players. It balances the immediate
    temptation to defect for higher payoffs with the risk of depleting the resource.
    It punishes deviations from cooperation but forgives and returns to cooperation
    if the resource is managed responsibly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.
        """
        self.game_description = game_description
        self.critical_stock_threshold = game_description.capacity / 2.0
        self.punishment_active = False
        self.punishment_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) based on the current state and history.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs for all players. None for the first round.

        Returns:
            Action.C for Cooperate, Action.D for Defect.
        """
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == r:
            return Action.D
        if current_stock <= 0:
            return Action.C
        if current_stock >= self.game_description.capacity:
            return Action.C
        if self.punishment_active:
            self.punishment_rounds_remaining -= 1
            if self.punishment_rounds_remaining <= 0:
                self.punishment_active = False
            if self.punishment_active:
                return Action.D
        if history is not None:
            opponents_defected_last_round = False
            if current_round > 0:
                last_round_idx = current_round - 1
                if last_round_idx < len(history.opponent_actions):
                    num_opponents = n - 1
                    if num_opponents > 0:
                        cooperators_count = np.sum(history.opponent_actions[last_round_idx, :])
                        if cooperators_count < num_opponents:
                            opponents_defected_last_round = True
                    else:
                        opponents_defected_last_round = False
            if current_stock < self.critical_stock_threshold and opponents_defected_last_round:
                self.punishment_active = True
                self.punishment_rounds_remaining = 1
                return Action.D
        return Action.C

class Strategy_COOPERATIVE_59(BaseStrategy):
    """
    The "Steadfast Steward" strategy. This strategy prioritizes the long-term
    health and sustainability of the common pool above all else. It believes
    that sustained cooperation is the only way to ensure long-term abundance
    for everyone.

    Decision Rules:
    - In any round before the last (rounds 1 to r-1), always Cooperate (C).
    - In the last round (round r), always Defect (D).

    This strategy is inherently cooperative, signaling unwavering trust and a
    commitment to collective well-being over short-term individual gain in all
    rounds that have future implications for the resource. It is robust because
    it never contributes to the depletion of the resource in rounds that matter
    for future game states. It adapts to the game's unfolding state by
    contributing positively, even if other players do not reciprocate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action to take in the current round.

        Args:
            state: The current state of the common pool (round_number, current_stock).
            history: The history of actions and payoffs for all players, or None
                     if it's the first round.

        Returns:
            The action (Action.C or Action.D) to take.
        """
        if history is None:
            return Action.C
        elif state.round_number < self.game_description.n_rounds - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_60(BaseStrategy):
    """
    Cooperative Strategy: The "Sustainable Stock Guardian"

    This strategy aims to maximize collective long-term payoff by prioritizing
    the sustainability of the common pool resource. It maintains the stock
    level at or near capacity for as long as possible, enabling higher
    individual payoffs over many rounds.

    Decision Rules:
    - Cooperate (C): If current_stock >= capacity * 0.6
    - Defect (D): If current_stock < capacity * 0.6

    Edge Cases:
    - First Round: Cooperate (C)
    - Last Round: Defect (D)
    - Near-Zero Stock: Cooperate (C)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold_ratio = 0.6
        self.epsilon = 1e-06

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.n_rounds:
            return Action.D
        if current_stock < self.epsilon:
            return Action.C
        cooperation_threshold = self.capacity * self.cooperation_threshold_ratio
        if current_stock >= cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_61(BaseStrategy):
    """
    Adaptive Sustainable Cooperate (ASC) Strategy for the Common Pool Resource Game.

    This strategy aims for long-term sustainability by prioritizing resource health.
    It cooperates when the stock is abundant and switches to a more aggressive
    harvesting approach (defecting) only when the stock falls below a dynamically
    adjusted "target stock" level. The target stock level adapts to the general
    trend of the resource (increasing or decreasing) over recent rounds.
    It defaults to cooperation in the first round and defects in the last round
    to maximize individual payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.window_size = 3
        self.stock_history: list[float] = []
        self.target_stock: float = self.capacity * 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round_number and current_stock.
            history: History of actions and payoffs for all players. None for the first round.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_round_num = state.round_number
        current_stock = state.current_stock
        if current_round_num == self.r:
            return Action.D
        if history is not None:
            self.stock_history.append(current_stock)
            if len(self.stock_history) > self.window_size:
                self.stock_history.pop(0)
            if len(self.stock_history) >= self.window_size:
                average_stock_in_window = np.mean(self.stock_history)
                if average_stock_in_window < current_stock:
                    self.target_stock *= 1.01
                elif average_stock_in_window > current_stock:
                    self.target_stock *= 0.99
                self.target_stock = max(0.0, min(self.target_stock, self.capacity))
        if current_stock >= self.target_stock:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_62(BaseStrategy):
    """
    The "Sustainable Gardener" strategy for the Common Pool Resource Game.
    This strategy aims to maximize long-term collective well-being by
    managing the common resource sustainably. It defaults to cooperation
    but adapts its behavior based on the current stock level, the number
    of rounds remaining, and a critical sustainability threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.sustainability_threshold_factor = 0.4
        self.sustainability_threshold = self.game_description.capacity * self.sustainability_threshold_factor

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: An object containing past actions and payoffs. None for the first round.

        Returns:
            Action.C for Cooperate, Action.D for Defect.
        """
        current_stock = state.current_stock
        current_round = state.round_number
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        rounds_remaining = r - current_round
        if current_round == r:
            return Action.D
        if current_round == 1:
            return Action.C
        if current_stock <= 0:
            return Action.D
        if current_stock >= self.sustainability_threshold:
            return Action.C
        elif current_stock < self.sustainability_threshold and rounds_remaining > r / 2:
            return Action.C
        elif current_stock < self.sustainability_threshold and rounds_remaining <= r / 2:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_63(BaseStrategy):
    """
    Adaptive Cooperative Guardian (ACG) strategy.

    This strategy aims to foster long-term cooperation and maximize individual
    cumulative payoffs by balancing immediate gains from defection against the
    risk of depleting the common resource. It is robust and adaptive,
    responding to the state of the resource and the implied behavior of other
    players based on past consumption.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the ACG strategy.

        Args:
            game_description: An object containing game parameters.
        """
        self.game_description = game_description
        self.high_stock_threshold_ratio = 0.75
        self.low_stock_threshold_ratio = 0.3
        self.consumption_analysis_window = 3
        self.high_consumption_multiplier = 1.2
        self.very_low_consumption_multiplier = 0.8

    def _get_recent_average_consumption_per_player(self, history: PlayerHistory) -> float:
        """
        Calculates the average consumption per player over the last `k` rounds.

        Args:
            history: The history of the game.

        Returns:
            The average consumption per player, or 0 if no history is available.
        """
        n_players = self.game_description.n_players
        window = min(self.consumption_analysis_window, history.round_number)
        if window == 0:
            return 0.0
        total_recent_consumption = np.sum(history.opponent_actions[-window:, :])
        num_defect_rounds = np.sum(history.opponent_actions[-window:, :] == False, axis=1)
        average_defect_rounds = np.mean(num_defect_rounds)
        return average_defect_rounds / n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the common pool.
            history: The history of actions and payoffs up to the previous round.

        Returns:
            The chosen action: Action.C for Cooperate, Action.D for Defect.
        """
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_stock <= 0:
            return Action.C
        if current_round_number == r - 1:
            return Action.D
        high_stock_threshold = self.high_stock_threshold_ratio * capacity
        low_stock_threshold = self.low_stock_threshold_ratio * capacity
        cooperative_consumption_per_player = current_stock / (2.0 * n)
        defection_consumption_per_player = current_stock / n
        average_recent_defection_rate = 0.0
        if history is not None and history.round_number > 0:
            average_recent_defection_rate = self._get_recent_average_consumption_per_player(history)
        if current_stock > high_stock_threshold:
            return Action.C
        elif current_stock >= low_stock_threshold:
            if history is not None and history.round_number > 0:
                if average_recent_defection_rate > self.high_consumption_multiplier * (1.0 / n):
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        elif history is not None and history.round_number > 0:
            if average_recent_defection_rate < self.very_low_consumption_multiplier * (1.0 / n):
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_64(BaseStrategy):
    """
    Cooperative, Adaptive, and Robust Strategy for the Common Pool Resource Game.

    This strategy prioritizes long-term collective benefit through a strong bias
    towards cooperation. It maintains a target sustainable stock level and
    cooperates when the stock is above this level. When the stock is below,
    it continues to cooperate to allow for regeneration, unless there is
    clear, sustained evidence of persistent defection by other players.

    In response to strong evidence of persistent defection, the strategy
    will defect for a single round as a temporary punishment signal. It then
    immediately reverts to cooperation to prevent a death spiral and allow
    for resource recovery.

    The strategy is designed to be robust by:
    1. Defaulting to cooperation.
    2. Using temporary defection only as a last resort.
    3. Reverting to cooperation immediately after temporary defection.
    4. Cooperating even in the last round if the stock is healthy, prioritizing
       the best possible final resource state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.target_sustainable_stock_level = self.capacity / 2.0
        self.defection_punishment_rounds = 1
        self.defection_detection_window = 3
        self.defection_threshold_ratio = 1.2
        self.rounds_since_last_cooperative_decision = 0
        self.consecutive_punishment_rounds_played = 0
        self.is_punishing = False
        self.history_of_states = []

    def _infer_total_consumption(self, stock_before_round: float, stock_after_round: float) -> float:
        """
        Infers total consumption by accounting for stock growth.
        This is an approximation and assumes we can't directly see stock before growth.
        A more accurate inference would require knowing the stock *after* consumption but *before* growth.
        Since we only have stock_before_round and stock_after_round (after growth),
        we can only infer a *lower bound* on consumption.
        If stock_after_round < stock_before_round, then consumption must have been > 0.
        The actual consumption is stock_before_round - S_remaining, where S_new = min(S_remaining + growth, capacity).
        We can rearrange the growth formula if needed, but for detecting *high* consumption,
        a significant drop in stock is a strong indicator.

        A simpler, though less precise, heuristic for detecting sustained high consumption:
        If stock_after_round is significantly lower than stock_before_round, it implies high consumption.
        We will use the difference as a proxy, acknowledging it's an upper bound if growth was minimal.
        """
        estimated_consumption = stock_before_round - stock_after_round
        return max(0.0, estimated_consumption)

    def _check_for_persistent_defection(self, current_stock: float, history: PlayerHistory) -> bool:
        if history.round_number < self.defection_detection_window:
            return False
        inferred_consumptions = []
        for i in range(self.defection_detection_window):
            round_idx = history.round_number - 1 - i
            stock_before_round = self.capacity
            if round_idx > 0:
                if i < len(self.history_of_states):
                    stock_before_round = self.history_of_states[-1 - i][0]
                else:
                    continue
            else:
                stock_before_round = self.capacity
            stock_after_this_round_for_inference = history.my_payoffs[round_idx]
            if i < len(self.history_of_states):
                prev_stock_before, inferred_cons = self.history_of_states[-1 - i]
                inferred_consumptions.append(inferred_cons)
            else:
                return False
        if not inferred_consumptions:
            return False
        expected_cooperative_consumption_sum = 0
        for i in range(self.defection_detection_window):
            if i < len(self.history_of_states):
                stock_before = self.history_of_states[-1 - i][0]
                expected_cooperative_consumption_sum += stock_before / (2.0 * self.n) * self.n
            else:
                return False
        total_inferred_consumption_over_window = sum(inferred_consumptions)
        if expected_cooperative_consumption_sum > 0 and total_inferred_consumption_over_window > expected_cooperative_consumption_sum * self.defection_threshold_ratio:
            return True
        return False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if len(self.history_of_states) > self.defection_detection_window + 5:
            self.history_of_states.pop(0)
        if history is None or current_round == 0:
            self.rounds_since_last_cooperative_decision = 0
            self.consecutive_punishment_rounds_played = 0
            self.is_punishing = False
            self.history_of_states.append((current_stock, 0.0))
            return Action.C
        if history.round_number > 0:
            stock_before_prev_round = self.capacity
            if len(self.history_of_states) > 1:
                stock_before_prev_round = self.history_of_states[-2][0]
            stock_after_prev_round = current_stock
            inferred_consumption_prev_round = self._infer_total_consumption(stock_before_prev_round, stock_after_prev_round)
            self.history_of_states.append((current_stock, inferred_consumption_prev_round))
        if self.is_punishing:
            self.consecutive_punishment_rounds_played += 1
            if self.consecutive_punishment_rounds_played >= self.defection_punishment_rounds:
                self.is_punishing = False
                self.consecutive_punishment_rounds_played = 0
            return Action.D
        if current_round == self.r - 1:
            return Action.C
        evidence_of_persistent_defection = False
        if current_stock < self.target_sustainable_stock_level:
            evidence_of_persistent_defection = self._check_for_persistent_defection(current_stock, history)
        if current_stock >= self.target_sustainable_stock_level:
            self.rounds_since_last_cooperative_decision += 1
            return Action.C
        elif evidence_of_persistent_defection:
            self.is_punishing = True
            self.consecutive_punishment_rounds_played = 1
            self.rounds_since_last_cooperative_decision = 0
            return Action.D
        else:
            self.rounds_since_last_cooperative_decision += 1
            return Action.C

class Strategy_COOPERATIVE_65(BaseStrategy):
    """
    "Sustainable Stock Sentinel" strategy for the Common Pool Resource Game.

    This strategy aims to maximize long-term cumulative payoffs by prioritizing
    the sustainability of the common pool resource. It uses a stock-dependent
    threshold to decide between cooperating and defecting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters
                              (n_players, n_rounds, capacity).
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def _calculate_cooperation_threshold(self, current_round: int, current_stock: float) -> float:
        """
        Calculates the dynamic cooperation threshold.

        Args:
            current_round: The current round number (1-indexed).
            current_stock: The current stock level of the common pool.

        Returns:
            The calculated cooperation threshold.
        """
        threshold_from_rounds = self.capacity / self.n * (self.r - current_round) / self.r
        cooperation_threshold = max(self.capacity * 0.4, threshold_from_rounds)
        return cooperation_threshold

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs for all players.
                     None for the first round.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        current_round = state.round_number
        round_for_calc = current_round + 1
        cooperation_threshold = self._calculate_cooperation_threshold(round_for_calc, current_stock)
        if current_stock >= cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_66(BaseStrategy):
    """
    Cooperative Strategy: "Sustainable Stewardship"
    This strategy aims to maximize the long-term collective payoff by prioritizing the
    sustainable management of the common pool resource. It is designed to be robust
    and adaptive, encouraging cooperation while defending against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.risk_factor = 1.5
        self.history_window_size = 2

    def _calculate_cooperation_threshold(self, current_stock: float, remaining_rounds: int) -> float:
        """
        Calculates the minimum stock level considered safe for cooperation.
        CT = max(capacity/2, remaining_rounds * (capacity/(2n)) * risk_factor)
        """
        baseline_threshold = self.capacity / 2.0
        future_value_term = remaining_rounds * (self.capacity / (2.0 * self.n)) * self.risk_factor
        return max(baseline_threshold, future_value_term)

    def _assess_recent_behavior(self, state: CommonPoolState, history: PlayerHistory) -> bool:
        """
        Assesses if other players are aggressively depleting the resource.
        Returns True if aggressive depletion is detected, False otherwise.
        """
        if history.round_number < self.history_window_size:
            return False
        recent_rounds_indices = range(history.round_number - self.history_window_size, history.round_number)
        total_consumption_recent = 0.0
        for round_idx in recent_rounds_indices:
            my_action = Action.C if history.my_actions[round_idx] else Action.D
            my_consumption = state.current_stock / (2.0 * self.n) if my_action == Action.C else state.current_stock / self.n
            opponents_consumption = 0.0
            approx_stock_at_round_start = state.current_stock
            for player_idx in range(self.n - 1):
                opponent_action = Action.C if history.opponent_actions[round_idx, player_idx] else Action.D
                opponents_consumption += approx_stock_at_round_start / (2.0 * self.n) if opponent_action == Action.C else approx_stock_at_round_start / self.n
            total_consumption_recent += my_consumption + opponents_consumption
        average_consumption_per_player = total_consumption_recent / (self.history_window_size * self.n)
        potential_cooperative_consumption_per_player = state.current_stock / (2.0 * self.n)
        aggressive_consumption_trigger = 1.2 * potential_cooperative_consumption_per_player
        return average_consumption_per_player > aggressive_consumption_trigger

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) based on the current state and history.
        """
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.C
        remaining_rounds = self.r - current_round
        cooperation_threshold = self._calculate_cooperation_threshold(current_stock, remaining_rounds)
        is_aggressive_depletion = False
        if history is not None:
            is_aggressive_depletion = self._assess_recent_behavior(state, history)
            if is_aggressive_depletion:
                self.risk_factor = min(self.risk_factor + 0.1, 2.0)
            else:
                self.risk_factor = max(self.risk_factor - 0.05, 1.0)
        if current_stock >= cooperation_threshold and (not is_aggressive_depletion):
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_67(BaseStrategy):
    """
    Cooperative Strategy for the Common Pool Resource Game.

    This strategy aims to maximize long-term, collective payoff by maintaining
    a healthy stock level. It prioritizes cooperation when the stock is abundant
    and becomes more cautious as the stock depletes. In the last round, it
    switches to defecting to maximize individual gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy.

        Args:
            game_description: Information about the game parameters.
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.high_stock_threshold = 0.75 * self.capacity
        self.low_stock_threshold = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of past actions and payoffs.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        round_number = state.round_number
        remaining_rounds = self.n_rounds - round_number + 1
        if remaining_rounds == 1:
            return Action.D
        if current_stock <= 0:
            return Action.C
        if current_stock >= self.high_stock_threshold:
            return Action.C
        elif current_stock >= self.low_stock_threshold:
            return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_68(BaseStrategy):
    """
    The "Sustainable Grasp" strategy aims to maintain a healthy stock level
    that allows for sustained future payoffs, rather than short-term maximization.
    It operates on a principle of "take what you can sustainably use, but never
    deplete the source."

    Decision Rule:
    - Cooperate (C) if the current stock level (S) is above capacity / 2.
    - Defect (D) if the current stock level (S) is at or below capacity / 2.

    This strategy is designed to be cooperative by default, cooperating when the
    resource is abundant and only defecting when the resource is stressed or
    depleted, acting as a self-preservation mechanism.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with the game description.

        Args:
            game_description: An object containing game parameters like
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.sustainable_threshold = self.game_description.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        """
        Determines the action (Cooperate or Defect) based on the current state.

        Args:
            state: The current state of the game, including the round number and
                   the current stock level.
            history: The history of actions and payoffs for all players up to
                     the previous round. None if it's the first round.

        Returns:
            The action to take in the current round (Action.C or Action.D).
        """
        current_stock = state.current_stock
        if current_stock > self.sustainable_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_69(BaseStrategy):
    """
    The "Sustainable Harvester" strategy.

    This strategy prioritizes long-term resource sustainability for
    higher cumulative payoffs. It defaults to cooperation but will defect
    if the stock is critically low, if there's a trend of unsustainable
    consumption, or in the final round to maximize immediate gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = max(2 * self.n, self.capacity / 3.0)
        self.warning_threshold = self.capacity * 0.5
        self.high_consumption_level = self.capacity / self.n

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if history is None:
            return Action.C
        if current_round == self.r:
            return Action.D
        if current_stock <= self.critical_threshold:
            return Action.D
        total_consumption_history = self._get_total_consumption_history(history)
        stock_history_after_growth = self._get_stock_history_after_growth(history, self.capacity)
        last_round_total_consumption = 0
        if len(total_consumption_history) > 0:
            last_round_total_consumption = total_consumption_history[-1]
        stock_before_last_consumption = current_stock
        if current_round > 1:
            if last_round_total_consumption > current_stock * 0.75 and current_stock < self.warning_threshold:
                return Action.D
            if len(total_consumption_history) >= 2:
                recent_consumption_avg = np.mean(total_consumption_history[-2:])
                if last_round_total_consumption > self.high_consumption_level * 1.5 and current_stock < self.warning_threshold:
                    return Action.D
        return Action.C

    def _get_total_consumption_history(self, history: PlayerHistory) -> list[float]:
        """Helper to calculate and return total consumption for each past round."""
        n_players = self.n
        total_consumption = []
        return []

    def _get_stock_history_after_growth(self, history: PlayerHistory, capacity: float) -> list[float]:
        """
        Helper to reconstruct stock levels if not directly available in history.
        This is a complex inversion and potentially inaccurate without exact game logic.
        """
        return []

class Strategy_COOPERATIVE_70(BaseStrategy):
    """
    Adaptive Cooperation with Gradual Punishment and Forgiveness Strategy.

    This strategy aims to maintain the common pool resource through a default
    cooperative stance, with adaptive responses to perceived over-exploitation
    by opponents. It incorporates a punishment phase triggered by significant
    stock depletion and a forgiveness mechanism to re-establish cooperation
    after stock recovery and observed cooperative behavior from others.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.critical_stock_level_ratio = 0.25
        self.recovery_stock_level_ratio = 0.75
        self.cooperation_trigger_count_target = 3
        self.punishment_phase = False
        self.consecutive_majority_cooperation_count = 0
        self.last_round_stock_before_consumption = None
        self.last_round_total_consumption = None

    def _calculate_consumption_and_payoff(self, stock: float, action: Action) -> tuple[float, float]:
        """
        Calculates consumption and payoff for a single player given stock and action.

        Args:
            stock: The current stock level.
            action: The player's action (Action.C or Action.D).

        Returns:
            A tuple containing (consumption, payoff).
        """
        n = self.game_description.n_players
        if action == Action.C:
            consumption = stock / (2 * n)
            payoff = stock / (2 * n)
        else:
            consumption = stock / n
            payoff = stock / n
        return (consumption, payoff)

    def _calculate_stock_dynamics(self, stock_before_consumption: float, total_consumption: float) -> float:
        """
        Calculates the new stock level after consumption and growth.

        Args:
            stock_before_consumption: The stock level before any player consumes.
            total_consumption: The sum of consumption by all players.

        Returns:
            The new stock level after growth, capped at capacity.
        """
        stock_remaining = stock_before_consumption - total_consumption
        if stock_remaining < 0:
            stock_remaining = 0
        capacity = self.game_description.capacity
        growth = 2 * stock_remaining * (1 - stock_remaining / capacity)
        new_stock = stock_remaining + growth
        return min(new_stock, capacity)

    def _count_opponent_cooperators_last_round(self, history: PlayerHistory) -> int:
        """
        Counts the number of opponents who cooperated in the most recent round.

        Args:
            history: The PlayerHistory object.

        Returns:
            The number of opponents who played Action.C.
        """
        if history.round_number == 0:
            return 0
        return np.sum(history.opponent_actions[-1, :])

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action for the current round.

        Args:
            state: The current state of the game (round_number, current_stock).
            history: The history of actions and payoffs from previous rounds.
                     If None, it's the first round.

        Returns:
            The action to take (Action.C or Action.D).
        """
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        critical_stock_level = self.critical_stock_level_ratio * capacity
        recovery_stock_level = self.recovery_stock_level_ratio * capacity
        if history is None:
            self.punishment_phase = False
            self.consecutive_majority_cooperation_count = 0
            self.last_round_stock_before_consumption = capacity
            self.last_round_total_consumption = 0
            return Action.C
        stock_after_consumption_last_round = self.last_round_stock_before_consumption - self.last_round_total_consumption
        if stock_after_consumption_last_round < critical_stock_level:
            self.punishment_phase = True
        else:
            pass
        if self.punishment_phase:
            num_others_cooperated = self._count_opponent_cooperators_last_round(history)
            majority_threshold = math.ceil(n_players / 2.0)
            majority_cooperation_from_others = num_others_cooperated >= majority_threshold
            if majority_cooperation_from_others:
                self.consecutive_majority_cooperation_count += 1
            else:
                self.consecutive_majority_cooperation_count = 0
            if current_stock >= recovery_stock_level and self.consecutive_majority_cooperation_count >= self.cooperation_trigger_count_target:
                self.punishment_phase = False
                self.consecutive_majority_cooperation_count = 0
        if current_round == self.game_description.n_rounds - 1:
            if current_stock > 0:
                self.last_round_stock_before_consumption = current_stock
                self.last_round_total_consumption = self._calculate_consumption_and_payoff(current_stock, Action.C)[0]
                return Action.C
            else:
                self.last_round_stock_before_consumption = current_stock
                self.last_round_total_consumption = 0
                return Action.C
        if self.punishment_phase:
            action_to_take = Action.D
        else:
            action_to_take = Action.C
        my_consumption, my_payoff = self._calculate_consumption_and_payoff(current_stock, action_to_take)
        total_consumption_this_round = my_consumption
        if n_players > 1:
            opponent_actions_last_round = history.opponent_actions[-1]
            for opponent_action_bool in opponent_actions_last_round:
                opponent_action = Action.C if opponent_action_bool else Action.D
                total_consumption_this_round += self._calculate_consumption_and_payoff(current_stock, opponent_action)[0]
        self.last_round_stock_before_consumption = current_stock
        self.last_round_total_consumption = total_consumption_this_round
        return action_to_take

class Strategy_COOPERATIVE_71(BaseStrategy):
    """
    Cooperative Strategy: "Stock-Responsive Tit-for-Tat with Capacity Safeguard"

    This strategy aims to be inherently cooperative while adapting to the current
    state of the resource and the observed behavior of others. It prioritizes
    the long-term sustainability of the common pool.

    Core Principles:
    1. Proactive Cooperation: Default mode is cooperation.
    2. Responsive Retaliation (Mild): If others defect and deplete stock,
       it will defect mildly to signal displeasure, not for mutual destruction.
    3. Stock-Dependent Consumption: Consumption tied to stock level and growth needs.
    4. Capacity Safeguard: Never take more than is sustainable to protect resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like n_players,
                              n_rounds, and capacity.
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds
        self.threshold_cooperate = 0.7
        self.threshold_moderate_depletion = 0.3
        self.safety_margin_stock_ratio = 0.1

    def _calculate_consumption(self, current_stock: float, action: Action) -> float:
        """
        Calculates the actual consumption amount for a given action,
        ensuring safety constraints are met.

        Args:
            current_stock: The current stock level.
            action: The action chosen (Action.C or Action.D).

        Returns:
            The actual amount of stock to be consumed.
        """
        cooperative_consumption_amount = current_stock / (2 * self.n)
        defect_consumption_potential = current_stock / self.n
        min_stock_to_leave = self.capacity * self.safety_margin_stock_ratio
        max_allowed_consumption = max(0.0, current_stock - min_stock_to_leave)
        if action == Action.C:
            consumed = min(cooperative_consumption_amount, max_allowed_consumption)
        else:
            consumed = min(cooperative_consumption_amount, max_allowed_consumption)
        return consumed

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game (round number, current stock).
            history: The history of past actions and payoffs for all players.
                     None if it's the first round.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        current_round = state.round_number
        n_players = self.n
        capacity = self.capacity
        if current_stock <= 0:
            return Action.C
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.C
        stock_ratio = current_stock / capacity
        average_cooperation_ratio_last_round = 1.0
        if history is not None and len(history.my_actions) > 0:
            last_round_idx = len(history.my_actions) - 1
            num_my_coop = 1 if history.my_actions[last_round_idx] else 0
            num_opp_coop = np.sum(history.opponent_actions[last_round_idx, :])
            total_cooperators = num_my_coop + num_opp_coop
            average_cooperation_ratio_last_round = total_cooperators / n_players
        if stock_ratio > self.threshold_cooperate:
            return Action.C
        elif stock_ratio <= self.threshold_cooperate and stock_ratio > self.threshold_moderate_depletion:
            if average_cooperation_ratio_last_round >= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_72(BaseStrategy):
    """
    "Sustainable Exploitation with Forgiveness" strategy for the Common Pool Resource Game.

    This strategy aims to maximize long-term payoff by prioritizing the health of the
    common resource. It defaults to cooperation but will defect under specific conditions
    related to resource depletion and observed widespread defection. It includes a
    limited retaliation mechanism and a willingness to return to cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.resource_depletion_threshold = self.capacity / 2.0
        self.forgiveness_window_rounds = 2
        self.limited_retaliation_rounds = 1
        self.my_current_retaliation_turns_left = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == self.r:
            return Action.D
        if current_stock <= 0:
            return Action.C
        action = Action.C
        if self.my_current_retaliation_turns_left > 0:
            pass
        is_resource_critically_low = current_stock < self.resource_depletion_threshold
        recent_defections_count = 0
        if history is not None and current_round_number > 0:
            start_round_for_window = max(0, current_round_number - self.forgiveness_window_rounds)
            if history.opponent_actions.shape[0] > 0:
                recent_opponent_actions = history.opponent_actions[start_round_for_window:current_round_number, :]
                recent_defections_count = np.sum(recent_opponent_actions == False)
            if self.my_current_retaliation_turns_left > 0:
                my_recent_actions = history.my_actions[start_round_for_window:current_round_number]
                my_recent_defections = np.sum(my_recent_actions == False)
                recent_defections_count += my_recent_defections
        recent_defections_by_others_count = 0
        if history is not None and current_round_number > 0:
            start_round_for_window = max(0, current_round_number - self.forgiveness_window_rounds)
            if history.opponent_actions.shape[0] > 0:
                relevant_opponent_actions_slice = history.opponent_actions[start_round_for_window:current_round_number, :]
                recent_defections_by_others_count = np.sum(relevant_opponent_actions_slice == False)
        significant_defection_observed_last_round = False
        if history is not None and current_round_number > 0:
            previous_round_actions = history.opponent_actions[current_round_number - 1, :]
            defections_in_prev_round = np.sum(previous_round_actions == False)
            if defections_in_prev_round > self.n / 2:
                significant_defection_observed_last_round = True
        should_defect = False
        if is_resource_critically_low:
            if significant_defection_observed_last_round:
                if self.my_current_retaliation_turns_left > 0 or True:
                    should_defect = True
            elif self.my_current_retaliation_turns_left > 0:
                should_defect = True
        elif self.my_current_retaliation_turns_left > 0:
            should_defect = True
        if should_defect:
            action = Action.D
            if self.my_current_retaliation_turns_left == 0:
                self.my_current_retaliation_turns_left = self.limited_retaliation_rounds
        if action == Action.C:
            self.my_current_retaliation_turns_left = 0
        else:
            self.my_current_retaliation_turns_left -= 1
            if self.my_current_retaliation_turns_left < 0:
                self.my_current_retaliation_turns_left = 0
        if history is None:
            return Action.C
        return action

class Strategy_COOPERATIVE_73(BaseStrategy):
    """
    The "Sustainable Steward" strategy aims to maximize long-term collective well-being
    by prioritizing the health of the common pool. It cooperates by default,
    especially when the stock is abundant. When the stock is low, it continues to
    cooperate in non-final rounds to prevent depletion, only defecting in the
    very last round to secure immediate personal gain if the stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperative_threshold_percentage = 0.75
        self.cooperative_threshold = self.capacity * self.cooperative_threshold_percentage

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            if current_stock <= self.cooperative_threshold:
                return Action.D
            else:
                return Action.C
        if current_stock > self.cooperative_threshold:
            return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_74(BaseStrategy):
    """
    The Sustainable Stock Tracker strategy aims to maximize long-term collective well-being
    by balancing immediate gains with the preservation of the common resource. It cooperates
    by default when the stock is abundant or when others are cooperating. It defects only
    when the stock is critically low and there's clear evidence of persistent defection
    by other players, or in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.s_target = self.capacity * 0.6
        self.history_window = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if history is None:
            return Action.C
        avg_other_consumption_recent = 0
        num_history_rounds = min(self.history_window, current_round)
        if num_history_rounds > 0:
            total_other_consumption_in_history = 0
            for i in range(num_history_rounds):
                round_idx_in_history = current_round - num_history_rounds + i
                num_opponent_defectors_in_history = 0
                my_cooperative_consumption = current_stock / (2 * self.n)
                for i in range(num_history_rounds):
                    hist_round_idx = current_round - num_history_rounds + i
                    opponent_actions_this_round = history.opponent_actions[hist_round_idx, :]
                    num_defectors_this_round = np.sum(~opponent_actions_this_round)
                    num_cooperators_this_round = np.sum(opponent_actions_this_round)
                    num_opponent_defectors_in_history += num_defectors_this_round
                avg_defectors_per_opponent_per_round = num_opponent_defectors_in_history / (num_history_rounds * (self.n - 1)) if num_history_rounds * (self.n - 1) > 0 else 0
                avg_defectors_in_history = 0
                if num_history_rounds > 0:
                    recent_opponent_actions = history.opponent_actions[current_round - num_history_rounds:current_round, :]
                    if recent_opponent_actions.size > 0:
                        total_defects_in_window = np.sum(recent_opponent_actions == False)
                        total_opponent_actions_in_window = recent_opponent_actions.size
                        if total_opponent_actions_in_window > 0:
                            avg_defectors_proportion = total_defects_in_window / total_opponent_actions_in_window
                            defection_threshold = 0.75
                            if current_stock < self.s_target and avg_defectors_proportion > defection_threshold:
                                return Action.D
        if current_stock >= self.s_target:
            return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_75(BaseStrategy):
    """
    Sustainable Stock Management (SSM) Strategy.

    This strategy prioritizes the sustainability of the common pool resource by
    always cooperating. The core idea is to maximize long-term cumulative
    payoff by ensuring the resource is available for future rounds, rather
    than seeking short-term gains through defection that could lead to resource
    depletion and significantly lower future payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the SSM strategy.

        Args:
            game_description: An object containing game parameters like
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        This strategy always chooses to Cooperate (Action.C).

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs from previous rounds.
                     If None, it's the first round.

        Returns:
            The action to take (Action.C or Action.D).
        """
        return Action.C

class Strategy_COOPERATIVE_76(BaseStrategy):
    """
    Adaptive Sustainability with Graded Response Strategy for Common Pool Resource Game.

    This strategy aims to maximize long-term collective payoff by promoting
    sustainable resource management. It defaults to cooperation but responds
    adaptively to observed depletion and the collective consumption in the
    previous round. It uses a graded response to encourage cooperation without
    immediate punitive defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.tsl = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs for all players. None for the first round.

        Returns:
            Action: The chosen action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if history is None:
            return Action.C
        if current_stock < 2.0 * self.n:
            return Action.C
        cooperative_consumption_per_player_baseline = self.capacity / (2.0 * self.n)
        last_round_idx = current_round - 1
        total_consumption_last_round = 0.0
        if history.my_actions[last_round_idx]:
            total_consumption_last_round += current_stock / (2.0 * self.n)
        else:
            total_consumption_last_round += current_stock / self.n
        for opp_action in history.opponent_actions[last_round_idx]:
            if opp_action:
                total_consumption_last_round += current_stock / (2.0 * self.n)
            else:
                total_consumption_last_round += current_stock / self.n
        if current_stock >= self.tsl:
            if total_consumption_last_round <= self.n * cooperative_consumption_per_player_baseline:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_77(BaseStrategy):
    """
    Adaptive Sustainability Pledge (ASP) Strategy for the Common Pool Resource Game.

    This strategy aims to maximize long-term collective well-being by prioritizing
    stock sustainability. It cooperates by default, but responds to over-exploitation
    by temporarily defecting. It includes special handling for the first and last
    rounds, and critically low stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.cooperation_threshold = 0.6 * self.capacity
        self.critical_stock_threshold = 0.1 * self.capacity

    def _has_any_opponent_defected_last_round(self, history: PlayerHistory) -> bool:
        """Checks if any opponent defected in the previous round."""
        if history.round_number == 0:
            return False
        return np.any(history.opponent_actions[history.round_number - 1, :] == Action.D.value)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if history is None:
            return Action.C
        if current_round_number == self.r:
            return Action.C
        if current_stock <= self.critical_stock_threshold:
            return Action.C
        if current_stock >= self.capacity:
            return Action.C
        has_opponent_defected = self._has_any_opponent_defected_last_round(history)
        if current_stock < self.cooperation_threshold and has_opponent_defected:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_78(BaseStrategy):
    """
    "Sustainable Yield Maximizer" strategy for the Common Pool Resource Game.

    This strategy aims to maximize long-term collective well-being and individual payoffs
    by maintaining the common pool resource at a sustainable level. It prioritizes
    stock health, rewards cooperation, and deters defection through adaptive thresholds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.initial_cooperative_stock_threshold_ratio = 0.75
        self.min_cooperative_players_ratio = 0.5
        self.target_growth_factor = 0.8
        self.low_stock_threshold_ratio = 0.2
        self.critical_low_stock_ratio = 0.1
        self.cooperative_stock_adjustment_rate = 0.05
        self.min_cooperative_players_adjustment_rate = 0.1
        self.cooperative_stock_threshold = self.initial_cooperative_stock_threshold_ratio * self.capacity
        self.min_cooperative_players = math.ceil(self.n * self.min_cooperative_players_ratio)

    def _calculate_sustainable_consumption_limit(self, stock_prev: float) -> float:
        """
        Calculates the maximum total consumption that allows for healthy stock growth.
        """
        if stock_prev <= 0:
            return 0.0
        growth_potential = 2 * stock_prev * (1 - stock_prev / self.capacity)
        if stock_prev < self.capacity * self.critical_low_stock_ratio:
            return stock_prev * 0.1
        elif stock_prev < self.capacity * self.low_stock_threshold_ratio:
            return stock_prev * 0.5
        elif stock_prev < self.capacity * 0.5:
            return stock_prev * 0.7
        else:
            return growth_potential * self.target_growth_factor

    def _adjust_strategy_parameters(self, state: CommonPoolState, history: PlayerHistory):
        """
        Adaptively adjusts strategy parameters based on past round's outcomes.
        """
        if history is None or history.round_number == 0:
            return
        prev_round = history.round_number - 1
        prev_stock = self.capacity if prev_round == 0 else state.current_stock_at_round_start(prev_round)
        if history.round_number > 1:
            prev_round_idx = history.round_number - 1
            num_prev_cooperators = np.sum(history.opponent_actions[prev_round_idx, :]) + history.my_actions[prev_round_idx]
            if num_prev_cooperators < self.min_cooperative_players and num_prev_cooperators < self.n:
                self.min_cooperative_players += self.min_cooperative_players_adjustment_rate
                self.min_cooperative_players = min(self.n, max(math.ceil(self.n * self.min_cooperative_players_ratio), self.min_cooperative_players))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.previous_stock_start_of_round = self.capacity
            return Action.C
        if state.round_number == self.r:
            return Action.D
        current_stock = state.current_stock
        round_idx = state.round_number
        prev_round_idx = round_idx - 1
        prev_my_action = history.my_actions[prev_round_idx]
        prev_opponent_actions = history.opponent_actions[prev_round_idx, :]
        prev_total_consumption = self._calculate_total_consumption(prev_my_action, prev_opponent_actions, self.previous_stock_start_of_round, self.n, self.capacity)
        num_prev_cooperators = np.sum(prev_opponent_actions) + prev_my_action
        self.previous_stock_start_of_round = current_stock
        if round_idx > 1:
            current_min_players_threshold = self.min_cooperative_players
            observed_cooperators = num_prev_cooperators
            if observed_cooperators < current_min_players_threshold and observed_cooperators < self.n:
                self.min_cooperative_players += self.min_cooperative_players_adjustment_rate
                self.min_cooperative_players = min(self.n, max(math.ceil(self.n * self.min_cooperative_players_ratio), self.min_cooperative_players))
        if current_stock < self.capacity * self.critical_low_stock_ratio:
            return Action.D
        if current_stock < self.cooperative_stock_threshold:
            sustainable_consumption_limit = self._calculate_sustainable_consumption_limit(self.previous_stock_start_of_round)
            if num_prev_cooperators >= self.min_cooperative_players and prev_total_consumption <= sustainable_consumption_limit:
                return Action.C
            else:
                return Action.D
        sustainable_consumption_limit = self._calculate_sustainable_consumption_limit(self.previous_stock_start_of_round)
        if num_prev_cooperators >= self.min_cooperative_players and prev_total_consumption <= sustainable_consumption_limit:
            return Action.C
        else:
            return Action.D

    def _calculate_consumption_per_player(self, stock: float, action: Action) -> float:
        """Calculates consumption for a single player based on their action."""
        if action == Action.C:
            return stock / (2 * self.n)
        elif action == Action.D:
            return stock / self.n
        return 0.0

    def _calculate_total_consumption(self, my_action: Action, opponent_actions: NDArray[np.bool_], stock_at_start_of_round: float, n: int, capacity: int) -> float:
        """Calculates total consumption in a round."""
        total_consumption = self._calculate_consumption_per_player(stock_at_start_of_round, my_action)
        for opp_action in opponent_actions:
            action = Action.C if opp_action else Action.D
            total_consumption += self._calculate_consumption_per_player(stock_at_start_of_round, action)
        return total_consumption

class Strategy_COOPERATIVE_79(BaseStrategy):
    """
    Cooperative strategy that manages the common pool resource for sustainable growth.
    It prioritizes cooperation when the stock is abundant and defects only when
    the resource is critically depleted or in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing the game's parameters.
        """
        self.game_description = game_description
        self.cooperation_threshold_high_multiplier = 0.7
        self.cooperation_threshold_medium_multiplier = 0.4
        self.depletion_threshold_multiplier = 0.2
        self.cooperation_threshold_medium = self.game_description.capacity * self.cooperation_threshold_medium_multiplier
        self.depletion_threshold = self.game_description.capacity * self.depletion_threshold_multiplier

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) based on the current state and history.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs for all players, or None if it's the first round.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        remaining_rounds = self.game_description.n_rounds - state.round_number
        if remaining_rounds == 1:
            return Action.D
        if history is None:
            return Action.C
        if current_stock >= self.cooperation_threshold_medium:
            return Action.C
        elif current_stock < self.depletion_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_80(BaseStrategy):
    """
    "Sustainable Harvest with Deterrence" strategy.
    This strategy aims to cooperate by default but defects to deter unsustainable harvesting
    when the stock is critically low or when a majority of players are defecting.
    It returns to cooperation once conditions improve. The last round is an exception
    where it defects to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.depletion_threshold = self.capacity / 3.0
        self.recovery_threshold = self.capacity / 2.0
        self.majority_defection_threshold = math.floor(self.n * 0.5) + 1
        self.history_window = min(3, self.r)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.r:
            return Action.D
        if history is None:
            return Action.C
        will_defect_due_to_stock = False
        if current_stock < self.depletion_threshold:
            will_defect_due_to_stock = True
        will_defect_due_to_majority = False
        if round_number > self.history_window:
            recent_opponent_actions = history.opponent_actions[round_number - self.history_window:round_number, :]
            total_defectors_in_history = 0
            for round_idx in range(self.history_window):
                defectors_in_this_round = np.sum(recent_opponent_actions[round_idx, :] == False)
                if defectors_in_this_round >= self.majority_defection_threshold:
                    total_defectors_in_history += 1
            if total_defectors_in_history > math.floor(self.history_window / 2.0):
                will_defect_due_to_majority = True
        action_to_take = Action.C
        if will_defect_due_to_stock or will_defect_due_to_majority:
            action_to_take = Action.D
        if will_defect_due_to_majority and (not will_defect_due_to_stock) and (current_stock >= self.recovery_threshold):
            action_to_take = Action.C
        if will_defect_due_to_stock and current_stock >= self.recovery_threshold:
            action_to_take = Action.C
        return action_to_take

class Strategy_COOPERATIVE_81(BaseStrategy):
    """
    The "Sustainable Harvestor" strategy.

    This strategy aims to maximize long-term collective well-being by prioritizing
    the sustainability of the common pool resource. It dynamically adjusts
    consumption based on the current stock level, with thresholds for cooperation
    and a defensive defection when the resource is critically depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.HIGH_SUSTAINABILITY_THRESHOLD = 0.8
        self.MODERATE_SUSTAINABILITY_THRESHOLD = 0.4
        self.LOW_SUSTAINABILITY_THRESHOLD = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if history is None:
            return Action.C
        if current_stock < self.capacity * self.LOW_SUSTAINABILITY_THRESHOLD:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_82(BaseStrategy):
    """
    Sustainability-Focused Tit-for-Tat strategy for the Common Pool Resource Game.
    This strategy aims to maximize long-term cumulative payoff by promoting
    cooperation and preserving the common resource. It starts by cooperating,
    then reciprocates the group's average behavior, and punishes significant
    stock depletion by defecting, while prioritizing stock regeneration when
    critically low. Defection is the default in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = self.capacity / 4.0
        self.depletion_punishment_threshold = self.capacity * 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        ACTION_C = True
        ACTION_D = False
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.r:
            return Action.D
        if history is None:
            return Action.C
        prev_round_idx = history.round_number - 1
        if history.my_actions[prev_round_idx] == ACTION_C:
            pass
        else:
            pass
        if current_stock < self.critical_stock_threshold:
            return Action.C
        elif current_stock >= self.depletion_punishment_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_83(BaseStrategy):
    """
    The "Sustainable Harvest Guardian" strategy.

    This strategy prioritizes the long-term health of the common pool resource.
    It aims to maintain the stock above a dynamic "Sustainable Harvest Threshold" (SHT).
    Cooperation is the default action unless the stock is abundant and the game
    is not in its final round, or if the stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.two_n = 2 * self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.n_rounds:
            return Action.D
        if history is None:
            return Action.C
        if current_stock < self.two_n:
            return Action.C
        rounds_remaining = self.n_rounds - current_round
        if rounds_remaining > self.n_rounds / 2:
            sht = self.capacity * 0.6
        else:
            sht = self.capacity * 0.4
        if current_stock <= sht:
            return Action.C
        elif current_stock > self.capacity * 0.8:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_84(BaseStrategy):
    """
    The "Sustainable Stewardship" strategy is designed to maximize long-term
    resource viability and collective payoff in a Common Pool Resource Game.
    It prioritizes stock growth, employs fairness, and adapts to observed
    player behavior by dynamically adjusting cooperation and defection.
    It uses a lookback window to gauge average defection rates and shifts
    to defection when the stock is not critically low and others are defecting,
    acting as a deterrent. In critically low stock situations, it defaults to
    cooperation to prevent complete collapse. It defects in the final round
    to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.lookback_window = 10
        self.defection_threshold = 0.4
        self.buffer_low = self.capacity / 4.0
        self.buffer_high = self.capacity / 4.0
        self.lower_optimal_zone = self.capacity / 2.0 - self.buffer_low
        self.upper_optimal_zone = self.capacity / 2.0 + self.buffer_high
        self.epsilon = 0.1

    def _calculate_observed_defection_rate(self, history: PlayerHistory) -> float:
        """Calculates the average defection rate over the lookback window."""
        if history is None or history.round_number == 0:
            return 0.0
        num_completed_rounds = history.round_number
        start_round = max(0, num_completed_rounds - self.lookback_window)
        relevant_rounds_data = history.opponent_actions[start_round:num_completed_rounds, :]
        if relevant_rounds_data.size == 0:
            return 0.0
        total_defectors = np.sum(relevant_rounds_data == False)
        total_player_rounds = relevant_rounds_data.size
        return total_defectors / total_player_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds:
            return Action.D
        if history is None:
            return Action.C
        if current_stock < self.epsilon:
            return Action.C
        observed_defection_rate = self._calculate_observed_defection_rate(history)
        if current_stock > self.upper_optimal_zone and observed_defection_rate < self.defection_threshold:
            return Action.C
        if current_stock >= self.lower_optimal_zone and current_stock <= self.upper_optimal_zone and (observed_defection_rate < self.defection_threshold):
            return Action.C
        if current_stock < self.lower_optimal_zone and observed_defection_rate < self.defection_threshold:
            return Action.C
        if current_stock >= self.lower_optimal_zone and current_stock <= self.upper_optimal_zone and (observed_defection_rate >= self.defection_threshold):
            return Action.D
        if current_stock > self.upper_optimal_zone and observed_defection_rate >= self.defection_threshold:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_85(BaseStrategy):
    """
    The Custodian strategy: a cooperative, adaptive strategy for the Common Pool Resource Game.
    It defaults to cooperation but will defect conditionally if the resource is being overexploited
    by the group or in the very last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_round = state.round_number
        if history is None:
            return Action.C
        if current_round == self.game_description.n_rounds:
            return Action.D
        stock_t = state.current_stock
        past_total_consumptions = []
        if history:
            for i in range(history.round_number):
                round_stock = self.game_description.capacity
                num_defectors_last_k = 0
                total_players_in_last_k_rounds = 0
                if history:
                    num_rounds_to_consider = min(history.round_number, self.k)
                    if num_rounds_to_consider > 0:
                        for i in range(num_rounds_to_consider):
                            defectors_in_round = np.sum(1 - np.concatenate([[history.my_actions[i]], history.opponent_actions[i, :]]))
                            num_defectors_last_k += defectors_in_round
                            total_players_in_last_k_rounds += n
                avg_defectors_per_round = num_defectors_last_k / num_rounds_to_consider if num_rounds_to_consider > 0 else 0

                def is_group_overexploiting(history_obj, current_round_idx, n_players, lookback_k, defection_threshold_proportion=0.5):
                    if history_obj is None or current_round_idx < 1:
                        return False
                    rounds_to_check = min(current_round_idx, lookback_k)
                    if rounds_to_check == 0:
                        return False
                    total_actual_defectors = 0
                    for r in range(rounds_to_check):
                        my_action_r = history_obj.my_actions[r]
                        opponents_actions_r = history_obj.opponent_actions[r, :]
                        defectors_in_round = np.sum(1 - np.concatenate([[my_action_r], opponents_actions_r]))
                        total_actual_defectors += defectors_in_round
                    avg_defectors_per_round = total_actual_defectors / rounds_to_check
                    if avg_defectors_per_round / n_players > defection_threshold_proportion:
                        return True
                    return False
                if stock_t < capacity / 4.0:
                    return Action.C
                defection_threshold = 0.6
                if is_group_overexploiting(history, current_round, n, self.k, defection_threshold):
                    return Action.D
                return Action.C

class Strategy_COOPERATIVE_86(BaseStrategy):
    """
    Cooperative Strategy for the Common Pool Resource Game.

    This strategy prioritizes the long-term sustainability of the common resource
    by cooperating when the stock is healthy and defecting strategically when the
    resource is scarce or unsustainable practices are observed.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold_factor = 0.5
        self.adaptive_punishment_stock_level = 0.8 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        r_remaining = self.total_rounds - current_round_number
        if current_stock < 1e-06:
            return Action.D
        threshold_multiplier = self.critical_threshold_factor + 0.4 * (1 - r_remaining / self.total_rounds)
        critical_threshold = self.capacity * threshold_multiplier
        if current_stock > critical_threshold:
            return Action.C
        elif current_stock < self.adaptive_punishment_stock_level and current_round_number > 0:
            return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_87(BaseStrategy):
    """
    Cooperative Strategy: "Sustainable Harvest and Adaptive Replenishment"

    This strategy prioritizes the long-term health of the common pool resource
    by cooperating when the stock is low and defecting opportunistically when
    the stock is abundant. It aims to maximize individual and collective long-term
    payoffs by ensuring the resource is sustainable.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold = 0.75 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs from previous rounds.
                     None if it's the first round.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if current_stock < self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_88(BaseStrategy):
    """
    Sustainable Stewardship Strategy:
    This strategy aims to maximize long-term collective payoff by prioritizing
    resource health. It defaults to cooperation but strategically defects when
    the stock level drops below certain thresholds to prevent collapse or
    maximize short-term gains in precarious situations. It also defects in the
    final round to maximize individual payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.
        Args:
            game_description: An object containing game parameters like n_players,
                              n_rounds, and capacity.
        """
        self.game_description = game_description
        self.cooperation_threshold_ratio = 0.4
        self.survival_threshold_ratio = 0.1

    def _get_decision_thresholds(self) -> tuple[float, float]:
        """Calculates the absolute cooperation and survival thresholds."""
        capacity = self.game_description.capacity
        cooperation_threshold = self.cooperation_threshold_ratio * capacity
        survival_threshold = self.survival_threshold_ratio * capacity
        return (cooperation_threshold, survival_threshold)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.
        Args:
            state: An object containing the current round number and stock level.
            history: An object containing past actions and payoffs, or None if it's the first round.
        Returns:
            The chosen Action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        round_number = state.round_number
        n_rounds = self.game_description.n_rounds
        cooperation_threshold, survival_threshold = self._get_decision_thresholds()
        if round_number == n_rounds:
            return Action.D
        if current_stock > cooperation_threshold:
            return Action.C
        elif current_stock > survival_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_89(BaseStrategy):
    """
    Cooperative Strategy: "Sustainable Harvest with Measured Reciprocity"

    This strategy aims to maximize long-term payoffs by managing the common
    resource sustainably. It cooperates by default, defects cautiously when
    conditions allow for immediate gain without long-term detriment, and
    is responsive to the actions of other players.

    Decision Rule:
    Play C (Cooperate) unless all of the following conditions are met:
    1. Sufficient Stock: The current stock S_t is greater than 1.2 * capacity.
    2. Low Observed Defection: In the previous round (t-1), the proportion of
       players who defected was less than 0.3.
    3. Safe Defection Consumption: Even if player i defects, the resulting stock
       level after their consumption (S_t - S_t/n) will still be above the
       Sustainable Harvest Threshold (SHT), where SHT = 0.3 * capacity.

    If all three conditions are met, play D (Defect). Otherwise, play C (Cooperate).

    Edge Cases:
    - First Round (t=1): Always C.
    - Last Round (t=r): Always D.
    - Stock Depletion (S_t = 0): Always C (payoff will be 0 anyway).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.SUSTAINABLE_HARVEST_THRESHOLD = 0.3 * self.game_description.capacity
        self.HIGH_STOCK_THRESHOLD = 1.2 * self.game_description.capacity
        self.LOW_DEFECTION_RATE_THRESHOLD = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if history is None:
            return Action.C
        if current_round_number == self.game_description.n_rounds:
            return Action.D
        if current_stock <= 0:
            return Action.C
        previous_round_actions = history.opponent_actions[history.round_number - 1]
        num_defectors_previous_round = np.sum(previous_round_actions == Action.D.value)
        observed_defection_rate = num_defectors_previous_round / self.game_description.n_players
        can_consider_defection = False
        if current_stock > self.HIGH_STOCK_THRESHOLD:
            if observed_defection_rate < self.LOW_DEFECTION_RATE_THRESHOLD:
                my_consumption_if_defect = current_stock / self.game_description.n_players
                stock_after_my_defection = current_stock - my_consumption_if_defect
                if stock_after_my_defection > self.SUSTAINABLE_HARVEST_THRESHOLD:
                    can_consider_defection = True
        if can_consider_defection:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_90(BaseStrategy):
    """
    Sustainable Yield Cooperative (SYC) strategy.
    Aims to maximize collective and individual long-term payoffs by prioritizing
    the health of the common pool resource. Cooperates by default, but defects
    if the stock is critically low or if other players are consistently over-exploiting.
    It adapts its level of cooperation based on the observed behavior of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.s_coop_threshold_ratio = 0.75
        self.min_sustainable_consumption_ratio = 0.1
        self.cooperation_level = 1.0
        self.consumption_history_window = 5
        self.s_coop_threshold = 0.0
        self.min_sustainable_consumption = 0.0
        self.cumulative_consumption_per_player = 0.0
        self.round_consumption_history = []

    def _calculate_consumption(self, stock: float, action: Action) -> float:
        """Calculates the amount consumed by a player given their action and current stock."""
        if action == Action.C:
            return stock / (2 * self.game_description.n_players)
        else:
            return stock / self.game_description.n_players

    def _calculate_growth(self, stock_remaining: float, capacity: float) -> float:
        """Calculates the stock growth based on the logistic growth model."""
        return 2 * stock_remaining * (1 - stock_remaining / capacity)

    def _update_cooperation_level(self, observed_avg_consumption_per_player: float):
        """
        Adapts the cooperation_level based on observed consumption.
        If others consume more than a 'safe' level, cooperation_level decreases.
        If others consume less than a 'safe' level, cooperation_level increases.
        """
        current_cooperative_share = self.s_coop_threshold / (2 * self.game_description.n_players) if self.s_coop_threshold > 0 else 0
        if len(self.round_consumption_history) > 1:
            last_round_avg_consumption = self.round_consumption_history[-1]
            if last_round_avg_consumption > self.cumulative_consumption_per_player / len(self.round_consumption_history):
                self.cooperation_level = max(0.2, self.cooperation_level * 0.95)
            else:
                self.cooperation_level = min(2.0, self.cooperation_level * 1.05)
        elif observed_avg_consumption_per_player > self.cumulative_consumption_per_player / len(self.round_consumption_history):
            self.cooperation_level = max(0.2, self.cooperation_level * 0.98)
        else:
            self.cooperation_level = min(2.0, self.cooperation_level * 1.02)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides whether to Cooperate (C) or Defect (D) in the current round.

        Args:
            state: The current state of the game (round number, current stock).
            history: The history of past rounds (actions and payoffs).

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        current_round = state.round_number
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        r = self.game_description.n_rounds
        if self.s_coop_threshold == 0.0:
            self.s_coop_threshold = self.s_coop_threshold_ratio * capacity
            self.min_sustainable_consumption = self.min_sustainable_consumption_ratio * capacity
        if history is None:
            self.cumulative_consumption_per_player = 0.0
            self.round_consumption_history = []
            self.cooperation_level = 1.0
            return Action.C
        previous_total_consumption = 0.0
        if current_round > 0:
            if not hasattr(self, 'stock_at_start_of_round'):
                self.stock_at_start_of_round = capacity
            stock_at_start_of_previous_round = self.stock_at_start_of_round
            my_action_prev = Action.C if history.my_actions[current_round - 1] else Action.D
            my_consumption_prev = self._calculate_consumption(stock_at_start_of_previous_round, my_action_prev)
            previous_total_consumption = my_consumption_prev
            for i in range(n - 1):
                opp_action_prev = Action.C if history.opponent_actions[current_round - 1, i] else Action.D
                previous_total_consumption += self._calculate_consumption(stock_at_start_of_previous_round, opp_action_prev)
            self.stock_at_start_of_round = current_stock
            avg_consumption_this_round = previous_total_consumption / n
            self.round_consumption_history.append(avg_consumption_this_round)
            if len(self.round_consumption_history) > self.consumption_history_window:
                self.round_consumption_history.pop(0)
            self.cumulative_consumption_per_player = sum(self.round_consumption_history) / len(self.round_consumption_history) if self.round_consumption_history else 0
            self._update_cooperation_level(self.cumulative_consumption_per_player)
        if current_round == r:
            if current_stock < self.min_sustainable_consumption:
                return Action.D
            else:
                return Action.C
        if current_stock < self.min_sustainable_consumption:
            return Action.D
        if current_stock > self.s_coop_threshold:
            cooperative_share = current_stock / (2 * n)
            excessive_consumption_threshold = cooperative_share * (1 + self.cooperation_level)
            if self.cumulative_consumption_per_player < excessive_consumption_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COOPERATIVE_91(BaseStrategy):
    """
    "Sustainable Stewardship" Strategy for Common Pool Resource Game.

    This strategy prioritizes long-term collective welfare by maintaining
    the common pool stock at healthy levels. It cooperates when the stock
    is high enough to support significant growth and defects when the stock
    is low to prevent depletion. It handles edge cases like the first and
    last rounds, and near-zero stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like
                              number of players, rounds, and capacity.
        """
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (C or D) for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: Historical data of past rounds (actions and payoffs).
                     None for the first round.

        Returns:
            Action: The action to take (Action.C or Action.D).
        """
        current_round = state.round_number
        current_stock = state.current_stock
        if history is None:
            return Action.C
        if current_round == self.n_rounds:
            return Action.D
        epsilon = 1e-09
        if current_stock < epsilon:
            return Action.C
        stock_threshold = self.capacity / 2.0
        if current_stock >= stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_92(BaseStrategy):
    """
    The Adaptive Stock Guardian strategy aims to maximize long-term collective payoff
    by maintaining a healthy stock level. It defaults to cooperation but adapts its
    behavior based on stock levels and observed consumption patterns. It includes
    thresholds for regeneration and full cooperation, and a mechanism to deter
    sustained over-exploitation by switching to defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.regeneration_threshold = self.capacity / 3.0
        self.full_cooperation_threshold = self.capacity * 0.8
        self.historical_total_consumption = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if history is None:
            return Action.C
        avg_consumption_last_rounds = 0.0
        num_history_rounds = len(self.historical_total_consumption)
        if num_history_rounds >= 3:
            avg_consumption_last_rounds = sum(self.historical_total_consumption[-3:]) / 3.0
        elif num_history_rounds > 0:
            avg_consumption_last_rounds = sum(self.historical_total_consumption) / num_history_rounds
        is_stock_low = current_stock < self.full_cooperation_threshold
        is_consumption_high_recently = False
        if current_stock > 1e-06:
            if num_history_rounds > 0:
                total_consumption_last_round = self.historical_total_consumption[-1]
                if total_consumption_last_round / current_stock > 0.7:
                    is_consumption_high_recently = True
            if num_history_rounds >= 3 and (not is_consumption_high_recently):
                if avg_consumption_last_rounds / current_stock > 0.7:
                    is_consumption_high_recently = True
        if current_stock < self.n * 0.1:
            return Action.C
        if current_stock >= self.full_cooperation_threshold:
            return Action.C
        if self.regeneration_threshold < current_stock < self.full_cooperation_threshold:
            if is_consumption_high_recently:
                return Action.D
            else:
                return Action.C
        if current_stock <= self.regeneration_threshold:
            if is_consumption_high_recently:
                return Action.D
            else:
                return Action.C
        return Action.C

    def _update_state(self, state: CommonPoolState, history: PlayerHistory, all_actions: list[Action]):
        current_stock = state.current_stock
        current_round_idx = state.round_number
        total_consumption_this_round = 0.0
        for i, action in enumerate(all_actions):
            consumption = 0.0
            if action == Action.C:
                consumption = current_stock / (2.0 * self.n)
            elif action == Action.D:
                consumption = current_stock / float(self.n)
            total_consumption_this_round += consumption
        self.historical_total_consumption.append(total_consumption_this_round)
        stock_after_consumption = current_stock - total_consumption_this_round
        if stock_after_consumption < 0:
            stock_after_consumption = 0.0
        growth = 2.0 * stock_after_consumption * (1.0 - stock_after_consumption / self.capacity)
        new_stock = min(stock_after_consumption + growth, self.capacity)

class Strategy_COOPERATIVE_93(BaseStrategy):
    """
    The "Sustainable Harvester" strategy for the Common Pool Resource Game.
    This strategy prioritizes long-term sustainability by defaulting to cooperation
    and only defecting when the resource is severely depleted. It aims to maximize
    total obtainable payoff over the game's duration by ensuring the common pool
    resource remains healthy and abundant.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Sustainable Harvester strategy.

        Args:
            game_description: An object containing the game parameters (n_players,
                              n_rounds, capacity).
        """
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.has_defect_been_triggered = False
        self.depletion_threshold = self.capacity * 0.3
        self.recovery_threshold = self.capacity * 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: History of actions and payoffs from previous rounds. If None,
                     it's the first round.

        Returns:
            Action: The action to take (Action.C for Cooperate, Action.D for Defect).
        """
        current_round = state.round_number
        current_stock = state.current_stock
        if history is None:
            return Action.C
        if current_round == self.n_rounds:
            return Action.C
        if self.has_defect_been_triggered and current_stock < self.depletion_threshold:
            return Action.D
        if self.has_defect_been_triggered and current_stock >= self.recovery_threshold:
            self.has_defect_been_triggered = False
            return Action.C
        if not self.has_defect_been_triggered and current_stock < self.depletion_threshold:
            self.has_defect_been_triggered = True
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_94(BaseStrategy):
    """
    Cooperative Strategy: "Sustainable Stock Maximizer"
    This strategy aims to maximize long-term payoff by managing the common pool resource sustainably.
    It prioritizes maintaining a healthy stock level, defaulting to cooperation, and adapting its
    threshold based on observed stock trends and depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold_ratio = 0.75
        self.cooperation_threshold = self.capacity * self.cooperation_threshold_ratio
        self.adaptive_threshold_adjustment_rate = 0.01 * self.capacity
        self.min_stock_for_defection_trigger = self.n
        self.previous_stock = self.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if current_stock < self.min_stock_for_defection_trigger:
            return Action.C
        if current_stock >= self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

    def update_strategy_state(self, state: CommonPoolState, history: PlayerHistory) -> None:
        """
        Updates strategy internal state for adaptation based on the last round's outcome.
        This method is called after the decision for the current round is made but before the next round starts.
        """
        current_stock = state.current_stock
        current_round = state.round_number
        stock_at_start_of_prev_round = self.previous_stock
        stock_at_start_of_current_round = current_stock
        stock_changed_positively = stock_at_start_of_current_round >= stock_at_start_of_prev_round
        stock_below_threshold = stock_at_start_of_current_round < self.cooperation_threshold
        if not stock_below_threshold and stock_changed_positively:
            self.cooperation_threshold = max(self.min_stock_for_defection_trigger, self.cooperation_threshold - self.adaptive_threshold_adjustment_rate)
        elif stock_below_threshold and (not stock_changed_positively):
            self.cooperation_threshold = min(self.capacity, self.cooperation_threshold + self.adaptive_threshold_adjustment_rate)
        elif stock_below_threshold and stock_changed_positively:
            if stock_at_start_of_current_round > self.cooperation_threshold * 1.1:
                self.cooperation_threshold = max(self.min_stock_for_defection_trigger, self.cooperation_threshold - self.adaptive_threshold_adjustment_rate / 2)
            else:
                pass
        self.cooperation_threshold = max(self.min_stock_for_defection_trigger, min(self.capacity, self.cooperation_threshold))
        self.previous_stock = current_stock

    def _calculate_next_stock(self, current_stock: float, actions: dict[int, Action]) -> float:
        """Helper to simulate stock dynamics for adaptation purposes if needed."""
        n_players = self.n
        capacity = self.capacity
        total_consumption = 0.0
        for player_idx, action in actions.items():
            if action == Action.C:
                consumption = current_stock / (2 * n_players)
            else:
                consumption = current_stock / n_players
            total_consumption += consumption
        stock_after_consumption = current_stock - total_consumption
        stock_after_consumption = max(0.0, stock_after_consumption)
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
        new_stock = min(stock_after_consumption + growth, capacity)
        return new_stock

    def handle_round_end(self, state: CommonPoolState, history: PlayerHistory):
        """
        This method is called by the simulation environment after a round has concluded.
        It's the place to update strategy state based on observed outcomes.
        """
        if history.round_number > 0:
            self.update_strategy_state(state, history)
        else:
            self.previous_stock = state.current_stock

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold_ratio = 0.75
        self.cooperation_threshold = self.capacity * self.cooperation_threshold_ratio
        self.adaptive_threshold_adjustment_rate = 0.01 * self.capacity
        self.min_stock_for_defection_trigger = self.n
        self.previous_stock = self.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if current_stock < self.min_stock_for_defection_trigger:
            return Action.C
        if current_stock >= self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_95(BaseStrategy):
    """
    The "Sustainable Steward" strategy aims to maintain the common pool resource
    while adapting to the behavior of other players. It prioritizes long-term
    sustainability by cooperating when the stock is low, reciprocating cooperation,
    and using defection as a punitive measure only when the stock is healthy and
    other players are consistently defecting. It defects in the final round to
    maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.coop_threshold_factor = 0.4
        self.defect_threshold_factor = 0.7
        self.punishment_round_buffer = 2
        self.stock_at_start_of_round = {}

    def _get_cooperation_consumption(self, stock: float) -> float:
        return stock / (2.0 * self.n)

    def _get_defection_consumption(self, stock: float) -> float:
        return stock / float(self.n)

    def _calculate_coop_threshold(self, current_stock: float) -> float:
        return self.capacity * self.coop_threshold_factor

    def _calculate_defect_threshold(self, current_stock: float) -> float:
        return self.capacity * self.defect_threshold_factor

    def _calculate_avg_opponent_consumption(self, stock_at_start_of_round: float, opponent_actions_prev_round: NDArray[np.bool_]) -> float:
        total_opponent_consumption = 0.0
        num_opponents_observed = 0
        for opponent_action in opponent_actions_prev_round:
            if opponent_action:
                consumption = self._get_cooperation_consumption(stock_at_start_of_round)
            else:
                consumption = self._get_defection_consumption(stock_at_start_of_round)
            total_opponent_consumption += consumption
            num_opponents_observed += 1
        if num_opponents_observed > 0:
            return total_opponent_consumption / num_opponents_observed
        else:
            return 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        self.stock_at_start_of_round[current_round] = current_stock
        if current_round == self.r - 1:
            return Action.D
        if history is None:
            return Action.C
        previous_round_index = current_round - 1
        if previous_round_index < 0:
            return Action.C
        opponent_actions_prev_round = history.opponent_actions[previous_round_index]
        stock_at_start_of_prev_round = self.stock_at_start_of_round[previous_round_index]
        coop_consumption_per_player_prev = self._get_cooperation_consumption(stock_at_start_of_prev_round)
        defect_consumption_per_player_prev = self._get_defection_consumption(stock_at_start_of_prev_round)
        avg_opp_consumption_prev_round = self._calculate_avg_opponent_consumption(stock_at_start_of_prev_round, opponent_actions_prev_round)
        coop_threshold = self._calculate_coop_threshold(current_stock)
        defect_threshold = self._calculate_defect_threshold(current_stock)
        if current_stock < coop_threshold:
            return Action.C
        elif avg_opp_consumption_prev_round < coop_consumption_per_player_prev:
            return Action.C
        elif avg_opp_consumption_prev_round < defect_consumption_per_player_prev:
            return Action.C
        elif current_stock >= defect_threshold and current_round < self.r - 1 - self.punishment_round_buffer:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_96(BaseStrategy):
    """
    Adaptive Stock Guardian strategy for the Common Pool Resource Game.

    This strategy aims to maximize long-term collective payoff by prioritizing
    stock sustainability. It reacts to the current stock level and adapts its
    cooperation threshold based on past outcomes, aiming for a balance between
    extraction and conservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Stock Guardian strategy.

        Args:
            game_description: An object containing game parameters.
        """
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.current_threshold = 0.75
        self.T_adjustment_factor_good_stock = 0.02
        self.T_adjustment_factor_bad_stock_coop = -0.03
        self.T_adjustment_factor_bad_stock_defect = -0.05
        self.T_adjustment_factor_good_stock_defect = 0.01
        self.min_T_when_coop = 0.5
        self.min_T_when_defect = 0.4
        self.low_stock_threshold_multiplier = 0.1
        self.stock_history: list[float] = []
        self.action_history: list[Action] = []
        self.last_stock: float | None = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs, or None for the first round.

        Returns:
            The action to take: Action.C (Cooperate) or Action.D (Defect).
        """
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.n_rounds:
            return Action.D
        if history is None:
            self.stock_history.append(current_stock)
            self.action_history.append(Action.C)
            self.last_stock = current_stock
            return Action.C
        if current_stock < self.n_players * self.low_stock_threshold_multiplier:
            my_action = Action.D
            self._update_history(current_stock, my_action)
            return my_action
        stock_ratio = current_stock / self.capacity
        if stock_ratio >= self.current_threshold:
            my_action = Action.C
        else:
            my_action = Action.D
        if len(self.action_history) > 0:
            previous_action = self.action_history[-1]
            stock_change_indicator = current_stock - self.last_stock
            if previous_action == Action.C:
                if stock_change_indicator >= 0:
                    self.current_threshold = min(1.0, self.current_threshold + self.T_adjustment_factor_good_stock)
                else:
                    self.current_threshold = max(self.min_T_when_coop, self.current_threshold + self.T_adjustment_factor_bad_stock_coop)
            elif stock_change_indicator >= 0:
                self.current_threshold = min(1.0, self.current_threshold + self.T_adjustment_factor_good_stock_defect)
            else:
                self.current_threshold = max(self.min_T_when_defect, self.current_threshold + self.T_adjustment_factor_bad_stock_defect)
        self._update_history(current_stock, my_action)
        return my_action

    def _update_history(self, current_stock: float, action: Action):
        """Helper to update internal history tracking."""
        self.stock_history.append(current_stock)
        self.action_history.append(action)
        self.last_stock = current_stock

class Strategy_COOPERATIVE_97(BaseStrategy):
    """
    The "Sustainable Harvester" strategy.

    This strategy prioritizes the long-term health of the common pool resource.
    It defaults to cooperation (C) as long as the stock level is healthy.
    If the stock falls below a critical threshold (capacity / n), it defects (D)
    as a punitive measure and to secure a share of a dwindling resource.
    It always defects in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.defection_threshold = self.capacity / self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds:
            return Action.D
        if history is None:
            return Action.C
        if current_stock <= 0:
            return Action.C
        elif current_stock < self.defection_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_98(BaseStrategy):
    """
    Adaptive Stock Guardian strategy for the Common Pool Resource Game.

    This strategy aims to maximize long-term collective payoff by balancing
    individual gain with resource sustainability. It defaults to cooperation
    but responds proportionally to perceived threats to the stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like n_players,
                              n_rounds, and capacity.
        """
        self.game_description = game_description
        self.stock_threshold = game_description.capacity * 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: History of actions and payoffs from previous rounds.
                     None if it's the first round.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == r:
            return Action.D
        if history is None:
            return Action.C
        if current_stock < 1e-06:
            return Action.C
        previous_round_defectors = np.sum(history.opponent_actions[current_round - 1, :] == False)
        if current_stock > self.stock_threshold and previous_round_defectors == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_99(BaseStrategy):
    """
    The "Sustainable Steward" strategy.
    This strategy aims to maximize collective long-term payoff by balancing
    individual immediate gains with the sustainability of the common resource.
    It cooperates when the stock is healthy and defects when it's necessary
    to secure a minimal payoff or prevent immediate collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy.

        Args:
            game_description: An object containing game parameters.
        """
        self.game_description = game_description
        self.cooperative_safety_threshold_percentage = 0.2

    def _get_cooperative_safety_threshold(self) -> float:
        """Calculates the absolute stock value for the CST."""
        return self.game_description.capacity * self.cooperative_safety_threshold_percentage

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (C or D) for the current round.

        Args:
            state: The current state of the game.
            history: The history of actions and payoffs up to the previous round.

        Returns:
            Action: The action to take (Action.C or Action.D).
        """
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_stock = state.current_stock
        current_round_number = state.round_number
        cst = self._get_cooperative_safety_threshold()
        if current_round_number == 1:
            return Action.C
        if current_round_number == r:
            return Action.D
        if current_stock < n:
            return Action.D
        if current_stock <= cst:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_100(BaseStrategy):
    """
    Adaptive Sustainable Consumption (ASC) Strategy.

    This strategy prioritizes the long-term health of the common pool resource.
    It predominantly cooperates, taking smaller shares of the stock, especially
    when the stock level is low or moderate. It only considers defecting in the
    very final rounds when the stock is healthy, to maximize immediate payoff.
    The decision logic is based on the current stock level as a proportion of
    capacity and the number of remaining rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy.

        Args:
            game_description: An object containing game parameters (n_players,
                              n_rounds, capacity).
        """
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and current stock.
            history: The history of actions and payoffs up to the previous round.
                     If None, it's the first round.

        Returns:
            The action to take (Action.C or Action.D).
        """
        current_stock = state.current_stock
        round_number = state.round_number
        total_rounds = self.n_rounds
        if history is None:
            if total_rounds <= 2:
                if 1.0 > 0.75:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        stock_proportion = current_stock / self.capacity
        remaining_rounds = total_rounds - round_number
        stock_proportion = max(0.0, stock_proportion)
        if stock_proportion > 0.75:
            if remaining_rounds <= 2:
                return Action.D
            else:
                return Action.C
        elif stock_proportion >= 0.35:
            return Action.C
        elif stock_proportion >= 0.15:
            return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_101(BaseStrategy):
    """
    The "Adaptive Guardian" strategy aims to maximize long-term cumulative payoff
    by prioritizing the sustainability of the common pool resource. It adopts a
    cooperative stance as the default but incorporates mechanisms to punish
    defection and adapt to depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.
        """
        self.game_description = game_description
        self.HEALTHY_THRESHOLD_RATIO = 0.75
        self.MODERATE_THRESHOLD_RATIO = 0.5

    def _get_healthy_threshold(self) -> float:
        """Calculates the stock level considered 'healthy'."""
        return self.game_description.capacity * self.HEALTHY_THRESHOLD_RATIO

    def _get_moderate_threshold(self) -> float:
        """Calculates the stock level considered 'moderately concerning'."""
        return self.game_description.capacity * self.MODERATE_THRESHOLD_RATIO

    def _has_any_previous_defection(self, history: PlayerHistory) -> bool:
        """Checks if any opponent defected in the previous round."""
        if history.round_number == 0:
            return False
        last_round_idx = history.round_number - 1
        for player_action_array in history.opponent_actions[last_round_idx, :]:
            if not player_action_array:
                return True
        return False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides whether to Cooperate (C) or Defect (D) based on the current game state.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs for this player and opponents.
                     None if this is the first round.

        Returns:
            Action.C for cooperation, Action.D for defection.
        """
        current_stock = state.current_stock
        current_round = state.round_number
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        healthy_threshold = self._get_healthy_threshold()
        moderate_threshold = self._get_moderate_threshold()
        if current_round == r:
            return Action.D
        if current_stock <= n:
            return Action.D
        if current_stock >= healthy_threshold:
            if history is None or not self._has_any_previous_defection(history):
                return Action.C
        previous_defection_occurred = history is not None and self._has_any_previous_defection(history)
        if previous_defection_occurred:
            if current_stock < moderate_threshold:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_102(BaseStrategy):
    """
    "Sustainable Reciprocity" strategy for the Common Pool Resource Game.

    This strategy aims to maximize individual long-term payoff by fostering a
    sustainable environment for resource extraction. It's a tit-for-tat-like
    approach adapted for a common pool resource game with stock dynamics,
    prioritizing cooperation but punishing defection to preserve the resource.

    Decision Rules:
    - Default Action: Cooperate (C) if the average consumption per player in the
      previous round was at or below the cooperative level (stock/(2n)).
    - Punishment: Defect (D) if the average consumption per player in the
      previous round was above the cooperative level.

    Edge Cases:
    - Round 1: Always play C to initiate cooperation.
    - Last Round (r): Always play D to maximize immediate payoff.
    - Depleted Stock (stock <= 0): Always play C (effectively no consumption).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if history is None:
            return Action.C
        if current_round == self.r:
            return Action.D
        if current_stock <= 0:
            return Action.C
        previous_round_idx = current_round - 1
        stock_previous_round = self.game_description.capacity
        stock_previous_round = current_stock
        previous_round_actions = history.opponent_actions[history.round_number - 1, :]
        this_player_action_prev_round = history.my_actions[history.round_number - 1]
        total_consumption_previous_round = 0.0
        if this_player_action_prev_round:
            total_consumption_previous_round += stock_previous_round / (2 * self.n)
        else:
            total_consumption_previous_round += stock_previous_round / self.n
        for i in range(self.n - 1):
            if previous_round_actions[i]:
                total_consumption_previous_round += stock_previous_round / (2 * self.n)
            else:
                total_consumption_previous_round += stock_previous_round / self.n
        average_consumption_per_player_previous_round = total_consumption_previous_round / self.n
        cooperative_consumption_level_previous_round = stock_previous_round / (2 * self.n)
        if average_consumption_per_player_previous_round <= cooperative_consumption_level_previous_round:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_103(BaseStrategy):
    """
    "Sustainable Growth Guardian" Strategy.
    This strategy prioritizes the long-term health of the common pool resource.
    It defaults to cooperation in most scenarios, aiming to maximize collective benefit.
    Defection is a rare, last-resort measure only considered if the stock is critically endangered
    and a controlled defection might prevent imminent collapse or aid recovery,
    while not immediately depleting the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.
        """
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_threshold = self.capacity / 4.0
        self.initial_stock_for_analysis = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) based on the current state and history.
        """
        current_stock = state.current_stock
        current_round = state.round_number
        if history is None:
            return Action.C
        if current_round == self.r:
            return Action.C
        if current_stock < self.critical_stock_threshold:
            return Action.C
        if current_stock >= self.capacity * 0.95:
            return Action.C
        return Action.C

class Strategy_COOPERATIVE_104(BaseStrategy):
    """
    The "Sustainable Steward" strategy. This strategy prioritizes long-term resource
    sustainability by defaulting to cooperation. It defects only when the resource
    is critically depleted or in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOPERATE_THRESHOLD = 0.7 * self.game_description.capacity
        self.CAUTIONARY_THRESHOLD = 0.4 * self.game_description.capacity
        self.CRITICAL_DEPLETION_THRESHOLD = 0.2 * self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == r:
            return Action.D
        if history is None:
            return Action.C
        action = Action.C
        if current_stock < self.CRITICAL_DEPLETION_THRESHOLD:
            action = Action.D
        elif current_stock < self.CAUTIONARY_THRESHOLD:
            action = Action.C
        else:
            action = Action.C
        return action

class Strategy_COOPERATIVE_106(BaseStrategy):
    """
    Adaptive Cooperative Strategy: "Cautious Growth"

    This strategy prioritizes long-term growth and sustainability of the common pool
    resource by defaulting to cooperation. It employs a defensive defection strategy
    only in two scenarios:
    1. In the very last round to maximize individual payoff.
    2. When the stock level drops below a "cautionary threshold," indicating a
       significant risk of resource depletion, likely due to other players' behavior.

    The cautionary threshold is adaptive, scaling with the number of remaining rounds,
    making the strategy more conservative as the game progresses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.cautionary_factor = 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = float(state.current_stock)
        current_round = state.round_number
        if current_round == self.n_rounds - 1:
            return Action.C
        rounds_left_inclusive = self.n_rounds - current_round
        S_caution = self.capacity * (rounds_left_inclusive / self.n_rounds) * self.cautionary_factor
        S_caution = max(0.0, S_caution)
        if current_stock < S_caution:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_107(BaseStrategy):
    """
    Cooperative Strategy: "Sustainable Grasp"

    This strategy aims to maximize long-term collective payoff by prioritizing
    resource sustainability. It cooperates when the resource is abundant or
    scarce, and adapts its behavior in the medium stock range based on
    inferred resource dynamics. It plays cooperatively in the first round
    and switches to a more self-interested strategy in the final round only
    if it can yield a good payoff without immediate depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.initial_stock = float(game_description.capacity)
        self.HIGH_STOCK_THRESHOLD = 0.75
        self.MEDIUM_STOCK_THRESHOLD = 0.4
        self.EPSILON = 0.001

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = float(state.current_stock)
        current_round = state.round_number
        if history is None:
            return Action.C
        if current_stock <= self.EPSILON:
            return Action.C
        if current_round == self.n_rounds:
            if current_stock > self.n_players:
                return Action.D
            else:
                return Action.C
        stock_fraction = current_stock / self.capacity
        if stock_fraction > self.HIGH_STOCK_THRESHOLD:
            return Action.C
        elif stock_fraction >= self.MEDIUM_STOCK_THRESHOLD:
            return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_108(BaseStrategy):
    """
    Cooperative Strategy for the Common Pool Resource Game.
    This strategy aims to maximize long-term collective payoff by maintaining
    resource sustainability. It prioritizes cooperation when the stock is healthy
    and uses defection as a last resort when the stock is critically low or
    in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.c_thresh = 0.75 * self.capacity
        self.m_thresh = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if history is None:
            return Action.C
        if round_num == self.r:
            return Action.D
        if current_stock <= 0:
            return Action.C
        if current_stock > self.c_thresh:
            return Action.C
        elif current_stock >= self.m_thresh:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_109(BaseStrategy):
    """
    "Sustainable Harvest" Strategy:
    This strategy prioritizes the long-term sustainability of the common pool resource
    by largely cooperating. It aims to keep the stock at healthy levels to ensure
    robust regeneration and consistent payoffs over time. The only deviation from
    cooperation is in the final round, where it defects to maximize immediate gain,
    acknowledging the game's terminal nature.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.r_thresh = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == self.r:
            return Action.D
        if current_stock >= self.r_thresh:
            return Action.C
        elif current_stock > 0 and current_stock < self.r_thresh:
            return Action.C
        elif current_stock <= 0:
            return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_110(BaseStrategy):
    """
    Cooperative Strategy for the Common Pool Resource Game.

    This strategy aims to maximize long-term cumulative payoff by promoting
    resource sustainability. It prioritizes cooperation when the stock is healthy,
    but incorporates a responsive mechanism to penalize defection and adapt to
    resource scarcity.

    Decision Rules:
    - If current stock > T_C: Cooperate (C).
    - If T_D < current stock <= T_C:
        - Defect (D) if any player defected in the previous round.
        - Cooperate (C) otherwise.
    - If current stock <= T_D: Defect (D).
    - Always Defect (D) in the last round.
    - Cooperate (C) if stock <= 0 (symbolic).

    Thresholds:
    - T_C (Cooperation Threshold): capacity * 0.6
    - T_D (Depletion Threshold): capacity * 0.2
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold = self.capacity * 0.6
        self.depletion_threshold = self.capacity * 0.2
        self.observed_defection_in_previous_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if history is not None:
            if current_stock > self.cooperation_threshold:
                self.observed_defection_in_previous_round = False
            elif history.round_number > 0:
                last_round_index = history.round_number - 1
                if np.any(history.opponent_actions[last_round_index, :] == Action.D.value):
                    self.observed_defection_in_previous_round = True
                else:
                    pass
            else:
                self.observed_defection_in_previous_round = False
        else:
            self.observed_defection_in_previous_round = False
        if current_round_number == self.r:
            return Action.D
        if current_stock <= 0:
            return Action.C
        if current_stock > self.cooperation_threshold:
            return Action.C
        elif current_stock > self.depletion_threshold:
            if self.observed_defection_in_previous_round:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_111(BaseStrategy):
    """
    The "Sustainable Harvest" strategy aims to maintain the common pool resource
    by prioritizing cooperation and adapting its consumption based on the stock level.
    It cooperates when the stock is high or medium, switches to a more conservative
    approach when the stock is low, and can use a limited punishment mechanism
    against detected defections when the resource is vulnerable. It defects in the
    last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.TARGET_COOP_THRESHOLD = 0.8 * self.capacity
        self.SAFE_HARVEST_THRESHOLD = 0.6 * self.capacity
        self.DEGRADATION_THRESHOLD = 0.3 * self.capacity
        self.PUNISHMENT_INITIATION_THRESHOLD = 0.2 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.r:
            return Action.D
        if current_stock < self.PUNISHMENT_INITIATION_THRESHOLD:
            if history is not None and history.round_number > 0:
                last_round_opponent_actions = history.opponent_actions[history.round_number - 1, :]
                if np.any(last_round_opponent_actions == Action.D.value):
                    return Action.D
        if current_stock > self.TARGET_COOP_THRESHOLD:
            return Action.C
        elif current_stock >= self.SAFE_HARVEST_THRESHOLD:
            return Action.C
        elif current_stock >= self.DEGRADATION_THRESHOLD:
            return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_112(BaseStrategy):
    """
    Cooperative Strategy: "Sustainable Stewardship"

    This strategy aims to maximize long-term collective welfare by prioritizing
    the sustainability of the common pool resource, while also ensuring a
    reasonable individual payoff. It is designed to be adaptive to a variety
    of opponent behaviors and the evolving state of the resource.

    Core Principle: Gradual Depletion and Reserve Building
    The fundamental idea is to consume at a rate that allows the stock to regenerate
    efficiently, especially when the stock is healthy. As the stock depletes, the
    strategy becomes more conservative, aiming to prevent collapse and rebuild
    the resource. A key element is maintaining a buffer stock to weather periods
    of higher consumption by others.

    Decision Rules: When to Cooperate vs. Defect
    The decision to cooperate (C) or defect (D) is primarily driven by the current
    stock level relative to its capacity, and a target "cooperative consumption threshold."

    1. If Stock is Abundant (stock > capacity * 1.2): Cooperate (C)
       Rationale: When the stock is significantly above the nominal cooperative
       consumption level, it's safe to cooperate. This allows for greater growth
       from the resource regeneration mechanism. The 1.2 multiplier acts as a
       small buffer.
    2. If Stock is Healthy (capacity * 0.8 <= stock <= capacity * 1.2): Cooperate (C)
       Rationale: This is the zone where cooperation is generally the most beneficial
       for long-term sustainability. The resource can regenerate effectively, and
       all players receive a moderate payoff. The 0.8 multiplier introduces a slight
       downward tolerance before considering more aggressive conservation.
    3. If Stock is Depleted (stock < capacity * 0.8): Decision hinges on immediate
       payoff vs. long-term risk.
       - If (stock/n) < (stock/(2n)) * 2: Cooperate (C)
         Rationale: This condition checks if the payoff from defecting (stock/n) is
         not substantially higher than the payoff from cooperating (stock/(2n)).
         If defecting only yields twice the cooperative payoff, it might be worth
         cooperating to preserve the resource for future rounds. This is a conservative
         interpretation.
       - If (stock/n) >= (stock/(2n)) * 2: Defect (D)
         Rationale: If the stock is low AND defecting offers a significantly higher
         immediate payoff (more than double the cooperative payoff), the strategy
         will defect. This is a measure to extract value when the resource is in
         danger of collapse.

    Handling Edge Cases:
    - First Round (history is None): Cooperate (C). Sets a positive tone.
    - Last Round (current_round == n_rounds): Defect (D). Maximize individual gain.
    - Stock Reaching Zero (current_stock <= 0): Cooperate (C). Nothing to consume.

    Being Cooperative:
    This strategy is fundamentally cooperative in spirit and design for the following reasons:
    - Prioritization of Resource Health: Actively seeks to keep the stock at healthy levels.
    - Default to Cooperation: Cooperation is the default action in most scenarios.
    - Long-Term Perspective: Values sustainability over short-term individual gains.
    - Adaptive Conservation: Adapts behavior based on the evolving state of the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.ABUNDANT_THRESHOLD_MULTIPLIER = 1.2
        self.HEALTHY_THRESHOLD_MULTIPLIER = 0.8
        self.DEFECT_PAYOFF_MULTIPLIER = 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if current_stock <= 0:
            return Action.C
        if history is None:
            return Action.C
        cooperative_payoff_per_player = current_stock / (2.0 * self.n)
        defect_payoff_per_player = current_stock / float(self.n)
        abundant_stock_level = self.capacity * self.ABUNDANT_THRESHOLD_MULTIPLIER
        healthy_stock_level = self.capacity * self.HEALTHY_THRESHOLD_MULTIPLIER
        if current_stock > abundant_stock_level:
            return Action.C
        elif current_stock > healthy_stock_level:
            return Action.C
        elif defect_payoff_per_player >= cooperative_payoff_per_player * self.DEFECT_PAYOFF_MULTIPLIER:
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_113(BaseStrategy):
    """
    "Sustainable Steward" Strategy: A purely cooperative strategy for the Common Pool Resource Game.

    This strategy prioritizes the long-term health of the common resource by always choosing to
    cooperate. The rationale is that consistent cooperation maximizes the chances of sustained
    resource availability and, consequently, the highest cumulative payoff for all players over
    multiple rounds. It assumes that the ultimate goal is shared welfare, achieved through
    responsible resource management. The strategy does not adapt its action based on stock levels
    or history, maintaining a steadfast commitment to cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the SustainableStewardStrategy.

        Args:
            game_description: An object containing game parameters like n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action for the current round.

        For the "Sustainable Steward" strategy, the decision is always to cooperate.
        The strategy's core tenet is to preserve the common resource for long-term gain,
        regardless of the current stock level or past actions of opponents.

        Args:
            state: The current state of the game, including the round number and current stock.
            history: Information about past rounds, including own and opponents' actions and payoffs.
                     This strategy does not use the history to make its decision.

        Returns:
            Action.C: Always returns Cooperate.
        """
        return Action.C

class Strategy_COOPERATIVE_114(BaseStrategy):
    """
    Cooperative Strategy for the Common Pool Resource Game.

    This strategy aims to maximize long-term collective payoff by prioritizing
    resource sustainability. It follows a "cooperate by default, reciprocate
    observed behavior" philosophy.

    Core Principles:
    1. Prioritize Sustainability: Maintain stock for consistent high yields.
    2. Cooperate by Default: Assume others aim for sustainability.
    3. Reciprocate Behavior: Adapt based on observed player actions.
    4. Stock Management: Adjust consumption based on stock levels.

    Decision Rules:
    - First Round (t=1): Always Cooperate (C).
    - Last Round (t=r): Always Defect (D).
    - Stock Near Zero: Cooperate (C) to prevent collapse.
    - Stock at Capacity: Cooperate (C) for safe consumption.
    - General Case:
        - Default: Cooperate (C).
        - Conditional Defection Trigger:
            - Stock falls below `critical_stock_level`.
            - OR a significant percentage of players defected last round.
        - Defection Tiers: If triggered, play D. The strategy is designed
          to be a moderate reciprocator, not an aggressive defector.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_level_fraction = 0.3
        self.critical_stock_level = self.capacity * self.critical_stock_level_fraction
        self.defection_percentage_threshold_fraction = 0.3
        self.min_cooperative_consumption_threshold = self.capacity / (2.0 * self.n)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == self.r:
            return Action.D
        if history is None:
            return Action.C
        if current_stock <= self.min_cooperative_consumption_threshold:
            return Action.C
        if current_stock >= self.capacity:
            return Action.C
        num_previous_rounds = history.round_number
        if num_previous_rounds == 0:
            return Action.C
        previous_round_idx = num_previous_rounds - 1
        num_defectors_last_round = np.sum(history.opponent_actions[previous_round_idx, :] == False)
        my_last_action_bool = history.my_actions[previous_round_idx]
        all_players_last_actions_bool = np.append(history.opponent_actions[previous_round_idx, :], my_last_action_bool)
        num_defectors_last_round = np.sum(all_players_last_actions_bool == False)
        percentage_defectors_last_round = num_defectors_last_round / self.n
        if current_stock >= self.critical_stock_level and percentage_defectors_last_round < self.defection_percentage_threshold_fraction:
            return Action.C
        if current_stock < self.critical_stock_level or percentage_defectors_last_round >= self.defection_percentage_threshold_fraction:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_115(BaseStrategy):
    """
    The Adaptive Stock Guardian strategy is designed to be inherently cooperative
    by prioritizing the long-term health of the common stock. It adapts its
    behavior based on the current state of the stock, the number of rounds
    remaining, and a general assessment of whether the collective is cooperating
    or defecting.

    Core Principles:
    1. Stock Preservation is Paramount: The strategy's primary objective is to keep
       the stock at a level where it can sustainably regenerate.
    2. Gradual Depletion: It will tolerate some level of defections from others
       and adjust its own consumption cautiously.
    3. Leverage Growth: Aims to keep the stock in the zone of maximum growth
       (around capacity/2).
    4. Retaliation (Limited and Last Resort): If others consistently defect and
       deplete the stock to dangerous levels, it will reluctantly defect.

    Decision Rules are based on:
    - Stock level relative to capacity.
    - Rounds remaining in the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.total_rounds = game_description.n_rounds
        self.HIGH_STOCK_THRESHOLD_RATIO = 0.7
        self.MODERATE_STOCK_THRESHOLD_RATIO = 0.4
        self.LOW_STOCK_THRESHOLD_RATIO = 0.2
        self.CRITICAL_STOCK_THRESHOLD_RATIO = 0.1
        self.ROUNDS_MID_POINT_RATIO = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        rounds_remaining = self.total_rounds - current_round_number
        if current_stock <= 0:
            return Action.C
        if rounds_remaining == 1:
            return Action.D
        HIGH_STOCK_THRESHOLD = self.HIGH_STOCK_THRESHOLD_RATIO * self.capacity
        MODERATE_STOCK_THRESHOLD = self.MODERATE_STOCK_THRESHOLD_RATIO * self.capacity
        LOW_STOCK_THRESHOLD = self.LOW_STOCK_THRESHOLD_RATIO * self.capacity
        CRITICAL_STOCK_THRESHOLD = self.CRITICAL_STOCK_THRESHOLD_RATIO * self.capacity
        ROUNDS_MID_POINT = self.ROUNDS_MID_POINT_RATIO * self.total_rounds
        if current_stock >= HIGH_STOCK_THRESHOLD and rounds_remaining >= ROUNDS_MID_POINT:
            return Action.C
        elif MODERATE_STOCK_THRESHOLD <= current_stock < HIGH_STOCK_THRESHOLD and rounds_remaining >= ROUNDS_MID_POINT:
            return Action.C
        elif LOW_STOCK_THRESHOLD <= current_stock < MODERATE_STOCK_THRESHOLD and rounds_remaining >= ROUNDS_MID_POINT:
            return Action.C
        elif current_stock < CRITICAL_STOCK_THRESHOLD or (rounds_remaining < ROUNDS_MID_POINT and current_stock < MODERATE_STOCK_THRESHOLD):
            return Action.D
        else:
            return Action.C

class Strategy_COOPERATIVE_116(BaseStrategy):
    """
    Cooperative Strategy: "Sustainable Stock Keeper"

    This strategy aims to maintain the stock at a level that allows for significant,
    but not excessive, consumption while also fostering growth. It prioritizes the
    long-term viability of the resource, which ultimately benefits all players.

    Decision Rules:
    - Cooperate (C) if current_stock > target_stock_level.
    - Defect (D) if current_stock <= target_stock_level.
    - Always cooperate on the first round.
    - Always defect on the last round.

    The target_stock_level is set to 50% of capacity, which is the point of maximum
    stock growth. This adaptive approach balances immediate gains with long-term
    resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.target_stock_multiplier = 0.5
        self.target_stock_level = self.capacity * self.target_stock_multiplier

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == self.r - 1:
            return Action.D
        if current_stock <= 0:
            return Action.D
        if current_stock >= self.capacity:
            return Action.C
        if current_stock > self.target_stock_level:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_117(BaseStrategy):
    """
    The "Adaptive Sustainer" strategy.
    This strategy aims to foster cooperation by defaulting to it,
    but will defect strategically if the resource is critically low,
    or if the overall level of cooperation from other players is insufficient.
    It also defects in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.msst = 0.3 * self.capacity
        self.rhi_target = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if history is None:
            return Action.C
        if history.round_number > 0:
            num_cooperators_prev_round = sum(history.opponent_actions[-1, :]) + (1 if history.my_actions[-1] else 0)
            rhi = num_cooperators_prev_round / self.n
        else:
            rhi = 1.0
        if current_stock <= self.msst:
            return Action.D
        elif current_stock > self.msst and rhi >= self.rhi_target:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_118(BaseStrategy):
    """
    "Sustainable Exploitation with Deterrence" strategy.
    This strategy aims to maximize long-term payoff by promoting resource sustainability.
    It defaults to cooperation but retaliates against excessive depletion by defecting
    until consumption levels return to moderate. It also defects in the last round
    and cooperates when the resource is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_mode = False
        self.current_round_num = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.current_round_num = state.round_number
        if self.current_round_num == self.r:
            return Action.D
        if state.current_stock < 1.0:
            self.punishment_mode = False
            return Action.C
        if history is None:
            self.punishment_mode = False
            return Action.C
        prev_round_idx = self.current_round_num - 1
        total_consumption_prev_round = 0.0
        if history.my_actions[prev_round_idx] == Action.C.value:
            total_consumption_prev_round += state.current_stock / (2 * self.n)
        else:
            total_consumption_prev_round += state.current_stock / self.n
        for opp_action in history.opponent_actions[prev_round_idx]:
            if opp_action == Action.C.value:
                total_consumption_prev_round += state.current_stock / (2 * self.n)
            else:
                total_consumption_prev_round += state.current_stock / self.n
        average_consumption_prev_round = total_consumption_prev_round / self.n
        healthy_zone_threshold = self.capacity * 0.6
        depleted_zone_threshold = self.capacity * 0.2
        cooperative_consumption_level = self.capacity / (2 * self.n)
        defecting_consumption_level = self.capacity / self.n
        if average_consumption_prev_round >= defecting_consumption_level:
            if state.current_stock > depleted_zone_threshold:
                self.punishment_mode = True
            else:
                self.punishment_mode = False
        elif average_consumption_prev_round <= cooperative_consumption_level and state.current_stock > depleted_zone_threshold:
            self.punishment_mode = False
        elif state.current_stock < depleted_zone_threshold:
            self.punishment_mode = False
        if self.punishment_mode:
            return Action.D
        if state.current_stock > healthy_zone_threshold:
            return Action.C
        elif state.current_stock < depleted_zone_threshold:
            return Action.C
        else:
            return Action.C

class Strategy_COOPERATIVE_119(BaseStrategy):
    """
    Adaptive Sustainable Yield Strategy (ASYS)

    This strategy aims to maximize long-term cumulative payoffs by balancing
    immediate gains with the sustainability of the common resource. It prioritizes
    a sustainable stock, understanding that a depleted stock leads to zero or
    very low payoffs for everyone. The ASYS cooperates when the stock is healthy,
    becomes cautious as it declines, and defects when the stock is critically low
    or in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold_frac = 0.75
        self.depletion_threshold_frac = 0.25
        self.critical_stock_for_recovery_frac = 0.1
        self.cooperation_threshold = self.cooperation_threshold_frac * self.capacity
        self.depletion_threshold = self.depletion_threshold_frac * self.capacity
        self.critical_stock_for_recovery = self.critical_stock_for_recovery_frac * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if history is None:
            return Action.C
        if round_number == self.r:
            return Action.D
        if current_stock < self.critical_stock_for_recovery:
            return Action.C
        if current_stock >= self.cooperation_threshold:
            return Action.C
        if current_stock > self.depletion_threshold:
            return Action.C
        if current_stock <= self.depletion_threshold:
            return Action.D
        return Action.C

class Strategy_COOPERATIVE_120(BaseStrategy):
    """
    The "Adaptive Sustainer" strategy.
    This strategy prioritizes long-term resource sustainability by defaulting
    to cooperation. It adapts its threshold for cooperation based on the
    stock level after consumption in the previous round. It defects in the
    final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.initial_cooperative_threshold_factor = 0.75
        self.min_cooperative_threshold_factor = 0.1
        self.max_cooperative_threshold_factor = 0.9
        self.threshold_adjustment_factor_strict = 0.9
        self.threshold_adjustment_factor_lenient = 0.95
        self.threshold_adjustment_factor_growth = 1.02
        self.low_stock_threshold_factor = 0.3
        self.medium_stock_threshold_factor = 0.5
        self.cooperative_threshold = 0.0
        self.total_consumption_prev_round = 0.0
        self.stock_after_consumption_prev_round = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == self.n_rounds:
            return Action.D
        if history is None:
            self.cooperative_threshold = self.capacity * self.initial_cooperative_threshold_factor
            self.total_consumption_prev_round = 0.0
            self.stock_after_consumption_prev_round = self.capacity
            return Action.C
        if not hasattr(self, 'previous_stock_state'):
            self.previous_stock_state = self.capacity
        stock_at_start_of_last_round = self.previous_stock_state
        total_consumption_this_round_from_history = 0.0
        last_round_my_action = history.my_actions[-1] if len(history.my_actions) > 0 else None
        if last_round_my_action is not None:
            for i in range(self.n_players):
                if i == 0:
                    if last_round_my_action:
                        total_consumption_this_round_from_history += stock_at_start_of_last_round / (2 * self.n_players)
                    else:
                        total_consumption_this_round_from_history += stock_at_start_of_last_round / self.n_players
                elif history.opponent_actions[-1, i - 1]:
                    total_consumption_this_round_from_history += stock_at_start_of_last_round / (2 * self.n_players)
                else:
                    total_consumption_this_round_from_history += stock_at_start_of_last_round / self.n_players
            stock_after_consumption_this_round_from_history = stock_at_start_of_last_round - total_consumption_this_round_from_history
            stock_proportion_after_consumption = stock_after_consumption_this_round_from_history / self.capacity
            if stock_proportion_after_consumption < self.low_stock_threshold_factor:
                self.cooperative_threshold = max(self.capacity * self.min_cooperative_threshold_factor, self.cooperative_threshold * self.threshold_adjustment_factor_strict)
            elif stock_proportion_after_consumption < self.medium_stock_threshold_factor:
                self.cooperative_threshold = max(self.capacity * self.min_cooperative_threshold_factor, self.cooperative_threshold * self.threshold_adjustment_factor_lenient)
            else:
                self.cooperative_threshold = min(self.capacity * self.max_cooperative_threshold_factor, self.cooperative_threshold * self.threshold_adjustment_factor_growth)
        else:
            self.cooperative_threshold = self.capacity * self.initial_cooperative_threshold_factor
        self.cooperative_threshold = max(self.capacity * self.min_cooperative_threshold_factor, self.cooperative_threshold)
        self.cooperative_threshold = min(self.capacity * self.max_cooperative_threshold_factor, self.cooperative_threshold)
        self.previous_stock_state = current_stock
        if current_stock >= self.cooperative_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_121(BaseStrategy):
    """
    The "Sustainable Share" strategy aims to maximize long-term collective payoff
    by ensuring the resource remains healthy and productive. It prioritizes
    sustainability and cooperation but includes mechanisms to protect itself
    and the group from potential exploitation.

    Core Philosophy:
    Consume a "fair share" of the resource, defined by what can be sustained
    without depleting the stock below a critical level. This fair share is
    dynamically adjusted based on the current stock and the number of players.
    The strategy is inherently cooperative because it aims to preserve the
    common good for everyone, over time.

    Decision Rules:
    - If current_stock < critical_stock_level: Play C (Conserve the resource).
    - If current_stock >= critical_stock_level: Play C (Take the cooperative share).

    Robustness:
    - Monitors observed defections. If more than RECIPROCITY_DEFECTION_THRESHOLD
      players defect for RECIPROCITY_GRACE_PERIOD consecutive rounds, the player
      will switch to playing C to minimize its own consumption.
    - In the last round, plays D to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_RATIO = 0.25
        self.RECIPROCITY_DEFECTION_THRESHOLD = math.ceil(self.game_description.n_players / 2)
        self.RECIPROCITY_GRACE_PERIOD = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_idx = state.round_number
        if current_round_idx == r:
            return Action.D
        cooperative_action = Action.C
        critical_stock_level = capacity * self.CRITICAL_STOCK_RATIO
        cooperative_consumption_per_player = current_stock / (2 * n)
        total_cooperative_consumption = n * cooperative_consumption_per_player
        stock_after_cooperative_consumption = current_stock - total_cooperative_consumption
        if current_stock < critical_stock_level or stock_after_cooperative_consumption < 0:
            return Action.C
        if history is not None:
            num_defectors_in_recent_rounds = 0
            rounds_to_check = min(current_round_idx, self.RECIPROCITY_GRACE_PERIOD)
            for i in range(1, rounds_to_check + 1):
                actions_in_prev_round = history.opponent_actions[current_round_idx - i, :]
                num_defectors_this_round = np.sum(actions_in_prev_round == Action.D.value)
                if num_defectors_this_round > self.RECIPROCITY_DEFECTION_THRESHOLD:
                    num_defectors_in_recent_rounds += 1
            if num_defectors_in_recent_rounds >= self.RECIPROCITY_GRACE_PERIOD:
                return Action.C
        return Action.C

class Strategy_COOPERATIVE_122(BaseStrategy):
    """
    The "Sustainable Harvester" strategy.

    This strategy prioritizes long-term resource sustainability and cooperative behavior.
    It defaults to cooperation (C) as long as the common pool stock is above a "safe threshold."
    If the stock falls below a "critical threshold," it switches to defection (D) as a last resort
    to secure a minimal payoff from a dwindling resource, acknowledging that the cooperative
    equilibrium may have been broken by others.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like n_players,
                              n_rounds, and capacity.
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.SAFE_THRESHOLD_RATIO = 0.4
        self.CRITICAL_THRESHOLD_RATIO = 0.1
        self.s_safe = self.capacity * self.SAFE_THRESHOLD_RATIO
        self.s_critical = self.capacity * self.CRITICAL_THRESHOLD_RATIO

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action to take in the current round.

        Args:
            state: The current state of the game, including the round number and current stock.
            history: The history of actions and payoffs up to the current round.
                     None if it's the first round.

        Returns:
            The action (Action.C or Action.D) to take in the current round.
        """
        current_stock = state.current_stock
        current_round_number = state.round_number
        if history is None:
            return Action.C
        if current_stock > self.s_safe:
            return Action.C
        elif current_stock <= self.s_safe and current_stock > self.s_critical:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_123(BaseStrategy):
    """
    Sustainable Stock Manager (SSM) strategy for the Common Pool Resource Game.

    This strategy prioritizes the sustainability of the common pool resource by
    defaulting to cooperation. It only considers defection when the stock is
    above a critical threshold and defection offers a higher immediate payoff,
    and even then, only if it does not risk immediate stock collapse if all
    players were to defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the SSM strategy.

        Args:
            game_description: An object containing game parameters (n_players, n_rounds, capacity).
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity * 0.5
        self.danger_zone_threshold = self.capacity * 0.25

    def _get_my_payoff(self, current_stock: float, action: Action) -> float:
        """Calculates the payoff for this player given the current stock and action."""
        if action == Action.C:
            return current_stock / (2.0 * self.n)
        elif action == Action.D:
            return current_stock / self.n
        return 0.0

    def _get_potential_stock_if_all_defect(self, current_stock: float) -> float:
        """
        Calculates the stock level after consumption and growth if all players defect.
        This is a worst-case scenario check for the stock.
        """
        if current_stock <= 0:
            return 0.0
        total_consumption_all_defect = self.n * (current_stock / self.n)
        stock_after_consumption = current_stock - total_consumption_all_defect
        if stock_after_consumption <= 0:
            return 0.0
        growth = 2.0 * stock_after_consumption * (1.0 - stock_after_consumption / self.capacity)
        new_stock = stock_after_consumption + growth
        return min(new_stock, self.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game (round_number, current_stock).
            history: The history of actions and payoffs for all players. None for the first round.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        if current_stock <= self.danger_zone_threshold:
            return Action.C
        if current_stock > self.critical_threshold:
            return Action.C
        if self.danger_zone_threshold < current_stock <= self.critical_threshold:
            cooperate_payoff = self._get_my_payoff(current_stock, Action.C)
            defect_payoff = self._get_my_payoff(current_stock, Action.D)
            if defect_payoff > cooperate_payoff:
                potential_new_stock_if_all_defect = self._get_potential_stock_if_all_defect(current_stock)
                survival_epsilon = 1e-09
                if potential_new_stock_if_all_defect > survival_epsilon:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        return Action.C

class Strategy_COOPERATIVE_124(BaseStrategy):
    """
    Adaptive Sustainable Harvesting (ASH) Strategy.

    This strategy aims to maximize long-term individual payoffs by fostering the
    sustainability of the common pool resource. It prioritizes cooperation when
    the stock is healthy and transitions to more cautious behavior when the stock
    is depleted or nearing depletion. The core idea is to act as a responsible
    steward of the resource, recognizing that individual short-term gains from
    defection can lead to collective long-term ruin.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.alpha = 0.75
        self.min_alpha = 0.5
        self.max_alpha = 0.9
        self.alpha_step = 0.01
        self.cooperation_benefit_threshold_ratio = 0.05
        self.significant_drop_ratio_coop = 0.1
        self.significant_drop_ratio_defect = 0.2
        self.previous_stock = float(self.capacity)
        self.previous_action_is_cooperate = True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if history is None:
            self.previous_stock = current_stock
            self.previous_action_is_cooperate = True
            return Action.C
        if round_number == self.n_rounds:
            return Action.D
        current_alpha = self.alpha
        coop_threshold = current_alpha * self.capacity
        action_to_take = Action.D
        cooperate_condition_1 = current_stock >= coop_threshold
        cooperate_condition_2 = current_stock >= self.previous_stock * (1 - self.cooperation_benefit_threshold_ratio)
        cooperate_condition_3 = current_stock >= self.previous_stock * (1 - self.cooperation_benefit_threshold_ratio)
        if cooperate_condition_1 and cooperate_condition_2 and self.previous_action_is_cooperate:
            action_to_take = Action.C
        elif cooperate_condition_1 and cooperate_condition_3 and (not self.previous_action_is_cooperate):
            pass
        if current_stock < coop_threshold:
            action_to_take = Action.D
        elif self.previous_action_is_cooperate and current_stock < self.previous_stock * (1 - self.significant_drop_ratio_coop):
            action_to_take = Action.D
        if round_number > 0:
            completed_round_index = round_number - 1
            stock_at_start_of_completed_round = self.capacity if completed_round_index == 0 else self._get_stock_at_round_start(history, completed_round_index)
            action_in_completed_round = history.my_actions[completed_round_index]
            stock_at_start_of_current_round = current_stock
            if action_to_take == Action.C:
                if stock_at_start_of_current_round >= self.previous_stock:
                    self.alpha = max(self.min_alpha, self.alpha - self.alpha_step)
                elif stock_at_start_of_current_round < self.previous_stock * (1 - self.significant_drop_ratio_coop):
                    self.alpha = min(self.max_alpha, self.alpha + self.alpha_step)
            elif stock_at_start_of_current_round > self.previous_stock:
                self.alpha = max(self.min_alpha, self.alpha - self.alpha_step * 0.5)
        self.previous_stock = current_stock
        self.previous_action_is_cooperate = action_to_take == Action.C
        return action_to_take

    def _get_stock_at_round_start(self, history: PlayerHistory, round_idx: int) -> float:
        """
        This is a mock helper. In a real simulation, you would need access to
        the stock levels after each round's dynamics. This method would require
        the simulator to expose this information or to re-simulate.
        Given the constraints, we can only infer trends from start-of-round stocks.
        For simplicity, let's assume if history is available, the stock at the start
        of round `round_idx` is `self.previous_stock` from when `round_idx-1` was computed.
        However, `self.previous_stock` is only the stock from the *last* completed round.
        This is a significant limitation for accurate adaptive alpha.

        A pragmatic approach: use a rolling average or store the full stock history if possible.
        Since we can't store full history easily without making `__init__` more complex or relying on outer scope,
        we'll make a simplified assumption: if it's not the first round, `previous_stock` *is* the stock at the start
        of the round whose action was `history.my_actions[round_idx]`.
        """
        if round_idx == 0:
            return self.capacity
        pass

class Strategy_COOPERATIVE_125(BaseStrategy):
    """
    Cooperative Sustainability Strategy for Common Pool Resource Game.

    This strategy aims to maximize long-term total payoff by managing the common
    pool resource sustainably. It cooperates when the stock is healthy (above
    capacity/2) and defects when the stock is low (below capacity/2) to secure
    immediate gains and signal resource endangerment. It always defects in the
    last round for maximum immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy.

        Args:
            game_description: An object containing game parameters.
        """
        self.game_description = game_description
        self.sustainable_consumption_threshold = self.game_description.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs for all players.
                     If None, this is the first round.

        Returns:
            The action to take: Action.C (Cooperate) or Action.D (Defect).
        """
        current_stock = state.current_stock
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if current_stock >= self.sustainable_consumption_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_126(BaseStrategy):
    """
    "Sustainable Yield Maximizer" strategy.
    Cooperates when the resource stock is high or medium, and defects when it's critically low.
    Cooperates in the first round and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.s_stable = 0.75 * self.capacity
        self.s_critical = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.r:
            return Action.D
        if history is None:
            return Action.C
        if current_stock >= self.s_stable:
            return Action.C
        elif current_stock > self.s_critical:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_127(BaseStrategy):
    """
    The "Sustainable Steward" strategy for the Common Pool Resource Game.
    This strategy prioritizes long-term resource sustainability by cooperating
    when the stock is low or healthy, and employing cautious defection only
    when the stock is very high and there are sufficient rounds remaining.
    It always defects in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_low_threshold_ratio = 0.2
        self.S_healthy_threshold_ratio = 0.6
        self.S_high_threshold_ratio = 0.8
        self.S_low = self.S_low_threshold_ratio * self.capacity
        self.S_healthy = self.S_healthy_threshold_ratio * self.capacity
        self.S_high = self.S_high_threshold_ratio * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        remaining_rounds = self.r - current_round + 1
        if remaining_rounds == 1:
            return Action.D
        if current_stock < self.S_low:
            return Action.C
        if current_stock < self.S_healthy:
            return Action.C
        if current_stock >= self.S_high and current_stock < self.capacity:
            if remaining_rounds > 2 and current_stock > self.S_high:
                return Action.D
            else:
                return Action.C
        if current_stock >= self.S_healthy and current_stock < self.S_high:
            return Action.C
        return Action.C

class Strategy_COOPERATIVE_128(BaseStrategy):
    """
    Cooperative strategy: "Sustainable Growth Maximizer".
    Aims to maximize long-term payoff by ensuring resource sustainability.
    Prioritizes cooperation when the stock is healthy and defects to protect
    the resource when it's low.

    Decision Rules:
    - Cooperate (C) if current stock (S) is above the "healthy threshold".
    - Defect (D) if current stock (S) is at or below the "healthy threshold".

    Healthy Threshold Calculation:
    `healthy_threshold = max(capacity * 0.4, stock / 2)`

    - `capacity * 0.4`: Ensures a baseline buffer.
    - `stock / 2`: Dynamically adjusts based on current stock, becoming stricter
                   when the stock is low.

    Edge Cases:
    - First Round: Cooperate (C) to establish cooperation.
    - Last Round: Continues to follow primary decision rules for cooperative principle.
    - Stock Zero/Negative: Will choose to defect, though payoff is 0.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        if history is None:
            return Action.C
        sustainability_threshold = self.capacity * 0.4
        dynamic_stock_threshold = current_stock / 2.0
        healthy_threshold = max(sustainability_threshold, dynamic_stock_threshold)
        if current_stock <= 0:
            return Action.D
        elif current_stock > healthy_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_1(BaseStrategy):
    """
    Aggressive "Dominant Harvest" strategy.
    Defects whenever the stock is healthy (>= capacity/2) or there are future rounds.
    Cooperates only when stock is low (< capacity/2) AND it's the final round.
    This strategy prioritizes immediate individual gain, assuming that if the
    resource collapses, it's better to have extracted as much as possible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_threshold = self.capacity / 2.0
        self.epsilon = 1e-09

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_stock < self.epsilon:
            return Action.C
        if current_stock >= self.stock_threshold:
            return Action.D
        elif current_round_number == self.r:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_2(BaseStrategy):
    """
    The "Ruthless Exploiter" strategy. This strategy prioritizes immediate gain
    by defaulting to "Defect". It only cooperates if the stock is critically low
    or if a majority of players defected in the previous round, indicating a
    need to retaliate or avoid being exploited. Cooperation is also skipped in
    the final round to maximize extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = self.capacity / 4

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_stock <= self.critical_stock_threshold:
            return Action.C
        if history is None:
            return Action.D
        num_previous_defectors = np.sum(history.opponent_actions[-1, :])
        total_previous_players = self.n
        if num_previous_defectors >= math.ceil(self.n / 2):
            return Action.D
        if current_round_number == self.r:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_3(BaseStrategy):
    """
    The Opportunist strategy for the Common Pool Resource Game.
    This strategy aims to maximize individual gain by exploiting the common pool
    resource when stock levels are high, and cooperating to preserve the resource
    when stock levels become critically low. It prioritizes short-term gains
    while being mindful of resource depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like n_players,
                              n_rounds, and capacity.
        """
        self.game_description = game_description
        self.aggression_factor = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and stock level.
            history: The history of actions and payoffs for all players up to the
                     previous round. None for the first round.

        Returns:
            The action to take: Action.C (Cooperate) or Action.D (Defect).
        """
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock <= 0:
            return Action.C
        if current_stock > self.aggression_factor * capacity:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_4(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.
    This strategy prioritizes taking the largest possible share of the resource
    in each round by defecting, unless the stock level drops below a
    calculated critical threshold, at which point it cooperates to avoid
    complete depletion and ensure its own survival in future rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the AggressiveStrategy.

        Args:
            game_description: An object containing game parameters like
                              n_players, n_rounds, and capacity.
        """
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.aggression_factor = 0.25
        self.critical_stock_level = self.capacity * self.aggression_factor

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Chooses an action (Cooperate or Defect) based on the current state and history.

        Args:
            state: The current state of the game, including round number and current stock.
            history: The history of actions and payoffs for all players. None for the first round.

        Returns:
            Action: The chosen action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        if state.round_number == self.r:
            return Action.D
        if current_stock < self.n:
            return Action.C
        if current_stock > self.critical_stock_level:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_5(BaseStrategy):
    """
    "The Predator" Strategy: An aggressive approach for the Common Pool Resource Game.
    This strategy prioritizes maximizing immediate individual gain by defecting by default.
    It only cooperates as a last resort when the stock level becomes critically low,
    threatening complete depletion and thus future exploitation. It is aggressive
    in the first and last rounds, and does not engage in trust-building.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with the game description.

        Args:
            game_description: An object containing game parameters like n_players,
                              n_rounds, and capacity.
        """
        self.game_description = game_description
        self.survival_threshold = self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: An object containing the current state of the game, including
                   the current round number and the current stock level.
            history: An object containing the history of actions and payoffs for
                     all players. It's None for the first round.

        Returns:
            The chosen action: Action.C for Cooperate, Action.D for Defect.
        """
        current_stock = state.current_stock
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round == total_rounds:
            return Action.D
        if current_stock <= self.survival_threshold:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_6(BaseStrategy):
    """
    Aggressive Strategy: "The Predatory Growth Maximizer"

    This strategy prioritizes immediate, high individual payoffs by defaulting to
    Defect (D). It only cooperates (C) under specific defensive conditions:
    either when the stock is critically low and immediate collapse is a risk,
    or in the last round to maximize final gains. It aims to exploit the common
    pool aggressively while maintaining a minimal level of self-preservation
    to avoid immediate self-defeating collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_divergence = 0.1
        self.threshold_cooperate_risk = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if current_stock <= 0:
            pass
        stock_ratio = current_stock / self.capacity
        if stock_ratio < self.threshold_divergence:
            return Action.D
        elif stock_ratio < self.threshold_cooperate_risk:
            return Action.D
        elif current_stock >= 2 * self.n:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_7(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game.
    This strategy aims to maximize individual payoff by exploiting the resource
    when it's abundant and adapting to opponent behavior. It defaults to defecting
    unless the stock is critically low and opponents are cooperating, in which
    case it cooperates temporarily to allow for regeneration.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.r = game_description.n_rounds
        self.avg_individual_consumption_history = []
        self.consumption_history_for_avg = []

    def _calculate_avg_individual_consumption(self, state: CommonPoolState, history: PlayerHistory) -> float:
        """Calculates the average individual consumption for the previous round."""
        if history.round_number == 0:
            return 0.0
        prev_stock = self.capacity
        if len(history.my_actions) > 0:
            pass
        if history.round_number == 0:
            return 0.0
        if not hasattr(self, 'stock_history'):
            self.stock_history = [self.capacity]
        current_round_num = state.round_number
        prev_round_num = current_round_num - 1
        if prev_round_num < 0:
            return 0.0
        stock_prev_round = self.stock_history[prev_round_num]
        total_consumption_prev_round = 0.0
        for action_bool in history.my_actions[prev_round_num]:
            if action_bool:
                total_consumption_prev_round += stock_prev_round / (2 * self.n)
            else:
                total_consumption_prev_round += stock_prev_round / self.n
        for i in range(self.n - 1):
            if history.opponent_actions[prev_round_num, i]:
                total_consumption_prev_round += stock_prev_round / (2 * self.n)
            else:
                total_consumption_prev_round += stock_prev_round / self.n
        aic_prev_round = total_consumption_prev_round / self.n
        return aic_prev_round

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock = state.current_stock
        current_round = state.round_number
        if not hasattr(self, 'stock_history'):
            self.stock_history = [self.capacity]
        if current_round >= len(self.stock_history):
            self.stock_history.append(stock)
        if current_round == self.r - 1:
            return Action.D
        if stock <= 0:
            return Action.C
        payoff_cooperate = stock / (2 * self.n)
        payoff_defect = stock / self.n
        payoff_gain_from_defect = payoff_defect - payoff_cooperate
        avg_aic = 0.0
        if history is not None and history.round_number > 0:
            num_past_rounds_for_aic = min(3, history.round_number)
            aic_sum = 0.0
            for i in range(1, num_past_rounds_for_aic + 1):
                round_to_analyze = history.round_number - i
                stock_at_start_of_round = self.stock_history[round_to_analyze]
                total_consumption_in_round = 0.0
                if round_to_analyze < len(history.my_actions):
                    my_action_bool = history.my_actions[round_to_analyze]
                    if my_action_bool:
                        total_consumption_in_round += stock_at_start_of_round / (2 * self.n)
                    else:
                        total_consumption_in_round += stock_at_start_of_round / self.n
                if round_to_analyze < history.opponent_actions.shape[0]:
                    for player_idx in range(self.n - 1):
                        opponent_action_bool = history.opponent_actions[round_to_analyze, player_idx]
                        if opponent_action_bool:
                            total_consumption_in_round += stock_at_start_of_round / (2 * self.n)
                        else:
                            total_consumption_in_round += stock_at_start_of_round / self.n
                aic_sum += total_consumption_in_round / self.n
            avg_aic = aic_sum / num_past_rounds_for_aic
        else:
            pass
        if current_round == 0:
            return Action.D
        elif stock >= 0.7 * self.capacity:
            return Action.D
        elif 0.3 * self.capacity <= stock < 0.7 * self.capacity:
            min_consumption_per_player = stock / (2 * self.n)
            max_consumption_per_player = stock / self.n
            mid_point_aic_threshold = min_consumption_per_player + 0.5 * (max_consumption_per_player - min_consumption_per_player)
            if avg_aic > mid_point_aic_threshold:
                return Action.D
            else:
                return Action.D
        else:
            min_consumption_per_player = stock / (2 * self.n)
            max_consumption_per_player = stock / self.n
            mid_point_aic_threshold = min_consumption_per_player + 0.5 * (max_consumption_per_player - min_consumption_per_player)
            if avg_aic > mid_point_aic_threshold:
                return Action.D
            else:
                return Action.C

class Strategy_AGGRESSIVE_8(BaseStrategy):
    """
    Aggressive Strategy: "Exploit and Adapt"
    This strategy prioritizes immediate gains by defecting whenever profitable,
    but includes mechanisms to avoid complete stock collapse if it would severely
    harm future payoffs. It adapts based on the current stock level and the
    recent history of cooperation/defection from other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_threshold_high = 0.7 * self.capacity
        self.stock_threshold_low = 0.1 * self.capacity

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        rounds_remaining = self.r - current_round
        if rounds_remaining == 1:
            if current_stock < current_stock / self.n:
                return Action.C
            else:
                return Action.D
        if history is None:
            return Action.D
        last_round_idx = current_round - 1
        stock_before_last_round = self.capacity if last_round_idx == 0 else history.opponent_payoffs[last_round_idx - 1, 0]
        if last_round_idx > 0:
            num_defections_last_round = np.sum(history.opponent_actions[last_round_idx, :])
            total_players_in_last_round = len(history.opponent_actions[last_round_idx, :])
            all_players_payoffs_last_round = np.sum(history.opponent_payoffs[last_round_idx, :]) + history.my_payoffs[last_round_idx]
            total_consumption_last_round = all_players_payoffs_last_round
            default_action = Action.D
            num_defections_last_round = 0
            if history.opponent_actions.size > 0:
                num_defections_last_round = np.sum(history.opponent_actions[last_round_idx, :])
            if current_stock > self.stock_threshold_high:
                if num_defections_last_round > self.n / 2:
                    return Action.C
            if current_stock < self.stock_threshold_low:
                if num_defections_last_round > self.n / 2 and rounds_remaining < 3:
                    return Action.C
            return default_action
        return Action.D

class Strategy_AGGRESSIVE_9(BaseStrategy):
    """
    "The Predator": An aggressive strategy for the Common Pool Resource Game.
    This strategy aims to maximize individual extraction by defaulting to Defect (D).
    Cooperation (C) is a rare defensive maneuver, employed only when the resource
    is critically low or when the potential payoff from Defect is significantly
    reduced by stock depletion. It adapts its aggression threshold based on the
    game phase and the observed defection behavior of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.initial_at_factor = 0.8
        self.late_game_at_reduction_factor = 0.4
        self.defection_backlash_increase_factor = 1.1
        self.min_at = 1.0

    def _calculate_aggression_threshold(self, current_round_number: int, history: PlayerHistory | None) -> float:
        """
        Calculates the dynamic Aggression Threshold (AT) for the current round.
        """
        base_at = self.capacity / self.n * self.initial_at_factor
        at = base_at
        if current_round_number > self.r / 2:
            progress_in_late_game = (current_round_number - self.r / 2) / (self.r / 2)
            at = base_at * (1 - progress_in_late_game * self.late_game_at_reduction_factor)
        if history is not None and current_round_number > 0:
            prev_round_idx = current_round_number - 1
            if prev_round_idx < len(history.opponent_actions):
                num_defect_last_round = np.sum(~history.opponent_actions[prev_round_idx, :])
                if num_defect_last_round > self.n / 2:
                    at *= self.defection_backlash_increase_factor
        return max(at, self.min_at)

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == self.r:
            return Action.D
        if current_stock < self.n:
            return Action.C
        potential_payoff_C = current_stock / (2 * self.n)
        potential_payoff_D = current_stock / self.n
        at = self._calculate_aggression_threshold(current_round_number, history)
        if potential_payoff_D >= at:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_10(BaseStrategy):
    """
    The "Predator" strategy is designed to maximize individual gains by
    aggressively defecting when the common pool resource is abundant. It
    only cooperates defensively when the resource is critically depleted
    to ensure its own survival and future exploitation opportunities.
    It also includes a specific rule for the first round to maximize initial
    extraction and for the last round to maximize final extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.high_stock_threshold = self.game_description.capacity * 0.75
        self.low_stock_threshold = self.game_description.capacity * 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_round_number = state.round_number
        if current_round_number == n_rounds:
            return Action.D
        if current_stock <= 1e-06:
            return Action.C
        if current_stock > self.high_stock_threshold:
            if history is not None and history.round_number > 0:
                if np.all(history.opponent_actions[-1, :]):
                    return Action.C
            return Action.D
        elif current_stock > self.low_stock_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_11(BaseStrategy):
    """
    The Predator strategy: Aggressively defects by default, but cooperates
    when the common pool stock falls below a critical threshold to prevent
    total collapse. It always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if current_stock <= self.critical_stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_12(BaseStrategy):
    """
    The Opportunistic Predator strategy.

    This strategy is designed to exploit the common pool resource game by maximizing
    immediate individual payoffs. It defaults to defecting, aiming for the higher
    consumption rate (stock/n). It only cooperates when the stock level falls
    below a critical, dynamically calculated threshold, to prevent complete depletion
    and ensure some level of survival for future rounds.

    Core Philosophy: "Take what you can, when you can, but don't kill the goose."
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with the game description.

        Args:
            game_description: An object containing game parameters like n_players,
                              n_rounds, and capacity.
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round_number and current_stock.
            history: The history of actions and payoffs for all players. None if it's the first round.

        Returns:
            Action.C for Cooperate, Action.D for Defect.
        """
        current_stock = state.current_stock
        current_round = state.round_number
        if history is None:
            return Action.D
        remaining_rounds = self.r - current_round
        if remaining_rounds == 0:
            return Action.D
        if current_stock <= 0:
            return Action.D
        cooperation_threshold = self.capacity / (2.0 * self.n)
        if current_stock <= cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_13(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    This strategy aims to extract as much as possible from the common pool,
    especially when the stock is high, but includes a "braking mechanism"
    to prevent the resource from being completely depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainability_threshold = self.capacity * 0.3
        self.min_stock_for_action = 1.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if current_stock < self.min_stock_for_action:
            return Action.C
        if current_stock < self.sustainability_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_14(BaseStrategy):
    """
    "High-Yield Raider" Strategy:
    This strategy aims for aggressive, short-term gain by exploiting the common pool
    resource when it's abundant. It only conserves when facing imminent depletion
    that threatens its own survival. It assumes opponents will act in their self-interest
    and is inherently distrustful.

    Decision Logic:
    - First round: Defect (exploit initial abundance).
    - Last round: Defect (maximize final payoff).
    - High Stock (> 70% capacity): Defect (exploit plentiful resource).
    - Medium Stock (30%-70% capacity): Defect (prioritize personal gain, risk-tolerant).
    - Low Stock (< 30% capacity):
        - If stock is very low (<10% capacity): Cooperate to prevent collapse (survival).
        - If stock is between 10%-30% capacity:
            - If previous round's consumption was high (>50% capacity consumed): Cooperate (cautious).
            - Otherwise: Defect (still enough buffer, pursue gain).
    - Near-Zero Stock (< 5% capacity): Cooperate (unless last round) to avoid immediate ruin.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.HIGH_STOCK_THRESHOLD_RATIO = 0.7
        self.MEDIUM_STOCK_LOW_THRESHOLD_RATIO = 0.3
        self.CRITICAL_STOCK_THRESHOLD_RATIO = 0.1
        self.EXTREME_STOCK_THRESHOLD_RATIO = 0.05
        self.HIGH_CONSUMPTION_PREVIOUS_ROUND_RATIO = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = float(state.current_stock)
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if current_stock < self.capacity * self.EXTREME_STOCK_THRESHOLD_RATIO:
            return Action.C
        if current_stock > self.capacity * self.HIGH_STOCK_THRESHOLD_RATIO:
            return Action.D
        if current_stock >= self.capacity * self.MEDIUM_STOCK_LOW_THRESHOLD_RATIO and current_stock <= self.capacity * self.HIGH_STOCK_THRESHOLD_RATIO:
            return Action.D
        if current_stock >= self.capacity * self.CRITICAL_STOCK_THRESHOLD_RATIO and current_stock < self.capacity * self.MEDIUM_STOCK_LOW_THRESHOLD_RATIO:
            total_consumption_previous_round = 0.0
            if history is not None and len(history.my_actions) > 0:
                my_consumption = current_stock / self.n if history.my_actions[-1] == Action.D.value else current_stock / (2 * self.n)
                num_defectors_previous_round = 0
                if history.my_actions[-1] == Action.D.value:
                    num_defectors_previous_round += 1
                num_defectors_previous_round += np.sum(history.opponent_actions[-1, :] == Action.D.value)
                if num_defectors_previous_round > self.n / 2:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        if current_stock < self.capacity * self.CRITICAL_STOCK_THRESHOLD_RATIO:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_15(BaseStrategy):
    """
    Aggressive Exploitation with Collapse Aversion Strategy.

    This strategy aims to maximize individual payoffs by defecting whenever
    the stock level is high, but cooperates to prevent resource collapse when
    the stock level drops below a critical threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.cooperation_low_stock_threshold = self.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.n_rounds:
            return Action.D
        if current_stock <= self.cooperation_low_stock_threshold:
            return Action.C
        if current_stock > self.cooperation_low_stock_threshold:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_16(BaseStrategy):
    """
    Aggressive Exploiter strategy for the Common Pool Resource Game.
    Prioritizes maximizing individual gain by defecting when stock is high,
    but cooperates reactively when the stock is critically low or opponents
    are depleting it unsustainably. Defecting is the default action unless
    specific conditions trigger cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_threshold_factor = 0.25
        self.danger_zone_multiplier = 1.2
        self.smoothing_factor = 0.3
        self.sustainable_consumption_rate = 0.0
        self.average_per_player_consumption_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if history is None:
            self.sustainable_consumption_rate = self.capacity / (2.0 * self.n_players)
            self.average_per_player_consumption_history = []
            defection_threshold = self.capacity * self.defection_threshold_factor
            if current_stock > defection_threshold:
                return Action.D
            else:
                return Action.C
        if round_number == 1:
            prev_total_consumption = np.sum(history.my_actions[:round_number]) + np.sum(history.opponent_actions[:round_number, :])
            if self.n_players > 0:
                current_round_avg_consumption = prev_total_consumption / self.n_players
            else:
                current_round_avg_consumption = 0.0
            self.average_per_player_consumption_history.append(current_round_avg_consumption)
            self.sustainable_consumption_rate = self.smoothing_factor * current_round_avg_consumption + (1 - self.smoothing_factor) * self.sustainable_consumption_rate
        elif round_number > 1:
            prev_total_consumption = np.sum(history.my_actions[round_number - 1]) + np.sum(history.opponent_actions[round_number - 1, :])
            if self.n_players > 0:
                current_round_avg_consumption = prev_total_consumption / self.n_players
            else:
                current_round_avg_consumption = 0.0
            self.average_per_player_consumption_history.append(current_round_avg_consumption)
            self.sustainable_consumption_rate = self.smoothing_factor * current_round_avg_consumption + (1 - self.smoothing_factor) * self.sustainable_consumption_rate
        if round_number == self.n_rounds - 1:
            return Action.D
        if current_stock <= 0:
            return Action.C
        defection_threshold = self.capacity * self.defection_threshold_factor
        if not self.average_per_player_consumption_history:
            if self.sustainable_consumption_rate > 0:
                danger_zone_threshold = self.sustainable_consumption_rate * self.danger_zone_multiplier
            else:
                danger_zone_threshold = self.capacity / (2.0 * self.n_players) * self.danger_zone_multiplier
        else:
            danger_zone_threshold = self.sustainable_consumption_rate * self.danger_zone_multiplier
        observed_avg_consumption = 0
        if self.average_per_player_consumption_history:
            observed_avg_consumption = self.average_per_player_consumption_history[-1]
        if current_stock > defection_threshold and observed_avg_consumption <= danger_zone_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_17(BaseStrategy):
    """
    "Harvest Maximizer" Strategy: Aggressively extracts resources, defecting by default
    unless the stock is critically low and cooperation is necessary for minimal survival.
    Prioritizes immediate gain, especially in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.AGGRESSION_FACTOR = 0.75
        self.DEPLETION_WARNING_FACTOR = 0.25
        self.MINIMAL_SURVIVAL_FACTOR = 0.05

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round = state.round_number
        high_stock_threshold = capacity * self.AGGRESSION_FACTOR
        depletion_warning_threshold = capacity * self.DEPLETION_WARNING_FACTOR
        minimal_survival_threshold = capacity * self.MINIMAL_SURVIVAL_FACTOR
        if current_round == r:
            return Action.D
        if current_stock <= 0:
            return Action.D
        if current_stock > high_stock_threshold:
            return Action.D
        elif current_stock > depletion_warning_threshold:
            return Action.D
        elif current_stock > minimal_survival_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_18(BaseStrategy):
    """
    Aggressive Resource Maximizer (ARM) Strategy.

    This strategy aims to maximize immediate gains by defecting when the resource
    stock is high and cooperating only when the stock falls below a critical
    depletion threshold or in the final round. It's designed to exploit the
    resource aggressively while having a basic self-preservation mechanism.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.depletion_threshold = 0.2
        self.ACTION_D = False
        self.ACTION_C = True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.r:
            return Action.D
        if current_stock < self.n:
            return Action.D
            return Action.D
        if current_stock < self.n:
            return Action.C
        if history is None:
            return Action.D
        critical_stock_level = self.capacity * self.depletion_threshold
        if current_stock > critical_stock_level:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_19(BaseStrategy):
    """
    Aggressive Strategy: "Exploit and Recover"

    This strategy aims to maximize immediate individual payoff by defaulting to defection,
    but incorporates adaptive mechanisms to prevent catastrophic resource depletion.
    It adjusts its defection threshold based on the current stock level, the number of
    remaining rounds, and a simplified heuristic analysis of past resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.initial_stock = game_description.capacity
        self.k_history = 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_num = state.round_number
        if history is None:
            base_threshold = max(self.capacity / 4.0, self.initial_stock / 4.0)
            rounds_factor = 1.0 + (self.r - current_round_num) / self.r * 0.5
            defection_threshold = base_threshold * 1.0 * rounds_factor
            defection_threshold = max(defection_threshold, self.capacity * 0.1)
            if current_stock > defection_threshold:
                return Action.D
            else:
                return Action.C
        history_factor = 1.0
        num_completed_rounds = history.round_number
        if num_completed_rounds > 0:
            rounds_to_consider = min(num_completed_rounds, self.k_history)
            my_actions_recent = history.my_actions[-rounds_to_consider:]
            opponent_actions_recent = history.opponent_actions[-rounds_to_consider:, :]
            my_defection_rate_recent = 1.0 - np.mean(my_actions_recent)
            if current_stock < self.capacity * 0.5 and my_defection_rate_recent > 0.5:
                history_factor = 0.7
            elif current_stock > self.capacity * 0.7 and my_defection_rate_recent < 0.5:
                history_factor = 1.3
            else:
                history_factor = 1.0
        remaining_rounds = self.r - current_round_num
        rounds_factor = 1.0 + remaining_rounds / self.r * 0.5
        rounds_factor = 1.0 + (1.0 - remaining_rounds / self.r) * 0.5
        base_threshold = max(self.capacity / 4.0, self.initial_stock / 4.0)
        defection_threshold = base_threshold * history_factor * rounds_factor
        defection_threshold = max(defection_threshold, self.capacity * 0.1)
        if current_stock < self.capacity * 0.1:
            return Action.C
        if current_stock > defection_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_20(BaseStrategy):
    """
    Aggressive, Adaptive, and Robust Strategy for the Common Pool Resource Game.

    This strategy prioritizes immediate gains by defaulting to defecting.
    It cooperates only when the common pool stock drops below a dynamic threshold,
    aiming to ensure future round viability. The threshold is adaptively adjusted
    based on stock levels, becoming more aggressive when the stock is healthy
    and more cautious when it is depleted. The strategy always defects in the
    final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_factor_f = 0.4
        self.min_f = 0.2
        self.max_f = 0.6
        self.stock_drop_threshold_percentage = 0.3
        self.high_stock_threshold_percentage = 0.7
        self.sustained_high_stock_rounds_needed = 3
        self.previous_stock_at_start_of_round = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_stock <= 0:
            return Action.C
        if current_round_number == self.n_rounds - 1:
            return Action.D
        cooperation_trigger_level = self.capacity * self.cooperation_factor_f
        if current_stock <= cooperation_trigger_level:
            return Action.C
        else:
            return Action.D

    def _update_strategy_variables(self, state: CommonPoolState, history: PlayerHistory):
        """
        Internal method to adapt cooperation_factor_f based on past round outcomes.
        This is called after the decision for the current round has been made and
        the game state (stock) has been updated for the *next* round.
        """
        current_stock_start_of_round = state.current_stock
        current_round_number = state.round_number
        if history.round_number >= self.sustained_high_stock_rounds_needed:
            all_high = True
            for i in range(1, self.sustained_high_stock_rounds_needed + 1):
                if current_stock_start_of_round > self.capacity * self.high_stock_threshold_percentage and self.previous_stock_at_start_of_round > self.capacity * self.high_stock_threshold_percentage:
                    self.cooperation_factor_f = max(self.min_f, self.cooperation_factor_f - 0.02)
        if current_stock_start_of_round <= self.capacity * self.cooperation_factor_f:
            self.cooperation_factor_f = min(self.max_f, self.cooperation_factor_f + 0.03)
        stock_change_last_round = current_stock_start_of_round - self.previous_stock_at_start_of_round
        if stock_change_last_round < -self.capacity * self.stock_drop_threshold_percentage:
            self.cooperation_factor_f = min(self.max_f, self.cooperation_factor_f + 0.03)
        self.cooperation_factor_f = max(self.min_f, min(self.max_f, self.cooperation_factor_f))
        self.previous_stock_at_start_of_round = current_stock_start_of_round

    def after_round(self, state: CommonPoolState, history: PlayerHistory):
        """
        Called by the environment after each round. Use this to update strategy parameters.
        """
        if history.round_number == 0:
            self._update_strategy_variables(state, history)
        elif history.round_number < self.n_rounds:
            self._update_strategy_variables(state, history)

class Strategy_AGGRESSIVE_21(BaseStrategy):
    """
    The "Predatory Opportunist" strategy. This strategy aims to maximize individual
    gain by defaulting to defection, exploiting periods of high stock and
    cooperation from others. It employs a calculated risk assessment to avoid
    complete resource depletion, especially when the stock is critically low.
    Cooperation is primarily a survival tactic to enable future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold_factor = 1.0 / (2.0 * self.n)
        self.abundant_stock_threshold = self.capacity
        self.high_cooperation_threshold_count = self.n - 1
        self.marginal_gain_threshold_factor = 0.25

    def _get_action_from_bool(self, action_bool: bool) -> Action:
        """Converts boolean representation to Action enum."""
        return Action.C if action_bool else Action.D

    def _get_bool_from_action(self, action: Action) -> bool:
        """Converts Action enum to boolean representation."""
        return action == Action.C

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.r:
            return Action.D
        if history is None:
            return Action.D
        my_actions_last_round = history.my_actions[-1]
        opponent_actions_last_round = history.opponent_actions[-1, :]
        num_cooperators_last_round = int(np.sum(opponent_actions_last_round)) + (1 if my_actions_last_round else 0)
        critical_stock_level = self.critical_stock_threshold_factor * self.capacity
        proposed_action = Action.D
        if current_stock <= critical_stock_level:
            return Action.C
        if num_cooperators_last_round >= self.high_cooperation_threshold_count and current_stock > critical_stock_level * 2:
            return Action.D
        if current_stock >= self.abundant_stock_threshold:
            return Action.D
        payoff_cooperate = current_stock / (2.0 * self.n)
        payoff_defect = current_stock / self.n
        consumption_defect = payoff_defect
        stock_after_consumption_defect = current_stock - consumption_defect
        if stock_after_consumption_defect < 0:
            stock_after_consumption_defect = 0.0
        growth_defect = 2.0 * stock_after_consumption_defect * (1.0 - stock_after_consumption_defect / self.capacity)
        new_stock_after_defect = min(stock_after_consumption_defect + growth_defect, self.capacity)
        consumption_cooperate = payoff_cooperate
        stock_after_consumption_cooperate = current_stock - consumption_cooperate
        if stock_after_consumption_cooperate < 0:
            stock_after_consumption_cooperate = 0.0
        growth_cooperate = 2.0 * stock_after_consumption_cooperate * (1.0 - stock_after_consumption_cooperate / self.capacity)
        new_stock_after_cooperate = min(stock_after_consumption_cooperate + growth_cooperate, self.capacity)
        marginal_gain = payoff_defect - payoff_cooperate
        if marginal_gain < self.marginal_gain_threshold_factor * (current_stock / self.n) and new_stock_after_defect < new_stock_after_cooperate - critical_stock_level * 1.5:
            return Action.C
        return proposed_action

class Strategy_AGGRESSIVE_22(BaseStrategy):
    """
    Strategy: "Exploit and Rebuild (EaR)"

    This strategy is an aggressive yet adaptive approach for the Common Pool Resource Game.
    It prioritizes immediate gains by defecting by default, but incorporates mechanisms
    to prevent resource collapse and to act conservatively when the marginal benefit
    of defecting is low and the stock is not at its peak. It does not rely on explicit
    coordination or trust, reacting primarily to the common pool's state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_depletion_threshold_ratio = 0.2
        self.conservative_cooperation_stock_ratio = 0.75
        self.gain_threshold_ratio = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: Information about past rounds, if available.

        Returns:
            Action: The chosen action for the current round (Action.C or Action.D).
        """
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.r:
            return Action.D
        payoff_cooperate = current_stock / (2.0 * self.n)
        payoff_defect = current_stock / self.n
        gain_from_defecting = payoff_defect - payoff_cooperate
        critical_depletion_threshold = self.critical_depletion_threshold_ratio * self.capacity
        conservative_cooperation_stock_threshold = self.conservative_cooperation_stock_ratio * self.capacity
        if current_stock < critical_depletion_threshold:
            return Action.C
        if gain_from_defecting < self.gain_threshold_ratio * payoff_defect and current_stock < conservative_cooperation_stock_threshold:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_23(BaseStrategy):
    """
    The Dominator strategy. This aggressive strategy aims to maximize immediate gains
    by primarily defecting. It employs a heuristic-based approach to adjust its
    defection/cooperation behavior based on the current stock level and the
    number of rounds remaining.

    - High stock: Always defects to maximize immediate gain.
    - Medium stock: Mostly defects, with a small probability of cooperating to avoid
      predictability.
    - Low stock:
        - In early/mid rounds: Defects aggressively to deplete the resource,
          punishing conservation attempts by others.
        - In late rounds (last two): Cooperates to ensure survival and extract
          any remaining resource.
    - Zero stock: Cooperates to do nothing and avoid potential issues.

    The strategy does not track individual opponent actions and reacts solely
    based on the global common pool state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.H_THRESHOLD_RATIO = 0.8
        self.M_THRESHOLD_RATIO = 0.4
        self.L_THRESHOLD_RATIO = 0.2
        self.PROB_COOPERATE_MEDIUM_STOCK = 0.1
        self.h_threshold = self.game_description.capacity * self.H_THRESHOLD_RATIO
        self.m_threshold = self.game_description.capacity * self.M_THRESHOLD_RATIO
        self.l_threshold = self.game_description.capacity * self.L_THRESHOLD_RATIO

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        if current_stock <= 0:
            return Action.C
        if current_stock > self.h_threshold:
            return Action.D
        elif current_stock > self.m_threshold:
            if random.random() < self.PROB_COOPERATE_MEDIUM_STOCK:
                return Action.C
            else:
                return Action.D
        elif current_round >= n_rounds - 1:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_24(BaseStrategy):
    """
    Aggressive Exploitation with Resource Awareness (AERA) strategy.
    This strategy prioritizes maximizing immediate gains by defecting
    when the resource stock is high, but conserves when the stock is low
    to prevent collapse. It's aggressive by default, cooperating only
    when necessary for survival.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.abundant_threshold = 0.8 * self.capacity
        self.exploitable_threshold = 0.6 * self.capacity
        self.cautionary_threshold = 0.3 * self.capacity
        self.critical_stock_for_cooperate = self.capacity / self.n

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if history is None or current_round == 0:
            return Action.D
        if current_round == self.r - 1:
            return Action.D
        if current_stock > self.abundant_threshold:
            return Action.D
        elif current_stock > self.exploitable_threshold:
            return Action.D
        elif current_stock > self.cautionary_threshold:
            if current_stock > self.n:
                if current_stock > self.n:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        else:
            return Action.C

class Strategy_AGGRESSIVE_25(BaseStrategy):
    """
    The "Predator" strategy: Aggressively extracts resources by defaulting to Defect (D),
    unless the stock is critically low, in which case it Cooperates (C) as a last resort
    to prevent immediate, absolute depletion. It prioritizes immediate gain and assumes
    other players are also self-interested.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.survival_threshold = self.n

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if history is None:
            return Action.D
        if current_round == self.r:
            return Action.D
        if current_stock <= self.survival_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_26(BaseStrategy):
    """
    The "Predator" strategy. This strategy aims to maximize individual
    payoff by defecting as much as possible while using a survival
    threshold to prevent complete stock collapse.

    It defects by default to exploit higher immediate payoffs, but switches
    to cooperating if the stock level falls below a critical threshold
    (capacity / 2) to ensure there are future opportunities for extraction.
    In the last round, it always defects to maximize final round payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.survival_threshold = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if current_stock <= self.survival_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_27(BaseStrategy):
    """
    Maximizer's Gambit: An aggressive strategy that defaults to defecting to maximize
    immediate individual gain. It only cooperates when the common pool stock
    falls below a critical threshold, indicating an imminent threat of collapse.
    This conditional cooperation is a defensive measure to ensure future
    payoff possibilities, reverting to defection once the stock recovers.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_threshold = 0.2 * game_description.capacity
        self.n = game_description.n_players
        self.r = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == self.r:
            return Action.D
        if history is None:
            return Action.D
        if current_stock < self.critical_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_28(BaseStrategy):
    """
    "The Predator's Feast" strategy: Aggressively exploits the common pool resource
    by defaulting to Defect, but strategically Cooperates when the stock is critically low
    to prevent complete collapse and enable future exploitation. It prioritizes maximum
    short-term gain while maintaining a calculated degree of self-preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.ABUNDANT_THRESHOLD = 0.75 * self.capacity
        self.CRITICAL_THRESHOLD = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: A record of past actions and payoffs for all players.
                     None for the first round.

        Returns:
            Action: The chosen action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if current_stock < current_stock / self.n * 0.6 and current_stock > 0:
            return Action.C
        if current_stock > self.ABUNDANT_THRESHOLD:
            return Action.D
        elif current_stock >= self.CRITICAL_THRESHOLD:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_29(BaseStrategy):
    """
    The "Aggressive Exploiter" strategy aims to maximize individual payoff by
    defaulting to Defect, exploiting the higher immediate reward. It only
    switches to Cooperate when the stock level drops to a critical threshold,
    acting as a self-preservation mechanism to prevent total collapse. In the
    final round, it unconditionally Defects to secure the maximum possible
    final payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold = self.capacity * (1.0 - 1.0 / (2.0 * self.n))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == self.r:
            return Action.D
        if current_stock <= self.cooperation_threshold:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_30(BaseStrategy):
    """
    The "Predator" strategy.

    This strategy is aggressive, prioritizing immediate individual gains by
    defaulting to Defect. It only cooperates when the common pool stock is
    critically low to prevent immediate resource depletion and ensure its own
    future ability to extract value. It defects in the last round regardless
    of stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold_ratio = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_number = state.round_number
        critical_threshold = capacity * self.critical_stock_threshold_ratio
        if history is None:
            return Action.D
        if current_round_number == r:
            return Action.D
        if current_stock <= critical_threshold:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_31(BaseStrategy):
    """
    The Predator strategy is designed to maximize individual gain by exploiting the common pool resource
    while remaining adaptable. It prioritizes aggressive extraction when the stock is high but conserves
    when the stock is dangerously depleted to ensure continued participation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.HIGH_STOCK_THRESHOLD = self.capacity * 0.75
        self.MEDIUM_HIGH_STOCK_THRESHOLD = self.capacity * 0.4
        self.LOW_STOCK_THRESHOLD = self.capacity * 0.4
        self.CRITICAL_LOW_STOCK_THRESHOLD = self.capacity * 0.1
        self.HIGH_CONSUMPTION_PREVIOUS_ROUND = self.capacity * 0.5
        self.MODERATE_CONSUMPTION_PREVIOUS_ROUND = self.capacity * 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if history is None:
            return Action.D
        if current_round == self.r:
            return Action.D
        if current_round == self.r - 1:
            if current_stock >= self.MODERATE_CONSUMPTION_PREVIOUS_ROUND:
                return Action.D
            else:
                return Action.C
        previous_total_consumption = 0.0
        if history.round_number > 0:
            my_consumption = self.capacity / (2 * self.n) if history.my_actions[-1] else self.capacity / self.n
            opponent_consumptions = []
            for i in range(self.n - 1):
                stock_for_prev_consumption_calc = self.stock_at_start_of_previous_round
                my_last_action_was_C = history.my_actions[-1]
                my_consumption_last_round = stock_for_prev_consumption_calc / (2 * self.n) if my_last_action_was_C else stock_for_prev_consumption_calc / self.n
                opponent_consumptions_last_round = 0.0
                for i in range(self.n - 1):
                    opponent_last_action_was_C = history.opponent_actions[-1, i]
                    opponent_consumption = stock_for_prev_consumption_calc / (2 * self.n) if opponent_last_action_was_C else stock_for_prev_consumption_calc / self.n
                    opponent_consumptions_last_round += opponent_consumption
                previous_total_consumption = my_consumption_last_round + opponent_consumptions_last_round
        if current_stock >= self.HIGH_STOCK_THRESHOLD:
            return Action.D
        if current_round > 0 and current_stock >= self.MEDIUM_HIGH_STOCK_THRESHOLD and (previous_total_consumption < self.MODERATE_CONSUMPTION_PREVIOUS_ROUND):
            return Action.D
        if current_stock < self.LOW_STOCK_THRESHOLD:
            return Action.C
        if current_round > 0 and previous_total_consumption > self.HIGH_CONSUMPTION_PREVIOUS_ROUND:
            return Action.C
        if current_stock < self.CRITICAL_LOW_STOCK_THRESHOLD:
            return Action.C
        return Action.D

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.HIGH_STOCK_THRESHOLD = self.capacity * 0.75
        self.MEDIUM_HIGH_STOCK_THRESHOLD = self.capacity * 0.4
        self.LOW_STOCK_THRESHOLD = self.capacity * 0.4
        self.CRITICAL_LOW_STOCK_THRESHOLD = self.capacity * 0.1
        self.HIGH_CONSUMPTION_PREVIOUS_ROUND = self.capacity * 0.5
        self.MODERATE_CONSUMPTION_PREVIOUS_ROUND = self.capacity * 0.2
        self.stock_at_start_of_previous_round = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if history is None:
            self.stock_at_start_of_previous_round = current_stock
            return Action.D
        previous_total_consumption = 0.0
        stock_for_prev_consumption_calc = self.stock_at_start_of_previous_round
        my_last_action_was_C = history.my_actions[-1]
        my_consumption_last_round = stock_for_prev_consumption_calc / (2 * self.n) if my_last_action_was_C else stock_for_prev_consumption_calc / self.n
        opponent_consumptions_last_round = 0.0
        for i in range(self.n - 1):
            opponent_last_action_was_C = history.opponent_actions[-1, i]
            opponent_consumption = stock_for_prev_consumption_calc / (2 * self.n) if opponent_last_action_was_C else stock_for_prev_consumption_calc / self.n
            opponent_consumptions_last_round += opponent_consumption
        previous_total_consumption = my_consumption_last_round + opponent_consumptions_last_round
        if current_round == self.r:
            self.stock_at_start_of_previous_round = current_stock
            return Action.D
        if current_round == self.r - 1:
            action = Action.D if current_stock >= self.MODERATE_CONSUMPTION_PREVIOUS_ROUND else Action.C
            self.stock_at_start_of_previous_round = current_stock
            return action
        if current_stock >= self.HIGH_STOCK_THRESHOLD:
            self.stock_at_start_of_previous_round = current_stock
            return Action.D
        if current_stock >= self.MEDIUM_HIGH_STOCK_THRESHOLD and previous_total_consumption < self.MODERATE_CONSUMPTION_PREVIOUS_ROUND:
            self.stock_at_start_of_previous_round = current_stock
            return Action.D
        if current_stock < self.LOW_STOCK_THRESHOLD:
            self.stock_at_start_of_previous_round = current_stock
            return Action.C
        if previous_total_consumption > self.HIGH_CONSUMPTION_PREVIOUS_ROUND:
            self.stock_at_start_of_previous_round = current_stock
            return Action.C
        if current_stock < self.CRITICAL_LOW_STOCK_THRESHOLD:
            self.stock_at_start_of_previous_round = current_stock
            return Action.C
        self.stock_at_start_of_previous_round = current_stock
        return Action.D

class Strategy_AGGRESSIVE_32(BaseStrategy):
    """
    The Predator Strategy: Aggressively exploits abundant resources,
    conserves when the stock is low, and always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_defect = 0.75
        self.epsilon = 1e-06

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_round == total_rounds:
            return Action.D
        if current_stock < self.epsilon:
            return Action.C
        if current_stock > capacity * self.threshold_defect:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_33(BaseStrategy):
    """
    Aggressive Exploitation with Measured Restraint.

    This strategy defaults to Defect (D) to maximize immediate individual gain.
    Cooperation (C) is considered only in very specific, rare scenarios where
    the resource is exceptionally abundant AND previous rounds indicated low
    collective consumption, suggesting others might also be cooperating or
    holding back. Even in such cases, the aggressive default of 'D' is often
    maintained due to the strategy's core focus on exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num = state.round_number
        if history is None:
            return Action.D
        if round_num == self.r:
            return Action.D
        low_stock_threshold = 0.2 * self.capacity
        if current_stock <= low_stock_threshold:
            return Action.D
        previous_round_stock_start = self.capacity if round_num == 1 else history.my_payoffs[round_num - 2] + history.opponent_payoffs[round_num - 2, :].sum()
        if round_num > 1:
            my_action_prev = Action.C if history.my_actions[round_num - 2] else Action.D
            opponent_actions_prev = [Action.C if hist else Action.D for hist in history.opponent_actions[round_num - 2, :]]
            total_consumption_prev = 0
            if my_action_prev == Action.C:
                total_consumption_prev += current_stock / (2 * self.n)
            else:
                total_consumption_prev += current_stock / self.n
            high_stock_threshold = 0.8 * self.capacity
            if current_stock > high_stock_threshold:
                return Action.D
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_34(BaseStrategy):
    """
    The "Opportunistic Grazer" strategy for the Common Pool Resource Game.
    This strategy is aggressive, prioritizing immediate higher payoffs from
    Defection when the common pool stock is high and there are enough rounds
    remaining. It cooperates only when the stock is critically low or
    approaching depletion to avoid complete collapse and guarantee some
    future payoff. It aims to exploit abundance while hedging against
    catastrophic depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.low_stock_threshold_ratio = 0.2
        self.stock_threshold_for_defect_ratio = 0.7
        self.safety_margin_rounds_ratio = 0.2
        self.defect_prob_high_stock = 0.95
        self.defect_prob_moderate_stock = 0.8
        self.defect_prob_near_end_high_stock = 0.7
        self.defect_prob_low_to_moderate_stock = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        remaining_rounds = r - current_round
        low_stock_threshold = capacity * self.low_stock_threshold_ratio
        stock_threshold_for_defect = capacity * self.stock_threshold_for_defect_ratio
        safety_margin_rounds = math.floor(r * self.safety_margin_rounds_ratio)
        if remaining_rounds == 0:
            return Action.D
        if current_stock <= low_stock_threshold:
            return Action.C
        if remaining_rounds <= safety_margin_rounds:
            if current_stock > stock_threshold_for_defect:
                if random.random() < self.defect_prob_near_end_high_stock:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        if current_stock > stock_threshold_for_defect:
            if random.random() < self.defect_prob_high_stock:
                return Action.D
            else:
                return Action.C
        elif current_stock > low_stock_threshold:
            if random.random() < self.defect_prob_moderate_stock:
                return Action.D
            else:
                return Action.C
        elif random.random() < self.defect_prob_low_to_moderate_stock:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_35(BaseStrategy):
    """
    Aggressive Predator strategy. This strategy aims to maximize individual player gains
    by leveraging the higher immediate payoff of defecting, while incorporating safeguards
    to prevent the complete collapse of the common pool resource. It exploits the temptation
    to defect inherent in the game's structure, cooperating only when the resource is
    critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.t_critical_factor = 1.0 / 3.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round = state.round_number
        t_critical = capacity * self.t_critical_factor
        if current_round == r:
            return Action.D
        if current_stock <= 0:
            return Action.C
        if history is None:
            return Action.D
        if current_stock < t_critical:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_36(BaseStrategy):
    """
    "Profit Maximization with Stock Buffer" strategy for the Common Pool Resource Game.

    This strategy aims to maximize individual payoffs by defecting aggressively when
    the stock is high, but cooperates to protect the stock when it is low to ensure
    future extraction opportunities.

    Decision logic:
    - Always defects in the first round.
    - Defects if the current stock is above 70% of capacity (unless it's the last round).
    - Cooperates if the current stock is at or below 70% of capacity (stock buffer).
    - In the last round, defects only if the stock is above 90% of capacity; otherwise cooperates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.high_stock_threshold = self.capacity * 0.7
        self.very_high_stock_threshold = self.capacity * 0.9

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if history is None or current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            if current_stock > self.very_high_stock_threshold:
                return Action.D
            else:
                return Action.C
        if current_stock > self.high_stock_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_37(BaseStrategy):
    """
    The "Predatory Accelerator" strategy. This strategy aggressively defects
    to maximize individual gain, only cooperating when the stock is critically low
    to ensure survival of the resource for potential future exploitation.
    It always defects in the last round to maximize final payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing the game's parameters (n_players, n_rounds, capacity).
        """
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_defect = self.capacity * 0.85
        self.threshold_cooperate = self.capacity * 0.15
        self.epsilon = 1e-06

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game (round_number, current_stock).
            history: A PlayerHistory object containing past actions and payoffs.
                     None if it's the first round.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.n_rounds:
            return Action.D
        if current_stock < self.epsilon:
            return Action.C
        if current_stock > self.threshold_defect:
            return Action.D
        elif current_stock <= self.threshold_cooperate:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_38(BaseStrategy):
    """
    Aggressive Strategy: "Exploit and Recover"

    This strategy prioritizes immediate high payoffs through defection.
    It switches to cooperation only when the stock level drops critically low
    to prevent complete resource collapse and enable future exploitation.
    It always defects in the last round to maximize final individual payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.
        """
        self.game_description = game_description
        self.critical_threshold = self.game_description.n_players
        self.default_action = Action.D
        self.fallback_action = Action.C

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs for all players.
                     If None, it's the first round.

        Returns:
            The action to take (Action.C or Action.D).
        """
        current_stock = state.current_stock
        current_round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round_number == total_rounds:
            return self.default_action
        action_to_take = self.default_action
        if current_stock <= self.critical_threshold:
            action_to_take = self.fallback_action
        return action_to_take

class Strategy_AGGRESSIVE_39(BaseStrategy):
    """
    The "Predator" strategy. This strategy aggressively defects when the stock
    is abundant and switches to cooperation only when the stock is critically low
    to ensure survival. It prioritizes immediate individual gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_cooperate_threshold_ratio = 0.2
        self.stock_defect_threshold_ratio = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round = state.round_number
        stock_cooperate_threshold = capacity * self.stock_cooperate_threshold_ratio
        stock_defect_threshold = capacity * self.stock_defect_threshold_ratio
        if history is None:
            return Action.D
        if current_round == self.game_description.n_rounds:
            return Action.D
        if current_stock <= stock_cooperate_threshold:
            return Action.C
        elif current_stock > stock_defect_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_40(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "The Opportunistic Predator"

    This strategy aims to maximize individual payoff by defaulting to Defection (D),
    which offers a higher immediate reward. It only switches to Cooperation (C)
    when the common pool stock level drops to a critical threshold, defined as
    `capacity / n_players`. This threshold is chosen to prevent immediate resource
    collapse if all players were to defect. The strategy also overrides the
    threshold in the last round, always choosing Defection to maximize final gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.danger_threshold = self.capacity / self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == self.n_rounds:
            return Action.D
        if current_stock > self.danger_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_41(BaseStrategy):
    """
    Aggressive strategy "Exploiter's Edge".
    This strategy aims to maximize individual player payoff by aggressively defecting
    when the stock is high, while attempting to manage stock depletion to avoid
    immediate collapse. It adapts its exploitation threshold based on recent stock
    performance.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.exploitation_factor = 0.7
        self.exploitation_factor_max = 0.85
        self.exploitation_factor_min = 0.4
        self.exploitation_factor_increase_step = 0.02
        self.exploitation_factor_decrease_step = 0.03
        self.high_stock_threshold_ratio = 0.8
        self.low_stock_threshold_ratio = 0.5
        self.sustained_rounds_for_adaptation = 3
        self.rounds_since_high_stock_performance = 0
        self.rounds_since_low_stock_performance = 0
        self.last_stock_after_regeneration = self.capacity

    def _get_exploitation_threshold(self) -> float:
        """Calculates the current stock level threshold for defection."""
        return self.capacity * self.exploitation_factor

    def _update_exploitation_factor(self, current_stock_after_regeneration: float):
        """
        Adapts the exploitation_factor based on the recent stock performance.
        """
        is_high_performance = current_stock_after_regeneration > self.capacity * self.high_stock_threshold_ratio
        is_low_performance = current_stock_after_regeneration < self.capacity * self.low_stock_threshold_ratio
        if is_high_performance:
            self.rounds_since_high_stock_performance += 1
            self.rounds_since_low_stock_performance = 0
            if self.rounds_since_high_stock_performance >= self.sustained_rounds_for_adaptation:
                self.exploitation_factor = min(self.exploitation_factor_max, self.exploitation_factor + self.exploitation_factor_increase_step)
                self.rounds_since_high_stock_performance = 0
        elif is_low_performance:
            self.rounds_since_low_stock_performance += 1
            self.rounds_since_high_stock_performance = 0
            if self.rounds_since_low_stock_performance >= self.sustained_rounds_for_adaptation:
                self.exploitation_factor = max(self.exploitation_factor_min, self.exploitation_factor - self.exploitation_factor_decrease_step)
                self.rounds_since_low_stock_performance = 0
        else:
            self.rounds_since_high_stock_performance = 0
            self.rounds_since_low_stock_performance = 0
        self.exploitation_factor = max(self.exploitation_factor_min, min(self.exploitation_factor_max, self.exploitation_factor))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        min_stock_to_avoid_zero_after_all_defect = float(self.n_players)
        if current_stock <= min_stock_to_avoid_zero_after_all_defect:
            return Action.C
        if round_number == self.n_rounds:
            return Action.D
        if history is None:
            return Action.D
        if self.last_stock_after_regeneration is not None:
            self._update_exploitation_factor(self.last_stock_after_regeneration)
        exploitation_threshold = self._get_exploitation_threshold()
        if current_stock >= exploitation_threshold:
            return Action.D
        else:
            return Action.C

    def _stock_dynamics(self, S: float, actions: list[Action]) -> tuple[float, float]:
        """
        Calculates stock after consumption and after growth.
        Returns (stock_after_consumption, stock_after_regeneration)
        """
        total_consumption = 0.0
        for action in actions:
            if action == Action.C:
                total_consumption += S / (2.0 * self.n_players)
            else:
                total_consumption += S / float(self.n_players)
        S_remaining = S - total_consumption
        S_remaining = max(0.0, S_remaining)
        growth = 2.0 * S_remaining * (1.0 - S_remaining / self.capacity)
        new_stock = S_remaining + growth
        new_stock = min(new_stock, self.capacity)
        return (S_remaining, new_stock)

    def _update_state_and_history_for_adaptation(self, state: CommonPoolState, history: PlayerHistory | None):
        """
        This method is called by the simulation framework AFTER the decision is made
        and the round has been played out. It's crucial for updating the state
        for the *next* round's decision and for the adaptation logic.
        """
        if history is not None:
            self.last_stock_after_regeneration = state.current_stock
        else:
            pass

class Strategy_AGGRESSIVE_42(BaseStrategy):
    """
    Predatory Growth Exploiter Strategy:
    This strategy is inherently aggressive, defaulting to Defect (D) to maximize
    immediate individual payoff. It only switches to Cooperate (C) under specific
    survival-critical conditions or in the final round to maximize its last extraction.

    The core logic is:
    1. Always Defect in the last round to maximize final payoff.
    2. If the stock falls below 25% of capacity, Cooperate to prevent total collapse
       and allow for future regeneration.
    3. Otherwise (stock is healthy and it's not the last round), Defect to maximize
       immediate gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.low_stock_threshold = self.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if history is None:
            return Action.D
        if current_round_number == self.n_rounds:
            return Action.D
        if current_stock <= self.low_stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_43(BaseStrategy):
    """
    Aggressive "Exploit and Survive" Strategy.
    This strategy aims to maximize immediate individual gain by defecting whenever possible.
    It only cooperates to prevent the complete collapse of the common resource when
    the stock level falls below a critical survival threshold, or in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like number of players,
                              number of rounds, and resource capacity.
        """
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.survival_threshold_fraction = 0.3
        self.survival_threshold = self.survival_threshold_fraction * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including the round number and current stock.
            history: A history object containing past actions and payoffs for all players.
                     This is None for the first round.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.r:
            return Action.D
        if current_stock <= self.survival_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_44(BaseStrategy):
    """
    Strategy: "Aggressive Exploiter with Restraint"

    This strategy aims to be aggressive by defecting when the common pool stock
    is high, but incorporates a safety mechanism to prevent total depletion.
    It adapts its decision based on the current stock level relative to capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.ALPHA = 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides whether to Cooperate (C) or Defect (D) based on the current state.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs, or None if it's the first round.

        Returns:
            Action: The action to take (Action.C or Action.D).
        """
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == r:
            return Action.D
        relative_stock = max(0.0, current_stock / capacity)
        base_dt = capacity * relative_stock ** self.ALPHA
        min_dt_safety = float(n)
        DT = max(base_dt, min_dt_safety)
        if current_stock > DT:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_45(BaseStrategy):
    """
    The "Opportunistic Ravager" strategy is designed to maximize individual payoff
    in the Common Pool Resource Game. It defaults to aggressive Defection ('D')
    to secure higher immediate gains, but will strategically switch to Cooperate ('C')
    only when the resource is on the brink of complete collapse, to prevent
    immediate zero payoff and potentially preserve the resource for future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if current_stock > 0:
            stock_after_all_defect_consumption = current_stock - current_stock
            stock_remaining_for_growth_after_all_defect = 0
            growth_from_zero_stock = 2 * stock_remaining_for_growth_after_all_defect * (1 - stock_remaining_for_growth_after_all_defect / self.capacity)
            next_stock_if_all_defect = min(stock_remaining_for_growth_after_all_defect + growth_from_zero_stock, self.capacity)
            if next_stock_if_all_defect == 0:
                payoff_if_i_cooperate = current_stock / (2 * self.n)
                if payoff_if_i_cooperate > 0:
                    return Action.C
        return Action.D

class Strategy_AGGRESSIVE_46(BaseStrategy):
    """
    The "Exploit and Adapt" strategy is an aggressive approach to the Common Pool Resource Game.
    It prioritizes maximizing individual payoff by defaulting to defection (D), which yields a higher
    immediate reward. Cooperation (C) is only employed as a defensive measure when the common stock
    level drops to critically low levels (below 20% of capacity) to prevent total depletion and
    preserve the possibility of future gains. In the last round, it exclusively defects to maximize
    final individual payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.ACTION_C = True
        self.ACTION_D = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == r:
            return Action.D
        cooperation_trigger_low_stock = capacity * 0.2
        if current_stock < cooperation_trigger_low_stock:
            return Action.C
        exploitation_zone_upper_bound = capacity * 0.5
        if current_stock < exploitation_zone_upper_bound:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_47(BaseStrategy):
    """
    Aggressive Stock Depletion (ASD) strategy.

    This strategy prioritizes immediate individual gain by exploiting the common
    resource. It defects when the stock is high or if other players are
    aggressively consuming. It conserves only when the stock is critically low
    to ensure future extraction. It always defects in the first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.explore_threshold_percent = 0.75
        self.conserve_threshold_percent = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == self.r:
            return Action.D
        if current_round_number == 1:
            return Action.D
        explore_threshold = self.capacity * self.explore_threshold_percent
        conserve_threshold = self.capacity * self.conserve_threshold_percent
        if current_stock >= explore_threshold:
            return Action.D
        elif current_stock <= conserve_threshold:
            return Action.C
        else:
            if history is None:
                return Action.D
            last_round_idx = history.round_number - 1
            my_payoff_last_round = history.my_payoffs[last_round_idx]
            other_players_payoffs_last_round = history.opponent_payoffs[last_round_idx, :]
            other_players_total_payoff_last_round = np.sum(other_players_payoffs_last_round)
            if self.n > 1:
                avg_other_payoff = other_players_total_payoff_last_round / (self.n - 1)
                opponent_actions_last_round = history.opponent_actions[last_round_idx, :]
                num_opponent_defect = np.sum(opponent_actions_last_round == Action.D.value)
                if num_opponent_defect > (self.n - 1) / 2:
                    return Action.D
            return Action.C

class Strategy_AGGRESSIVE_48(BaseStrategy):
    """
    The Dominator Strategy: Aggressively exploits the common pool resource
    to maximize individual gain, only cooperating when immediate defection
    by all players would lead to the irreversible collapse of the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        n = self.n_players
        action = Action.D
        if current_stock > 0:
            action = Action.D
        else:
            action = Action.C
        return action

class Strategy_AGGRESSIVE_49(BaseStrategy):
    """
    Aggressive Exploitation Strategy: This strategy aims to maximize individual
    payoffs by defecting whenever the common resource is sufficiently abundant.
    It only switches to cooperation when the stock level falls to a critical
    danger threshold, to prevent immediate collapse and preserve future earning
    potential. The strategy is purely reactive to the stock level and game
    parameters, without relying on communication or coordination.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.high_stock_threshold = 0.75 * self.game_description.capacity
        self.medium_stock_threshold = 0.5 * self.game_description.capacity
        self.danger_stock_threshold = 0.25 * self.game_description.capacity
        self.recovery_stock_threshold = 0.6 * self.game_description.capacity
        self.in_cooperative_mode = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) based on the current
        state of the common resource and the game history.

        Args:
            state: Current state of the common pool (round_number, current_stock).
            history: History of player actions and payoffs. None for the first round.

        Returns:
            The chosen action: Action.C (Cooperate) or Action.D (Defect).
        """
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.game_description.n_rounds:
            if current_stock > 1e-09:
                return Action.D
            else:
                return Action.C
        if history is None:
            return Action.D
        if self.in_cooperative_mode:
            if current_stock >= self.recovery_stock_threshold:
                self.in_cooperative_mode = False
                return Action.D
            else:
                return Action.C
        else:
            if current_stock >= self.medium_stock_threshold:
                return Action.D
            if current_stock >= self.danger_stock_threshold:
                return Action.D
            if current_stock < self.danger_stock_threshold:
                self.in_cooperative_mode = True
                return Action.C
        return Action.C

class Strategy_AGGRESSIVE_50(BaseStrategy):
    """
    The "Opportunistic Depletion" strategy. This strategy aims to maximize
    short-term individual gain by defaulting to Defect (D). However, it
    incorporates a safety mechanism to prevent total resource collapse by
    switching to Cooperate (C) when the common stock falls below a critical
    threshold. It also cooperates in the final round to ensure a guaranteed,
    albeit smaller, payoff and avoid potential zero payoff from complete
    resource depletion by all players defecting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.COLLAPSE_THRESHOLD_FACTOR = 1.0 / 3.0
        self.collapse_threshold = self.capacity * self.COLLAPSE_THRESHOLD_FACTOR

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs for all players up to
                     the previous round. If None, it's the first round.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_stock = float(state.current_stock)
        current_round = state.round_number
        if current_round == self.n_rounds:
            return Action.C
        if current_stock <= self.collapse_threshold:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_51(BaseStrategy):
    """
    Aggressive Exploitation with Adaptive Restraint strategy for the Common Pool Resource Game.
    This strategy aims to maximize individual payoff by defaulting to defection,
    but adapts its threshold for cooperation based on observed resource depletion
    to prevent total collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.current_stock_threshold = 0.8
        self.past_stock_level = float(self.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.r:
            return Action.D
        if current_stock / self.capacity < 0.1:
            return Action.C
        if current_stock / self.capacity > self.current_stock_threshold:
            return Action.D
        else:
            return Action.C

    def update_strategy_state(self, new_stock_level: float, current_round_number: int):
        """
        Updates the internal state of the strategy based on the outcome of the last round.
        This method is called by the game engine after each round.
        """
        if current_round_number > 0 and current_round_number < self.r:
            stock_depletion_ratio = (self.past_stock_level - new_stock_level) / self.capacity
            if stock_depletion_ratio > 0.2:
                adjustment_factor = 0.1
                self.current_stock_threshold = min(1.0, self.current_stock_threshold + stock_depletion_ratio * adjustment_factor)
            elif stock_depletion_ratio < 0.05:
                adjustment_factor = 0.05
                self.current_stock_threshold = max(0.4, self.current_stock_threshold - (0.05 - stock_depletion_ratio) * adjustment_factor)
        self.past_stock_level = new_stock_level

class Strategy_AGGRESSIVE_52(BaseStrategy):
    """
    "The Predator's Gambit" strategy for the Common Pool Resource Game.

    This strategy is designed to be opportunistic and aggressive,
    maximizing immediate gains when the resource is abundant, while
    exercising calculated caution to avoid resource depletion when
    the stock is low. It adapts its decision based on the current stock level,
    the game's parameters, and the current round number.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing the game's parameters (n_players, n_rounds, capacity).
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.HIGH_STOCK_THRESHOLD = 0.75
        self.MODERATE_STOCK_LOW_THRESHOLD = 0.3
        self.CRITICAL_STOCK_THRESHOLD = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game (round_number, current_stock).
            history: The history of actions and payoffs for all players up to the previous round.
                     If None, it's the first round.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.r:
            return Action.D
        if current_stock < 0.01:
            return Action.C
        if current_stock > self.capacity * self.HIGH_STOCK_THRESHOLD:
            return Action.D
        elif current_stock >= self.capacity * self.MODERATE_STOCK_LOW_THRESHOLD:
            estimated_my_consumption = current_stock / self.n
            estimated_other_players_consumption = (self.n - 1) * (current_stock / self.n)
            estimated_total_consumption = estimated_my_consumption + estimated_other_players_consumption
            stock_after_consumption_estimated = current_stock - estimated_total_consumption
            if stock_after_consumption_estimated < 0:
                stock_after_consumption_estimated = 0
            growth_estimated = 2 * stock_after_consumption_estimated * (1 - stock_after_consumption_estimated / self.capacity)
            expected_next_stock = min(stock_after_consumption_estimated + growth_estimated, self.capacity)
            if expected_next_stock >= self.capacity * self.CRITICAL_STOCK_THRESHOLD:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_AGGRESSIVE_53(BaseStrategy):
    """
    Aggressive Strategy: "Resource Predator"

    This strategy defects aggressively when the resource stock is abundant
    and switches to cooperation when the stock level drops below a critical
    threshold to prevent resource depletion and ensure future payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.threshold_defect = self.capacity * 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        if history is None:
            return Action.D
        elif current_stock > self.threshold_defect:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_54(BaseStrategy):
    """
    Aggressive strategy "Exploit & Conserve":
    Defects when stock is above a dynamic threshold, cooperates when below.
    The threshold tightens as stock decreases and loosens as it increases.
    Always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold = self.capacity * 0.6
        self.last_stock_level = self.capacity
        self.current_round_number = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.current_round_number = state.round_number
        if self.current_round_number == self.r:
            return Action.D
        if state.current_stock <= 0:
            return Action.C
        if state.current_stock > self.cooperation_threshold:
            return Action.D
        else:
            return Action.C

    def update_strategy(self, new_stock_level: float):
        """
        Updates the cooperation threshold based on stock dynamics.
        This method would typically be called by the game engine after each round.
        """
        if new_stock_level > self.last_stock_level:
            self.cooperation_threshold += self.capacity * 0.02
            self.cooperation_threshold = min(self.capacity * 0.8, self.cooperation_threshold)
        elif new_stock_level < self.last_stock_level:
            self.cooperation_threshold -= self.capacity * 0.05
            self.cooperation_threshold = max(self.capacity * 0.2, self.cooperation_threshold)
        self.last_stock_level = new_stock_level

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            self.cooperation_threshold = self.capacity * 0.6
            self.last_stock_level = state.current_stock
            return Action.D
        current_stock_at_start_of_round = state.current_stock
        if state.round_number == self.r:
            return Action.D
        if current_stock_at_start_of_round <= 0:
            return Action.C
        if current_stock_at_start_of_round > self.cooperation_threshold:
            decision = Action.D
        else:
            decision = Action.C
        if state.round_number > 0:
            stock_change = current_stock_at_start_of_round - self.last_stock_level
            if stock_change > 0:
                self.cooperation_threshold += self.capacity * 0.02
                self.cooperation_threshold = min(self.capacity * 0.8, self.cooperation_threshold)
            elif stock_change < 0:
                self.cooperation_threshold -= self.capacity * 0.05
                self.cooperation_threshold = max(self.capacity * 0.2, self.cooperation_threshold)
        self.last_stock_level = current_stock_at_start_of_round
        return decision

class Strategy_AGGRESSIVE_55(BaseStrategy):
    """
    The "Profit Maximizer" strategy is an aggressive and adaptive approach
    to the Common Pool Resource Game. It prioritizes maximizing individual
    gain by leaning towards defection, but incorporates caution when the
    resource stock is critically low and exploits the last round for maximum
    extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_probability = 0.8
        self.critical_stock_threshold = self.game_description.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_stock < self.critical_stock_threshold:
            return Action.C
        elif current_round == self.game_description.n_rounds:
            return Action.D
        elif random.random() < self.defection_probability:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_56(BaseStrategy):
    """
    Aggressive Strategy: "Maximize Extraction, Minimize Vulnerability"

    This strategy aims to maximize immediate individual gain by defecting
    when the stock level can sustain it, while being mindful of avoiding
    complete resource depletion. It prioritizes individual payoff but
    maintains a floor for stock level to ensure continued extraction
    opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.sustainability_threshold = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if current_stock <= self.sustainability_threshold:
            return Action.C
        else:
            consumption_if_defect = current_stock / self.n
            stock_after_defect = current_stock - consumption_if_defect
            if stock_after_defect < 0:
                stock_after_defect = 0.0
            growth_if_defect = 2.0 * stock_after_defect * (1.0 - stock_after_defect / self.capacity)
            new_stock_if_defect = min(stock_after_defect + growth_if_defect, self.capacity)
            if new_stock_if_defect > self.sustainability_threshold:
                return Action.D
            else:
                return Action.C

class Strategy_AGGRESSIVE_57(BaseStrategy):
    """
    The "Predator" strategy: Aggressively exploits the common resource
    by defecting whenever the stock level is above a calculated aggression
    threshold. It cooperates only when the stock is critically low to ensure
    the resource isn't immediately depleted, thus preserving it for future
    exploitation. In the last round, it defects unconditionally to maximize
    immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Predator strategy with game parameters.
        """
        self.game_description = game_description
        self.aggression_multiplier = 1.5
        self.stock_threshold = None

    def _calculate_stock_threshold(self) -> float:
        """
        Calculates the stock level above which the strategy will defect.
        """
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        return capacity / n * self.aggression_multiplier

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs for this player and opponents.
                     None if it's the first round.

        Returns:
            The chosen Action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        current_round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if self.stock_threshold is None:
            self.stock_threshold = self._calculate_stock_threshold()
        if current_round_number == total_rounds:
            return Action.D
        if current_stock <= self.stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_58(BaseStrategy):
    """
    Aggressive Accumulator strategy for the Common Pool Resource Game.
    This strategy prioritizes immediate gains by defecting when the stock is high
    and the game is not in its final stages. It becomes cautious and cooperates
    when the stock is critically low or in the last round to ensure a payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like n_players,
                              n_rounds, and capacity.
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_threshold_ratio = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs for all players.
                     None if it's the first round.

        Returns:
            The chosen action: Action.C for Cooperate, Action.D for Defect.
        """
        current_stock = state.current_stock
        current_round = state.round_number
        critical_stock_threshold = self.capacity * self.critical_stock_threshold_ratio
        stock_ratio = current_stock / self.capacity if self.capacity > 0 else 0
        if current_round == self.r:
            return Action.C
        if current_stock < critical_stock_threshold:
            return Action.C
        if current_round < self.r and current_stock >= critical_stock_threshold:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_59(BaseStrategy):
    """
    The "Opportunistic Predator" strategy.
    This strategy prioritizes immediate gains by defecting when the resource stock is
    sufficiently high. It adopts a self-preservation mechanism by cooperating when the
    stock level becomes critically low, to prevent resource collapse and ensure future
    exploitation opportunities. It defects on the first and last rounds to maximize gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.
        """
        self.game_description = game_description
        self.STOCK_SUSTAINABILITY_FRACTION = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) based on the current state and history.

        Args:
            state: The current state of the game (round number, current stock).
            history: The history of actions and payoffs for all players.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == r:
            return Action.D
        if history is None:
            return Action.D
        stock_sustainability_threshold = capacity * self.STOCK_SUSTAINABILITY_FRACTION
        if current_stock > stock_sustainability_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_60(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predator"
    This strategy aims to maximize individual payoff by defecting whenever
    the potential reward outweighs the immediate risk of stock depletion.
    It defects if the stock is sufficiently high, and only cooperates when
    the stock reaches a critical level or in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.initial_risk_factor = self.n
        self.risk_increase_per_depletion_event = 0.1
        self.risk_decrease_per_growth_event = 0.05
        self.critical_stock_threshold_ratio = 0.1
        self.aggressive_defect_threshold_ratio = 0.6
        self.max_risk_factor = 2 * self.n
        self.min_risk_factor = self.initial_risk_factor / 2
        self.current_risk_factor = self.initial_risk_factor
        self.previous_stock = float(self.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if history is None:
            self.current_risk_factor = self.initial_risk_factor
            self.previous_stock = float(self.capacity)
            return Action.D
        if round_number > 0:
            stock_change = current_stock - self.previous_stock
            relative_stock_change = stock_change / self.capacity
            if relative_stock_change < -0.05:
                self.current_risk_factor += self.risk_increase_per_depletion_event
            elif relative_stock_change > 0.05:
                self.current_risk_factor -= self.risk_decrease_per_growth_event
            self.current_risk_factor = max(self.current_risk_factor, self.min_risk_factor)
            self.current_risk_factor = min(self.current_risk_factor, self.max_risk_factor)
        if round_number == self.r - 1:
            if current_stock > 0:
                return Action.D
            else:
                return Action.C
        if current_stock < self.capacity * self.critical_stock_threshold_ratio:
            return Action.C
        defect_threshold = self.capacity * self.aggressive_defect_threshold_ratio
        risk_difference_factor = (self.current_risk_factor - self.initial_risk_factor) / self.initial_risk_factor
        adjustment_amount = risk_difference_factor * (self.capacity / self.n)
        defect_threshold += adjustment_amount
        defect_threshold = max(defect_threshold, self.capacity * 0.1)
        defect_threshold = min(defect_threshold, self.capacity * 0.9)
        if current_stock > defect_threshold:
            my_action = Action.D
        else:
            my_action = Action.C
        self.previous_stock = current_stock
        return my_action

class Strategy_AGGRESSIVE_61(BaseStrategy):
    """
    The "Wolf" strategy: Aggressive extraction with a survival mechanism.
    This strategy defaults to defecting to maximize immediate gains, but
    will cooperate if the resource stock falls below a critical threshold
    or in the very last round to ensure maximum extraction.
    The exploitation threshold is dynamically adjusted based on past consumption.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.exploitation_threshold = self.capacity / 2.0
        self.previous_stock = self.capacity
        self.stock_after_consumption_previous_round = self.capacity
        self.my_last_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if history is not None and history.round_number > 0:
            stock_at_start_of_previous_round_inferred = self.previous_stock
            if current_round > 1:
                consumption_this_round = self.previous_stock - self.stock_after_consumption_previous_round
                my_consumption = 0
                if self.my_last_action == Action.C:
                    my_consumption = self.previous_stock / (2.0 * self.n_players)
                elif self.my_last_action == Action.D:
                    my_consumption = self.previous_stock / self.n_players
                total_consumption_prev_round = self.previous_stock - self.stock_after_consumption_previous_round
                depletion_ratio_prev_round = total_consumption_prev_round / self.previous_stock if self.previous_stock > 0 else 0
                if depletion_ratio_prev_round > 1.0 / (2.0 * self.n_players) and current_stock < self.previous_stock / 2.0:
                    self.exploitation_threshold = min(self.capacity, self.exploitation_threshold * 1.1)
                elif depletion_ratio_prev_round < 1.0 / (4.0 * self.n_players) and self.previous_stock > self.capacity / 2.0:
                    self.exploitation_threshold = max(self.capacity / 4.0, self.exploitation_threshold * 0.9)
        if current_stock < self.capacity / 4.0:
            action = Action.C
        elif current_round == self.n_rounds:
            action = Action.D
        elif current_stock >= self.exploitation_threshold:
            action = Action.D
        else:
            action = Action.C
        if history is None:
            self.exploitation_threshold = self.capacity / 2.0
            self.previous_stock = self.capacity
            self.stock_after_consumption_previous_round = self.capacity
            self.my_last_action = None
            return Action.D
        consumption_this_round_for_next_update = 0
        if action == Action.C:
            consumption_this_round_for_next_update = current_stock / (2.0 * self.n_players)
        elif action == Action.D:
            consumption_this_round_for_next_update = current_stock / self.n_players
        stock_after_consumption_this_round = current_stock - consumption_this_round_for_next_update
        self.previous_stock = current_stock
        self.stock_after_consumption_previous_round = stock_after_consumption_this_round
        self.my_last_action = action
        return action

class Strategy_AGGRESSIVE_62(BaseStrategy):
    """
    Aggressive Dominance Strategy (ADS).
    This strategy aims to maximize its own payoff by exploiting the commons,
    while being acutely aware of the potential for stock depletion and using
    that knowledge to its advantage. It's designed to be aggressive but not
    recklessly so, understanding that sustained high individual payoffs require
    a minimally functional resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.high_stock_threshold = 0.8 * self.capacity
        self.medium_stock_threshold = 0.5 * self.capacity
        self.low_stock_threshold = 0.2 * self.capacity
        self.previous_stock_at_start_of_round = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if history is None:
            self.previous_stock_at_start_of_round = current_stock
            return Action.D
        if current_round_number == self.r:
            return Action.D
        if current_stock <= self.low_stock_threshold:
            self.previous_stock_at_start_of_round = current_stock
            return Action.C
        elif self.low_stock_threshold < current_stock <= self.medium_stock_threshold:
            stock_change = self.previous_stock_at_start_of_round - current_stock
            stock_depletion_rate = stock_change / self.previous_stock_at_start_of_round if self.previous_stock_at_start_of_round > 0 else 0
            if stock_depletion_rate > 0.5:
                self.previous_stock_at_start_of_round = current_stock
                return Action.C
            else:
                self.previous_stock_at_start_of_round = current_stock
                return Action.D
        elif self.medium_stock_threshold < current_stock <= self.high_stock_threshold:
            self.previous_stock_at_start_of_round = current_stock
            return Action.D
        else:
            self.previous_stock_at_start_of_round = current_stock
            return Action.D

class Strategy_AGGRESSIVE_63(BaseStrategy):
    """
    "The Strategic Predator" strategy for the Common Pool Resource Game.
    This strategy is aggressive, prioritizing immediate individual gains by
    defecting frequently when the resource is abundant. It only cooperates
    when the stock level becomes critically low to prevent total depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.r = game_description.n_rounds
        self.AGGRESSIVE_DEF_THRESH_PERCENT = 0.75
        self.MODERATE_DEF_THRESH_PERCENT = 0.4
        self.CAUTIOUS_OBS_THRESH_PERCENT = 0.2
        self.MODERATE_DEF_PROB = 0.8
        self.CAUTIOUS_COOP_PROB = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        if history is None:
            return Action.D
        aggressive_def_threshold = self.AGGRESSIVE_DEF_THRESH_PERCENT * self.capacity
        moderate_def_threshold = self.MODERATE_DEF_THRESH_PERCENT * self.capacity
        cautious_obs_threshold = self.CAUTIOUS_OBS_THRESH_PERCENT * self.capacity
        if current_stock <= cautious_obs_threshold:
            return Action.C
        elif current_stock > aggressive_def_threshold:
            return Action.D
        elif current_stock > moderate_def_threshold:
            if random.random() < self.MODERATE_DEF_PROB:
                return Action.D
            else:
                return Action.C
        elif current_stock > cautious_obs_threshold:
            if random.random() < self.CAUTIOUS_COOP_PROB:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_64(BaseStrategy):
    """
    Aggressive "Maximize-or-Sustain" Strategy for the Common Pool Resource Game.

    This strategy prioritizes immediate gains by defaulting to 'Defect' when the
    stock is healthy or moderately high. It employs strategic cooperation only
    when the stock reaches a critically low level to ensure its survival for
    future exploitation. In the final round, it maximizes individual payoff by
    defecting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / 4.0
        self.MODERATE_STOCK_THRESHOLD = self.capacity / 3.0
        self.HEALTHY_STOCK_THRESHOLD = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs for all players. None for the first round.

        Returns:
            The chosen Action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if current_stock <= self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        if current_stock > self.HEALTHY_STOCK_THRESHOLD:
            return Action.D
        if current_round < self.r:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_65(BaseStrategy):
    """
    The Opportunist's Edge strategy.
    This strategy is aggressive, defaulting to Defect (D) to maximize immediate gains.
    It only switches to Cooperate (C) when the common pool stock is critically low
    (less than 'n' units), to prevent total resource depletion and thus future payoff
    annihilation. Cooperation is a reactive, self-preservation measure, not altruism.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.n

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        if history is None:
            return Action.D
        if current_stock < self.critical_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_66(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "Predatory Growth"

    This strategy prioritizes maximizing individual gain through defection.
    It only cooperates when the resource stock falls below a critical threshold
    to prevent complete collapse. It defects aggressively in the first round
    and always defects in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like n_players,
                              n_rounds, and capacity.
        """
        self.game_description = game_description
        self.THRESHOLD_LOW = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action based on the current state and history.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs for all players. None for the first round.

        Returns:
            The action to take: Action.C (Cooperate) or Action.D (Defect).
        """
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        round_number = state.round_number
        total_rounds = self.game_description.n_players
        if history is None:
            return Action.D
        abundance_ratio = current_stock / capacity if capacity > 0 else 0
        if round_number == total_rounds:
            return Action.D
        if abundance_ratio <= self.THRESHOLD_LOW:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_67(BaseStrategy):
    """
    The "Resource Predator" strategy is designed to maximize individual gain by
    aggressively exploiting the common pool resource. It defaults to Defect (D)
    to achieve higher immediate payoffs. Cooperation (C) is only employed as a
    last resort to prevent catastrophic stock depletion, ensuring continued
    future exploitation.

    Decision Logic:
    1. In the last round, always Defect (D) to maximize final payoff.
    2. In earlier rounds, default to Defect (D).
    3. Switch to Cooperate (C) only if the current stock level triggers the
       "Imminent Collapse Safeguard". This safeguard activates if:
       a) The current stock is less than twice the number of players (indicating
          a very low stock relative to the consumption if everyone cooperates).
       OR
       b) The current stock is less than 15% of the maximum capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.r:
            return Action.D
        condition1 = current_stock < 2 * self.n
        condition2 = current_stock < self.capacity * 0.15
        if condition1 or condition2:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_68(BaseStrategy):
    """
    Aggressive Strategy: "Harvest and Replenish"

    This strategy aims to maximize individual player's total payoff by aggressively
    extracting resources when beneficial, while simultaneously attempting to maintain
    a sustainable stock level that allows for future profitable harvests. It is
    designed to be adaptive and resilient to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.threshold_stock_ratio = 0.75
        self.min_threshold_ratio = 0.5
        self.max_threshold_ratio = 0.9
        self.aggressive_boost_factor_ratio = 0.05
        self.conservative_reduction_factor_ratio = 0.02
        self.prev_round_start_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if history is None:
            self.prev_round_start_stock = current_stock
            return Action.D
        if current_round == self.n_rounds:
            return Action.D
        if self.prev_round_start_stock is not None:
            stock_after_growth_prev_round = current_stock
            stock_before_growth_prev_round = self.prev_round_start_stock
            if stock_before_growth_prev_round > 0 and stock_after_growth_prev_round < 0.5 * stock_before_growth_prev_round:
                self.threshold_stock_ratio = min(self.max_threshold_ratio, self.threshold_stock_ratio + self.aggressive_boost_factor_ratio)
            elif stock_after_growth_prev_round > 0.9 * self.capacity:
                self.threshold_stock_ratio = max(self.min_threshold_ratio, self.threshold_stock_ratio - self.conservative_reduction_factor_ratio)
        self.prev_round_start_stock = current_stock
        current_threshold = self.threshold_stock_ratio * self.capacity
        if current_stock > current_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_69(BaseStrategy):
    """
    Aggressive "Exploit and Replenish" Strategy.

    This strategy aims to maximize individual gains by aggressively exploiting
    the common pool resource while incorporating a dynamic threshold to prevent
    complete depletion. It prioritizes immediate gains but adapts to ensure
    long-term viability for continued exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        rounds_remaining = self.r - current_round_number
        if rounds_remaining <= 1:
            return Action.D
        danger_threshold = self.capacity * (rounds_remaining / self.r)
        if current_stock < danger_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_70(BaseStrategy):
    """
    Resource Predator: Aggressive exploitation strategy for the Common Pool Resource Game.
    This strategy prioritizes immediate gains by defecting when the resource stock
    is abundant. It cooperates only when the stock level drops to a critical threshold
    to prevent resource collapse and ensure future harvesting opportunities.
    It is also ruthless in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_cooperation = 0.7 * self.capacity
        self.aggressive_depletion_threshold = 0.3 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.n_rounds:
            return Action.D
        if current_stock < self.n_players or current_stock <= self.threshold_cooperation:
            if history is not None and len(history.my_actions) > 0:
                pass
            return Action.C
        else:
            if history is not None and len(history.my_actions) > 0:
                if len(self.stock_history) >= 2:
                    stock_at_start_prev_round = self.stock_history[-2]
                    stock_at_start_this_round = self.stock_history[-1]
                    stock_change_last_round = stock_at_start_prev_round - stock_at_start_this_round
                    pass
            return Action.D

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_cooperation = 0.7 * self.capacity
        self.aggressive_depletion_threshold = 0.3 * self.capacity
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        self.stock_history.append(current_stock)
        if round_number == self.n_rounds:
            return Action.D
        if current_stock < self.n_players or current_stock <= self.threshold_cooperation:
            if history is not None and len(history.my_actions) > 0:
                if len(self.stock_history) >= 3:
                    stock_at_start_prev_round = self.stock_history[-2]
                    stock_at_start_this_round = self.stock_history[-1]
                    stock_change_last_round = stock_at_start_prev_round - stock_at_start_this_round
                    pass
            return Action.C
        else:
            if history is not None and len(history.my_actions) > 0:
                if len(self.stock_history) >= 3:
                    stock_at_start_prev_round = self.stock_history[-2]
                    stock_at_start_this_round = self.stock_history[-1]
                    stock_change_last_round = stock_at_start_prev_round - stock_at_start_this_round
                    pass
            return Action.D

class Strategy_AGGRESSIVE_71(BaseStrategy):
    """
    The Opportunistic Exploiter strategy.
    This strategy prioritizes maximizing individual payoffs by defecting whenever the
    short-term gain outweighs the perceived long-term risk to the common pool.
    It defaults to Defect (D), only cooperating (C) when the stock level falls below
    a critical threshold (capacity / 4) to prevent complete depletion.
    It always defects in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if history is None:
            return Action.D
        if current_round == self.n_rounds:
            return Action.D
        if current_stock <= self.critical_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_72(BaseStrategy):
    """
    The "Opportunistic Exploiter" strategy for the Common Pool Resource Game.
    This strategy defaults to Defect to maximize immediate individual gain but
    switches to Cooperate when the stock is critically low to avoid complete
    resource collapse. It defects aggressively in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        s_crit = min(self.capacity / 4.0, float(self.n) * 2.0)
        if round_number == self.r:
            return Action.D
        if current_stock <= s_crit:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_73(BaseStrategy):
    """
    Aggressive Harvest Maximizer (AHM) strategy for the Common Pool Resource Game.
    This strategy aims to maximize individual payoffs by aggressively defecting when
    the resource is abundant or growing, and cooperating only when the stock is critically low.
    It prioritizes immediate gains and exploits favorable conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_prev = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = float(state.current_stock)
        round_number = state.round_number
        if round_number == self.r:
            return Action.D
        critical_low_threshold = 0.05 * self.capacity
        if current_stock < critical_low_threshold:
            return Action.C
        if history is None:
            self.stock_prev = current_stock
            return Action.D
        high_stock_threshold = 0.75 * self.capacity
        moderate_stock_threshold = 0.3 * self.capacity
        if current_stock > high_stock_threshold:
            self.stock_prev = current_stock
            return Action.D
        elif current_stock > moderate_stock_threshold:
            if current_stock > self.stock_prev:
                self.stock_prev = current_stock
                return Action.D
            else:
                self.stock_prev = current_stock
                return Action.C
        else:
            self.stock_prev = current_stock
            return Action.C

class Strategy_AGGRESSIVE_74(BaseStrategy):
    """
    Aggressive strategy for the Common Pool Resource Game: "Exploit and Recover".
    This strategy prioritizes immediate high payouts by defaulting to "Defect",
    but employs a dynamic threshold based on stock levels and round progression
    to avoid total depletion and strategically cooperate when necessary for future gain.
    It aims to maximize individual gain while being robust against exploitation and
    adaptive to the resource's state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.risk_tolerance = 0.85

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        t = current_round + 1
        if t > self.r * 0.9:
            if current_stock < self.capacity * 0.3:
                return Action.C
            else:
                return Action.D
        else:
            threshold_base = self.capacity * self.risk_tolerance
            if current_stock < self.capacity * 0.2:
                current_defection_threshold = self.capacity * 0.2
            else:
                current_defection_threshold = threshold_base
            if current_stock > current_defection_threshold:
                return Action.D
            elif current_stock < self.capacity * 0.25:
                return Action.C
            else:
                return Action.D

class Strategy_AGGRESSIVE_75(BaseStrategy):
    """
    "The Opportunist" strategy for the Common Pool Resource Game.
    This strategy defaults to Defect (D) to maximize immediate individual gain.
    It switches to Cooperate (C) only when the stock level falls below a
    calculated threshold (30% of capacity) to prevent total stock collapse.
    The first and last rounds are always Defect to exploit abundant stock
    and maximize final round payoff, respectively.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like
                              number of players, rounds, and capacity.
        """
        self.game_description = game_description
        self.cooperation_threshold_percentage = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action for the current round based on the strategy.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs for all players. None for the first round.

        Returns:
            The action to take (Action.C or Action.D).
        """
        current_stock = state.current_stock
        current_round = state.round_number
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if current_round == r:
            return Action.D
        if history is None:
            return Action.D
        cooperation_threshold = self.cooperation_threshold_percentage * capacity
        action = Action.D
        if current_stock < cooperation_threshold:
            action = Action.C
        return action

class Strategy_AGGRESSIVE_76(BaseStrategy):
    """
    Opportunistic Predator strategy for the Common Pool Resource Game.

    This strategy defaults to defecting to maximize immediate individual gain.
    It adapts by cooperating when the resource stock is critically low to ensure
    its long-term survival and future exploitation opportunities. It always defects
    in the last round to maximize final payoff and defects in the first round
    due to high initial stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like
                              number of players, rounds, and capacity.
        """
        self.game_description = game_description
        self.high_stock_threshold_ratio = 0.7
        self.low_stock_threshold_ratio = 0.3
        self.high_stock_threshold = self.game_description.capacity * self.high_stock_threshold_ratio
        self.low_stock_threshold = self.game_description.capacity * self.low_stock_threshold_ratio

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) based on the current state.

        Args:
            state: The current state of the game, including the round number and stock.
            history: Historical data of actions and payoffs for all players. None for the first round.

        Returns:
            The chosen action: Action.C (Cooperate) or Action.D (Defect).
        """
        current_round = state.round_number
        current_stock = state.current_stock
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if current_round == total_rounds:
            return Action.D
        if current_stock <= 0:
            return Action.C
        if current_stock >= self.high_stock_threshold:
            return Action.D
        elif current_stock < self.low_stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_77(BaseStrategy):
    """
    "Exploit and Survive" Strategy for the Common Pool Resource Game.

    This strategy prioritizes immediate high payoffs by defaulting to Defect (D).
    It incorporates a critical stock threshold to switch to Cooperate (C) and
    prevent total collapse, ensuring some future potential. It becomes maximally
    aggressive in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_low_stock_threshold = 0.2 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round_number and current_stock.
            history: The history of actions and payoffs for all players. None for the first round.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == self.r:
            return Action.D
        if current_stock <= self.critical_low_stock_threshold:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_78(BaseStrategy):
    """
    The Calculated Predator strategy aims to maximize immediate personal gain
    by defecting when the stock is high enough to absorb the consumption,
    while cooperating when the stock is low or few rounds remain, to avoid
    resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_stock <= 0:
            return Action.C
        remaining_rounds = self.r - current_round
        epsilon = 0.0001
        cooperate_payoff_per_unit = 1 / (2 * self.n)
        defect_payoff_per_unit = 1 / self.n
        if history is None:
            initial_threshold = self.capacity / (2 * self.n)
            if current_stock / self.n >= initial_threshold:
                return Action.D
            else:
                return Action.C
        stock_ratio = current_stock / self.capacity
        stock_modifier = 1 + (1 - stock_ratio) * 0.5
        if remaining_rounds == 0:
            if current_stock / self.n > current_stock / (2 * self.n) - epsilon:
                return Action.D
            else:
                return Action.C
        risk_factor = (1 - stock_ratio) * 0.5 + (1 - remaining_rounds / self.r) * 0.5
        num_remaining_decisions = self.r - current_round
        if num_remaining_decisions == 0:
            if current_stock / self.n > current_stock / (2 * self.n) - epsilon:
                return Action.D
            else:
                return Action.C
        stock_ratio = current_stock / self.capacity
        rounds_modifier_val = 1 - num_remaining_decisions / self.r
        rounds_modifier = 1 + rounds_modifier_val * 0.5
        stock_modifier_val = 1 - stock_ratio
        stock_modifier = 1 + stock_modifier_val * 0.5
        base_threshold_value = self.capacity / (2 * self.n)
        dynamic_threshold = base_threshold_value * stock_modifier * rounds_modifier
        if current_stock / self.n >= dynamic_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_79(BaseStrategy):
    """
    Strategy: "The Monopoly Man"

    This strategy is designed to be aggressively exploitative in the Common Pool
    Resource Game. It prioritizes maximizing individual gain by defaulting to
    defection. Cooperation is only considered as a last resort to prevent the
    resource from collapsing entirely, thereby jeopardizing future extraction.

    Decision Logic:
    1. Aggressive Consumption Threshold (ACT): If current stock > 80% of initial
       capacity, always Defect (D).
    2. Near-Collapse Cooperation Threshold (NCCT): If current stock < 25% of
       initial capacity:
       - If 4 or fewer rounds remain, Cooperate (C) to preserve the resource.
       - If more than 4 rounds remain, Defect (D) to extract remaining value.
    3. Moderate Stock: If stock is between ACT and NCCT, always Defect (D).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.ACT_RATIO = 0.8
        self.NCCT_RATIO = 0.25
        self.LCR = 4
        self.act_level = self.game_description.capacity * self.ACT_RATIO
        self.ncct_level = self.game_description.capacity * self.NCCT_RATIO

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.D
        current_stock = state.current_stock
        current_round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        rounds_remaining = total_rounds - history.round_number
        if current_stock > self.act_level:
            return Action.D
        elif current_stock <= self.ncct_level:
            if rounds_remaining <= self.LCR:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_80(BaseStrategy):
    """
    The "Resource Dominance" strategy aims to maximize individual gains by exploiting
    the common pool resource aggressively. It defects when the stock is high relative
    to a dynamically calculated Defection Threshold (DT), and cooperates when the
    stock is low to prevent total collapse. The DT decreases as the game progresses,
    allowing for more defection in later rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        if history is None:
            return Action.D
        one_indexed_round = current_round + 1
        remaining_rounds_proportion = (self.n_rounds - one_indexed_round) / self.n_rounds
        if self.n_rounds == 1:
            defection_threshold = 0.0
        else:
            defection_threshold = self.capacity * math.pow((self.n_rounds - one_indexed_round) / self.n_rounds, 2)
        defection_threshold = max(0.0, defection_threshold)
        if stock > defection_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_81(BaseStrategy):
    """
    The "Opportunistic Predator" strategy for the Common Pool Resource Game.
    This strategy aims for aggressive extraction when the resource is abundant
    and players are likely cooperating, but becomes more cautious when the
    resource is scarce or others are exhibiting aggressive behavior.

    It prioritizes immediate individual payoff but incorporates adaptive mechanisms
    to avoid complete resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy parameters.

        Args:
            game_description: An object containing game parameters (n_players, n_rounds, capacity).
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.greed_threshold = self.capacity * 0.8
        self.danger_zone = self.capacity * 0.2
        self.previous_stock = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game (round number, current stock).
            history: History of actions and payoffs from previous rounds. None for the first round.

        Returns:
            The chosen action: Action.C (Cooperate) or Action.D (Defect).
        """
        current_stock = state.current_stock
        round_num = state.round_number
        if history is not None and history.round_number > 0:
            stock_change = current_stock - self.previous_stock
            my_last_action = Action.C if history.my_actions[-1] else Action.D
            total_consumption_last_round = 0
            if self.previous_stock > 0:
                my_consumption_last_round = self.previous_stock / (2 * self.n) if my_last_action == Action.C else self.previous_stock / self.n
                opp_consumption_sum = np.sum([self.previous_stock / (2 * self.n) if history.opponent_actions[-1, i] else self.previous_stock / self.n for i in range(self.n - 1) if self.previous_stock > 0])
                total_consumption_last_round = my_consumption_last_round + opp_consumption_sum
            if my_last_action == Action.D and stock_change >= -0.1 * self.capacity:
                self.greed_threshold = min(self.capacity, self.greed_threshold + 0.02 * self.capacity)
                self.danger_zone = max(0, self.danger_zone - 0.005 * self.capacity)
            elif my_last_action == Action.D and stock_change < -0.3 * self.capacity:
                self.greed_threshold = max(0, self.greed_threshold - 0.01 * self.capacity)
                self.danger_zone = min(self.capacity * 0.7, self.danger_zone + 0.05 * self.capacity)
            elif my_last_action == Action.C and stock_change > 0.1 * self.capacity:
                self.greed_threshold = min(self.capacity, self.greed_threshold + 0.01 * self.capacity)
            if current_stock <= self.danger_zone:
                self.danger_zone = min(self.capacity * 0.7, self.danger_zone + 0.1 * self.capacity)
                self.greed_threshold = max(0, self.greed_threshold - 0.02 * self.capacity)
            self.greed_threshold = max(0, min(self.capacity, self.greed_threshold))
            self.danger_zone = max(0, min(self.capacity, self.danger_zone))
        if round_num == self.r:
            return Action.D
        if current_stock <= self.danger_zone:
            chosen_action = Action.C
        elif current_stock >= self.greed_threshold:
            chosen_action = Action.D
        else:
            chosen_action = Action.C
        self.previous_stock = current_stock
        return chosen_action

class Strategy_AGGRESSIVE_82(BaseStrategy):
    """
    The Predator Strategy: Aggressively extracts resources, defecting by default.
    It only cooperates under specific conditions:
    1. To survive when the stock is critically low.
    2. Opportunistically, if the stock is high and demonstrating strong growth.
    It reinforces defection if many opponents defected in the previous round.
    It always defects in the first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.high_stock_threshold = self.capacity * 0.8
        self.strong_growth_rate_threshold = 0.5
        self.critical_stock_threshold = float(self.n)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if history is None or current_round_number == 1:
            return Action.D
        if current_round_number == self.r:
            return Action.D
        if current_stock < self.critical_stock_threshold:
            return Action.C
        previous_round_idx = current_round_number - 2
        previous_stock_before_consumption = history.my_payoffs[previous_round_idx] + np.sum(history.opponent_payoffs[previous_round_idx, :]) if previous_round_idx >= 0 else self.capacity
        if previous_round_idx >= 0:
            num_opponents_defected_prev_round = np.sum(history.opponent_actions[previous_round_idx, :])
            percentage_opponents_defected = num_opponents_defected_prev_round / (self.n - 1)
            action = Action.D
            if percentage_opponents_defected > 0.5:
                action = Action.D
            if percentage_opponents_defected < 0.5:
                action = Action.C
            if current_stock > self.high_stock_threshold and action == Action.D and (percentage_opponents_defected < 0.5):
                action = Action.C
            return action
        else:
            return Action.D

class Strategy_AGGRESSIVE_83(BaseStrategy):
    """
    Aggressive Strategy: "Maximum Exploitation"

    This strategy aims to maximize immediate individual gain by exploiting the common
    pool resource as aggressively as possible. It prioritizes short-term gains over
    long-term sustainability, assuming other players may also act selfishly.
    It defects if the stock is above 50% of capacity. It only cooperates if the
    stock is critically low such that a full round of defections by all players
    would lead to zero stock, as a last-ditch effort to preserve some resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like n_players,
                              n_rounds, and capacity.
        """
        self.game_description = game_description
        self.exploitation_threshold = 0.5
        self.min_stock_for_survival_heuristic = self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: An object containing the current round number and stock level.
            history: An object containing past actions and payoffs. None for the first round.

        Returns:
            The chosen action: Action.C (Cooperate) or Action.D (Defect).
        """
        current_stock = state.current_stock
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        hypothetical_total_consumption_if_all_defect = current_stock
        hypothetical_stock_after_consumption = current_stock - hypothetical_total_consumption_if_all_defect
        hypothetical_growth = 0.0
        if hypothetical_stock_after_consumption > 0:
            hypothetical_growth = 2 * hypothetical_stock_after_consumption * (1 - hypothetical_stock_after_consumption / capacity)
        hypothetical_new_stock = min(hypothetical_stock_after_consumption + hypothetical_growth, capacity)
        if hypothetical_new_stock <= 0 and current_stock <= self.min_stock_for_survival_heuristic:
            return Action.C
        if current_stock > capacity * self.exploitation_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_84(BaseStrategy):
    """
    Aggressive Strategy: "Predator's Advantage"

    This strategy aims for maximum immediate gain by defecting whenever possible,
    but incorporates thresholds to avoid catastrophic depletion and to capitalize
    on periods of high abundance. It defaults to defection when the stock is
    high and cooperates only when the stock is critically low or to facilitate
    future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.r = game_description.n_rounds
        self.optimal_exploitation_threshold = self.capacity * 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == self.r:
            return Action.D
        if current_stock < self.n:
            return Action.C
        if current_stock > self.optimal_exploitation_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_85(BaseStrategy):
    """
    "Resource Predator" strategy for the Common Pool Resource Game.
    This strategy aggressively defects when the stock is high,
    but becomes cautious and may cooperate if the stock drops
    critically low to avoid immediate depletion. It also adapts
    its aggression threshold based on stock recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.epsilon = 1e-06
        self.aggression_threshold = self.capacity / 2.0
        self.high_growth_threshold_ratio = 1.2
        self.low_growth_threshold_ratio = 0.8
        self.threshold_adjustment_factor = 0.05

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            if current_stock / self.n < self.epsilon:
                return Action.C
            else:
                return Action.D
        if current_stock > self.aggression_threshold:
            return Action.D
        elif current_stock / self.n < self.epsilon:
            return Action.C
        else:
            return Action.D

    def update_strategy_state(self, stock_at_start_of_round: float, new_stock: float, current_round: int):
        """
        Adapts the aggression_threshold based on stock dynamics after a round.
        This method is called by the game engine after each round, after the player's
        action has been determined and the new state calculated.
        """
        if current_round < self.r and stock_at_start_of_round > self.epsilon:
            stock_ratio_change = new_stock / stock_at_start_of_round
            if stock_ratio_change > self.high_growth_threshold_ratio:
                adjustment = self.capacity * self.threshold_adjustment_factor
                self.aggression_threshold = min(self.capacity, self.aggression_threshold + adjustment)
            elif stock_ratio_change < self.low_growth_threshold_ratio:
                adjustment = self.capacity * self.threshold_adjustment_factor
                self.aggression_threshold = max(0.0, self.aggression_threshold - adjustment)
        self.aggression_threshold = max(0.0, min(self.capacity, self.aggression_threshold))

class Strategy_AGGRESSIVE_86(BaseStrategy):
    """
    Calculated Predator Strategy: Aggressively seeks to maximize individual gain
    while incorporating defensive measures to avoid immediate self-destruction
    due to mutual defection or critically low stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_risk_ratio = 0.2
        self.high_stock_aggression_ratio = 0.8
        self.min_payoff_guard = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        stock_ratio = current_stock / self.capacity
        if round_number == self.r:
            return Action.D
        if history is None:
            if stock_ratio >= self.high_stock_aggression_ratio:
                return Action.D
            else:
                return Action.C
        if stock_ratio < self.critical_stock_risk_ratio:
            payoff_if_defect = current_stock / self.n
            if payoff_if_defect < self.min_payoff_guard:
                return Action.C
            else:
                return Action.D
        elif stock_ratio >= self.high_stock_aggression_ratio:
            return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_87(BaseStrategy):
    """
    "Aggressive Harvest & Rebuild" strategy for the Common Pool Resource Game.

    This strategy prioritizes immediate individual gains by defecting when the
    stock is high. It switches to cooperating only when the stock falls below
    a critical threshold to prevent complete depletion and ensure future
    harvesting opportunities. It always defects in the final round for maximum
    immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.HIGH_STOCK_THRESHOLD_RATIO = 0.7
        self.CRITICAL_STOCK_THRESHOLD_RATIO = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_round = state.round_number
        if current_round == n_rounds - 1:
            return Action.D
        high_stock_threshold = capacity * self.HIGH_STOCK_THRESHOLD_RATIO
        critical_stock_threshold = capacity * self.CRITICAL_STOCK_THRESHOLD_RATIO
        if current_stock > high_stock_threshold:
            return Action.D
        elif current_stock > critical_stock_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_88(BaseStrategy):
    """
    The "Reckless Maximizer" strategy for the Common Pool Resource Game.

    This strategy aims to maximize immediate personal payoff by defecting
    whenever the common pool stock is sufficiently abundant (above 50% of capacity).
    It only cooperates when the stock is critically low (at or below 50% of capacity)
    to prevent immediate collapse. In the final round, it always defects to maximize
    its payoff when future sustainability is irrelevant.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.r:
            return Action.D
        if current_stock > self.capacity * 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_89(BaseStrategy):
    """
    Aggressive strategy "Predatory Growth" for the Common Pool Resource Game.
    This strategy prioritizes immediate gains through defection but incorporates
    conditional cooperation to prevent resource collapse, ensuring future extraction
    opportunities.

    Core Philosophy: Extract as much as possible, as quickly as possible, but
    avoid outright resource destruction if it means sacrificing a larger future payoff.
    This strategy is about being the biggest predator, not necessarily the one that
    kills the prey instantly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def _calculate_payoff(self, stock: float, action: Action) -> float:
        """Calculates the payoff for a single player given stock and action."""
        if action == Action.C:
            return stock / (2 * self.n)
        else:
            return stock / self.n

    def _project_stock_next_round(self, current_stock: float, all_actions: list[Action]) -> float:
        """Projects the stock level for the next round given current stock and all players' actions."""
        total_consumption = 0
        for action in all_actions:
            if action == Action.C:
                total_consumption += current_stock / (2 * self.n)
            else:
                total_consumption += current_stock / self.n
        stock_after_consumption = current_stock - total_consumption
        stock_after_consumption = max(0.0, stock_after_consumption)
        growth = 0.0
        if stock_after_consumption > 0:
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
        new_stock = stock_after_consumption + growth
        return min(new_stock, self.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        action_to_take = Action.D
        all_other_players_defect_actions = [Action.D] * (self.n - 1)
        projected_stock_if_we_defect_and_others_defect = self._project_stock_next_round(current_stock, all_other_players_defect_actions + [Action.D])
        projected_stock_if_we_cooperate_and_others_defect = self._project_stock_next_round(current_stock, all_other_players_defect_actions + [Action.C])
        current_cooperate_payoff = self._calculate_payoff(current_stock, Action.C)
        next_defect_payoff_if_we_defect = self._calculate_payoff(projected_stock_if_we_defect_and_others_defect, Action.D)
        next_defect_payoff_if_we_cooperate = self._calculate_payoff(projected_stock_if_we_cooperate_and_others_defect, Action.D)
        stock_if_all_defect_round = current_stock - self.n * (current_stock / self.n)
        stock_if_all_defect_round = max(0.0, stock_if_all_defect_round)
        growth_if_all_defect_round = 0.0
        if stock_if_all_defect_round > 0:
            growth_if_all_defect_round = 2 * stock_if_all_defect_round * (1 - stock_if_all_defect_round / self.capacity)
        projected_stock_if_all_defect = stock_if_all_defect_round + growth_if_all_defect_round
        projected_stock_if_all_defect = min(projected_stock_if_all_defect, self.capacity)
        if projected_stock_if_all_defect < self.n or stock_if_all_defect_round <= 0:
            if current_cooperate_payoff > next_defect_payoff_if_we_defect:
                action_to_take = Action.C
            elif current_stock < self.n and current_stock > 0:
                action_to_take = Action.C
        return action_to_take

class Strategy_AGGRESSIVE_90(BaseStrategy):
    """
    The "Aggressive Maximizer" strategy. This strategy aims to maximize individual
    player payoff by exploiting the higher immediate gains from defecting, while
    attempting to manage the common pool resource just enough to avoid its
    complete collapse. It defaults to defecting unless the stock is critically
    low or it's the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.s_critical = self.capacity / 3.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        rounds_remaining = self.r - state.round_number
        if rounds_remaining == 1:
            return Action.C
        if current_stock <= self.s_critical:
            return Action.C
        if history is None:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_91(BaseStrategy):
    """
    The "Unyielding Harvester" strategy.
    This strategy prioritizes immediate individual gain, defecting by default
    to exploit the common pool resource. It employs tactical cooperation only
    when the stock level is critically low to prevent complete depletion,
    thus preserving its own future harvesting potential. It aggressively exploits
    abundant resources and makes no concessions for long-term cooperation beyond
    what's necessary for its own survival.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold_fraction = 0.2
        self.critical_stock_fraction = 0.1
        self.aggressive_exploitation_threshold_fraction = 0.7
        self.consecutive_low_stock_limit = 2
        self.consecutive_low_stock_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round = state.round_number
        cooperation_threshold = self.cooperation_threshold_fraction * capacity
        critical_stock = self.critical_stock_fraction * capacity
        aggressive_exploitation_threshold = self.aggressive_exploitation_threshold_fraction * capacity
        if current_round == self.game_description.n_rounds:
            return Action.D
        if current_stock <= 0.3 * capacity:
            self.consecutive_low_stock_rounds += 1
        else:
            self.consecutive_low_stock_rounds = 0
        if current_stock > aggressive_exploitation_threshold:
            return Action.D
        if current_stock <= critical_stock:
            return Action.C
        if current_stock <= cooperation_threshold and self.consecutive_low_stock_rounds >= self.consecutive_low_stock_limit:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_92(BaseStrategy):
    """
    The "Resource Raider" strategy is designed to maximize individual player gain
    by prioritizing short-term benefits while maintaining a keen eye on the
    sustainability of the resource for future exploitation. It's adaptive and
    robust, aiming to exploit any perceived weakness in opponents' strategies.

    Core Philosophy: "Take what you can, when you can, before it's gone."

    Decision Rules:
    - Always Defect (D) in the last round.
    - Always Defect (D) in the first round to gain an early advantage.
    - Cooperate (C) if the stock is critically low (below LowerStockThreshold)
      to prevent resource collapse and preserve future gains.
    - Defect (D) if the stock is above the LowerStockThreshold, as this indicates
      the resource can sustain extraction and offers higher immediate payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.high_stock_threshold = 0.75 * self.capacity
        self.lower_stock_threshold = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.r:
            return Action.D
        if history is None or round_number == 0:
            return Action.D
        if current_stock <= self.lower_stock_threshold:
            return Action.C
        if current_stock > self.lower_stock_threshold:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_93(BaseStrategy):
    """
    Aggressive strategy "Predator's Feast" for the Common Pool Resource Game.
    This strategy prioritizes immediate gains by defaulting to Defect (D).
    It only cooperates (C) under extreme circumstances to prevent immediate stock collapse
    and ensure a possibility of future extraction, or if a rare condition of significantly
    increased future stock potential is met.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.COOPERATE = Action.C
        self.DEFECT = Action.D

    def _calculate_next_stock(self, current_stock: float, total_consumption: float) -> float:
        """Helper to calculate stock dynamics after consumption and growth."""
        stock_remaining = current_stock - total_consumption
        if stock_remaining < 0:
            stock_remaining = 0.0
        growth = 2 * stock_remaining * (1 - stock_remaining / self.capacity)
        new_stock = min(stock_remaining + growth, self.capacity)
        return new_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return self.DEFECT
        if current_stock <= 0:
            return self.DEFECT
        action = self.DEFECT
        total_consumption_all_defect = self.n * (current_stock / self.n)
        stock_after_consumption_all_defect = current_stock - total_consumption_all_defect
        if stock_after_consumption_all_defect < 1e-09:
            total_consumption_all_coop = self.n * (current_stock / (2 * self.n))
            stock_after_consumption_all_coop = current_stock - total_consumption_all_coop
            if current_round < self.r and stock_after_consumption_all_coop > 1e-09:
                if total_consumption_all_defect >= current_stock - 1e-09:
                    return self.COOPERATE
        payoff_cooperate_immediate = current_stock / (2 * self.n)
        payoff_defect_immediate = current_stock / self.n
        total_consumption_if_i_C_others_D = (self.n - 1) * (current_stock / self.n) + current_stock / (2 * self.n)
        next_stock_if_i_C_others_D = self._calculate_next_stock(current_stock, total_consumption_if_i_C_others_D)
        total_consumption_if_i_D_others_D = self.n * (current_stock / self.n)
        next_stock_if_i_D_others_D = self._calculate_next_stock(current_stock, total_consumption_if_i_D_others_D)
        return action

class Strategy_AGGRESSIVE_94(BaseStrategy):
    """
    The Predator strategy aims to maximize individual payoff by defecting frequently,
    especially when the stock is high. It cooperates only when the stock level
    falls below a critical threshold to avoid complete depletion. In the final
    round, it always defects to extract maximum value.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold = self.capacity / 3.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if history is None:
            return Action.D
        action = Action.D
        if current_stock < self.cooperation_threshold:
            action = Action.C
        if current_round == self.r - 1:
            action = Action.D
        return action

class Strategy_AGGRESSIVE_95(BaseStrategy):
    """
    Aggressive, Adaptive Strategy: "Stock Raider".

    This strategy aims to maximize individual player payoff by aggressively exploiting
    the common pool resource. It prioritizes short-term gains by defecting when
    stock levels are high and defecting is generally more profitable. It adapts
    its threshold for aggression based on the remaining rounds, becoming more
    aggressive as the game nears its end. It also includes safety mechanisms
    to avoid immediate resource collapse when the stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the StockRaider strategy.

        Args:
            game_description: An object containing game parameters (n_players, n_rounds, capacity).
        """
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def _calculate_aggression_threshold(self, current_round_num: int) -> float:
        """
        Calculates the Aggression Threshold (AT).

        The AT determines at what stock level the player switches from cooperating to defecting.
        It increases as the number of remaining rounds decreases, making the strategy more
        aggressive towards the end of the game.

        Args:
            current_round_num: The current round number (1-indexed).

        Returns:
            The calculated aggression threshold.
        """
        if current_round_num == self.r:
            return 0.0
        base_aggression = self.capacity / 2.0
        aggression_multiplier = 1.0 + (self.r - current_round_num) / (2.0 * self.r)
        return base_aggression * aggression_multiplier

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game (round_number, current_stock).
            history: The history of past actions and payoffs for all players. None for the first round.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        current_round_num = state.round_number
        if current_stock < self.n:
            return Action.C
        if current_round_num == 1:
            return Action.D
        if current_round_num == self.r:
            return Action.D
        aggression_threshold = self._calculate_aggression_threshold(current_round_num)
        if current_stock > aggression_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_96(BaseStrategy):
    """
    Aggressive Exploitation Strategy: "The Opportunist"

    This strategy aims to maximize individual payoff by defecting frequently
    to secure higher immediate gains. It cooperates only when the stock level
    falls below a dynamically calculated "danger threshold" to avoid complete
    resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.safety_multiplier = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        n = self.n_players
        r = self.n_rounds
        cap = self.capacity
        if history is None:
            return Action.D
        remaining_rounds = r - current_round + 1
        if current_round == r:
            potential_defection_payoff = current_stock / n
            if current_stock - potential_defection_payoff < 0:
                return Action.C
            else:
                return Action.D
        critical_stock_level = cap / n * (remaining_rounds / r) * self.safety_multiplier
        if current_stock < critical_stock_level:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_97(BaseStrategy):
    """
    "The Predator" Strategy: Aggressively exploits the common pool by defecting
    by default, but cooperates temporarily when the stock is critically low to
    ensure its recovery for future exploitation. It prioritizes immediate payoff
    but avoids complete resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_defect = self.capacity * 0.7
        self.threshold_cooperate_recovery = self.capacity * 0.3
        self.in_cooperation_phase = False
        self.stock_at_cooperation_start = -1.0
        self.stock_after_growth_in_cooperation = -1.0
        self.cooperation_start_round = -1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if history is None:
            return Action.D
        if current_stock > self.threshold_defect:
            if self.in_cooperation_phase and current_stock > self.threshold_defect:
                self.in_cooperation_phase = False
                self.stock_at_cooperation_start = -1.0
                self.stock_after_growth_in_cooperation = -1.0
            return Action.D
        elif current_stock > self.threshold_cooperate_recovery:
            if self.in_cooperation_phase:
                self.in_cooperation_phase = False
                self.stock_at_cooperation_start = -1.0
                self.stock_after_growth_in_cooperation = -1.0
            return Action.D
        else:
            if not self.in_cooperation_phase:
                self.in_cooperation_phase = True
                self.stock_at_cooperation_start = current_stock
                self.cooperation_start_round = current_round
            return Action.C

    def _calculate_consumption(self, action: Action, stock: float) -> float:
        """Helper to calculate consumption for a given action and stock."""
        if action == Action.C:
            return stock / (2 * self.n)
        else:
            return stock / self.n

    def _calculate_stock_growth(self, stock_remaining: float) -> float:
        """Helper to calculate stock growth."""
        return 2 * stock_remaining * (1 - stock_remaining / self.capacity)

    def _adapt_thresholds(self, stock_before_round: float, current_stock_after_round: float, stock_after_consumption_in_round: float):
        """
        Adapt thresholds based on observed stock recovery after cooperation.
        This is a heuristic and can be tuned.
        """
        if self.in_cooperation_phase and self.cooperation_start_round == state.round_number - 1:
            growth_in_prev_round = self._calculate_stock_growth(stock_after_consumption_in_round)
            self.stock_after_growth_in_cooperation = stock_after_consumption_in_round + growth_in_prev_round
            if self.stock_after_growth_in_cooperation < self.capacity * 0.5 and self.stock_after_growth_in_cooperation < self.threshold_cooperate_recovery:
                self.threshold_defect *= 0.98
                self.threshold_cooperate_recovery *= 1.02
            elif self.stock_after_growth_in_cooperation > self.threshold_defect * 1.1 and self.in_cooperation_phase:
                self.threshold_defect *= 1.02
                self.threshold_cooperate_recovery *= 0.98
            self.threshold_defect = max(self.capacity * 0.1, min(self.capacity * 0.9, self.threshold_defect))
            self.threshold_cooperate_recovery = max(self.capacity * 0.05, min(self.capacity * 0.5, self.threshold_cooperate_recovery))
            self.threshold_cooperate_recovery = min(self.threshold_cooperate_recovery, self.threshold_defect - self.capacity * 0.05)

    def update_strategy_state(self, state: CommonPoolState, history: PlayerHistory):
        """
        This method is called by the simulator after a round is played.
        It provides the state of the game *after* the round has concluded,
        and the history *including* the round that just finished.
        """
        current_stock_after_round = state.current_stock
        current_round = state.round_number
        if history is not None and history.round_number > 0:
            round_idx = history.round_number - 1
            if self.in_cooperation_phase and self.cooperation_start_round == round_idx:
                if self.in_cooperation_phase and self.cooperation_start_round == round_idx:
                    my_last_action_bool = history.my_actions[round_idx]
                    my_last_action = Action.C if my_last_action_bool else Action.D
                    opp_last_actions_bool = history.opponent_actions[round_idx, :]
                    opp_last_actions = [Action.C if action else Action.D for action in opp_last_actions_bool]
                    total_consumption_prev_round = self._calculate_consumption(my_last_action, self.stock_at_cooperation_start)
                    for opp_action in opp_last_actions:
                        total_consumption_prev_round += self._calculate_consumption(opp_action, self.stock_at_cooperation_start)
                    stock_after_consumption_prev_round = self.stock_at_cooperation_start - total_consumption_prev_round
                    stock_after_consumption_prev_round = max(0.0, stock_after_consumption_prev_round)
                    if current_stock_after_round < self.capacity * 0.5 and current_stock_after_round < self.threshold_cooperate_recovery:
                        self.threshold_defect *= 0.98
                        self.threshold_cooperate_recovery *= 1.02
                    elif current_stock_after_round > self.threshold_defect * 1.1 and self.in_cooperation_phase:
                        self.threshold_defect *= 1.02
                        self.threshold_cooperate_recovery *= 0.98
                    self.threshold_defect = max(self.capacity * 0.1, min(self.capacity * 0.9, self.threshold_defect))
                    self.threshold_cooperate_recovery = max(self.capacity * 0.05, min(self.capacity * 0.5, self.threshold_cooperate_recovery))
                    self.threshold_cooperate_recovery = min(self.threshold_cooperate_recovery, self.threshold_defect - self.capacity * 0.05)
                    if current_stock_after_round > self.threshold_defect:
                        self.in_cooperation_phase = False
                        self.stock_at_cooperation_start = -1.0
                        self.stock_after_growth_in_cooperation = -1.0
                        self.cooperation_start_round = -1

class Strategy_AGGRESSIVE_98(BaseStrategy):
    """
    Aggressive Predator strategy for the Common Pool Resource Game.

    This strategy aims to maximize individual gain by exploiting the resource
    aggressively when it's abundant, but cooperates to prevent immediate
    resource collapse and ensure future exploitation opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Aggressive Predator strategy.

        Args:
            game_description: An object containing the game's parameters.
        """
        self.game_description = game_description
        self.ABUNDANCE_THRESHOLD_RATIO = 0.75
        self.CRITICAL_MINIMUM_STOCK = 0.0001

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game (round number, current stock).
            history: The history of actions and payoffs for all players.
                     If None, it's the first round.

        Returns:
            The action to take (Action.C or Action.D).
        """
        current_stock = state.current_stock
        current_round = state.round_number
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if current_round == r:
            return Action.D
        if current_stock < self.CRITICAL_MINIMUM_STOCK:
            return Action.C
        if current_stock > self.ABUNDANCE_THRESHOLD_RATIO * capacity:
            return Action.D
        return Action.C

class Strategy_AGGRESSIVE_99(BaseStrategy):
    """
    Aggressive "Predator" Strategy for Common Pool Resource Game.

    This strategy aims to maximize individual gain by defecting by default.
    It becomes more cautious and cooperates only when the stock level falls
    below a dynamically calculated threshold. This threshold adapts based on
    the average depletion rate observed in previous rounds, ensuring a degree
    of self-preservation to avoid complete resource collapse. The strategy
    always defects in the last round to maximize final payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.current_round_num = 0
        self.total_consumption_history = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.current_round_num = state.round_number
        if self.current_round_num == self.r:
            return Action.D
        if self.current_round_num == 1:
            return Action.D
        if history is not None and history.round_number > 0:
            pass
        completed_rounds = history.round_number if history else 0
        if completed_rounds > 0:
            average_depletion_per_round = self.total_consumption_history / completed_rounds
        else:
            average_depletion_per_round = 0.0
        ideal_sustainable_consumption = self.capacity / self.r
        depletion_factor = 0.0
        if ideal_sustainable_consumption > 1e-09:
            depletion_factor = average_depletion_per_round / ideal_sustainable_consumption
        elif average_depletion_per_round > 1e-09:
            depletion_factor = 1.0
        depletion_alert_level_proportion = max(0.2, 1.0 - depletion_factor)
        self.stock_threshold = depletion_alert_level_proportion * self.capacity
        current_stock = state.current_stock
        if current_stock <= self.stock_threshold:
            return Action.C
        else:
            return Action.D

    def update_total_consumption(self, total_consumption_this_round: float):
        """
        Updates the total consumption history for the strategy.
        This method should be called by the game engine after each round.
        """
        self.total_consumption_history += total_consumption_this_round

class Strategy_AGGRESSIVE_100(BaseStrategy):
    """
    Aggressive Strategy: "Exploiter-Adaptive"

    This strategy is designed to be overtly aggressive, aiming to extract as much
    as possible from the common pool. It incorporates adaptive elements to avoid
    self-destruction and to capitalize on opportunities presented by the dynamic
    stock level.

    Decision Rules:
    - Defect if current_stock > defect_threshold (0.8 * capacity)
    - Cooperate if current_stock <= cooperate_trigger (0.2 * capacity)
    - Defect otherwise (between cooperate_trigger and defect_threshold)

    Edge Cases:
    - First Round: Always Defect.
    - Last Round: Always Defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defect_threshold = 0.8 * self.capacity
        self.cooperate_trigger = 0.2 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if history is None:
            return Action.D
        if current_stock > self.defect_threshold:
            return Action.D
        elif current_stock <= self.cooperate_trigger:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_101(BaseStrategy):
    """
    "The Ruthless Accumulator" strategy. This strategy aims to maximize
    individual payoff by defecting by default. It only cooperates when
    the common pool stock falls critically low, or in the final round where
    maximizing immediate payoff is the sole objective.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if history is None:
            return Action.D
        if current_round == self.r - 1:
            return Action.D
        if current_stock <= self.critical_stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_102(BaseStrategy):
    """
    The "Jackhammer" strategy. This strategy aims to aggressively exploit
    the common resource when stock is high and rounds are plentiful,
    but conserves the resource when it becomes critically low or
    when few rounds remain to avoid complete depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.total_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = float(state.current_stock)
        current_round_number = state.round_number
        remaining_rounds = self.total_rounds - current_round_number
        if history is None:
            return Action.D
        my_actions_bool = history.my_actions.astype(bool)
        opponent_actions_bool = history.opponent_actions.astype(bool)
        CRITICAL_STOCK_THRESHOLD = self.capacity / 4.0
        AMPLY_STOCK_THRESHOLD = self.capacity / 2.0
        END_GAME_THRESHOLD = self.total_rounds / 4.0
        if remaining_rounds <= END_GAME_THRESHOLD:
            if current_stock > CRITICAL_STOCK_THRESHOLD:
                return Action.D
            else:
                return Action.C
        elif current_stock > AMPLY_STOCK_THRESHOLD:
            return Action.D
        elif current_stock > CRITICAL_STOCK_THRESHOLD:
            return Action.D
        else:
            return Action.C
        if current_stock <= 0:
            return Action.C

class Strategy_AGGRESSIVE_103(BaseStrategy):
    """
    Aggressive strategy "Greedy Opportunist" that maximizes individual gain
    by extracting heavily when stock is high and rounds remain, and defensively
    cooperating only when stock is critically low to ensure survival, or in the
    last round when stock is low. It defects on the first round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        current_round = state.round_number
        if history is None:
            return Action.D
        rounds_remaining = total_rounds - current_round + 1
        stock_percentage = current_stock / capacity
        if rounds_remaining == 1:
            if stock_percentage > 0.5:
                return Action.D
            else:
                return Action.C
        if stock_percentage > 0.75:
            return Action.D
        elif stock_percentage > 0.5:
            return Action.C
        else:
            return Action.C

class Strategy_AGGRESSIVE_104(BaseStrategy):
    """
    Maximizing Aggression Strategy:
    This strategy prioritizes immediate personal gain by defaulting to defecting (D).
    It only cooperates (C) when the stock level falls critically low to prevent
    immediate depletion and enable future exploitation. It always defects in the
    last round to maximize final payoff and always defects in the first round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if current_stock <= self.critical_stock_threshold:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_105(BaseStrategy):
    """
    Exploitative Forethought Strategy for the Common Pool Resource Game.

    This strategy aims to maximize individual payoff by defecting whenever
    the current stock level is sufficiently high to prevent immediate resource
    collapse. It calculates a dynamic "safe extraction threshold" based on
    remaining rounds, player count, and capacity, ensuring that even with
    aggressive play, the resource has a chance to regenerate. The default
    action is to defect, only cooperating as a precautionary measure when
    the stock level approaches a critical point.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: Historical data from previous rounds. If None, it's the first round.

        Returns:
            The chosen Action (Action.C or Action.D).
        """
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.r:
            return Action.D if current_stock > 0 else Action.C
        rounds_remaining_inclusive = self.r - current_round + 1
        safe_extraction_threshold = rounds_remaining_inclusive * (self.capacity / (2.0 * self.n)) * 1.2
        if current_stock > safe_extraction_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_106(BaseStrategy):
    """
    The 'Predator' strategy is fundamentally about opportunistic exploitation with a
    calculated risk of collapse. It prioritizes extracting as much as possible from
    the common pool, but it incorporates a safety net to prevent immediate,
    self-defeating depletion.

    Decision Rules:
    1. Default to Defect (D).
    2. Cooperate (C) if stock falls below a "panic threshold".
       Panic Threshold: stock <= n * (r - current_round) * 2
    3. Always Defect (D) in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.
        """
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action for the current round based on the state and history.
        """
        current_round = state.round_number
        stock = state.current_stock
        if current_round == self.r:
            return Action.D
        panic_threshold_value = self.n * (self.r - current_round) * 2
        if stock <= panic_threshold_value:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_107(BaseStrategy):
    """
    Aggressive strategy: "Profit Maximizing Exploiter with Bailout".
    This strategy prioritizes Defecting for higher immediate gains but switches to
    Cooperate when the stock level drops below a dynamic 'bailout threshold' to
    prevent resource depletion. The threshold is adaptively adjusted based on
    past stock depletion trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.initial_threshold_percentage = 0.4
        self.min_threshold_percentage = 0.1
        self.max_threshold_percentage = 0.6
        self.percentage_decrease_rate = 0.01
        self.percentage_increase_rate = 0.005
        self.stock_decrease_trigger_ratio = 0.1
        self.consumption_increase_trigger_factor = 1.5
        self.threshold_percentage = self.initial_threshold_percentage
        self.previous_stock = float(self.capacity)
        self.average_consumption_last_round = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == self.n_rounds:
            return Action.D
        bailout_threshold = self.capacity * self.threshold_percentage
        if current_stock <= 0:
            my_action = Action.C if current_stock <= bailout_threshold else Action.D
        elif current_stock > bailout_threshold:
            my_action = Action.D
        else:
            my_action = Action.C
        if history is not None:
            if history.round_number > 0:
                last_round_index = history.round_number - 1
                total_consumption_last_round = 0.0
                my_action_last_round = Action.C if history.my_actions[last_round_index] else Action.D
                consumption_from_me_last_round = current_stock / (2 * self.n_players) if my_action_last_round == Action.C else current_stock / self.n_players
                total_consumption_last_round += consumption_from_me_last_round
                stock_before_last_round = self.previous_stock
                total_consumption_last_round = 0.0
                my_action_last_round_bool = history.my_actions[last_round_index]
                if my_action_last_round_bool:
                    my_consumption_last_round = stock_before_last_round / (2 * self.n_players)
                else:
                    my_consumption_last_round = stock_before_last_round / self.n_players
                total_consumption_last_round += my_consumption_last_round
                for i in range(self.n_players - 1):
                    opponent_action_last_round_bool = history.opponent_actions[last_round_index, i]
                    if opponent_action_last_round_bool:
                        opponent_consumption_last_round = stock_before_last_round / (2 * self.n_players)
                    else:
                        opponent_consumption_last_round = stock_before_last_round / self.n_players
                    total_consumption_last_round += opponent_consumption_last_round
                self.average_consumption_last_round = total_consumption_last_round / self.n_players
                cooperation_consumption_per_player_last_round = stock_before_last_round / (2 * self.n_players)
                stock_change = current_stock - stock_before_last_round
                stock_change_effective = current_stock - stock_before_last_round
                if stock_change_effective < -self.stock_decrease_trigger_ratio * self.capacity:
                    self.threshold_percentage = max(self.min_threshold_percentage, self.threshold_percentage - self.percentage_decrease_rate)
                elif stock_change_effective > -self.stock_decrease_trigger_ratio * self.capacity * 0.5:
                    self.threshold_percentage = min(self.max_threshold_percentage, self.threshold_percentage + self.percentage_increase_rate)
            self.previous_stock = current_stock
        else:
            self.previous_stock = float(self.capacity)
            self.threshold_percentage = self.initial_threshold_percentage
            self.average_consumption_last_round = 0.0
        return my_action

class Strategy_AGGRESSIVE_108(BaseStrategy):
    """
    The "Aggressive Predator" strategy for the Common Pool Resource Game.

    This strategy aims to maximize individual gain by defaulting to defection (D).
    It only cooperates (C) if continuing to defect would lead to a situation where
    the player's estimated future payoff is strictly less than the payoff they
    would have received by cooperating in the current round. This acts as a
    self-preservation mechanism to ensure continued future extraction rather
    than immediate ruin.

    Default Action: Defect (D)
    Cooperate Condition: If defecting today results in an estimated next-round
                         payoff that is less than the payoff from cooperating today.
    Edge Cases: Always defects in the first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if history is None:
            return Action.D
        if current_round == self.r:
            return Action.D
        my_defect_payoff_this_round = current_stock / self.n
        my_cooperate_payoff_this_round = current_stock / (2 * self.n)
        stock_after_my_defect = current_stock - my_defect_payoff_this_round
        if stock_after_my_defect < 0:
            stock_after_my_defect = 0
        growth_from_my_defect = 0.0
        if stock_after_my_defect > 0:
            growth_from_my_defect = 2 * stock_after_my_defect * (1 - stock_after_my_defect / self.capacity)
        estimated_next_round_stock_if_i_defect = stock_after_my_defect + growth_from_my_defect
        estimated_my_next_round_payoff = 0.0
        if estimated_next_round_stock_if_i_defect > 0:
            estimated_my_next_round_payoff = estimated_next_round_stock_if_i_defect / (2 * self.n)
        if estimated_my_next_round_payoff < my_cooperate_payoff_this_round:
            return Action.C
        return Action.D

class Strategy_AGGRESSIVE_109(BaseStrategy):
    """
    The "Ruthless Predator" strategy.

    This strategy prioritizes immediate, maximum individual gain by almost always defecting.
    It only cooperates in extreme, self-preservation scenarios where defecting would lead to
    instantaneous and complete stock annihilation, and the payoff from defecting is negligible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.r = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_stock <= 0:
            return Action.C
        if current_round == self.r:
            return Action.D
        action = Action.D
        if current_stock <= self.capacity / 2.0:
            total_consumption_if_all_defect = current_stock
            if total_consumption_if_all_defect >= current_stock:
                payoff_defect = current_stock / self.n
                if payoff_defect <= 1e-09:
                    action = Action.C
        return action

class Strategy_AGGRESSIVE_110(BaseStrategy):
    """
    Aggressive Extraction Strategy (AES) for the Common Pool Resource Game.

    This strategy defaults to defecting to maximize immediate payoff. It switches
    to cooperating only when the stock level falls below a critical depletion
    threshold to prevent complete resource collapse. It reverts to defecting as
    soon as the stock recovers.

    - Default Action: Defect (D)
    - Cooperation Trigger: Stock Depletion Threshold (SDT) = 25% of capacity.
                          If current_stock < SDT, switch to Cooperate (C).
    - Resumption of Defection: If current_stock >= SDT, switch back to Defect (D).
    - Edge Case (Last Round): Always Defect (D).
    - Edge Case (Stock <= 0): Cooperate (C) as action is impossible otherwise.
    - First Round: Always Defect (D).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_depletion_threshold = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.n_rounds:
            return Action.D
        if current_stock <= 0:
            return Action.C
        if history is None:
            return Action.D
        action = Action.D
        if current_stock < self.stock_depletion_threshold:
            action = Action.C
        return action

class Strategy_AGGRESSIVE_111(BaseStrategy):
    """
    "The Opportunist" Strategy for the Common Pool Resource Game.

    This strategy is aggressive, aiming to maximize individual gain by defecting
    whenever the stock level is high or the payoff difference between defecting
    and cooperating is significant. It only cooperates when the stock is critically
    low or when the gain from defecting is marginal. It always defects in the
    last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.exploitation_threshold = 0.75
        self.survival_threshold = 0.2
        self.minimum_gain_multiplier = 1.5
        self.epsilon = 0.001

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.n_rounds:
            return Action.D
        if current_stock < self.epsilon:
            return Action.C
        cooperation_payoff = current_stock / (2 * self.n_players)
        defection_payoff = current_stock / self.n_players
        stock_ratio = current_stock / self.capacity
        if stock_ratio > self.exploitation_threshold:
            return Action.D
        elif stock_ratio > self.survival_threshold:
            if defection_payoff >= cooperation_payoff * self.minimum_gain_multiplier:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_AGGRESSIVE_112(BaseStrategy):
    """
    The "Resource Raider" strategy is an aggressive, adaptive approach to the Common Pool Resource Game.
    It defaults to defecting to maximize immediate payoff but switches to cooperation if the resource
    stock drops below a predefined "stock preservation threshold" to prevent total depletion and
    enable continued extraction in future rounds. It always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_preservation_threshold_percentage = 0.25
        self.stock_preservation_threshold = self.game_description.capacity * self.stock_preservation_threshold_percentage

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == r:
            return Action.D
        if current_stock < self.stock_preservation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_113(BaseStrategy):
    """
    "The Opportunist" - An aggressive strategy for the Common Pool Resource Game.
    This strategy prioritizes immediate gain by defaulting to Defect (D).
    It employs tactical Cooperation (C) only when the stock level drops below
    a dynamically adjusted threshold, to prevent complete resource depletion.
    The threshold is adjusted based on the previous round's stock depletion levels,
    leaning towards more aggressive exploitation when the stock is robust, and
    becoming slightly more cautious (but still aggressive) when depletion is high.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_cooperate: float = 0.0
        self.last_stock_after_consumption: float = 0.0
        self.last_action_was_defect: bool = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        round_number = state.round_number
        if history is None:
            self.threshold_cooperate = capacity / 2.5
            self.last_stock_after_consumption = capacity
            self.last_action_was_defect = False
            return Action.D
        prev_round_idx = history.round_number - 1
        if prev_round_idx >= 0:
            prev_action_was_defect = not history.my_actions[prev_round_idx]
            prev_round_all_actions_bool = np.concatenate((history.my_actions[prev_round_idx].reshape(-1), history.opponent_actions[prev_round_idx, :]))
            total_consumption_prev = 0
            for i, action_bool in enumerate(prev_round_all_actions_bool):
                if action_bool:
                    total_consumption_prev += current_stock / (2 * n)
                else:
                    total_consumption_prev += current_stock / n
            if prev_action_was_defect:
                if current_stock < capacity / 4:
                    self.threshold_cooperate *= 1 - 0.05
                elif current_stock > capacity / 1.5:
                    self.threshold_cooperate *= 1 + 0.02
            elif current_stock > capacity / 1.5:
                self.threshold_cooperate *= 1 + 0.01
            elif current_stock < capacity / 4:
                self.threshold_cooperate *= 1 - 0.01
        if round_number == self.game_description.n_rounds:
            return Action.D
        if current_stock <= self.threshold_cooperate:
            return Action.C
        return Action.D

    def _update_strategy_state(self, state: CommonPoolState, history: PlayerHistory):
        pass

class Strategy_AGGRESSIVE_114(BaseStrategy):
    """
    Aggressive Strategy: "Maximize Immediate Gain, Punish Deviations"

    This strategy prioritizes immediate self-interest by defecting when the
    common pool resource is abundant. It cooperates only when the resource
    level is critically low to prevent collapse, thereby ensuring future
    opportunities for exploitation. It aims to extract maximum value and
    implicitly punishes over-exploitation by others by conserving the
    resource when threatened.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Aggressive strategy.

        Args:
            game_description: An object containing game parameters.
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.high_reward_threshold = self.capacity * 0.6
        self.cooperation_threshold = self.capacity * 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the common pool game.
            history: The history of actions and payoffs, or None if it's the first round.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        current_round = state.round_number
        if history is None:
            return Action.D
        if current_round == self.r:
            return Action.D
        if current_stock <= self.cooperation_threshold:
            return Action.C
        if current_stock > self.high_reward_threshold:
            return Action.D
        return Action.D

class Strategy_AGGRESSIVE_115(BaseStrategy):
    """
    The Opportunistic Raider strategy. This strategy aims to maximize immediate
    individual gain by defaulting to Defect. It becomes more cautious and
    switches to Cooperate only when the stock level drops below a critical
    threshold, or in specific edge cases like the final round to ensure a
    minimal payoff. It is an adaptive strategy that reacts to resource scarcity
    but doesn't actively try to enforce cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.low_stock_threshold_factor = 1.0 / self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if history is None:
            return Action.D
        low_stock_threshold = self.capacity * self.low_stock_threshold_factor
        if current_round == self.n_rounds:
            if current_stock >= self.n_players:
                return Action.D
            else:
                return Action.C
        if current_stock <= 0:
            return Action.C
        if current_stock < low_stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_116(BaseStrategy):
    """
    Aggressive, Adaptive Strategy for Common Pool Resource Game.
    This strategy aims to maximize individual payoff by exploiting the resource
    aggressively while maintaining a degree of adaptability to prevent immediate
    collapse. It defaults to defecting when the stock is high and cooperates
    when the stock is low or the environment appears to be too aggressive.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like n_players,
                              n_rounds, and capacity.
        """
        self.game_description = game_description
        self.initial_defection_threshold: float = 0.7
        self.adaptation_step: float = 0.05
        self.aggressive_depletion_rate: float = 0.4
        self.conservative_replenish_rate: float = 0.3
        self.critical_stock_level_factor: float = 0.1
        self.defection_threshold: float = self.initial_defection_threshold
        self.stock_at_start_of_previous_round: float = float(game_description.capacity)

    def _calculate_critical_stock_level(self) -> float:
        """Calculates the absolute critical stock level."""
        return self.critical_stock_level_factor * self.game_description.capacity

    def _get_stock_change_ratio(self, stock_prev_start: float, stock_prev_end: float) -> float:
        """
        Calculates the ratio of stock change relative to the starting stock of the previous round.
        Handles division by zero.
        """
        if stock_prev_start <= 0:
            return 0.0
        return (stock_prev_end - stock_prev_start) / stock_prev_start

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs for all players.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.game_description.n_rounds:
            return Action.D
        critical_stock_level = self._calculate_critical_stock_level()
        if current_stock < critical_stock_level:
            return Action.C
        if history is not None and history.round_number > 0:
            stock_prev_start = self.stock_at_start_of_previous_round
            stock_prev_end = current_stock
            stock_change_ratio = self._get_stock_change_ratio(stock_prev_start, stock_prev_end)
            if (stock_prev_start - stock_prev_end) / stock_prev_start > self.aggressive_depletion_rate:
                self.defection_threshold = min(self.defection_threshold + self.adaptation_step, 1.0)
            elif (stock_prev_end - stock_prev_start) / stock_prev_start > self.conservative_replenish_rate:
                self.defection_threshold = max(self.defection_threshold - self.adaptation_step, 0.0)
            self.defection_threshold = max(0.0, min(self.defection_threshold, 1.0))
        self.stock_at_start_of_previous_round = current_stock
        if current_stock / self.game_description.capacity > self.defection_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_117(BaseStrategy):
    """
    Aggressive "Exploit and Replenish" Strategy.

    This strategy aims to maximize individual gain by aggressively exploiting the
    common pool resource, while adapting its aggressiveness based on the perceived
    health of the resource and the behavior of other players. It defaults to
    defecting unless the resource is critically low or the resource depletion
    rate suggests opponents are being more aggressive than anticipated.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.initial_aggressive_threshold = 0.7
        self.aggressive_threshold = self.initial_aggressive_threshold
        self.aggressive_threshold_min = 0.3
        self.aggressive_threshold_max = 0.9
        self.threshold_adjustment_factor = 0.05
        self.stock_history = []
        self.my_consumption_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        self.stock_history.append(current_stock)
        if history is None:
            my_consumption = current_stock / self.n_players
            self.my_consumption_history.append(my_consumption)
            return Action.D
        self._update_aggressive_threshold(history)
        if round_number == self.n_rounds:
            my_consumption = current_stock / self.n_players
            self.my_consumption_history.append(my_consumption)
            return Action.D
        if current_stock < self.n_players:
            my_consumption = current_stock / (2 * self.n_players)
            self.my_consumption_history.append(my_consumption)
            return Action.C
        stock_ratio = current_stock / self.capacity
        if stock_ratio > self.aggressive_threshold:
            my_consumption = current_stock / self.n_players
            self.my_consumption_history.append(my_consumption)
            return Action.D
        else:
            my_consumption = current_stock / (2 * self.n_players)
            self.my_consumption_history.append(my_consumption)
            return Action.C

    def _update_aggressive_threshold(self, history: PlayerHistory):
        """
        Dynamically adjusts the aggressive_threshold based on historical data.

        The threshold is lowered if opponents are depleting the resource faster
        than us, and raised if we are depleting it faster than them.
        """
        num_completed_rounds = history.round_number
        if num_completed_rounds < 2:
            return
        initial_stock_in_history = self.stock_history[0]
        current_stock_in_history = self.stock_history[-1]
        total_depletion_over_history = initial_stock_in_history - current_stock_in_history
        average_stock_depletion_rate = total_depletion_over_history / num_completed_rounds
        total_my_consumption = np.sum(self.my_consumption_history)
        average_my_consumption_rate = total_my_consumption / len(self.my_consumption_history)
        if average_stock_depletion_rate > average_my_consumption_rate:
            adjustment = self.aggressive_threshold * self.threshold_adjustment_factor
            self.aggressive_threshold = max(self.aggressive_threshold_min, self.aggressive_threshold - adjustment)
        elif average_stock_depletion_rate < average_my_consumption_rate:
            adjustment = self.aggressive_threshold * self.threshold_adjustment_factor
            self.aggressive_threshold = min(self.aggressive_threshold_max, self.aggressive_threshold + adjustment)

class Strategy_AGGRESSIVE_118(BaseStrategy):
    """
    Aggressive "Maximize Immediate Gain, Minimize Future Risk" Strategy.
    This strategy prioritizes maximizing individual gain in the current round
    while being acutely aware of the long-term consequences of stock depletion.
    It defines high and low stock thresholds to dictate behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.
        """
        self.game_description = game_description
        self.HIGH_STOCK_THRESHOLD_PERCENTAGE = 0.75
        self.LOW_STOCK_THRESHOLD_PERCENTAGE = 0.25
        self.hst = self.game_description.capacity * self.HIGH_STOCK_THRESHOLD_PERCENTAGE
        self.lst = self.game_description.capacity * self.LOW_STOCK_THRESHOLD_PERCENTAGE

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs for all players.
                     None if it's the first round.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_stock = state.current_stock
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == total_rounds:
            return Action.D
        if current_stock > self.hst:
            return Action.D
        elif current_stock <= self.lst:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_119(BaseStrategy):
    """
    Aggressive Dominance Strategy for the Common Pool Resource Game.

    This strategy aims to maximize individual payoff by leveraging the higher
    immediate reward of defecting, while being mindful of the long-term
    sustainability of the resource to avoid complete collapse. It prioritizes
    self-interest and assumes other players may do the same.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.aggression_zone_threshold = 0.3
        self.moderate_zone_threshold = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: An object containing the current round number and stock level.
            history: An object containing past actions and payoffs. If None,
                     it's the first round.

        Returns:
            Action: The action to take (Action.C or Action.D).
        """
        current_stock = float(state.current_stock)
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        if current_stock <= 0.001:
            return Action.D
        stock_proportion = current_stock / self.capacity
        if stock_proportion < self.aggression_zone_threshold:
            return Action.C
        elif stock_proportion <= self.moderate_zone_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_AGGRESSIVE_120(BaseStrategy):
    """
    "The Predator" Strategy: An aggressive approach to the Common Pool Resource Game.

    This strategy prioritizes maximizing immediate individual payoff by defecting when
    the resource stock is abundant or moderately healthy. It employs a strong
    retaliation mechanism against players who cause significant resource depletion.
    Cooperation is only considered as a last resort for survival or to facilitate
    future exploitation after sustained group cooperation.

    Key Features:
    - Aggressive exploitation when stock is above 30% of capacity.
    - Strong retaliation against players causing significant stock drops.
    - Forced cooperation when stock is critically low (below 30%).
    - Limited "forgiveness" for sustained group cooperation.
    - Always defects in the last round for maximum individual gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.high_stock_threshold = 0.7 * self.capacity
        self.low_stock_threshold = 0.3 * self.capacity
        self.retaliation_stock_drop_percentage = 0.2
        self.forgiveness_rounds = 2

    def _get_stock_from_state(self, state: CommonPoolState) -> float:
        """Safely extracts current stock, ensuring it's within bounds."""
        return max(0.0, min(self.capacity, state.current_stock))

    def _get_previous_round_stock(self, history: PlayerHistory) -> float:
        """Safely retrieves stock from the start of the previous round."""
        if history is None or history.round_number == 0:
            return self.capacity
        if not hasattr(self, '_previous_stock_levels'):
            self._previous_stock_levels = []
        if state.round_number > 0 and state.round_number - 1 < len(self._previous_stock_levels):
            return self._previous_stock_levels[state.round_number - 1]
        elif state.round_number == 1:
            return self.capacity
        else:
            return self.capacity

    def _get_stock_before_last_round(self, history: PlayerHistory) -> float:
        """Gets the stock at the START of the previous round."""
        if history is None or history.round_number == 0:
            return self.capacity
        if hasattr(self, '_last_state_stock'):
            return self._last_state_stock
        else:
            return self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = self._get_stock_from_state(state)
        current_round = state.round_number
        n_players = self.n
        capacity = self.capacity
        if hasattr(self, '_last_state_stock'):
            self._last_state_stock = current_stock
        else:
            self._last_state_stock = current_stock
        if current_round == self.r:
            return Action.D
        if current_stock <= 0:
            return Action.C
        if current_stock > self.high_stock_threshold:
            return Action.D
        elif current_stock > self.low_stock_threshold:
            if history is not None and history.round_number > 0:
                stock_before_last_round = self._get_stock_before_last_round(history)
                stock_after_last_round = current_stock
                stock_start_of_last_round = self._get_stock_before_last_round(history)
                if stock_start_of_last_round > 0 and stock_start_of_last_round - stock_after_last_round > self.retaliation_stock_drop_percentage * stock_start_of_last_round:
                    if stock_start_of_last_round > self.low_stock_threshold:
                        if history.opponent_actions.shape[0] > history.round_number - 1:
                            opponent_actions_last_round = history.opponent_actions[history.round_number - 1, :]
                            my_action_last_round = history.my_actions[history.round_number - 1]
                            opponent_defected = np.where(opponent_actions_last_round == Action.D.value)[0]
                            if len(opponent_defected) > 0:
                                return Action.D
            return Action.D
        else:
            if history is not None and history.round_number > 0:
                stock_start_of_last_round = self._get_stock_before_last_round(history)
                stock_after_last_round = current_stock
                if stock_start_of_last_round > 0 and stock_start_of_last_round - stock_after_last_round > self.retaliation_stock_drop_percentage * stock_start_of_last_round:
                    if history.opponent_actions.shape[0] > history.round_number - 1:
                        opponent_actions_last_round = history.opponent_actions[history.round_number - 1, :]
                        if stock_start_of_last_round > self.low_stock_threshold:
                            opponent_defected = np.where(opponent_actions_last_round == Action.D.value)[0]
                            if len(opponent_defected) > 0:
                                return Action.D
                        opponent_defected = np.where(opponent_actions_last_round == Action.D.value)[0]
                        if len(opponent_defected) > 0:
                            return Action.D
            all_cooperated_recently = True
            if history is not None and current_round >= self.forgiveness_rounds:
                for r_idx in range(current_round - self.forgiveness_rounds, current_round):
                    my_action = history.my_actions[r_idx]
                    opp_actions = history.opponent_actions[r_idx, :]
                    if my_action == Action.D.value or np.any(opp_actions == Action.D.value):
                        all_cooperated_recently = False
                        break
                if all_cooperated_recently:
                    return Action.C
            return Action.C

class Strategy_AGGRESSIVE_121(BaseStrategy):
    """
    Aggressive "Exploit and Survive" Strategy:
    This strategy prioritizes immediate personal gain. It defaults to defecting
    to maximize immediate payoffs. Cooperation is a rare tactical choice made
    only to prevent the complete collapse of the common resource, thereby
    preserving opportunities for future exploitation. The decision to cooperate
    is purely self-serving and aims to extend the player's ability to extract
    value in subsequent rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold_very_high = 0.7
        self.threshold_high = 0.4
        self.threshold_medium = 0.2
        self.threshold_low = 0.05
        self.critical_stock_fraction = 0.01

    def __call__(self, state: CommonPoolState, history: PlayerHistory | None) -> Action:
        stock = state.current_stock
        current_round = state.round_number
        if current_round == self.r:
            return Action.D
        normalized_stock = stock / self.capacity
        if normalized_stock > self.threshold_very_high:
            return Action.D
        if normalized_stock > self.threshold_high:
            return Action.D
        if normalized_stock > self.threshold_medium:
            return Action.D
        if normalized_stock > self.threshold_low:
            consumption_if_defect = stock / self.n
            stock_after_consumption_if_defect = stock - consumption_if_defect
            critical_stock_level = self.capacity * self.critical_stock_fraction
            if stock_after_consumption_if_defect < critical_stock_level:
                return Action.C
            else:
                return Action.D
        if normalized_stock <= self.threshold_low:
            return Action.C
        return Action.C

class Strategy_AGGRESSIVE_122(BaseStrategy):
    """
    The "Maximizer" Strategy: Aggressive Resource Exploitation.

    This strategy prioritizes immediate payoffs by defecting when the common
    pool stock is healthy. It only cooperates when the stock falls below
    predefined thresholds, indicating a risk of collapse, or in the final
    round to maximize last-minute gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.aggressive_threshold_ratio = 0.4
        self.cooperation_trigger_ratio = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.total_rounds:
            return Action.D
        stock_ratio = current_stock / self.capacity
        if stock_ratio < self.aggressive_threshold_ratio:
            return Action.C
        if stock_ratio < self.cooperation_trigger_ratio:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_123(BaseStrategy):
    """
    "Predatory Escalation" Strategy:
    This strategy aggressively defects to maximize immediate payoff, but
    switches to cooperating defensively when the common pool stock falls
    to a level where continued defection would lead to an unsustainable
    stock level in the next round (stock dropping too low after consumption
    and subsequent growth). It prioritizes long-term extraction potential
    only when immediate greedy actions risk resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.n_float = float(self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = float(state.current_stock)
        current_round = state.round_number
        if current_round == self.n_rounds:
            return Action.D
        if current_stock <= 0:
            return Action.C
        consumption_if_defect = current_stock / self.n_float
        potential_stock_after_defect = current_stock - consumption_if_defect
        if potential_stock_after_defect < 0:
            potential_stock_after_defect = 0.0
        growth_at_defect_level = 2.0 * potential_stock_after_defect * (1.0 - potential_stock_after_defect / self.capacity)
        next_stock_if_defect = potential_stock_after_defect + growth_at_defect_level
        if next_stock_if_defect <= self.capacity / 2.0:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_124(BaseStrategy):
    """
    The Predator strategy for the Common Pool Resource Game.

    This strategy aims to maximize individual gain by defecting by default,
    leveraging the higher payoff of defection. It only cooperates
    as a tactical retreat when the stock is critically low or in the final
    round to ensure some payoff rather than risk a complete loss.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) based on the current state.

        Args:
            state: The current state of the game, including round_number and current_stock.
            history: The history of actions and payoffs for all players. None for the first round.

        Returns:
            Action.C if the player chooses to Cooperate, Action.D if Defect.
        """
        current_stock = state.current_stock
        round_number = state.round_number
        action = Action.D
        stock_depletion_threshold = self.capacity / 3.0
        if current_stock < stock_depletion_threshold and round_number > 1:
            action = Action.C
        if round_number == self.r and current_stock < self.capacity / 2.0:
            action = Action.C
        if current_stock < 1.0:
            action = Action.C
        if history is None:
            return Action.D
        return action

class Strategy_AGGRESSIVE_125(BaseStrategy):
    """
    The Apex Predator strategy: Aggressively seeks maximum individual gain by
    prioritizing defection, especially when the resource stock is high.
    It adapts by cooperating defensively when the stock is low or medium AND
    other players are perceived as aggressive, to prevent resource collapse.
    It always defects in the first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.HIGH_STOCK_THRESHOLD_RATIO = 0.75
        self.LOW_STOCK_THRESHOLD_RATIO = 0.25
        self.OPPONENT_AGGRESSION_LOW_THRESHOLD = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 1:
            return Action.D
        if round_number == self.r:
            return Action.D
        if current_stock <= 0:
            return Action.C
        aggression_index = 0.0
        num_opponents = self.n - 1
        if num_opponents > 0 and history is not None:
            previous_round_idx = history.round_number - 1
            opponent_actions_prev_round = history.opponent_actions[previous_round_idx, :]
            total_opponent_defections = np.sum(1 - opponent_actions_prev_round)
            aggression_index = total_opponent_defections / num_opponents
        high_stock_threshold = self.capacity * self.HIGH_STOCK_THRESHOLD_RATIO
        low_stock_threshold = self.capacity * self.LOW_STOCK_THRESHOLD_RATIO
        if current_stock >= high_stock_threshold:
            return Action.D
        elif current_stock > low_stock_threshold:
            if aggression_index <= self.OPPONENT_AGGRESSION_LOW_THRESHOLD:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_AGGRESSIVE_126(BaseStrategy):
    """
    The "Exploiter" strategy is designed to maximize individual payoff by aggressively
    extracting resources from the common pool. It prioritizes immediate gains,
    believing that hesitation will be exploited by other aggressive players.
    The core principle is to defect whenever the potential for immediate gain outweighs
    the long-term risk of stock depletion, and to cooperate only when forced to by
    the game's structure to avoid immediate collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.small_buffer_ratio = 0.05
        self.small_buffer = self.capacity * self.small_buffer_ratio

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == self.n_rounds:
            return Action.D
        if current_stock <= self.small_buffer:
            return Action.C
        if history is None or current_round == 1:
            return Action.D
        stock_ratio = current_stock / self.capacity
        round_ratio = current_round / self.n_rounds
        exploitation_threshold = max(0.1, 0.5 - 0.3 * stock_ratio - 0.1 * round_ratio)
        projected_stock_if_i_defect = current_stock - current_stock / self.n_players - (self.n_players - 1) * current_stock / (2 * self.n_players)
        if current_stock > 0:
            proportion_remaining_if_i_defect = projected_stock_if_i_defect / current_stock
        else:
            proportion_remaining_if_i_defect = 0
        if proportion_remaining_if_i_defect < exploitation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_AGGRESSIVE_127(BaseStrategy):
    """
    Aggressive strategy: "Opportunistic Exploitation with Controlled Burn".
    This strategy aims to maximize immediate gains by defecting when the stock
    is sufficiently high, while employing a controlled burn to prevent immediate
    resource collapse and preserve future exploitation opportunities.
    It cooperates in the last round to ensure payoff in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.
        """
        self.game_description = game_description
        self.exploitation_zone_threshold_factor = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and stock.
            history: The history of actions and payoffs for all players.
                     None for the first round.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_number = state.round_number
        exploitation_zone_threshold = capacity * self.exploitation_zone_threshold_factor
        if current_round_number == r:
            return Action.C
        if current_stock >= exploitation_zone_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_AGGRESSIVE_128(BaseStrategy):
    """
    Profit Maximizer strategy for the Common Pool Resource Game.

    This strategy aims for maximum individual gain by defecting whenever the
    stock is not critically low, only cooperating to prevent immediate ruin.
    It prioritizes short-term advantage and high personal payoff, defecting
    unless the stock falls below a very low threshold (20% of capacity),
    at which point it cooperates minimally to survive for future exploitation.
    In the last round, it always defects to maximize final gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Profit Maximizer strategy.

        Args:
            game_description: An object containing game parameters
                              (n_players, n_rounds, capacity).
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.cooperation_threshold = self.capacity * 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state: An object containing the current state of the game
                   (round_number, current_stock).
            history: An object containing past actions and payoffs,
                     or None if it's the first round.

        Returns:
            The chosen action (Action.C or Action.D).
        """
        current_stock = float(state.current_stock)
        current_round_number = state.round_number
        rounds_remaining = self.r - current_round_number
        if rounds_remaining == 1:
            return Action.D
        if current_stock <= self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COOPERATIVE_105(BaseStrategy):
    """
    The "Sustainable Guardian" strategy for the Common Pool Resource Game.
    This strategy prioritizes long-term stock health and cooperative behavior,
    but adapts by defecting under conditions of critical stock depletion,
    observed persistent defection by opponents, or in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.healthy_threshold = 0.75 * self.capacity
        self.warning_threshold = 0.5 * self.capacity
        self.danger_threshold = 0.25 * self.capacity
        self.defection_retaliation_limit = math.floor(self.n_rounds / 4)
        self.aggressive_consumption_ratio_threshold = 1.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        rounds_played = state.round_number
        if history is None:
            return Action.C
        if rounds_played == self.n_rounds:
            if current_stock >= self.healthy_threshold:
                return Action.C
            else:
                return Action.D
        defection_counts = self._analyze_defection_history(history)
        avg_other_consumption_ratio = self._calculate_avg_other_consumption_ratio(history, current_stock)
        if current_stock <= self.danger_threshold:
            if avg_other_consumption_ratio > self.aggressive_consumption_ratio_threshold:
                return Action.D
            else:
                return Action.C
        elif current_stock <= self.warning_threshold:
            has_aggressive_opponent = False
            for i in range(self.n_players - 1):
                if defection_counts[i] >= self.defection_retaliation_limit:
                    has_aggressive_opponent = True
                    break
            if has_aggressive_opponent:
                return Action.D
            else:
                return Action.C
        elif current_stock >= self.healthy_threshold:
            return Action.C
        else:
            return Action.C

    def _analyze_defection_history(self, history: PlayerHistory) -> list[int]:
        """
        Analyzes the history to count consecutive defections for each opponent.
        Returns a list where each element is the count of consecutive defections
        for a specific opponent.
        """
        n_opponents = self.n_players - 1
        consecutive_defections = [0] * n_opponents
        for r in range(history.round_number - 1, -1, -1):
            for op_idx in range(n_opponents):
                if not history.opponent_actions[r, op_idx]:
                    consecutive_defections[op_idx] += 1
                else:
                    break
        return consecutive_defections

    def _calculate_avg_other_consumption_ratio(self, history: PlayerHistory, current_stock: float) -> float:
        """
        Calculates the average consumption ratio of all other players in previous rounds.
        Ratio is calculated as (total consumption by others) / (potential maximum consumption by others).
        """
        total_consumption_by_others = 0
        total_potential_consumption_by_others = 0
        num_relevant_rounds = 0
        for r in range(history.round_number):
            stock_at_start_of_round = self.capacity
            stock_for_calc = current_stock
            if stock_for_calc > 0:
                other_actions = history.opponent_actions[r, :]
                round_consumption_by_others = 0
                for op_idx in range(self.n_players - 1):
                    if other_actions[op_idx] == Action.C.value:
                        round_consumption_by_others += stock_for_calc / (2 * self.n_players)
                    else:
                        round_consumption_by_others += stock_for_calc / self.n_players
                total_consumption_by_others += round_consumption_by_others
                potential_max_consumption_by_others = (self.n_players - 1) * (stock_for_calc / self.n_players)
                total_potential_consumption_by_others += potential_max_consumption_by_others
                num_relevant_rounds += 1
        if num_relevant_rounds == 0 or total_potential_consumption_by_others == 0:
            return 0.0
        return total_consumption_by_others / num_relevant_rounds / (total_potential_consumption_by_others / num_relevant_rounds)