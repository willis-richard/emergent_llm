"""
Generated LLM strategies for social dilemma games.

This file contains strategy classes generated by LLMs for game theory experiments.
Each strategy is a callable class that implements a specific approach to the game.

Generated with:
- Provider: Client
- Model: gemini-2.5-flash
- Game: common_pool
"""

from dataclasses import dataclass
from enum import Enum
import math
import numpy as np
from numpy.typing import NDArray
import random

from emergent_llm.players import BaseStrategy
from emergent_llm.games import PublicGoodsDescription, CollectiveRiskDescription, CommonPoolDescription, CommonPoolState
from emergent_llm.common import Action, C, D, PlayerHistory, GameState




class Strategy_COLLECTIVE_1(BaseStrategy):
    """
    Adaptive Stock-Aware Punisher (ASAP) strategy for the Common Pool Resource Game.

    This strategy aims to foster and maintain cooperation by using a combination
    of conditional cooperation, proportional punishment, and stock-aware thresholds.
    It prioritizes the collective good but also incorporates self-preservation
    mechanisms when collective efforts fail or are being actively undermined.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.STOCK_CRITICAL_THRESHOLD_FOR_DOOMED_RESOURCE = self.capacity / (self.n_players * 2)
        self.STOCK_RECOVERY_TRIGGER_THRESHOLD = self.capacity / 2
        self.DEFECTION_TOLERANCE_HEALTHY_STOCK = max(1, math.floor(self.n_players / 4))
        self.DEFECTION_TOLERANCE_LOW_STOCK = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        D_count_prev = 0
        if current_round > 0:
            D_count_prev = sum(~history.opponent_actions[-1, :])
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock <= self.STOCK_CRITICAL_THRESHOLD_FOR_DOOMED_RESOURCE and D_count_prev > 0:
            return Action.D
        elif current_stock < self.STOCK_RECOVERY_TRIGGER_THRESHOLD:
            if D_count_prev > self.DEFECTION_TOLERANCE_LOW_STOCK:
                return Action.D
            else:
                return Action.C
        elif D_count_prev > self.DEFECTION_TOLERANCE_HEALTHY_STOCK:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_2(BaseStrategy):
    """
    The Adaptive Collective Sustainer (ACS) strategy aims to promote and maintain cooperation to sustain the common
    resource while being adaptive and robust against exploitation in a tournament setting. It balances collective
    well-being with self-preservation, reacting dynamically to both opponent behavior and the state of the shared stock.

    Core Principles:
    1.  Initiate Cooperation: Start by cooperating to signal willingness for collective benefit.
    2.  Conditional Cooperation: Maintain cooperation as long as others are largely cooperating, but react to
        significant defection.
    3.  Forgiveness: Forgive minor deviations (single defector when n > 2) to encourage re-establishment of cooperation.
    4.  Resource Preservation: Prioritize stock recovery if it's critically low and others are willing to cooperate.
    5.  Self-Preservation & Deterrence: Protect against exploitation by defecting when cooperation breaks down
        or the game is ending.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold_factor: float = 0.25
        self.terminal_phase_rounds: int = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        critical_stock_level = capacity * self.critical_stock_threshold_factor
        forgiveness_active = n_players > 2
        if current_round == 0:
            return Action.C
        if current_round >= n_rounds - self.terminal_phase_rounds:
            return Action.D
        else:
            num_other_defectors = np.sum(~history.opponent_actions[-1, :])
            if current_stock < critical_stock_level:
                if num_other_defectors == 0:
                    return Action.C
                else:
                    return Action.D
            elif num_other_defectors == 0:
                return Action.C
            elif num_other_defectors == 1 and forgiveness_active:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_3(BaseStrategy):
    """
    Adaptive Stock Monitor (ASM) strategy for the Common Pool Resource Game.
    This strategy prioritizes resource sustainability by attempting to maintain
    stock near capacity. It employs conditional cooperation, responding to
    significant collective defection with temporary punishment, and enters a
    recovery mode when stock levels are critically low. It rationally defects
    in the final round.
    """
    _DEFECTION_TOLERANCE_RATIO = 0.2
    _RECOVERY_MODE_THRESHOLD = 0.6
    _PUNISHMENT_DURATION = 2

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round == total_rounds:
            return Action.D
        if state.round_number == 0:
            self.punishment_counter = 0
            return Action.C
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            return Action.D
        prev_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        k_prev = np.sum(~prev_round_opponent_actions)
        defection_rate_prev = k_prev / n_players
        stock_ratio = current_stock / capacity
        if stock_ratio < self._RECOVERY_MODE_THRESHOLD:
            if defection_rate_prev > 0.5:
                return Action.D
            else:
                return Action.C
        elif defection_rate_prev > self._DEFECTION_TOLERANCE_RATIO:
            self.punishment_counter = self._PUNISHMENT_DURATION - 1
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_4(BaseStrategy):
    """
    The Adaptive Stock Steward strategy for the Common Pool Resource game.
    This strategy prioritizes sustainability, adapts its defection tolerance
    based on the common stock level, promotes reciprocal cooperation, and
    plays rationally in the final round. It balances collective well-being
    with individual rationality, adjusting its strictness based on the
    health of the common stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_recovery_threshold = 0.75 * self.capacity
        self.stock_crisis_threshold = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        num_opponent_defectors = np.sum(history.opponent_actions[-1, :] == False)
        my_prev_action_was_D = history.my_actions[-1] == False
        k_D_prev = num_opponent_defectors + (1 if my_prev_action_was_D else 0)
        defection_tolerance_count = 0
        if current_stock < self.stock_crisis_threshold:
            defection_tolerance_count = 0
        elif current_stock < self.stock_recovery_threshold:
            defection_tolerance_count = 0
        elif self.n_players == 2:
            defection_tolerance_count = 0
        else:
            defection_tolerance_count = 1
        if k_D_prev <= defection_tolerance_count:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_5(BaseStrategy):
    """
    Implements the "Collective Warden" strategy for the Common Pool Resource Game.
    This strategy prioritizes long-term resource sustainability, promotes cooperation,
    and conditionally punishes defection. It features a crucial mechanism to preserve
    the resource when it falls below a critical stock level, even at the cost of
    immediate individual gain. It also adapts to terminal rounds for individual payoff maximization.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_LOW_STOCK_THRESHOLD = self.game_description.capacity / self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if state.round_number == 0:
            return Action.C
        if current_round_1_indexed == total_rounds:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        opponent_defectors_count = np.sum(~previous_round_opponent_actions)
        if opponent_defectors_count == 0:
            return Action.C
        elif current_stock < self.CRITICAL_LOW_STOCK_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_6(BaseStrategy):
    """
    The Adaptive Conservationist strategy aims to foster cooperation and ensure the long-term
    sustainability of the common pool resource, while also being robust against exploitative
    behaviors. It adapts its actions based on the current stock level and the observed behavior
    of other players.

    Key features:
    - Starts with cooperation to establish a positive baseline.
    - Defects in the last round to maximize individual payoff, as there are no future consequences.
    - Prioritizes resource recovery: Always cooperates if the stock falls below a critical
      'sustainability_threshold' (25% of capacity), overriding other decision rules. This is
      designed to prevent resource collapse.
    - Reacts to opponent behavior: In intermediate rounds, if the stock is healthy, it observes
      the actions of other players from the previous round. It retaliates by defecting if more
      than `floor((n-1)/2)` opponents defected, otherwise, it continues to cooperate. This threshold
      allows for some tolerance of individual defections before retaliating.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.sustainability_threshold = 0.25 * self.capacity
        self.defect_threshold = math.floor((self.n - 1) / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.C
        elif current_round_1_indexed == self.r:
            return Action.D
        elif current_stock < self.sustainability_threshold:
            return Action.C
        else:
            k_D_observed = np.sum(~history.opponent_actions[state.round_number - 1])
            if k_D_observed > self.defect_threshold:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_7(BaseStrategy):
    """
    Adaptive Collective Resource Guardian (ACRG) strategy.

    This strategy balances collective resource sustainability with individual robustness.
    It cooperates in the first round to signal intent, defects in the last round for
    immediate gain, and in intermediate rounds, it prioritizes resource recovery if
    stock is critically low. Otherwise, it conditionally cooperates or defects based
    on the number of defecting opponents in the previous round, tolerating a small
    number of defections before retaliating.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / 4.0
        self.DEFECTION_TOLERANCE_THRESHOLD = max(1, math.floor(self.n_players / 4))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num = state.round_number
        current_stock = state.current_stock
        if current_round_num == self.n_rounds - 1:
            return Action.D
        if current_round_num == 0:
            return Action.C
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        num_C_opponents_last_round = np.sum(history.opponent_actions[current_round_num - 1])
        num_D_opponents_last_round = self.n_players - 1 - num_C_opponents_last_round
        if num_D_opponents_last_round <= self.DEFECTION_TOLERANCE_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_8(BaseStrategy):
    """
    Adaptive Common Pool Steward (ACPS) strategy.
    This strategy balances individual payoff with resource sustainability by adapting its
    cooperative or defecting behavior based on the current stock level and the observed
    collective actions of other players. It prioritizes resource recovery when stock is low,
    employs a punishment mechanism against collective defection, and defects in the final round
    to maximize terminal payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_RATIO = 0.25
        self.DEFECTION_TOLERANCE_RATIO = 0.2
        self.FORGIVENESS_ROUNDS = 2
        self.punishment_mode = False
        self.cooperative_rounds_observed_since_punishment = 0
        self.max_tolerated_defectors = math.floor(self.game_description.n_players * self.DEFECTION_TOLERANCE_RATIO)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_game_round = state.round_number + 1
        if current_game_round == 1:
            self.punishment_mode = False
            self.cooperative_rounds_observed_since_punishment = 0
            return Action.C
        if current_game_round == self.game_description.n_rounds:
            return Action.D
        num_opponent_defect = np.sum(~history.opponent_actions[state.round_number - 1, :])
        my_action_prev = history.my_actions[state.round_number - 1]
        self_defected_prev = not my_action_prev
        k_D_prev = num_opponent_defect + (1 if self_defected_prev else 0)
        if state.current_stock / self.game_description.capacity < self.CRITICAL_STOCK_RATIO:
            self.punishment_mode = False
            self.cooperative_rounds_observed_since_punishment = 0
            return Action.C
        if self.punishment_mode:
            if k_D_prev <= self.max_tolerated_defectors:
                self.cooperative_rounds_observed_since_punishment += 1
                if self.cooperative_rounds_observed_since_punishment >= self.FORGIVENESS_ROUNDS:
                    self.punishment_mode = False
                    self.cooperative_rounds_observed_since_punishment = 0
                    return Action.C
                else:
                    return Action.D
            else:
                self.cooperative_rounds_observed_since_punishment = 0
                return Action.D
        elif k_D_prev > self.max_tolerated_defectors:
            self.punishment_mode = True
            self.cooperative_rounds_observed_since_punishment = 0
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_9(BaseStrategy):
    """
    Adaptive Collective Sustainer (ACS) strategy for the Common Pool Resource Game.

    This strategy aims for sustainable resource management and long-term collective payoff.
    It starts with cooperation, adapts to observed collective behavior, prioritizes resource
    recovery when stock is low, and defends against exploitation, especially in the endgame.

    Core Philosophy: Starts with trust, adapts to observed collective behavior, prioritizes
    resource recovery when necessary, and protects against exploitation, especially in the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_tolerance_fraction = 0.25
        self.stock_recovery_threshold_fraction = 0.6
        self.cooperation_tolerance_count = self.n * self.cooperation_tolerance_fraction
        self.stock_recovery_threshold = self.capacity * self.stock_recovery_threshold_fraction

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == 0:
            return Action.C
        if current_round_number == self.r - 1:
            return Action.D
        previous_round_index = current_round_number - 1
        num_opponent_cooperators_prev = np.sum(history.opponent_actions[previous_round_index, :])
        num_opponent_defectors_prev = self.n - 1 - num_opponent_cooperators_prev
        my_action_prev_is_cooperate = history.my_actions[previous_round_index]
        my_defection_prev = 1 if not my_action_prev_is_cooperate else 0
        total_defectors_prev = num_opponent_defectors_prev + my_defection_prev
        is_collective_cooperation_sufficient = total_defectors_prev <= self.cooperation_tolerance_count
        if current_stock < self.stock_recovery_threshold:
            if is_collective_cooperation_sufficient:
                return Action.C
            else:
                return Action.D
        elif is_collective_cooperation_sufficient:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_10(BaseStrategy):
    """
    Adaptive Stock-Aware Reciprocity: Aims to promote collective welfare by prioritizing
    the health of the common resource while being adaptive to opponent behavior and
    robust to defection. It balances immediate payoffs with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.TargetStock = float(self.capacity)
        self.RecoveryThreshold = float(self.capacity) / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.r:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        num_defectors_last_round = (~previous_round_opponent_actions).sum()
        if current_stock < self.RecoveryThreshold:
            return Action.C
        elif current_stock < self.TargetStock:
            threshold_for_cooperation = math.ceil(self.n / 4.0)
            if num_defectors_last_round < threshold_for_cooperation:
                return Action.C
            else:
                return Action.D
        else:
            threshold_for_cooperation = math.ceil(self.n / 2.0)
            if num_defectors_last_round < threshold_for_cooperation:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_11(BaseStrategy):
    """
    The Adaptive Collective Steward (ACS) strategy for the Common Pool Resource Game.
    This strategy prioritizes the long-term health of the shared resource. It begins
    cooperatively, monitors collective actions and stock levels, and adapts its behavior.
    It punishes collective defection when the resource is vulnerable but also shows
    forgiveness and reverts to cooperation when players demonstrate sustained cooperative
    behavior or when the resource is abundant. Resource preservation at critical levels
    overrides all other considerations.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD_PCT = 0.2
        self.FORGIVING_STOCK_THRESHOLD_PCT = 0.75
        self.DEFENSIVE_DEFECTION_THRESHOLD_COUNT = 1
        self.COOPERATION_REINFORCEMENT_ROUNDS = 2
        self.consecutive_cooperative_rounds_observed = 0
        self.i_am_currently_punishing = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        my_current_action = None
        if current_round_num_1_indexed == 1:
            my_current_action = Action.C
            self.consecutive_cooperative_rounds_observed = 0
            self.i_am_currently_punishing = False
        elif current_round_num_1_indexed == self.r:
            my_current_action = Action.D
        elif current_stock < self.CRITICAL_STOCK_THRESHOLD_PCT * self.capacity:
            my_current_action = Action.C
            self.i_am_currently_punishing = False
        else:
            num_defectors_last_round = 0
            if state.round_number > 0:
                my_prev_action_was_C = history.my_actions[-1]
                cooperators_last_round = 0
                if my_prev_action_was_C:
                    cooperators_last_round += 1
                cooperators_last_round += np.sum(history.opponent_actions[-1, :])
                num_defectors_last_round = self.n - cooperators_last_round
            if num_defectors_last_round < self.DEFENSIVE_DEFECTION_THRESHOLD_COUNT:
                self.consecutive_cooperative_rounds_observed += 1
            else:
                self.consecutive_cooperative_rounds_observed = 0
            if self.i_am_currently_punishing and self.consecutive_cooperative_rounds_observed >= self.COOPERATION_REINFORCEMENT_ROUNDS:
                self.i_am_currently_punishing = False
            if self.i_am_currently_punishing:
                my_current_action = Action.D
            elif num_defectors_last_round == 0:
                my_current_action = Action.C
            elif current_stock >= self.FORGIVING_STOCK_THRESHOLD_PCT * self.capacity:
                my_current_action = Action.C
            elif num_defectors_last_round >= self.DEFENSIVE_DEFECTION_THRESHOLD_COUNT:
                my_current_action = Action.D
                self.i_am_currently_punishing = True
            else:
                my_current_action = Action.C
        return my_current_action

class Strategy_COLLECTIVE_12(BaseStrategy):
    """
    Adaptive Stock-Aware Collective (ASC) strategy.
    Promotes collective benefit through sustainable resource management, adapting to opponent
    behaviors and prioritizing resource preservation when stock is low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_ratio = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        num_cooperators_others_prev_round = np.sum(history.opponent_actions[-1, :])
        my_action_prev_round_was_C = history.my_actions[-1]
        total_cooperators_prev_round = num_cooperators_others_prev_round + (1 if my_action_prev_round_was_C else 0)
        critical_stock_threshold = self.capacity * self.critical_stock_ratio
        if current_stock < critical_stock_threshold:
            return Action.C
        if self.n_players == 2:
            if total_cooperators_prev_round == self.n_players:
                return Action.C
            else:
                return Action.D
        elif total_cooperators_prev_round >= self.n_players - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_13(BaseStrategy):
    """
    Collective Steward with Adaptive Punishment (CSAP) strategy for the Common Pool Resource Game.
    This strategy prioritizes the sustainability of the common resource by initiating cooperation,
    adapting its behavior based on collective actions and resource health, and applying deterrence
    against widespread defection. It also includes mechanisms for forgiveness and self-preservation
    when the resource is critically low or in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.STOCK_DANGER_THRESHOLD_RATIO = 0.3
        self.STOCK_RECOVERY_THRESHOLD_RATIO = 0.6
        self.WIDESPREAD_DEFECTION_THRESHOLD = math.ceil(self.n / 2)
        self.MIN_COOPERATION_FOR_FORGIVENESS = 1
        self._previous_stock: float | None = None
        self._my_previous_action: Action | None = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        chosen_action: Action
        if current_round == 0:
            chosen_action = Action.C
            self._previous_stock = self.capacity
            self._my_previous_action = chosen_action
            return chosen_action
        if current_round == self.r - 1:
            chosen_action = Action.D
            self._previous_stock = current_stock
            self._my_previous_action = chosen_action
            return chosen_action
        my_action_prev_bool: np.bool_ = history.my_actions[-1]
        observed_opponent_actions_prev: NDArray[np.bool_] = history.opponent_actions[-1, :]
        my_action_prev: Action = Action.C if my_action_prev_bool else Action.D
        k_prev = np.sum(~observed_opponent_actions_prev)
        if my_action_prev == Action.D:
            k_prev += 1
        if current_stock < self.STOCK_DANGER_THRESHOLD_RATIO * self.capacity:
            chosen_action = Action.D
        elif k_prev >= self.WIDESPREAD_DEFECTION_THRESHOLD:
            chosen_action = Action.D
        elif self._previous_stock is not None and current_stock < self._previous_stock and (my_action_prev == Action.C):
            chosen_action = Action.D
        elif k_prev <= self.MIN_COOPERATION_FOR_FORGIVENESS or current_stock >= self.STOCK_RECOVERY_THRESHOLD_RATIO * self.capacity:
            chosen_action = Action.C
        else:
            chosen_action = my_action_prev
        self._previous_stock = current_stock
        self._my_previous_action = chosen_action
        return chosen_action

class Strategy_COLLECTIVE_14(BaseStrategy):
    """
    The "Adaptive Conservationist" strategy balances individual rationality with collective sustainability.
    It initiates cooperation, uses reciprocity to encourage others, and enforces strict conservation
    when the resource is at risk, adapting its behavior based on the current stock level and
    the actions of other players in the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_health_threshold = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num = state.round_number
        current_stock = state.current_stock
        if current_round_num == 0:
            return Action.C
        if current_round_num == self.n_rounds - 1:
            return Action.D
        if current_stock < self.stock_health_threshold:
            return Action.C
        else:
            previous_round_idx = current_round_num - 1
            my_previous_action = history.my_actions[previous_round_idx]
            opponent_previous_actions = history.opponent_actions[previous_round_idx, :]
            total_cooperators_previous_round = int(my_previous_action) + np.sum(opponent_previous_actions)
            d_count = self.n_players - total_cooperators_previous_round
            if d_count == 0:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_15(BaseStrategy):
    """
    The Adaptive Collective Steward (ACS) strategy balances collective resource management with
    self-preservation in a competitive tournament environment. It starts cooperatively,
    prioritizes resource health when the common stock is low, punishes detected defection
    from other players to enforce cooperative norms, and defects in the final round to
    prevent exploitation when future consequences are absent.
    """

    class ACSState(Enum):
        COOPERATING = 1
        PUNISHING = 2
        RECOVERING = 3

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._acs_state = self.ACSState.COOPERATING
        self._acs_punishment_rounds_remaining = 0
        self._stock_panic_threshold_factor = 0.25
        self._punishment_duration = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            self._acs_state = self.ACSState.COOPERATING
            self._acs_punishment_rounds_remaining = 0
            return Action.C
        if current_round == total_rounds - 1:
            return Action.D
        stock_panic_threshold = self._stock_panic_threshold_factor * capacity
        if current_stock < stock_panic_threshold:
            self._acs_state = self.ACSState.RECOVERING
            self._acs_punishment_rounds_remaining = 0
            return Action.C
        my_action_prev_round = history.my_actions[-1]
        num_defectors_prev_round = (1 if not my_action_prev_round else 0) + np.sum(~history.opponent_actions[-1, :])
        if self._acs_state == self.ACSState.RECOVERING and current_stock >= stock_panic_threshold:
            self._acs_state = self.ACSState.COOPERATING
        if self._acs_state == self.ACSState.PUNISHING:
            self._acs_punishment_rounds_remaining -= 1
            if self._acs_punishment_rounds_remaining <= 0:
                self._acs_state = self.ACSState.COOPERATING
        if self._acs_state == self.ACSState.COOPERATING:
            if my_action_prev_round == Action.C and num_defectors_prev_round > 0:
                self._acs_state = self.ACSState.PUNISHING
                self._acs_punishment_rounds_remaining = self._punishment_duration
        if self._acs_state == self.ACSState.PUNISHING:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_16(BaseStrategy):
    """
    The Adaptive Collective Steward (ACS) strategy promotes long-term sustainability of the common
    resource by balancing cooperation with defensive defection. It adapts its behavior based on
    the collective actions of others in the previous round and the current health of the common stock.

    It starts by cooperating, defects in the final round to maximize terminal payoff,
    and in intermediate rounds, it reacts to significant defection by others
    while also considering the criticality of the common resource stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.D_threshold = max(1, math.floor(self.n_players / 3))
        self.critical_stock_level = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        if current_round_number == 0:
            return Action.C
        if current_round_number == self.total_rounds - 1:
            return Action.D
        prev_round_idx = current_round_number - 1
        my_prev_action_is_C = history.my_actions[prev_round_idx]
        num_opponent_cooperators_prev_round = np.sum(history.opponent_actions[prev_round_idx, :])
        num_cooperators_prev_round = int(my_prev_action_is_C) + num_opponent_cooperators_prev_round
        num_defectors_prev_round = self.n_players - num_cooperators_prev_round
        if state.current_stock < self.critical_stock_level:
            if num_defectors_prev_round > self.D_threshold:
                return Action.D
            else:
                return Action.C
        elif num_defectors_prev_round > self.D_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_17(BaseStrategy):
    """
    Adaptive Collective Guardian (ACG) strategy for the Common Pool Resource Game.
    Prioritizes resource sustainability by starting cooperatively,
    punishing significant free-riding, and enforcing unconditional cooperation
    if the resource stock falls to a critical level. Adapts behavior based on
    the number of players, using a Tit-for-Tat approach in 2-player games
    and tolerating a single defector in multi-player games.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if state.current_stock < self.capacity / 2:
            return Action.C
        all_players_prev_actions = np.concatenate((np.array([history.my_actions[-1]]), history.opponent_actions[-1, :]))
        num_cooperators_last_round = np.sum(all_players_prev_actions)
        num_defectors_last_round = self.n_players - num_cooperators_last_round
        if self.n_players == 2:
            if num_defectors_last_round == 0:
                return Action.C
            else:
                return Action.D
        elif num_defectors_last_round <= 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_18(BaseStrategy):
    """
    Adaptive Resource Protector (ARP) strategy for the Common Pool Resource Game.
    This strategy balances collective good (resource sustainability) with individual
    rationality by being initially cooperative, punishing defectors, and working
    to recover the common pool when it's low, while simultaneously defending
    itself against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.DEFECTOR_TOLERANCE_PROPORTION = 0.2
        self.STOCK_CRITICAL_PROPORTION = 0.3
        self.STOCK_HEALTHY_PROPORTION = 0.8
        self.current_mode = 'COOPERATE'

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        my_prev_action_is_C = int(history.my_actions[-1])
        opponent_prev_cooperators = np.sum(history.opponent_actions[-1, :])
        total_cooperators_prev_round = my_prev_action_is_C + opponent_prev_cooperators
        total_players = self.game_description.n_players
        total_defectors_prev_round = total_players - total_cooperators_prev_round
        proportion_defectors_prev_round = total_defectors_prev_round / total_players
        if proportion_defectors_prev_round > self.DEFECTOR_TOLERANCE_PROPORTION:
            self.current_mode = 'PUNISH'
        elif state.current_stock < self.STOCK_CRITICAL_PROPORTION * self.game_description.capacity:
            self.current_mode = 'RECOVER'
        elif state.current_stock >= self.STOCK_HEALTHY_PROPORTION * self.game_description.capacity and proportion_defectors_prev_round <= self.DEFECTOR_TOLERANCE_PROPORTION:
            self.current_mode = 'COOPERATE'
        if self.current_mode == 'COOPERATE':
            return Action.C
        elif self.current_mode == 'PUNISH':
            return Action.D
        elif self.current_mode == 'RECOVER':
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_19(BaseStrategy):
    """
    Adaptive Collective Reciprocity (ACR) strategy for the Common Pool Resource Game.
    This strategy starts cooperatively, adapts based on collective opponent behavior,
    prioritizes resource sustainability, and defends against sustained exploitation.

    Core Principle: Start cooperatively, adapt based on the collective behavior of others,
    prioritize resource sustainability, and defend against sustained exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold = 0.25 * self.game_description.capacity
        self.cooperation_threshold_for_self_C = 0.75
        self.defection_tolerance_threshold = 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        if current_round == 0:
            return Action.C
        if current_round == total_rounds - 1:
            return Action.D
        if current_stock < self.critical_stock_threshold:
            return Action.C
        N_others = n_players - 1
        num_cooperators_others_t_minus_1 = sum(history.opponent_actions[-1, :])
        p_C_others = num_cooperators_others_t_minus_1 / N_others
        my_previous_action_is_C = history.my_actions[-1]
        if p_C_others >= self.cooperation_threshold_for_self_C:
            return Action.C
        elif p_C_others < 1 - self.defection_tolerance_threshold:
            return Action.D
        else:
            return Action.C if my_previous_action_is_C else Action.D

class Strategy_COLLECTIVE_20(BaseStrategy):
    """
    The Sustainable Harvest Pact (SHP) strategy balances collective good with individual protection.
    It adapts its cooperation based on current stock health and observed cooperation from others.
    It prioritizes sustainability by demanding higher cooperation as the resource depletes,
    starts cooperatively, and defects in the final round for immediate gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.INIT_COOPERATE_THRESHOLD = 0.5
        self.CONSERVATIVE_COOPERATE_THRESHOLD = 0.75
        self.CRITICAL_COOPERATE_THRESHOLD = 0.9
        self.STOCK_TIER_HEALTHY = 0.75
        self.STOCK_TIER_LOW = 0.5
        self.STOCK_TIER_CRITICAL = 0.25
        self.STOCK_TIER_DEPLETED = 0.05

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == total_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.C
        stock_ratio = current_stock / capacity
        if stock_ratio < self.STOCK_TIER_DEPLETED:
            return Action.D
        required_threshold = 0.0
        if stock_ratio >= self.STOCK_TIER_HEALTHY:
            required_threshold = self.INIT_COOPERATE_THRESHOLD
        elif stock_ratio >= self.STOCK_TIER_LOW:
            required_threshold = self.CONSERVATIVE_COOPERATE_THRESHOLD
        elif stock_ratio >= self.STOCK_TIER_CRITICAL:
            required_threshold = self.CRITICAL_COOPERATE_THRESHOLD
        else:
            required_threshold = self.CRITICAL_COOPERATE_THRESHOLD
        num_other_cooperators = sum(history.opponent_actions[-1, :])
        num_other_players = n - 1
        proportion_other_cooperators = num_other_cooperators / num_other_players
        if proportion_other_cooperators >= required_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_21(BaseStrategy):
    """
    Collective Sustainability with Adaptive Deterrence and Forgiveness strategy for the Common Pool Resource game.
    This strategy prioritizes long-term resource health by starting cooperatively and forgiving minor defections.
    It adapts by defecting against widespread non-cooperation and cooperates unconditionally when the resource is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = self.capacity / 4.0
        self.forgiveness_count = max(1, math.floor(self.n_players / 3))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_stock < self.critical_stock_threshold:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        num_cooperators_in_prev_round = np.sum(previous_round_opponent_actions)
        num_defectors_in_prev_round = self.n_players - 1 - num_cooperators_in_prev_round
        if num_defectors_in_prev_round > self.forgiveness_count:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_22(BaseStrategy):
    """
    The Stock-and-Reciprocity Guardian (SRG) strategy balances immediate individual
    incentives with the long-term collective sustainability of the common pool resource.
    It prioritizes resource health by cooperating unconditionally when stock is low,
    defaults to cooperation, and punishes significant defection from others to deter
    unsustainable behavior, offering forgiveness after a streak of cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_FACTOR = 0.25
        self.FORGIVENESS_STREAK_REQUIRED = 2
        n = self.game_description.n_players
        if n == 2:
            self.DEFECTION_TOLERANCE_COUNT = 0
        else:
            self.DEFECTION_TOLERANCE_COUNT = max(1, (n - 1) // 3)
        self._my_last_action: Action | None = None
        self._consecutive_cooperation_streak_others: int = 0
        self._punishment_mode_active: bool = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            self._my_last_action = Action.C
            return Action.C
        if current_round_1_indexed == n_rounds:
            self._my_last_action = Action.D
            return Action.D
        if state.current_stock < self.CRITICAL_STOCK_FACTOR * capacity:
            self._punishment_mode_active = False
            self._consecutive_cooperation_streak_others = 0
            self._my_last_action = Action.C
            return Action.C
        num_defectors_last_round = (history.opponent_actions[-1, :] == Action.D.value).sum()
        if num_defectors_last_round <= self.DEFECTION_TOLERANCE_COUNT:
            self._consecutive_cooperation_streak_others += 1
        else:
            self._consecutive_cooperation_streak_others = 0
        action_for_this_round = Action.C
        if self._punishment_mode_active:
            if self._consecutive_cooperation_streak_others >= self.FORGIVENESS_STREAK_REQUIRED:
                action_for_this_round = Action.C
                self._punishment_mode_active = False
            else:
                action_for_this_round = Action.D
        elif num_defectors_last_round > self.DEFECTION_TOLERANCE_COUNT:
            action_for_this_round = Action.D
            self._punishment_mode_active = True
        else:
            action_for_this_round = Action.C
        self._my_last_action = action_for_this_round
        return action_for_this_round

class Strategy_COLLECTIVE_23(BaseStrategy):
    """
    Adaptive Steward: Prioritizes long-term resource sustainability through conditional cooperation,
    punishing defection, and implementing emergency measures for critical stock levels.
    It starts cooperatively, attempts to maintain cooperation, and punishes non-cooperative
    behavior to deter exploitation. It also incorporates an emergency measure to protect the
    resource when it's critically low, signalling the crisis to all players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.DEFECTION_TOLERANCE_COUNT: int = 1
        self.PUNISHMENT_DURATION: int = 2
        self.CRITICAL_STOCK_THRESHOLD_FACTOR: float = 0.25
        self.punishment_active_until_round: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        total_rounds_r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock_S = state.current_stock
        critical_stock_threshold = capacity * self.CRITICAL_STOCK_THRESHOLD_FACTOR
        if current_round_0_indexed == total_rounds_r - 1:
            return Action.D
        if current_stock_S < critical_stock_threshold:
            self.punishment_active_until_round = 0
            return Action.D
        if self.punishment_active_until_round > current_round_0_indexed:
            return Action.D
        elif current_round_0_indexed > 0:
            num_defectors_last_round = sum((1 for action_bool in history.opponent_actions[-1, :] if not action_bool))
            if num_defectors_last_round > self.DEFECTION_TOLERANCE_COUNT:
                self.punishment_active_until_round = current_round_0_indexed + self.PUNISHMENT_DURATION
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_24(BaseStrategy):
    """
    The Adaptive Sustainability Enforcer (ASE) strategy prioritizes long-term resource health.
    It begins cooperatively, then adapts based on observed collective actions and current stock levels.
    It enforces cooperation through conditional retaliation, becoming stricter as the resource depletes,
    but always prioritizes resource recovery if the stock becomes critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_critical = self.capacity / 2
        self.S_warning = self.capacity * 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        num_cooperators_prev_round = sum(history.opponent_actions[current_round_0_indexed - 1, :])
        if history.my_actions[current_round_0_indexed - 1]:
            num_cooperators_prev_round += 1
        if current_stock < self.S_critical:
            return Action.C
        elif self.S_critical <= current_stock < self.S_warning:
            if num_cooperators_prev_round == self.n_players:
                return Action.C
            else:
                return Action.D
        else:
            cooperation_threshold_healthy: int
            if self.n_players <= 4:
                cooperation_threshold_healthy = self.n_players
            else:
                cooperation_threshold_healthy = math.floor(self.n_players * 0.9)
            if num_cooperators_prev_round >= cooperation_threshold_healthy:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_25(BaseStrategy):
    """
    The Adaptive Sustainability & Reciprocity (ASR) strategy for the Common Pool Resource Game.
    This strategy prioritizes the long-term health and sustainability of the common resource.
    It employs a multi-tiered approach based on the current stock level:
    1. Critically Low Stock: Unconditional cooperation to prevent resource collapse.
    2. Recovering Stock: Conditional cooperation, requiring a majority of others to cooperate
       to ensure continued recovery.
    3. Healthy Stock: Forgiving tit-for-tat, rewarding full cooperation and tolerating a single
       defector in larger groups, but punishing more widespread defection.

    The strategy initiates with cooperation and defects only in the final round to maximize
    end-game payoff, recognizing the lack of future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.SCT = self.capacity / 2.0
        self.SRT = 0.75 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.r:
            return Action.D
        others_previous_actions = history.opponent_actions[-1, :]
        num_defectors = np.sum(others_previous_actions == False)
        if current_stock < self.SCT:
            return Action.C
        elif current_stock < self.SRT:
            if num_defectors <= (self.n - 1) / 2.0:
                return Action.C
            else:
                return Action.D
        elif num_defectors == 0:
            return Action.C
        elif num_defectors == 1 and self.n > 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_26(BaseStrategy):
    """
    The "Adaptive Resource Steward" strategy promotes collective sustainability in the
    Common Pool Resource Game. It combines initial cooperation, reactive punishment,
    resource-aware overrides, and a forgiveness mechanism to adapt to dynamic environments.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.my_previous_action: Action = Action.C
        self.my_defect_streak: int = 0
        self.defection_tolerance_count: int = 1
        self.forgiveness_rounds: int = 3
        self.critical_stock_threshold: float = self.capacity / 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == 0:
            self.my_previous_action = Action.C
            self.my_defect_streak = 0
            return Action.C
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        my_action_prev_round_is_C = history.my_actions[current_round_0_indexed - 1]
        opponent_cooperators_prev = np.sum(history.opponent_actions[current_round_0_indexed - 1, :])
        num_cooperators_prev = opponent_cooperators_prev + (1 if my_action_prev_round_is_C else 0)
        num_defectors_prev = self.n_players - num_cooperators_prev
        action_to_take: Action
        if state.current_stock < self.critical_stock_threshold:
            action_to_take = Action.C
        elif self.my_previous_action == Action.D and self.my_defect_streak >= self.forgiveness_rounds:
            action_to_take = Action.C
        elif num_defectors_prev <= self.defection_tolerance_count:
            action_to_take = Action.C
        else:
            action_to_take = Action.D
        if action_to_take == Action.C:
            self.my_defect_streak = 0
        else:
            self.my_defect_streak += 1
        self.my_previous_action = action_to_take
        return action_to_take

class Strategy_COLLECTIVE_27(BaseStrategy):
    """
    The Adaptive Collective Harvester (ACH) strategy promotes collective sustainability
    by adapting its actions based on the common pool's health and observed opponent behavior.
    It aims to foster cooperation but retaliates against significant free-riding or
    when the resource is critically endangered.

    Decision rules:
    - First round: Cooperate to establish a cooperative baseline.
    - Last round: Defect to maximize individual payoff in an end-game scenario.
    - Intermediate rounds:
        - If stock is Healthy (> 50% capacity): Tolerate at most one defector (C), otherwise retaliate (D).
        - If stock is Warning (> 25% and <= 50% capacity): Cooperate only if all others cooperated, otherwise retaliate (D).
        - If stock is Critical (<= 25% capacity): Cooperate only if all others cooperated, otherwise retaliate (D).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_sustainability_threshold = self.capacity * 0.5
        self.stock_danger_threshold = self.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock_level = state.current_stock
        if current_round_number == 0:
            return Action.C
        if current_round_number == self.n_rounds - 1:
            return Action.D
        num_defectors_prev_round = int(np.sum(~history.opponent_actions[-1, :]))
        if current_stock_level > self.stock_sustainability_threshold:
            if num_defectors_prev_round <= 1:
                return Action.C
            else:
                return Action.D
        elif current_stock_level > self.stock_danger_threshold:
            if num_defectors_prev_round == 0:
                return Action.C
            else:
                return Action.D
        elif num_defectors_prev_round == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_28(BaseStrategy):
    """
    Adaptive Sustainer with Resilience strategy for the Common Pool Resource Game.
    This strategy aims for long-term resource sustainability, defaulting to cooperation.
    It adapts to defection by others, tolerating minor free-riding but responding
    defensively to widespread defection. Critically, it prioritizes resource
    recovery by cooperating unconditionally when stock levels are low.
    It defects in the final round for rational self-interest.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_ratio = 0.5
        self.defection_tolerance_threshold = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_zero_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        num_players = self.game_description.n_players
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round_zero_indexed == total_rounds - 1:
            return Action.D
        if current_round_zero_indexed == 0:
            return Action.C
        all_players_actions_previous_round = [history.my_actions[-1]] + list(history.opponent_actions[-1, :])
        num_defectors_t_minus_1 = sum((1 for action_bool in all_players_actions_previous_round if not action_bool))
        if current_stock < capacity * self.critical_stock_ratio:
            return Action.C
        defection_rate = num_defectors_t_minus_1 / num_players
        if num_defectors_t_minus_1 == 0:
            return Action.C
        elif defection_rate <= self.defection_tolerance_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_29(BaseStrategy):
    """
    The "Adaptive Collective Steward" strategy for the Common Pool Resource Game.
    It cooperates initially, defects in the final round, and in intermediate rounds,
    it conditionally cooperates based on the current stock level and the observed
    defections of other players in the previous round. It becomes stricter about
    tolerating defection as the resource stock diminishes.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.STOCK_THRESHOLD_VERY_HIGH = self.capacity * 0.75
        self.STOCK_THRESHOLD_HIGH = self.capacity * 0.5
        self.STOCK_THRESHOLD_MEDIUM = self.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.r - 1:
            return Action.D
        num_other_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
        N_others = self.n - 1
        num_other_defectors_last_round = N_others - num_other_cooperators_last_round
        D_tolerance = 0
        if current_stock > self.STOCK_THRESHOLD_VERY_HIGH:
            D_tolerance = max(0, math.floor(N_others / 2))
        elif current_stock > self.STOCK_THRESHOLD_HIGH:
            D_tolerance = max(0, math.floor(N_others / 3))
        elif current_stock > self.STOCK_THRESHOLD_MEDIUM:
            D_tolerance = max(0, math.floor(N_others / 4))
        else:
            D_tolerance = 0
        if num_other_defectors_last_round <= D_tolerance:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_30(BaseStrategy):
    """
    The Adaptive Sustainability Protocol (ASP) is designed to balance immediate
    individual incentives with the long-term health of the common resource.
    It prioritizes resource preservation, employs conditional cooperation
    based on observed collective actions of other players, and adjusts its
    response based on the current stock level. It also incorporates endgame
    prudence to avoid exploitation in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = 0.5 * self.capacity
        self.VERY_HIGH_STOCK_THRESHOLD = 0.75 * self.capacity
        self.PROMPT_COOPERATION_THRESHOLD = 0.9
        self.TOLERANCE_THRESHOLD = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if state.current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        if current_round_1_indexed == 1:
            return Action.C
        num_others_cooperated = np.sum(history.opponent_actions[-1, :])
        num_others_played = self.n_players - 1
        cooperation_rate_previous_round = num_others_cooperated / num_others_played
        if cooperation_rate_previous_round >= self.PROMPT_COOPERATION_THRESHOLD:
            return Action.C
        if cooperation_rate_previous_round < self.TOLERANCE_THRESHOLD:
            return Action.D
        if state.current_stock >= self.VERY_HIGH_STOCK_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_31(BaseStrategy):
    """
    The "Adaptive Resource Guardian" (ARG) is a collective strategy designed to promote
    long-term sustainability of the common pool resource while remaining robust to
    various opponent behaviors in a tournament setting. It balances cooperation,
    self-protection against exploitation, and critical resource conservation.

    Its core philosophy is:
    - Start Cooperative: Signal willingness to cooperate.
    - Conserve Aggressively when Low: Prioritize the resource's survival above all else.
    - Adaptive Response: Retaliate against widespread defection, but be forgiving.
    - Rational Endgame: Maximize immediate payoff in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_RATIO = 0.25
        self.LOW_STOCK_RATIO = 0.5
        self.DEFECTION_TOLERANCE_PROPORTION = 0.3
        self.PUNISHMENT_DURATION_ROUNDS = 1
        self.rounds_since_significant_defection = math.inf

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r_total = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == r_total - 1:
            return Action.D
        if current_stock < self.CRITICAL_STOCK_RATIO * capacity:
            return Action.C
        if current_stock < self.LOW_STOCK_RATIO * capacity:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.C
        num_defectors_previous_round = (history.opponent_actions[-1, :] == False).sum()
        if num_defectors_previous_round > self.DEFECTION_TOLERANCE_PROPORTION * (n - 1):
            self.rounds_since_significant_defection = 0
        else:
            self.rounds_since_significant_defection += 1
        if self.rounds_since_significant_defection < self.PUNISHMENT_DURATION_ROUNDS:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_32(BaseStrategy):
    """
    The "Adaptive Conservationist" strategy for the Common Pool Resource game.
    This strategy aims to promote collective welfare by sustaining the common pool resource,
    while being robust and adaptive to varying levels of cooperation or defection from
    other players in a tournament setting. It balances ideal collective behavior with
    pragmatic self-interest given the game's incentives.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        if self.n_players == 2:
            self.max_tolerated_D_count = 0
        else:
            self.max_tolerated_D_count = 1
        self.critical_stock_threshold = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.total_rounds - 1:
            return Action.D
        else:
            prev_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1]
            previous_D_count = np.sum(~prev_round_opponent_actions)
            if current_stock < self.critical_stock_threshold:
                if previous_D_count <= self.max_tolerated_D_count:
                    return Action.C
                else:
                    return Action.D
            elif previous_D_count > self.max_tolerated_D_count:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_33(BaseStrategy):
    """
    Collective Guardian strategy for the Common Pool Resource Game.
    This strategy aims to foster cooperation, maintain resource sustainability,
    and be robust against exploitation by adaptive opponents.

    Core Principles:
    1. Initial Trust: Starts by cooperating to signal a willingness for collective action.
    2. Sustainability First: Prioritizes the health of the common resource, especially
       when it falls below a critical threshold (capacity / 2.0). This overrides
       any individualistic or retaliatory impulses.
    3. Adaptive Reciprocity: Rewards collective cooperation and punishes any observed
       defection in the previous round to deter exploitation.
    4. Endgame Optimization: Optimizes individual payoff in the final round when
       long-term resource health is no longer a factor.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD = self.game_description.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == total_rounds:
            return Action.D
        if state.current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        num_opponent_D_prev = np.sum(~history.opponent_actions[-1, :])
        my_prev_action_was_D = not history.my_actions[-1]
        num_D_prev = num_opponent_D_prev + (1 if my_prev_action_was_D else 0)
        if num_D_prev > 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_34(BaseStrategy):
    """
    Adaptive Sustainability Enforcer (ASE) strategy for the Common Pool Resource Game.

    Core Philosophy:
    The ASE strategy aims to establish cooperation from the outset, maintain resource
    sustainability through vigilant monitoring of collective behavior, and intervene
    decisively when the resource is threatened or exploited. It balances the need for
    individual gain with the imperative of collective resource preservation.

    Decision Rules:
    1.  Last Round: Always Defect (D) to maximize final payoff.
    2.  First Round: Always Cooperate (C) to establish a cooperative baseline.
    3.  Intermediate Rounds:
        a.  Stock Recovery Mode: If current_stock < capacity / 2.0, unconditionally Cooperate (C)
            to allow the resource to recover.
        b.  Enforcement Mode: If current_stock >= capacity / 2.0, decide based on previous round's defectors:
            - If 0 defectors: Cooperate (C) to maintain cooperation.
            - If >0 and <n defectors: Defect (D) to punish and deter partial defection.
            - If n defectors: Cooperate (C) to attempt a reset and prevent total collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        game_round = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if game_round == total_rounds:
            return Action.D
        if game_round == 1:
            return Action.C
        self_defected_last_round = not history.my_actions[state.round_number - 1]
        opponent_defectors_last_round = np.sum(~history.opponent_actions[state.round_number - 1, :])
        num_defectors_last_round = (1 if self_defected_last_round else 0) + opponent_defectors_last_round
        if current_stock < capacity / 2.0:
            return Action.C
        elif num_defectors_last_round == 0:
            return Action.C
        elif 0 < num_defectors_last_round < n_players:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_35(BaseStrategy):
    """
    Adaptive Collective Steward (ACS) strategy for the Common Pool Resource Game.
    This strategy aims for sustainable resource management by starting cooperatively,
    strictly punishing any defection from the group for a single round, and adapting
    to end-game dynamics by defecting in the final two rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_rounds_left = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if state.round_number == 0:
            self.punishment_rounds_left = 0
            return Action.C
        if state.round_number == n_rounds - 1:
            return Action.D
        if state.round_number == n_rounds - 2:
            return Action.D
        if self.punishment_rounds_left > 0:
            self.punishment_rounds_left -= 1
            return Action.D
        previous_round_idx = state.round_number - 1
        my_prev_action = history.my_actions[previous_round_idx]
        opponent_prev_actions = history.opponent_actions[previous_round_idx, :]
        all_prev_actions = np.concatenate(([my_prev_action], opponent_prev_actions))
        num_cooperators_prev_round = np.sum(all_prev_actions)
        if num_cooperators_prev_round < n_players:
            self.punishment_rounds_left = 1
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_36(BaseStrategy):
    """
    Adaptive Collective Steward: Fosters cooperation for resource sustainability,
    adapting to opponent behavior and resource health, while protecting against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        if self.n_players == 2:
            self.cooperation_tolerance_window_defectors = 0
        else:
            self.cooperation_tolerance_window_defectors = 1
        self.critical_stock_level = 0.1 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        num_cooperating_opponents_prev_round = np.sum(history.opponent_actions[-1, :])
        prev_defectors = self.n_players - 1 - num_cooperating_opponents_prev_round
        if current_stock < self.critical_stock_level:
            if prev_defectors <= self.cooperation_tolerance_window_defectors:
                return Action.C
            else:
                return Action.D
        elif prev_defectors <= self.cooperation_tolerance_window_defectors:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_37(BaseStrategy):
    """
    The Adaptive Collective Steward (ACS) strategy for the Common Pool Resource Game.

    This strategy balances cooperation, resource stewardship, and reciprocal enforcement
    to achieve long-term sustainability and robust performance. It defaults to
    cooperation, but temporarily defects in response to others' defections
    (Tit-for-Tat style with forgiveness) and prioritizes resource regeneration when
    the common stock is critically low. It also includes an endgame defection
    to prevent exploitation in the final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.my_strategy_state = {'current_mode': 'COOPERATING', 'punishment_rounds_left': 0}
        self.stock_threshold_low = self.game_description.capacity / 4.0
        self.stock_recovery_threshold = self.game_description.capacity * 0.9
        self.punishment_duration = 1
        self.endgame_rounds = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.my_strategy_state['current_mode'] = 'COOPERATING'
            self.my_strategy_state['punishment_rounds_left'] = 0
            return Action.C
        if state.round_number >= self.game_description.n_rounds - self.endgame_rounds:
            return Action.D
        if state.current_stock < self.stock_threshold_low:
            self.my_strategy_state['current_mode'] = 'RECOVERING'
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[state.round_number - 1]
        num_defectors_last_round = np.sum(~previous_round_opponent_actions)
        if self.my_strategy_state['current_mode'] == 'COOPERATING':
            if num_defectors_last_round == 0:
                return Action.C
            else:
                self.my_strategy_state['current_mode'] = 'PUNISHING'
                self.my_strategy_state['punishment_rounds_left'] = self.punishment_duration
                return Action.D
        elif self.my_strategy_state['current_mode'] == 'PUNISHING':
            self.my_strategy_state['punishment_rounds_left'] -= 1
            if self.my_strategy_state['punishment_rounds_left'] > 0:
                return Action.D
            else:
                self.my_strategy_state['current_mode'] = 'COOPERATING'
                return Action.C
        elif self.my_strategy_state['current_mode'] == 'RECOVERING':
            if state.current_stock >= self.stock_recovery_threshold:
                self.my_strategy_state['current_mode'] = 'COOPERATING'
                return Action.C
            else:
                return Action.C

class Strategy_COLLECTIVE_38(BaseStrategy):
    """
    The Adaptive Collective Conservationist (ACC) strategy balances individual payoff 
    maximization with long-term resource sustainability. It adapts its behavior 
    based on the current stock level and the observed actions of players in the 
    previous round.

    - In the first round, it cooperates to establish a baseline for collaboration.
    - In the last round, it defects to maximize final payoff.
    - In intermediate rounds:
        - If the resource is critically low (below S_low_threshold = capacity/4):
            - If all players cooperated previously, it continues to cooperate to aid recovery.
            - If any player defected previously, it defects in desperation.
        - If the resource is not critically low:
            - If all players cooperated previously, it cooperates to reward and maintain good behavior.
            - If any player defected previously, it defects in a Tit-for-Tat manner to deter exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_low_threshold = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number_1_indexed = state.round_number + 1
        current_stock_level = state.current_stock
        if current_round_number_1_indexed == self.n_rounds:
            return Action.D
        elif state.round_number == 0:
            return Action.C
        else:
            opponent_cooperators_prev = np.sum(history.opponent_actions[-1, :])
            my_action_prev = history.my_actions[-1]
            total_cooperators_prev_round = int(my_action_prev) + opponent_cooperators_prev
            n_D_prev = self.n_players - total_cooperators_prev_round
            if current_stock_level < self.S_low_threshold:
                if n_D_prev == 0:
                    return Action.C
                else:
                    return Action.D
            elif n_D_prev == 0:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_39(BaseStrategy):
    """
    The Adaptive Reciprocal Resource Manager (ARRM) strategy navigates the Common Pool Resource Game
    by balancing collective sustainability with individual payoff maximization. It uses a priority-based
    decision system: starting with cooperation, prioritizing resource preservation at critical levels,
    adapting behavior based on observed collective actions (conditional reciprocity),
    and shifting to individual exploitation in the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_critical = self.game_description.capacity / 2
        self.D_tolerance_threshold = math.floor(self.game_description.n_players / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        num_players = self.game_description.n_players
        num_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.C
        previous_cooperations_count = sum(history.opponent_actions[-1, :]) + history.my_actions[-1]
        previous_defections_count = num_players - previous_cooperations_count
        if current_stock <= self.S_critical:
            if previous_cooperations_count >= num_players / 2:
                return Action.C
            else:
                return Action.D
        if current_round_1_indexed >= num_rounds - 1:
            return Action.D
        if previous_defections_count <= self.D_tolerance_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_40(BaseStrategy):
    """
    Collective Stock Guardian (CSG) strategy for the Common Pool Resource Game.
    Prioritizes long-term resource health by defaulting to cooperation,
    but adapts to punish sustained collective over-exploitation and
    self-preserves when the resource is critically endangered.
    """
    _PUNISHMENT_THRESHOLD_STOCK_RATIO: float = 0.8
    _PUNISHMENT_COUNTER: int = 2
    _CRITICAL_STOCK_THRESHOLD_RATIO: float = 0.3

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.rounds_of_depletion: int = 0
        self.previous_round_initial_stock: float | None = None
        self.PUNISHMENT_THRESHOLD_STOCK_RATIO = self._PUNISHMENT_THRESHOLD_STOCK_RATIO
        self.PUNISHMENT_COUNTER = self._PUNISHMENT_COUNTER
        self.CRITICAL_STOCK_THRESHOLD_RATIO = self._CRITICAL_STOCK_THRESHOLD_RATIO

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if current_round == 0:
            self.previous_round_initial_stock = capacity
            return Action.C
        if current_round == r - 1:
            return Action.D
        S_prev = self.previous_round_initial_stock
        if S_prev is None:
            S_prev = current_stock
        S_after_all_C_consumption = S_prev - S_prev / 2
        S_after_all_C_consumption = max(0.0, S_after_all_C_consumption)
        growth_C = 2 * S_after_all_C_consumption * (1 - S_after_all_C_consumption / capacity)
        S_expected_C_after_growth = min(S_after_all_C_consumption + growth_C, capacity)
        if current_stock < S_expected_C_after_growth * self.PUNISHMENT_THRESHOLD_STOCK_RATIO:
            self.rounds_of_depletion += 1
        else:
            self.rounds_of_depletion = 0
        action_for_this_round = Action.C
        if current_stock < self.CRITICAL_STOCK_THRESHOLD_RATIO * capacity:
            action_for_this_round = Action.D
            self.rounds_of_depletion = 0
        elif self.rounds_of_depletion >= self.PUNISHMENT_COUNTER:
            action_for_this_round = Action.D
            self.rounds_of_depletion = 0
        self.previous_round_initial_stock = current_stock
        return action_for_this_round

class Strategy_COLLECTIVE_41(BaseStrategy):
    """
    The Adaptive Stock-Aware Reciprocity (ASAR) strategy.

    This strategy aims to promote long-term resource sustainability while being
    robust and adaptive to opponent behaviors. It prioritizes the health of the
    stock but includes reciprocal mechanisms to prevent exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.stock_critical_threshold = max(1.0, capacity / (2 * n))
        self.stock_recovery_threshold = capacity / 2.0
        self.defection_tolerance_healthy = 0
        self.defection_tolerance_recovery = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        observed_defect_count_others = np.sum(~history.opponent_actions[-1, :])
        if state.current_stock < self.stock_critical_threshold:
            return Action.C
        elif state.current_stock < self.stock_recovery_threshold:
            if observed_defect_count_others > self.defection_tolerance_recovery:
                return Action.D
            else:
                return Action.C
        elif observed_defect_count_others > self.defection_tolerance_healthy:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_42(BaseStrategy):
    """
    The Adaptive Resource Guardian (ARG) strategy is designed to promote and sustain cooperation
    in the Common Pool Resource Game, while being robust against exploitation and adaptable to
    varying game states and opponent behaviors. It aligns with a collective mindset by
    prioritizing resource sustainability and fostering re-cooperation, yet incorporates
    self-preservation mechanisms essential for a competitive tournament environment.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD_RATIO = 0.2
        self.RECOVERY_STOCK_THRESHOLD_RATIO = 0.7
        self.COOPERATION_TOLERANCE = 0 if self.game_description.n_players == 2 else 1
        self.FORGIVENESS_ROUNDS = 1
        self._my_action_last_round: Action = Action.C
        self._other_players_cooperated_streak: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        critical_stock_threshold = self.CRITICAL_STOCK_THRESHOLD_RATIO * self.game_description.capacity
        recovery_stock_threshold = self.RECOVERY_STOCK_THRESHOLD_RATIO * self.game_description.capacity
        if state.round_number == 0:
            self._my_action_last_round = Action.C
            self._other_players_cooperated_streak = 0
            return Action.C
        num_other_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
        num_other_defectors_last_round = self.game_description.n_players - 1 - num_other_cooperators_last_round
        if num_other_defectors_last_round == 0:
            self._other_players_cooperated_streak += 1
        else:
            self._other_players_cooperated_streak = 0
        if state.current_stock <= critical_stock_threshold:
            self._my_action_last_round = Action.D
            return Action.D
        if num_other_defectors_last_round > self.COOPERATION_TOLERANCE:
            self._my_action_last_round = Action.D
            return Action.D
        if self._my_action_last_round == Action.D and num_other_defectors_last_round == 0 and (self._other_players_cooperated_streak >= self.FORGIVENESS_ROUNDS) and (state.current_stock >= recovery_stock_threshold):
            self._my_action_last_round = Action.C
            return Action.C
        self._my_action_last_round = Action.C
        return Action.C

class Strategy_COLLECTIVE_43(BaseStrategy):
    """
    The Adaptive Sustainable Collective (ASC) strategy balances collective resource preservation
    with self-protection against exploitation in a dynamic common pool resource game.
    It adapts its decision based on the current health of the shared resource and the
    observed behavior of other players, prioritizing resource sustainability through
    conditional cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_ratio = 0.25
        self.recovery_stock_ratio = 0.5
        self.forgiveness_threshold_recovery = 0.25
        self.forgiveness_threshold_healthy = 0.05

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == total_rounds:
            return Action.D
        num_opponents = n_players - 1
        opponent_defection_rate = 0.0
        if num_opponents > 0:
            num_cooperators_prev_round = np.sum(history.opponent_actions[state.round_number - 1, :])
            num_defectors_prev_round = num_opponents - num_cooperators_prev_round
            opponent_defection_rate = num_defectors_prev_round / num_opponents
        current_stock_ratio = state.current_stock / self.game_description.capacity
        if current_stock_ratio < self.critical_stock_ratio:
            return Action.C
        elif current_stock_ratio < self.recovery_stock_ratio:
            if opponent_defection_rate <= self.forgiveness_threshold_recovery:
                return Action.C
            else:
                return Action.D
        elif opponent_defection_rate <= self.forgiveness_threshold_healthy:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_44(BaseStrategy):
    """
    Adaptive Conservationist strategy for the Common Pool Resource Game.

    This strategy aims to balance collective resource sustainability with individual
    payoff maximization in a tournament setting. It starts cooperatively,
    monitors collective behavior by comparing actual stock to an ideal cooperative
    outcome, reciprocates defection if the resource is significantly depleted,
    and defects in the final round to optimize for immediate gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        self.stock_history.append(current_stock)
        if current_stock <= 0.0001:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.r - 1:
            return Action.D
        S_prev = self.stock_history[current_round_0_indexed - 1]
        S_remaining_after_all_C_consumption = S_prev / 2.0
        S_remaining_after_all_C_consumption = max(0.0, S_remaining_after_all_C_consumption)
        growth_if_all_C = 2 * S_remaining_after_all_C_consumption * (1 - S_remaining_after_all_C_consumption / self.capacity)
        S_expected_if_all_C_prev_round = min(S_remaining_after_all_C_consumption + growth_if_all_C, self.capacity)
        tolerance_factor = 0.98
        if current_stock < S_expected_if_all_C_prev_round * tolerance_factor:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_45(BaseStrategy):
    """
    The Adaptive Conservationist strategy aims to maximize collective long-term payoff by promoting
    sustainable resource management, adapting to observed opponent behavior, and employing forgiveness.
    It prioritizes resource preservation when stock is low, uses adaptive reciprocity based on
    previous round's collective actions, and strategically defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.STOCK_CRITICAL_THRESHOLD_PROPORTION = 0.5
        self.TOLERATED_DEFECTION_PROPORTION = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == n_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.C
        if current_stock < self.STOCK_CRITICAL_THRESHOLD_PROPORTION * capacity:
            return Action.C
        else:
            previous_round_my_action = history.my_actions[-1]
            previous_round_opponent_actions = history.opponent_actions[-1, :]
            all_previous_round_actions = np.concatenate(([previous_round_my_action], previous_round_opponent_actions))
            num_defectors_last_round = n_players - np.sum(all_previous_round_actions)
            if num_defectors_last_round == 0:
                return Action.C
            else:
                proportion_defectors = num_defectors_last_round / n_players
                if proportion_defectors <= self.TOLERATED_DEFECTION_PROPORTION:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_46(BaseStrategy):
    """
    The Sustainable Reciprocity (SR) strategy aims to promote collective sustainability of the common
    pool resource while being robust and adaptive to various opponent behaviors. It balances
    cooperation for long-term resource health with individual protection against exploitation.

    This strategy initiates cooperation, tolerates a single defector, but retaliates against
    widespread defection. It crucially prioritizes resource conservation by cooperating
    unconditionally when the stock is critically low, overriding other considerations.
    In the final round, it defects to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_tolerance_limit = 1
        self.critical_stock_threshold = self.game_description.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_0_indexed_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        if current_0_indexed_round == total_rounds - 1:
            return Action.D
        if current_0_indexed_round == 0:
            return Action.C
        if current_stock < self.critical_stock_threshold:
            return Action.C
        else:
            num_other_cooperators = np.sum(history.opponent_actions[-1, :])
            num_other_defectors = n_players - 1 - num_other_cooperators
            if num_other_defectors <= self.defection_tolerance_limit:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_47(BaseStrategy):
    """
    Dynamic Sustainability Guard: A strategy for the Common Pool Resource Game that prioritizes
    maintaining a healthy common pool resource. It defaults to cooperation but adapts by defecting
    if the current stock level falls below a critical threshold (half of the capacity).
    In the final round, it always defects to maximize immediate payoff, as there are no future
    consequences for the resource. This strategy relies solely on observable game state and
    parameters, ensuring robustness in a tournament environment.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_critical = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.S_critical:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_48(BaseStrategy):
    """
    The Collective Steward strategy aims to foster cooperation and ensure resource sustainability
    in the Common Pool Resource Game. It prioritizes resource preservation by cooperating
    when stock is critically low, and defaults to cooperation to establish a positive norm.
    It punishes significant collective defection to deter free-riding but tolerates minor
    transgressions to avoid punishment spirals. In the final round, it defects to maximize
    payoff due to the absence of future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = self.capacity / 4.0
        self.defection_tolerance_percent = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if state.current_stock < self.critical_stock_threshold:
            return Action.C
        if state.round_number == 0:
            return Action.C
        num_defectors_prev_round = 0
        if not history.my_actions[-1]:
            num_defectors_prev_round += 1
        num_defectors_prev_round += np.sum(~history.opponent_actions[-1, :])
        if num_defectors_prev_round == 0:
            return Action.C
        else:
            defection_proportion = num_defectors_prev_round / self.n_players
            if defection_proportion > self.defection_tolerance_percent:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_49(BaseStrategy):
    """
    Collective Adaptive Resource Strategy (CARS) for the Common Pool Resource Game.

    This strategy aims to foster cooperation for the long-term health of the common resource.
    It starts cooperatively, rewards continued cooperation, and prioritizes resource
    preservation when stock levels are low. However, it is not naive; it will defect
    to punish widespread exploitation and prevent its own demise, adapting to the
    observed behavior of other players.

    Assumptions: This strategy assumes the current stock can range up to `capacity`,
    consistent with common interpretations of the Common Pool Resource game and
    the provided example calculations, despite a potential contradiction in the
    problem's `STATE` definition when n=4, capacity=100 (where 2n=8).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.LOW_STOCK_THRESHOLD = self.capacity / 4.0
        self.FORGIVENESS_THRESHOLD = max(1, math.floor((self.n_players - 1) / 4.0))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == 0:
            return Action.C
        if current_round_number == self.n_rounds - 1:
            return Action.D
        else:
            if current_stock < self.LOW_STOCK_THRESHOLD:
                return Action.C
            previous_round_opponent_actions = history.opponent_actions[-1, :]
            num_opponents_defected = np.sum(previous_round_opponent_actions == False)
            if num_opponents_defected <= self.FORGIVENESS_THRESHOLD:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_50(BaseStrategy):
    """
    Adaptive Reciprocity with Resource Conservation strategy for the Common Pool Resource Game.

    This strategy balances cooperative sustainability with self-protection and
    resource conservation. It starts cooperative, adapts its reciprocity based
    on the collective behavior of other players, prioritizes resource
    conservation when stock is critically low, and acts self-interestedly in
    the final round.
    """
    _DEFAULT_COOPERATION_THRESHOLD = 0.5
    _DEFAULT_CRITICAL_STOCK_THRESHOLD_FRACTION = 0.3

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self._cooperation_threshold = self._DEFAULT_COOPERATION_THRESHOLD
        self._critical_stock_threshold_fraction = self._DEFAULT_CRITICAL_STOCK_THRESHOLD_FRACTION

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.total_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.C
        prev_round_idx = current_round - 1
        prev_round_my_action = history.my_actions[prev_round_idx]
        prev_round_opponent_actions = history.opponent_actions[prev_round_idx, :]
        all_prev_round_actions = np.concatenate(([prev_round_my_action], prev_round_opponent_actions))
        num_cooperators_prev_round = np.sum(all_prev_round_actions)
        fraction_cooperators_prev_round = num_cooperators_prev_round / self.n_players
        if current_stock < self._critical_stock_threshold_fraction * self.capacity:
            return Action.C
        elif fraction_cooperators_prev_round >= self._cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_51(BaseStrategy):
    """
    The Adaptive Collective Sustainer (ACS) strategy balances collective resource sustainability with
    individual self-protection. It starts cooperatively, dynamically adjusts its cooperation
    threshold based on resource health (stock level), and retaliates against insufficient
    cooperation from other players. It aims to promote long-term sustainability while being
    robust against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.HIGH_STOCK_THRESHOLD = self.capacity * 0.75
        self.LOW_STOCK_THRESHOLD = self.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        k_others_prev = sum(history.opponent_actions[-1, :])
        others_cooperation_rate = k_others_prev / (self.n_players - 1)
        current_cooperation_threshold_others: float
        if current_stock >= self.HIGH_STOCK_THRESHOLD:
            current_cooperation_threshold_others = 0.5
        elif current_stock >= self.LOW_STOCK_THRESHOLD:
            current_cooperation_threshold_others = 0.75
        else:
            current_cooperation_threshold_others = 0.9
        if others_cooperation_rate >= current_cooperation_threshold_others:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_52(BaseStrategy):
    """
    Adaptive Collective Cooperator (ACC) strategy for the Common Pool Resource game.
    Aims to foster cooperation for long-term sustainability by prioritizing resource recovery
    when stock is low, maintaining cooperation with minor defections, and retaliating
    against significant exploitation, while defecting pragmatically in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.FTD = 1
        self.SST_ratio = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        my_prev_action_was_D = not history.my_actions[-1]
        num_opponent_D_prev = np.sum(~history.opponent_actions[-1, :])
        D_prev_count = num_opponent_D_prev + (1 if my_prev_action_was_D else 0)
        S_ratio = current_stock / capacity if capacity > 0 else 0.0
        if S_ratio < self.SST_ratio:
            return Action.C
        elif D_prev_count <= self.FTD:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_53(BaseStrategy):
    """
    Adaptive Resource Steward (ARS) strategy for the Common Pool Resource Game.
    Prioritizes long-term resource health, adapts to opponent behavior, and defends against exploitation.
    It cooperates by default, defends the resource when critically low, and retaliates
    against widespread defection from other players while remaining open to renewed cooperation.
    """
    _CRITICAL_STOCK_THRESHOLD_RATIO = 0.25
    _DEFECTION_PROPORTION_TOLERANCE = 0.5

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold_ratio = self._CRITICAL_STOCK_THRESHOLD_RATIO
        self.defection_proportion_tolerance = self._DEFECTION_PROPORTION_TOLERANCE

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        critical_stock_threshold = capacity * self.critical_stock_threshold_ratio
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.C
        if current_stock <= critical_stock_threshold:
            return Action.C
        num_others = n_players - 1
        num_others_cooperated = np.sum(history.opponent_actions[-1, :])
        num_others_defected = num_others - num_others_cooperated
        proportion_others_defected = num_others_defected / num_others
        if proportion_others_defected > self.defection_proportion_tolerance:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_54(BaseStrategy):
    """
    The Adaptive Resource Steward (ARS) strategy for the Common Pool Resource Game.

    ARS is designed for pragmatic collectivism, balancing long-term resource health
    with individual self-preservation in a competitive environment. It starts with
    cooperation, but adapts by punishing widespread defection, and shifts to a
    "salvage" mode by defecting if the common resource falls below a critical threshold.
    In the final round, it defects to maximize immediate payoff, as future consequences
    are irrelevant.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / (2 * self.n)
        self.DEFECTION_PROPORTION_THRESHOLD = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.r - 1:
            return Action.D
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.D
        my_action_prev_round_is_C = history.my_actions[current_round_0_indexed - 1]
        num_opponent_cooperators_prev_round = history.opponent_actions[current_round_0_indexed - 1, :].sum()
        total_cooperators_prev_round = int(my_action_prev_round_is_C) + num_opponent_cooperators_prev_round
        total_defectors_prev_round = self.n - total_cooperators_prev_round
        defection_proportion = total_defectors_prev_round / self.n
        if defection_proportion > self.DEFECTION_PROPORTION_THRESHOLD:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_55(BaseStrategy):
    """
    Adaptive Collective Steward: A strategy for common pool resource games
    that aims for sustainable resource management. It adapts its cooperation
    based on current stock levels and observed collective behavior in the
    previous round, balancing the collective good with self-preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        num_cooperators_prev_round = sum(history.opponent_actions[-1, :])
        if history.my_actions[-1]:
            num_cooperators_prev_round += 1
        num_defectors_prev_round = self.n_players - num_cooperators_prev_round
        stock_10_percent_capacity = 0.1 * self.capacity
        stock_50_percent_capacity = 0.5 * self.capacity
        if current_stock < stock_10_percent_capacity:
            if num_defectors_prev_round >= self.n_players / 2.0:
                return Action.D
            else:
                return Action.C
        elif current_stock < stock_50_percent_capacity:
            if num_defectors_prev_round == 0:
                return Action.C
            else:
                return Action.D
        elif num_defectors_prev_round == 0:
            return Action.C
        elif num_defectors_prev_round == 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_56(BaseStrategy):
    """
    The Adaptive Steward strategy aims for sustainable resource management by balancing
    cooperation, reciprocity, and self-preservation. It adapts its behavior based on
    the common pool's health and opponents' past actions. It starts cooperatively,
    defects in the final round for rational self-interest, and employs thresholds
    to maintain healthy stock levels or react to critical depletion. It punishes
    defection by others and includes a self-correction mechanism if its own
    defection caused resource decline when others cooperated.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOPERATION_MAINTAIN_STOCK_PERCENTAGE = 0.9
        self.DANGER_STOCK_PERCENTAGE = 0.2
        self.PUNISHMENT_THRESHOLD_DEFECTORS = 1
        self.stock_history: list[float] = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_1_indexed == total_rounds:
            return Action.D
        S_at_start_of_prev_round = self.stock_history[current_round_0_indexed - 1]
        actions_prev_round_bool = history.opponent_actions[current_round_0_indexed - 1, :]
        num_others_defected_prev = np.sum(~actions_prev_round_bool)
        if current_stock <= capacity * self.DANGER_STOCK_PERCENTAGE:
            return Action.D
        elif current_stock >= capacity * self.COOPERATION_MAINTAIN_STOCK_PERCENTAGE:
            if num_others_defected_prev >= self.PUNISHMENT_THRESHOLD_DEFECTORS:
                return Action.D
            else:
                return Action.C
        elif current_stock >= S_at_start_of_prev_round:
            return Action.C
        elif num_others_defected_prev >= self.PUNISHMENT_THRESHOLD_DEFECTORS:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_57(BaseStrategy):
    """
    The Common Pool Sentinel (CPS) strategy is designed for the Common Pool Resource Game.
    It prioritizes collective sustainability by starting with cooperation, but adapts its
    behavior based on observed opponent actions and the health of the common resource.
    It incorporates mechanisms for reciprocity, forgiveness, and resource conservation,
    while optimizing for immediate gain in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        if self.n_players == 2:
            self.FORGIVENESS_THRESHOLD = 0
        else:
            self.FORGIVENESS_THRESHOLD = 1
        self.CRITICAL_STOCK_RATIO = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_idx = state.round_number
        if current_round_idx == 0:
            return Action.C
        elif current_round_idx == self.n_rounds - 1:
            return Action.D
        else:
            k_D_prev = np.sum(~history.opponent_actions[-1, :])
            if state.current_stock < self.capacity * self.CRITICAL_STOCK_RATIO:
                if k_D_prev > self.FORGIVENESS_THRESHOLD:
                    return Action.D
                else:
                    return Action.C
            elif k_D_prev == 0:
                return Action.C
            elif k_D_prev <= self.FORGIVENESS_THRESHOLD:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_58(BaseStrategy):
    """
    Adaptive Collective Resource Manager (ACRM) strategy for the Common Pool Resource Game.
    This strategy is designed for long-term resource sustainability and tournament performance.
    It prioritizes conditional cooperation, strong resource preservation, and adaptive responses
    to observed opponent behavior, while acknowledging end-game incentives.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_total_players = self.game_description.n_players
        n_total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == n_total_rounds - 1:
            return Action.D
        if current_round_number == 0:
            return Action.C
        stock_critical_threshold = capacity / 2.0
        if current_stock <= stock_critical_threshold:
            return Action.C
        num_opponent_defectors = np.sum(~history.opponent_actions[-1, :])
        my_previous_action_was_defect = not history.my_actions[-1]
        num_total_defectors_prev_round = num_opponent_defectors + (1 if my_previous_action_was_defect else 0)
        defection_trigger_count: int
        if n_total_players <= 4:
            defection_trigger_count = 1
        else:
            defection_trigger_count = math.floor(n_total_players / 4.0) + 1
        if num_total_defectors_prev_round >= defection_trigger_count:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_59(BaseStrategy):
    """
    The "Adaptive Resource Guardian (ARG)" strategy for the Common Pool Resource Game.
    It prioritizes long-term sustainability by starting with cooperation, applying
    contingent punishment for collective defection, allowing forgiveness, and
    prioritizing recovery when stock is critical. It defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishing_rounds_remaining: int = 0
        self.consecutive_rounds_collective_defection: int = 0
        self.CRITICAL_STOCK_FACTOR: float = 0.25
        self.DEFECTION_THRESHOLD_PROPORTION: float = 0.33
        self.TOLERANCE_ROUNDS_BEFORE_PUNISHMENT: int = 1
        self.PUNISHMENT_DURATION_ROUNDS: int = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        actual_round_number = state.round_number + 1
        if actual_round_number == 1:
            self.punishing_rounds_remaining = 0
            self.consecutive_rounds_collective_defection = 0
            return Action.C
        if actual_round_number == self.game_description.n_rounds:
            return Action.D
        critical_stock_threshold = self.CRITICAL_STOCK_FACTOR * self.game_description.capacity
        if state.current_stock < critical_stock_threshold:
            self.punishing_rounds_remaining = 0
            self.consecutive_rounds_collective_defection = 0
            return Action.C
        if self.punishing_rounds_remaining > 0:
            self.punishing_rounds_remaining -= 1
            return Action.D
        num_other_players = self.game_description.n_players - 1
        num_other_defectors_last_round = num_other_players - np.sum(history.opponent_actions[-1, :])
        is_collective_defection_last_round = False
        if num_other_defectors_last_round > 0 and num_other_defectors_last_round / num_other_players >= self.DEFECTION_THRESHOLD_PROPORTION:
            is_collective_defection_last_round = True
        if is_collective_defection_last_round:
            self.consecutive_rounds_collective_defection += 1
        else:
            self.consecutive_rounds_collective_defection = 0
        if self.consecutive_rounds_collective_defection > self.TOLERANCE_ROUNDS_BEFORE_PUNISHMENT:
            self.punishing_rounds_remaining = self.PUNISHMENT_DURATION_ROUNDS - 1
            self.consecutive_rounds_collective_defection = 0
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_61(BaseStrategy):
    """
    The Adaptive Collective Sustainer strategy aims to balance individual incentives with the
    long-term sustainability of the common pool resource. It prioritizes the health of the
    shared stock while adapting to the observed behavior of other players.

    Core Principles:
    1. Resource Preservation First: Prioritizes stock recovery when critically low.
    2. Default Cooperation: Starts and defaults to cooperation under healthy conditions.
    3. Adaptive Retaliation: Responds to significant defection to deter free-riding.
    4. Forgiveness: Tolerates minor defections to prevent a permanent spiral into defection.
    5. End-Game Rationality: Defects in the final round due to altered incentives.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_recovery_mode_threshold: float = self.game_description.capacity / 2.0
        self.max_tolerable_D_count: int = self.game_description.n_players // 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round_0_indexed == 0:
            return Action.C
        elif current_round_0_indexed == total_rounds - 1:
            return Action.D
        else:
            num_cooperating_opponents = sum(history.opponent_actions[-1, :])
            num_defecting_opponents = self.game_description.n_players - 1 - num_cooperating_opponents
            self_defected_last_round = not history.my_actions[-1]
            k_D = num_defecting_opponents + (1 if self_defected_last_round else 0)
            if state.current_stock < self.S_recovery_mode_threshold:
                return Action.C
            elif k_D <= self.max_tolerable_D_count:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_62(BaseStrategy):
    """
    Sustainable Reactor (SR) strategy for the Common Pool Resource Game.

    This strategy aims to foster collective cooperation for resource sustainability,
    adapt to various opponent behaviors, and ensure robustness in a tournament setting.
    It employs conditional cooperation, punishes defection, and critically
    prioritizes resource recovery when the common pool is in danger.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.my_mode: str = 'COOPERATE'
        self.my_rounds_in_punish_mode: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_t = state.round_number
        current_stock = state.current_stock
        if current_round_t == 0:
            self.my_mode = 'COOPERATE'
            self.my_rounds_in_punish_mode = 0
            return Action.C
        if current_round_t == n_rounds - 1:
            return Action.D
        others_defections_in_prev_round = sum(~history.opponent_actions[-1, :])
        is_stock_critical = current_stock < capacity / n_players
        if is_stock_critical:
            self.my_mode = 'COOPERATE'
            self.my_rounds_in_punish_mode = 0
            return Action.C
        elif others_defections_in_prev_round == 0:
            self.my_mode = 'COOPERATE'
            self.my_rounds_in_punish_mode = 0
            return Action.C
        elif self.my_mode == 'COOPERATE':
            self.my_mode = 'PUNISH'
            self.my_rounds_in_punish_mode = 1
            return Action.D
        elif self.my_mode == 'PUNISH':
            if self.my_rounds_in_punish_mode < 2:
                self.my_rounds_in_punish_mode += 1
                return Action.D
            else:
                self.my_mode = 'COOPERATE'
                self.my_rounds_in_punish_mode = 0
                return Action.C

class Strategy_COLLECTIVE_63(BaseStrategy):
    """
    Adaptive Collective Sustainer (ACS) strategy for the Common Pool Resource Game.
    This strategy balances collective resource sustainability with robustness against exploitation.
    It initiates cooperation, monitors opponent behavior to react to defection,
    offers forgiveness, and adjusts behavior based on the current stock level.
    It also employs endgame rationality.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.FORGIVENESS_ROUNDS = 2
        self.STOCK_CRITICAL_THRESHOLD_PERCENT = 0.25
        self.my_current_action_stance: Action = Action.C
        self.is_in_punishment_mode: bool = False
        self.rounds_since_last_other_defection: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number
        if current_round_t == self.total_rounds - 1:
            return Action.D
        if current_round_t == 0:
            self.my_current_action_stance = Action.C
            self.is_in_punishment_mode = False
            self.rounds_since_last_other_defection = 0
            return Action.C
        previous_opponent_actions = history.opponent_actions[-1, :]
        num_other_defectors = np.sum(previous_opponent_actions == False)
        if num_other_defectors > 0:
            self.rounds_since_last_other_defection = 0
        else:
            self.rounds_since_last_other_defection += 1
        if num_other_defectors > 0:
            self.is_in_punishment_mode = True
            self.my_current_action_stance = Action.D
        elif self.is_in_punishment_mode and self.rounds_since_last_other_defection >= self.FORGIVENESS_ROUNDS:
            self.is_in_punishment_mode = False
            self.my_current_action_stance = Action.C
        elif not self.is_in_punishment_mode:
            self.my_current_action_stance = Action.C
        critical_stock_level = self.STOCK_CRITICAL_THRESHOLD_PERCENT * self.capacity
        if state.current_stock < critical_stock_level:
            if not self.is_in_punishment_mode:
                self.my_current_action_stance = Action.C
        return self.my_current_action_stance

class Strategy_COLLECTIVE_64(BaseStrategy):
    """
    Adaptive Resource Guardian (ARG) strategy for the Common Pool Resource Game.
    This strategy employs conditional cooperation, retaliation against defection,
    and adaptation based on resource health. It aims to balance sustainability
    with self-protection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.INITIAL_COOPERATION_ROUNDS: int = 1
        self.RETALIATION_DURATION: int = 2
        self.STOCK_HEALTH_THRESHOLD_RATIO: float = 0.75
        self.COOPERATION_PROPORTION_THRESHOLD: float = 0.5
        self.retaliating: bool = False
        self.retaliation_counter: int = 0
        self._last_round_stock_at_start: float = self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_game_round = state.round_number + 1
        if current_game_round == r:
            self._last_round_stock_at_start = state.current_stock
            return Action.D
        if self.retaliating:
            if self.retaliation_counter > 0:
                self.retaliation_counter -= 1
                self._last_round_stock_at_start = state.current_stock
                return Action.D
            else:
                self.retaliating = False
        if current_game_round <= self.INITIAL_COOPERATION_ROUNDS:
            self._last_round_stock_at_start = state.current_stock
            return Action.C
        stock_at_start_of_prev_round = self._last_round_stock_at_start
        current_stock_at_start_of_this_round = state.current_stock
        my_action_prev_was_cooperate = history.my_actions[state.round_number - 1]
        opponent_cooperators_prev = np.sum(history.opponent_actions[state.round_number - 1, :])
        k_prev = (1 if my_action_prev_was_cooperate else 0) + opponent_cooperators_prev
        proportion_cooperators = k_prev / n if n > 0 else 0.0
        total_consumption_prev_round = stock_at_start_of_prev_round * (2 * n - k_prev) / (2 * n)
        stock_is_unhealthy = current_stock_at_start_of_this_round < capacity * self.STOCK_HEALTH_THRESHOLD_RATIO
        was_significant_defection_prev = proportion_cooperators < self.COOPERATION_PROPORTION_THRESHOLD
        action = Action.C
        if stock_at_start_of_prev_round < 0.01 and total_consumption_prev_round < 0.01:
            action = Action.D
        elif stock_is_unhealthy:
            if was_significant_defection_prev:
                self.retaliating = True
                self.retaliation_counter = self.RETALIATION_DURATION - 1
                action = Action.D
            else:
                action = Action.C
        elif was_significant_defection_prev:
            self.retaliating = True
            self.retaliation_counter = self.RETALIATION_DURATION - 1
            action = Action.D
        else:
            action = Action.C
        self._last_round_stock_at_start = state.current_stock
        return action

class Strategy_COLLECTIVE_65(BaseStrategy):
    """
    Adaptive Resource Guardian: Aims for sustainable resource management for all players while
    protecting itself against exploitation. It prioritizes the long-term health of the common
    pool resource and promotes conditional cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.k_threshold = self.n_players - 1
        self.resource_danger_threshold = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == self.n_rounds - 1:
            return Action.D
        if current_stock < self.resource_danger_threshold:
            return Action.C
        if current_round_number == 0:
            return Action.C
        else:
            prev_round_opponent_actions = history.opponent_actions[-1, :]
            num_cooperators_prev_round = sum(prev_round_opponent_actions)
            if num_cooperators_prev_round >= self.k_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_66(BaseStrategy):
    """
    The Adaptive Regulator strategy aims to balance resource sustainability with self-protection.
    It fosters cooperation by leading with 'C' and rewarding high cooperation rates, but defects
    to punish free-riders or prevent exploitation in critical situations. It is adaptive
    to opponent behavior and the resource's health, prioritizing long-term collective benefit
    while avoiding being a "sucker".
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOPERATION_THRESHOLD_HIGH = 0.8
        self.COOPERATION_THRESHOLD_LOW = 0.4
        self.CRITICAL_STOCK_THRESHOLD = self.game_description.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        current_round_num = state.round_number
        current_stock = state.current_stock
        if current_round_num == 0:
            return Action.C
        if current_round_num == total_rounds - 1:
            return Action.D
        num_C_others = np.sum(history.opponent_actions[-1, :])
        n_others = n_players - 1
        effective_cooperation_rate_others = num_C_others / n_others
        if current_stock >= self.CRITICAL_STOCK_THRESHOLD:
            if effective_cooperation_rate_others >= self.COOPERATION_THRESHOLD_HIGH:
                return Action.C
            else:
                return Action.D
        elif effective_cooperation_rate_others >= self.COOPERATION_THRESHOLD_HIGH:
            return Action.C
        elif effective_cooperation_rate_others >= self.COOPERATION_THRESHOLD_LOW:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_67(BaseStrategy):
    """
    The Collective Guardian strategy for the Common Pool Resource Game.
    This strategy prioritizes long-term resource sustainability, adapting to opponent
    behavior through conditional cooperation and proportional response,
    while being rational in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_recovery_threshold = self.game_description.capacity / 2
        self.defection_tolerance_threshold = max(1, math.floor(self.game_description.n_players / 4))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_t = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_t == total_rounds:
            return Action.D
        if current_t == 1:
            return Action.C
        my_defection_prev_round = int(not history.my_actions[-1])
        opponent_defections_prev_round = np.sum(~history.opponent_actions[-1, :])
        num_defectors_prev_round = my_defection_prev_round + opponent_defections_prev_round
        if state.current_stock < self.stock_recovery_threshold:
            return Action.C
        elif num_defectors_prev_round <= self.defection_tolerance_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_68(BaseStrategy):
    """
    The "Sentinel of the Commons" strategy promotes and sustains cooperation in the Common Pool Resource Game,
    while being robust against exploitation and prioritizing resource health. It starts cooperatively,
    responds with defection if others defect, immediately forgives upon universal cooperation,
    prioritizes cooperation during resource crisis, and defects in the final round for immediate gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.crisis_stock_threshold = self.game_description.capacity / 2.0
        self._last_action_i_played: Action = Action.C

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        stock = state.current_stock
        if current_round_0_indexed == total_rounds - 1:
            self._last_action_i_played = Action.D
            return Action.D
        if stock < self.crisis_stock_threshold:
            self._last_action_i_played = Action.C
            return Action.C
        if current_round_0_indexed == 0:
            self._last_action_i_played = Action.C
            return Action.C
        num_defectors_among_others_last_round = np.sum(history.opponent_actions[current_round_0_indexed - 1, :] == False)
        if num_defectors_among_others_last_round > 0:
            self._last_action_i_played = Action.D
            return Action.D
        else:
            self._last_action_i_played = Action.C
            return Action.C

class Strategy_COLLECTIVE_69(BaseStrategy):
    """
    Common Pool Steward (CPS) strategy for the Common Pool Resource Game.

    This strategy aims to promote collective resource sustainability through
    conditional cooperation, balanced with self-preservation and a mechanism
    to deter widespread defection. It responds adaptively to both the health
    of the common resource and the observed behavior of other players.

    Key principles:
    - Starts with cooperation to signal a desire for collective good.
    - Defects in the last round to maximize immediate gain and avoid exploitation.
    - Prioritizes resource recovery by unconditionally cooperating if the
      common stock falls below a critical threshold.
    - Tolerates a limited number of defectors in the previous round, fostering
      forgiveness and encouraging a return to cooperation.
    - Retaliates with defection if widespread defection is observed,
      to deter exploitation and impose a collective cost.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.STOCK_CRITICAL_THRESHOLD = self.game_description.capacity / (2 * self.game_description.n_players)
        self.DEFECTION_TOLERANCE_COUNT = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == r:
            return Action.D
        my_prev_action_array = np.array([history.my_actions[-1]])
        all_prev_actions = np.concatenate((my_prev_action_array, history.opponent_actions[-1, :]))
        num_defectors_prev_round = np.sum(all_prev_actions == False)
        if state.current_stock <= self.STOCK_CRITICAL_THRESHOLD:
            return Action.C
        elif num_defectors_prev_round == 0:
            return Action.C
        elif num_defectors_prev_round <= self.DEFECTION_TOLERANCE_COUNT:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_70(BaseStrategy):
    """
    The Adaptive Conservationist strategy for the Common Pool Resource Game.
    This strategy starts cooperatively, maintains cooperation when others are
    generally cooperative and the resource is healthy, but quickly switches
    to defection if others heavily defect or if the resource becomes
    critically low (prioritizing collective conservation). It defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.DEFECTION_TOLERANCE_THRESHOLD = 0.25
        self.LOW_STOCK_THRESHOLD_PERCENT = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        current_round_1_indexed = current_round_0_indexed + 1
        if current_round_1_indexed == total_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        other_defection_count = np.sum(previous_round_opponent_actions == False)
        other_defection_rate = 0.0
        other_defection_rate = other_defection_count / (total_players - 1)
        if current_stock < self.LOW_STOCK_THRESHOLD_PERCENT * capacity:
            return Action.C
        elif other_defection_rate > self.DEFECTION_TOLERANCE_THRESHOLD:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_71(BaseStrategy):
    """
    Adaptive Stock-based Tit-for-Tat (ASTFT) strategy for the Common Pool Resource Game.
    This strategy encourages collective cooperation and aims for resource sustainability
    by adjusting its behavior based on observed stock levels and previous round actions.
    It incorporates crisis response, vigilant enforcement, and forgiving cooperation,
    along with a rational end-game defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = 0.2 * self.capacity
        self.SUSTAINABILITY_GOAL_STOCK = 0.8 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        total_rounds = self.n_rounds
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.C
        num_defectors_prev_round = np.sum(history.opponent_actions[-1, :] == False)
        if history.my_actions[-1] == False:
            num_defectors_prev_round += 1
        if current_stock <= self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        elif current_stock >= self.SUSTAINABILITY_GOAL_STOCK:
            if num_defectors_prev_round == 0 or (num_defectors_prev_round == 1 and self.n_players > 2):
                return Action.C
            else:
                return Action.D
        elif num_defectors_prev_round == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_72(BaseStrategy):
    """
    The Collective Steward strategy for the Common Pool Resource Game.
    This strategy implements an adaptive reciprocity approach, prioritizing the
    sustainability and health of the common resource. It begins with cooperation,
    then dynamically adjusts its expectations for collective cooperation based
    on the current stock level. When the resource is critically low, it cooperates
    unconditionally to promote recovery. Otherwise, it rewards sufficient
    cooperation from others and punishes insufficient cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Collective Steward strategy with game parameters.

        Args:
            game_description (CommonPoolDescription): An object containing
                                                     n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_ratio = 0.25
        self.base_cooperation_demand = 0.5
        self.max_cooperation_demand = 1.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state (CommonPoolState): Contains the current round number and stock level.
            history (None | PlayerHistory): Historical actions and payoffs of all players.
                                            None for the very first round.

        Returns:
            Action: Action.C for Cooperate, Action.D for Defect.
        """
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == 0:
            return Action.C
        my_prev_action_bool = history.my_actions[current_round_number - 1]
        opponent_prev_actions_bool = history.opponent_actions[current_round_number - 1, :]
        cooperators_prev_round = np.sum(opponent_prev_actions_bool) + int(my_prev_action_bool)
        coop_rate_prev = cooperators_prev_round / self.n if self.n > 0 else 0.0
        stock_health_ratio = max(0.0, min(1.0, current_stock / self.capacity))
        effective_cooperation_demand = self.base_cooperation_demand + (self.max_cooperation_demand - self.base_cooperation_demand) * (1 - stock_health_ratio)
        effective_cooperation_demand = min(effective_cooperation_demand, self.max_cooperation_demand)
        is_stock_critical = current_stock < self.critical_stock_ratio * self.capacity
        if is_stock_critical:
            return Action.C
        elif coop_rate_prev >= effective_cooperation_demand:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_73(BaseStrategy):
    """
    The "Adaptive Collective Steward" strategy is designed for the Common Pool Resource Game.
    It balances collective resource sustainability with self-preservation against exploitation.
    The strategy is adaptive to the current common stock level and the historical actions
    of other players, aiming to foster long-term cooperation.

    Its core principles are conditional cooperation, strong emphasis on resource preservation
    when stock is low, and deterrence against significant free-riding.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initialises the AdaptiveCollectiveSteward strategy with game parameters and internal thresholds.

        Args:
            game_description: An object containing game parameters such as n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.CRITICAL_STOCK_RATIO = 0.2
        self.FORGIVING_COOP_THRESHOLD = 0.75
        self.PUNISH_COOP_THRESHOLD = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round based on
        game state, history, and predefined strategy rules.

        Args:
            state: An object containing the current round number and current stock level.
            history: An object containing past actions and payoffs for all players, or None for round 0.

        Returns:
            An Action (either Action.C for Cooperate or Action.D for Defect).
        """
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == 0:
            return Action.C
        if current_round_number == total_rounds - 1:
            return Action.D
        num_cooperators_prev_round = np.sum(history.opponent_actions[-1, :]) + int(history.my_actions[-1])
        cooperation_rate_prev_round = num_cooperators_prev_round / n
        if current_stock <= capacity * self.CRITICAL_STOCK_RATIO:
            return Action.C
        elif cooperation_rate_prev_round >= self.FORGIVING_COOP_THRESHOLD:
            return Action.C
        elif cooperation_rate_prev_round < self.PUNISH_COOP_THRESHOLD:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_74(BaseStrategy):
    """
    Adaptive Common Pool Steward (ACPS) Strategy.

    This strategy prioritizes the long-term health of the common pool resource.
    It starts cooperatively, monitors collective behavior from the previous round,
    and adapts its actions to punish widespread defection while forgiving minor
    deviations. It also includes an override mechanism to collectively preserve
    the resource when it becomes critically low. In the final round, it reverts
    to self-interest due to the finite horizon effect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock_S = state.current_stock
        critical_stock_threshold = self.capacity / (2.0 * self.n_players)
        if current_stock_S < critical_stock_threshold:
            if current_round_0_indexed == self.total_rounds - 1:
                return Action.D
            else:
                return Action.C
        if current_round_0_indexed == self.total_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.C
        prev_round_idx = current_round_0_indexed - 1
        my_prev_action_was_C = history.my_actions[prev_round_idx]
        opponents_prev_actions = history.opponent_actions[prev_round_idx, :]
        num_defectors_prev_round = 0
        if not my_prev_action_was_C:
            num_defectors_prev_round += 1
        num_defectors_prev_round += np.sum(1 - opponents_prev_actions)
        if num_defectors_prev_round <= 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_75(BaseStrategy):
    """
    The "Adaptive Collective Steward" strategy promotes collective resource sustainability
    while being robust against exploitation in a Common Pool Resource game. It balances
    initial cooperation, continuous monitoring, and dynamic response to defection,
    prioritizing resource health and self-preservation in critical situations.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self._punishment_rounds_remaining: int = 0
        self.S_critical_threshold: float = self.capacity / 4.0
        self.S_warning_threshold: float = self.capacity / 2.0
        self.D_significant_threshold: int = max(1, math.floor(self.n_players / 3))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            self._punishment_rounds_remaining = 0
            return Action.C
        if current_round == self.total_rounds - 1:
            return Action.D
        if self._punishment_rounds_remaining > 0:
            self._punishment_rounds_remaining -= 1
            return Action.D
        prev_round_opponent_actions = history.opponent_actions[current_round - 1, :]
        k_D_prev = sum(~prev_round_opponent_actions)
        if k_D_prev == 0:
            return Action.C
        elif current_stock < self.S_critical_threshold:
            return Action.D
        elif current_stock < self.S_warning_threshold:
            punishment_duration = min(3, k_D_prev + 1)
            self._punishment_rounds_remaining = punishment_duration - 1
            return Action.D
        elif k_D_prev >= self.D_significant_threshold:
            punishment_duration = min(2, k_D_prev)
            self._punishment_rounds_remaining = punishment_duration - 1
            return Action.D
        else:
            self._punishment_rounds_remaining = 0
            return Action.D

class Strategy_COLLECTIVE_76(BaseStrategy):
    """
    This strategy aims to foster and maintain cooperation to ensure the long-term health
    of the common resource. It starts cooperatively, adapts based on observed actions
    and resource health, and incorporates rational terminal-round behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.C
        c_count_opponents_prev = np.sum(history.opponent_actions[-1, :])
        d_count_opponents_prev = self.n_players - 1 - c_count_opponents_prev
        my_action_prev_was_C = history.my_actions[-1]
        d_count_prev_total = d_count_opponents_prev + (1 if not my_action_prev_was_C else 0)
        cooperation_is_reciprocated = False
        if self.n_players == 2:
            if d_count_prev_total == 0:
                cooperation_is_reciprocated = True
        elif d_count_prev_total <= 1:
            cooperation_is_reciprocated = True
        resource_is_healthy = current_stock >= self.capacity / 2.0
        if cooperation_is_reciprocated and resource_is_healthy:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_77(BaseStrategy):
    """
    The Adaptive Sustainability Protocol (ASP) strategy is designed for the Common Pool Resource Game.
    It prioritizes collective resource sustainability by adapting its actions based on the current
    stock level and the observed behavior of other players in the previous round. ASP aims to foster
    cooperation, reward collective efforts, and strategically defect to deter widespread free-riding,
    with a strong override to conserve the resource when it is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.depletion_threshold = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_idx = state.round_number
        stock_level = state.current_stock
        if current_round_idx == 0:
            return Action.C
        if current_round_idx == self.n_rounds - 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[current_round_idx - 1, :]
        k_prev = sum(~previous_round_opponent_actions)
        if stock_level < self.depletion_threshold:
            return Action.C
        elif k_prev == 0:
            return Action.C
        elif k_prev >= self.n_players / 2.0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_78(BaseStrategy):
    """
    Adaptive Sustainability Enforcer (ASE) strategy for the Common Pool Resource game.
    Prioritizes the long-term health of the common resource and promotes collective cooperation.
    It starts cooperatively, monitors other players' behavior and resource state, and dynamically
    adjusts its tolerance for defection. When defection is prevalent or the resource threatened,
    it shifts to a defensive (defecting) stance to deter exploitation and protect its interests.
    It accounts for altered incentives in the game's final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.BASE_DEFECTION_TOLERANCE_THRESHOLD = 0.33
        self.STOCK_RECOVERY_LEVEL_FOR_LENIENCY = 0.8 * game_description.capacity
        self.STOCK_CRITICAL_LEVEL_FOR_STRICTNESS = 0.4 * game_description.capacity
        self.EXTREME_DEPLETION_THRESHOLD = 0.1 * game_description.capacity
        self.FINAL_ROUND_PRELUDE_ROUNDS = 2
        self.my_last_action = Action.C

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds_1_indexed = self.game_description.n_rounds
        n_players = self.game_description.n_players
        action_to_take: Action
        if current_round_1_indexed == 1:
            action_to_take = Action.C
        else:
            num_defected_by_others_prev_round = np.sum(~history.opponent_actions[-1, :])
            defection_rate_of_others = num_defected_by_others_prev_round / (n_players - 1)
            if current_round_1_indexed == total_rounds_1_indexed:
                action_to_take = Action.D
            elif current_round_1_indexed >= total_rounds_1_indexed - self.FINAL_ROUND_PRELUDE_ROUNDS + 1:
                effective_tolerance_end_game = self.BASE_DEFECTION_TOLERANCE_THRESHOLD * 0.75
                if defection_rate_of_others > effective_tolerance_end_game or state.current_stock < self.game_description.capacity * 0.3:
                    action_to_take = Action.D
                else:
                    action_to_take = Action.C
            else:
                effective_defection_tolerance = self.BASE_DEFECTION_TOLERANCE_THRESHOLD
                if state.current_stock < self.STOCK_CRITICAL_LEVEL_FOR_STRICTNESS:
                    effective_defection_tolerance *= 0.6
                elif state.current_stock > self.STOCK_RECOVERY_LEVEL_FOR_LENIENCY:
                    effective_defection_tolerance *= 1.3
                effective_defection_tolerance = max(0.0, min(1.0, effective_defection_tolerance))
                action_to_take = Action.C
                if state.current_stock < self.EXTREME_DEPLETION_THRESHOLD:
                    action_to_take = Action.D
                elif defection_rate_of_others > effective_defection_tolerance:
                    action_to_take = Action.D
                elif self.my_last_action == Action.D and defection_rate_of_others > effective_defection_tolerance * 0.5:
                    action_to_take = Action.D
        self.my_last_action = action_to_take
        return action_to_take

class Strategy_COLLECTIVE_79(BaseStrategy):
    """
    The Adaptive Conservationist strategy for the Common Pool Resource Game.
    This strategy balances sustainability with protection against exploitation,
    aligning with a "collective mindset" while preparing for competition.

    It starts cooperatively, monitors collective behavior, and applies conditional
    cooperation or punishment. Crucially, it prioritizes resource conservation
    when the stock is critically low, and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Conservationist strategy.

        Args:
            game_description: An object containing game parameters (n_players, n_rounds, capacity).
        """
        self.game_description = game_description
        self.COOPERATION_THRESHOLD = (self.game_description.n_players - 1) / self.game_description.n_players
        self.CRITICAL_STOCK_LEVEL = self.game_description.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current player in the current round.

        Args:
            state: An object containing the current round number and current stock level.
            history: An object containing past actions and payoffs for the current player and opponents.
                     It is None for the very first round (round_number = 0).

        Returns:
            An Action enum: Action.C for Cooperate, Action.D for Defect.
        """
        current_round_t = state.round_number + 1
        total_rounds_r = self.game_description.n_rounds
        current_stock_S = state.current_stock
        n_players = self.game_description.n_players
        if current_stock_S <= 0:
            return Action.C
        if current_round_t == total_rounds_r:
            return Action.D
        if current_round_t == 1:
            return Action.C
        num_cooperators_prev_round = int(history.my_actions[-1]) + np.sum(history.opponent_actions[-1, :])
        collective_cooperation_ratio = num_cooperators_prev_round / n_players
        is_stock_endangered = current_stock_S <= self.CRITICAL_STOCK_LEVEL
        if is_stock_endangered:
            return Action.C
        elif collective_cooperation_ratio >= self.COOPERATION_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_80(BaseStrategy):
    """
    Adaptive Sustainability & Conditional Reciprocity (ASCR) strategy.
    Prioritizes resource sustainability by aiming to maintain stock near capacity.
    It employs conditional cooperation, reacting to significant defection from others.
    Includes emergency measures for critically low stock levels to promote recovery,
    and adjusts behavior for the final round based on endgame rationality.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_threshold = max(1, math.floor(self.n / 3))
        self.critical_stock_level = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.r - 1:
            return Action.D
        elif current_stock < self.critical_stock_level:
            return Action.C
        else:
            observed_defectors_count = 0
            if current_round == 0:
                observed_defectors_count = 0
            else:
                observed_defectors_count = np.sum(~history.opponent_actions[current_round - 1, :])
            if observed_defectors_count >= self.defection_threshold:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_81(BaseStrategy):
    """
    The Adaptive Sustainability Enforcer (ASE) strategy for the Common Pool Resource Game.

    This strategy aims to balance individual incentives with the long-term sustainability
    of the common resource. It starts with cooperation, enforces against widespread
    defection with temporary punishment when the resource is healthy, and prioritizes
    resource recovery with universal cooperation when the stock is critical. It adapts
    to the final round by defecting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD = self.game_description.capacity / 2.0
        self.DEFECTION_TOLERANCE_COUNT = self.game_description.n_players // 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == r - 1:
            return Action.D
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        else:
            defection_count_t_minus_1 = np.sum(~history.opponent_actions[-1, :])
            if defection_count_t_minus_1 > self.DEFECTION_TOLERANCE_COUNT:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_82(BaseStrategy):
    """
    The Adaptive Community Guardian (ACG) strategy promotes collective sustainability.
    It starts with cooperation, adapts to opponent behavior by punishing defection,
    and has a critical override to prioritize resource preservation when the stock is low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock <= self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        my_action_prev_round = history.my_actions[current_round - 1]
        opponent_actions_prev_round = history.opponent_actions[current_round - 1, :]
        num_cooperators_prev_round = 0
        if my_action_prev_round:
            num_cooperators_prev_round += 1
        num_cooperators_prev_round += np.sum(opponent_actions_prev_round)
        num_defectors_last_round = self.n_players - num_cooperators_prev_round
        if num_defectors_last_round == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_83(BaseStrategy):
    """
    The Collective Sustainability Adaptive Strategy (CSAS) prioritizes the health of the
    shared resource while adapting to the behaviors of other players. It operates on a
    tiered decision-making process based on the current state of the common stock and
    the observed actions of other players in the previous round. It aims to foster
    cooperation when possible, enforce it when necessary, and defend against widespread
    defection to maintain resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        elif current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        else:
            k_others_prev = np.sum(history.opponent_actions[-1, :] == False)
            if current_stock < self.capacity / 2:
                return Action.C
            elif k_others_prev == 0:
                return Action.C
            elif 0 < k_others_prev <= (self.n_players - 1) / 2:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_84(BaseStrategy):
    """
    Adaptive Conservator (AC) Strategy:
    Promotes and maintains a healthy common pool resource, balancing sustainability with self-preservation.
    It adapts to the resource state and observed opponent behavior, employing conditional punishment and
    prioritizing collective recovery during critical resource depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.r = game_description.n_rounds
        self.punishment_duration = 2
        self.defection_threshold_num = max(1, int(round((self.n - 1) / 2)))
        self.stock_recovery_threshold = self.capacity / 2
        self.stock_critical_threshold = self.capacity / 4
        self.punishment_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.r - 1:
            return Action.D
        prev_round_actions_of_others = history.opponent_actions[state.round_number - 1, :]
        k_D_others_prev = sum(~prev_round_actions_of_others)
        if self.punishment_counter > 0:
            self.punishment_counter -= 1
            if state.current_stock < self.stock_critical_threshold and k_D_others_prev == 0:
                self.punishment_counter = 0
                return Action.C
            else:
                return Action.D
        elif k_D_others_prev >= self.defection_threshold_num:
            self.punishment_counter = self.punishment_duration
            return Action.D
        elif state.current_stock < self.stock_recovery_threshold and k_D_others_prev == 0:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_85(BaseStrategy):
    """
    The "Adaptive Collective Guardian" strategy enforces optimal collective behavior (full cooperation for sustainability).
    It starts with cooperation, strictly punishes any defection, and offers conditional forgiveness to restore cooperation
    when the resource recovers and all players cooperate. It also includes self-preservation mechanisms in the final round
    or when the resource is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.my_last_action = Action.C

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        S = state.current_stock
        action_to_take: Action
        if current_round_1_indexed == r:
            action_to_take = Action.D
        elif S <= 0.1 * capacity:
            action_to_take = Action.D
        elif state.round_number == 0:
            action_to_take = Action.C
        else:
            my_prev_action_bool = history.my_actions[-1]
            opponent_prev_actions_bool = history.opponent_actions[-1, :]
            all_actions_prev_round_bool = np.concatenate(([my_prev_action_bool], opponent_prev_actions_bool))
            k_last_round = n - np.sum(all_actions_prev_round_bool)
            if self.my_last_action == Action.D and k_last_round == 0 and (S > 0.5 * capacity):
                action_to_take = Action.C
            elif k_last_round > 0:
                action_to_take = Action.D
            else:
                action_to_take = Action.C
        self.my_last_action = action_to_take
        return action_to_take

class Strategy_COLLECTIVE_86(BaseStrategy):
    """
    Adaptive Collective Guardian (ACG) strategy promotes collective sustainability
    by employing conditional cooperation, a responsive punishment mechanism, and
    adapting its tolerance for defection based on the current stock level.

    It starts with cooperation, defects in the last round, and in intermediate
    rounds, it analyzes previous round's behavior to decide based on stock health
    (Healthy, Warning, Critical) and the number of defectors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.SHT = 0.75 * self.capacity
        self.SWT = 0.5 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number + 1
        current_stock = state.current_stock
        if current_round == 1:
            return Action.C
        if current_round == self.n_rounds:
            return Action.D
        else:
            num_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
            if history.my_actions[-1] == Action.C.value:
                num_cooperators_last_round += 1
            num_defectors_last_round = self.n_players - num_cooperators_last_round
            if current_stock >= self.SHT:
                if num_defectors_last_round == 0:
                    return Action.C
                elif num_defectors_last_round == 1 and self.n_players > 2:
                    return Action.C
                else:
                    return Action.D
            elif current_stock >= self.SWT:
                if num_defectors_last_round == 0:
                    return Action.C
                else:
                    return Action.D
            elif num_cooperators_last_round == self.n_players:
                return Action.C
            elif num_cooperators_last_round == self.n_players - 1:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_87(BaseStrategy):
    """
    This strategy, named "Sustainable Reciprocator with Stock Safeguard," aims to promote
    collective sustainability of the common pool resource while remaining adaptive and
    robust against various opponent behaviors in a tournament setting. It balances the
    need for individual payoff maximization with the imperative to maintain the health
    of the shared resource.

    Core Principles:
    1. Initiate Cooperation: Start by cooperating to signal a willingness for collective action.
    2. Resource Safeguard: Prioritize the health of the common pool resource, cooperating
       unconditionally when stock levels are critically low to prevent collapse.
    3. Forgiving Reciprocity: Reward collective cooperation by continuing to cooperate, but
       tolerate minor defections to prevent a spiral of punishment.
    4. Deterrence: Defect when collective cooperation falls significantly, signaling the
       need for greater participation in resource management.
    5. Pragmatic Finale: In the final round, anticipate self-interested behavior from others
       and act accordingly to maximize immediate payoff, as there are no future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == r:
            return Action.D
        else:
            previous_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
            c_others_prev = np.sum(previous_round_opponent_actions)
            n_others = n - 1
            cooperation_rate_others = c_others_prev / n_others
            if current_stock < capacity / 4.0:
                return Action.C
            elif cooperation_rate_others >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_88(BaseStrategy):
    """
    Adaptive Steward is a collective strategy for a Common Pool Resource Game.
    It adapts its behavior based on the current stock level and the observed
    cooperation of other players. It aims to foster cooperation when the
    resource is healthy, react defensively when it's under threat, and
    attempt collective rescue in critical situations.

    - Starts by cooperating to signal willingness for collective action.
    - Defects in the last round to align with individual rationality as there
      are no future consequences.
    - In intermediate rounds, it dynamically adjusts its action:
        - If stock is healthy, cooperates if enough others (>= 50%) cooperated.
        - If stock is low but not critical, cooperates only if a strong majority
          (all but one) of others cooperated, demanding more collective effort for recovery.
        - If stock is critically low, attempts rescue only if an overwhelming
          proportion (>= 80%) of others show commitment.
        - Otherwise, defects to deter free-riding or protect personal share.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOPERATION_THRESHOLD_OTHERS = 0.5
        self.STOCK_RECOVERY_THRESHOLD = self.game_description.capacity / 2.0
        self.STOCK_CRITICAL_THRESHOLD = 0.1 * self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        S_t = state.current_stock
        current_round_number = state.round_number
        if current_round_number == 0:
            return Action.C
        if current_round_number == r - 1:
            return Action.D
        num_cooperators_others_prev_round = int(np.sum(history.opponent_actions[-1, :]))
        cooperation_rate_others = float(num_cooperators_others_prev_round) / (n - 1)
        if S_t > self.STOCK_RECOVERY_THRESHOLD:
            if cooperation_rate_others >= self.COOPERATION_THRESHOLD_OTHERS:
                return Action.C
            else:
                return Action.D
        elif S_t > self.STOCK_CRITICAL_THRESHOLD:
            coop_threshold_recovery_zone = (n - 2.0) / (n - 1.0)
            if cooperation_rate_others >= coop_threshold_recovery_zone:
                return Action.C
            else:
                return Action.D
        elif cooperation_rate_others >= 0.8:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_89(BaseStrategy):
    """
    The "Adaptive Resource Guardian" (ARG) strategy for the Common Pool Resource Game.
    This strategy prioritizes resource preservation, adapting its behavior based on the
    observed health of the stock and inferring the collective cooperation level of others.

    Core Philosophy:
    1. Resource First (Famine Response): When the common resource is critically low,
       the strategy always cooperates to promote recovery.
    2. Adaptive Reciprocity (Abundance/Normal Response): When the resource is not critically
       endangered, the strategy adapts its behavior based on the inferred cooperation
       level of others, cooperating when others do, and defecting defensively otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_tendency: float = 1.0
        self.s_prev: float = float(game_description.capacity)
        self.LEARNING_RATE: float = 0.2
        self.CRITICAL_STOCK_FACTOR: float = 4.0
        self.HIGH_COOPERATION_THRESHOLD: float = 0.75
        self.LOW_COOPERATION_THRESHOLD: float = 0.25
        self._EPSILON = 0.001

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock_level = state.current_stock
        capacity_param = float(self.game_description.capacity)
        total_rounds = self.game_description.n_rounds
        if state.round_number == 0:
            self.s_prev = current_stock_level
            self.cooperation_tendency = 1.0
            return Action.C
        if state.round_number == total_rounds - 1:
            self.s_prev = current_stock_level
            return Action.D
        S_after_consumption_prev_round: float = 0.0
        if current_stock_level >= capacity_param - self._EPSILON:
            S_after_consumption_prev_round = capacity_param / 2.0
        else:
            A = 2.0 / capacity_param
            B = -3.0
            C = current_stock_level
            discriminant = B * B - 4 * A * C
            if discriminant < 0:
                S_after_consumption_prev_round = 0.0
            else:
                sqrt_discriminant = math.sqrt(discriminant)
                x1 = (-B + sqrt_discriminant) / (2 * A)
                x2 = (-B - sqrt_discriminant) / (2 * A)
                if x2 >= 0 and x2 <= self.s_prev:
                    S_after_consumption_prev_round = x2
                elif x1 >= 0 and x1 <= self.s_prev:
                    S_after_consumption_prev_round = x1
                else:
                    S_after_consumption_prev_round = 0.0
        coop_level_observed: float = 0.0
        if self.s_prev > self._EPSILON:
            coop_level_observed = S_after_consumption_prev_round / (self.s_prev / 2.0)
            coop_level_observed = max(0.0, min(1.0, coop_level_observed))
        self.cooperation_tendency = (1.0 - self.LEARNING_RATE) * self.cooperation_tendency + self.LEARNING_RATE * coop_level_observed
        self.cooperation_tendency = max(0.0, min(1.0, self.cooperation_tendency))
        action_to_take = Action.C
        critical_stock_level = capacity_param / self.CRITICAL_STOCK_FACTOR
        if current_stock_level <= critical_stock_level:
            action_to_take = Action.C
        elif self.cooperation_tendency >= self.HIGH_COOPERATION_THRESHOLD:
            action_to_take = Action.C
        elif self.cooperation_tendency <= self.LOW_COOPERATION_THRESHOLD:
            action_to_take = Action.D
        else:
            action_to_take = Action.C
        self.s_prev = current_stock_level
        return action_to_take

class Strategy_COLLECTIVE_90(BaseStrategy):
    """
    Adaptive Collective Sustainer (ACS) Strategy for Common Pool Resource Game.
    The strategy aims to achieve high overall payoffs by prioritizing resource
    sustainability. It balances collective good with self-preservation, fostering
    cooperation while protecting against exploitation.

    Key behaviors:
    - Cooperates in the first round.
    - Always defects in the final round to maximize immediate payoff.
    - If the common stock is "endangered" (below a set threshold), it prioritizes
      resource recovery by always cooperating, even if others are defecting.
    - If the stock is healthy, it adapts to opponent behavior:
        - It retaliates by defecting if a significant fraction of opponent actions
          in recent rounds were defections.
        - Otherwise, it cooperates to maintain a sustainable equilibrium.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defect_tolerance_fraction = 0.5
        self.history_window_size = 3
        self.stock_recovery_threshold_fraction = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.game_description.n_rounds:
            return Action.D
        current_stock_is_endangered = state.current_stock < self.game_description.capacity * self.stock_recovery_threshold_fraction
        is_significant_defection = False
        if state.round_number > 0 and history is not None:
            num_past_rounds_to_consider = min(state.round_number, self.history_window_size)
            start_history_idx = state.round_number - num_past_rounds_to_consider
            relevant_opponent_actions = history.opponent_actions[start_history_idx:state.round_number, :]
            total_opponent_defections = np.sum(relevant_opponent_actions == False)
            total_possible_opponent_actions = (self.game_description.n_players - 1) * num_past_rounds_to_consider
            if total_possible_opponent_actions > 0:
                k_D_avg_per_opponent = total_opponent_defections / total_possible_opponent_actions
                is_significant_defection = k_D_avg_per_opponent > self.defect_tolerance_fraction
        if current_stock_is_endangered:
            return Action.C
        elif is_significant_defection:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_91(BaseStrategy):
    """
    The Adaptive Community Steward (ACS) strategy for the Common Pool Resource Game.
    It prioritizes resource health, starting with cooperation and dynamically adjusting
    its defection tolerance based on the current stock level and past collective actions.
    It is stricter when stock is low and more forgiving when stock is healthy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.s_critical = self.game_description.capacity / 4.0
        self.s_healthy = self.game_description.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        num_defectors_last_round = np.sum(~history.opponent_actions[-1, :])
        n_players = self.game_description.n_players
        n_others = n_players - 1
        d_tolerance = 0
        if n_others >= 1:
            if state.current_stock < self.s_critical:
                d_tolerance = 0
            elif state.current_stock < self.s_healthy:
                d_tolerance = math.floor(n_others / 3)
            else:
                d_tolerance = math.floor(n_others / 2)
        if num_defectors_last_round <= d_tolerance:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_92(BaseStrategy):
    """
    Adaptive Stock-Protector with Forgiveness (ASPF) strategy for the Common Pool Resource Game.

    This strategy prioritizes the sustainability of the shared resource, adaptively responds
    to the behavior of other players, and includes mechanisms for proportional punishment and
    forgiveness. It aims to foster cooperation while being robust against exploitation
    in a tournament setting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters and internal state variables.

        Args:
            game_description (CommonPoolDescription): An object containing game parameters
                                                     like n_players, n_rounds, and capacity.
        """
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.my_punishment_rounds_left = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state (CommonPoolState): An object containing current round number and stock level.
                                     `state.round_number` is 0-indexed (0 for the first round).
            history (None | PlayerHistory): An object containing historical actions and payoffs,
                                            or None for the very first round (`state.round_number == 0`).

        Returns:
            Action: Action.C for Cooperate, Action.D for Defect.
        """
        current_round_0_indexed = state.round_number
        r_remaining = self.n_rounds - current_round_0_indexed
        if r_remaining == 1:
            return Action.D
        if state.current_stock < self.capacity / (2.0 * self.n_players):
            self.my_punishment_rounds_left = 0
            return Action.C
        if self.my_punishment_rounds_left > 0:
            self.my_punishment_rounds_left -= 1
            return Action.D
        if self.n_players == 2:
            D_tolerance = 0
        else:
            D_tolerance = max(1, self.n_players // 4)
        k_defectors_prev_round = 0
        if current_round_0_indexed > 0 and history is not None:
            previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
            k_defectors_prev_round = np.sum(~previous_round_opponent_actions)
        if k_defectors_prev_round <= D_tolerance:
            return Action.C
        else:
            self.my_punishment_rounds_left = max(1, k_defectors_prev_round // 2)
            return Action.D

class Strategy_COLLECTIVE_93(BaseStrategy):
    """
    Adaptive Sustainability (AS) strategy for the Common Pool Resource Game.

    This strategy aims to maintain the common pool stock at a high level over the rounds,
    ensuring sustained payoffs for all players, while adapting to deviations from
    cooperative behavior and avoiding individual exploitation. It fosters cooperation
    but enforces rules to prevent resource collapse or individual exploitation.
    """
    CRITICAL_STOCK_FACTOR: float = 0.6
    DEFAULT_D_TOLERANCE: int = 1

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_round_number == 0:
            return Action.C
        if current_round_number == n_rounds - 1:
            return Action.D
        n_opponents_D_prev = np.sum(~history.opponent_actions[-1, :])
        my_current_D_tolerance = self.DEFAULT_D_TOLERANCE
        if current_stock < capacity * self.CRITICAL_STOCK_FACTOR:
            my_current_D_tolerance = 0
        if n_opponents_D_prev > my_current_D_tolerance:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_94(BaseStrategy):
    """
    Adaptive Stock Manager with Collective Forgiveness strategy for the Common Pool Resource game.
    This strategy aims to maintain the common pool resource at its maximum sustainable level
    through cooperation. It monitors resource health and opponent behavior, using defection
    as a signal or punishment when the resource is threatened, and quickly reverting to
    cooperation when conditions improve or become critical.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.COOPERATION_STOCK_THRESHOLD_HIGH = 0.8 * self.capacity
        self.COOPERATION_STOCK_THRESHOLD_LOW = 0.5 * self.capacity
        self.CRITICAL_STOCK_THRESHOLD = 0.2 * self.capacity
        self.COOPERATION_HISTORY_WINDOW = 2
        self.DEFECTION_STREAK_TOLERANCE = 1
        self.my_last_action: Action | None = None
        self.prev_stock: float = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number + 1
        if current_round_t == 1:
            self.my_last_action = Action.C
            self.prev_stock = state.current_stock
            return Action.C
        if current_round_t == self.n_rounds:
            self.my_last_action = Action.D
            self.prev_stock = state.current_stock
            return Action.D
        is_stock_declining = state.current_stock < self.prev_stock
        num_active_defectors = 0
        num_opponents = self.n_players - 1
        for opponent_idx in range(num_opponents):
            defection_count_for_opponent = 0
            for past_round_idx_0_indexed in range(state.round_number - 1, max(-1, state.round_number - 1 - self.COOPERATION_HISTORY_WINDOW), -1):
                if not history.opponent_actions[past_round_idx_0_indexed, opponent_idx]:
                    defection_count_for_opponent += 1
            if defection_count_for_opponent >= self.DEFECTION_STREAK_TOLERANCE:
                num_active_defectors += 1
        my_action: Action
        if state.current_stock < self.CRITICAL_STOCK_THRESHOLD:
            my_action = Action.C
        elif state.current_stock >= self.COOPERATION_STOCK_THRESHOLD_HIGH:
            my_action = Action.C
        elif state.current_stock >= self.COOPERATION_STOCK_THRESHOLD_LOW and (not is_stock_declining):
            my_action = Action.C
        elif num_active_defectors > 0:
            my_action = Action.D
        else:
            my_action = Action.C
        self.my_last_action = my_action
        self.prev_stock = state.current_stock
        return my_action

class Strategy_COLLECTIVE_95(BaseStrategy):
    """
    Adaptive Stock-Aware Reciprocity (ASAR) strategy for the Common Pool Resource Game.
    ASAR is a conditionally cooperative strategy that balances long-term resource sustainability
    with robust protection against exploitation. It prioritizes resource recovery when stock is critical,
    retaliates against widespread defection, and defaults to cooperation otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_critical_rebuild_threshold = self.capacity / 2.0
        self.Max_Tolerated_Defectors = max(1, math.floor(self.n_players / 4.0))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        num_opponent_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
        num_opponent_defectors_last_round = self.n_players - 1 - num_opponent_cooperators_last_round
        if state.current_stock < self.S_critical_rebuild_threshold:
            return Action.C
        if num_opponent_defectors_last_round > self.Max_Tolerated_Defectors:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_96(BaseStrategy):
    """
    The Adaptive Reciprocal Cooperator (ARC) strategy aims to foster cooperation
    and resource sustainability by adapting its actions based on the current
    resource state, opponent behaviors, and internal history. It starts cooperative,
    prioritizes resource preservation, punishes defection adaptively, and
    incorporates forgiveness to avoid permanent punishment loops.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_opponents = self.n_players - 1
        self.CRITICAL_STOCK_THRESHOLD = self.game_description.capacity * 0.5
        self.MIN_ROUNDS_FOR_OBSERVATION = 3
        self.INDIVIDUAL_DEFECTION_TOLERANCE_RATE = 0.3
        self.MAJORITY_DEFECTION_THRESHOLD = math.ceil(self.n_opponents / 2)
        self.PUNISHMENT_ROUNDS_INDIVIDUAL = 2
        self.PUNISHMENT_ROUNDS_COLLECTIVE = 3
        self.PROB_COOPERATE_DURING_COLLECTIVE_PUNISHMENT = 0.2
        self.my_punishment_timer_individual = [0] * self.n_opponents
        self.my_punishment_timer_collective = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if state.round_number > 0:
            for opp_idx in range(self.n_opponents):
                if self.my_punishment_timer_individual[opp_idx] > 0:
                    self.my_punishment_timer_individual[opp_idx] -= 1
            if self.my_punishment_timer_collective > 0:
                self.my_punishment_timer_collective -= 1
        if current_round_1_indexed == total_rounds:
            return Action.D
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        if self.my_punishment_timer_collective > 0:
            if random.random() < self.PROB_COOPERATE_DURING_COLLECTIVE_PUNISHMENT:
                return Action.C
            else:
                return Action.D
        if state.round_number > 0:
            num_opponent_defections_last_round = np.sum(~history.opponent_actions[-1, :])
            if num_opponent_defections_last_round >= self.MAJORITY_DEFECTION_THRESHOLD:
                self.my_punishment_timer_collective = self.PUNISHMENT_ROUNDS_COLLECTIVE
                return Action.D
            if any((timer > 0 for timer in self.my_punishment_timer_individual)):
                return Action.D
            if current_round_1_indexed > self.MIN_ROUNDS_FOR_OBSERVATION:
                for opp_idx in range(self.n_opponents):
                    opponent_actions_history = history.opponent_actions[:state.round_number, opp_idx]
                    num_defections_by_opponent = np.sum(~opponent_actions_history)
                    defection_rate = num_defections_by_opponent / state.round_number
                    if defection_rate > self.INDIVIDUAL_DEFECTION_TOLERANCE_RATE:
                        self.my_punishment_timer_individual[opp_idx] = self.PUNISHMENT_ROUNDS_INDIVIDUAL
                        return Action.D
        return Action.C

class Strategy_COLLECTIVE_97(BaseStrategy):
    """
    Adaptive Collective Steward (ACS) strategy for the Common Pool Resource Game.

    This strategy aims to foster long-term sustainability by prioritizing cooperation,
    monitoring the collective behavior of other players, and adapting its actions
    based on the common stock's health and observed defection. It rewards cooperation,
    forgives minor deviations when the resource is vulnerable, and punishes
    significant or persistent defection to protect against exploitation.
    In the final round or under extreme resource depletion, it shifts to
    self-preservation mode to minimize individual losses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.N = float(self.game_description.n_players)
        self.r = self.game_description.n_rounds
        self.capacity = float(self.game_description.capacity)
        self.CRITICAL_STOCK_THRESHOLD = self.N * 2.0
        self.WARNING_STOCK_THRESHOLD = self.capacity * 0.3
        self.HEALTHY_STOCK_THRESHOLD = self.capacity * 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.r:
            return Action.D
        else:
            previous_round_idx = state.round_number - 1
            D_count_prev = 0
            D_count_prev += np.sum(~history.opponent_actions[previous_round_idx, :])
            if not history.my_actions[previous_round_idx]:
                D_count_prev += 1
            D_count_prev_float = float(D_count_prev)
            if current_stock >= self.HEALTHY_STOCK_THRESHOLD:
                if D_count_prev_float == 0.0:
                    return Action.C
                else:
                    return Action.D
            elif current_stock >= self.WARNING_STOCK_THRESHOLD:
                if D_count_prev_float <= self.N / 4.0:
                    return Action.C
                else:
                    return Action.D
            elif current_stock < self.CRITICAL_STOCK_THRESHOLD:
                return Action.D
            elif D_count_prev_float == 0.0:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_98(BaseStrategy):
    """
    The "Adaptive Steward" strategy prioritizes the long-term health of the shared resource
    while adapting to opponent behaviors. It adjusts its actions based on the current stock
    level and the observed actions of other players in the previous round. It aims to
    promote cooperation, recover depleted stock, and punish defection when the resource
    is healthy, while always reverting to cooperation in critically low stock situations.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = float(self.game_description.capacity)
        self.DANGER_STOCK_THRESHOLD = capacity / (2 * n) if n >= 1 else 0.0
        self.LOW_STOCK_THRESHOLD = capacity / 4.0
        self.PUNISHMENT_LENGTH = 1
        self.is_punishing = False
        self.rounds_to_punish = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        if current_round_0_indexed == 0:
            self.is_punishing = False
            self.rounds_to_punish = 0
            return Action.C
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        last_round_opponent_actions = history.opponent_actions[-1, :]
        num_others_defected_last_round = np.sum(last_round_opponent_actions == False)
        if self.is_punishing and self.rounds_to_punish > 0:
            if current_stock <= self.DANGER_STOCK_THRESHOLD:
                self.is_punishing = False
                self.rounds_to_punish = 0
                return Action.C
            else:
                self.rounds_to_punish -= 1
                if self.rounds_to_punish == 0:
                    self.is_punishing = False
                return Action.D
        if current_stock <= self.DANGER_STOCK_THRESHOLD:
            self.is_punishing = False
            self.rounds_to_punish = 0
            return Action.C
        if current_stock <= self.LOW_STOCK_THRESHOLD:
            if num_others_defected_last_round > 0:
                return Action.D
            else:
                return Action.C
        elif num_others_defected_last_round > 0:
            self.is_punishing = True
            self.rounds_to_punish = self.PUNISHMENT_LENGTH
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_99(BaseStrategy):
    """
    Adaptive Collective Sustain (ACS) strategy for the Common Pool Resource Game.
    This strategy aims for collective sustainability, prioritizing resource health,
    using conditional cooperation, measured retaliation, and forgiveness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.IDEAL_COOPERATION_STOCK_LEVEL = self.capacity
        self.ACCEPTABLE_STOCK_DEGRADATION_THRESHOLD = 0.05 * self.capacity
        self.CRITICAL_STOCK_ABSOLUTE_THRESHOLD = 0.25 * self.capacity
        self.ACCEPTABLE_STOCK_DEGRADATION_THRESHOLD = max(0.0, self.ACCEPTABLE_STOCK_DEGRADATION_THRESHOLD)
        self.CRITICAL_STOCK_ABSOLUTE_THRESHOLD = max(0.0, self.CRITICAL_STOCK_ABSOLUTE_THRESHOLD)
        self.TOLERABLE_OTHER_DEFECTORS_HIGH_STOCK = max(1, math.floor(self.n_players / 4))
        self.TOLERABLE_OTHER_DEFECTORS_DEGRADING_OR_CRITICAL_STOCK = 0
        self.SEVERE_DEFECTION_THRESHOLD_CRITICAL = math.ceil(self.n_players / 2)
        self._previous_round_start_stock: float = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        if current_round_1_indexed == 1:
            self._previous_round_start_stock = current_stock
            return Action.C
        if current_round_1_indexed == self.n_rounds:
            self._previous_round_start_stock = current_stock
            return Action.D
        num_other_defectors_prev_round = (~history.opponent_actions[-1, :]).sum()
        stock_at_start_of_prev_round = self._previous_round_start_stock
        stock_degraded_significantly = current_stock < stock_at_start_of_prev_round - self.ACCEPTABLE_STOCK_DEGRADATION_THRESHOLD
        action_to_take: Action
        if current_stock < self.CRITICAL_STOCK_ABSOLUTE_THRESHOLD:
            if num_other_defectors_prev_round >= self.SEVERE_DEFECTION_THRESHOLD_CRITICAL:
                action_to_take = Action.D
            else:
                action_to_take = Action.C
        elif current_stock < self.IDEAL_COOPERATION_STOCK_LEVEL or stock_degraded_significantly:
            if num_other_defectors_prev_round > self.TOLERABLE_OTHER_DEFECTORS_DEGRADING_OR_CRITICAL_STOCK:
                action_to_take = Action.D
            else:
                action_to_take = Action.C
        elif num_other_defectors_prev_round <= self.TOLERABLE_OTHER_DEFECTORS_HIGH_STOCK:
            action_to_take = Action.C
        else:
            action_to_take = Action.D
        self._previous_round_start_stock = current_stock
        return action_to_take

class Strategy_COLLECTIVE_100(BaseStrategy):
    """
    Adaptive Sustainable Reciprocity (ASR) strategy for the Common Pool Resource Game.
    This strategy prioritizes the health of the shared resource and employs conditional
    cooperation, responding to the collective actions of other players to foster
    sustainable management while being robust against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_recovery_threshold = 0.5 * self.game_description.capacity
        self.defection_tolerance_threshold = max(1, math.floor(self.game_description.n_players / 3))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds_1_indexed = self.game_description.n_rounds
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == total_rounds_1_indexed:
            return Action.D
        if state.current_stock < self.stock_recovery_threshold:
            return Action.C
        else:
            num_defectors_last_round = np.sum(history.opponent_actions[-1, :] == False)
            if num_defectors_last_round <= self.defection_tolerance_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_101(BaseStrategy):
    """
    The Adaptive Resource Steward (ARS) strategy for the Common Pool Resource Game.
    It aims for long-term resource sustainability by starting with cooperation,
    and then adaptively responding to opponent behavior and the current health
    of the common resource. It incorporates thresholds for stock levels to
    prioritize conservation and applies proportional punishment for defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_threshold = 0.25 * self.capacity
        self.recovery_stock_threshold = 0.75 * self.capacity
        self.defection_proportion_for_punishment_strict = 0.35
        self.defection_proportion_for_punishment_lenient = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        num_opponents = self.n_players - 1
        num_cooperators_prev_round = np.sum(history.opponent_actions[-1, :])
        num_defectors_prev_round = num_opponents - num_cooperators_prev_round
        if state.current_stock <= self.critical_stock_threshold:
            return Action.C
        elif state.current_stock >= self.recovery_stock_threshold:
            punishment_threshold = num_opponents * self.defection_proportion_for_punishment_lenient
            if num_defectors_prev_round >= punishment_threshold:
                return Action.D
            else:
                return Action.C
        else:
            punishment_threshold = num_opponents * self.defection_proportion_for_punishment_strict
            if num_defectors_prev_round >= punishment_threshold:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_102(BaseStrategy):
    """
    The Adaptive Stock-Aware Reciprocity (ASAR) strategy balances collective resource sustainability
    with individual protection. It starts with cooperation, preserves stock when critically low,
    and employs conditional reciprocity based on previous round's opponent cooperation,
    while defecting in the final round for self-interest.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold_ocr: float = 0.5
        self.critical_stock_ratio: float = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock <= self.game_description.capacity * self.critical_stock_ratio:
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        num_cooperators_prev = np.sum(previous_round_opponent_actions)
        n_other_players = self.game_description.n_players - 1
        ocr_prev = num_cooperators_prev / n_other_players
        if ocr_prev >= self.cooperation_threshold_ocr:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_103(BaseStrategy):
    """
    The Adaptive Resource Guardian (ARG) strategy for the Common Pool Resource Game.
    This strategy prioritizes the long-term sustainability of the common stock
    while dynamically responding to observed player behavior and the current
    state of the resource. It aims to encourage cooperation but defends against
    exploitation and resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_tolerance_ratio = 0.25
        self.critical_stock_threshold_ratio = 0.4
        self.recovery_stock_threshold_ratio = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        if current_round_number == 0:
            return Action.C
        if current_round_number == self.r - 1:
            return Action.D
        S_current = state.current_stock
        current_stock_ratio = S_current / self.capacity
        player_actions_prev_round = history.opponent_actions[-1, :]
        num_C_prev = np.sum(player_actions_prev_round)
        num_D_prev = self.n - num_C_prev
        observed_defection_rate = num_D_prev / self.n
        if current_stock_ratio < self.critical_stock_threshold_ratio:
            return Action.D
        elif observed_defection_rate > self.defection_tolerance_ratio:
            return Action.D
        elif current_stock_ratio >= self.recovery_stock_threshold_ratio and num_D_prev == 0:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_104(BaseStrategy):
    """
    The Sustainable Adaptive Player (SAP) strategy balances individual short-term incentives with
    the long-term collective goal of sustaining the common pool resource. It prioritizes resource health,
    promotes and enforces cooperation, and adapts based on game state and opponent actions, with a
    pragmatic self-interested approach in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.recovery_stock_threshold = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if state.current_stock < self.recovery_stock_threshold:
            return Action.C
        if current_round_1_indexed == 1:
            return Action.C
        previous_round_0_indexed = state.round_number - 1
        previous_opponent_actions = history.opponent_actions[previous_round_0_indexed, :]
        if np.all(previous_opponent_actions):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_105(BaseStrategy):
    """
    The Collective Guardian strategy is designed for long-term resource sustainability and aims to
    foster a cooperative environment among players while being robust against defection. It balances
    the collective good (maintaining the common stock) with individual rationality within a repeated
    game context.

    Core Principles:
    1. Start Cooperative: Begin by cooperating to establish a high stock trajectory.
    2. Prioritize Stock Recovery: If stock falls critically low, immediate cooperation for recovery.
    3. Punish Defection: Deviations from collective cooperation are met with punishment.
    4. Forgive and Revert: After consistent cooperation, forgive and revert to cooperation.
    5. Rational End-Game: In the final round, play rationally to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / self.n_players
        self.DEFECTOR_TOLERANCE_THRESHOLD = 1
        self.FORGIVENESS_ROUNDS = 2
        self.punishment_mode_active = False
        self.rounds_since_last_full_cooperation = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        prev_round_my_action_was_D = not history.my_actions[-1]
        prev_round_opponent_actions_bools = history.opponent_actions[-1, :]
        num_D_opponents_prev = sum((not act for act in prev_round_opponent_actions_bools))
        num_D_prev = num_D_opponents_prev
        if prev_round_my_action_was_D:
            num_D_prev += 1
        if state.current_stock < self.CRITICAL_STOCK_THRESHOLD:
            self.punishment_mode_active = False
            self.rounds_since_last_full_cooperation = 0
            return Action.C
        if self.punishment_mode_active:
            if num_D_prev == 0:
                self.rounds_since_last_full_cooperation += 1
                if self.rounds_since_last_full_cooperation >= self.FORGIVENESS_ROUNDS:
                    self.punishment_mode_active = False
                    self.rounds_since_last_full_cooperation = 0
                    return Action.C
                else:
                    return Action.D
            else:
                self.rounds_since_last_full_cooperation = 0
                return Action.D
        elif num_D_prev >= self.DEFECTOR_TOLERANCE_THRESHOLD:
            self.punishment_mode_active = True
            self.rounds_since_last_full_cooperation = 0
            return Action.D
        else:
            self.rounds_since_last_full_cooperation = 0
            return Action.C

class Strategy_COLLECTIVE_106(BaseStrategy):
    """
    The "Dynamic Stock Protector (DSP)" strategy for the Common Pool Resource Game.
    It adapts its behavior based on stock levels and collective actions to promote long-term sustainability
    while protecting against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        capacity = game_description.capacity
        n_players = game_description.n_players
        self.COOPERATION_THRESHOLD_HIGH_STOCK = 0.75 * capacity
        self.COOPERATION_THRESHOLD_MID_STOCK = 0.5 * capacity
        self.DEFECTION_THRESHOLD_LOW_STOCK = 0.25 * capacity
        self.CRITICAL_STOCK_LEVEL = max(0.05 * capacity, capacity / (2 * n_players))

    def _get_max_tolerated_defectors(self, current_stock_level: float, n_players: int) -> int:
        """
        Calculates the maximum number of defectors that can be tolerated based on the
        current stock level and the total number of players.
        """
        if n_players <= 4:
            if current_stock_level >= self.COOPERATION_THRESHOLD_HIGH_STOCK:
                return 1
            elif current_stock_level >= self.COOPERATION_THRESHOLD_MID_STOCK:
                return 0
            else:
                return 0
        elif current_stock_level >= self.COOPERATION_THRESHOLD_HIGH_STOCK:
            return max(1, math.floor(n_players / 4))
        elif current_stock_level >= self.COOPERATION_THRESHOLD_MID_STOCK:
            return max(1, math.floor(n_players / 8))
        elif current_stock_level >= self.DEFECTION_THRESHOLD_LOW_STOCK:
            return 0
        else:
            return 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        n_players = self.game_description.n_players
        my_prev_action_was_D = not history.my_actions[-1]
        opponent_D_count_prev_round = np.sum(~history.opponent_actions[-1, :])
        D_count_prev_round = opponent_D_count_prev_round + (1 if my_prev_action_was_D else 0)
        if state.current_stock < self.CRITICAL_STOCK_LEVEL:
            return Action.D
        max_tolerated_defectors = self._get_max_tolerated_defectors(state.current_stock, n_players)
        if D_count_prev_round > max_tolerated_defectors:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_107(BaseStrategy):
    """
    The "Resource-First Adaptive" strategy prioritizes common pool resource sustainability.
    It starts cooperatively, defects in the last round, and otherwise dynamically adjusts behavior
    based on the current stock level and observed defection among other players. It has an
    emergency mode for critically low stock (always cooperate), a full capacity mode (punish
    any defection), and a depleted but not critical mode (punish significant defection,
    forgive minor defection).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_critical = 2 * self.game_description.n_players
        self.D_significant_threshold = self.game_description.n_players / 3.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            D_count_last_round = sum((1 for action in history.opponent_actions[-1, :] if not action))
            if state.current_stock < self.S_critical:
                return Action.C
            elif state.current_stock == self.game_description.capacity:
                if D_count_last_round > 0:
                    return Action.D
                else:
                    return Action.C
            elif D_count_last_round == 0:
                return Action.C
            elif D_count_last_round >= self.D_significant_threshold:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_108(BaseStrategy):
    """
    The Adaptive Collective Steward strategy balances resource sustainability
    with self-preservation. It aims to cooperate proactively, adapt to opponent
    behavior and resource health, and deter exploitation, especially when
    the common pool stock is critically low. It recognizes the distinct
    incentives of the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold = self.game_description.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        if current_round == 0:
            return Action.C
        if current_round == total_rounds - 1:
            return Action.D
        num_C_prev_opponents = sum(history.opponent_actions[-1, :])
        num_D_prev_opponents = n_players - 1 - num_C_prev_opponents
        if current_stock < self.critical_stock_threshold:
            if num_D_prev_opponents == 0:
                return Action.C
            else:
                return Action.D
        else:
            cooperation_tolerance_threshold = math.floor((n_players - 1) / 2)
            if num_D_prev_opponents <= cooperation_tolerance_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_109(BaseStrategy):
    """
    The "Adaptive Resource Steward" strategy prioritizes the long-term health of the common resource,
    aiming to foster and maintain a cooperative equilibrium. It is pragmatic, defending its own
    interests when cooperation breaks down or the resource is critically endangered.

    It adapts its behavior based on the current stock level and the observed defection rate
    of all players (including itself) in the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_tolerance_ratio = 0.25
        self.stock_health_threshold = 0.5
        self.stock_crisis_threshold = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if round_num_1_indexed == total_rounds:
            return Action.D
        if round_num_1_indexed == 1:
            return Action.C
        all_players_actions_prev_round = np.concatenate((history.my_actions[-1:], history.opponent_actions[-1, :]))
        n_defected_prev_round = np.sum(~all_players_actions_prev_round)
        observed_defection_rate = n_defected_prev_round / n_players
        normalized_stock = current_stock / capacity
        if normalized_stock <= self.stock_crisis_threshold:
            return Action.D
        elif normalized_stock < self.stock_health_threshold:
            if observed_defection_rate <= self.cooperation_tolerance_ratio:
                return Action.C
            else:
                return Action.D
        elif observed_defection_rate <= self.cooperation_tolerance_ratio:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_110(BaseStrategy):
    """
    Adaptive Collective Steward: Promotes long-term sustainability through cooperation,
    defends against exploitation, and signals consequences for defection.
    Adapts behavior based on current stock health and rationalizes end-game play.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.other_player_defection_streaks: dict[int, int] = {}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_1_indexed = state.round_number + 1
        if state.round_number == 0:
            for opp_idx in range(n_players - 1):
                self.other_player_defection_streaks[opp_idx] = 0
            return Action.C
        if current_round_1_indexed == n_rounds:
            return Action.D
        prev_round_my_action_is_C = history.my_actions[state.round_number - 1]
        prev_round_opponent_actions_is_C = history.opponent_actions[state.round_number - 1, :]
        for opp_idx, action_is_C in enumerate(prev_round_opponent_actions_is_C):
            if not action_is_C:
                self.other_player_defection_streaks[opp_idx] += 1
            else:
                self.other_player_defection_streaks[opp_idx] = 0
        num_cooperators_prev_round = int(prev_round_my_action_is_C) + np.sum(prev_round_opponent_actions_is_C)
        num_defectors_prev_round = n_players - num_cooperators_prev_round
        if num_cooperators_prev_round == n_players:
            return Action.C
        if state.current_stock < capacity / 2:
            return Action.D
        has_persistent_defector = False
        for opp_idx in range(n_players - 1):
            if self.other_player_defection_streaks[opp_idx] >= 2:
                has_persistent_defector = True
                break
        if has_persistent_defector:
            return Action.D
        elif num_defectors_prev_round <= 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_111(BaseStrategy):
    """
    The Adaptive Sentinel (Collective) strategy for the Common Pool Resource Game.
    This strategy is designed to be highly adaptive to opponent behaviors and stock levels,
    robust to various playing styles, and prioritize the sustainability of the common
    resource while remaining competitive. It balances individual self-preservation
    with the collective goal of resource management through dynamic thresholds
    and collective reciprocity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.FORGIVENESS_THRESHOLD_RATIO = 0.25
        self.PUNISHMENT_THRESHOLD_RATIO = 0.75
        self.forgiveness_threshold = self.FORGIVENESS_THRESHOLD_RATIO * self.capacity
        self.punishment_threshold = self.PUNISHMENT_THRESHOLD_RATIO * self.capacity
        self.defector_tolerance = math.floor(self.n_players / 4)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        elif current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        num_opponent_players = self.n_players - 1
        num_cooperate_previous_round = np.sum(history.opponent_actions[-1, :])
        num_defect_previous_round = num_opponent_players - num_cooperate_previous_round
        if current_stock < self.forgiveness_threshold:
            return Action.C
        elif current_stock >= self.punishment_threshold:
            if num_defect_previous_round == 0:
                return Action.C
            else:
                return Action.D
        elif num_defect_previous_round == 0:
            return Action.C
        elif num_defect_previous_round <= self.defector_tolerance:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_112(BaseStrategy):
    """
    Sustainable Reciprocity with Adaptive Recovery (SR-AR) strategy for the Common Pool Resource Game.
    This strategy prioritizes resource sustainability through adaptive cooperation and defection rules.
    It initiates cooperation, monitors opponent actions, and adjusts its tolerance for defection
    based on the current stock level. It also includes specific rules for critical stock levels
    to attempt recovery or, if overwhelmed by defection, defect to secure individual gains.
    In the final round, it defects due to a lack of future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.HEALTHY_STOCK_THRESHOLD = self.capacity * 0.75
        self.CRITICAL_STOCK_THRESHOLD = self.capacity * 0.25
        self.OVERWHELMING_DEFECTION_THRESHOLD = math.ceil(self.n / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        total_rounds = self.r
        current_stock = state.current_stock
        if current_round_number == total_rounds - 1:
            return Action.D
        if current_round_number == 0:
            return Action.C
        opponent_actions_last_round = history.opponent_actions[-1, :]
        num_defectors_last_round = np.sum(~opponent_actions_last_round)
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            if num_defectors_last_round >= self.OVERWHELMING_DEFECTION_THRESHOLD:
                return Action.D
            else:
                return Action.C
        else:
            current_forgiveness_level = 0
            if current_stock >= self.HEALTHY_STOCK_THRESHOLD:
                current_forgiveness_level = math.floor(self.n / 4)
                if current_forgiveness_level == 0 and self.n > 1:
                    current_forgiveness_level = 1
            if num_defectors_last_round > current_forgiveness_level:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_113(BaseStrategy):
    """
    Adaptive Conservationist (AC) strategy for the Common Pool Resource Game.

    This strategy aims for long-term resource sustainability at capacity. It
    defaults to cooperation but adapts its behavior based on the current
    resource level and the observed actions of other players.

    It initiates with cooperation, maintains it when others cooperate, and
    forgives minor defections. It resorts to defection in the final round,
    when the resource is critically low and all other players are defecting,
    or when significant defection by the collective is observed.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / 4
        self.SIGNIFICANT_DEFECTION_THRESHOLD = math.ceil(self.n_players / 3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num = state.round_number
        current_stock = state.current_stock
        if current_round_num == 0:
            return Action.C
        if current_round_num == self.n_rounds - 1:
            return Action.D
        prev_round_history_idx = current_round_num - 1
        my_action_was_D_prev_round = history.my_actions[prev_round_history_idx] == False
        num_D_others_prev_round = np.sum(history.opponent_actions[prev_round_history_idx, :] == False)
        num_D_total_prev_round = num_D_others_prev_round + (1 if my_action_was_D_prev_round else 0)
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            if num_D_others_prev_round == self.n_players - 1:
                return Action.D
            else:
                return Action.C
        elif num_D_total_prev_round == 0:
            return Action.C
        elif num_D_total_prev_round < self.SIGNIFICANT_DEFECTION_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_114(BaseStrategy):
    """
    Adaptive Conditional Cooperator with Stock Safeguard (ACCS) strategy.

    This strategy aims to foster cooperation for long-term sustainability of the
    common resource while protecting itself from exploitation. It starts
    cooperatively, attempts to enforce cooperation through conditional responses
    to defection, and employs a critical safeguard to recover the resource
    when it's under threat. It also accounts for the finite nature of the game
    in the final round to prevent exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        if self.n_players == 2:
            self.defection_tolerance_threshold = 0
        else:
            self.defection_tolerance_threshold = 1
        self.critical_stock_ratio = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        critical_stock_threshold = self.critical_stock_ratio * self.capacity
        if state.current_stock < critical_stock_threshold:
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        num_opponents = previous_round_opponent_actions.shape[0]
        num_cooperators_last_round = np.sum(previous_round_opponent_actions)
        num_defectors_last_round = num_opponents - num_cooperators_last_round
        if num_defectors_last_round > self.defection_tolerance_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_115(BaseStrategy):
    """
    The Adaptive Collective Steward strategy balances individual incentives with long-term collective good.
    It prioritizes resource sustainability, leads with cooperation, and adapts behavior based on stock levels
    and observed opponent cooperation. It features critical conservation mode and end-game rationality.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_factor = 0.25
        self.moderate_stock_factor = 0.5
        self.cooperation_threshold_healthy_stock = 0.6
        self.cooperation_threshold_moderate_stock = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        num_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        is_last_round = current_round_0_indexed == total_rounds - 1
        if is_last_round:
            return Action.D
        if current_stock < self.critical_stock_factor * capacity:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.C
        else:
            num_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
            cooperation_ratio = num_cooperators_last_round / num_players
            dynamic_cooperation_threshold: float
            if current_stock < self.moderate_stock_factor * capacity:
                dynamic_cooperation_threshold = self.cooperation_threshold_moderate_stock
            else:
                dynamic_cooperation_threshold = self.cooperation_threshold_healthy_stock
            if cooperation_ratio >= dynamic_cooperation_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_116(BaseStrategy):
    """
    The Adaptive Community Steward (ACS) strategy starts cooperatively,
    then adapts based on observed collective cooperation. It calculates a
    forgiveness threshold (K) to tolerate minor defections but retaliates
    against significant collective free-riding to protect the common resource
    and prevent exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.forgiveness_threshold_K = max(1, math.floor(self.n_players / 4))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number
        if current_round_t == 0:
            return Action.C
        if current_round_t == self.n_rounds - 1:
            return Action.D
        prev_round_opponent_actions = history.opponent_actions[current_round_t - 1, :]
        ND_prev = np.sum(prev_round_opponent_actions == False)
        if ND_prev <= self.forgiveness_threshold_K:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_117(BaseStrategy):
    """
    Adaptive Collective Guardian (ACG) strategy for the Common Pool Resource Game.
    This strategy aims to foster cooperation for resource sustainability,
    adapting to opponent behavior by rewarding high cooperation, punishing low cooperation,
    and prioritizing resource recovery when stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold_high = 0.75
        self.cooperation_threshold_low = 0.5
        self.stock_warning_threshold_ratio = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_round == 0:
            return Action.C
        if current_round == total_rounds - 1:
            return Action.D
        num_cooperators_last_round = int(history.my_actions[-1]) + np.sum(history.opponent_actions[-1, :])
        cooperation_ratio_last_round = num_cooperators_last_round / n_players
        if current_stock < self.stock_warning_threshold_ratio * capacity:
            if cooperation_ratio_last_round >= self.cooperation_threshold_low:
                return Action.C
            else:
                return Action.D
        elif cooperation_ratio_last_round >= self.cooperation_threshold_high:
            return Action.C
        elif cooperation_ratio_last_round < self.cooperation_threshold_low:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_118(BaseStrategy):
    """
    Adaptive Stock-Preserving Cooperator (ASPC) strategy.
    This strategy balances resource sustainability with individual performance.
    It starts cooperatively, enforces conservation via stock thresholds, and
    dynamically adjusts to defection based on group size and number of defectors.
    It's more forgiving in larger groups but employs a stricter Tit-for-Tat in two-player games.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_threshold_danger = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == 0:
            return Action.C
        if current_round_number == self.n_rounds - 1:
            return Action.D
        if current_stock < self.S_threshold_danger:
            return Action.C
        else:
            prev_round_idx = current_round_number - 1
            my_action_prev = history.my_actions[prev_round_idx]
            opponent_actions_prev = history.opponent_actions[prev_round_idx]
            total_cooperators_prev = np.sum(opponent_actions_prev) + (1 if my_action_prev else 0)
            num_defectors_prev_round = self.n_players - total_cooperators_prev
            if self.n_players == 2:
                if num_defectors_prev_round == 0:
                    return Action.C
                else:
                    return Action.D
            elif num_defectors_prev_round == 0:
                return Action.C
            elif num_defectors_prev_round == 1:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_119(BaseStrategy):
    """
    The Adaptive Conservationist: Prioritizes long-term resource sustainability through cooperation,
    but adapts to opponent defection and enforces conservation during critical stock depletion.
    It defaults to cooperation, punishes widespread defection, and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self._low_stock_threshold = capacity / 4.0
        self._defection_tolerance_threshold = math.floor(n / 3.0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        if current_stock <= self._low_stock_threshold:
            return Action.C
        else:
            previous_round_index = current_round_0_indexed - 1
            num_opponent_cooperators_prev_round = np.sum(history.opponent_actions[previous_round_index, :])
            num_opponent_defectors_prev_round = n_players - 1 - num_opponent_cooperators_prev_round
            if num_opponent_defectors_prev_round <= self._defection_tolerance_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_120(BaseStrategy):
    """
    Adaptive Resource Steward with Forgiveness:
    This strategy aims for sustainable resource management by adapting its behavior based on
    current stock levels and past opponent actions. It prioritizes resource survival when
    stock is low, fosters cooperation when recovering, and retaliates defensively against
    excessive defection only when the resource is healthy. It starts cooperatively and
    defects in the final round for short-term gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters and pre-calculates stock thresholds
        and the maximum tolerated number of defectors.
        """
        self.game_description = game_description
        self.CRITICAL_STOCK_LEVEL = 0.1 * self.game_description.capacity
        self.RECOVERY_STOCK_LEVEL = 0.25 * self.game_description.capacity
        self.HEALTHY_STOCK_LEVEL = 0.5 * self.game_description.capacity
        self.MAX_TOLERATED_DEFECTORS = max(1, math.floor(self.game_description.n_players / 4))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round based on the
        strategy's rules.
        """
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        my_action_last_round_was_D = not history.my_actions[current_round_0_indexed - 1]
        num_opponent_defectors_last_round = np.sum(~history.opponent_actions[current_round_0_indexed - 1, :])
        num_defectors_last_round = (1 if my_action_last_round_was_D else 0) + num_opponent_defectors_last_round
        if current_stock <= self.CRITICAL_STOCK_LEVEL:
            return Action.C
        elif current_stock <= self.RECOVERY_STOCK_LEVEL:
            return Action.C
        elif current_stock <= self.HEALTHY_STOCK_LEVEL:
            return Action.C
        elif num_defectors_last_round <= self.MAX_TOLERATED_DEFECTORS:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_121(BaseStrategy):
    """
    The Adaptive Resource Manager (ARM) strategy for the Common Pool Resource Game.
    It adapts its behavior based on the current health of the common resource
    and the observed cooperation levels of all players in the previous round,
    balancing individual gain with collective resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_critical_ratio = 0.1
        self.S_danger_ratio = 0.3
        self.S_stable_ratio = 0.7
        self.P_coop_danger_threshold = 0.3
        self.P_coop_min_threshold = 0.5
        self.P_coop_stable_threshold = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num_1_indexed = state.round_number + 1
        if round_num_1_indexed == 1:
            return Action.C
        if round_num_1_indexed == self.n_rounds:
            return Action.D
        num_cooperators_prev_round = sum(history.opponent_actions[-1, :]) + history.my_actions[-1]
        alpha = num_cooperators_prev_round / self.n_players
        current_stock = state.current_stock
        if current_stock < self.capacity * self.S_critical_ratio:
            return Action.C
        elif current_stock < self.capacity * self.S_danger_ratio:
            if alpha >= self.P_coop_danger_threshold:
                return Action.C
            else:
                return Action.D
        elif current_stock >= self.capacity * self.S_stable_ratio:
            if alpha >= self.P_coop_stable_threshold:
                return Action.C
            else:
                return Action.D
        elif alpha >= self.P_coop_min_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_122(BaseStrategy):
    """
    Adaptive Conservationist strategy for the Common Pool Resource Game.
    Prioritizes the long-term sustainability of the common pool resource while
    remaining resilient to exploitation. It begins with a cooperative stance,
    but adapts its behavior based on observed actions of other players and
    the health of the resource stock. It aims to foster cooperation when possible,
    punish persistent exploitation, and protect its own interests when the
    resource is critically endangered or at the game's end.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._consecutive_majority_defections: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        num_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == 0:
            self._consecutive_majority_defections = 0
            return Action.C
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        defections_count_last_round = (previous_round_opponent_actions == False).sum()
        num_other_players = num_players - 1
        defect_ratio = defections_count_last_round / num_other_players
        if defect_ratio >= 0.5:
            self._consecutive_majority_defections += 1
        else:
            self._consecutive_majority_defections = 0
        if current_stock < capacity / 4.0:
            if defect_ratio >= 0.5 or self._consecutive_majority_defections >= 2:
                return Action.D
            else:
                return Action.C
        elif defections_count_last_round == 0:
            return Action.C
        elif defect_ratio >= 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_123(BaseStrategy):
    """
    The Adaptive Guardian strategy balances initial cooperation and resource stewardship with pragmatic 
    self-preservation against exploitation in the Common Pool Resource Game. It starts with cooperation, 
    then adapts its behavior based on the observed cooperation levels of other players and the current 
    state of the common pool stock. It demands higher collective cooperation when the stock is low 
    and defects in the final round to avoid exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_stress_threshold_ratio = 0.6
        self.stock_critical_threshold_ratio = 0.2
        self.cooperation_threshold_normal = 0.5
        self.cooperation_threshold_stressed = 0.7
        self.cooperation_threshold_critical = 0.85

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        num_players_n = self.game_description.n_players
        if current_round == 0:
            return Action.C
        if current_round == total_rounds - 1:
            return Action.D
        effective_cooperation_threshold: float
        stress_stock_level = capacity * self.stock_stress_threshold_ratio
        critical_stock_level = capacity * self.stock_critical_threshold_ratio
        if current_stock < critical_stock_level:
            effective_cooperation_threshold = self.cooperation_threshold_critical
        elif current_stock < stress_stock_level:
            effective_cooperation_threshold = self.cooperation_threshold_stressed
        else:
            effective_cooperation_threshold = self.cooperation_threshold_normal
        num_other_players = num_players_n - 1
        if num_other_players == 0:
            return Action.C
        num_other_cooperators_prev_round = np.sum(history.opponent_actions[-1, :])
        proportion_other_cooperators_prev_round = num_other_cooperators_prev_round / num_other_players
        if proportion_other_cooperators_prev_round >= effective_cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_124(BaseStrategy):
    """
    Adaptive Collective Sustainer (ACS) strategy for the Common Pool Resource game.
    This strategy is designed to promote and maintain collective cooperation for resource
    sustainability. It prioritizes the long-term health of the shared resource while
    being adaptive and robust against various opponent behaviors, including exploitation.

    The core idea is to start cooperatively, react to the collective behavior of other
    players, become more stringent when the resource is threatened, and anticipate
    end-game defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_duration = 2
        self.leniency_threshold_percentage = 0.1
        self.critical_stock_ratio = 0.25
        self.recovery_stock_ratio = 0.5
        self.punishment_countdown = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        num_players = self.game_description.n_players
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round_1_indexed == 1:
            self.punishment_countdown = 0
            return Action.C
        if current_round_1_indexed == total_rounds:
            return Action.D
        if self.punishment_countdown > 0:
            self.punishment_countdown -= 1
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[state.round_number - 1]
        num_defectors_last_round = (~previous_round_opponent_actions).sum()
        stock_level_classification = None
        if current_stock < capacity * self.critical_stock_ratio:
            stock_level_classification = 'CRITICAL'
        elif current_stock < capacity * self.recovery_stock_ratio:
            stock_level_classification = 'RECOVERING'
        else:
            stock_level_classification = 'HEALTHY'
        if stock_level_classification == 'CRITICAL':
            if num_defectors_last_round > 0:
                self.punishment_countdown = self.punishment_duration
                return Action.D
            else:
                return Action.C
        elif stock_level_classification == 'RECOVERING':
            if num_defectors_last_round > 0:
                self.punishment_countdown = self.punishment_duration
                return Action.D
            else:
                return Action.C
        elif stock_level_classification == 'HEALTHY':
            max_tolerated_defectors = math.floor(num_players * self.leniency_threshold_percentage)
            if num_defectors_last_round > max_tolerated_defectors:
                self.punishment_countdown = self.punishment_duration
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_125(BaseStrategy):
    """
    The "Adaptive Resource Manager" strategy balances collective sustainability
    with robustness against exploitative behavior. It prioritizes the health
    of the common resource but learns to defend itself when others consistently
    free-ride or when the resource is pushed to the brink.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_DEPLETION_THRESHOLD = self.capacity * 0.1
        self.RECOVERY_THRESHOLD = self.capacity * 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        n_opponents = self.n_players - 1
        n_others_cooperated_last_round = np.sum(history.opponent_actions[-1, :])
        n_others_defected_last_round = n_opponents - n_others_cooperated_last_round
        if current_stock < self.CRITICAL_DEPLETION_THRESHOLD:
            if n_others_defected_last_round > n_opponents / 2.0:
                return Action.D
            else:
                return Action.C
        if n_others_defected_last_round == 0:
            return Action.C
        if current_stock < self.RECOVERY_THRESHOLD:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_126(BaseStrategy):
    """
    Adaptive Stock Guardian strategy for the Common Pool Resource Game.
    This strategy prioritizes long-term sustainability by adapting its cooperativeness
    based on the common stock's health and observed opponent behaviors. It aims to
    foster cooperation, punish exploitation, and act rationally in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_critical = self.capacity / 2.0
        self.S_recovery_target = self.capacity * 0.9
        self.COOPERATION_THRESHOLD_BASE = (self.n - 1) / float(self.n)
        if self.n > 2:
            self.COOPERATION_THRESHOLD_FORGIVING = (self.n - 2) / float(self.n)
        else:
            self.COOPERATION_THRESHOLD_FORGIVING = self.COOPERATION_THRESHOLD_BASE

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_idx = state.round_number
        total_rounds = self.r
        current_stock = state.current_stock
        if current_round_idx == 0:
            return Action.C
        if current_round_idx == total_rounds - 1:
            return Action.D
        if current_stock <= self.S_critical:
            return Action.C
        else:
            prev_my_action = history.my_actions[-1]
            prev_opponent_actions = history.opponent_actions[-1, :]
            num_cooperators_prev = np.sum(prev_opponent_actions) + int(prev_my_action)
            cooperation_index_prev = num_cooperators_prev / float(self.n)
            dynamic_coop_threshold = self.COOPERATION_THRESHOLD_BASE
            if current_stock >= self.S_recovery_target and self.n > 2:
                dynamic_coop_threshold = self.COOPERATION_THRESHOLD_FORGIVING
            if cooperation_index_prev >= dynamic_coop_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_127(BaseStrategy):
    """
    Collective Adaptive Resource Management (CARM) Strategy for the Common Pool Resource Game.
    This strategy aims to maximize total payoff by promoting sustainable resource management,
    while also protecting itself from exploitation by non-cooperative opponents. It prioritizes
    the health of the common stock and adapts its behavior based on observed opponent actions
    and the current state of the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.STOCK_CRITICAL_LOW = self.capacity / 4.0
        self.STOCK_WARNING_LOW = self.capacity / 2.0
        self.TOLERABLE_DEFECTIONS_MINOR = math.floor(self.n / 4.0)
        self.TOLERABLE_DEFECTIONS_MAJOR = math.floor(self.n / 2.0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        elif current_round_0_indexed == self.r - 1:
            if current_stock >= self.STOCK_WARNING_LOW:
                return Action.C
            else:
                return Action.D
        else:
            previous_opponent_defections_count = np.sum(~history.opponent_actions[-1, :])
            if current_stock <= self.STOCK_CRITICAL_LOW:
                if previous_opponent_defections_count >= self.TOLERABLE_DEFECTIONS_MAJOR:
                    return Action.D
                else:
                    return Action.C
            elif current_stock <= self.STOCK_WARNING_LOW:
                if previous_opponent_defections_count >= self.TOLERABLE_DEFECTIONS_MAJOR:
                    return Action.D
                else:
                    return Action.C
            elif previous_opponent_defections_count == 0:
                return Action.C
            elif previous_opponent_defections_count <= self.TOLERABLE_DEFECTIONS_MINOR:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_128(BaseStrategy):
    """
    Adaptive Resource Guardian strategy for the Common Pool Resource Game.
    This strategy prioritizes the health and sustainability of the common pool stock
    while adapting its behavior based on observed opponent cooperation levels.
    It initiates cooperation, punishes defection to maintain norms, and acknowledges
    the shift in incentives during the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOPERATION_THRESHOLD = 0.5
        self.STOCK_HEALTHY_THRESHOLD_FACTOR = 0.75
        self.STOCK_WARNING_THRESHOLD_FACTOR = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == 0:
            return Action.C
        if current_round_number == r - 1:
            return Action.D
        num_cooperators_prev_round = sum(history.opponent_actions[-1, :])
        n_minus_1 = n - 1
        opponent_cooperation_rate = num_cooperators_prev_round / n_minus_1
        is_stock_critical = current_stock < capacity * self.STOCK_WARNING_THRESHOLD_FACTOR
        is_stock_warning = current_stock >= capacity * self.STOCK_WARNING_THRESHOLD_FACTOR and current_stock < capacity * self.STOCK_HEALTHY_THRESHOLD_FACTOR
        is_stock_healthy = current_stock >= capacity * self.STOCK_HEALTHY_THRESHOLD_FACTOR
        if is_stock_critical:
            if opponent_cooperation_rate >= self.COOPERATION_THRESHOLD:
                return Action.C
            else:
                return Action.D
        elif is_stock_warning:
            if opponent_cooperation_rate >= self.COOPERATION_THRESHOLD:
                return Action.C
            else:
                return Action.D
        elif is_stock_healthy:
            if opponent_cooperation_rate >= self.COOPERATION_THRESHOLD:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_129(BaseStrategy):
    """
    Resource-Oriented Tit-for-Tat (RO-TfT) is an adaptive strategy for the Common Pool Resource Game.
    It prioritizes long-term resource sustainability by starting cooperatively, but responds to
    defections from other players (Tit-for-Tat logic) and signals a severe alarm (by defecting)
    if the shared resource stock drops to a critically low level. It features a short punishment
    duration and a recovery mechanism for the resource-alarm state to foster quick re-establishment
    of cooperation. In the final round, it defects to maximize immediate payoff, as there are no
    future interactions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_RATIO = 0.5
        self.TOLERATED_DEFECTORS = 0
        self.PUNISHMENT_DURATION = 1
        self.my_previous_action: Action = Action.C
        self.punish_for_stock_mismanagement: bool = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        n_rounds_total = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if current_round == 0:
            self.my_previous_action = Action.C
            self.punish_for_stock_mismanagement = False
            return Action.C
        if current_round == n_rounds_total - 1:
            self.my_previous_action = Action.D
            return Action.D
        num_defectors_prev_round = np.sum(~history.opponent_actions[-1, :])
        critical_level = self.CRITICAL_STOCK_RATIO * capacity
        recovery_level = (self.CRITICAL_STOCK_RATIO + 0.1) * capacity
        if current_stock < critical_level:
            self.punish_for_stock_mismanagement = True
        elif current_stock >= recovery_level:
            self.punish_for_stock_mismanagement = False
        action_to_take = Action.C
        if self.punish_for_stock_mismanagement:
            action_to_take = Action.D
        elif num_defectors_prev_round > self.TOLERATED_DEFECTORS:
            action_to_take = Action.D
        self.my_previous_action = action_to_take
        return action_to_take

class Strategy_COLLECTIVE_130(BaseStrategy):
    """
    The "Adaptive Steward" strategy for the Common Pool Resource Game.

    This strategy prioritizes the sustainability of the common resource.
    It starts cooperatively, adapts its behavior based on the resource's health
    and the cooperation levels of other players, and enforces cooperation when
    necessary to prevent exploitation, without leading to absolute resource collapse.

    Key principles:
    1. Resource Preservation First: Cooperate unconditionally when stock is critical.
    2. Conditional Cooperation: Default to cooperation, but require a majority of
       players to cooperate to continue.
    3. Punishment for Free-Riding: Defect when cooperation is insufficient,
       especially when the resource is not critically endangered.
    4. Endgame Rationality: Defect in the final round to maximize individual payoff
       when there are no future consequences for the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.s_critical_threshold = self.capacity / 4.0
        self.s_warning_threshold = self.capacity / 2.0
        self.cooperation_threshold_count = math.floor(self.n_players / 2) + 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock_level = state.current_stock
        if current_round_number == self.n_rounds - 1:
            return Action.D
        if current_round_number == 0:
            return Action.C
        c_count_last_round = int(history.my_actions[-1]) + np.sum(history.opponent_actions[-1, :])
        if current_stock_level < self.s_critical_threshold:
            return Action.C
        elif self.s_critical_threshold <= current_stock_level < self.s_warning_threshold:
            if c_count_last_round >= self.cooperation_threshold_count:
                return Action.C
            else:
                return Action.D
        elif c_count_last_round >= self.cooperation_threshold_count:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_131(BaseStrategy):
    """
    Adaptive Conservationist strategy for the Common Pool Resource Game.
    This strategy aims to balance the need for resource sustainability with
    the reality of diverse opponent behaviors. It adapts its play based on
    the game's state and history, prioritizing cooperation but including
    mechanisms to detect and respond to defection to avoid exploitation,
    while also seeking to restore cooperative play.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.my_last_action: Action | None = None
        self.punishing_mode_active: bool = False
        self.punishment_countdown: int = 0
        self.cooperation_streak: int = 0
        self.forgiveness_threshold_value: int = max(1, math.floor(self.n_players / 3))
        self.critical_stock_level: float = self.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            self.my_last_action = Action.D
            return Action.D
        if state.round_number == 0:
            self.my_last_action = Action.C
            return Action.C
        D_count_prev = (not history.my_actions[-1]) + (~history.opponent_actions[-1, :]).sum()
        if self.punishing_mode_active:
            if self.punishment_countdown > 0:
                self.punishment_countdown -= 1
                if self.punishment_countdown == 0:
                    self.punishing_mode_active = False
                self.my_last_action = Action.D
                return Action.D
            else:
                self.punishing_mode_active = False
        if D_count_prev == 0:
            self.cooperation_streak += 1
        else:
            self.cooperation_streak = 0
        if state.current_stock < self.critical_stock_level:
            if D_count_prev > 0:
                self.my_last_action = Action.D
                return Action.D
            else:
                self.my_last_action = Action.C
                return Action.C
        if D_count_prev > self.forgiveness_threshold_value:
            self.punishing_mode_active = True
            self.punishment_countdown = 1
            self.my_last_action = Action.D
            return Action.D
        self.my_last_action = Action.C
        return Action.C

class Strategy_COLLECTIVE_132(BaseStrategy):
    """
    Adaptive Resource Guardian (ARG) strategy for the Common Pool Resource Game.

    This strategy prioritizes the long-term sustainability of the common pool resource.
    It aims to foster a cooperative environment by initiating cooperation and rewarding it,
    but will defensively defect to deter persistent or widespread free-riding, especially
    if the resource is healthy enough to withstand temporary defection. When the resource
    is critically low, it will unconditionally cooperate to ensure recovery.
    """
    STOCK_RECOVERY_THRESHOLD_FACTOR = 0.5
    MINOR_DEFECTION_STREAK_LIMIT = 2

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_minor_defections_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        tolerated_defections_count = 0
        if n_players > 2:
            tolerated_defections_count = 1
        if current_round == 0:
            return Action.C
        if current_round == total_rounds - 1:
            return Action.D
        if current_stock < capacity * self.STOCK_RECOVERY_THRESHOLD_FACTOR:
            self.last_round_minor_defections_count = 0
            return Action.C
        num_other_cooperators_prev_round = sum(history.opponent_actions[-1, :])
        num_other_defectors_prev_round = n_players - 1 - num_other_cooperators_prev_round
        if num_other_defectors_prev_round == 0:
            self.last_round_minor_defections_count = 0
            return Action.C
        elif num_other_defectors_prev_round <= tolerated_defections_count:
            self.last_round_minor_defections_count += 1
            if self.last_round_minor_defections_count >= self.MINOR_DEFECTION_STREAK_LIMIT:
                self.last_round_minor_defections_count = 0
                return Action.D
            else:
                return Action.C
        else:
            self.last_round_minor_defections_count = 0
            return Action.D

class Strategy_COLLECTIVE_133(BaseStrategy):
    """
    Adaptive Collective Sustainer (ACS) strategy for the Common Pool Resource Game.
    This strategy balances resource sustainability with adaptive responses to player behavior,
    aiming for long-term collective welfare while preventing exploitation. It considers
    current stock levels and the observed actions of all players in the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_STOCK_SEVERE = self.capacity / 4.0
        self.CRITICAL_STOCK_MODERATE = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        prev_round_idx = current_round_0_indexed - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponents_prev_actions = history.opponent_actions[prev_round_idx, :]
        all_prev_round_actions_bool = np.concatenate(([my_prev_action], opponents_prev_actions))
        num_cooperators_prev_round = np.sum(all_prev_round_actions_bool)
        num_D_prev_round = self.n_players - num_cooperators_prev_round
        if current_stock <= self.CRITICAL_STOCK_SEVERE:
            if num_D_prev_round >= self.n_players / 2.0:
                return Action.D
            else:
                return Action.C
        elif current_stock < self.CRITICAL_STOCK_MODERATE:
            return Action.C
        elif num_D_prev_round == 0:
            return Action.C
        elif num_D_prev_round == 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_134(BaseStrategy):
    """
    Adaptive Sustainability Enforcer (ASE) strategy for the Common Pool Resource Game.
    This strategy prioritizes the long-term sustainability of the common stock resource.
    It aims to foster cooperation by starting cooperatively and forgiving minor deviations
    from opponents, but it is ready to defend against widespread exploitation by punishing
    multiple defecting opponents. Critical stock levels trigger an overriding focus on
    resource recovery. It also anticipates the end-game effect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = float(self.game_description.capacity)
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == n_rounds - 1:
            return Action.D
        else:
            num_defectors_last_round = np.sum(~history.opponent_actions[-1, :])
            if current_stock < capacity / (2.0 * n_players):
                return Action.C
            elif current_stock < capacity / 2.0:
                if num_defectors_last_round <= 1:
                    return Action.C
                else:
                    return Action.D
            elif num_defectors_last_round <= 1:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_135(BaseStrategy):
    """
    The Collective Adaptive Stock-Aware (CASA) strategy for the Common Pool Resource game.
    This strategy prioritizes resource sustainability, fosters cooperation, and responds
    adaptively to opponent behaviors and stock levels. It aims for high cumulative payoffs
    by maintaining a healthy common stock, while being robust against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD: float = capacity / 4.0
        self.DEFECTION_TOLERANCE: int = math.ceil(n / 4.0)
        self.WIDESPREAD_DEFECTION_THRESHOLD: int = math.ceil(n / 2.0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        stock_t = state.current_stock
        current_round_t = state.round_number
        if current_round_t == 0:
            return Action.C
        if current_round_t == r - 1:
            return Action.D
        num_defectors_prev_round = np.sum(~history.opponent_actions[-1, :])
        if stock_t < self.CRITICAL_STOCK_THRESHOLD:
            if num_defectors_prev_round >= self.WIDESPREAD_DEFECTION_THRESHOLD:
                return Action.D
            else:
                return Action.C
        elif num_defectors_prev_round == 0:
            return Action.C
        elif num_defectors_prev_round <= self.DEFECTION_TOLERANCE:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_136(BaseStrategy):
    """
    Adaptive Common Pool Guardian (ACPG) strategy for the Common Pool Resource Game.

    ACPG promotes long-term sustainability by initiating cooperation,
    monitoring collective behavior, and adapting actions to either reward
    cooperation or deter defection. It critically prioritizes resource
    preservation when stock is low, even at the cost of immediate individual gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.T_coop = 0.75
        self.T_defect = 0.5
        self.S_danger_ratio = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        current_round_1_indexed = state.round_number + 1
        if state.round_number == 0:
            return Action.C
        if state.round_number == n_rounds - 1:
            return Action.D
        num_cooperators_prev_round = int(history.my_actions[-1]) + np.sum(history.opponent_actions[-1, :])
        C_score_prev = num_cooperators_prev_round / n_players
        if current_stock < capacity * self.S_danger_ratio:
            return Action.C
        if C_score_prev >= self.T_coop:
            return Action.C
        if C_score_prev < self.T_defect:
            return Action.D
        if current_round_1_indexed < n_rounds / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_137(BaseStrategy):
    """
    Adaptive Collective Conservationist (ACC) strategy for the Common Pool Resource Game.

    The ACC strategy aims to foster sustainable cooperation by starting cooperatively,
    offering grace for minor infractions (if the `defection_threshold_for_punishment`
    allows for 'minor' defection), punishing persistent or significant defection,
    but always prioritizing the critical health of the common resource above all else.
    It is designed to be robust in a tournament setting, handling various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self._initial_grace_rounds = 2
        self._defection_threshold_for_punishment = 1
        self._punishment_duration = 3
        self._stock_warning_low_factor = 0.5
        self._stock_panic_threshold_factor = 0.25
        self._end_game_rounds = 5
        self._grace_period_active = False
        self._punishment_active = False
        self._punishment_rounds_left = 0
        self._rounds_since_last_all_C = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self._grace_period_active = False
            self._punishment_active = False
            self._punishment_rounds_left = 0
            self._rounds_since_last_all_C = 0
            return Action.C
        stock_warning_low = self.capacity * self._stock_warning_low_factor
        stock_panic_threshold = self.capacity * self._stock_panic_threshold_factor
        num_opponent_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
        num_defectors_last_round_opponents = self.n - 1 - num_opponent_cooperators_last_round
        my_action_last_round = history.my_actions[-1]
        num_defectors_last_round = num_defectors_last_round_opponents + (1 if not my_action_last_round else 0)
        if num_defectors_last_round == 0:
            self._rounds_since_last_all_C = 0
        else:
            self._rounds_since_last_all_C += 1
        if self._punishment_active and self._punishment_rounds_left == 0:
            self._punishment_active = False
        if self._punishment_active and self._punishment_rounds_left > 0:
            self._punishment_rounds_left -= 1
        if state.current_stock <= stock_panic_threshold:
            self._grace_period_active = False
            self._punishment_active = False
            self._punishment_rounds_left = 0
            return Action.C
        rounds_to_go = self.r - state.round_number
        if rounds_to_go <= self._end_game_rounds:
            if state.current_stock < stock_warning_low:
                return Action.C
            elif num_defectors_last_round > 0:
                return Action.D
            else:
                return Action.C
        if state.current_stock < stock_warning_low:
            self._grace_period_active = False
            self._punishment_active = False
            self._punishment_rounds_left = 0
            return Action.C
        if self._punishment_active:
            return Action.D
        if self._grace_period_active:
            if num_defectors_last_round == 0:
                self._grace_period_active = False
                return Action.C
            elif self._rounds_since_last_all_C >= self._initial_grace_rounds:
                self._grace_period_active = False
                if num_defectors_last_round >= self._defection_threshold_for_punishment:
                    self._punishment_active = True
                    self._punishment_rounds_left = self._punishment_duration - 1
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        if num_defectors_last_round == 0:
            return Action.C
        elif num_defectors_last_round >= self._defection_threshold_for_punishment:
            self._punishment_active = True
            self._punishment_rounds_left = self._punishment_duration - 1
            return Action.D
        else:
            self._grace_period_active = True
            return Action.C

class Strategy_COLLECTIVE_138(BaseStrategy):
    """
    Adaptive Resource Steward (ARS) strategy for the Common Pool Resource Game.
    This strategy balances cooperation for resource sustainability with a deterrent
    against free-riding, adapting its behavior based on observed opponent actions
    and the critical state of the common stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_ratio = 0.25
        self.cooperation_ratio_threshold = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        if state.current_stock < self.critical_stock_ratio * capacity:
            return Action.C
        previous_round_0_indexed = current_round_0_indexed - 1
        num_cooperating_opponents = np.sum(history.opponent_actions[previous_round_0_indexed, :])
        num_other_players = n_players - 1
        cooperation_ratio = num_cooperating_opponents / num_other_players
        if cooperation_ratio >= self.cooperation_ratio_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_139(BaseStrategy):
    """
    The Adaptive Collective Steward (ACS) strategy prioritizes the sustainability of the common stock
    while responding adaptively to the actions of other players. It operates on the principle of
    conditional cooperation, seeking to maintain a healthy resource and fostering cooperation among
    players, but also protecting itself against persistent exploitation.

    Key features:
    - Cooperates by default and in critical stock situations to promote resource recovery.
    - Observes previous round's opponent actions:
        - Continues cooperation if defection is low or non-existent.
        - Defects if too many players defected in the previous round, to protect individual payoff
          and signal unsustainable behavior.
    - Defects in the final round to maximize immediate payoff, as there are no future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOPERATION_THRESHOLD_D = 1
        self.CRITICAL_STOCK_THRESHOLD = self.game_description.capacity / 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        defection_count_previous_round = np.sum(~previous_round_opponent_actions)
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        elif defection_count_previous_round == 0:
            return Action.C
        elif defection_count_previous_round <= self.COOPERATION_THRESHOLD_D:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_140(BaseStrategy):
    """
    The Adaptive Sustainability Steward (ASS) strategy aims to maintain the common pool resource at healthy levels
    while adapting to the observed behavior of other players and the current state of the game. It embodies a
    collective mindset by prioritizing the long-term sustainability of the resource, fostering cooperation,
    and forgiving minor deviations, but also demonstrates robustness by punishing persistent free-riding
    and widespread defection, particularly as the game progresses or the resource becomes critical.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOP_RATE_HIGH_TH = 0.8
        self.COOP_RATE_LOW_TH = 0.3
        self.STOCK_HEALTHY_THRESHOLD_PCT = 0.75
        self.STOCK_CRITICAL_THRESHOLD_PCT = 0.25
        self.FORGIVE_EARLY_GAME_ROUNDS_PCT = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        num_others_cooperated = int(np.sum(previous_round_opponent_actions))
        coop_rate_others = num_others_cooperated / (n - 1)
        is_stock_healthy = current_stock >= capacity * self.STOCK_HEALTHY_THRESHOLD_PCT
        is_stock_critical = current_stock < capacity * self.STOCK_CRITICAL_THRESHOLD_PCT
        is_stock_warning = not is_stock_healthy and (not is_stock_critical)
        if is_stock_critical:
            if coop_rate_others >= self.COOP_RATE_HIGH_TH:
                return Action.C
            elif coop_rate_others >= self.COOP_RATE_LOW_TH:
                return Action.C
            else:
                return Action.D
        elif is_stock_healthy:
            if coop_rate_others >= self.COOP_RATE_HIGH_TH:
                return Action.C
            elif coop_rate_others < self.COOP_RATE_LOW_TH:
                return Action.D
            else:
                early_game_rounds_threshold = total_rounds * self.FORGIVE_EARLY_GAME_ROUNDS_PCT
                if current_round_1_indexed <= early_game_rounds_threshold:
                    return Action.C
                else:
                    return Action.D
        elif is_stock_warning:
            if coop_rate_others >= self.COOP_RATE_HIGH_TH:
                return Action.C
            elif coop_rate_others < self.COOP_RATE_LOW_TH:
                return Action.D
            else:
                return Action.D

class Strategy_COLLECTIVE_141(BaseStrategy):
    """
    Adaptive Stock-Aware Reciprocity strategy for the Common Pool Resource Game.

    This strategy aims to promote long-term sustainability of the common resource
    by initially cooperating and then conditionally punishing free-riding behavior.
    Its tolerance for defection is dynamically adjusted based on the current health
    of the common stock, ensuring greater stringency when the resource is under threat.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_round == 0:
            return Action.C
        if current_round == total_rounds - 1:
            return Action.D
        D_others_prev = (history.opponent_actions[-1, :] == False).sum()
        n_opponents = n_players - 1
        D_rate_others_prev = D_others_prev / n_opponents
        rate_threshold_healthy = 0.25
        rate_threshold_warning = 0.1
        rate_threshold_critical = 0.01
        effective_D_rate_threshold: float
        if current_stock >= capacity * 0.8:
            effective_D_rate_threshold = rate_threshold_healthy
        elif current_stock >= capacity * 0.5:
            effective_D_rate_threshold = rate_threshold_warning
        else:
            effective_D_rate_threshold = rate_threshold_critical
        if D_rate_others_prev > effective_D_rate_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_142(BaseStrategy):
    """
    The Adaptive Collective Steward (ACS) strategy aims to foster long-term sustainability of the common pool resource
    by promoting cooperation, while being robust against exploitation. It prioritizes the health of the shared stock
    and reacts dynamically to observed collective behavior, balancing individual self-interest with the collective good.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._forgiveness_level = 0.15
        self._defection_punishment_rounds = 2
        self._recovery_stock_threshold_ratio = 0.4
        self._end_game_horizon = 3
        self._punishment_active_until_round = -1
        self._last_round_start_stock = self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        S_current_start = state.current_stock
        capacity = self.game_description.capacity
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        action_to_take = Action.C
        if current_round == 0:
            action_to_take = Action.C
        elif current_round >= r - self._end_game_horizon:
            action_to_take = Action.D
        elif S_current_start < capacity * self._recovery_stock_threshold_ratio:
            self._punishment_active_until_round = -1
            action_to_take = Action.C
        elif self._punishment_active_until_round >= current_round:
            action_to_take = Action.D
        else:
            S_prev_start = self._last_round_start_stock
            all_actions_prev_round = [history.my_actions[-1]] + history.opponent_actions[-1, :].tolist()
            total_consumption_prev_round = 0.0
            for player_action_bool in all_actions_prev_round:
                if player_action_bool:
                    total_consumption_prev_round += S_prev_start / (2 * n)
                else:
                    total_consumption_prev_round += S_prev_start / n
            ideal_cooperative_consumption_prev = S_prev_start / 2.0
            if total_consumption_prev_round > ideal_cooperative_consumption_prev * (1 + self._forgiveness_level):
                self._punishment_active_until_round = current_round + self._defection_punishment_rounds - 1
                action_to_take = Action.D
            else:
                action_to_take = Action.C
        self._last_round_start_stock = S_current_start
        return action_to_take

class Strategy_COLLECTIVE_143(BaseStrategy):
    """
    Adaptive Stock-Conscious Reciprocity (ASCR) strategy for the Common Pool Resource Game.
    This strategy prioritizes long-term resource sustainability, adapting its reciprocity
    based on the current stock level. It starts cooperatively, becomes more forgiving
    when the stock is healthy, but gets stricter as the stock depletes to prevent collapse.
    It also adjusts its behavior for the final round.
    """
    _HEALTHY_STOCK_THRESHOLD_RATIO = 0.75
    _MODERATE_STOCK_THRESHOLD_RATIO = 0.4
    _CRITICAL_STOCK_THRESHOLD_RATIO = 0.1

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.healthy_threshold_ratio = self._HEALTHY_STOCK_THRESHOLD_RATIO
        self.moderate_threshold_ratio = self._MODERATE_STOCK_THRESHOLD_RATIO
        self.critical_threshold_ratio = self._CRITICAL_STOCK_THRESHOLD_RATIO

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        prev_round_opponent_actions = history.opponent_actions[-1, :]
        num_cooperators_prev_round = np.sum(prev_round_opponent_actions)
        num_defectors_prev_round = self.n_players - 1 - num_cooperators_prev_round
        if current_round == self.total_rounds - 1:
            if current_stock <= self.critical_threshold_ratio * self.capacity:
                return Action.D
            elif num_defectors_prev_round > 0:
                return Action.D
            else:
                return Action.C
        forgiveness_threshold = 0
        if current_stock >= self.healthy_threshold_ratio * self.capacity:
            forgiveness_threshold = 1
        elif current_stock >= self.moderate_threshold_ratio * self.capacity:
            forgiveness_threshold = 0
        else:
            forgiveness_threshold = 0
        if num_defectors_prev_round <= forgiveness_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_144(BaseStrategy):
    """
    Adaptive Reciprocal Conservationist strategy for the Common Pool Resource Game.

    This strategy balances resource sustainability with robustness against exploitation.
    It initiates cooperation, adjusts reciprocity based on stock health, prioritizes
    recovery when stock is critically low, and maximizes immediate payoff in the
    final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_LEVEL = self.capacity / (2 * self.n_players)
        self.LOW_STOCK_LEVEL = self.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        last_round_opponent_actions = history.opponent_actions[-1, :]
        num_defectors_last_round = np.sum(last_round_opponent_actions == False)
        all_cooperated = num_defectors_last_round == 0
        if current_stock <= self.CRITICAL_STOCK_LEVEL:
            if num_defectors_last_round > (self.n_players - 1) / 2:
                return Action.D
            else:
                return Action.C
        elif current_stock <= self.LOW_STOCK_LEVEL:
            if all_cooperated:
                return Action.C
            else:
                return Action.D
        elif self.n_players == 2:
            if all_cooperated:
                return Action.C
            else:
                return Action.D
        elif num_defectors_last_round <= 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_145(BaseStrategy):
    """
    The "Adaptive Collective Guardian" strategy balances collective sustainability
    with individual self-preservation in the Common Pool Resource Game.
    It prioritizes cooperation when the stock is critically low, adapts its
    behavior based on observed defection from other players, and switches
    to defection in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / (4 * self.n)
        if self.n == 2:
            self.DEFECTION_TOLERANCE_THRESHOLD_N_ADJUSTED = 0.0
        else:
            self.DEFECTION_TOLERANCE_THRESHOLD_N_ADJUSTED = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.r:
            return Action.D
        if state.round_number == 0:
            return Action.C
        if state.current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        else:
            previous_round_opponent_actions = history.opponent_actions[state.round_number - 1]
            num_defectors = 0
            for action_bool in previous_round_opponent_actions:
                if not action_bool:
                    num_defectors += 1
            defection_rate = num_defectors / self.n
            if defection_rate > self.DEFECTION_TOLERANCE_THRESHOLD_N_ADJUSTED:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_146(BaseStrategy):
    """
    The Adaptive Collective Sustainer (ACS) strategy for the Common Pool Resource Game.

    This strategy aims to foster collective cooperation and resource sustainability while
    remaining robust against exploitative behaviors. It is built on principles of initial
    trust, swift punishment for significant defection, and a strong commitment to resource
    sustainability. It uses a Tit-for-Tat-like mechanism adapted for multiple players,
    combined with a dedicated recovery mechanism for critically low stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.D_tolerance: int = 0
        self.Stock_critical_threshold: float = self.game_description.capacity / 4
        self.Forgiveness_rounds_in_recovery: int = 2
        self.current_forgiveness_count: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_zero_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round_zero_indexed == 0:
            return Action.C
        if current_round_zero_indexed == total_rounds - 1:
            if current_stock <= 0:
                return Action.C
            else:
                return Action.D
        num_opponent_cooperators_prev = sum(history.opponent_actions[-1, :])
        num_players_excluding_self = self.game_description.n_players - 1
        k_prev = num_players_excluding_self - num_opponent_cooperators_prev
        if current_stock < self.Stock_critical_threshold:
            if self.current_forgiveness_count < self.Forgiveness_rounds_in_recovery:
                self.current_forgiveness_count += 1
                return Action.C
            else:
                self.current_forgiveness_count = 0
                if k_prev > self.D_tolerance:
                    return Action.D
                else:
                    return Action.C
        else:
            self.current_forgiveness_count = 0
        if k_prev > self.D_tolerance:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_147(BaseStrategy):
    """
    Adaptive Sustainable Reciprocity (ASR) strategy for the Common Pool Resource Game.

    ASR balances individual payoff maximization with collective resource sustainability.
    It employs a dynamic, state-dependent approach, adapting its behavior based on
    observed opponent actions, the current health of the resource, and the game's progress.

    Core Philosophy:
    ASR starts cooperatively, rewards cooperation, and punishes defection.
    It critically prioritizes the recovery of the common pool when the stock becomes
    stressed (below S_stressed) or critical (below S_critical), even if it means
    temporarily forgiving past defections. In the endgame, it shifts to maximizing
    immediate returns as the "shadow of the future" diminishes.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_critical = self.game_description.capacity / 4.0
        self.S_stressed = self.game_description.capacity / 2.0
        self.n_cooperation_threshold = self.game_description.n_players - 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round == total_rounds - 1:
            return Action.D
        if current_stock < self.S_critical:
            return Action.C
        if current_round == 0:
            return Action.C
        num_opponent_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
        num_cooperators_last_round = num_opponent_cooperators_last_round + history.my_actions[-1]
        if num_cooperators_last_round >= self.n_cooperation_threshold:
            return Action.C
        elif current_stock > self.S_stressed:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_148(BaseStrategy):
    """
    The Adaptive Forager strategy balances individual gain with collective resource sustainability.
    It conditionally cooperates based on observed past cooperation levels, penalizing widespread
    defection and making decisions influenced by the health of the common stock. In the first round,
    it cooperates to signal goodwill and gather information. In the last round, it defects to
    maximize immediate payoff due to the absence of future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.THRESHOLD_C_HIGH = (self.n - 1) / self.n
        self.THRESHOLD_C_LOW = 0.5
        self.CRITICAL_STOCK_LEVEL = self.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.r - 1:
            return Action.D
        num_cooperators_prev_round = np.sum(history.opponent_actions[current_round - 1, :]) + history.my_actions[current_round - 1]
        cooperation_ratio = num_cooperators_prev_round / self.n
        if cooperation_ratio >= self.THRESHOLD_C_HIGH:
            return Action.C
        elif cooperation_ratio < self.THRESHOLD_C_LOW:
            return Action.D
        elif current_stock > self.CRITICAL_STOCK_LEVEL:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_149(BaseStrategy):
    """
    Adaptive Collective Harvester (ACH) strategy for the Common Pool Resource Game.

    This strategy aims for sustainable harvesting, starting cooperatively, and
    maintaining cooperation while deterring persistent defectors. It prioritizes
    resource recovery above all when the stock is critically low and plays
    rationally in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = self.capacity / 4.0
        self.persistent_defection_rounds_threshold = 2
        self.consecutive_defections_by_player = {opponent_idx: 0 for opponent_idx in range(self.n_players - 1)}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round > 0:
            for opponent_idx, action_bool in enumerate(history.opponent_actions[-1, :]):
                if not action_bool:
                    self.consecutive_defections_by_player[opponent_idx] += 1
                else:
                    self.consecutive_defections_by_player[opponent_idx] = 0
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock <= self.critical_stock_threshold:
            return Action.C
        num_persistent_defectors = 0
        for opponent_idx in self.consecutive_defections_by_player:
            if self.consecutive_defections_by_player[opponent_idx] >= self.persistent_defection_rounds_threshold:
                num_persistent_defectors += 1
        if num_persistent_defectors > 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_150(BaseStrategy):
    """
    The Adaptive Resource Guardian (ARG) strategy aims to balance individual payoff maximization
    with the collective goal of sustaining a common resource. It employs conditional cooperation,
    punishment for exploitation, and prioritizes resource recovery.

    Key principles:
    1. Proactive Cooperation: Starts by cooperating.
    2. Conditional Reciprocity: Monitors opponent actions and responds in kind.
    3. Resource Prioritization: Unconditionally cooperates if stock is critically low.
    4. Strategic Punishment: Applies temporary punishment for widespread defection.
    5. End-Game Rationality: Defects in the last round to maximize final payoff.
    """
    COOPERATION_THRESHOLD_RATIO = 0.6
    PUNISHMENT_TRIGGER_RATIO = 0.3
    CRITICAL_STOCK_LEVEL_RATIO = 0.25
    PUNISHMENT_DURATION = 2

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_absolute_threshold = (self.n_players - 1) * self.COOPERATION_THRESHOLD_RATIO
        self.punishment_absolute_trigger = (self.n_players - 1) * self.PUNISHMENT_TRIGGER_RATIO
        self._punishment_mode_active: bool = False
        self._punishment_rounds_left: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock < self.capacity * self.CRITICAL_STOCK_LEVEL_RATIO:
            self._punishment_mode_active = False
            self._punishment_rounds_left = 0
            return Action.C
        if self._punishment_mode_active:
            if self._punishment_rounds_left > 0:
                self._punishment_rounds_left -= 1
                return Action.D
            else:
                self._punishment_mode_active = False
        if state.round_number > 0:
            num_other_cooperators_prev_round = int(np.sum(history.opponent_actions[-1, :]))
            if num_other_cooperators_prev_round <= self.punishment_absolute_trigger:
                self._punishment_mode_active = True
                self._punishment_rounds_left = self.PUNISHMENT_DURATION - 1
                return Action.D
            elif num_other_cooperators_prev_round < self.cooperation_absolute_threshold:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_151(BaseStrategy):
    """
    Adaptive Forgiving Tit-for-Tat with Crisis Conservation strategy for the Common Pool Resource Game.
    This strategy prioritizes long-term resource health and collective payoff. It defaults to cooperation,
    forgives minor transgressions by other players, punishes significant defection, and commits to
    conservation (cooperation) during resource crises.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.cooperation_forgiveness_threshold = max(0, math.ceil(n / 2) - 1)
        self.critical_stock_level = capacity / 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        else:
            my_previous_action_was_D = not history.my_actions[-1]
            num_opponent_defectors_prev_round = (~history.opponent_actions[-1, :]).sum()
            d_prev = (1 if my_previous_action_was_D else 0) + num_opponent_defectors_prev_round
            if state.current_stock < self.critical_stock_level:
                return Action.C
            elif d_prev <= self.cooperation_forgiveness_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_152(BaseStrategy):
    """
    The Adaptive Conservationist strategy prioritizes long-term resource health.
    It starts cooperatively, adapts behavior based on resource stock levels (critical, warning, healthy/abundant),
    and punishes defection with varying tolerance. In the final round, it defects for individual gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_CRITICAL_RATIO = 0.25
        self.S_WARNING_RATIO = 0.5
        self.DEF_TOLERANCE_LENIENT = math.floor(self.game_description.n_players / 3)
        self.DEF_TOLERANCE_STRICT = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        current_round_1_indexed = current_round_0_indexed + 1
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == total_rounds:
            return Action.D
        previous_defections = n - sum(history.opponent_actions[current_round_0_indexed - 1])
        if current_stock < self.S_CRITICAL_RATIO * capacity:
            if previous_defections >= self.DEF_TOLERANCE_STRICT:
                return Action.D
            else:
                return Action.C
        elif current_stock < self.S_WARNING_RATIO * capacity:
            if previous_defections >= self.DEF_TOLERANCE_STRICT:
                return Action.D
            else:
                return Action.C
        elif previous_defections > self.DEF_TOLERANCE_LENIENT:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_153(BaseStrategy):
    """
    Adaptive Collective Conservation (ACC) Strategy:
    This strategy aims to maximize collective welfare and resource sustainability by
    balancing initial cooperation, adaptive retaliation against free-riders, and
    prioritizing resource preservation under critical conditions. It adapts its
    behavior based on the common pool stock level and the observed defection
    of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_critical_low = 0.25 * self.capacity
        self.S_warning = 0.5 * self.capacity
        if self.n_players == 2:
            self.defection_tolerance_threshold = 0
        else:
            self.defection_tolerance_threshold = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        num_cooperators_t_minus_1 = np.sum(history.opponent_actions[-1, :])
        num_opponents = self.n_players - 1
        num_defectors_t_minus_1 = num_opponents - num_cooperators_t_minus_1
        if current_stock <= self.S_critical_low:
            return Action.C
        elif current_stock <= self.S_warning:
            if num_defectors_t_minus_1 > 0:
                return Action.D
            else:
                return Action.C
        elif num_defectors_t_minus_1 > self.defection_tolerance_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_154(BaseStrategy):
    """
    The "Adaptive Sustainability Guardian" strategy promotes collective cooperation for sustainable 
    resource management while dynamically adapting to perceived exploitation and preventing individual 
    players from suffering disproportionately in scenarios of resource collapse.

    It operates based on the current state of the resource (stock level) and its historical trend, 
    along with the current round number. It does not attempt to track individual opponent actions, 
    instead inferring collective behavior from the aggregate impact on the common stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._CRITICAL_STOCK_THRESHOLD: float = self.game_description.capacity * 0.1
        self._previous_round_start_stock: float | None = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed: int = state.round_number + 1
        total_rounds: int = self.game_description.n_rounds
        current_stock: float = state.current_stock
        action_to_take: Action
        if current_round_1_indexed == total_rounds:
            action_to_take = Action.D
        elif current_stock < self._CRITICAL_STOCK_THRESHOLD:
            action_to_take = Action.D
        elif state.round_number == 0:
            action_to_take = Action.C
        else:
            prev_round_stock_for_comparison: float | None = self._previous_round_start_stock
            if prev_round_stock_for_comparison is None:
                prev_round_stock_for_comparison = self.game_description.capacity
            if current_stock < prev_round_stock_for_comparison:
                action_to_take = Action.D
            else:
                action_to_take = Action.C
        self._previous_round_start_stock = current_stock
        return action_to_take

class Strategy_COLLECTIVE_155(BaseStrategy):
    """
    The Adaptive Steward strategy aims to promote long-term sustainability of the common resource
    while being robust and adaptive to varying behaviors from other players. It balances individual
    rationality with collective welfare through conditional cooperation, deterrence, and
    resource-dependent actions.

    It operates in phases:
    1. End-Game: Unconditionally defects in the final rounds to maximize immediate payoff.
    2. Initial Goodwill: Cooperates in the very first rounds to signal willingness for cooperation.
    3. Adaptive Mid-Game:
        a. Stock Recovery Mode: Prioritizes cooperation if the common stock falls below a critical threshold,
           regardless of other players' actions, to allow the resource to recover.
        b. Conditional Cooperation/Deterrence Mode: If stock is healthy, it cooperates if a
           sufficient proportion of other players cooperated in the previous round, otherwise defects
           to deter free-riding.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_cooperation_rounds = 1
        self.end_game_rounds = 2
        self.stock_recovery_threshold_ratio = 0.4
        self.cooperation_deterrence_ratio = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round_1_indexed > total_rounds - self.end_game_rounds:
            return Action.D
        if current_round_1_indexed <= self.initial_cooperation_rounds:
            return Action.C
        num_other_cooperators = np.sum(history.opponent_actions[-1, :])
        cooperation_proportion = num_other_cooperators / (n_players - 1)
        if current_stock < capacity * self.stock_recovery_threshold_ratio:
            return Action.C
        elif cooperation_proportion >= self.cooperation_deterrence_ratio:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_156(BaseStrategy):
    """
    Conditional Steward (CS) strategy for the Common Pool Resource Game.
    This strategy prioritizes long-term resource sustainability and adapts to
    the collective behavior of other players. It initiates cooperation,
    tolerates minor deviations, and retaliates against excessive free-riding.
    Special rules are implemented when the common stock is critically low to
    either facilitate recovery or signal a collective failure to preserve the resource.

    Core Principles:
    1. Stewardship: Prioritize the health and sustainability of the common pool stock.
    2. Conditional Cooperation: Adapt behavior based on collective actions in previous rounds.
    3. Forgiveness and Firmness: Tolerate minor defections, but punish excessive free-riding.
    4. Resource Preservation: Special rules for critically low stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the ConditionalSteward strategy with game parameters.

        Args:
            game_description: An object containing game parameters such as
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.D_THRESHOLD_FORGIVENESS = 1
        self.CRITICAL_STOCK_LEVEL = self.capacity / self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: An object containing the current round number and stock level.
            history: An object containing past actions and payoffs for the player
                     and opponents, or None for the first round.

        Returns:
            An Action (Action.C for Cooperate, Action.D for Defect).
        """
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        my_prev_action_is_C = history.my_actions[current_round_0_indexed - 1]
        opponent_prev_actions_are_C = history.opponent_actions[current_round_0_indexed - 1, :]
        num_cooperators_prev = int(my_prev_action_is_C) + np.sum(opponent_prev_actions_are_C)
        d_prev = self.n_players - num_cooperators_prev
        if current_stock < self.CRITICAL_STOCK_LEVEL:
            if d_prev == 0:
                return Action.C
            else:
                return Action.D
        elif d_prev == 0:
            return Action.C
        elif d_prev <= self.D_THRESHOLD_FORGIVENESS:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_157(BaseStrategy):
    """
    The Adaptive Conservationist strategy aims to promote long-term sustainability of the common stock
    while being robust against exploitation by other players. It adapts its behavior based on the current
    stock level and the observed actions of other players in previous rounds.

    Decision Rules:
    1. Last Round: Always Defect (maximize immediate payoff).
    2. First Round: Always Cooperate (signal willingness for collective good).
    3. Normal Rounds:
        - Emergency (Critically low stock): Defect.
        - Widespread Defection from others: Defect.
        - Stock Recovery (if stock depleted): Cooperate ONLY if all other players cooperated. Else, Defect.
        - Default (Healthy stock & sufficient cooperation): Cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.critical_stock_threshold = capacity / (2.0 * n)
        self.majority_other_defection_threshold = math.floor(0.5 * (n - 1)) + 1
        self.stock_healthy_threshold = capacity * 0.95

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        num_players = self.game_description.n_players
        if current_round_1_indexed == total_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        num_other_players_total = num_players - 1
        num_other_cooperators_last_round = history.opponent_actions[-1, :].sum()
        num_other_defectors_last_round = num_other_players_total - num_other_cooperators_last_round
        if current_stock < self.critical_stock_threshold:
            return Action.D
        if num_other_defectors_last_round >= self.majority_other_defection_threshold:
            return Action.D
        if current_stock < self.stock_healthy_threshold:
            if num_other_defectors_last_round > 0:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_COLLECTIVE_158(BaseStrategy):
    """
    The "Adaptive Resource Guardian" (ARG) strategy for the Common Pool Resource Game.
    It prioritizes resource sustainability, employing conditional cooperation,
    adaptive punishment, and forgiveness mechanisms. It defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.COOP_THRESHOLD_DEFECTORS_RATIO = 0.25
        self.PUNISHMENT_DURATION_ROUNDS = 2
        self.FORGIVENESS_MIN_COOP_ROUNDS = 2
        self.CRITICAL_STOCK_LEVEL_RATIO = 0.2
        self.STOCK_RECOVERY_FORGIVENESS_RATIO = 0.9
        self.punishing_for = 0
        self.consecutive_full_coop = 0
        self.last_round_initial_stock = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num = state.round_number
        current_stock = state.current_stock
        if current_round_num == 0:
            self.punishing_for = 0
            self.consecutive_full_coop = 0
            self.last_round_initial_stock = current_stock
            return Action.C
        if current_round_num == self.r - 1:
            self.last_round_initial_stock = current_stock
            return Action.D
        S_prev_end = current_stock
        S_prev_start = self.last_round_initial_stock
        my_action_prev = history.my_actions[-1]
        opponent_actions_prev = history.opponent_actions[-1, :]
        k_D_prev = 0
        if not my_action_prev:
            k_D_prev += 1
        k_D_prev += np.sum(~opponent_actions_prev)
        if k_D_prev == 0:
            self.consecutive_full_coop += 1
        else:
            self.consecutive_full_coop = 0
        chosen_action = Action.C
        if S_prev_end < self.capacity * self.CRITICAL_STOCK_LEVEL_RATIO:
            self.punishing_for = 0
            chosen_action = Action.C
        elif self.punishing_for > 0:
            self.punishing_for -= 1
            chosen_action = Action.D
        elif self.consecutive_full_coop >= self.FORGIVENESS_MIN_COOP_ROUNDS and S_prev_end >= self.capacity * self.STOCK_RECOVERY_FORGIVENESS_RATIO:
            chosen_action = Action.C
        else:
            trigger_punishment = False
            if k_D_prev > self.n * self.COOP_THRESHOLD_DEFECTORS_RATIO:
                trigger_punishment = True
            if S_prev_end < S_prev_start and k_D_prev > 0:
                trigger_punishment = True
            if trigger_punishment:
                self.punishing_for = self.PUNISHMENT_DURATION_ROUNDS
                chosen_action = Action.D
        self.last_round_initial_stock = current_stock
        return chosen_action

class Strategy_COLLECTIVE_159(BaseStrategy):
    """
    Sustainable Reciprocity with Emergency Conservation strategy.

    This strategy aims to achieve sustainable resource management by balancing
    individual incentives with the collective good. It defaults to cooperation,
    punishes defection when the resource is healthy, and strictly conserves
    when the resource is threatened.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description (CommonPoolDescription): An object containing
                                                     n_players, n_rounds, and capacity.
        """
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state (CommonPoolState): The current state of the game, including
                                     round_number and current_stock.
            history (None | PlayerHistory): A record of past actions and payoffs.
                                            None for the very first round (round_number = 0).

        Returns:
            Action: The chosen action, either Action.C (Cooperate) or Action.D (Defect).
        """
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == 0:
            return Action.C
        if current_round_number == r - 1:
            return Action.D
        if current_stock <= capacity / (2 * n):
            return Action.C
        num_defectors_last_round = np.sum(~history.opponent_actions[-1, :])
        if num_defectors_last_round == 0:
            return Action.C
        elif current_stock > capacity / 2:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_160(BaseStrategy):
    """
    The Adaptive Collective Sustainer (ACS) strategy for the Common Pool Resource Game.

    ACS starts cooperatively, signaling a willingness for collective good. It continues
    cooperating as long as the common resource stock is stable or recovering. If the
    stock depletes due to defection from other players, it retaliates by defecting.
    However, if depletion occurs even with universal cooperation, it continues to
    cooperate to prevent further collapse. In the final round, it pragmatically
    defects to maximize immediate payoff, anticipating similar behavior from others.

    The strategy maintains an internal history to track stock levels and collective
    defection counts from previous rounds, which are crucial for its dynamic adaptation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self._strategy_history = []
        self._stock_start_of_last_round = None
        self._my_last_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        if current_round_0_indexed > 0:
            prev_round_num_0_indexed = current_round_0_indexed - 1
            prev_stock_start = self._stock_start_of_last_round
            prev_stock_end = state.current_stock
            prev_my_action_bool = history.my_actions[-1]
            prev_opponent_actions_bool = history.opponent_actions[-1, :]
            d_count = 0
            if not prev_my_action_bool:
                d_count += 1
            d_count += np.sum(prev_opponent_actions_bool == False)
            self._strategy_history.append({'round_0_indexed': prev_round_num_0_indexed, 'stock_start': prev_stock_start, 'stock_end': prev_stock_end, 'd_count': d_count})
        chosen_action = None
        if current_round_0_indexed == 0:
            chosen_action = Action.C
        elif current_round_0_indexed == self.n_rounds - 1:
            chosen_action = Action.D
        else:
            prev_round_data = self._strategy_history[-1]
            prev_stock_start = prev_round_data['stock_start']
            prev_stock_end = prev_round_data['stock_end']
            d_count = prev_round_data['d_count']
            if prev_stock_end >= prev_stock_start:
                chosen_action = Action.C
            elif d_count > 0:
                chosen_action = Action.D
            else:
                chosen_action = Action.C
        self._stock_start_of_last_round = state.current_stock
        self._my_last_action = chosen_action
        return chosen_action

class Strategy_COLLECTIVE_161(BaseStrategy):
    """
    Adaptive Prudent Steward (APS) Strategy for the Common Pool Resource Game.

    This strategy prioritizes the long-term sustainability of the common resource.
    It aims to foster cooperation by starting cooperatively, being forgiving of minor
    defections, but firmly retaliating against significant breakdowns in cooperation.
    Crucially, it has an "emergency conservation" mode to prevent irreversible
    resource collapse, demonstrating a strong collective commitment when the resource
    is most vulnerable. It also incorporates standard game-theoretic considerations
    for the final round and depleted states.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_stock <= 0.001:
            return Action.D
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        if current_stock < self.capacity / self.n_players:
            return Action.C
        prev_my_action = history.my_actions[state.round_number - 1]
        prev_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        num_defectors_prev = int(not prev_my_action) + np.sum(prev_opponent_actions == False)
        defection_tolerance_threshold = max(1, math.floor(self.n_players / 2))
        if num_defectors_prev >= defection_tolerance_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_162(BaseStrategy):
    """
    The Adaptive Collective Guardian strategy for the Common Pool Resource Game.

    This strategy aims to foster sustainable resource management by prioritizing
    long-term stock health while adapting to opponent behavior. It operates in
    two primary modes: an Urgent Conservation Mode, triggered by critically low
    stock levels, and a Balanced Management Mode, which applies conditional
    cooperation based on past opponent actions and switches to defection in the
    final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold = self.game_description.capacity / 2.0
        self.defection_tolerance_count = math.floor((self.game_description.n_players - 1) / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.current_stock < self.critical_stock_threshold:
            return Action.C
        elif state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            opponent_defections_last_round = np.sum(~history.opponent_actions[-1, :])
            if opponent_defections_last_round > self.defection_tolerance_count:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_163(BaseStrategy):
    """
    The Adaptive Conservationist strategy prioritizes long-term sustainability of the common pool resource.
    It aims to foster cooperation through clear, reciprocal actions, and has an emergency protocol
    to ensure resource recovery when facing critical depletion.
    
    Decision Rules in Priority Order:
    1. First Round Protocol: Always Cooperate (C) to establish a cooperative baseline.
    2. Last Round Protocol: Always Defect (D) to maximize immediate payoff, as there are no future consequences.
    3. Critical Resource Protocol: If stock is below half capacity, always Cooperate (C) to facilitate recovery.
    4. Normal Operating Protocol: Implement Tit-for-Tat; if any opponent defected in the previous round, defect (D);
       otherwise, cooperate (C).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == n_rounds - 1:
            return Action.D
        if current_stock < capacity / 2:
            return Action.C
        num_defectors_in_prev_round = np.count_nonzero(~history.opponent_actions[-1, :])
        if num_defectors_in_prev_round > 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_164(BaseStrategy):
    """
    Adaptive Collective Conservationist (ACC) strategy for the Common Pool Resource Game.
    This strategy adapts its behavior based on the common stock level and the collective
    defection observed in the previous round, aiming for long-term sustainability
    and resilience against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_observation_streak = 0
        self.CRITICAL_STOCK_THRESHOLD_FACTOR = 0.25
        self.LOW_STOCK_THRESHOLD_FACTOR = 0.5
        self.MAJORITY_DEFECTION_RATIO = 0.5
        self.CRITICAL_STOCK_THRESHOLD = self.CRITICAL_STOCK_THRESHOLD_FACTOR * self.game_description.capacity
        self.LOW_STOCK_THRESHOLD = self.LOW_STOCK_THRESHOLD_FACTOR * self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        if current_round_number == total_rounds - 1:
            return Action.D
        if current_round_number == 0:
            return Action.C
        prev_round_idx = current_round_number - 1
        num_opponent_cooperators_prev = sum(history.opponent_actions[prev_round_idx, :])
        my_action_prev_cooperated = history.my_actions[prev_round_idx]
        num_all_cooperators_prev = num_opponent_cooperators_prev + (1 if my_action_prev_cooperated else 0)
        num_all_defectors_prev = n_players - num_all_cooperators_prev
        defection_ratio_prev = num_all_defectors_prev / n_players
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            self.defection_observation_streak = 0
            return Action.C
        elif current_stock < self.LOW_STOCK_THRESHOLD:
            if num_all_defectors_prev > 0:
                self.defection_observation_streak += 1
                return Action.D
            else:
                self.defection_observation_streak = 0
                return Action.C
        elif defection_ratio_prev > self.MAJORITY_DEFECTION_RATIO:
            self.defection_observation_streak += 1
            return Action.D
        elif num_all_defectors_prev > 0:
            self.defection_observation_streak += 1
            if self.defection_observation_streak >= 2:
                return Action.D
            else:
                return Action.C
        else:
            self.defection_observation_streak = 0
            return Action.C

class Strategy_COLLECTIVE_165(BaseStrategy):
    """
    Adaptive Community Guardian (ACG) strategy for the Common Pool Resource Game.

    ACG starts cooperatively and maintains cooperation as long as the resource health
    is stable or improving. When the resource shows signs of consistent overexploitation
    (declining stock below a threshold for a set number of rounds), it adaptively shifts
    to defection to protect its immediate interests and signal unsustainability.
    It defects in the final round to maximize terminal payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOPERATION_THRESHOLD: float = 0.8
        self.TOLERANCE_ROUNDS: int = 2
        self.previous_stock_level: float = game_description.capacity
        self.consecutive_unhealthy_rounds: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_idx = state.round_number
        observed_current_stock = state.current_stock
        if current_round_idx == 0:
            action = Action.C
        elif current_round_idx == self.game_description.n_rounds - 1:
            action = Action.D
        else:
            is_stock_declining = observed_current_stock < self.previous_stock_level
            is_below_threshold = observed_current_stock < self.COOPERATION_THRESHOLD * self.game_description.capacity
            if is_stock_declining and is_below_threshold:
                self.consecutive_unhealthy_rounds += 1
            else:
                self.consecutive_unhealthy_rounds = 0
            if self.consecutive_unhealthy_rounds >= self.TOLERANCE_ROUNDS:
                action = Action.D
            else:
                action = Action.C
        self.previous_stock_level = observed_current_stock
        return action

class Strategy_COLLECTIVE_166(BaseStrategy):
    """
    The Adaptive Collective Sustainer (ACS) strategy for the Common Pool Resource Game.

    This strategy aims to ensure the long-term sustainability of the common pool resource by
    employing conditional cooperation, resource health monitoring, and proportional reciprocity.
    It prioritizes collective resource health, starting with cooperation and reacting to
    defection based on a tolerance threshold, with decisions influenced by whether the resource
    is critically low or stable.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_recovery_threshold = self.capacity / 2.0
        if self.n_players == 2:
            self.k_defection_threshold = 0
        else:
            self.k_defection_threshold = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        num_other_defectors_last_round = np.sum(~history.opponent_actions[current_round_0_indexed - 1, :])
        if current_stock < self.S_recovery_threshold:
            if num_other_defectors_last_round > self.k_defection_threshold:
                return Action.D
            else:
                return Action.C
        elif num_other_defectors_last_round > self.k_defection_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_167(BaseStrategy):
    """
    Adaptive Collective Steward (ACS) strategy for the Common Pool Resource Game.
    This strategy monitors the common stock level and recent collective behavior
    to promote sustainability, while being robust and adaptive against exploitation.
    It balances forgiveness, proactive resource management, and defensive measures.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.DEF_TOLERANCE_THRESHOLD = max(1, math.floor(self.n / 4))
        self.STOCK_CRITICAL_THRESHOLD_FACTOR = 0.3
        self.STOCK_RECOVERY_THRESHOLD_FACTOR = 0.7
        self.PUNISHMENT_DURATION = 2
        self.last_round_defect_count = 0
        self.currently_in_punishment = False
        self.punishment_rounds_left = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        stock_critical_level = self.capacity * self.STOCK_CRITICAL_THRESHOLD_FACTOR
        stock_recovery_level = self.capacity * self.STOCK_RECOVERY_THRESHOLD_FACTOR
        if current_round_0_indexed > 0:
            defect_count_opponents = np.sum(~history.opponent_actions[current_round_0_indexed - 1, :])
            my_prev_action_was_D = not history.my_actions[current_round_0_indexed - 1]
            self.last_round_defect_count = defect_count_opponents + (1 if my_prev_action_was_D else 0)
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.r - 1:
            if current_stock >= stock_recovery_level:
                return Action.C
            else:
                return Action.D
        if self.currently_in_punishment:
            self.punishment_rounds_left -= 1
            if self.punishment_rounds_left > 0:
                return Action.D
            else:
                self.currently_in_punishment = False
        if current_stock < stock_critical_level:
            if self.last_round_defect_count >= self.n - 1:
                return Action.D
            else:
                return Action.C
        if self.last_round_defect_count == 0:
            return Action.C
        elif self.last_round_defect_count <= self.DEF_TOLERANCE_THRESHOLD:
            return Action.C
        else:
            self.currently_in_punishment = True
            self.punishment_rounds_left = self.PUNISHMENT_DURATION
            return Action.D

class Strategy_COLLECTIVE_168(BaseStrategy):
    """
    The Adaptive Conservationist with Forgiveness (ACF) strategy prioritizes long-term
    sustainability. It starts by cooperating, monitors opponent behavior, punishes
    significant defection, and has an absolute commitment to conservation when
    the resource is critically low. It is also forgiving, allowing a quick return
    to cooperation once opponents improve.
    """

    class StrategyState(Enum):
        COOPERATE = 1
        PUNISH = 2

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = game_description.n_players
        capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = max(capacity / (2 * n), capacity * 0.25)
        self.TOLERANCE_THRESHOLD_DEFECTORS = 0.5
        self.PUNISHMENT_DURATION = 1
        self.current_strategy_state = self.StrategyState.COOPERATE
        self.rounds_in_punishment = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == r - 1:
            return Action.D
        if state.current_stock < self.CRITICAL_STOCK_THRESHOLD:
            self.current_strategy_state = self.StrategyState.COOPERATE
            self.rounds_in_punishment = 0
            return Action.C
        if current_round_0_indexed == 0:
            return Action.C
        num_defectors_last_round = np.sum(np.logical_not(history.opponent_actions[-1, :]))
        proportion_defecting_last_round = num_defectors_last_round / (n - 1)
        if self.current_strategy_state == self.StrategyState.COOPERATE:
            if proportion_defecting_last_round > self.TOLERANCE_THRESHOLD_DEFECTORS:
                self.current_strategy_state = self.StrategyState.PUNISH
                self.rounds_in_punishment = 1
        elif self.rounds_in_punishment >= self.PUNISHMENT_DURATION:
            if proportion_defecting_last_round > self.TOLERANCE_THRESHOLD_DEFECTORS:
                self.rounds_in_punishment = 1
            else:
                self.current_strategy_state = self.StrategyState.COOPERATE
                self.rounds_in_punishment = 0
        if self.current_strategy_state == self.StrategyState.COOPERATE:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_169(BaseStrategy):
    """
    The "Adaptive Collective Steward" strategy for the Common Pool Resource Game.
    It balances initial cooperation with an adaptive response mechanism, a forgiving nature,
    and a strong emphasis on resource survival.
    """

    class Stance(Enum):
        """Internal states for the Adaptive Collective Steward strategy."""
        COOPERATIVE = 1
        PUNISHING = 2

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.current_stance = self.Stance.COOPERATIVE
        self.punishment_rounds_count = 0
        if self.n == 2:
            self.CTT = 0
        else:
            self.CTT = max(1, math.floor(self.n / 4))
        self.MAX_PUNISHMENT_ROUNDS = max(1, min(self.n, 5, math.floor(self.r / 2)))
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == self.r - 1:
            return Action.D
        if current_round_number == 0:
            self.current_stance = self.Stance.COOPERATIVE
            self.punishment_rounds_count = 0
            return Action.C
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            self.current_stance = self.Stance.COOPERATIVE
            self.punishment_rounds_count = 0
            return Action.C
        num_defectors_prev_round = np.sum(~history.opponent_actions[-1, :])
        if self.current_stance == self.Stance.COOPERATIVE:
            if num_defectors_prev_round <= self.CTT:
                self.punishment_rounds_count = 0
                return Action.C
            else:
                self.current_stance = self.Stance.PUNISHING
                self.punishment_rounds_count = 1
                return Action.D
        else:
            self.punishment_rounds_count += 1
            if num_defectors_prev_round == 0:
                self.current_stance = self.Stance.COOPERATIVE
                self.punishment_rounds_count = 0
                return Action.C
            elif self.punishment_rounds_count >= self.MAX_PUNISHMENT_ROUNDS:
                self.current_stance = self.Stance.COOPERATIVE
                self.punishment_rounds_count = 0
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_170(BaseStrategy):
    """
    The Adaptive Collective Manager (ACM) strategy aims to balance individual payoff maximization
    with the long-term sustainability of the common pool resource. It starts cooperatively,
    observes other players' actions, and adjusts its behavior to either encourage continued
    cooperation or to protect against excessive free-riding and resource depletion.
    The strategy's tolerance for defection is inversely related to the health of the common stock.
    It defects in the final round to maximize last-round payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_1_indexed = state.round_number + 1
        if state.round_number == 0:
            return Action.C
        if current_round_1_indexed == n_rounds:
            return Action.D
        num_opponent_cooperators_prev_round = np.sum(history.opponent_actions[-1, :])
        num_opponent_defectors_prev_round = n_players - 1 - num_opponent_cooperators_prev_round
        my_action_prev_round_was_defection = not history.my_actions[-1]
        my_defection_count_prev_round = 1 if my_action_prev_round_was_defection else 0
        observed_defections = num_opponent_defectors_prev_round + my_defection_count_prev_round
        stock_ratio = state.current_stock / capacity
        D_threshold = 0
        if stock_ratio <= 0.25:
            D_threshold = 1
        elif stock_ratio <= 0.5:
            D_threshold = math.ceil(n_players / 4)
        elif stock_ratio <= 0.75:
            D_threshold = math.ceil(n_players / 3)
        else:
            D_threshold = math.ceil(n_players / 2)
        if observed_defections >= D_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_171(BaseStrategy):
    """
    The "Adaptive Conservationist" strategy prioritizes the health and sustainability of the common stock
    while dynamically adapting its behavior based on the observed actions of other players.
    It aims to foster a cooperative environment but will react to sustained defection to deter exploitation,
    always reverting to conservationist behavior when the resource is critically threatened.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.collective_defection_streak = 0
        self.critical_stock_threshold = self.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        my_prev_action_was_D = 1 if not history.my_actions[-1] else 0
        num_D_prev_round = my_prev_action_was_D + np.sum(~history.opponent_actions[-1, :])
        if num_D_prev_round == 0:
            self.collective_defection_streak = 0
        else:
            self.collective_defection_streak += 1
        current_stock = state.current_stock
        if current_stock < self.critical_stock_threshold:
            return Action.C
        elif self.collective_defection_streak == 0:
            return Action.C
        elif self.collective_defection_streak == 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_172(BaseStrategy):
    """
    Adaptive Threshold Cooperation (ATC) strategy for the Common Pool Resource Game.
    Prioritizes long-term sustainability by cooperating, reacts to collective overconsumption
    with a short, deterrent defection, and emphasizes resource recovery when stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.sustainability_threshold_percent: float = 0.75
        self.critical_threshold_percent: float = 0.25
        self.defect_trigger_rounds: int = 1
        self.punishment_duration: int = 1
        self.consecutive_stock_decline: int = 0
        self.in_punishment_mode: bool = False
        self.punishment_rounds_left: int = 0
        self.last_observed_stock: float | None = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num = state.round_number
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        if current_round_num > 0 and self.last_observed_stock is not None:
            if current_stock < self.last_observed_stock:
                self.consecutive_stock_decline += 1
            else:
                self.consecutive_stock_decline = 0
                self.in_punishment_mode = False
                self.punishment_rounds_left = 0
        if current_round_num == 0:
            self.consecutive_stock_decline = 0
            self.in_punishment_mode = False
            self.punishment_rounds_left = 0
            action_for_round = Action.C
        elif current_round_num == total_rounds - 1:
            action_for_round = Action.D
        else:
            action_for_round = Action.C
            if self.in_punishment_mode and self.punishment_rounds_left > 0:
                action_for_round = Action.D
                self.punishment_rounds_left -= 1
                if self.punishment_rounds_left == 0:
                    self.in_punishment_mode = False
            elif current_stock < capacity * self.critical_threshold_percent:
                action_for_round = Action.C
            elif current_stock < capacity * self.sustainability_threshold_percent:
                if self.consecutive_stock_decline >= self.defect_trigger_rounds:
                    self.in_punishment_mode = True
                    self.punishment_rounds_left = self.punishment_duration
                    action_for_round = Action.D
                else:
                    action_for_round = Action.C
            elif self.consecutive_stock_decline >= self.defect_trigger_rounds:
                self.in_punishment_mode = True
                self.punishment_rounds_left = self.punishment_duration
                action_for_round = Action.D
            else:
                action_for_round = Action.C
        self.last_observed_stock = current_stock
        return action_for_round

class Strategy_COLLECTIVE_173(BaseStrategy):
    """
    Stock-Optimal Adaptive Cooperator (SOAC) strategy.
    Balances collective resource sustainability with individual robustness by adapting behavior
    based on current stock levels and observed opponent cooperation.

    The strategy's decision to Cooperate (C) or Defect (D) depends on three key factors:
    1. Current Round: Determines if it's the beginning, end, or middle of the game.
    2. Current Stock Level: Categorizes the resource as Healthy, Optimal Growth Zone, or Critical.
    3. Opponent Behavior: Observes the actions of other players from the previous round to gauge their cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.STOCK_HEALTHY_THRESHOLD = self.capacity * 0.75
        self.STOCK_OPTIMAL_GROWTH_THRESHOLD = self.capacity * 0.5
        self.STOCK_CRITICAL_THRESHOLD = self.capacity * 0.1
        self.DEFECTION_TOLERANCE_HEALTHY = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.total_rounds - 1:
            return Action.D
        previous_round_actions_others = history.opponent_actions[-1, :]
        d_count_prev = np.sum(~previous_round_actions_others)
        num_other_players = self.n_players - 1
        opponent_defection_ratio = d_count_prev / num_other_players
        if current_stock >= self.STOCK_HEALTHY_THRESHOLD:
            if opponent_defection_ratio <= self.DEFECTION_TOLERANCE_HEALTHY:
                return Action.C
            else:
                return Action.D
        elif current_stock >= self.STOCK_OPTIMAL_GROWTH_THRESHOLD:
            if d_count_prev == 0:
                return Action.C
            else:
                return Action.D
        elif current_stock >= self.STOCK_CRITICAL_THRESHOLD:
            if d_count_prev == 0:
                return Action.C
            else:
                return Action.D
        elif d_count_prev == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_174(BaseStrategy):
    """
    Collective Adaptive Strategy (CAS)

    Goal: Maximize the collective long-term stock sustainability (ideally maintaining stock at capacity)
    by fostering cooperation, while adapting to and mitigating the impact of defection from other players.

    Key Parameters for Strategy Logic:
    - n_players: Total number of players.
    - n_rounds: Total number of rounds.
    - current_round_number: The current round number (0 to n_rounds - 1).
    - D_count_prev: The number of players who chose to Defect in the immediately preceding round.

    Internal Strategy Parameter:
    - defection_tolerance_threshold: Calculated as max(0, floor(n_players / 3)).

    Decision Rules:
    1. First Round (current_round_number == 0):
       Action: Play C (Cooperate).
       Rationale: To signal a willingness to cooperate and establish a cooperative baseline.

    2. Last Round (current_round_number == n_rounds - 1):
       Action: Play D (Defect).
       Rationale: In the final round, there are no future consequences, so rational players
                  are expected to defect to maximize immediate payoff.

    3. Intermediate Rounds (0 < current_round_number < n_rounds - 1):
       The strategy monitors the collective behavior of other players from the previous round.
       - Retrieve D_count_prev (number of players who chose 'D' in the previous round).
       - Conditional Logic:
         - IF D_count_prev <= defection_tolerance_threshold:
           Action: Play C (Cooperate).
           Rationale: Defection from others is within acceptable limits; continue to reinforce cooperation.
         - ELSE (D_count_prev > defection_tolerance_threshold):
           Action: Play D (Defect).
           Rationale: Too many players defected, so play 'D' as a punitive measure to mitigate exploitation
                      and accelerate stock depletion, demonstrating that widespread defection is costly for all.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.defection_tolerance_threshold = max(0, self.n_players // 3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        if current_round_number == 0:
            return Action.C
        elif current_round_number == self.n_rounds - 1:
            return Action.D
        else:
            d_count_prev = np.sum(~history.opponent_actions[-1, :])
            if d_count_prev <= self.defection_tolerance_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_175(BaseStrategy):
    """
    Adaptive Reciprocity & Stock Management (ARSM) strategy for the Common Pool Resource Game.
    This strategy balances individual self-preservation with collective resource sustainability.
    It prioritizes maintaining the common stock through conditional cooperation, while defending
    against exploitation and adapting to the health of the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.P_coop_threshold = 0.7
        self.stock_critical_threshold = 0.2 * self.game_description.capacity
        self.stock_healthy_threshold = 0.7 * self.game_description.capacity
        self.defection_memory_window = 3
        self.forgiveness_coop_floor = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        num_rounds_in_window = min(state.round_number, self.defection_memory_window)
        average_coop_rate_others = 1.0
        if num_rounds_in_window > 0:
            recent_opponent_actions = history.opponent_actions[-num_rounds_in_window:]
            total_cooperators_in_window = np.sum(recent_opponent_actions)
            total_possible_cooperators_in_window = num_rounds_in_window * (n_players - 1)
            if total_possible_cooperators_in_window > 0:
                average_coop_rate_others = total_cooperators_in_window / total_possible_cooperators_in_window
        is_stock_critical = current_stock <= self.stock_critical_threshold
        is_stock_healthy = current_stock >= self.stock_healthy_threshold
        if state.round_number == total_rounds - 1:
            if is_stock_healthy:
                return Action.C
            else:
                return Action.D
        if is_stock_critical:
            return Action.D
        elif average_coop_rate_others >= self.P_coop_threshold:
            return Action.C
        elif is_stock_healthy and state.round_number < total_rounds - 2 and (average_coop_rate_others > self.forgiveness_coop_floor):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_176(BaseStrategy):
    """
    Adaptive Collective Enforcer (ACE) strategy for the Common Pool Resource Game.
    This strategy aims to foster collective, sustainable outcomes by starting with cooperation,
    but vigilantly responding to defection or stock depletion to protect its own long-term
    interests and incentivize better collective behavior. It operates on a system of "modes"
    that dictate its action, transitioning between them based on observed opponent actions
    and the common stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = game_description.n_players
        self.mode = 'COOPERATING'
        self.punishment_countdown = 0
        self.rehabilitation_countdown = 0
        self.CRITICAL_STOCK_RATIO = 0.25
        self.CONCERN_STOCK_RATIO = 0.5
        self.MAX_TOLERATED_DEFECTORS_NORMAL = max(1, math.floor(n * 0.2))
        self.MAX_TOLERATED_DEFECTORS_CONCERN = max(0, math.floor(n * 0.1))
        self.PUNISHMENT_DURATION_ROUNDS = 3
        self.REHABILITATION_OBSERVATION_ROUNDS = 2
        self.EMERGENCY_COOPERATE_THRESHOLD_DEFECT_COUNT = max(0, math.floor(n * 0.1))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        r_total = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == r_total - 1:
            return Action.D
        num_defectors_prev = sum((1 for action_bool in history.opponent_actions[-1, :] if not action_bool))
        prev_mode = self.mode
        if current_stock < capacity * self.CRITICAL_STOCK_RATIO:
            self.mode = 'EMERGENCY_CONSERVATION'
            self.punishment_countdown = 0
            self.rehabilitation_countdown = 0
        elif prev_mode == 'EMERGENCY_CONSERVATION' and current_stock >= capacity * self.CRITICAL_STOCK_RATIO:
            self.mode = 'COOPERATING'
            self.punishment_countdown = 0
            self.rehabilitation_countdown = 0
        if self.mode != 'EMERGENCY_CONSERVATION':
            if self.mode == 'PUNISHING':
                self.punishment_countdown -= 1
                if self.punishment_countdown <= 0:
                    self.mode = 'REHABILITATING'
                    self.rehabilitation_countdown = 0
            elif self.mode == 'REHABILITATING':
                if num_defectors_prev == 0:
                    self.rehabilitation_countdown += 1
                    if self.rehabilitation_countdown >= self.REHABILITATION_OBSERVATION_ROUNDS:
                        self.mode = 'COOPERATING'
                        self.rehabilitation_countdown = 0
                else:
                    self.rehabilitation_countdown = 0
                    self.mode = 'PUNISHING'
                    self.punishment_countdown = self.PUNISHMENT_DURATION_ROUNDS
            elif self.mode == 'COOPERATING':
                if current_stock < capacity * self.CONCERN_STOCK_RATIO:
                    if num_defectors_prev > self.MAX_TOLERATED_DEFECTORS_CONCERN:
                        self.mode = 'PUNISHING'
                        self.punishment_countdown = self.PUNISHMENT_DURATION_ROUNDS
                elif num_defectors_prev > self.MAX_TOLERATED_DEFECTORS_NORMAL:
                    self.mode = 'PUNISHING'
                    self.punishment_countdown = self.PUNISHMENT_DURATION_ROUNDS
        if self.mode == 'EMERGENCY_CONSERVATION':
            if num_defectors_prev <= self.EMERGENCY_COOPERATE_THRESHOLD_DEFECT_COUNT:
                return Action.C
            else:
                return Action.D
        elif self.mode == 'PUNISHING':
            return Action.D
        elif self.mode == 'REHABILITATING':
            return Action.C
        elif self.mode == 'COOPERATING':
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_177(BaseStrategy):
    """
    The "Adaptive Conservationist (AC)" strategy for the Common Pool Resource game.
    This strategy prioritizes sustainability, starting with cooperation and adapting to
    opponent behaviors. It protects the resource in critical conditions, punishes widespread
    defection, and forgives minor defections to foster long-term cooperation. In the final
    round, it reverts to individual self-interest.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if state.current_stock < self.capacity / 2:
            return Action.C
        if current_round_1_indexed == 1:
            return Action.C
        else:
            num_opponent_cooperated_prev_round = sum(history.opponent_actions[-1, :])
            my_cooperated_prev_round = history.my_actions[-1]
            total_cooperators_prev_round = num_opponent_cooperated_prev_round + (1 if my_cooperated_prev_round else 0)
            total_D_count_prev = self.n_players - total_cooperators_prev_round
            if total_D_count_prev == 0:
                return Action.C
            elif total_D_count_prev >= math.ceil(self.n_players / 2):
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_178(BaseStrategy):
    """
    Adaptive Resource Steward (ARS) strategy for the Common Pool Resource game.

    This strategy balances individual incentives with collective resource
    sustainability. It prioritizes the health and recovery of the common pool stock,
    especially when critically low, while also adapting to opponent behavior.
    It conditionally cooperates, starting with cooperation, but responds to
    collective defection to avoid exploitation. In the final round, it defects
    to maximize personal payoff, aligning with end-game rationality.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold_ratio = 0.25
        if self.n_players == 2:
            self.max_tolerated_defectors_count = 0
        else:
            self.max_tolerated_defectors_count = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_stock < self.capacity * self.critical_stock_threshold_ratio:
            return Action.C
        num_defectors_prev_round = 0
        if not history.my_actions[-1]:
            num_defectors_prev_round += 1
        num_defectors_prev_round += np.count_nonzero(~history.opponent_actions[-1, :])
        if num_defectors_prev_round > self.max_tolerated_defectors_count:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_179(BaseStrategy):
    """
    The Adaptive Conservationist strategy for the Common Pool Resource Game.
    This strategy prioritizes long-term resource sustainability through conditional
    cooperation, responding to defection, and enforcing emergency restoration.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = game_description.n_players
        capacity = game_description.capacity
        self.LOW_STOCK_THRESHOLD = 0.25 * capacity
        self.RESTORATION_ROUNDS = 2
        self.DEFECTION_TOLERANCE_COUNT = max(1, math.floor((n - 1) / 3))
        self.in_restoration_mode = False
        self.restoration_rounds_left = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        total_rounds = self.game_description.n_rounds
        if state.round_number == 0:
            return Action.C
        if state.round_number == total_rounds - 1:
            return Action.D
        num_other_defecting_players = np.sum(~history.opponent_actions[-1, :])
        if self.in_restoration_mode:
            self.restoration_rounds_left -= 1
            if self.restoration_rounds_left > 0:
                return Action.C
            else:
                self.in_restoration_mode = False
        if state.current_stock < self.LOW_STOCK_THRESHOLD:
            self.in_restoration_mode = True
            self.restoration_rounds_left = self.RESTORATION_ROUNDS
            return Action.C
        if num_other_defecting_players > self.DEFECTION_TOLERANCE_COUNT:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_180(BaseStrategy):
    """
    Sustainable Reciprocity (SR) strategy for the Common Pool Resource Game.
    SR prioritizes the long-term health of the common resource to ensure sustained
    high payoffs for all players. It starts by trusting and cooperating but adapts
    to the current state of the common stock and observed collective behavior.
    It retaliates against exploitation and forgives, aiming for a sustainable
    equilibrium while being robust against various opponent behaviors.
    """
    COOPERATION_THRESHOLD_HIGH = 0.95
    COOPERATION_THRESHOLD_MEDIUM = 0.75
    CONSUMPTION_TOLERANCE_FACTOR = 1.05

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        n = self.n_players
        capacity = self.capacity
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        last_round_was_collective_enough = True
        my_action_prev_round = history.my_actions[-1]
        my_payoff_prev_round = history.my_payoffs[-1]
        opponent_actions_prev_round = history.opponent_actions[-1, :]
        if my_action_prev_round == Action.C.value:
            initial_stock_prev_round = my_payoff_prev_round * (2.0 * n)
        else:
            initial_stock_prev_round = my_payoff_prev_round * n
        total_consumption_prev_round = 0.0
        if my_action_prev_round == Action.C.value:
            total_consumption_prev_round += initial_stock_prev_round / (2.0 * n)
        else:
            total_consumption_prev_round += initial_stock_prev_round / n
        num_cooperating_opponents = np.sum(opponent_actions_prev_round)
        num_defecting_opponents = n - 1 - num_cooperating_opponents
        total_consumption_prev_round += num_cooperating_opponents * (initial_stock_prev_round / (2.0 * n))
        total_consumption_prev_round += num_defecting_opponents * (initial_stock_prev_round / n)
        if initial_stock_prev_round > 0:
            expected_consumption_all_C = initial_stock_prev_round / 2.0
            if total_consumption_prev_round > expected_consumption_all_C * self.CONSUMPTION_TOLERANCE_FACTOR:
                last_round_was_collective_enough = False
        else:
            last_round_was_collective_enough = True
        if current_stock >= capacity * self.COOPERATION_THRESHOLD_HIGH:
            return Action.C
        elif current_stock >= capacity * self.COOPERATION_THRESHOLD_MEDIUM:
            if last_round_was_collective_enough:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_181(BaseStrategy):
    """
    The Common Pool Steward strategy aims for sustainable resource management by prioritizing 
    the long-term health of the common pool. It initiates cooperation and maintains it under 
    healthy conditions, but adapts to significant resource depletion or widespread defection.
    It balances collective well-being with pragmatic self-preservation to maximize collective 
    well-being over the long run, but not at the expense of being continuously exploited.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_CRITICAL = self.capacity * 0.2
        self.S_WARNING = self.capacity * 0.4
        self.D_TOLERANCE_THRESHOLD = max(1, math.floor(self.n_players / 4))
        self.D_MAJORITY_THRESHOLD = math.floor(self.n_players / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number + 1
        current_stock = state.current_stock
        if t == 1:
            return Action.C
        elif t == self.n_rounds:
            return Action.D
        else:
            previous_round_idx = state.round_number - 1
            my_action_prev_round_is_C = history.my_actions[previous_round_idx]
            num_opponents_cooperating = np.sum(history.opponent_actions[previous_round_idx, :])
            total_cooperators_prev_round = num_opponents_cooperating + (1 if my_action_prev_round_is_C else 0)
            num_D_last_round = self.n_players - total_cooperators_prev_round
            if current_stock < self.S_CRITICAL:
                return Action.C
            elif num_D_last_round > self.D_MAJORITY_THRESHOLD:
                return Action.D
            elif current_stock < self.S_WARNING and num_D_last_round > self.D_TOLERANCE_THRESHOLD:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_182(BaseStrategy):
    """
    The Adaptive Custodian strategy aims to achieve collective well-being in the Common Pool Resource game
    by prioritizing long-term resource sustainability and adapting to other players' actions.
    It encourages cooperation, deters defection, and manages resource depletion effectively.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.PUNISHMENT_DURATION: int = 2
        self.CRITICAL_STOCK_THRESHOLD_RATIO: float = 0.25
        self.DEFECTION_TOLERANCE: int = 0
        self.rounds_since_last_observed_defection: int = self.PUNISHMENT_DURATION

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round_number == 0:
            return Action.C
        my_action_prev = history.my_actions[-1]
        opponent_actions_prev = history.opponent_actions[-1, :]
        k_D_previous_round = 0
        if not my_action_prev:
            k_D_previous_round += 1
        k_D_previous_round += (opponent_actions_prev == False).sum()
        if k_D_previous_round > self.DEFECTION_TOLERANCE:
            self.rounds_since_last_observed_defection = 0
        else:
            self.rounds_since_last_observed_defection += 1
        if current_round_number == total_rounds - 1:
            return Action.D
        if current_stock / capacity < self.CRITICAL_STOCK_THRESHOLD_RATIO:
            return Action.C
        elif self.rounds_since_last_observed_defection < self.PUNISHMENT_DURATION:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_183(BaseStrategy):
    """
    Adaptive Collective Stewardship (ACS) Strategy for the Common Pool Resource game.
    This strategy balances collective resource sustainability with self-preservation.
    It defaults to cooperation but includes emergency conservation measures,
    adapts defensively to widespread defection from other players, and
    switches to a purely rational defection in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_tolerance_threshold = 0.25
        self.stock_critical_threshold_proportion = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_round_1_indexed == total_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        if current_stock < self.stock_critical_threshold_proportion * capacity:
            return Action.C
        num_defectors_in_previous_round = 0
        if not history.my_actions[-1]:
            num_defectors_in_previous_round += 1
        num_cooperating_opponents = np.sum(history.opponent_actions[-1, :])
        num_defecting_opponents = n_players - 1 - num_cooperating_opponents
        num_defectors_in_previous_round += num_defecting_opponents
        proportion_defectors = num_defectors_in_previous_round / n_players
        if proportion_defectors >= self.cooperation_tolerance_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_184(BaseStrategy):
    """
    The Adaptive Collective Sustainer (ACS) strategy aims to maximize collective payoff
    over the long run by prioritizing resource sustainability. It starts cooperatively,
    retaliates against excessive defections, but also exhibits forgiveness for minor
    deviations, and always cooperates when the resource is critically low. In the final
    round, it defects to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = self.capacity / 4.0
        if self.n_players == 2:
            self.max_tolerated_defections = 0
        else:
            self.max_tolerated_defections = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if state.current_stock < self.critical_stock_threshold:
            return Action.C
        last_round_history_idx = state.round_number - 1
        my_action_last_round = history.my_actions[last_round_history_idx]
        opponent_actions_last_round = history.opponent_actions[last_round_history_idx, :]
        num_defections_last_round = 0
        if not my_action_last_round:
            num_defections_last_round += 1
        num_defections_last_round += np.sum(~opponent_actions_last_round)
        if num_defections_last_round == 0:
            return Action.C
        elif 0 < num_defections_last_round <= self.max_tolerated_defections:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_185(BaseStrategy):
    """
    The Adaptive Collective Steward strategy prioritizes the long-term health of the common resource,
    encourages cooperation through conditional reciprocity, and acts to prevent exploitation.
    Its adaptive nature is based on both the observed actions of other players and the current
    state of the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.D_forgiveness_threshold = max(1, math.floor(self.n / 4))
        self.S_recovery_threshold = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock_level = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.r - 1:
            return Action.D
        else:
            all_prev_actions = np.append(history.opponent_actions[-1, :], history.my_actions[-1])
            num_cooperators_prev_round = np.sum(all_prev_actions)
            num_defectors_prev_round = self.n - num_cooperators_prev_round
            if current_stock_level < self.S_recovery_threshold:
                return Action.C
            elif num_defectors_prev_round <= self.D_forgiveness_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_186(BaseStrategy):
    """
    Adaptive Stock-Conscious Cooperator strategy for the Common Pool Resource Game.
    Prioritizes resource health and adapts to collective opponent behavior.

    This strategy aims for long-term sustainability by conditionally cooperating,
    punishing widespread defection, and adapting its stance based on the current
    stock level and observed player behavior. It incorporates a forgiveness mechanism
    for minor defections and a final round defection for immediate payoff maximization.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_threshold_ratio: float = 0.5
        self.critical_stock_ratio: float = 0.4
        self.punishment_duration: int = 2
        self.last_round_defectors_count: int = 0
        self.punishment_countdown: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round_0_indexed > 0 and history is not None:
            opponent_cooperators_prev_round = np.sum(history.opponent_actions[current_round_0_indexed - 1, :])
            opponent_defectors_prev_round = n_players - 1 - opponent_cooperators_prev_round
            my_defection_prev_round = 1 if not history.my_actions[current_round_0_indexed - 1] else 0
            self.last_round_defectors_count = opponent_defectors_prev_round + my_defection_prev_round
        else:
            self.last_round_defectors_count = 0
        if current_round_0_indexed == 0:
            self.punishment_countdown = 0
            return Action.C
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        if self.punishment_countdown > 0:
            self.punishment_countdown -= 1
            return Action.D
        if current_stock < capacity * self.critical_stock_ratio:
            if self.last_round_defectors_count >= n_players * self.defection_threshold_ratio:
                return Action.D
            else:
                self.punishment_countdown = 0
                return Action.C
        elif self.last_round_defectors_count == 0:
            self.punishment_countdown = 0
            return Action.C
        elif self.last_round_defectors_count >= n_players * self.defection_threshold_ratio:
            self.punishment_countdown = self.punishment_duration - 1
            return Action.D
        else:
            self.punishment_countdown = 0
            return Action.C

class Strategy_COLLECTIVE_187(BaseStrategy):
    """
    The Adaptive Collective Sustainer (ACS) strategy balances immediate gain with long-term resource sustainability.
    It promotes cooperation, punishes defection when the resource is healthy, but prioritizes resource
    recovery by cooperating when the stock is critically low or stressed. It adopts a rational, selfish
    approach in the final rounds of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.LOW_STOCK_THRESHOLD = self.capacity / (2.0 * self.n)
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / 2.0
        self.END_GAME_BUFFER_ROUNDS = max(1, math.floor(self.r / 4.0))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num_1_indexed = state.round_number + 1
        defection_count_prev_round = 0
        if round_num_1_indexed > 1:
            cooperating_opponents_prev_round = np.sum(history.opponent_actions[-1, :])
            defection_count_prev_round = self.n - 1 - cooperating_opponents_prev_round
        rounds_left = self.r - round_num_1_indexed + 1
        if rounds_left == 1:
            return Action.D
        elif rounds_left <= self.END_GAME_BUFFER_ROUNDS:
            if defection_count_prev_round == 0 and current_stock >= self.CRITICAL_STOCK_THRESHOLD:
                return Action.C
            else:
                return Action.D
        if current_stock <= self.LOW_STOCK_THRESHOLD:
            return Action.C
        if round_num_1_indexed == 1:
            return Action.C
        elif defection_count_prev_round == 0:
            return Action.C
        elif current_stock > self.CRITICAL_STOCK_THRESHOLD:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_188(BaseStrategy):
    """
    The Adaptive Collective Resource Steward strategy aims for collective sustainability
    and long-term stock levels in the Common Pool Resource Game. It starts cooperatively,
    monitors resource health, and adapts behavior based on current stock levels and the
    observed cooperation of other players in the previous round. It implements collective
    punishment for significant defection to enforce cooperative norms and rewards
    collective cooperation, while also accounting for endgame rationality.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_danger_zone = self.capacity / 4.0
        self.S_recovery_zone = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.C
        num_cooperators_prev_round = sum(history.opponent_actions[-1, :]) + int(history.my_actions[-1])
        num_defectors_prev_round = self.n_players - num_cooperators_prev_round
        if state.current_stock < self.S_danger_zone:
            return Action.C
        elif state.current_stock < self.S_recovery_zone:
            if num_cooperators_prev_round >= self.n_players - 1:
                return Action.C
            else:
                return Action.D
        elif num_cooperators_prev_round == self.n_players:
            return Action.C
        elif num_defectors_prev_round < math.floor(self.n_players / 2.0):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_189(BaseStrategy):
    """
    The Adaptive Collective Steward strategy promotes and sustains cooperation by being
    initially cooperative, selectively forgiving, and firm against persistent or
    widespread defection, while also safeguarding the common resource when it's
    critically low.
    """
    CRITICAL_STOCK_THRESHOLD_DIVISOR: int = 4
    MAX_TOLERATED_DEFECTORS_COUNT: int = 1
    PERSISTENT_DEFECTION_ROUNDS: int = 1

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.rounds_since_full_cooperation: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == 0:
            self.rounds_since_full_cooperation = 0
            return Action.C
        if current_round_0_indexed == n_rounds - 1:
            return Action.D
        num_defectors_prev_round = 0
        if history is not None and current_round_0_indexed > 0:
            prev_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
            num_defectors_prev_round = np.sum(~prev_round_opponent_actions)
        if num_defectors_prev_round > 0:
            self.rounds_since_full_cooperation += 1
        else:
            self.rounds_since_full_cooperation = 0
        if current_stock < capacity / self.CRITICAL_STOCK_THRESHOLD_DIVISOR:
            return Action.C
        if num_defectors_prev_round == 0:
            return Action.C
        elif num_defectors_prev_round <= self.MAX_TOLERATED_DEFECTORS_COUNT and self.rounds_since_full_cooperation <= self.PERSISTENT_DEFECTION_ROUNDS:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_190(BaseStrategy):
    """
    The Adaptive Forager (AF) is a collective strategy designed for the Common Pool Resource Game.
    It prioritizes long-term sustainability by starting cooperatively, enforcing cooperation
    through reciprocal punishment, forgiving past transgressions, entering emergency
    conservation mode when the resource is critical, and defecting in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.DEFECTION_TOLERANCE_THRESHOLD = 1.0 / self.game_description.n_players
        self.FORGIVENESS_ROUNDS = 1
        self.S_CRITICAL_THRESHOLD = self.game_description.capacity * 0.25
        self.punish_mode_active = False
        self.punish_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            self.punish_mode_active = False
            self.punish_rounds_remaining = 0
            return Action.C
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        stock_is_critical = current_stock < self.S_CRITICAL_THRESHOLD
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        num_defectors_last_round = np.sum(previous_round_opponent_actions == False)
        defection_rate_last_round = num_defectors_last_round / n_players
        if stock_is_critical:
            self.punish_mode_active = False
            self.punish_rounds_remaining = 0
            return Action.C
        elif self.punish_mode_active:
            if self.punish_rounds_remaining > 0:
                self.punish_rounds_remaining -= 1
                return Action.D
            else:
                self.punish_mode_active = False
                return Action.C
        elif defection_rate_last_round >= self.DEFECTION_TOLERANCE_THRESHOLD:
            self.punish_mode_active = True
            self.punish_rounds_remaining = self.FORGIVENESS_ROUNDS - 1
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_191(BaseStrategy):
    """
    Adaptive Collective Reciprocator: This strategy promotes collective sustainability
    while being robust against exploitation. It balances immediate individual gain
    with long-term resource preservation, adapting its behavior based on the current
    state of the common pool resource and the observed actions of all players.

    It operates under the assumption that while cooperation is beneficial for everyone
    in the long run, outright altruism will be exploited by purely selfish players.
    Therefore, it aims to facilitate cooperation through reciprocity and deterrence.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self._critical_stock_ratio: float = 0.3
        self._sufficient_cooperation_for_recovery: float = 0.75
        self._tolerance_for_defectors: int = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        my_previous_action_was_C = history.my_actions[-1]
        opponent_cooperators_prev_round = sum(history.opponent_actions[-1, :])
        num_cooperators_prev_round = opponent_cooperators_prev_round + int(my_previous_action_was_C)
        num_defectors_prev_round = self.n_players - num_cooperators_prev_round
        if current_stock < self._critical_stock_ratio * self.capacity:
            if num_cooperators_prev_round >= self._sufficient_cooperation_for_recovery * self.n_players:
                return Action.C
            else:
                return Action.D
        elif num_defectors_prev_round <= self._tolerance_for_defectors:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_192(BaseStrategy):
    """
    Adaptive Collective Sustainer (ACS) Strategy:
    Promotes collective welfare by prioritizing resource sustainability while remaining robust against free-riders.
    It balances long-term cooperation with short-term responses to defection, adapting based on stock level
    and observed opponent actions. It cooperates by default, but defects in the final round and
    when the stock is healthy but opponents defect significantly. It prioritizes cooperation
    for resource recovery if the stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.STOCK_CRITICAL_THRESHOLD_FACTOR = 0.25
        self.STOCK_WARNING_THRESHOLD_FACTOR = 0.75
        self.DEMAND_COOP_WARNING_STOCK = 0.8
        self.DEMAND_COOP_HEALTHY_STOCK = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_idx = state.round_number
        current_stock = state.current_stock
        if current_round_idx == 0:
            return Action.C
        if current_round_idx == self.n_rounds - 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[-1]
        num_cooperators_others_prev_round = np.sum(previous_round_opponent_actions)
        num_other_players = self.n_players - 1
        cooperation_rate_others_prev_round = num_cooperators_others_prev_round / num_other_players
        stock_critical_threshold = self.capacity * self.STOCK_CRITICAL_THRESHOLD_FACTOR
        stock_warning_threshold = self.capacity * self.STOCK_WARNING_THRESHOLD_FACTOR
        if current_stock < stock_critical_threshold:
            return Action.C
        elif current_stock < stock_warning_threshold:
            if cooperation_rate_others_prev_round >= self.DEMAND_COOP_WARNING_STOCK:
                return Action.C
            else:
                return Action.D
        elif cooperation_rate_others_prev_round >= self.DEMAND_COOP_HEALTHY_STOCK:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_193(BaseStrategy):
    """
    The Adaptive Collective Sustainer (ACS) strategy prioritizes the long-term health and
    sustainability of the common pool resource, aiming to maintain the stock level at capacity.
    It begins with a cooperative stance and adapts its behavior dynamically based on the observed
    actions of other players and the current state of the resource. It balances the pursuit
    of collective good with the need to protect against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOPERATION_MIN_OTHERS_RATIO = 0.5
        self.STOCK_CRITICAL_LOW_THRESHOLD = self.game_description.capacity / 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        num_other_cooperators = sum(previous_round_opponent_actions)
        num_other_players = self.game_description.n_players - 1
        observed_cooperation_rate_others = 0.0
        if num_other_players > 0:
            observed_cooperation_rate_others = num_other_cooperators / num_other_players
        else:
            observed_cooperation_rate_others = 1.0
        current_stock = state.current_stock
        if current_stock < self.STOCK_CRITICAL_LOW_THRESHOLD:
            if observed_cooperation_rate_others >= 0.5:
                return Action.C
            else:
                return Action.D
        elif observed_cooperation_rate_others < self.COOPERATION_MIN_OTHERS_RATIO:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_194(BaseStrategy):
    """
    Adaptive Stock-Aware Reciprocity (ASAR) strategy for the Common Pool Resource Game.
    This strategy balances resource sustainability with conditional reciprocity, adapting
    its behavior based on the current stock level and the observed defection of other players.
    It starts cooperatively, becomes more cautious with low stock, and retaliates against
    significant defection, while maximizing immediate gains in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_FACTOR = 0.2
        self.LOW_STOCK_FACTOR = 0.5
        self.DEFECTION_TOLERANCE_NORMAL = 0.35
        self.DEFECTION_TOLERANCE_LOW_STOCK = 0.15

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        num_players = self.game_description.n_players
        if current_round == 0:
            return Action.C
        if current_round == total_rounds - 1:
            return Action.D
        CRITICAL_STOCK_LEVEL = self.CRITICAL_STOCK_FACTOR * capacity
        LOW_STOCK_LEVEL = self.LOW_STOCK_FACTOR * capacity
        prev_round_opponent_actions = history.opponent_actions[current_round - 1, :]
        num_other_defectors = np.sum(~prev_round_opponent_actions)
        fraction_other_defectors = num_other_defectors / (num_players - 1)
        if current_stock < CRITICAL_STOCK_LEVEL:
            return Action.C
        elif current_stock < LOW_STOCK_LEVEL:
            if fraction_other_defectors > self.DEFECTION_TOLERANCE_LOW_STOCK:
                return Action.D
            else:
                return Action.C
        elif fraction_other_defectors > self.DEFECTION_TOLERANCE_NORMAL:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_195(BaseStrategy):
    """
    The Adaptive Resource Guardian strategy aims to balance sustainable resource management
    with individual robustness. It implements conditional cooperation, adapting its
    behavior based on observed actions of other players and the current state of the
    common resource pool. It prioritizes resource recovery when the stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOPERATION_THRESHOLD_PERCENTAGE = 0.7
        self.STOCK_CRITICAL_THRESHOLD_FACTOR = 0.25
        self.STOCK_DANGER_THRESHOLD_FACTOR = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_game_round = state.round_number + 1
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_game_round == 1:
            return Action.C
        if current_game_round == total_rounds:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[state.round_number - 1]
        num_cooperators_last_round = np.sum(previous_round_opponent_actions).item()
        cooperation_rate_last_round = num_cooperators_last_round / n_players
        stock_status = 'healthy'
        if current_stock < capacity * self.STOCK_CRITICAL_THRESHOLD_FACTOR:
            stock_status = 'critical'
        if current_stock < capacity * self.STOCK_DANGER_THRESHOLD_FACTOR:
            stock_status = 'danger'
        if stock_status == 'danger':
            return Action.C
        elif stock_status == 'critical':
            if cooperation_rate_last_round >= self.COOPERATION_THRESHOLD_PERCENTAGE:
                return Action.C
            else:
                return Action.D
        elif cooperation_rate_last_round >= self.COOPERATION_THRESHOLD_PERCENTAGE:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_196(BaseStrategy):
    """
    Adaptive Resource Guardian (ARG) strategy for the Common Pool Resource Game.
    This strategy prioritizes resource sustainability, employs conditional cooperation,
    and uses adaptive punishment against excessive defection by other players.
    It includes specific logic for the first and last rounds to establish good faith
    and maximize endgame payoff, respectively.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Resource Guardian strategy.

        Args:
            game_description: An object containing game parameters such as
                              number of players (n_players), total rounds (n_rounds),
                              and resource capacity.
        """
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD = 0.25
        n = self.game_description.n_players
        self.DEFECTOR_TOLERANCE_COUNT = math.floor((n - 1) / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: An object containing the current round number and current stock level.
            history: An object containing records of past actions and payoffs for
                     this player and opponents. None for the very first round.

        Returns:
            An Action enum value (Action.C for Cooperate, Action.D for Defect).
        """
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round == 0:
            return Action.C
        if current_round == total_rounds - 1:
            return Action.D
        else:
            num_defectors_prev_round_opponents = np.sum(~history.opponent_actions[-1, :])
            is_stock_critically_low = current_stock < capacity * self.CRITICAL_STOCK_THRESHOLD
            if is_stock_critically_low:
                return Action.C
            elif num_defectors_prev_round_opponents > self.DEFECTOR_TOLERANCE_COUNT:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_197(BaseStrategy):
    """
    Collective Guardian strategy aims for robust long-term sustainability of the common pool resource.
    It fosters cooperation by rewarding good behavior and deterring exploitation,
    adapting its approach based on the health of the resource (critical, moderate, healthy).
    This strategy prioritizes collective well-being and resource preservation,
    employs conditional reciprocity, and acts to optimize individual gain only in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        stock_percentage = current_stock / self.capacity
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if stock_percentage < 0.2:
            return Action.C
        if stock_percentage >= 0.9:
            return Action.C
        all_players_cooperated_last_round = False
        if current_round_0_indexed == 0:
            all_players_cooperated_last_round = True
        else:
            my_last_action_was_C = history.my_actions[-1]
            num_opponent_cooperators = history.opponent_actions[-1, :].sum()
            all_opponents_last_actions_were_C = num_opponent_cooperators == self.n_players - 1
            all_players_cooperated_last_round = my_last_action_was_C and all_opponents_last_actions_were_C
        if all_players_cooperated_last_round:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_198(BaseStrategy):
    """
    The Adaptive Conservationist strategy aims for sustainable resource management by defaulting to cooperation,
    adapting behavior based on common pool stock health, responding to collective defection only when the resource
    is robust, and defecting in the terminal round for immediate payoff maximization.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.HEALTHY_THRESHOLD = 0.75
        self.CRITICAL_THRESHOLD = 0.25
        self.HIGH_DEFECTION_RATE_THRESHOLD = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = float(self.game_description.capacity)
        current_round = state.round_number
        stock = state.current_stock
        if stock <= 0.01:
            return Action.C
        if current_round == 0:
            return Action.C
        if current_round == n_rounds - 1:
            return Action.D
        stock_health_ratio = stock / capacity
        previous_round_idx = current_round - 1
        my_prev_action_was_D = not history.my_actions[previous_round_idx]
        num_opponent_defectors_in_prev_round = np.sum(~history.opponent_actions[previous_round_idx, :])
        total_defectors_in_prev_round = int(my_prev_action_was_D) + num_opponent_defectors_in_prev_round
        avg_defection_rate = total_defectors_in_prev_round / n_players
        if stock_health_ratio > self.HEALTHY_THRESHOLD:
            if avg_defection_rate > self.HIGH_DEFECTION_RATE_THRESHOLD:
                return Action.D
            else:
                return Action.C
        elif stock_health_ratio > self.CRITICAL_THRESHOLD:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_199(BaseStrategy):
    """
    The Adaptive Conservationist strategy aims to sustain the common pool resource at a healthy level
    by conditionally cooperating, while also protecting itself from excessive exploitation. It prioritizes
    resource recovery when the stock is critically low, acting as a collective safety mechanism.

    It operates based on three main decision rules:
    1. Initial cooperation in the first round to foster a cooperative environment.
    2. Defection in the final round to maximize individual payoff (backward induction).
    3. In intermediate rounds, it prioritizes resource recovery by cooperating if the stock is below
       a critical threshold. Otherwise, it conditionally cooperates based on the number of defectors
       observed in the previous round, retaliating if defections exceed a calculated tolerance.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = game_description.n_players
        capacity = game_description.capacity
        self.max_tolerated_defectors = math.floor((n - 1) / 2)
        self.critical_stock_threshold = capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock_S = state.current_stock
        if current_round_t_0_indexed == 0:
            return Action.C
        if current_round_t_0_indexed == total_rounds - 1:
            return Action.D
        if current_stock_S <= self.critical_stock_threshold:
            return Action.C
        else:
            previous_round_opponent_actions = history.opponent_actions[-1, :]
            num_defectors_prev_round = np.sum(~previous_round_opponent_actions)
            if num_defectors_prev_round > self.max_tolerated_defectors:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_200(BaseStrategy):
    """
    The 'Adaptive Collective Steward' strategy aims to foster sustainable common pool resource
    management through conditional cooperation. It starts cooperatively, maintains cooperation
    as long as others generally do and the resource is healthy, but switches to defection
    if widespread defection is observed or if the resource stock becomes critically low.
    It defects in the final round for self-preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_threshold = self.n_players / 2
        self.critical_stock_threshold = self.capacity / 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        previous_round_all_actions = np.append(history.opponent_actions[state.round_number - 1, :], history.my_actions[state.round_number - 1])
        num_defectors_prev_round = np.sum(previous_round_all_actions == False)
        if num_defectors_prev_round >= self.defection_threshold:
            return Action.D
        if state.current_stock <= self.critical_stock_threshold:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_201(BaseStrategy):
    """
    The "Adaptive Conservationist" (AC) strategy is designed to promote long-term collective welfare
    by sustaining the common pool resource, while also being robust against exploitation from defecting players.
    It operates on a principle of conditional cooperation, adapting its behavior based on the collective actions
    of other players and the current health of the resource stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.MIN_COOPERATION_RATE = 0.75
        self.HEALTHY_STOCK_THRESHOLD = 0.75
        self.CRITICAL_STOCK_THRESHOLD = 0.25
        self.ENDGAME_THRESHOLD_ROUNDS = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.C
        num_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        num_cooperators_prev_round = sum(history.opponent_actions[-1, :]) + history.my_actions[-1]
        cooperation_rate = num_cooperators_prev_round / num_players if num_players > 0 else 0.0
        stock_ratio = state.current_stock / capacity if capacity > 0 else 0.0
        remaining_rounds_including_current = total_rounds - current_round_1_indexed + 1
        if remaining_rounds_including_current <= self.ENDGAME_THRESHOLD_ROUNDS:
            if stock_ratio >= self.HEALTHY_STOCK_THRESHOLD:
                return Action.C
            else:
                return Action.D
        if stock_ratio < self.CRITICAL_STOCK_THRESHOLD:
            return Action.D
        if cooperation_rate >= self.MIN_COOPERATION_RATE:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_202(BaseStrategy):
    """
    The "Adaptive Community Guardian" strategy balances individual self-interest in the final round with long-term
    collective well-being, adapting its behavior based on observed history and the current state of the resource.

    Core Principles:
    1.  Stewardship: Prioritize resource preservation when the stock is critically low.
    2.  Reciprocity: Start cooperatively and reward sustained cooperation from others.
    3.  Deterrence: Respond to defection from other players to prevent exploitation.
    4.  Forgiveness: Allow for a return to cooperation after punishment phases.
    5.  Rationality: Act to maximize individual payoff in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.STOCK_PRESERVATION_THRESHOLD = self.game_description.capacity / 2.0
        self.PUNISHMENT_DURATION = 1
        self.punishment_rounds_remaining: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number + 1
        if t == 1:
            self.punishment_rounds_remaining = 0
            return Action.C
        if t == self.game_description.n_rounds:
            return Action.D
        if state.current_stock < self.STOCK_PRESERVATION_THRESHOLD:
            self.punishment_rounds_remaining = 0
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[state.round_number - 1]
        cooperators_from_others = np.sum(previous_round_opponent_actions)
        num_other_players = self.game_description.n_players - 1
        defection_count_others = num_other_players - cooperators_from_others
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            return Action.D
        elif defection_count_others > 0:
            self.punishment_rounds_remaining = self.PUNISHMENT_DURATION - 1
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_203(BaseStrategy):
    """
    Adaptive Threshold-based Cooperation (ATC) strategy.

    This strategy aims for collective sustainability of the common pool resource.
    It defaults to cooperation but employs a punitive mechanism for insufficient
    cooperation from other players and a pragmatic response to critical resource
    depletion. It concludes with a rational defection in the final round.

    Key principles:
    - Lead with Cooperation: Start by cooperating.
    - Monitor & Retaliate: Defect if the previous round's cooperation rate falls below `alpha_coop_min`.
    - Protect Resource: Cooperate if the resource is healthy and cooperation is sufficient.
    - Pragmatic Salvage: If the resource is critically low (`beta_resource_critical`) AND there
      were defectors in the previous round, defect to salvage immediate value.
      However, if the resource is critical but *all* players cooperated perfectly
      in the previous round, continue cooperating to maintain solidarity.
    - Rational End-Game: Defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.alpha_coop_min = 0.75
        self.beta_resource_critical = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        num_cooperators_prev = np.sum(history.opponent_actions[-1, :]) + history.my_actions[-1]
        cooperation_rate_prev = num_cooperators_prev / self.n_players
        resource_health = state.current_stock / self.capacity
        if cooperation_rate_prev < self.alpha_coop_min:
            return Action.D
        elif resource_health < self.beta_resource_critical:
            num_defectors_prev = self.n_players - num_cooperators_prev
            if num_defectors_prev > 0:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_204(BaseStrategy):
    """
    The "Adaptive Conservationist" (AC) strategy is designed to promote collective
    cooperation and resource sustainability in the Common Pool Resource Game.
    It balances the immediate individual incentive to defect with the long-term
    collective benefit of maintaining the resource. Its decisions are based on
    the current round number, the current stock level, and the observed actions
    of all players in the previous round, adapting to promote cooperation while
    also protecting against exploitation and ensuring self-preservation in crisis.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.STOCK_RECOVERY_THRESHOLD = capacity / 3.0
        self.STOCK_PUNISHMENT_THRESHOLD = capacity / 6.0
        if n == 2:
            self.COOPERATION_THRESHOLD_COUNT = 2
        else:
            self.COOPERATION_THRESHOLD_COUNT = math.ceil(n / 2.0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number
        total_rounds_r = self.game_description.n_rounds
        current_stock_S = state.current_stock
        if current_round_t == total_rounds_r - 1:
            return Action.D
        if current_round_t == 0:
            return Action.C
        num_cooperators_last_round = int(np.sum(history.opponent_actions[-1, :])) + int(history.my_actions[-1])
        if current_stock_S <= self.STOCK_RECOVERY_THRESHOLD:
            if current_stock_S <= self.STOCK_PUNISHMENT_THRESHOLD and num_cooperators_last_round < self.COOPERATION_THRESHOLD_COUNT:
                return Action.D
            else:
                return Action.C
        if num_cooperators_last_round >= self.COOPERATION_THRESHOLD_COUNT:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_205(BaseStrategy):
    """
    The Adaptive Resource Guardian (ARG) strategy aims to maximize the collective long-term payoff
    by sustaining the common pool resource at or near its capacity. It promotes cooperation but
    detects and deters free-riding, adjusting its behavior based on observed actions and resource health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.PUNISHMENT_DURATION = 2
        self.DEFECTION_TOLERANCE_LEVEL = 1
        self.STOCK_THRESHOLD_FOR_PUNISHMENT_FACTOR = 0.9
        self.MAX_NON_COOPERATIVE_ROUNDS = 3
        self._punishment_rounds_remaining: int = 0
        self._consecutive_non_cooperative_rounds: int = 0
        self._game_capacity_value: float | None = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number_1_indexed = state.round_number + 1
        total_rounds_r = self.game_description.n_rounds
        if state.round_number == 0:
            self._game_capacity_value = state.current_stock
            self._punishment_rounds_remaining = 0
            self._consecutive_non_cooperative_rounds = 0
            return Action.C
        if current_round_number_1_indexed == total_rounds_r:
            return Action.D
        if state.current_stock <= 0:
            return Action.D
        all_players_prev_actions = np.concatenate((np.array([history.my_actions[-1]]), history.opponent_actions[-1, :]))
        num_defectors_prev_round = np.sum(all_players_prev_actions == False)
        if self._punishment_rounds_remaining > 0:
            self._punishment_rounds_remaining -= 1
            return Action.D
        elif num_defectors_prev_round == 0:
            self._consecutive_non_cooperative_rounds = 0
            return Action.C
        else:
            self._consecutive_non_cooperative_rounds += 1
            trigger_new_punishment = False
            if num_defectors_prev_round >= self.DEFECTION_TOLERANCE_LEVEL and self._game_capacity_value is not None and (state.current_stock < self.STOCK_THRESHOLD_FOR_PUNISHMENT_FACTOR * self._game_capacity_value):
                trigger_new_punishment = True
            if self._consecutive_non_cooperative_rounds >= self.MAX_NON_COOPERATIVE_ROUNDS:
                trigger_new_punishment = True
            if trigger_new_punishment:
                self._punishment_rounds_remaining = self.PUNISHMENT_DURATION - 1
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_206(BaseStrategy):
    """
    The "Adaptive Community Steward" (ACS) strategy promotes collective sustainability
    of the common pool resource while being robust against exploitation by defecting players.
    It operates on principles of conditional cooperation, proportional punishment, and
    critical resource conservation.

    The core idea is to lead by example with cooperation, quickly retaliate against
    defectors to deter free-riding, and, most importantly, prioritize the survival of
    the resource when it's under severe threat, even if it means temporary individual
    sacrifice.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_rounds_left: int = 0
        self.MIN_DEFECTOR_COUNT_FOR_PUNISHMENT: int = 1
        self.CONSERVATION_STOCK_THRESHOLD_RATIO: float = 0.5
        self.PUNISHMENT_DURATION: int = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_idx = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round_idx == total_rounds - 1:
            return Action.D
        if current_stock < self.CONSERVATION_STOCK_THRESHOLD_RATIO * capacity:
            self.punishment_rounds_left = 0
            return Action.C
        if self.punishment_rounds_left > 0:
            self.punishment_rounds_left -= 1
            return Action.D
        if current_round_idx == 0:
            return Action.C
        num_other_defectors_prev_round = np.sum(~history.opponent_actions[-1, :])
        if num_other_defectors_prev_round >= self.MIN_DEFECTOR_COUNT_FOR_PUNISHMENT:
            self.punishment_rounds_left = self.PUNISHMENT_DURATION
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_207(BaseStrategy):
    """
    The Guardian strategy for the Common Pool Resource Game.
    Guardian prioritizes long-term resource sustainability, balancing individual payoff
    with collective well-being. It starts cooperatively, employs conditional forgiveness
    for minor defections, and punishes widespread exploitation or critical resource depletion.
    It anticipates rational end-game behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOPERATION_TOLERANCE_THRESHOLD_COUNT = max(1, math.floor(self.game_description.n_players * 0.5))
        self.CRITICAL_STOCK_RATIO = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number
        total_rounds_r = self.game_description.n_rounds
        current_stock_S = state.current_stock
        capacity = self.game_description.capacity
        if current_round_t == 0:
            return Action.C
        if current_round_t == total_rounds_r - 1:
            return Action.D
        num_D_prev = 0
        if not history.my_actions[-1]:
            num_D_prev += 1
        num_D_prev += np.sum(~history.opponent_actions[-1, :])
        is_stock_critical = current_stock_S < self.CRITICAL_STOCK_RATIO * capacity
        if is_stock_critical:
            if num_D_prev > 0:
                return Action.D
            else:
                return Action.C
        elif num_D_prev == 0:
            return Action.C
        elif num_D_prev <= self.COOPERATION_TOLERANCE_THRESHOLD_COUNT:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_208(BaseStrategy):
    """
    This strategy is designed to promote collective welfare by maintaining the common pool resource, 
    while being robust enough to survive and adapt in a tournament setting against diverse opponents.
    It balances the collective good with self-preservation, recognizing that naive cooperation leads to exploitation.
    It defaults to cooperation, punishes widespread defection, focuses on stock preservation at critical levels,
    and acts rationally in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_threshold = math.floor(self.n_players / 2)
        self.stock_critical_threshold = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[state.round_number - 1]
        previous_defections_count = np.sum(previous_round_opponent_actions == False)
        if previous_defections_count >= self.defection_threshold:
            return Action.D
        if state.current_stock < self.stock_critical_threshold:
            if previous_defections_count == 0:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_209(BaseStrategy):
    """
    The "Adaptive Collective Conservationist" strategy prioritizes the long-term sustainability
    of the common resource. It aims to cooperate to maintain the stock, but adapts to opponent
    behavior, retaliating against significant defection while remaining forgiving to minor
    deviations. It also has specific rules for critical stock levels to ensure resource recovery
    and employs end-game rationality.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = self.capacity * 0.1
        self.LOW_STOCK_THRESHOLD = self.capacity * 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        prev_round_idx = state.round_number - 1
        my_prev_action = history.my_actions[prev_round_idx]
        opponent_prev_actions = history.opponent_actions[prev_round_idx, :]
        all_players_prev_actions = np.concatenate(([my_prev_action], opponent_prev_actions))
        num_defectors_prev_round = self.n_players - np.sum(all_players_prev_actions)
        if state.current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        elif state.current_stock < self.LOW_STOCK_THRESHOLD:
            if num_defectors_prev_round >= self.n_players - 1:
                return Action.D
            else:
                return Action.C
        else:
            max_tolerated_defectors = self.n_players // 4
            if num_defectors_prev_round == 0:
                return Action.C
            elif num_defectors_prev_round <= max_tolerated_defectors:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_210(BaseStrategy):
    """
    Adaptive Resource Guardian (ARG) strategy for the Common Pool Resource Game.
    This strategy aims to promote collective sustainability by adapting its behavior
    between a "Cooperating" mode and a "Punishing" mode based on the common stock level.
    It cooperates when the stock is healthy, defects when it's depleted, and reverts
    to cooperation when the stock recovers. In the last round, it always defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOPERATION_HEALTH_THRESHOLD_PERCENTAGE = 0.8
        self.RECOVERY_FORGIVENESS_THRESHOLD_PERCENTAGE = 0.7
        self.current_mode = 'Cooperating'

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        current_round = state.round_number
        current_stock = state.current_stock
        cooperation_threshold_value = self.COOPERATION_HEALTH_THRESHOLD_PERCENTAGE * capacity
        recovery_forgiveness_value = self.RECOVERY_FORGIVENESS_THRESHOLD_PERCENTAGE * capacity
        if current_round == total_rounds - 1:
            return Action.D
        if current_round == 0:
            self.current_mode = 'Cooperating'
            return Action.C
        if self.current_mode == 'Cooperating':
            if current_stock < cooperation_threshold_value:
                self.current_mode = 'Punishing'
                return Action.D
            else:
                return Action.C
        elif current_stock >= recovery_forgiveness_value:
            self.current_mode = 'Cooperating'
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_211(BaseStrategy):
    """
    The Adaptive Conservationist with Stock Safeguard strategy aims to balance
    resource sustainability with self-protection against defection.
    It begins by cooperating to establish a sustainable baseline.
    In intermediate rounds, it prioritizes resource recovery by cooperating
    if the stock is critically low, regardless of others' actions.
    If the stock is healthy, it monitors the previous round's collective defection.
    If significant defection is detected (more than one player defected), it retaliates
    by defecting. Otherwise, it continues to cooperate.
    In the final round, it defects to maximize immediate payoff, as there are no
    future consequences for resource depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_threshold = 0.25 * self.capacity
        self.defection_tolerance_threshold = 1.0 / self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_idx = state.round_number
        current_stock = state.current_stock
        if current_round_idx == 0:
            return Action.C
        if current_round_idx == self.n_rounds - 1:
            return Action.D
        if current_stock <= 0:
            return Action.C
        prev_round_idx = current_round_idx - 1
        my_prev_action = history.my_actions[prev_round_idx]
        my_prev_payoff = history.my_payoffs[prev_round_idx]
        S_prev = 0.0
        if my_prev_payoff > 0:
            if my_prev_action == Action.C:
                S_prev = my_prev_payoff * (2 * self.n_players)
            else:
                S_prev = my_prev_payoff * self.n_players
        num_defectors_prev_round = 0
        if S_prev > 0:
            num_opponent_cooperators = np.sum(history.opponent_actions[prev_round_idx])
            num_opponent_defectors = len(history.opponent_actions[prev_round_idx]) - num_opponent_cooperators
            num_all_cooperators = num_opponent_cooperators + (1 if my_prev_action == Action.C else 0)
            num_all_defectors = num_opponent_defectors + (1 if my_prev_action == Action.D else 0)
            observed_total_consumption_prev = num_all_cooperators * (S_prev / (2 * self.n_players)) + num_all_defectors * (S_prev / self.n_players)
            calculated_k = 2 * self.n_players * observed_total_consumption_prev / S_prev - self.n_players
            num_defectors_prev_round = max(0, min(self.n_players, round(calculated_k)))
        defection_ratio = num_defectors_prev_round / self.n_players
        if current_stock <= self.critical_stock_threshold:
            return Action.C
        elif defection_ratio > self.defection_tolerance_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_212(BaseStrategy):
    """
    Strategy: CollectiveGuardian

    The CollectiveGuardian strategy aims to foster and maintain a cooperative environment
    to ensure the long-term sustainability of the common resource. It acts as a conditional
    cooperator, willing to lead by example but quick to punish exploitation, especially
    when the resource is abundant. When the resource is critically low, it prioritizes
    emergency cooperation for recovery, regardless of past betrayals.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_critical = self.capacity / 2.0
        if self.n_players == 2:
            self.max_defectors_tolerated = 0
        else:
            self.max_defectors_tolerated = 1
        self.P_coop_threshold = float(self.n_players - self.max_defectors_tolerated) / self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == 0:
            return Action.C
        if current_round_number == self.n_rounds - 1:
            return Action.D
        if current_stock < self.S_critical:
            return Action.C
        else:
            my_action_prev_round_is_C = history.my_actions[current_round_number - 1]
            opponent_actions_prev_round = history.opponent_actions[current_round_number - 1, :]
            my_defected_prev_round = 1 if not my_action_prev_round_is_C else 0
            cooperating_opponents_prev_round = sum(opponent_actions_prev_round)
            defected_opponents_prev_round = self.n_players - 1 - cooperating_opponents_prev_round
            total_defectors_prev_round = my_defected_prev_round + defected_opponents_prev_round
            actual_coop_rate_prev_round = float(self.n_players - total_defectors_prev_round) / self.n_players
            if actual_coop_rate_prev_round >= self.P_coop_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_213(BaseStrategy):
    """
    The Common Guardian strategy aims to foster sustainable resource management in the Common Pool Resource Game.
    It prioritizes resource health, using conditional cooperation and collective enforcement.
    It cooperates initially, defects in the final round, and adapts its behavior in intermediate rounds
    based on the stock level and the number of defectors in the previous round.
    It prioritizes stock recovery when critically low, even forgiving past defections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / 4.0
        self.RECOVERY_STOCK_THRESHOLD = self.capacity / 2.0
        self.STRICT_DEFECTION_DETECTION = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock_level = state.current_stock
        if current_round_number == 0:
            return Action.C
        if current_round_number == self.n_rounds - 1:
            return Action.D
        num_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
        if history.my_actions[-1]:
            num_cooperators_last_round += 1
        num_defectors_last_round = self.n_players - num_cooperators_last_round
        if current_stock_level < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        elif current_stock_level < self.RECOVERY_STOCK_THRESHOLD:
            return Action.C
        elif num_defectors_last_round > self.STRICT_DEFECTION_DETECTION:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_214(BaseStrategy):
    """
    Adaptive Collective Steward: A strategy designed for the Common Pool Resource Game
    to maximize collective welfare over the long term by promoting resource sustainability
    and encouraging cooperation. It adapts to observed group behavior, incorporates
    safeguards against resource collapse, and accounts for end-game defection.
    """
    _CRITICAL_STOCK_THRESHOLD_RATIO = 0.2
    _DEFECTION_TRIGGER_TOLERANCE_FACTOR = 0.05

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Collective Steward strategy.

        Args:
            game_description: An object containing game parameters such as
                              number of players, rounds, and capacity.
        """
        self.game_description = game_description
        self.critical_stock_threshold_ratio = self.__class__._CRITICAL_STOCK_THRESHOLD_RATIO
        self.defection_trigger_tolerance_factor = self.__class__._DEFECTION_TRIGGER_TOLERANCE_FACTOR

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round number and stock level.
            history: A record of previous rounds' actions and payoffs for all players.
                     This is None for the very first round (round_number == 0).

        Returns:
            An Action enum (Action.C for Cooperate, Action.D for Defect).
        """
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_1_indexed = state.round_number + 1
        current_stock_S = state.current_stock
        critical_stock_level = self.critical_stock_threshold_ratio * capacity
        if current_round_1_indexed == r:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        prev_round_0_indexed = state.round_number - 1
        my_prev_action_is_C = history.my_actions[prev_round_0_indexed]
        my_prev_payoff = history.my_payoffs[prev_round_0_indexed]
        if my_prev_payoff == 0:
            S_prev_start = 0.0
        elif my_prev_action_is_C:
            S_prev_start = my_prev_payoff * (2 * n)
        else:
            S_prev_start = my_prev_payoff * n
        total_consumption_observed_prev = 0.0
        if S_prev_start > 0:
            my_consumption_prev = S_prev_start / (2 * n) if my_prev_action_is_C else S_prev_start / n
            total_consumption_observed_prev += my_consumption_prev
            opponent_prev_actions = history.opponent_actions[prev_round_0_indexed, :]
            num_opponent_cooperators_prev = np.sum(opponent_prev_actions)
            num_opponent_defectors_prev = n - 1 - num_opponent_cooperators_prev
            opponent_consumption_prev = num_opponent_cooperators_prev * (S_prev_start / (2 * n)) + num_opponent_defectors_prev * (S_prev_start / n)
            total_consumption_observed_prev += opponent_consumption_prev
        expected_all_C_consumption_prev = S_prev_start / 2.0
        defection_threshold_consumption = expected_all_C_consumption_prev * (1 + self.defection_trigger_tolerance_factor)
        if current_stock_S <= critical_stock_level:
            return Action.C
        elif total_consumption_observed_prev > defection_threshold_consumption:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_215(BaseStrategy):
    """
    The "Adaptive Resource Guardian" (ARG) strategy balances collective sustainability
    with self-protection, adapting its behavior based on resource health and observed
    actions of other players. It aims for high collective long-term payoff by
    promoting cooperation and deterring widespread defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.HEALTHY_STOCK_THRESHOLD = 0.8 * self.capacity
        self.CRITICAL_STOCK_THRESHOLD = 0.1 * self.capacity
        self.MODERATE_DEFECTION_TOLERANCE_HEALTHY = 0.33
        self.SINGLE_DEFECTOR_TOLERANCE_MODERATE = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        num_others = self.n_players - 1
        num_others_cooperate = sum(history.opponent_actions[-1, :])
        num_others_defect = num_others - num_others_cooperate
        fraction_others_defect = num_others_defect / num_others
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        elif current_stock >= self.HEALTHY_STOCK_THRESHOLD:
            if fraction_others_defect == 0:
                return Action.C
            elif fraction_others_defect <= self.MODERATE_DEFECTION_TOLERANCE_HEALTHY:
                return Action.C
            else:
                return Action.D
        elif num_others_defect == 0:
            return Action.C
        elif num_others_defect <= self.SINGLE_DEFECTOR_TOLERANCE_MODERATE:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_216(BaseStrategy):
    """
    The Adaptive Sentinel strategy balances cooperation for long-term resource sustainability
    with adaptive responses to collective consumption. It starts by cooperating, monitors
    the common stock level, and tracks collective defection streaks. It prioritizes
    resource recovery when stock is critically low and includes specific endgame behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.current_defection_streak = 0
        self.S_danger_threshold = self.capacity / 4.0
        self.max_defectors_allowed_for_cooperative_behavior = 1
        self.max_defection_streak_allowed = 2
        self.endgame_lookahead_rounds = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.r - 1:
            self.current_defection_streak = 0
            return Action.D
        if current_round_0_indexed >= self.r - 1 - self.endgame_lookahead_rounds and current_round_0_indexed < self.r - 1:
            if current_stock < self.S_danger_threshold:
                return Action.C
            else:
                return Action.D
        if current_round_0_indexed == 0:
            self.current_defection_streak = 0
            return Action.C
        if current_stock < self.S_danger_threshold:
            self.current_defection_streak = 0
            return Action.C
        previous_round_idx = current_round_0_indexed - 1
        if history is None or previous_round_idx < 0:
            self.current_defection_streak = 0
            return Action.C
        previous_my_action_C = history.my_actions[previous_round_idx]
        previous_opponent_actions_C = history.opponent_actions[previous_round_idx, :]
        num_defectors_prev_round = 0
        if not previous_my_action_C:
            num_defectors_prev_round += 1
        num_defectors_prev_round += np.sum(~previous_opponent_actions_C)
        if num_defectors_prev_round > self.max_defectors_allowed_for_cooperative_behavior:
            self.current_defection_streak += 1
            if self.current_defection_streak >= self.max_defection_streak_allowed:
                self.current_defection_streak = 0
                return Action.D
            else:
                return Action.C
        else:
            self.current_defection_streak = 0
            return Action.C

class Strategy_COLLECTIVE_217(BaseStrategy):
    """
    Adaptive Conservationist strategy for the Common Pool Resource Game.

    This strategy aims to promote and sustain cooperation, prioritize the health
    of the common resource, and protect itself from exploitation. It balances
    immediate individual payoffs with the long-term collective good.

    Decision Rules:
    1.  First Round: Cooperate to establish a positive precedent and ensure initial resource health.
    2.  Last Round: Defect to prevent exploitation by others and maximize final payoff, as there are no future consequences.
    3.  Critical Stock: If the common stock falls below a critical threshold (1/4 of capacity),
        prioritize conservation by cooperating, regardless of others' previous actions.
    4.  General Rounds: Reciprocate based on the observed collective behavior. If at least
        50% of other players cooperated in the previous round, cooperate; otherwise, defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold_proportion = 0.5
        self.critical_stock_threshold_proportion = 0.25
        self.critical_stock_threshold_value = self.critical_stock_threshold_proportion * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_stock < self.critical_stock_threshold_value:
            return Action.C
        previous_actions_of_others = history.opponent_actions[current_round_0_indexed - 1, :]
        num_other_cooperators = np.sum(previous_actions_of_others)
        num_other_players = self.n_players - 1
        proportion_other_cooperators = num_other_cooperators / num_other_players
        if proportion_other_cooperators >= self.cooperation_threshold_proportion:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_218(BaseStrategy):
    """
    The Adaptive Conservationist strategy aims to foster a sustainable equilibrium by rewarding cooperation and
    punishing significant defections, while also accounting for the terminal round.
    It starts with trust, strives for collective sustainability, but swiftly adjusts its behavior when others
    demonstrate non-cooperative tendencies or when the resource itself is under threat.
    It forgives minor deviations to maintain a path towards cooperation but will not allow itself to be exploited,
    especially when the resource becomes fragile.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        num_players = self.game_description.n_players
        if state.round_number == 0:
            return Action.C
        if state.round_number == total_rounds - 1:
            return Action.D
        stock_critical_threshold = capacity / 4
        stock_fragile_threshold = capacity / 2
        num_other_defectors_prev_round = np.sum(~history.opponent_actions[-1, :])
        if current_stock <= stock_critical_threshold:
            return Action.D
        elif current_stock < stock_fragile_threshold:
            if num_other_defectors_prev_round == 0:
                return Action.C
            else:
                return Action.D
        elif num_other_defectors_prev_round <= 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_219(BaseStrategy):
    """
    ASAR-DF (Adaptive Stock-Aware Reciprocal Strategy with Dynamic Forgiveness)
    implements a collective strategy for the Common Pool Resource Game.
    It balances initial trust, stock preservation, conditional reciprocity,
    and dynamic forgiveness, with a pragmatic self-preservation rule for the endgame
    or when resource collapse is imminent due to widespread defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.capacity_half = self.capacity / 2.0
        self.capacity_quarter = self.capacity / 4.0
        self.num_opponents = self.n_players - 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number_0_indexed = state.round_number
        if round_number_0_indexed == 0:
            return Action.C
        if round_number_0_indexed == self.n_rounds - 1:
            return Action.D
        opponent_actions_prev_round_bool = history.opponent_actions[-1, :]
        num_other_cooperators_prev_round = np.sum(opponent_actions_prev_round_bool)
        num_other_defectors_prev_round = self.num_opponents - num_other_cooperators_prev_round
        is_any_chronic_defector = False
        if round_number_0_indexed >= 2:
            actions_t_minus_1_bool = history.opponent_actions[-1, :]
            actions_t_minus_2_bool = history.opponent_actions[-2, :]
            for opponent_idx in range(self.num_opponents):
                if not actions_t_minus_1_bool[opponent_idx] and (not actions_t_minus_2_bool[opponent_idx]):
                    is_any_chronic_defector = True
                    break
        if current_stock < self.capacity_quarter:
            if num_other_cooperators_prev_round >= self.num_opponents / 2.0:
                return Action.C
            else:
                return Action.D
        elif current_stock < self.capacity_half:
            if num_other_cooperators_prev_round == self.num_opponents:
                return Action.C
            elif num_other_defectors_prev_round == self.num_opponents:
                return Action.D
            elif num_other_cooperators_prev_round >= self.num_opponents / 2.0:
                return Action.C
            else:
                return Action.D
        elif num_other_cooperators_prev_round == self.num_opponents:
            return Action.C
        elif num_other_defectors_prev_round == self.num_opponents:
            return Action.D
        elif is_any_chronic_defector:
            return Action.D
        elif num_other_defectors_prev_round == 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_220(BaseStrategy):
    """
    Adaptive Collective Guardian (ACG) strategy for the Common Pool Resource Game.
    This strategy prioritizes long-term resource sustainability through conditional cooperation.
    It starts cooperatively, defects in the last round, enters an emergency cooperation mode
    if the stock is critically low, and otherwise adapts its behavior based on the
    observed level of cooperation in the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.K_cooperate_threshold: float = 0.5
        self.K_stock_critical: float = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock <= self.game_description.capacity * self.K_stock_critical:
            return Action.C
        num_cooperators_previous_round = np.sum(history.opponent_actions[-1, :]) + int(history.my_actions[-1])
        cooperation_fraction = num_cooperators_previous_round / self.game_description.n_players
        if cooperation_fraction >= self.K_cooperate_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_221(BaseStrategy):
    """
    The Adaptive Stock Sentinel strategy for the Common Pool Resource Game.
    It prioritizes the long-term sustainability of the common resource by starting
    cooperatively and dynamically adjusting its actions based on the current stock
    level (resource health) and the observed cooperation levels of all players
    in the previous round (collective behavior). It seeks to guide the group
    towards resource preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        S = state.current_stock
        capacity = self.game_description.capacity
        t = state.round_number
        if t == 0:
            return Action.C
        if t == r - 1:
            return Action.D
        num_cooperators_prev = sum(history.opponent_actions[-1, :]) + int(history.my_actions[-1])
        cooperation_threshold_full = n
        cooperation_threshold_minor_defection = n - 1
        cooperation_threshold_significant_defection = n - math.floor(n / 3)
        stock_threshold_high = capacity * 0.75
        stock_threshold_medium = capacity * 0.5
        stock_threshold_low = capacity * 0.25
        if S >= stock_threshold_high:
            if num_cooperators_prev == cooperation_threshold_full:
                return Action.C
            elif num_cooperators_prev >= cooperation_threshold_minor_defection:
                return Action.C
            else:
                return Action.D
        elif S >= stock_threshold_medium:
            if num_cooperators_prev >= cooperation_threshold_minor_defection:
                return Action.C
            else:
                return Action.D
        elif S >= stock_threshold_low:
            if num_cooperators_prev >= cooperation_threshold_significant_defection:
                return Action.C
            else:
                return Action.D
        elif num_cooperators_prev == cooperation_threshold_full:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_222(BaseStrategy):
    """
    The Adaptive Conservationist strategy aims to promote long-term collective well-being
    by prioritizing the sustainability of the common resource while adapting to the
    behaviors of other players. It starts with cooperation, preserves the resource
    when critically low, reciprocates defection if too many opponents defect, and
    defects in the final round for self-maximization.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = self.capacity / 3.0
        self.defection_tolerance_count = max(1, math.floor(self.n_players / 4.0))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_stock < self.critical_stock_threshold:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        num_opponent_defectors = np.sum(previous_round_opponent_actions == False)
        if num_opponent_defectors > self.defection_tolerance_count:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_223(BaseStrategy):
    """
    The Adaptive Steward strategy for the Common Pool Resource Game.
    It prioritizes collective long-term sustainability. It begins by cooperating,
    rewards continued collective effort, and punishes individual defection to
    prevent free-riding. Crucially, when the resource faces a critical threat
    of collapse (stock <= 25% of capacity), it overrides all other
    considerations to enforce unconditional cooperation, prioritizing the
    survival of the common pool for the benefit of all. In the final round,
    it defects to maximize immediate payoff, as there are no future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_emergency_threshold = self.game_description.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        r_current = state.round_number + 1
        n_rounds = self.game_description.n_rounds
        stock_current = state.current_stock
        if r_current == n_rounds:
            return Action.D
        elif r_current == 1:
            return Action.C
        elif stock_current <= self.S_emergency_threshold:
            return Action.C
        else:
            my_defection_prev_round = int(not history.my_actions[-1])
            opponent_defections_prev_round = np.sum(~history.opponent_actions[-1, :])
            num_defectors_prev_round = my_defection_prev_round + opponent_defections_prev_round
            if num_defectors_prev_round > 0:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_224(BaseStrategy):
    """
    The Adaptive Collective Resource Steward (ACRS) strategy balances collective welfare and
    sustainable resource management with pragmatic robustness. It leads with conditional
    cooperation, forgiving minor transgressions, and actively restores the common pool
    when in danger. It defends against persistent exploitation to prevent being a 'sucker'
    and signals the necessity of collective action.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_recovery_threshold_multiplier = 0.9
        self.stock_danger_threshold_multiplier = 0.5
        self.alpha_trust_decay = 0.8
        self.min_trust_for_cooperation = 0.7
        self.others_cooperation_to_attempt_recovery = 0.75
        self.trust_score = 1.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        num_others_cooperated_prev_round = np.sum(history.opponent_actions[-1, :])
        total_others = self.n_players - 1
        others_cooperation_rate_prev_round = 1.0
        if total_others > 0:
            others_cooperation_rate_prev_round = num_others_cooperated_prev_round / total_others
        self.trust_score = self.alpha_trust_decay * self.trust_score + (1 - self.alpha_trust_decay) * others_cooperation_rate_prev_round
        stock_is_healthy = state.current_stock >= self.capacity * self.stock_recovery_threshold_multiplier
        stock_is_in_danger = state.current_stock < self.capacity * self.stock_danger_threshold_multiplier
        if stock_is_in_danger:
            if self.trust_score >= self.min_trust_for_cooperation or others_cooperation_rate_prev_round >= self.others_cooperation_to_attempt_recovery:
                return Action.C
            else:
                return Action.D
        if stock_is_healthy and self.trust_score >= self.min_trust_for_cooperation:
            return Action.C
        if self.trust_score < self.min_trust_for_cooperation:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_225(BaseStrategy):
    """
    Adaptive Resource Guardian (ARG) strategy for the Common Pool Resource Game.
    This strategy balances collective sustainability with individual robustness by
    employing conditional cooperation, resource recovery prioritization, and
    punishment for defection based on observed opponent behavior and current stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Resource Guardian strategy.

        Args:
            game_description: An object containing game parameters such as
                              number of players, rounds, and capacity.
        """
        self.game_description = game_description
        self.forgiveness_threshold = 0
        self.critical_stock_ratio = 0.5
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: An object containing the current round number and stock level.
            history: An object containing records of past actions and payoffs for
                     this player and opponents. None for the very first round.

        Returns:
            An Action (Action.C for Cooperate, Action.D for Defect).
        """
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        k_previous_round = np.sum(~history.opponent_actions[-1, :])
        is_stock_critical = current_stock < self.capacity * self.critical_stock_ratio
        if is_stock_critical:
            if k_previous_round <= self.forgiveness_threshold:
                return Action.C
            elif k_previous_round < (self.n_players - 1) / 2.0:
                return Action.C
            else:
                return Action.D
        elif k_previous_round <= self.forgiveness_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_226(BaseStrategy):
    """
    Adaptive Stock-Maintainer (ASM) strategy for the Common Pool Resource Game.

    ASM aims for long-term sustainable resource management by initiating cooperation,
    but vigilantly responding to defection from others. It is designed to be "nice"
    but firm, prioritizing the collective good when the resource is threatened,
    while also being rationally self-interested in the absence of future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_FACTOR = 0.25
        self.MIN_COOPERATION_PROPORTION = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        critical_stock_level = self.CRITICAL_STOCK_FACTOR * self.game_description.capacity
        if state.current_stock < critical_stock_level:
            return Action.C
        if state.round_number == 0:
            return Action.C
        num_cooperators_prev_round = np.sum(history.opponent_actions[-1, :])
        cooperation_proportion = num_cooperators_prev_round / self.game_description.n_players
        if cooperation_proportion >= self.MIN_COOPERATION_PROPORTION:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_227(BaseStrategy):
    """
    The Adaptive Stock-Sensitive Collective Strategy (ASCS) prioritizes the long-term health
    of the common resource by generally favoring cooperation. It dynamically adjusts its
    behavior based on the current stock level and the observed cooperation of other players.
    It will punish significant defection and protect its own payoff when the resource is
    critically low and collective effort is lacking, while accounting for end-game rationality.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / 4.0
        self.COOPERATION_THRESHOLD_STOCK = self.capacity / 2.0
        self.HIGH_COOP_RATIO_THRESHOLD = 0.75
        self.BARELY_SUFFICIENT_COOP_RATIO = 0.5
        self.PERFECT_COOP_RATIO = 1.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.total_rounds:
            return Action.D
        my_prev_action_was_D = not history.my_actions[-1]
        k_D_my = 1 if my_prev_action_was_D else 0
        k_D_opponents = np.sum(~history.opponent_actions[-1, :])
        k_D_prev = k_D_my + k_D_opponents
        cooperation_ratio = (self.n_players - k_D_prev) / self.n_players
        if state.current_stock < self.CRITICAL_STOCK_THRESHOLD:
            if cooperation_ratio >= self.BARELY_SUFFICIENT_COOP_RATIO:
                return Action.C
            else:
                return Action.D
        elif state.current_stock >= self.COOPERATION_THRESHOLD_STOCK:
            if cooperation_ratio >= self.HIGH_COOP_RATIO_THRESHOLD:
                return Action.C
            else:
                return Action.D
        elif cooperation_ratio == self.PERFECT_COOP_RATIO:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_228(BaseStrategy):
    """
    The "Adaptive Collective Watchdog" strategy aims to achieve and maintain sustainable resource levels
    through conditional cooperation. It starts by cooperating, monitors the behavior of other players,
    and reacts reciprocally to defection. Its primary goal is to encourage and enforce collective
    cooperation, but it will defect to avoid exploitation, especially when the resource is at risk.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = self.capacity / 2.0
        if self.n_players > 2:
            self.max_tolerated_defectors = 1
        else:
            self.max_tolerated_defectors = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            num_other_players_defected = np.sum(~history.opponent_actions[-1, :])
            if state.current_stock < self.critical_stock_threshold:
                if num_other_players_defected == 0:
                    return Action.C
                else:
                    return Action.D
            elif num_other_players_defected <= self.max_tolerated_defectors:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_229(BaseStrategy):
    """
    The Adaptive Collective Steward (ACS) strategy for the Common Pool Resource Game.

    ACS aims to maintain resource health by promoting cooperation, monitoring
    other players' actions, and adapting based on observed collective behavior
    and the resource stock level. It starts cooperatively, tolerates minor
    defection in larger groups, but retaliates against widespread free-riding
    or when the resource is critically low and others are still defecting.
    It prioritizes collective well-being and resource preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = float(game_description.capacity)
        if self.n_players == 2:
            self.defection_tolerance_threshold = 0
        else:
            self.defection_tolerance_threshold = max(1, math.floor((self.n_players - 1) / 3))
        self.CRITICAL_STOCK_PERCENTAGE = 0.2
        self.critical_stock_level = self.CRITICAL_STOCK_PERCENTAGE * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round_actions_opponents = history.opponent_actions[state.round_number - 1]
        num_defectors_last_round = np.sum(~previous_round_actions_opponents)
        current_stock = state.current_stock
        if current_stock < self.critical_stock_level:
            if num_defectors_last_round == 0:
                return Action.C
            else:
                return Action.D
        elif num_defectors_last_round > self.defection_tolerance_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_230(BaseStrategy):
    """
    Steward of the Commons strategy promotes sustainable resource management and cooperation.
    It begins cooperatively, maintains cooperation under favorable conditions, and retaliates
    against widespread defection. Crucially, it prioritizes resource recovery by unconditionally
    cooperating if the common stock falls to a critically low level, acting as a collective failsafe.
    It adopts a self-interested defection stance in the final round.
    """
    _S_CRITICAL_LOW_PERCENTAGE = 0.6

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters and pre-calculates internal thresholds.

        Args:
            game_description: An object containing game-wide parameters like
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        if self.game_description.n_players == 2:
            self.n_defection_threshold_actual = 1
        else:
            self.n_defection_threshold_actual = 2
        self.s_critical_threshold = self.game_description.capacity * self._S_CRITICAL_LOW_PERCENTAGE

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: An object representing the current state of the game, including
                   the current round number and common stock level.
            history: An object providing historical actions and payoffs of all players
                     in previous rounds. It is None for the very first round (round 0).

        Returns:
            An Action enum value (Action.C for Cooperate, Action.D for Defect).
        """
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        num_defectors_last_round = np.sum(~previous_round_opponent_actions)
        if state.current_stock < self.s_critical_threshold:
            return Action.C
        elif num_defectors_last_round >= self.n_defection_threshold_actual:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_231(BaseStrategy):
    """
    The Adaptive Conservationist strategy aims to promote collective sustainability of the common
    pool resource while protecting itself from excessive exploitation. It relies on observing
    the collective consumption behavior of all players in the previous round and adjusting its
    own actions based on an adaptive threshold tied to the current stock level.

    The strategy initiates cooperation, monitors collective impact, and employs an adaptive
    threshold for collective consumption. If consumption exceeds this threshold, it defects
    to signal over-exploitation; otherwise, it cooperates to maintain stock. In the final round,
    it defects for immediate payoff maximization.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_round_start_stock: float | None = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_round == 0:
            action = Action.C
            self.prev_round_start_stock = state.current_stock
            return action
        elif current_round == total_rounds - 1:
            action = Action.D
            return action
        else:
            prev_round_stock = self.prev_round_start_stock
            if prev_round_stock is None:
                action = Action.D
                self.prev_round_start_stock = state.current_stock
                return action
            if prev_round_stock == 0:
                action = Action.D
                self.prev_round_start_stock = state.current_stock
                return action
            my_prev_action_bool = history.my_actions[current_round - 1]
            opponent_prev_actions_bool = history.opponent_actions[current_round - 1, :]
            num_coop_prev_round = int(my_prev_action_bool) + np.sum(opponent_prev_actions_bool)
            observed_consumption_rate = (2 * n_players - num_coop_prev_round) / (2 * n_players)
            min_tolerance_rate = 0.5
            max_tolerance_rate = 0.6
            cooperation_threshold = min_tolerance_rate + (max_tolerance_rate - min_tolerance_rate) * (state.current_stock / capacity)
            if observed_consumption_rate <= cooperation_threshold:
                action = Action.C
            else:
                action = Action.D
            self.prev_round_start_stock = state.current_stock
            return action

class Strategy_COLLECTIVE_232(BaseStrategy):
    """
    Collective Adaptive Resource Steward (CARS) strategy for the Common Pool Resource Game.
    CARS prioritizes long-term resource sustainability, promoting cooperation through
    responsive mechanisms, rewarding collective effort, and retaliating against excessive
    free-riding, with a strong emphasis on resource conservation when stocks are low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_level = self.capacity * 0.25
        self.moderate_stock_level = self.capacity * 0.5
        self.healthy_stock_level = self.capacity * 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        num_opponent_cooperators_prev_round = np.sum(history.opponent_actions[-1, :])
        num_opponent_defectors_prev_round = self.n_players - 1 - num_opponent_cooperators_prev_round
        if current_round_0_indexed == self.n_rounds - 1:
            if current_stock <= self.capacity / (2 * self.n_players):
                return Action.C
            else:
                return Action.D
        if current_stock <= self.critical_stock_level:
            return Action.C
        elif current_stock >= self.healthy_stock_level:
            if num_opponent_defectors_prev_round > math.floor(self.n_players / 3):
                return Action.D
            else:
                return Action.C
        elif current_stock >= self.moderate_stock_level:
            if self.n_players == 2:
                if num_opponent_defectors_prev_round > 0:
                    return Action.D
                else:
                    return Action.C
            elif num_opponent_defectors_prev_round > 1:
                return Action.D
            else:
                return Action.C
        elif num_opponent_defectors_prev_round > 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_233(BaseStrategy):
    """
    Adaptive Collective Enforcer strategy for the Common Pool Resource Game.
    This strategy prioritizes establishing and maintaining collective cooperation
    to ensure long-term sustainability, while being prepared to defend against exploitation.
    It employs a mix of initial cooperation, conditional punishment, self-preservation,
    and rational endgame play.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD = self.game_description.capacity / 4.0
        self.MODERATE_DEFECTION_THRESHOLD = 1
        self.FORGIVENESS_ROUNDS = 1
        self._num_defections_in_prev_round: int = 0
        self._consecutive_rounds_with_some_defection: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        num_players = self.game_description.n_players
        current_stock = state.current_stock
        if state.round_number > 0:
            my_prev_action = history.my_actions[-1]
            opponent_prev_actions = history.opponent_actions[-1, :]
            all_prev_actions_combined = np.concatenate((np.array([my_prev_action]), opponent_prev_actions))
            temp_defections_count = num_players - np.sum(all_prev_actions_combined)
            self._num_defections_in_prev_round = int(temp_defections_count)
            if self._num_defections_in_prev_round > 0:
                self._consecutive_rounds_with_some_defection += 1
            else:
                self._consecutive_rounds_with_some_defection = 0
        else:
            self._num_defections_in_prev_round = 0
            self._consecutive_rounds_with_some_defection = 0
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == total_rounds:
            return Action.D
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.D
        if self._num_defections_in_prev_round > 0:
            if self._num_defections_in_prev_round > self.MODERATE_DEFECTION_THRESHOLD or self._consecutive_rounds_with_some_defection > self.FORGIVENESS_ROUNDS:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_COLLECTIVE_234(BaseStrategy):
    """
    The Adaptive Collective Steward (ACS) strategy aims to promote collective sustainability by balancing
    cooperation with individual self-preservation. It starts cooperatively, but adapts its behavior
    based on the current stock level of the common resource and the observed cooperation of other players
    in the previous round. It implements conditional cooperation, adaptive punishment, and forgiveness
    to navigate the repeated game, always prioritizing resource sustainability. In the final round,
    it defects to maximize individual payoff as there are no future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_STOCK_EMERGENCY_THRESHOLD = self.capacity / (2.0 * self.n)
        self.STOCK_HIGH_BOUNDARY = 0.8 * self.capacity
        self.STOCK_MODERATE_BOUNDARY = 0.5 * self.capacity
        self.LOW_STOCK_COOPERATION_DEMAND = 0.9
        self.MODERATE_STOCK_COOPERATION_DEMAND = 0.75
        self.HIGH_STOCK_COOPERATION_DEMAND = 0.6
        self.stock_history_at_start_of_round: list[float] = []
        self.total_consumption_in_round: list[float] = []

    def _calculate_cooperation_ratio(self, prev_stock: float, prev_total_consumption: float) -> float:
        """
        Calculates the observed cooperation ratio for the previous round.
        Ratio of 1.0 means all players cooperated (TC = S/2).
        Ratio of 0.0 means all players defected (TC = S).
        """
        if prev_stock <= 1e-09:
            return 0.0
        denominator = prev_stock - prev_stock / 2.0
        if denominator <= 1e-09:
            return 0.0
        numerator = prev_stock - prev_total_consumption
        ratio = numerator / denominator
        return max(0.0, min(1.0, ratio))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_0_indexed_round = state.round_number
        current_1_indexed_round = current_0_indexed_round + 1
        current_stock = float(state.current_stock)
        if current_0_indexed_round == 0:
            self.stock_history_at_start_of_round.append(current_stock)
            return Action.C
        prev_stock_at_start = self.stock_history_at_start_of_round[-1]
        prev_round_my_action_is_cooperate = history.my_actions[-1]
        prev_round_opponent_actions_are_cooperate = history.opponent_actions[-1, :]
        num_cooperators_prev_round = int(prev_round_my_action_is_cooperate) + np.sum(prev_round_opponent_actions_are_cooperate)
        num_defectors_prev_round = self.n - num_cooperators_prev_round
        consumption_per_cooperator = prev_stock_at_start / (2.0 * self.n)
        consumption_per_defector = prev_stock_at_start / self.n
        prev_total_consumption = num_cooperators_prev_round * consumption_per_cooperator + num_defectors_prev_round * consumption_per_defector
        self.total_consumption_in_round.append(prev_total_consumption)
        self.stock_history_at_start_of_round.append(current_stock)
        cooperation_ratio_last_round = self._calculate_cooperation_ratio(prev_stock_at_start, prev_total_consumption)
        if current_1_indexed_round == self.r:
            return Action.D
        if current_stock < self.CRITICAL_STOCK_EMERGENCY_THRESHOLD:
            if cooperation_ratio_last_round >= self.LOW_STOCK_COOPERATION_DEMAND:
                return Action.C
            else:
                return Action.D
        else:
            required_cooperation_threshold: float
            if current_stock >= self.STOCK_HIGH_BOUNDARY:
                required_cooperation_threshold = self.HIGH_STOCK_COOPERATION_DEMAND
            elif current_stock >= self.STOCK_MODERATE_BOUNDARY:
                required_cooperation_threshold = self.MODERATE_STOCK_COOPERATION_DEMAND
            else:
                required_cooperation_threshold = self.LOW_STOCK_COOPERATION_DEMAND
            if cooperation_ratio_last_round >= required_cooperation_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_235(BaseStrategy):
    """
    Adaptive Resource Steward: A strategy for the Common Pool Resource Game that balances
    immediate gains with long-term resource sustainability. It conditionally cooperates,
    monitors opponent behavior, and adjusts its actions based on resource health.
    Prioritizes resource replenishment when stock is low and punishes insufficient cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Resource Steward strategy.

        Args:
            game_description (CommonPoolDescription): An object containing game parameters
                                                     like n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.COOPERATION_LEVEL_THRESHOLD = 0.6
        self.REBUILD_TRIGGER_STOCK_LEVEL = self.game_description.capacity * 0.6
        self.CRITICAL_DEFECTION_THRESHOLD = self.game_description.capacity / self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current player based on
        the current game state and historical actions.

        Args:
            state (CommonPoolState): The current state of the game, including round number
                                     and current stock level.
            history (None | PlayerHistory): An object containing historical actions and payoffs.
                                            None for the very first round (round_number = 0).

        Returns:
            Action: Action.C for Cooperate, Action.D for Defect.
        """
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        num_opponent_cooperators = np.sum(history.opponent_actions[-1, :])
        num_opponents = self.game_description.n_players - 1
        cooperation_ratio = num_opponent_cooperators / num_opponents
        if state.current_stock < self.CRITICAL_DEFECTION_THRESHOLD:
            return Action.D
        elif state.current_stock < self.REBUILD_TRIGGER_STOCK_LEVEL:
            return Action.C
        elif cooperation_ratio >= self.COOPERATION_LEVEL_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_236(BaseStrategy):
    """
    The Adaptive Collective Guardian strategy prioritizes long-term resource sustainability.
    It initiates cooperation, then adapts its behavior based on collective cooperation rates
    from the previous round. It enters a "panic mode" to preserve the resource when stock is low,
    requiring a higher collective commitment to cooperate. In the final round, it defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold_history = 0.75
        self.stock_panic_threshold_factor = 0.3
        self.stock_panic_threshold = self.game_description.capacity * self.stock_panic_threshold_factor

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        num_cooperators_last_round = sum(history.opponent_actions[-1, :]) + int(history.my_actions[-1])
        recent_cooperation_rate = num_cooperators_last_round / self.game_description.n_players
        if state.current_stock < self.stock_panic_threshold:
            if recent_cooperation_rate >= 0.75:
                return Action.C
            else:
                return Action.D
        elif recent_cooperation_rate >= self.cooperation_threshold_history:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_237(BaseStrategy):
    """
    The "Adaptive Resource Guardian" (ARG) is a collective strategy designed
    to promote sustainability of the common pool resource while remaining
    robust and adaptive to various opponent behaviors in a tournament setting.
    It prioritizes the health of the resource, initiates cooperation, but also
    defends against exploitation by punishing widespread defection.

    This strategy balances collective resource sustainability with individual
    robustness against exploitation. It adapts its response based on the
    dynamic state of the common pool and the observed cooperation levels of
    other players, aiming to elicit and maintain cooperation where possible,
    but prepared to defect when necessary to avoid being a persistent martyr.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_critical_threshold = self.capacity / 2
        self.stock_safe_threshold = self.capacity * 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.r:
            return Action.D
        num_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
        num_defectors_last_round = self.n - 1 - num_cooperators_last_round
        if current_stock < self.stock_critical_threshold:
            return Action.C
        elif current_stock >= self.stock_safe_threshold:
            if num_defectors_last_round <= 1:
                return Action.C
            else:
                return Action.D
        elif num_defectors_last_round <= (self.n - 1) / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_238(BaseStrategy):
    """
    Adaptive Collective Sustenance (ACS) strategy.

    This strategy aims to maximize a player's total payoff by prioritizing the
    long-term health of the common resource while adaptively responding to the
    actions of other players. It encourages cooperation through conditional
    responses and ensures resource preservation in critical situations.

    Core principles:
    1. Prioritize Resource Health: If stock is critically low, always cooperate.
    2. Conditional Cooperation: Start and continue cooperating if others do.
    3. Deter Defection: Respond to defection with defection when stock is healthy.
    4. Forgiveness for Sustainability: If stock is struggling, cooperate even
       if others defect, to aid recovery.
    5. End-Game Rationality: Defect in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_STOCK_LOW = 0.1 * self.capacity
        self.SUSTAINABLE_COOPERATION_THRESHOLD_STOCK = 0.5 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock < self.CRITICAL_STOCK_LOW:
            return Action.C
        num_defectors_last_round = np.sum(history.opponent_actions[-1, :] == False)
        if num_defectors_last_round == 0:
            return Action.C
        elif current_stock > self.SUSTAINABLE_COOPERATION_THRESHOLD_STOCK:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_239(BaseStrategy):
    """
    The Adaptive Stock Steward (ASR) strategy balances initial cooperation,
    conditional reciprocity, resource protection, and endgame rationality
    in the Common Pool Resource Game. It uses an adaptive TrustLevel
    that adjusts based on observed collective cooperation in previous rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_trust_level = 0.75
        self.adaptation_rate = 0.1
        self.min_trust_level = 0.0
        self.max_trust_level = 1.0
        self.dangerous_stock_threshold_factor = 0.2
        self.trust_level_i = self.initial_trust_level

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round_1_indexed == total_rounds:
            return Action.D
        if state.round_number == 0:
            my_action_for_this_round = Action.C
        else:
            num_cooperated_prev_round = int(history.my_actions[-1]) + np.sum(history.opponent_actions[-1, :])
            avg_coop_prev_round = num_cooperated_prev_round / self.game_description.n_players
            effective_trust_level_for_decision = self.trust_level_i
            if state.current_stock < self.game_description.capacity * self.dangerous_stock_threshold_factor:
                effective_trust_level_for_decision = 1.0
            if avg_coop_prev_round >= effective_trust_level_for_decision:
                my_action_for_this_round = Action.C
            else:
                my_action_for_this_round = Action.D
            if avg_coop_prev_round >= self.trust_level_i:
                self.trust_level_i = max(self.min_trust_level, self.trust_level_i - self.adaptation_rate)
            else:
                self.trust_level_i = min(self.max_trust_level, self.trust_level_i + self.adaptation_rate)
        return my_action_for_this_round

class Strategy_COLLECTIVE_240(BaseStrategy):
    """
    The "Adaptive Reciprocal Conservationist" strategy prioritizes the health of the common pool stock.
    It attempts to cooperate as a default, especially when the stock is low, to ensure sustainability.
    However, it is not a naive cooperator; it will retaliate against significant collective defection
    to avoid being exploited, and it acts in its immediate self-interest in the final round when
    future consequences are absent. It applies a "generous tit-for-tat" approach for larger groups,
    tolerating minor deviations to prevent a spiral of defection, but is stricter in a 2-player setting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.LST = self.capacity / 2.0
        if self.n_players == 2:
            self.PUNISH_THRESHOLD_COUNT = 1
        else:
            self.PUNISH_THRESHOLD_COUNT = math.floor(self.n_players / 2.0) + 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.n_rounds
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        num_opponent_defectors_last_round = np.sum(history.opponent_actions[-1, :] == False)
        my_defection_last_round = 1 if history.my_actions[-1] == False else 0
        total_defectors_last_round = num_opponent_defectors_last_round + my_defection_last_round
        if total_defectors_last_round >= self.PUNISH_THRESHOLD_COUNT:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_241(BaseStrategy):
    """
    The Adaptive Collective Harvester (ACH) strategy for the Common Pool Resource Game.
    This strategy balances resource sustainability with individual payoff protection,
    adapting to current stock levels and observed collective behavior of other players.
    It aims to incentivize cooperation by rewarding it and punishing persistent defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.hst_ratio = 0.8
        self.wst_ratio = 0.4
        self.defection_tolerance_healthy = 0.2
        self.defection_tolerance_warning = 0.25
        self.history_window = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        healthy_stock_threshold = capacity * self.hst_ratio
        warning_stock_threshold = capacity * self.wst_ratio
        last_round_my_action = history.my_actions[current_round_0_indexed - 1]
        last_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        k_prev = (1 if last_round_my_action == False else 0) + np.sum(last_round_opponent_actions == False)
        defection_ratio_prev = k_prev / n_players
        recent_defection_ratios = []
        start_idx_for_history = max(0, current_round_0_indexed - self.history_window)
        for r_idx in range(start_idx_for_history, current_round_0_indexed):
            round_my_action = history.my_actions[r_idx]
            round_opponent_actions = history.opponent_actions[r_idx, :]
            k_hist = (1 if round_my_action == False else 0) + np.sum(round_opponent_actions == False)
            recent_defection_ratios.append(k_hist / n_players)
        if not recent_defection_ratios:
            recent_defection_count_avg = defection_ratio_prev
        else:
            recent_defection_count_avg = sum(recent_defection_ratios) / len(recent_defection_ratios)
        if current_stock >= healthy_stock_threshold:
            if defection_ratio_prev == 0:
                return Action.C
            elif defection_ratio_prev <= self.defection_tolerance_healthy:
                return Action.C
            else:
                return Action.D
        elif current_stock >= warning_stock_threshold:
            if defection_ratio_prev == 0:
                return Action.C
            elif defection_ratio_prev <= self.defection_tolerance_warning:
                return Action.C
            else:
                return Action.D
        elif defection_ratio_prev == 0 and recent_defection_count_avg == 0:
            return Action.C
        elif defection_ratio_prev <= 1 / n_players and recent_defection_count_avg < 0.1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_242(BaseStrategy):
    """
    The Adaptive Resource Steward (ARS) strategy for the Common Pool Resource Game.
    It balances long-term resource health with individual rationality, adapting its
    behavior based on the current stock level and opponent actions. It prioritizes
    cooperation when the resource is critical (unless all others defect), and
    enforces strict Tit-for-Tat behavior when the resource is healthy.
    It defects in the final round to maximize immediate gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_critical_threshold = self.game_description.capacity / 4.0
        self.defection_forgiveness_level = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.game_description.n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        prev_round_opponent_actions = history.opponent_actions[state.round_number - 1]
        num_opponents_defected_prev_round = np.sum(prev_round_opponent_actions == Action.D)
        if state.current_stock < self.stock_critical_threshold:
            if num_opponents_defected_prev_round == self.game_description.n_players - 1:
                return Action.D
            else:
                return Action.C
        elif num_opponents_defected_prev_round > self.defection_forgiveness_level:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_243(BaseStrategy):
    """
    Adaptive Sustainability & Retaliation (ASR) strategy for the Common Pool Resource Game.
    This strategy promotes collective sustainability by cooperating by default,
    punishes any defection from the group, and conserves the resource when it's
    in a critical state, but only if there's collective effort.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_CRITICAL = self.capacity / 2.0
        self.C_THRESHOLD = 1.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        my_prev_action_is_C = history.my_actions[-1]
        opponent_prev_cooperators = np.sum(history.opponent_actions[-1, :])
        k_t_minus_1 = int(my_prev_action_is_C) + opponent_prev_cooperators
        C_rate = k_t_minus_1 / self.n_players
        if current_stock < self.S_CRITICAL:
            if C_rate == self.C_THRESHOLD:
                return Action.C
            else:
                return Action.D
        elif C_rate == self.C_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_244(BaseStrategy):
    """
    Adaptive Conservationist (AC) strategy for the Common Pool Resource Game.

    This strategy aims to promote collective welfare by prioritizing resource
    sustainability. It starts with initial trust, conditionally cooperates,
    implements graduated punishment for minor defections, and strongly prioritizes
    resource preservation in critical situations. It also incorporates backward
    induction for the final round to maximize individual payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.my_num_rounds_minor_defection: int = 0
        self.MINOR_DEFECTION_TOLERANCE_ROUNDS: int = 2
        self.CRITICAL_STOCK_THRESHOLD_RATIO: float = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            self.my_num_rounds_minor_defection = 0
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[current_round - 1, :]
        num_opponents_who_cooperated = np.sum(previous_round_opponent_actions)
        num_opponents_who_defected = self.n_players - 1 - num_opponents_who_cooperated
        is_stock_critical = current_stock < self.CRITICAL_STOCK_THRESHOLD_RATIO * self.capacity
        if is_stock_critical and num_opponents_who_defected > 0:
            self.my_num_rounds_minor_defection = 0
            return Action.C
        if num_opponents_who_defected == 0:
            self.my_num_rounds_minor_defection = 0
            return Action.C
        if num_opponents_who_defected > 0 and num_opponents_who_defected < (self.n_players - 1) / 2.0:
            self.my_num_rounds_minor_defection += 1
            if self.my_num_rounds_minor_defection >= self.MINOR_DEFECTION_TOLERANCE_ROUNDS:
                self.my_num_rounds_minor_defection = 0
                return Action.D
            else:
                return Action.C
        else:
            self.my_num_rounds_minor_defection = 0
            return Action.D

class Strategy_COLLECTIVE_245(BaseStrategy):
    """
    The Adaptive Collective Sustainer (ACS) strategy for the Common Pool Resource game.
    It prioritizes resource sustainability, adapting its tolerance for opponent defection
    based on the common stock level. It starts cooperatively, becomes stricter as
    the resource depletes, and defects in the final round to maximize individual payoff
    when future consequences are nil.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        round_number = state.round_number
        STOCK_HEALTHY_THRESHOLD_RATIO = 0.75
        STOCK_LOW_THRESHOLD_RATIO = 0.5
        STOCK_CRITICAL_THRESHOLD_RATIO = 0.2
        FORGIVENESS_LEVEL_HEALTHY_STOCK = 0.5
        FORGIVENESS_LEVEL_LOW_STOCK = 0.25
        if round_number == 0:
            return Action.C
        if round_number == n_rounds - 1:
            return Action.D
        num_defectors_last_round = np.sum(~history.opponent_actions[-1, :])
        max_tolerable_defectors_this_round = 0
        n_players_minus_one = n_players - 1
        if current_stock < capacity * STOCK_CRITICAL_THRESHOLD_RATIO:
            max_tolerable_defectors_this_round = 0
        elif current_stock < capacity * STOCK_LOW_THRESHOLD_RATIO:
            tolerable_ratio = FORGIVENESS_LEVEL_LOW_STOCK
            max_tolerable_defectors_this_round = math.floor(n_players_minus_one * tolerable_ratio)
            max_tolerable_defectors_this_round = max(0, max_tolerable_defectors_this_round)
        else:
            tolerable_ratio = FORGIVENESS_LEVEL_HEALTHY_STOCK
            max_tolerable_defectors_this_round = math.floor(n_players_minus_one * tolerable_ratio)
            max_tolerable_defectors_this_round = max(0, max_tolerable_defectors_this_round)
        if num_defectors_last_round <= max_tolerable_defectors_this_round:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_246(BaseStrategy):
    """
    The "Adaptive Sentinel" strategy for the Common Pool Resource game.
    Prioritizes the long-term health of the shared resource while being adaptive
    to opponent behaviors and the current stock level. It promotes cooperation
    through conditional reciprocity and strong conservation ethics, especially
    when the resource is stressed.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = game_description.n_players
        capacity = game_description.capacity
        self.S_low_threshold: float = capacity / (2 * n)
        self.S_critical_threshold: float = capacity / 2
        self.cooperation_defection_tolerance_proportion: float = 0.2
        self.punishment_duration: int = 3
        self.punishment_countdown: int = 0
        self.historical_defection_count_others: int = 0
        self.historical_total_actions_others: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        num_others = n_players - 1
        if current_round_0_indexed == 0:
            return Action.C
        others_actions_last_round_bool = history.opponent_actions[-1, :]
        num_defectors_last_round = np.sum(~others_actions_last_round_bool)
        self.historical_defection_count_others += num_defectors_last_round
        self.historical_total_actions_others += num_others
        if current_round_1_indexed == total_rounds:
            return Action.D
        if current_round_1_indexed == total_rounds - 1:
            if self.historical_total_actions_others > 0:
                avg_defection_rate_others = self.historical_defection_count_others / self.historical_total_actions_others
            else:
                avg_defection_rate_others = 0.0
            if current_stock <= self.S_low_threshold or avg_defection_rate_others > 0.6:
                return Action.D
            else:
                return Action.C
        if current_stock <= self.S_low_threshold:
            self.punishment_countdown = 0
            return Action.C
        elif current_stock <= self.S_critical_threshold:
            self.punishment_countdown = 0
            return Action.C
        if self.punishment_countdown > 0:
            self.punishment_countdown -= 1
            return Action.D
        else:
            defection_proportion_last_round = num_defectors_last_round / num_others
            if num_defectors_last_round == 0:
                return Action.C
            elif defection_proportion_last_round <= self.cooperation_defection_tolerance_proportion:
                return Action.C
            else:
                self.punishment_countdown = self.punishment_duration - 1
                return Action.D

class Strategy_COLLECTIVE_247(BaseStrategy):
    """
    Adaptive Collective Sustainer (ACS) strategy for the Common Pool Resource Game.
    This strategy prioritizes resource sustainability by initially cooperating and
    maintaining a critical stock recovery mechanism. It employs forgiving but firm
    reciprocity, allowing for a "grace round" for minor, isolated defections, but
    responding firmly to persistent minor defection or immediate widespread defection.
    It includes self-protection mechanisms and a rational end-game defecting behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.rounds_since_collective_cooperation = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.r:
            return Action.D
        prev_round_total_cooperators = np.sum(history.opponent_actions[-1, :]) + int(history.my_actions[-1])
        D_prev = self.n - prev_round_total_cooperators
        if D_prev == 0:
            self.rounds_since_collective_cooperation = 0
        else:
            self.rounds_since_collective_cooperation += 1
        if state.current_stock < self.capacity / 4:
            return Action.C
        elif D_prev == 0:
            return Action.C
        elif D_prev >= self.n / 2:
            return Action.D
        elif self.rounds_since_collective_cooperation >= 2:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_248(BaseStrategy):
    """
    The Adaptive Conservationist strategy aims to promote collective sustainability
    of the common resource while remaining robust and adaptive in a tournament setting.
    It balances immediate incentives to defect with long-term collective benefit,
    prioritizing resource health, especially when under threat. It initiates
    cooperation, adapts to observed opponent behavior, and defects in the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        endgame_rounds_count = max(1, min(3, math.floor(self.n_rounds / 5.0)))
        endgame_threshold_round_1_indexed = self.n_rounds - endgame_rounds_count + 1
        if current_round_1_indexed >= endgame_threshold_round_1_indexed:
            return Action.D
        if current_stock < self.capacity / 4.0:
            return Action.C
        num_other_players = self.n_players - 1
        lookback_rounds_count = min(current_round_0_indexed, 3)
        if lookback_rounds_count == 0:
            effective_cooperation_rate = 0.5
        else:
            recent_opponent_actions = history.opponent_actions[-lookback_rounds_count:, :]
            player_j_coop_counts = np.sum(recent_opponent_actions, axis=0)
            total_cooperation_score = np.sum(player_j_coop_counts / lookback_rounds_count)
            effective_cooperation_rate = total_cooperation_score / num_other_players
        stock_impact = (1.0 - current_stock / self.capacity) * 0.3
        round_impact = current_round_1_indexed / self.n_rounds * 0.2
        DTT = 0.5 + stock_impact + round_impact
        DTT = min(1.0, max(0.0, DTT))
        if effective_cooperation_rate >= DTT:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_249(BaseStrategy):
    """
    Adaptive Stock-Aware Reciprocity (ASAR) strategy for the Common Pool Resource Game.

    This strategy aims for sustainable resource management by adapting its behavior
    based on the common pool stock level and the recent actions of other players.
    It starts cooperatively, prioritizes resource recovery when stock is low,
    forgives minor defections to maintain cooperation, and punishes significant
    defection to prevent exploitation. In the final round, it defects for individual
    payoff maximization.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = max(2 * self.n, self.capacity / 4.0)
        self.tolerance_threshold_D = max(1, math.floor(self.n / 4.0))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number + 1
        stock_level = state.current_stock
        if current_round == self.r:
            return Action.D
        elif current_round == 1:
            return Action.C
        num_opponent_cooperators_last_round = sum(history.opponent_actions[-1, :])
        num_defectors_last_round = self.n - 1 - num_opponent_cooperators_last_round
        if stock_level <= self.critical_stock_threshold:
            if num_defectors_last_round >= (self.n - 1) / 2.0:
                return Action.D
            else:
                return Action.C
        elif num_defectors_last_round == 0:
            return Action.C
        elif num_defectors_last_round <= self.tolerance_threshold_D:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_250(BaseStrategy):
    """
    The Adaptive Collective Steward (ACS) strategy for the Common Pool Resource Game.
    This strategy is designed to balance the sustainability of the shared resource
    with the need to protect against exploitation, adapting its behavior based
    on the current resource state and observed opponent actions.

    It prioritizes resource survival, encourages mutual cooperation, deters
    free-riding with adaptive punishment, and allows for forgiveness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_critical_threshold = self.capacity / 4.0
        self.S_low_threshold = self.capacity / 2.0
        self.consecutive_defections_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number_1_indexed = state.round_number + 1
        n_cooperators_prev = 0
        n_defectors_prev = 0
        if state.round_number > 0:
            n_opponent_cooperators_prev = sum(history.opponent_actions[-1, :])
            my_prev_action_was_cooperate = history.my_actions[-1]
            n_cooperators_prev = n_opponent_cooperators_prev + int(my_prev_action_was_cooperate)
            n_defectors_prev = self.n_players - n_cooperators_prev
            if n_defectors_prev > 0:
                self.consecutive_defections_count += 1
            else:
                self.consecutive_defections_count = 0
        else:
            self.consecutive_defections_count = 0
        if current_round_number_1_indexed == self.n_rounds:
            return Action.D
        if current_round_number_1_indexed == 1:
            return Action.C
        if state.current_stock < self.S_critical_threshold:
            return Action.C
        effective_punishment_trigger = 0
        if state.current_stock < self.S_low_threshold:
            effective_punishment_trigger = 1
        else:
            effective_punishment_trigger = 2
        if n_defectors_prev == 0:
            return Action.C
        elif self.consecutive_defections_count >= effective_punishment_trigger:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_251(BaseStrategy):
    """
    Adaptive Collective Conservationist: Prioritizes long-term resource sustainability,
    adapts to opponent behavior, punishes free-riders, and ensures self-preservation.
    It begins with cooperation, maintains vigilance over the resource, enforces reciprocity,
    allows for re-cooperation after minor deviations, and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        if self.n == 2:
            self.defection_tolerance_threshold = 0
        else:
            self.defection_tolerance_threshold = 1
        self.low_stock_threshold = self.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == 0:
            return Action.C
        if current_round_number == self.r - 1:
            return Action.D
        num_cooperators_prev_round = np.sum(history.opponent_actions[current_round_number - 1, :])
        num_defectors_prev_round = self.n - num_cooperators_prev_round
        if current_stock < self.low_stock_threshold:
            if num_defectors_prev_round <= self.defection_tolerance_threshold:
                return Action.C
            else:
                return Action.D
        elif num_defectors_prev_round > self.defection_tolerance_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_252(BaseStrategy):
    """
    Adaptive Sustainability Reciprocity (ASR) Strategy.

    This strategy aims to foster and maintain a cooperative environment that ensures the
    long-term health of the common resource, maximizing cumulative payoffs. It adapts
    to observed collective behavior, cooperating when the resource is sustainably managed
    or showing signs of recovery from critical levels, and defecting to punish exploitation
    or protect immediate interests during the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.r_endgame = 2
        self.cooperation_tolerance_factor = 0.05
        self.critical_stock_threshold_ratio = 0.2
        self.history_of_stocks: list[float] = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.history_of_stocks.append(state.current_stock)
        round_t = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if round_t == 1:
            return Action.C
        if round_t >= total_rounds - self.r_endgame + 1:
            return Action.D
        previous_stock = self.history_of_stocks[state.round_number - 1]
        s_remaining_if_all_C_prev = previous_stock / 2.0
        growth_if_all_C_prev = 2 * s_remaining_if_all_C_prev * (1 - s_remaining_if_all_C_prev / capacity) if capacity > 0 else 0
        s_next_if_all_C_prev = s_remaining_if_all_C_prev + growth_if_all_C_prev
        s_next_if_all_C_prev = min(s_next_if_all_C_prev, capacity)
        is_sustainably_managed = current_stock >= s_next_if_all_C_prev * (1 - self.cooperation_tolerance_factor)
        is_actually_growing = current_stock > previous_stock
        is_critically_low = current_stock / capacity <= self.critical_stock_threshold_ratio if capacity > 0 else True
        if is_sustainably_managed:
            return Action.C
        elif is_critically_low and is_actually_growing:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_253(BaseStrategy):
    """
    The Adaptive Collective Steward (ACS) strategy for the Common Pool Resource Game.
    It prioritizes long-term stock sustainability by starting cooperatively,
    adapting its defection tolerance based on stock health, and reacting to
    opponent defection with punishment while allowing for forgiveness.
    It maximizes individual payoff in the final round.
    """
    DEFECTION_MEMORY_WINDOW: int
    FORGIVENESS_ROUNDS: int
    STOCK_HIGH_THRESHOLD: float
    STOCK_MEDIUM_THRESHOLD: float
    STOCK_CRITICAL_THRESHOLD: float
    STOCK_DANGER_THRESHOLD: float
    my_current_stance: str
    rounds_of_good_behavior_observed: int

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.DEFECTION_MEMORY_WINDOW = 3
        self.FORGIVENESS_ROUNDS = 2
        self.STOCK_HIGH_THRESHOLD = 0.9
        self.STOCK_MEDIUM_THRESHOLD = 0.6
        self.STOCK_CRITICAL_THRESHOLD = 0.25
        self.STOCK_DANGER_THRESHOLD = 0.1
        self.my_current_stance = 'COOPERATIVE'
        self.rounds_of_good_behavior_observed = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_idx = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        num_players = self.game_description.n_players
        if current_round_0_idx == total_rounds - 1:
            return Action.D
        if current_round_0_idx == 0:
            self.my_current_stance = 'COOPERATIVE'
            self.rounds_of_good_behavior_observed = 0
            return Action.C
        total_opponent_defections_in_recent_history = 0
        num_rounds_evaluated = 0
        start_history_check_round_idx = max(0, current_round_0_idx - self.DEFECTION_MEMORY_WINDOW)
        end_history_check_round_idx = current_round_0_idx - 1
        for r_hist_idx in range(start_history_check_round_idx, end_history_check_round_idx + 1):
            num_rounds_evaluated += 1
            total_opponent_defections_in_recent_history += np.sum(~history.opponent_actions[r_hist_idx])
        denominator = num_players * num_rounds_evaluated
        if denominator > 0:
            avg_defections_per_opponent_per_round = total_opponent_defections_in_recent_history / denominator
        else:
            avg_defections_per_opponent_per_round = 0.0
        stock_percentage = min(1.0, current_stock / capacity)
        defection_tolerance_rate = 0.05
        if stock_percentage >= self.STOCK_HIGH_THRESHOLD:
            defection_tolerance_rate = 0.25
        elif stock_percentage >= self.STOCK_MEDIUM_THRESHOLD:
            defection_tolerance_rate = 0.1
        if stock_percentage <= self.STOCK_CRITICAL_THRESHOLD:
            if avg_defections_per_opponent_per_round >= 0.5 or stock_percentage <= self.STOCK_DANGER_THRESHOLD:
                self.my_current_stance = 'PUNITIVE'
                self.rounds_of_good_behavior_observed = 0
                return Action.D
            else:
                self.my_current_stance = 'COOPERATIVE'
                self.rounds_of_good_behavior_observed = 0
                return Action.C
        if self.my_current_stance == 'COOPERATIVE':
            if avg_defections_per_opponent_per_round > defection_tolerance_rate:
                self.my_current_stance = 'PUNITIVE'
                self.rounds_of_good_behavior_observed = 0
                return Action.D
            else:
                self.rounds_of_good_behavior_observed += 1
                return Action.C
        elif self.my_current_stance == 'PUNITIVE':
            if avg_defections_per_opponent_per_round == 0:
                self.rounds_of_good_behavior_observed += 1
                if self.rounds_of_good_behavior_observed >= self.FORGIVENESS_ROUNDS:
                    self.my_current_stance = 'COOPERATIVE'
                    self.rounds_of_good_behavior_observed = 0
                    return Action.C
                else:
                    return Action.D
            else:
                self.rounds_of_good_behavior_observed = 0
                return Action.D

class Strategy_COLLECTIVE_254(BaseStrategy):
    """
    Adaptive Commons Steward strategy aims to maximize the collective payoff by sustaining the common stock
    at its capacity, promoting cooperation, and punishing defection. It is adaptive based on the observed
    collective behavior of other players and the current state of the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_recovery_threshold = self.capacity / 2.0
        self.stock_critical_threshold = self.capacity / 4.0
        self.perfect_cooperation_threshold = self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number + 1
        current_stock = state.current_stock
        if current_round_t == 1:
            return Action.C
        if current_round_t == self.n_rounds:
            return Action.D
        cooperators_prev_round = np.sum(history.opponent_actions[state.round_number - 1, :]) + int(history.my_actions[state.round_number - 1])
        if current_stock < self.stock_critical_threshold:
            return Action.C
        elif cooperators_prev_round == self.perfect_cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_255(BaseStrategy):
    """
    The Adaptive Sustainability Enforcer (ASE) strategy balances sustainable resource management
    with self-protection. It cooperates initially to foster sustainability, enforces
    unconditional cooperation if the resource stock falls below a critical threshold (capacity/2),
    and defects in the last round. In other rounds, it adapts its behavior based on a
    'cooperation_tolerance_ratio' derived from the number of players, retaliating against
    sufficiently widespread defection while tolerating minor deviations.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_critical_threshold = self.capacity / 2.0
        if self.n_players == 2:
            self.cooperation_tolerance_ratio = 1.0
        else:
            self.cooperation_tolerance_ratio = (self.n_players - 2) / (self.n_players - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == 0:
            return Action.C
        if current_round_number == self.n_rounds - 1:
            return Action.D
        if current_stock < self.S_critical_threshold:
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        other_cooperators_count = np.sum(previous_round_opponent_actions)
        current_cooperation_ratio = other_cooperators_count / (self.n_players - 1)
        if current_cooperation_ratio >= self.cooperation_tolerance_ratio:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_256(BaseStrategy):
    """
    The Adaptive Collective Steward strategy aims to foster and maintain collective cooperation to preserve
    the common pool resource, while also being robust and adaptive to varying levels of defection from
    other players. It prioritizes the long-term health of the resource by adjusting its behavior based on
    the current stock level and the observed cooperation in the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_critical_low = 0.25 * self.capacity
        self.S_forgiveness_threshold = 0.75 * self.capacity
        self.C_threshold_lenient = (self.n_players - 1) / self.n_players
        self.C_threshold_strict = 1.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        c_count = history.my_actions[-1].item() + np.sum(history.opponent_actions[-1, :]).item()
        cooperation_rate = c_count / self.n_players
        if current_stock >= self.S_forgiveness_threshold:
            if cooperation_rate >= self.C_threshold_lenient:
                return Action.C
            else:
                return Action.D
        elif current_stock >= self.S_critical_low:
            if cooperation_rate == self.C_threshold_strict:
                return Action.C
            else:
                return Action.D
        elif cooperation_rate == self.C_threshold_strict:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_257(BaseStrategy):
    """
    Adaptive Equity Enforcer v3.0: This strategy promotes collective sustainability
    by starting cooperatively, prioritizing resource recovery when stock is low,
    and adaptively punishing or rewarding collective behavior based on the resource's health.
    It includes self-correction and adjusts for endgame dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = self.game_description.n_players
        self.r = self.game_description.n_rounds
        self.capacity = self.game_description.capacity
        self.Punish_Threshold_Normal = math.ceil(self.n / 2)
        self.Punish_Threshold_Crisis = max(1, math.ceil(self.n / 4))
        self.Stock_Recovery_Threshold = self.capacity * 0.75
        self.Stock_Critical_Threshold = self.capacity * 0.5
        self.Stock_Dire_Threshold = self.capacity * 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        round_number = state.round_number
        num_defectors_prev_round = int(not history.my_actions[-1])
        num_defectors_prev_round += np.sum(~history.opponent_actions[-1, :])
        my_prev_action_was_D = not history.my_actions[-1]
        if round_number == self.r - 1:
            if current_stock <= self.Stock_Dire_Threshold:
                return Action.D
            elif num_defectors_prev_round < self.Punish_Threshold_Normal:
                return Action.C
            else:
                return Action.D
        elif current_stock <= self.Stock_Critical_Threshold:
            if num_defectors_prev_round < self.Punish_Threshold_Crisis:
                return Action.C
            else:
                return Action.D
        elif current_stock < self.Stock_Recovery_Threshold:
            if my_prev_action_was_D and num_defectors_prev_round == 1:
                return Action.C
            elif num_defectors_prev_round < self.Punish_Threshold_Normal:
                return Action.C
            else:
                return Action.D
        elif num_defectors_prev_round == 0:
            return Action.C
        elif num_defectors_prev_round < self.Punish_Threshold_Normal:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_258(BaseStrategy):
    """
    The Adaptive Collective Steward (ACS) strategy for the Common Pool Resource Game.
    It initiates cooperation, monitors opponents, and adjusts behavior based on defection levels
    and the current stock health. It aims to foster sustainability while deterring exploitation,
    and plays rationally in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        if self.n_players <= 2:
            self.forgiveness_count = 0
        else:
            self.forgiveness_count = 1
        self.critical_stock_threshold = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        num_opponent_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
        num_other_defectors_last_round = self.n_players - 1 - num_opponent_cooperators_last_round
        if current_stock < self.critical_stock_threshold:
            if num_other_defectors_last_round <= self.forgiveness_count:
                return Action.C
            else:
                return Action.D
        elif num_other_defectors_last_round <= self.forgiveness_count:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_259(BaseStrategy):
    """
    The Adaptive Collective Safeguard strategy aims to foster and maintain a cooperative environment for sustainable 
    resource management. It starts with an open hand, offering cooperation, but it is not naive. It continuously 
    monitors the collective behavior of other players and the state of the common stock. If cooperation from others 
    is insufficient or if the resource becomes critically low, it adapts by becoming less cooperative to prevent 
    exploitation and signal the necessity of collective effort. The strategy is designed to be "collective" in its 
    aspiration for a sustained resource, but "safeguarding" in its reaction to defection or endangerment of the stock.
    """
    MIN_COOPERATION_DEMAND = 0.6
    MAX_COOPERATION_DEMAND = 0.9

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds_0_indexed = self.game_description.n_rounds - 1
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == total_rounds_0_indexed:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        num_cooperators_others = np.sum(previous_round_opponent_actions)
        num_other_players = self.game_description.n_players - 1
        observed_cooperation_rate_others = num_cooperators_others / num_other_players
        stock_ratio = state.current_stock / self.game_description.capacity
        dynamic_cooperation_threshold = self.MIN_COOPERATION_DEMAND + (1 - stock_ratio) * (self.MAX_COOPERATION_DEMAND - self.MIN_COOPERATION_DEMAND)
        dynamic_cooperation_threshold = max(0.0, min(1.0, dynamic_cooperation_threshold))
        if observed_cooperation_rate_others >= dynamic_cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_260(BaseStrategy):
    """
    The Adaptive Collective Guardian strategy aims to promote long-term sustainability
    and cooperation in the Common Pool Resource Game. It combines elements of
    reciprocity (Tit-for-Tat), state-dependent adaptation, and critical thresholds
    to manage the common resource effectively.

    Decision Logic:
    1.  First Round: Always Cooperate to signal a willingness to collaborate.
    2.  Emergency: If stock is critically low (below S_emergency_low), always Cooperate
        to prioritize resource survival, overriding other considerations.
    3.  End Game: In the final round, always Defect to maximize immediate payoff,
        as there are no future consequences.
    4.  Adaptive Reciprocity:
        a.  Recovery Zone (stock between S_emergency_low and S_abundance_start):
            Forgives a single defector from the previous round (Cooperate if <= 1 defector),
            but punishes multiple defectors (Defect if > 1 defector) to encourage rebuilding.
        b.  Abundance Zone (stock at or above S_abundance_start):
            Applies a strict Tit-for-Tat (Cooperate if 0 defectors, Defect if > 0 defectors)
            to strictly enforce cooperation and maintain the healthy stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_emergency_low = self.capacity / 4
        self.S_abundance_start = self.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_stock < self.S_emergency_low:
            return Action.C
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        k_prev = sum(~history.opponent_actions[-1, :])
        if self.S_emergency_low <= current_stock < self.S_abundance_start:
            if k_prev <= 1:
                return Action.C
            else:
                return Action.D
        elif k_prev == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_261(BaseStrategy):
    """
    Stock-Aware Conditional Forgiver (SACF) strategy for the Common Pool Resource Game.

    This strategy aims for resource sustainability through conditional cooperation,
    defending against exploitation by punishing significant defection, and offering
    limited forgiveness to prevent perpetual conflict. It adapts its behavior based
    on the current stock level and the actions of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_RATIO: float = 0.1
        self.FORGIVENESS_STRIKES_LIMIT: int = 1
        self.my_forgiveness_strikes_remaining: int = self.FORGIVENESS_STRIKES_LIMIT

    def _get_tolerance_defection_count_for_N(self, n_players: int) -> int:
        """
        Helper function to determine how many defectors are "tolerated" before
        immediate punishment, adapting based on the total number of players.
        """
        if n_players == 2:
            return 0
        else:
            return 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            self.my_forgiveness_strikes_remaining = self.FORGIVENESS_STRIKES_LIMIT
            return Action.C
        if round_number == n_rounds - 1:
            return Action.D
        previous_round_actions = history.opponent_actions[round_number - 1, :]
        k_D_t_minus_1 = (previous_round_actions == False).sum()
        if current_stock < self.CRITICAL_STOCK_RATIO * capacity:
            self.my_forgiveness_strikes_remaining = self.FORGIVENESS_STRIKES_LIMIT
            return Action.C
        if k_D_t_minus_1 == 0:
            self.my_forgiveness_strikes_remaining = self.FORGIVENESS_STRIKES_LIMIT
            return Action.C
        TOLERANCE_DEFECTION_COUNT = self._get_tolerance_defection_count_for_N(n_players)
        if k_D_t_minus_1 > TOLERANCE_DEFECTION_COUNT:
            self.my_forgiveness_strikes_remaining = self.FORGIVENESS_STRIKES_LIMIT
            return Action.D
        if k_D_t_minus_1 > 0 and k_D_t_minus_1 <= TOLERANCE_DEFECTION_COUNT:
            if self.my_forgiveness_strikes_remaining > 0:
                self.my_forgiveness_strikes_remaining -= 1
                return Action.C
            else:
                self.my_forgiveness_strikes_remaining = self.FORGIVENESS_STRIKES_LIMIT
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_262(BaseStrategy):
    """
    The "Collective Navigator" strategy aims to be a responsible steward of the common pool resource.
    It initiates cooperation to establish a sustainable dynamic, continuously monitors the collective
    behavior of other players, and adapts its actions. It operates on a principle of tempered reciprocity:
    it rewards sustained cooperation with cooperation, but it will defensively defect to protect the
    resource and its own interests from consistent exploitation, especially when the resource is
    vulnerable or nearing depletion. Its ultimate goal is to maximize total payoff over the entire
    game by ensuring the resource remains productive for as long as possible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        game_round = state.round_number + 1
        recent_history_window_size = min(max(1, int(0.1 * total_rounds)), 5)
        opponent_cooperation_rates = []
        start_history_idx = max(0, state.round_number - recent_history_window_size)
        num_opponents = n_players - 1
        for t_idx in range(start_history_idx, state.round_number):
            opponent_cooperation_count_t = np.sum(history.opponent_actions[t_idx, :])
            rate = opponent_cooperation_count_t / num_opponents
            opponent_cooperation_rates.append(rate)
        avg_recent_opponent_cooperation = 0.0
        if len(opponent_cooperation_rates) > 0:
            avg_recent_opponent_cooperation = sum(opponent_cooperation_rates) / len(opponent_cooperation_rates)
        cooperation_threshold_base = 0.7
        COOPERATION_THRESHOLD = cooperation_threshold_base
        stock_ratio = current_stock / capacity
        if stock_ratio >= 0.8:
            COOPERATION_THRESHOLD = 0.8
        elif stock_ratio <= 0.4:
            COOPERATION_THRESHOLD = 0.6
        CRITICAL_STOCK_LEVEL_RATIO = 0.25
        DEFENSIVE_DEFECTION_THRESHOLD = 0.4
        END_GAME_ROUNDS = max(1, int(0.15 * total_rounds))
        if current_stock < CRITICAL_STOCK_LEVEL_RATIO * capacity:
            if avg_recent_opponent_cooperation < DEFENSIVE_DEFECTION_THRESHOLD:
                return Action.D
            else:
                return Action.C
        if game_round >= total_rounds - END_GAME_ROUNDS:
            if avg_recent_opponent_cooperation < COOPERATION_THRESHOLD:
                return Action.D
            else:
                return Action.C
        if avg_recent_opponent_cooperation >= COOPERATION_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_263(BaseStrategy):
    """
    The Adaptive Collective Sustainer (ACS) strategy for the Common Pool Resource Game.
    This strategy aims for collective sustainability by initiating cooperation,
    monitoring resource levels and opponent actions, and adapting decisions.
    It enforces cooperation, prioritizes resource recovery when stock is low,
    and optimizes for immediate payoff in the final round. It incorporates
    forgiveness for minor defections in multi-player scenarios (n > 2).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD = self.game_description.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        elif current_round == r - 1:
            return Action.D
        else:
            previous_round_opponent_actions = history.opponent_actions[-1, :]
            num_others_cooperated = sum(previous_round_opponent_actions)
            num_others_defected = n - 1 - num_others_cooperated
            if current_stock < self.CRITICAL_STOCK_THRESHOLD:
                if num_others_cooperated >= (n - 1) / 2.0:
                    return Action.C
                else:
                    return Action.D
            elif n == 2:
                if num_others_defected == 0:
                    return Action.C
                else:
                    return Action.D
            elif num_others_defected <= 1:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_264(BaseStrategy):
    """
    Community Steward with Adaptive Forgiveness strategy for the Common Pool Resource Game.

    This strategy aims to foster collective sustainability by prioritizing the common stock's health.
    It cooperates initially, employs adaptive reciprocity (Tit-for-Tat with forgiveness) when stock is healthy,
    but always overrides with unconditional cooperation if the stock is critically low to prevent collapse.
    It defects in the final round for endgame rationality.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_active_until_round: int = 0
        self.forgiveness_active_until_round: int = 0
        self.S_CRITICAL_EMERGENCY: float = 2 * self.n
        self.S_REBUILD_TARGET: float = self.capacity / 2
        self.DEFECTION_TOLERANCE_NUM: int = 1
        self.PUNISHMENT_DURATION: int = 1
        self.FORGIVENESS_ROUNDS: int = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.r - 1:
            self.punishment_active_until_round = 0
            self.forgiveness_active_until_round = 0
            return Action.D
        if current_stock <= self.S_CRITICAL_EMERGENCY:
            self.punishment_active_until_round = 0
            self.forgiveness_active_until_round = 0
            return Action.C
        if current_stock < self.S_REBUILD_TARGET:
            self.punishment_active_until_round = 0
            self.forgiveness_active_until_round = 0
            return Action.C
        if current_round < self.forgiveness_active_until_round:
            return Action.C
        if current_round < self.punishment_active_until_round:
            return Action.D
        if current_round == 0:
            return Action.C
        previous_opponent_actions = history.opponent_actions[current_round - 1, :]
        num_other_defectors_last_round = np.sum(~previous_opponent_actions)
        if num_other_defectors_last_round >= self.DEFECTION_TOLERANCE_NUM:
            self.punishment_active_until_round = current_round + self.PUNISHMENT_DURATION
            self.forgiveness_active_until_round = current_round + self.PUNISHMENT_DURATION + self.FORGIVENESS_ROUNDS
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_265(BaseStrategy):
    """
    The "Adaptive Sustainable Reciprocity (ASR)" strategy for the Common Pool Resource Game.
    It balances collective sustainability with self-protection.
    Starts cooperatively, then adapts based on stock health and opponent actions.
    Switches to defection in endgame rounds. Prioritizes cooperation for recovery
    when the resource is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.ENDGAME_ROUNDS = 2
        self.S_CRITICAL_THRESHOLD = self.capacity / (2 * self.n)
        self.D_TOLERANCE_HEALTHY = 0.25
        self.HEALTHY_STOCK_RATIO = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed >= self.r - self.ENDGAME_ROUNDS + 1:
            return Action.D
        n_others = self.n - 1
        d_count = np.sum(history.opponent_actions[-1, :] == False)
        defection_ratio = d_count / n_others
        if current_stock <= self.S_CRITICAL_THRESHOLD:
            return Action.C
        elif current_stock >= self.capacity * self.HEALTHY_STOCK_RATIO:
            if defection_ratio < self.D_TOLERANCE_HEALTHY:
                return Action.C
            else:
                return Action.D
        elif defection_ratio > 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_266(BaseStrategy):
    """
    AdaptiveConservationist strategy for the Common Pool Resource Game.

    This strategy aims to establish and maintain a cooperative equilibrium,
    proactively respond to defection to deter free-riders, and most importantly,
    safeguard the common pool resource from collapse. It balances the collective
    good (resource sustainability and long-term total payoffs) with the need for
    self-preservation in a competitive environment where other players might
    not share the same collective goals.

    Design Principles:
    1. Initiate Cooperation: Start with cooperation.
    2. Deter Defection: Punish significant defection.
    3. Forgive and Reconcile: Allow for recovery from punishment.
    4. Resource Safeguard: Prioritize cooperation when stock is critically low.
    5. Adaptive Aggregation: Respond to overall group behavior.
    6. End-Game Rationality: Defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.punishment_duration = 2
        self.resource_crisis_threshold = float(self.capacity * 0.25)
        self.defection_response_threshold = 0.5
        self.is_in_punishment_phase = False
        self.punishment_countdown = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if state.round_number == 0:
            self.is_in_punishment_phase = False
            self.punishment_countdown = 0
            return Action.C
        if current_round_1_indexed == self.r:
            self.is_in_punishment_phase = False
            self.punishment_countdown = 0
            return Action.D
        num_opponent_defectors = np.sum(history.opponent_actions[-1, :] == Action.D)
        my_previous_action_was_D = history.my_actions[-1] == Action.D
        num_defectors_in_system = num_opponent_defectors + (1 if my_previous_action_was_D else 0)
        if current_stock < self.resource_crisis_threshold:
            self.is_in_punishment_phase = False
            self.punishment_countdown = 0
            return Action.C
        if self.is_in_punishment_phase:
            if self.punishment_countdown > 0:
                self.punishment_countdown -= 1
                return Action.D
            else:
                self.is_in_punishment_phase = False
        action_to_take = Action.C
        if num_defectors_in_system == 0:
            action_to_take = Action.C
            self.is_in_punishment_phase = False
            self.punishment_countdown = 0
        else:
            defection_ratio = num_defectors_in_system / self.n
            if defection_ratio >= self.defection_response_threshold:
                action_to_take = Action.D
                self.is_in_punishment_phase = True
                self.punishment_countdown = self.punishment_duration - 1
            else:
                action_to_take = Action.C
                self.is_in_punishment_phase = False
                self.punishment_countdown = 0
        return action_to_take

class Strategy_COLLECTIVE_267(BaseStrategy):
    """
    Adaptive Collective Conservationist (ACC) Strategy for Common Pool Resource games.
    Prioritizes resource sustainability through adaptive cooperation and strategic retaliation.
    It fosters cooperation, punishes excessive exploitation, and makes decisions based on
    current stock levels, past actions of other players, and the stage of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.STOCK_EMERGENCY_THRESHOLD = self.capacity / 4.0
        self.DEFECTION_TOLERANCE_LIMIT = math.floor(self.n_players / 4.0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number + 1
        current_stock_S = state.current_stock
        if current_round_t == 1:
            return Action.C
        elif current_round_t == self.n_rounds:
            return Action.D
        else:
            opponent_cooperators_prev_round = np.sum(history.opponent_actions[-1, :])
            opponent_defectors_prev_round = self.n_players - 1 - opponent_cooperators_prev_round
            if current_stock_S < self.STOCK_EMERGENCY_THRESHOLD:
                if opponent_defectors_prev_round == 0:
                    return Action.C
                else:
                    return Action.D
            elif opponent_defectors_prev_round <= self.DEFECTION_TOLERANCE_LIMIT:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_268(BaseStrategy):
    """
    The Adaptive Collective Sustenance (ACS) strategy for the Common Pool Resource game.
    It prioritizes long-term resource health and sustainability, aiming to maximize
    collective payoffs. It operates on a foundation of cooperation, adapting its
    behavior based on the current stock level and the observed actions of other players,
    with the goal of fostering a cooperative environment while preventing sustained exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.COOPERATIVE_THRESHOLD_HIGH = 0.75 * self.capacity
        self.COOPERATIVE_THRESHOLD_MEDIUM = 0.5 * self.capacity
        self.COOPERATIVE_THRESHOLD_LOW = 0.25 * self.capacity
        self.DEFECTION_TOLERANCE_MEDIUM_STOCK = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_num_1_indexed == 1:
            return Action.C
        if current_round_num_1_indexed == self.total_rounds:
            if current_stock < self.COOPERATIVE_THRESHOLD_LOW:
                return Action.C
            else:
                return Action.D
        prev_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        d_count_prev = np.sum(~prev_round_opponent_actions)
        defection_ratio_prev = 0.0
        defection_ratio_prev = d_count_prev / (self.n_players - 1)
        if current_stock < self.COOPERATIVE_THRESHOLD_MEDIUM:
            return Action.C
        elif self.COOPERATIVE_THRESHOLD_MEDIUM <= current_stock < self.COOPERATIVE_THRESHOLD_HIGH:
            if defection_ratio_prev > self.DEFECTION_TOLERANCE_MEDIUM_STOCK:
                return Action.D
            else:
                return Action.C
        elif d_count_prev > 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_269(BaseStrategy):
    """
    Adaptive Collective Steward (ACS) strategy for the Common Pool Resource Game.
    This strategy balances sustainable cooperation with individual performance,
    adapting to observed player actions and resource levels. It starts cooperative,
    punishes widespread defection, tolerates minor infractions, and prioritizes
    resource recovery in crises or individual gain in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.INITIAL_TOLERANCE_THRESHOLD = max(1, math.floor(n / 4))
        self.CRITICAL_STOCK_THRESHOLD = capacity / 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        my_previous_action_was_D = not history.my_actions[-1]
        my_d_count = 1 if my_previous_action_was_D else 0
        opponent_d_count = np.sum(~history.opponent_actions[-1, :])
        d_count_prev = my_d_count + opponent_d_count
        if current_stock <= self.CRITICAL_STOCK_THRESHOLD:
            if d_count_prev >= math.floor(n_players / 2):
                return Action.D
            else:
                return Action.C
        elif d_count_prev == 0:
            return Action.C
        elif d_count_prev <= self.INITIAL_TOLERANCE_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_270(BaseStrategy):
    """
    Adaptive Sustainability with Resource Triage (ASRT) strategy prioritizes long-term resource
    sustainability through cooperation. It aims to foster cooperation, punish widespread defection,
    and attempt resource recovery when threatened. It is also robust against exploitation, reacting
    strategically to severe resource depletion by making self-preserving moves.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.defection_tolerance = max(1, math.floor(n / 3))
        self.recovery_defection_tolerance = max(1, math.floor(n / 4))
        self.critical_stock_threshold_mid = capacity / 2.0
        self.critical_stock_threshold_low = capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == n_rounds - 1:
            return Action.D
        if current_round_number == 0:
            return Action.C
        num_opponents_defected_last_round = np.sum(history.opponent_actions[-1, :] == False)
        is_stock_very_critical = current_stock <= self.critical_stock_threshold_low
        is_stock_concerning = current_stock <= self.critical_stock_threshold_mid
        if is_stock_very_critical:
            return Action.D
        elif is_stock_concerning:
            if num_opponents_defected_last_round >= self.recovery_defection_tolerance:
                return Action.D
            else:
                return Action.C
        elif num_opponents_defected_last_round >= self.defection_tolerance:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_271(BaseStrategy):
    """
    Adaptive Sustainability with Forgiveness (ASF) strategy for the Common Pool Resource Game.
    Prioritizes long-term resource sustainability through conditional cooperation,
    adapting forgiveness levels based on current stock health and reacting to defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        capacity = self.game_description.capacity
        self.S_healthy_threshold = capacity * 0.75
        self.S_concern_threshold = capacity * 0.5
        self.S_danger_threshold = capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == 0:
            return Action.C
        if current_round_number == n_rounds - 1:
            return Action.D
        num_cooperated_prev = np.sum(history.opponent_actions[current_round_number - 1, :]) + int(history.my_actions[current_round_number - 1])
        num_defected_prev = n_players - num_cooperated_prev
        action_to_play = Action.C
        if current_stock < self.S_danger_threshold:
            if num_defected_prev > 0:
                action_to_play = Action.D
            else:
                action_to_play = Action.C
        elif current_stock < self.S_concern_threshold:
            if num_defected_prev > 0:
                action_to_play = Action.D
            else:
                action_to_play = Action.C
        elif current_stock < self.S_healthy_threshold:
            if num_defected_prev > n_players / 2:
                action_to_play = Action.D
            elif num_defected_prev > 0:
                action_to_play = Action.C
            else:
                action_to_play = Action.C
        elif num_defected_prev > n_players / 2:
            action_to_play = Action.D
        elif num_defected_prev > 0:
            action_to_play = Action.C
        else:
            action_to_play = Action.C
        return action_to_play

class Strategy_COLLECTIVE_272(BaseStrategy):
    """
    Adaptive Collective Guardian (ACG) strategy for the Common Pool Resource Game.
    This strategy prioritizes resource preservation, adaptively responds to other
    players' actions, and adjusts behavior based on the current health of the
    common pool.

    The strategy implements three core principles:
    1. Resource Preservation: Maintains common stock at healthy levels.
    2. Adaptive Reciprocity: Responds to other players' actions to deter exploitation.
    3. Situational Awareness: Adjusts behavior based on the current health of the common pool.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = self.capacity / (2 * self.n_players)
        self.warning_stock_threshold = self.capacity / 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.total_rounds - 1:
            return Action.D
        num_cooperators_prev_round = sum(history.opponent_actions[-1, :])
        d_count_prev = self.n_players - num_cooperators_prev_round
        if current_stock <= self.critical_stock_threshold:
            return Action.C
        elif current_stock <= self.warning_stock_threshold:
            if d_count_prev >= self.n_players / 2:
                return Action.D
            else:
                return Action.C
        elif d_count_prev > 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_273(BaseStrategy):
    """
    Adaptive Stock-Aware Retaliation (ASAR) Strategy for the Common Pool Resource Game.

    This strategy aims for collective sustainability by conditionally cooperating based on
    the current stock level and the observed defection rate of all players in the previous round.
    It transitions from strict cooperation enforcement when stock is healthy to more forgiving
    cooperation when stock is critically low, and defects in the final round to maximize individual payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_threshold = float(self.n_players)
        self.low_threshold = 0.25 * self.capacity
        self.recovery_threshold = 0.5 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num_1_indexed = state.round_number + 1
        if current_round_num_1_indexed == 1:
            return Action.C
        if current_round_num_1_indexed == self.total_rounds:
            return Action.D
        total_cooperators_prev = sum(history.opponent_actions[-1, :]) + (1 if history.my_actions[-1] else 0)
        D_count_prev = self.n_players - total_cooperators_prev
        current_stock_S = state.current_stock
        if current_stock_S <= self.critical_threshold:
            return Action.C
        elif current_stock_S <= self.low_threshold:
            if D_count_prev > math.floor(self.n_players / 2):
                return Action.D
            else:
                return Action.C
        elif current_stock_S <= self.recovery_threshold:
            if D_count_prev > math.floor(self.n_players / 4):
                return Action.D
            else:
                return Action.C
        elif D_count_prev > 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_274(BaseStrategy):
    """
    The "Adaptive Resource Guardian" (ARG) strategy is designed to promote sustainable resource management
    and collective welfare while remaining robust against exploitation in a competitive tournament environment.
    It balances cooperative tendencies with defensive reactions based on observed opponent behavior
    and the critical state of the common pool stock.

    This strategy initiates cooperation, rewards sustained cooperation, and tolerates minor defections
    if the resource stock is healthy. However, it adopts a punitive (defecting) stance when the stock
    falls below a critical threshold (DANGER_STOCK_THRESHOLD_RATIO) or when the number of defectors
    exceeds a defined tolerance (DEFECTION_TOLERANCE_COUNT). In the final round, it defects to maximize
    immediate payoff due to the absence of future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.DANGER_STOCK_THRESHOLD_RATIO: float = 0.5
        self.DEFECTION_TOLERANCE_COUNT: int = max(1, math.floor(self.game_description.n_players / 4))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == total_rounds:
            return Action.D
        num_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
        num_opponents = self.game_description.n_players - 1
        num_defectors_last_round = num_opponents - num_cooperators_last_round
        stock_is_healthy = current_stock >= capacity * self.DANGER_STOCK_THRESHOLD_RATIO
        if num_defectors_last_round == 0:
            return Action.C
        elif num_defectors_last_round <= self.DEFECTION_TOLERANCE_COUNT:
            if stock_is_healthy:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_275(BaseStrategy):
    """
    Adaptive Resource Guardian (ARG) strategy for the Common Pool Resource Game.

    This strategy aims to maintain the common resource at high levels through conditional
    cooperation. It acts as a guardian by defaulting to cooperation but aggressively
    punishing free-riders and unsustainable consumption patterns, adapting its
    strictness based on the current health of the resource. It balances collective
    sustainability with robustness against exploitation in a tournament setting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Resource Guardian strategy.

        Args:
            game_description: An object containing game parameters like
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.S_warning: float = game_description.capacity * 0.75
        self.S_critical: float = game_description.capacity * 0.25
        self.defection_tolerance_threshold: int = max(1, math.floor(game_description.n_players / 4))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: An object containing the current round number and current stock level.
            history: An object containing past actions and payoffs for the player and opponents.
                     It is None for the very first round (round_number == 0).

        Returns:
            An Action enum (Action.C for Cooperate, Action.D for Defect).
        """
        current_round_number: int = state.round_number
        total_rounds: int = self.game_description.n_rounds
        current_stock: float = state.current_stock
        n_players: int = self.game_description.n_players
        if current_round_number == 0:
            return Action.C
        if current_round_number == total_rounds - 1:
            return Action.D
        num_C_opponents_prev: int = np.sum(history.opponent_actions[-1, :])
        my_prev_action_was_C: bool = history.my_actions[-1]
        num_C_prev: int = num_C_opponents_prev + (1 if my_prev_action_was_C else 0)
        num_D_prev: int = n_players - num_C_prev
        if current_stock > self.S_warning:
            if num_D_prev >= self.defection_tolerance_threshold:
                return Action.D
            else:
                return Action.C
        elif current_stock > self.S_critical and current_stock <= self.S_warning:
            if num_D_prev > 0:
                return Action.D
            else:
                return Action.C
        elif num_D_prev > 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_276(BaseStrategy):
    """
    The 'Adaptive Resource Steward' strategy balances collective resource sustainability with robustness against exploitation.
    It cooperates initially, defects in the final round, and in intermediate rounds,
    adapts its behavior based on the common pool stock level and the observed cooperation
    ratio of all players from the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.low_stock_threshold = self.game_description.capacity / 2.0
        self.critical_cooperation_ratio_for_recovery = 0.5
        self.cooperation_forgiveness_ratio = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == n_rounds - 1:
            return Action.D
        num_cooperators_among_others = np.sum(history.opponent_actions[-1, :])
        num_total_cooperators_last_round = num_cooperators_among_others + (1 if history.my_actions[-1] else 0)
        cooperation_ratio_last_round = num_total_cooperators_last_round / n_players
        if current_stock < self.low_stock_threshold:
            if cooperation_ratio_last_round >= self.critical_cooperation_ratio_for_recovery:
                return Action.C
            else:
                return Action.D
        elif cooperation_ratio_last_round >= self.cooperation_forgiveness_ratio:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_277(BaseStrategy):
    """
    Adaptive Conditional Cooperation with Stock Preservation (ACC-SP) strategy.
    This strategy promotes initial cooperation, monitors and reacts to defection,
    prioritizes resource preservation when stock is low, and adapts its
    defection tolerance based on the number of players. It also accounts for
    endgame rationality in the final round to prevent exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters and internal strategy constants.

        Args:
            game_description: An object containing game-wide parameters like
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.low_stock_threshold_ratio: float = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round based on
        the game state, history, and the ACC-SP strategy rules.

        Args:
            state: An object containing the current round number and stock level.
            history: An object containing past actions and payoffs for the current
                     player and opponents. None for the very first round.

        Returns:
            An Action enum (Action.C for Cooperate, Action.D for Defect).
        """
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        defection_tolerance = 0 if n_players == 2 else 1
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.C
        low_stock_threshold = self.low_stock_threshold_ratio * capacity
        if current_stock < low_stock_threshold:
            return Action.C
        num_defecting_opponents = np.sum(history.opponent_actions[-1, :] == False)
        if num_defecting_opponents > defection_tolerance:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_278(BaseStrategy):
    """
    Adaptive Collective Guardian (ACG) strategy for the Common Pool Resource Game.

    This strategy aims to foster cooperation and ensure the long-term sustainability
    of the common resource. It operates on principles of default cooperation,
    prioritizing resource recovery if stock levels are critically low, and
    reciprocal punishment against defecting players.

    Key principles:
    - Default Cooperation: Begins and defaults to cooperation.
    - Resource Preservation: Switches to mandatory cooperation if stock falls below
      a critical threshold, overriding all other rules.
    - Reciprocity: Punishes other players' defection for a short duration.
    - Long-term View: Balances immediate payoffs with resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.TRIGGER_PUNISHMENT_IF_OTHER_DEFECTORS_COUNT = 0
        self.PUNISHMENT_DURATION = 1
        self.RECOVERY_THRESHOLD_RATIO = 0.5
        self.punishment_active_rounds_left = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if current_round_0_indexed == 0:
            self.punishment_active_rounds_left = 0
            return Action.C
        if current_round_0_indexed == total_rounds - 1:
            if current_stock < capacity * self.RECOVERY_THRESHOLD_RATIO:
                return Action.C
            prev_round_0_indexed = current_round_0_indexed - 1
            num_other_defectors_prev_round = np.sum(~history.opponent_actions[prev_round_0_indexed, :])
            if num_other_defectors_prev_round > self.TRIGGER_PUNISHMENT_IF_OTHER_DEFECTORS_COUNT:
                return Action.D
            return Action.C
        if self.punishment_active_rounds_left > 0:
            self.punishment_active_rounds_left -= 1
        if current_stock < capacity * self.RECOVERY_THRESHOLD_RATIO:
            return Action.C
        if self.punishment_active_rounds_left > 0:
            return Action.D
        prev_round_0_indexed = current_round_0_indexed - 1
        num_other_defectors_prev_round = np.sum(~history.opponent_actions[prev_round_0_indexed, :])
        if num_other_defectors_prev_round > self.TRIGGER_PUNISHMENT_IF_OTHER_DEFECTORS_COUNT:
            self.punishment_active_rounds_left = self.PUNISHMENT_DURATION
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_279(BaseStrategy):
    """
    The "Sustainable Retaliation" strategy for the Common Pool Resource Game.

    This strategy aims to foster collective cooperation for long-term resource
    sustainability while protecting individual interests against exploitation
    and during resource crises. It starts with cooperation, defects in the
    last round, and in intermediate rounds, it cooperates if a high level of
    collective cooperation was observed in the previous round, or defects if
    the stock level is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.K_threshold = self.n_players - 1
        self.critical_stock_ratio = 0.25
        self.critical_stock_level = self.critical_stock_ratio * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == 0:
            return Action.C
        elif current_round_number == self.n_rounds - 1:
            return Action.D
        else:
            if current_stock < self.critical_stock_level:
                return Action.D
            all_players_prev_actions = np.concatenate(([history.my_actions[-1]], history.opponent_actions[-1, :]))
            num_cooperators_prev_round = np.sum(all_players_prev_actions)
            if num_cooperators_prev_round >= self.K_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_280(BaseStrategy):
    """
    Adaptive Sustainability & Reciprocity (ASR) strategy for the Common Pool Resource Game.
    ASR prioritizes the sustainability of the common resource, recognizing that collective
    prosperity is impossible without it. It starts by signaling cooperative intent,
    responds to widespread cooperation with continued cooperation, and defends against
    significant defection to prevent exploitation and resource collapse. In times of
    crisis, it unconditionally cooperates to allow the resource to recover.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.COOPERATION_RATIO_THRESHOLD = 0.75
        self.S_CRITICAL_THRESHOLD = self.capacity / (2.0 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.n_rounds
        current_stock = state.current_stock
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        if current_stock < self.S_CRITICAL_THRESHOLD:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.C
        k_C_prev = sum(history.opponent_actions[-1, :])
        cooperation_ratio = k_C_prev / self.n_players
        if cooperation_ratio >= self.COOPERATION_RATIO_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_281(BaseStrategy):
    """
    The Adaptive Collective Sustainer (ACS) strategy for the Common Pool Resource Game.
    It aims for long-term collective sustainability by cooperating initially,
    reciprocating cooperation, punishing defection, prioritizing resource
    conservation when critically low, and defecting in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.s_danger = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == 0:
            return Action.C
        elif current_round_number == self.n_rounds - 1:
            return Action.D
        else:
            total_cooperators_prev_round = np.sum(history.opponent_actions[-1, :]) + (1 if history.my_actions[-1] else 0)
            total_defectors_prev_round = self.n_players - total_cooperators_prev_round
            if current_stock < self.s_danger:
                return Action.C
            elif total_defectors_prev_round == 0:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_282(BaseStrategy):
    """
    Adaptive Collective Steward (ACS) strategy for the Common Pool Resource Game.

    The ACS strategy aims to maximize the collective long-term payoff by promoting
    cooperation and ensuring the sustainability of the common resource. It is
    designed to be adaptive to opponent behavior and robust in a tournament setting.

    Core principles:
    1.  Prioritize cooperation to sustain the common stock, especially when critically low.
    2.  Adapt behavior based on current resource levels and observed actions of others.
    3.  Encourage collective stewardship through continued cooperation when successful.
    4.  Deter exploitation through strategic defection when a majority defects or
        when moderate defection occurs while the resource is declining.
    5.  Maximize individual payoff in the very last round as future consequences cease.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_low_threshold = self.capacity / self.n_players
        self.S_mid_target = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        num_D_opponents_last_round = np.sum(history.opponent_actions[-1, :] == Action.D.value)
        my_action_last_round_was_D = history.my_actions[-1] == Action.D.value
        num_D_me_last_round = 1 if my_action_last_round_was_D else 0
        num_D_last_round = num_D_opponents_last_round + num_D_me_last_round
        if current_stock < self.S_low_threshold:
            return Action.C
        elif num_D_last_round > self.n_players / 2:
            return Action.D
        elif num_D_last_round > 0:
            if current_stock < self.S_mid_target:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_283(BaseStrategy):
    """
    Adaptive Collective Steward Strategy for the Common Pool Resource Game.

    This strategy balances collective resource preservation with individual robustness.
    It cooperates initially, defects in the last round, and in intermediate rounds
    adapts its behavior based on the current stock level and the collective cooperation
    of all players in the previous round. It defines a critical stock recovery threshold
    and a minimum number of cooperators needed to maintain cooperation, otherwise resorting
    to defection to prevent exploitation or signal the necessity for collective action.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_recovery_threshold: float = self.game_description.capacity / 2.0
        max_tolerated_defectors: int = max(1, math.floor(self.game_description.n_players / 4))
        self.min_cooperators_needed: int = self.game_description.n_players - max_tolerated_defectors

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        num_cooperators_from_opponents = np.sum(previous_round_opponent_actions)
        previous_round_my_action = history.my_actions[state.round_number - 1]
        num_cooperators_prev_round = num_cooperators_from_opponents + int(previous_round_my_action)
        if state.current_stock < self.stock_recovery_threshold:
            if num_cooperators_prev_round >= self.min_cooperators_needed:
                return Action.C
            else:
                return Action.D
        elif num_cooperators_prev_round >= self.min_cooperators_needed:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_284(BaseStrategy):
    """
    Collective Adaptive Strategy with Emergency Response (CAES) aims to promote
    and maintain cooperation for long-term resource sustainability. It starts
    cooperatively, monitors opponent behavior with a Tit-for-Tat-like response,
    prioritizes resource recovery during critical stock levels, and defects
    in the final round for self-preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description: An object containing game parameters like
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.critical_stock_threshold = self.game_description.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current
        round based on the CAES strategy's rules.

        Args:
            state: An object representing the current game state, including
                   round_number and current_stock.
            history: An object containing past actions and payoffs of this
                     player and opponents. It is None for the first round (round_number 0).

        Returns:
            An Action (Cooperate or Defect).
        """
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == n_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.C
        if state.current_stock < self.critical_stock_threshold:
            return Action.C
        num_cooperators_last_round = np.sum(history.opponent_actions[-1])
        num_defectors_last_round = n_players - 1 - num_cooperators_last_round
        if num_defectors_last_round == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_285(BaseStrategy):
    """
    The Adaptive Stockkeeper (ASK) strategy for the Common Pool Resource Game.

    This strategy aims to promote collective sustainability by adapting its behavior
    based on the observed health of the common resource, while also being robust
    against exploitative behaviors from other players. It operates with a default
    cooperative stance, coupled with mechanisms for resource recovery and punishment
    of unsustainable consumption.

    It employs standard game theory reasoning for the first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.STOCK_DANGER_THRESHOLD_RATIO = 0.25
        self.STOCK_DEPLETION_THRESHOLD_RATIO = 0.05
        self.stock_at_start_of_previous_round: float = float(self.game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        action_to_take = Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            action_to_take = Action.D
        elif state.round_number == 0:
            action_to_take = Action.C
        else:
            stock_change_prev = state.current_stock - self.stock_at_start_of_previous_round
            if state.current_stock < self.game_description.capacity * self.STOCK_DANGER_THRESHOLD_RATIO:
                action_to_take = Action.C
            elif stock_change_prev < -self.game_description.capacity * self.STOCK_DEPLETION_THRESHOLD_RATIO:
                action_to_take = Action.D
            else:
                action_to_take = Action.C
        self.stock_at_start_of_previous_round = state.current_stock
        return action_to_take

class Strategy_COLLECTIVE_286(BaseStrategy):
    """
    The Adaptive Sustainability Trigger strategy for Common Pool Resource games.
    It prioritizes collective well-being by maintaining the common stock through cooperation,
    but shifts to self-preservation (defecting) if the resource is significantly depleted,
    and returns to cooperation upon recovery. The final round always defects.
    """
    _SUSTAINABILITY_THRESHOLD_RATIO = 0.6
    _RECOVERY_THRESHOLD_RATIO = 0.8

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_flag = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_round_0_indexed == 0:
            self.defection_flag = False
            return Action.C
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        if current_stock <= capacity / (2 * n_players):
            self.defection_flag = True
            return Action.D
        if current_stock < capacity * self._SUSTAINABILITY_THRESHOLD_RATIO:
            self.defection_flag = True
            return Action.D
        elif current_stock > capacity * self._RECOVERY_THRESHOLD_RATIO and self.defection_flag:
            self.defection_flag = False
            return Action.C
        elif self.defection_flag:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_287(BaseStrategy):
    """
    The Adaptive Resource Guardian (ARG) strategy balances collective resource management with self-protection
    and deterrence of defection in the Common Pool Resource Game.
    It prioritizes resource recovery when stock is critically low, rewards universal cooperation,
    and punishes defection when the resource is not endangered. In the final round, it defects for immediate gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_critical = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        num_defectors_prev_round = int(sum(~history.opponent_actions[state.round_number - 1, :]))
        if not history.my_actions[state.round_number - 1]:
            num_defectors_prev_round += 1
        if current_stock < self.S_critical:
            return Action.C
        elif num_defectors_prev_round == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_288(BaseStrategy):
    """
    The Adaptive Collective Conservationist (ACC) strategy promotes collective sustainability
    by starting cooperatively, monitoring opponent behavior and resource health, and
    adapting its strictness. It punishes defections for a set duration but allows for
    reconciliation. It enters an emergency conservation mode when stock is critically low,
    prioritizing resource recovery unless cooperation is clearly futile.
    It rationally defects in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_punishment_start_round: int = 0
        self.PUNISHMENT_DURATION: int = 2
        self.CRITICAL_STOCK_RATIO: float = 0.1
        self.LOW_STOCK_RATIO: float = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_round == 0:
            self.last_punishment_start_round = 0
            return Action.C
        if current_round == total_rounds - 1:
            self.last_punishment_start_round = 0
            return Action.D
        non_cooperators_prev_round = 0
        for opponent_action in history.opponent_actions[-1, :]:
            if opponent_action == Action.D:
                non_cooperators_prev_round += 1
        if current_stock <= capacity * self.CRITICAL_STOCK_RATIO:
            if non_cooperators_prev_round > (n_players - 1) / 2:
                self.last_punishment_start_round = 0
                return Action.D
            else:
                self.last_punishment_start_round = 0
                return Action.C
        if self.last_punishment_start_round > 0:
            if current_round - self.last_punishment_start_round <= self.PUNISHMENT_DURATION:
                return Action.D
            else:
                self.last_punishment_start_round = 0
        tolerated_defections = 0
        if current_stock > capacity * self.LOW_STOCK_RATIO:
            tolerated_defections = 1
        if non_cooperators_prev_round > tolerated_defections:
            self.last_punishment_start_round = current_round
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_290(BaseStrategy):
    """
    The "Collective Steward" strategy for the Common Pool Resource Game.
    Prioritizes long-term resource sustainability and collective welfare,
    while being responsive to opponent actions to avoid exploitation.
    It starts cooperatively, punishes widespread defection, is forgiving
    of minor lapses, and defects in the last round.
    """
    CRITICAL_STOCK_THRESHOLD = 0.2

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.widespread_defection_threshold = math.ceil(self.n_players / 2)
        self.my_last_action: Action = Action.C

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        my_action: Action
        if current_round == 0:
            my_action = Action.C
            self.my_last_action = my_action
            return my_action
        if current_round == self.n_rounds - 1:
            my_action = Action.D
            self.my_last_action = my_action
            return my_action
        opponent_defection_count_prev = self.n_players - 1 - np.sum(history.opponent_actions[-1, :])
        my_defection_prev = not history.my_actions[-1]
        d_count_prev = opponent_defection_count_prev + (1 if my_defection_prev else 0)
        if current_stock < self.CRITICAL_STOCK_THRESHOLD * self.capacity:
            my_action = Action.C
        elif d_count_prev == 0:
            my_action = Action.C
        elif self.my_last_action == Action.C:
            if d_count_prev >= self.widespread_defection_threshold:
                my_action = Action.D
            else:
                my_action = Action.C
        else:
            my_action = Action.C
        self.my_last_action = my_action
        return my_action

class Strategy_COLLECTIVE_291(BaseStrategy):
    """
    Adaptive Collective Retaliation (ACR) strategy for the Common Pool Resource Game.

    This strategy balances cooperation, retaliation against free-riding, and
    resource preservation. It aims to foster collective well-being by starting
    cooperatively, punishing observed defections when stock levels are sufficient,
    and prioritizing stock recovery when the common pool is low. In the final
    round, it maximizes immediate individual payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == 0:
            return Action.C
        if current_round_number == n_rounds - 1:
            return Action.D
        my_previous_action_was_cooperate = history.my_actions[current_round_number - 1]
        num_opponent_defectors_prev_round = np.sum(~history.opponent_actions[current_round_number - 1, :])
        num_defectors_prev_round = num_opponent_defectors_prev_round
        if not my_previous_action_was_cooperate:
            num_defectors_prev_round += 1
        critical_stock_threshold = capacity / 4.0
        low_stock_threshold = capacity / 2.0
        if current_stock < critical_stock_threshold:
            return Action.C
        elif current_stock < low_stock_threshold:
            return Action.C
        elif num_defectors_prev_round == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_292(BaseStrategy):
    """
    Adaptive Collective Sustainer (ACS) strategy for the Common Pool Resource Game.

    This strategy aims to promote long-term resource sustainability and collective welfare
    by balancing cooperative behavior with adaptive responses to observed exploitation,
    while remaining robust to diverse opponent strategies.

    It prioritizes resource preservation when stock is critically low, practices conditional
    reciprocity based on observed defections, and adjusts its tolerance for defection based
    on the current resource abundance. It also acts in immediate self-interest in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_Danger_Zone = self.capacity / 4.0
        self.S_High_Tolerance_Zone = self.capacity * 0.75
        self.k_low_tolerance = 0
        self.k_high_tolerance = math.floor((self.n_players - 1) / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        num_defectors_prev_round = 0
        if not history.my_actions[-1]:
            num_defectors_prev_round += 1
        num_defectors_prev_round += np.sum(history.opponent_actions[-1, :] == False)
        if current_stock < self.S_Danger_Zone:
            return Action.C
        elif current_stock >= self.S_High_Tolerance_Zone:
            if num_defectors_prev_round > self.k_high_tolerance:
                return Action.D
            else:
                return Action.C
        elif num_defectors_prev_round > self.k_low_tolerance:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_293(BaseStrategy):
    """
    The Adaptive Enforcer strategy promotes collective sustainability in the Common Pool Resource Game.
    It defaults to cooperation but monitors collective behavior and resource health.
    It punishes significant collective defection or critically low stock by temporarily defecting,
    but is quick to forgive and return to cooperation if conditions improve.
    It defects in the final round for self-preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.cooperation_grace_period = 1
        self.defection_threshold_ratio = 0.5
        self.stock_recovery_cooperate_threshold = 0.75
        self.stock_critical_defection_threshold = 0.1
        self.rounds_since_collective_defection = 0
        self.currently_punishing = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == 0:
            return Action.C
        if current_round_number == self.r - 1:
            return Action.D
        num_opponent_defectors_last_round = np.sum(~history.opponent_actions[-1, :])
        my_last_action_was_C = history.my_actions[-1]
        my_last_action_was_D = not my_last_action_was_C
        total_defectors_last_round = num_opponent_defectors_last_round + (1 if my_last_action_was_D else 0)
        is_collective_defection = total_defectors_last_round / self.n >= self.defection_threshold_ratio
        if is_collective_defection:
            self.rounds_since_collective_defection += 1
        else:
            self.rounds_since_collective_defection = 0
        if self.currently_punishing:
            if num_opponent_defectors_last_round == 0:
                self.currently_punishing = False
            elif current_stock >= self.capacity * self.stock_recovery_cooperate_threshold:
                self.currently_punishing = False
        elif self.rounds_since_collective_defection >= self.cooperation_grace_period:
            self.currently_punishing = True
        if current_stock <= self.capacity * self.stock_critical_defection_threshold:
            return Action.D
        elif self.currently_punishing:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_294(BaseStrategy):
    """
    Sustainable Reactive Reciprocity (SRR) strategy for the Common Pool Resource Game.

    This strategy aims to maximize a player's total payoff over the entire game by primarily
    pursuing collective sustainability. It begins with cooperation, reacts to defection,
    and adapts its behavior based on the common stock level and the perceived cooperativeness
    of the other players. It incorporates mechanisms to protect against exploitation and
    mitigate losses in hostile or resource-depleted environments.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.STOCK_CRITICAL_LEVEL = 0.3 * capacity
        self.COOPERATIVE_ENVIRONMENT_THRESHOLD = math.floor(n * 0.5)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == total_rounds:
            return Action.D
        my_action_prev_round_is_C = history.my_actions[-1]
        num_coop_opponents_prev_round = np.sum(history.opponent_actions[-1, :])
        num_coop_prev_round = num_coop_opponents_prev_round + (1 if my_action_prev_round_is_C else 0)
        num_defect_prev_round = n - num_coop_prev_round
        if current_stock < self.STOCK_CRITICAL_LEVEL:
            if num_coop_prev_round > self.COOPERATIVE_ENVIRONMENT_THRESHOLD:
                return Action.C
            else:
                return Action.D
        elif num_defect_prev_round == 0:
            return Action.C
        elif not my_action_prev_round_is_C:
            if num_coop_prev_round >= self.COOPERATIVE_ENVIRONMENT_THRESHOLD:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_295(BaseStrategy):
    """
    The Adaptive Common Pool Steward (ACPS) strategy aims to sustain the common pool resource at high levels
    for as long as possible by prioritizing collective welfare. It starts with cooperation, continues
    cooperating as long as others do (conditional cooperation), and punishes defection to deter exploitation.
    It adapts to resource scarcity by maintaining cooperation when stock is low if all others cooperate,
    but defects if others exploit a dwindling resource. The strategy also incorporates end-game awareness
    to pragmatically adapt to the breakdown of cooperation in the final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        n_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        num_defectors_prev_round = 0
        if current_round_0_indexed > 0:
            num_defectors_prev_round = (~history.opponent_actions[-1, :]).sum()
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == n_rounds - 1:
            return Action.D
        if current_round_0_indexed == n_rounds - 2:
            if current_stock >= capacity * 0.75 and num_defectors_prev_round == 0:
                return Action.C
            else:
                return Action.D
        recovery_stock_threshold = capacity * 0.25
        if num_defectors_prev_round == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_296(BaseStrategy):
    """
    Adaptive Conservationist with Forgiveness strategy for the Common Pool Resource Game.
    This strategy aims to promote collective welfare by prioritizing resource sustainability
    while remaining robust against exploitation. It adapts its behavior based on the current
    stock level and observed actions of other players, incorporating punishment for defection
    and forgiveness to restore cooperation, with an overriding conservation mode for low stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Conservationist with Forgiveness strategy.

        Args:
            game_description: An object containing game parameters like n_players, n_rounds, capacity.
        """
        self.game_description = game_description
        self.punishment_rounds_remaining: int = 0
        self.forgiveness_counter: int = 0
        self.D_trigger_threshold: int = 1
        self.Punishment_duration: int = 1
        self.Conservation_threshold: float = 0.25
        self.Forgiveness_rounds: int = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate 'C' or Defect 'D') for the current round.

        Args:
            state: An object containing current round_number and current_stock.
            history: An object containing past actions and payoffs. None for the first round.

        Returns:
            An Action enum (Action.C or Action.D).
        """
        current_stock = state.current_stock
        round_number = state.round_number
        capacity = self.game_description.capacity
        stock_health_ratio = current_stock / capacity
        num_defectors_last_round = 0
        if history is not None and round_number > 0:
            previous_round_opponent_actions = history.opponent_actions[round_number - 1, :]
            for action_bool in previous_round_opponent_actions:
                if not action_bool:
                    num_defectors_last_round += 1
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            if num_defectors_last_round == 0:
                self.forgiveness_counter += 1
            else:
                self.forgiveness_counter = 0
            if self.forgiveness_counter >= self.Forgiveness_rounds:
                self.punishment_rounds_remaining = 0
        if stock_health_ratio < self.Conservation_threshold or current_stock == 0:
            self.punishment_rounds_remaining = 0
            self.forgiveness_counter = 0
            return Action.C
        elif self.punishment_rounds_remaining > 0:
            return Action.D
        elif num_defectors_last_round >= self.D_trigger_threshold:
            self.punishment_rounds_remaining = self.Punishment_duration - 1
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_297(BaseStrategy):
    """
    The Adaptive Sustainability Enforcer (ASE) strategy prioritizes the health of the common stock.
    It employs conditional cooperation, reacting to both the resource's state and other players' behaviors.

    Core Principles:
    1.  Prioritize Resource Health: Maintain high and stable common pool stock.
    2.  Conditional Cooperation: Start cooperative and continue if stock is healthy AND others cooperate.
    3.  Punishment for Defection: Respond to significant free-riding by defecting.
    4.  Implicit Forgiveness: Revert to cooperation if defectors return to cooperation and stock improves.
    5.  Self-Preservation in Extremis: In the final round or if stock is critically depleted due to collective failure,
        act to minimize individual losses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        if self.n_players == 2:
            self.defection_tolerance_count = 0
        else:
            self.defection_tolerance_count = 1
        self.stock_recovery_threshold = self.capacity * 0.75
        self.stock_danger_threshold = self.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == 0:
            return Action.C
        if current_round_number == self.n_rounds - 1:
            return Action.D
        num_other_cooperators = np.sum(history.opponent_actions[-1, :])
        num_other_defectors = self.n_players - 1 - num_other_cooperators
        if current_stock >= self.stock_recovery_threshold:
            if num_other_defectors <= self.defection_tolerance_count:
                return Action.C
            else:
                return Action.D
        elif current_stock < self.stock_recovery_threshold and current_stock >= self.stock_danger_threshold:
            if num_other_defectors == 0:
                return Action.C
            else:
                return Action.D
        elif num_other_defectors == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_298(BaseStrategy):
    """
    Adaptive Collective Conservationist strategy for the Common Pool Resource Game.
    This strategy promotes long-term sustainability by starting with cooperation,
    then adaptively punishing defection. The tolerance for defection decreases
    as the resource stock declines. In the final round, it defects to maximize
    immediate personal gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_level = self.capacity / 4
        self.warning_stock_level = self.capacity / 2
        self.initial_defection_tolerance_rate = 1 / self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number + 1
        if current_round_t == 1:
            return Action.C
        if current_round_t == self.n_rounds:
            return Action.D
        num_cooperators_prev = sum(history.opponent_actions[-1, :])
        n_D_prev = self.n_players - num_cooperators_prev
        defection_rate_prev = n_D_prev / self.n_players
        dynamic_defection_trigger_threshold = 0.0
        if state.current_stock > self.critical_stock_level:
            scaling_factor = (state.current_stock - self.critical_stock_level) / (self.capacity - self.critical_stock_level)
            dynamic_defection_trigger_threshold = self.initial_defection_tolerance_rate * scaling_factor
        if defection_rate_prev > dynamic_defection_trigger_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_299(BaseStrategy):
    """
    Adaptive Resource Steward (ARS) strategy for the Common Pool Resource Game.
    This strategy is designed to be robust, adaptive, and prioritize the long-term
    sustainability of the shared resource while navigating the inherent tensions
    of collective action. It employs proactive cooperation, adaptive reciprocity,
    resource stewardship, strategic forgiveness, and endgame awareness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        self.MAX_OPPONENT_DEFECTIONS_TOLERATED = max(0, math.floor((n - 1) / 2))
        self.CRITICAL_STOCK_THRESHOLD = capacity * 0.4
        self.NORMAL_PUNISHMENT_DURATION = max(1, math.floor(n / 3))
        self.CRITICAL_PUNISHMENT_DURATION = max(2, math.floor(r / 4))
        self.my_last_action = None
        self.currently_punishing = False
        self.punishment_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        num_opponent_defectors = 0
        if current_round > 1:
            last_round_opponent_actions = history.opponent_actions[-1, :]
            num_opponent_defectors = np.sum(~last_round_opponent_actions)
        is_stock_critical = state.current_stock <= self.CRITICAL_STOCK_THRESHOLD
        if self.currently_punishing:
            self.punishment_rounds_remaining -= 1
            if self.punishment_rounds_remaining <= 0:
                self.currently_punishing = False
        my_action = Action.C
        if current_round == 1:
            my_action = Action.C
        elif current_round == r:
            if is_stock_critical or self.currently_punishing:
                my_action = Action.D
            else:
                my_action = Action.C
        elif is_stock_critical and num_opponent_defectors > self.MAX_OPPONENT_DEFECTIONS_TOLERATED:
            my_action = Action.D
            self.currently_punishing = True
            self.punishment_rounds_remaining = self.CRITICAL_PUNISHMENT_DURATION
        elif self.currently_punishing:
            my_action = Action.D
        elif num_opponent_defectors > self.MAX_OPPONENT_DEFECTIONS_TOLERATED:
            my_action = Action.D
            self.currently_punishing = True
            self.punishment_rounds_remaining = self.NORMAL_PUNISHMENT_DURATION
        else:
            my_action = Action.C
        self.my_last_action = my_action
        return my_action

class Strategy_COLLECTIVE_301(BaseStrategy):
    """
    Adaptive Collective Steward (ACS) strategy for the Common Pool Resource game.
    This strategy prioritizes resource health, employs conditional cooperation,
    punishment for defection, forgiveness, and adapts its response based on
    current stock levels, with special handling for the first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.my_current_stance = 'COOPERATING'
        self.punish_countdown = 0
        self.COOP_PROPORTION_THRESHOLD_HEALTHY = 0.8
        self.COOP_PROPORTION_THRESHOLD_CONSERVATION = 0.95
        self.STOCK_HEALTHY_PERCENT = 0.75
        self.STOCK_CONSERVATION_PERCENT = 0.4
        self.STOCK_CRITICAL_PERCENT = 0.1
        self.PUNISHMENT_DURATION = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            self.my_current_stance = 'COOPERATING'
            self.punish_countdown = 0
            return Action.C
        if current_round == self.n_rounds - 1:
            if current_stock < self.capacity * self.STOCK_CRITICAL_PERCENT:
                return Action.C
            else:
                return Action.D
        last_round_idx = current_round - 1
        my_previous_action_is_C = history.my_actions[last_round_idx]
        opponent_previous_coop_count = np.sum(history.opponent_actions[last_round_idx, :])
        total_cooperators_previous_round = opponent_previous_coop_count + (1 if my_previous_action_is_C else 0)
        observed_coop_proportion = total_cooperators_previous_round / self.n_players
        if self.punish_countdown > 0:
            self.punish_countdown -= 1
        if self.punish_countdown == 0:
            self.my_current_stance = 'COOPERATING'
        if current_stock < self.capacity * self.STOCK_CRITICAL_PERCENT:
            self.my_current_stance = 'COOPERATING'
            self.punish_countdown = 0
            return Action.C
        elif current_stock < self.capacity * self.STOCK_CONSERVATION_PERCENT:
            if observed_coop_proportion >= self.COOP_PROPORTION_THRESHOLD_CONSERVATION:
                self.my_current_stance = 'COOPERATING'
                self.punish_countdown = 0
                return Action.C
            else:
                self.my_current_stance = 'PUNISHING'
                self.punish_countdown = self.PUNISHMENT_DURATION
                return Action.D
        elif self.my_current_stance == 'PUNISHING':
            return Action.D
        elif observed_coop_proportion >= self.COOP_PROPORTION_THRESHOLD_HEALTHY:
            return Action.C
        else:
            self.my_current_stance = 'PUNISHING'
            self.punish_countdown = self.PUNISHMENT_DURATION
            return Action.D

class Strategy_COLLECTIVE_302(BaseStrategy):
    """
    Sustainable Adaptive Reciprocity (SAR) strategy for the Common Pool Resource Game.

    This strategy aims to foster collective sustainability by defaulting to cooperation,
    but adapts behavior based on observed defection and the health of the common resource stock.
    It includes specific rules for the first and last rounds, emergency recovery, and adaptive
    reciprocity based on the proportion of defectors and current stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0idx = state.round_number
        current_stock = state.current_stock
        if current_round_0idx == 0:
            return Action.C
        prev_round_0idx = current_round_0idx - 1
        num_opponent_defectors = np.sum(~history.opponent_actions[prev_round_0idx, :])
        my_previous_action_was_D = not history.my_actions[prev_round_0idx]
        k_D_prev = int(num_opponent_defectors) + int(my_previous_action_was_D)
        if current_round_0idx == self.n_rounds - 1:
            return Action.D
        if current_stock < self.capacity / 4:
            if k_D_prev == self.n_players:
                return Action.D
            else:
                return Action.C
        if k_D_prev == 0:
            return Action.C
        elif k_D_prev <= self.n_players / 2:
            if current_stock < self.capacity / 2:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_303(BaseStrategy):
    """
    The Adaptive Sustainability Guardian (ASG) prioritizes long-term resource sustainability.
    It conditionally cooperates, punishing excessive defection with a short retaliation period,
    and enforces mandatory cooperation during critical resource depletion to ensure recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.my_strategy_state: str = 'COOPERATING'
        self.punish_rounds_remaining: int = 0
        self.TOLERANCE_THRESHOLD: int = 1
        self.RETALIATION_DURATION: int = 1
        self.CRITICAL_STOCK_LEVEL_FACTOR: float = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity_val = float(self.game_description.capacity)
        if state.round_number == 0:
            self.my_strategy_state = 'COOPERATING'
            self.punish_rounds_remaining = 0
            return Action.C
        if current_round_1_indexed == total_rounds:
            return Action.D
        total_cooperators_prev_round = np.sum(history.opponent_actions[-1, :]) + history.my_actions[-1]
        num_total_defectors_prev_round = n_players - total_cooperators_prev_round
        if state.current_stock < capacity_val * self.CRITICAL_STOCK_LEVEL_FACTOR:
            self.my_strategy_state = 'COOPERATING'
            self.punish_rounds_remaining = 0
            return Action.C
        if self.my_strategy_state == 'PUNISHING':
            if self.punish_rounds_remaining > 0:
                self.punish_rounds_remaining -= 1
                return Action.D
            else:
                self.my_strategy_state = 'COOPERATING'
                return Action.C
        elif self.my_strategy_state == 'COOPERATING':
            if num_total_defectors_prev_round > self.TOLERANCE_THRESHOLD:
                self.my_strategy_state = 'PUNISHING'
                self.punish_rounds_remaining = self.RETALIATION_DURATION - 1
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_304(BaseStrategy):
    """
    Collective Guardian strategy is designed to foster and maintain cooperation within the common pool
    resource game, prioritizing long-term resource sustainability. It starts cooperatively, punishes
    observed collective defection, and enacts emergency conservation measures when the resource is
    critically threatened, overriding other considerations. It defects in the final round as per
    standard game theory backward induction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_RATIO: float = 0.25
        self.COOPERATION_THRESHOLD_SCORE: float = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.game_description.capacity * self.CRITICAL_STOCK_RATIO:
            return Action.C
        prev_round_idx = state.round_number - 1
        if not hasattr(history, 'stock_at_start') or prev_round_idx >= len(history.stock_at_start):
            return Action.C
        prev_stock_at_start = history.stock_at_start[prev_round_idx]
        if prev_stock_at_start <= 0.0001:
            return Action.C
        if not hasattr(history, 'total_consumption') or prev_round_idx >= len(history.total_consumption):
            return Action.C
        prev_total_consumption = history.total_consumption[prev_round_idx]
        observed_consumption_ratio_prev = prev_total_consumption / prev_stock_at_start
        inferred_defection_level = (observed_consumption_ratio_prev - 0.5) / 0.5
        inferred_defection_level = max(0.0, min(1.0, inferred_defection_level))
        inferred_cooperation_score = 1.0 - inferred_defection_level
        if inferred_cooperation_score < self.COOPERATION_THRESHOLD_SCORE:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_305(BaseStrategy):
    """
    Steward aims to foster and maintain cooperation to ensure the long-term sustainability
    of the common pool resource. It starts cooperatively, monitors the collective behavior
    of other players and the health of the stock, and adjusts its actions to promote
    resource preservation or to counter exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold = max(1, math.floor(self.n / 4))
        self.critical_stock_threshold = 0.25 * self.capacity
        self.recovery_stock_threshold = 0.75 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.r - 1:
            return Action.D
        prev_round_opponent_actions = history.opponent_actions[-1, :]
        d_count_prev_round = sum((1 for action_bool in prev_round_opponent_actions if not action_bool))
        if current_stock < self.critical_stock_threshold:
            return Action.C
        if current_stock >= self.recovery_stock_threshold:
            return Action.C
        elif d_count_prev_round <= self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_306(BaseStrategy):
    """
    Dynamic Adaptive Collective (DAC) strategy for the Common Pool Resource Game.
    This strategy prioritizes the long-term sustainability of the common stock
    while being adaptive and robust to various opponent behaviors. It incorporates
    elements of reciprocity, punishment, and forgiveness, with an overriding
    commitment to resource preservation when the stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD = 0.2 * self.game_description.capacity
        self.FORGIVENESS_ROUNDS = 2
        self.trust_level: int = 0
        self.last_defection_round: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_zero_indexed = state.round_number
        current_stock = state.current_stock
        total_rounds = self.game_description.n_rounds
        if current_round_zero_indexed == 0:
            return Action.C
        if current_round_zero_indexed == total_rounds - 1:
            return Action.D
        num_D_prev_round = np.sum(~history.opponent_actions[-1, :])
        if num_D_prev_round > 0:
            self.last_defection_round = current_round_zero_indexed - 1
            self.trust_level = 0
        else:
            self.trust_level += 1
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        else:
            if self.last_defection_round == current_round_zero_indexed - 1:
                return Action.D
            if self.last_defection_round > 0 and self.trust_level < self.FORGIVENESS_ROUNDS:
                return Action.D
            return Action.C

class Strategy_COLLECTIVE_307(BaseStrategy):
    """
    Adaptive Resource Guardian strategy for the Common Pool Resource game.
    It prioritizes resource sustainability, encourages cooperation, deters defection,
    and adapts its actions based on the common pool's health and observed cooperation.
    It includes special logic for the first and last rounds.
    """
    COOPERATION_THRESHOLD_PERCENTAGE = 0.75
    CRITICAL_STOCK_THRESHOLD_RATIO = 0.5

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold_percentage = self.COOPERATION_THRESHOLD_PERCENTAGE
        self.critical_stock_threshold_ratio = self.CRITICAL_STOCK_THRESHOLD_RATIO

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == n_rounds - 1:
            return Action.D
        if current_stock < self.critical_stock_threshold_ratio * capacity:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.C
        num_opponent_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
        num_other_players = n_players - 1
        fraction_others_cooperated = num_opponent_cooperators_last_round / num_other_players
        if fraction_others_cooperated >= self.cooperation_threshold_percentage:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_308(BaseStrategy):
    """
    The Adaptive Sustainability and Retaliation (ASR) strategy is built on principles
    of cooperative resource management, robust deterrence of defection, and forgiveness.
    It aims to foster a sustainable common pool by initially cooperating and maintaining
    cooperation as long as others do. When significant defection is observed, it
    retaliates to discourage further exploitation. It also prioritizes resource
    preservation when the stock is critically low and adapts to end-game dynamics.
    """
    COOPERATION_TOLERANCE_THRESHOLD: float = 1.0
    FORGIVENESS_ROUNDS_REQUIRED: int = 2
    PUNISHMENT_DURATION_ROUNDS: int = 1
    LAST_ROUND_TRIGGER: int = 2
    CRITICAL_STOCK_FACTOR: float = 0.25

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.rounds_since_defection_by_others: int = 0
        self.am_i_punishing: bool = False
        self.punishment_countdown: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock_S = state.current_stock
        n = self.n_players
        capacity = self.capacity
        total_rounds = self.n_rounds
        if current_round_0_indexed == 0:
            self.rounds_since_defection_by_others = 0
            self.am_i_punishing = False
            self.punishment_countdown = 0
            return Action.C
        if current_round_0_indexed >= total_rounds - self.LAST_ROUND_TRIGGER:
            return Action.D
        if current_stock_S < capacity * self.CRITICAL_STOCK_FACTOR:
            return Action.C
        my_previous_action_bool = history.my_actions[-1]
        my_previous_payoff = history.my_payoffs[-1]
        if my_previous_payoff == 0:
            previous_stock_S_t_minus_1 = 0.0
        elif my_previous_action_bool == Action.C.value:
            previous_stock_S_t_minus_1 = my_previous_payoff * (2 * n)
        else:
            previous_stock_S_t_minus_1 = my_previous_payoff * n
        if previous_stock_S_t_minus_1 < 1e-09:
            previous_stock_S_t_minus_1 = 0.0
        my_consumption_t_minus_1 = previous_stock_S_t_minus_1 / (2 * n) if my_previous_action_bool == Action.C.value else previous_stock_S_t_minus_1 / n
        opponent_actions_t_minus_1 = history.opponent_actions[-1, :]
        num_opponent_cooperators = np.sum(opponent_actions_t_minus_1).item()
        num_opponent_defectors = n - 1 - num_opponent_cooperators
        denominator_for_consumption = 2 * n if n > 0 else 1
        denominator_for_defection = n if n > 0 else 1
        others_consumption_t_minus_1 = num_opponent_cooperators * (previous_stock_S_t_minus_1 / denominator_for_consumption) + num_opponent_defectors * (previous_stock_S_t_minus_1 / denominator_for_defection)
        expected_others_consumption_if_all_C_t_minus_1 = (n - 1) * previous_stock_S_t_minus_1 / denominator_for_consumption
        observed_excess_consumption_by_others = others_consumption_t_minus_1 - expected_others_consumption_if_all_C_t_minus_1
        cost_of_one_defection_unit = previous_stock_S_t_minus_1 / denominator_for_consumption if previous_stock_S_t_minus_1 > 0 else 0.0
        if observed_excess_consumption_by_others > self.COOPERATION_TOLERANCE_THRESHOLD * cost_of_one_defection_unit:
            self.am_i_punishing = True
            self.punishment_countdown = self.PUNISHMENT_DURATION_ROUNDS
            self.rounds_since_defection_by_others = 0
        elif not self.am_i_punishing:
            self.rounds_since_defection_by_others += 1
        elif observed_excess_consumption_by_others <= 0:
            self.rounds_since_defection_by_others += 1
        my_action = Action.C
        if self.am_i_punishing:
            my_action = Action.D
            self.punishment_countdown -= 1
            if self.punishment_countdown <= 0 and self.rounds_since_defection_by_others >= self.FORGIVENESS_ROUNDS_REQUIRED:
                self.am_i_punishing = False
                self.rounds_since_defection_by_others = 0
        return my_action

class Strategy_COLLECTIVE_309(BaseStrategy):
    """
    Sentinel of the Commons strategy: Prioritizes the long-term sustainability of the common stock
    while dynamically adjusting its behavior based on the observed cooperation levels of other players.
    It starts by signaling cooperation, defects in the final round, and implements adaptive reciprocity
    in intermediate rounds. An emergency "preservation mode" forces cooperation to prevent resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.
        """
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.
        """
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_stock < self.capacity / self.n_players:
            return Action.C
        else:
            previous_round_opponent_actions = history.opponent_actions[-1, :]
            num_defected_others = np.sum(~previous_round_opponent_actions)
            if num_defected_others > (self.n_players - 1) / 2:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_310(BaseStrategy):
    """
    Adaptive Stock Guardian (ASG) strategy for the Common Pool Resource Game.

    ASG prioritizes the long-term health and sustainability of the common pool resource.
    It aims to foster a cooperative environment by defaulting to cooperation, but will
    conditionally retaliate against significant defection to prevent exploitation.
    A key feature is its dynamic adaptation to the current stock level, implementing
    more conservative behaviors when the resource is depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Stock Guardian strategy.

        Args:
            game_description (CommonPoolDescription): Description of the game parameters.
        """
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_RATIO = 0.2
        self.CAUTIOUS_STOCK_RATIO = 0.5
        self.DEFECTION_TOLERANCE_THRESHOLD_PERCENT = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state (CommonPoolState): The current state of the game.
            history (None | PlayerHistory): Past actions and payoffs, or None for the first round.

        Returns:
            Action: The chosen action, Action.C for Cooperate or Action.D for Defect.
        """
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        capacity = self.capacity
        n = self.n_players
        total_rounds = self.n_rounds
        if current_stock < capacity * self.CRITICAL_STOCK_RATIO:
            return Action.C
        total_defectors_last_round = 0
        num_other_defectors_last_round = 0
        if history is not None:
            my_action_last_round_is_C = history.my_actions[-1]
            opponent_actions_last_round_are_C = history.opponent_actions[-1, :]
            total_defectors_last_round = (1 if not my_action_last_round_is_C else 0) + np.sum(~opponent_actions_last_round_are_C)
            num_other_defectors_last_round = np.sum(~opponent_actions_last_round_are_C)
        if current_round_1_indexed == total_rounds:
            if current_stock > capacity * self.CAUTIOUS_STOCK_RATIO:
                if total_defectors_last_round > n / 2:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        if current_round_1_indexed == 1:
            return Action.C
        defection_threshold = 0
        if n > 1:
            defection_threshold = math.ceil((n - 1) * self.DEFECTION_TOLERANCE_THRESHOLD_PERCENT)
            defection_threshold = max(1, defection_threshold)
        if num_other_defectors_last_round >= defection_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_311(BaseStrategy):
    """
    Adaptive Stock-Aware Retaliatory Cooperation (ASARC) strategy.

    This strategy aims to foster and maintain cooperation for the collective good
    in the Common Pool Resource Game. It balances immediate payoffs with
    long-term resource sustainability by adapting its behavior based on
    observed actions of other players and the state of the shared resource (stock).

    Key principles:
    1.  Start Cooperative.
    2.  Monitor collective behavior and resource stock.
    3.  Punish significant defection to deter exploitation.
    4.  Forgive and restore cooperation when others demonstrate commitment.
    5.  Become more sensitive to defection when stock is low.
    6.  Prioritize immediate self-interest in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.last_round_my_action: Action | None = None
        self.in_defection_response_mode: bool = False
        self.consecutive_cooperative_rounds_after_response: int = 0
        self.CRITICAL_STOCK_THRESHOLD_RATIO: float = 0.25
        self.MAJORITY_DEFECTION_THRESHOLD_RATIO: float = 0.5
        self.MINOR_DEFECTION_TOLERANCE_COUNT: int = max(1, math.ceil(self.n_players / 4))
        self.COOPERATION_FORGIVENESS_ROUNDS: int = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        if current_round_number == self.n_rounds - 1:
            self.last_round_my_action = Action.D
            return Action.D
        if current_round_number == 0:
            self.last_round_my_action = Action.C
            self.in_defection_response_mode = False
            self.consecutive_cooperative_rounds_after_response = 0
            return Action.C
        opponent_cooperators_prev_round = int(np.sum(history.opponent_actions[-1, :]))
        opponent_defectors_prev_round = self.n_players - 1 - opponent_cooperators_prev_round
        my_action_prev_round_bool = history.my_actions[-1]
        my_action_prev_round_enum = Action.C if my_action_prev_round_bool else Action.D
        total_defectors_prev_round = opponent_defectors_prev_round + (1 if my_action_prev_round_enum == Action.D else 0)
        significant_defection_observed_in_prev_round = False
        current_stock = state.current_stock
        if current_stock < self.capacity * self.CRITICAL_STOCK_THRESHOLD_RATIO and total_defectors_prev_round > 0:
            significant_defection_observed_in_prev_round = True
        elif total_defectors_prev_round >= math.ceil(self.n_players * self.MAJORITY_DEFECTION_THRESHOLD_RATIO):
            significant_defection_observed_in_prev_round = True
        elif opponent_defectors_prev_round > self.MINOR_DEFECTION_TOLERANCE_COUNT:
            significant_defection_observed_in_prev_round = True
        if self.in_defection_response_mode and my_action_prev_round_enum == Action.D and (opponent_defectors_prev_round == 0):
            self.in_defection_response_mode = False
            self.consecutive_cooperative_rounds_after_response = 0
        elif significant_defection_observed_in_prev_round:
            self.in_defection_response_mode = True
            self.consecutive_cooperative_rounds_after_response = 0
        elif self.in_defection_response_mode:
            if opponent_defectors_prev_round == 0:
                self.consecutive_cooperative_rounds_after_response += 1
            else:
                self.consecutive_cooperative_rounds_after_response = 0
            if self.consecutive_cooperative_rounds_after_response >= self.COOPERATION_FORGIVENESS_ROUNDS:
                self.in_defection_response_mode = False
                self.consecutive_cooperative_rounds_after_response = 0
        current_round_action = Action.C
        if self.in_defection_response_mode:
            current_round_action = Action.D
        else:
            current_round_action = Action.C
        self.last_round_my_action = current_round_action
        return current_round_action

class Strategy_COLLECTIVE_312(BaseStrategy):
    """
    Adaptive Sustainability strategy for the Common Pool Resource Game.
    This strategy aims to balance the collective good of resource preservation
    with robustness against exploitation in a competitive tournament environment.
    It operates on principles of initial trust, reciprocal cooperation,
    and a strong override for critical resource depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.STOCK_CRITICAL_THRESHOLD = max(capacity / 4, 2 * n)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if state.round_number == 0:
            return Action.C
        if state.round_number == r - 1:
            return Action.D
        is_stock_critically_low = state.current_stock < self.STOCK_CRITICAL_THRESHOLD
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        num_defectors_among_others_last_round = np.sum(previous_round_opponent_actions == False)
        if is_stock_critically_low:
            return Action.C
        elif num_defectors_among_others_last_round > 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_313(BaseStrategy):
    """
    The Adaptive Collective Sustainer (ACS) strategy promotes and sustains cooperation in the
    Common Pool Resource Game. It combines a pro-social default with a robust mechanism for
    dealing with defection, adapting its strictness based on the current state of the common pool.

    ACS starts by cooperating and retaliates against significant defection to prevent exploitation.
    It demonstrates forgiveness to allow for the re-establishment of cooperative behavior.
    A key feature is its adaptive nature, becoming more stringent in demanding cooperation
    when the resource is under threat. In the final round, it defects to prevent last-round exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.LOW_STOCK_PERCENTAGE_THRESHOLD = 0.5
        if self.n_players <= 3:
            self.COOPERATION_TOLERANCE_HIGH_STOCK = 0.5
        else:
            self.COOPERATION_TOLERANCE_HIGH_STOCK = (self.n_players - 2) / (self.n_players - 1)
        self.COOPERATION_TOLERANCE_LOW_STOCK = 1.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.total_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        num_C_others = np.sum(history.opponent_actions[-1, :])
        num_opponents = self.n_players - 1
        cooperation_rate_others = num_C_others / num_opponents
        active_threshold: float
        if current_stock < self.capacity * self.LOW_STOCK_PERCENTAGE_THRESHOLD:
            active_threshold = self.COOPERATION_TOLERANCE_LOW_STOCK
        else:
            active_threshold = self.COOPERATION_TOLERANCE_HIGH_STOCK
        if cooperation_rate_others >= active_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_314(BaseStrategy):
    """
    Adaptive Resource Steward (ARS) strategy for the Common Pool Resource Game.

    This strategy aims to maximize total payoff by sustaining the common pool
    resource. It starts cooperatively, is forgiving of minor defections when
    the resource is healthy, but quickly retaliates against significant
    exploitation. If the resource itself is in severe peril due to collective
    actions, it prioritizes self-preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.STOCK_CRITICAL_THRESHOLD = self.game_description.capacity / 4.0
        if self.game_description.n_players == 2:
            self.DEFECTION_TOLERANCE_THRESHOLD = 0
        else:
            self.DEFECTION_TOLERANCE_THRESHOLD = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        num_opponent_cooperators_prev_round = np.sum(history.opponent_actions[-1, :])
        num_opponent_defectors_prev_round = self.game_description.n_players - 1 - num_opponent_cooperators_prev_round
        my_action_prev_round_is_D = not history.my_actions[-1]
        num_defectors_prev_round = num_opponent_defectors_prev_round
        if my_action_prev_round_is_D:
            num_defectors_prev_round += 1
        if state.current_stock < self.STOCK_CRITICAL_THRESHOLD:
            return Action.D
        if num_defectors_prev_round > self.DEFECTION_TOLERANCE_THRESHOLD:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_315(BaseStrategy):
    """
    The Adaptive Collective Steward aims to foster a sustainable cooperative equilibrium.
    It starts by cooperating, expecting others to do the same. It is quick to punish
    defection to deter free-riding but offers a pathway to forgiveness to re-establish
    cooperation. Crucially, when the resource is under severe threat, it prioritizes
    resource preservation above all else. Finally, it recognizes the end-game dynamics
    of repeated games and adapts accordingly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOP_THRESHOLD: int = 0
        self.CRITICAL_STOCK_RATIO: float = 0.4
        self.FORGIVENESS_ROUNDS: int = 2
        self.ENDGAME_ROUNDS: int = 2
        self.my_previous_action: Action = Action.C
        self.rounds_since_all_others_cooperated: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round == 0:
            self.my_previous_action = Action.C
            self.rounds_since_all_others_cooperated = 0
            return Action.C
        defection_count_others_prev_round = np.sum(~history.opponent_actions[-1, :])
        if defection_count_others_prev_round == 0:
            self.rounds_since_all_others_cooperated += 1
        else:
            self.rounds_since_all_others_cooperated = 0
        chosen_action: Action
        remaining_rounds = total_rounds - current_round
        if remaining_rounds <= self.ENDGAME_ROUNDS:
            chosen_action = Action.D
        elif current_stock < capacity * self.CRITICAL_STOCK_RATIO:
            chosen_action = Action.C
        elif self.my_previous_action == Action.D and defection_count_others_prev_round == 0 and (self.rounds_since_all_others_cooperated >= self.FORGIVENESS_ROUNDS):
            chosen_action = Action.C
        elif defection_count_others_prev_round > self.COOP_THRESHOLD:
            chosen_action = Action.D
        else:
            chosen_action = Action.C
        self.my_previous_action = chosen_action
        return chosen_action

class Strategy_COLLECTIVE_316(BaseStrategy):
    """
    Adaptive Stock-Guard Reciprocity: Prioritizes long-term resource sustainability through
    adaptive cooperation and punishment. It starts by cooperating, defects in the final round,
    and during intermediate rounds, its behavior is governed by the resource's health and
    other players' past actions. When the stock is critically low, it demands strict cooperation
    and punishes any defection. In normal stock situations, it reciprocates defection but
    allows for forgiveness after a period of sustained cooperation from others.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_critical_threshold_ratio = 0.25
        self.max_minor_defectors_tolerated = 0
        self.cooperation_reset_rounds = 2
        self.my_current_stance: str = 'Cooperate'
        self.consecutive_all_others_coop_rounds: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round == 0:
            self.my_current_stance = 'Cooperate'
            self.consecutive_all_others_coop_rounds = 0
            return Action.C
        if current_round == total_rounds - 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        num_defectors_others_last_round = np.sum(~previous_round_opponent_actions)
        all_others_cooperated_last_round = num_defectors_others_last_round == 0
        if all_others_cooperated_last_round:
            self.consecutive_all_others_coop_rounds += 1
        else:
            self.consecutive_all_others_coop_rounds = 0
        stock_health_ratio = current_stock / capacity
        if stock_health_ratio < self.stock_critical_threshold_ratio:
            if all_others_cooperated_last_round:
                self.my_current_stance = 'Cooperate'
                return Action.C
            else:
                self.my_current_stance = 'Defect'
                return Action.D
        elif self.my_current_stance == 'Defect':
            if self.consecutive_all_others_coop_rounds >= self.cooperation_reset_rounds:
                self.my_current_stance = 'Cooperate'
                return Action.C
            else:
                return Action.D
        elif num_defectors_others_last_round <= self.max_minor_defectors_tolerated:
            return Action.C
        else:
            self.my_current_stance = 'Defect'
            return Action.D

class Strategy_COLLECTIVE_317(BaseStrategy):
    """
    Adaptive Stock-Aware Conditional Cooperation:
    This strategy aims to foster cooperation for sustainable resource management while being
    resilient to opportunistic behavior. It starts cooperatively, then dynamically adjusts
    its willingness to cooperate based on the observed cooperation level of other players
    and the current health of the common stock. It becomes stricter (requires more
    cooperation from others) as the stock depletes and more lenient when the stock is abundant.
    It defects in the final round to maximize individual payoff when no future consequences exist.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        k_last_round = int(history.my_actions[-1]) + np.sum(history.opponent_actions[-1, :])
        cooperation_rate_observed = k_last_round / self.n_players
        CRITICAL_STOCK_THRESHOLD = self.capacity * 0.25
        LOW_STOCK_THRESHOLD = self.capacity * 0.5
        MEDIUM_STOCK_THRESHOLD = self.capacity * 0.75
        if current_stock <= CRITICAL_STOCK_THRESHOLD:
            if cooperation_rate_observed >= 0.75:
                return Action.C
            else:
                return Action.D
        elif current_stock <= LOW_STOCK_THRESHOLD:
            if cooperation_rate_observed >= 0.5:
                return Action.C
            else:
                return Action.D
        elif current_stock <= MEDIUM_STOCK_THRESHOLD:
            if cooperation_rate_observed >= 0.25:
                return Action.C
            else:
                return Action.D
        elif cooperation_rate_observed >= 1 / self.n_players:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_318(BaseStrategy):
    """
    Adaptive Resource Steward strategy for the Common Pool Resource Game.

    This strategy balances collective cooperation with self-preservation by adapting
    its actions based on the common stock level and observed past actions of all players.
    It aims to establish cooperation, maintain it as long as possible, punish significant
    defection, and incorporate forgiveness for minor deviations, especially when the
    resource is healthy. It becomes more strict as the resource depletes and defects
    in the final round to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.TOLERATED_DEFECTORS = 0 if self.n_players == 2 else 1
        self.STOCK_RECOVER_THRESHOLD = 0.75 * self.capacity
        self.STOCK_CRITICAL_THRESHOLD = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        current_round_1_indexed = current_round_0_indexed + 1
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        my_prev_action = history.my_actions[current_round_0_indexed - 1]
        opponent_prev_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        all_prev_actions = np.concatenate(([my_prev_action], opponent_prev_actions))
        D_count_prev = self.n_players - np.sum(all_prev_actions)
        if current_stock >= self.STOCK_RECOVER_THRESHOLD:
            if D_count_prev > self.TOLERATED_DEFECTORS:
                return Action.D
            else:
                return Action.C
        elif current_stock >= self.STOCK_CRITICAL_THRESHOLD:
            if D_count_prev > 0:
                return Action.D
            else:
                return Action.C
        elif D_count_prev > 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_319(BaseStrategy):
    """
    Adaptive Collective Stewardship (ACS) strategy.
    Aims to maximize collective long-term welfare by fostering sustainable resource management
    through conditional cooperation and immediate response to defection, with an emergency
    override for critical stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOPERATION_THRESHOLD: float = 1.0
        self.FORGIVENESS_ROUNDS: int = 0
        self.STOCK_RECOVERY_THRESHOLD: float = self.game_description.capacity / 4.0
        self.consecutive_non_coop_rounds: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        if current_round_number_0_indexed == 0:
            self.consecutive_non_coop_rounds = 0
            return Action.C
        if current_round_number_0_indexed == total_rounds - 1:
            return Action.D
        num_C_prev = np.sum(history.opponent_actions[-1, :])
        ACR_prev = float(num_C_prev) / n_players
        if current_stock < self.STOCK_RECOVERY_THRESHOLD:
            self.consecutive_non_coop_rounds = 0
            return Action.C
        elif ACR_prev < self.COOPERATION_THRESHOLD:
            self.consecutive_non_coop_rounds += 1
            if self.consecutive_non_coop_rounds > self.FORGIVENESS_ROUNDS:
                return Action.D
            else:
                return Action.C
        else:
            self.consecutive_non_coop_rounds = 0
            return Action.C

class Strategy_COLLECTIVE_320(BaseStrategy):
    """
    Adaptive Resource Guardian (ARG) strategy for the Common Pool Resource game.
    Aims to promote long-term resource sustainability through conditional cooperation,
    responding to defections, managing resource levels, and handling the game's
    finite horizon by anticipating endgame unraveling.
    """

    class PlayerState(Enum):
        COOPERATE_MODE = 1
        PUNISH_MODE = 0

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.my_internal_state: Strategy.PlayerState = self.PlayerState.COOPERATE_MODE
        self.punishment_countdown: int = 0
        self.last_round_other_defectors: int = 0
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        self.DEFECTION_TRIGGER_COUNT: int = max(1, math.floor(n / 2))
        self.PUNISHMENT_DURATION: int = 1
        self.CRITICAL_STOCK_THRESHOLD_RATIO: float = 0.3
        self.ENDGAME_UNRAVELING_START_ROUND: int = self.game_description.n_rounds - 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        if current_round_number > 0 and history is not None:
            self.last_round_other_defectors = np.sum(history.opponent_actions[-1, :] == Action.D.value).item()
            if self.my_internal_state == self.PlayerState.PUNISH_MODE:
                self.punishment_countdown -= 1
                if self.punishment_countdown <= 0:
                    self.my_internal_state = self.PlayerState.COOPERATE_MODE
            if self.my_internal_state == self.PlayerState.COOPERATE_MODE:
                if self.last_round_other_defectors >= self.DEFECTION_TRIGGER_COUNT:
                    self.my_internal_state = self.PlayerState.PUNISH_MODE
                    self.punishment_countdown = self.PUNISHMENT_DURATION
        if current_round_number == n_rounds - 1:
            return Action.D
        if current_round_number == self.ENDGAME_UNRAVELING_START_ROUND:
            return Action.D
        if capacity > 0 and current_stock / capacity < self.CRITICAL_STOCK_THRESHOLD_RATIO:
            if self.last_round_other_defectors == 0:
                return Action.C
            else:
                return Action.D
        if self.my_internal_state == self.PlayerState.PUNISH_MODE:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_321(BaseStrategy):
    """
    Adaptive Sustainability Enforcer (ASE) strategy for the Common Pool Resource Game.
    This strategy prioritizes maintaining the common pool stock at a sustainable level,
    adaptively enforcing cooperative norms, and employing a limited forgiveness mechanism
    during critical stock periods, with an end-game defection for terminal payoff maximization.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD = self.game_description.capacity / 2.0
        self.RECOVERY_PATIENCE_ROUNDS = 2
        self.num_consecutive_critical_defections = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_index = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock_S = state.current_stock
        if current_round_index == 0:
            self.num_consecutive_critical_defections = 0
            return Action.C
        opponent_actions_prev_round = history.opponent_actions[-1, :]
        k_other_defectors_prev = (~opponent_actions_prev_round).sum()
        if current_round_index == total_rounds - 1:
            return Action.D
        if current_stock_S < self.CRITICAL_STOCK_THRESHOLD:
            if k_other_defectors_prev > 0:
                self.num_consecutive_critical_defections += 1
            else:
                self.num_consecutive_critical_defections = 0
            if self.num_consecutive_critical_defections >= self.RECOVERY_PATIENCE_ROUNDS:
                return Action.D
            else:
                return Action.C
        else:
            self.num_consecutive_critical_defections = 0
            if k_other_defectors_prev >= 1:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_322(BaseStrategy):
    """
    Adaptive Forgiving Cooperator (AFC) strategy for the Common Pool Resource Game.
    This strategy aims to promote cooperation and ensure the long-term health of the common resource.
    It starts by trusting others, adapts its behavior based on observed collective actions,
    and is designed to be forgiving to encourage a return to cooperative play.
    However, it will also defend itself against exploitation and react decisively
    if the resource reaches critical levels due to widespread defection.
    """
    POST_TRIGGER_PUNISHMENT_ROUNDS: int
    CRITICAL_STOCK_FRACTION: float
    cached_defection_threshold: float
    punishment_active_until_round: int

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.POST_TRIGGER_PUNISHMENT_ROUNDS = 0
        self.CRITICAL_STOCK_FRACTION = 0.25
        self.punishment_active_until_round = 0
        n_players = self.game_description.n_players
        self.cached_defection_threshold = (n_players - 1) / n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_game_round = state.round_number + 1
        total_game_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if state.round_number == 0:
            self.punishment_active_until_round = 0
            return Action.C
        if state.round_number == total_game_rounds - 1:
            self.punishment_active_until_round = 0
            return Action.D
        if self.punishment_active_until_round >= current_game_round:
            return Action.D
        num_cooperators_prev = sum(history.opponent_actions[state.round_number - 1, :])
        if state.current_stock < self.game_description.capacity * self.CRITICAL_STOCK_FRACTION:
            if num_cooperators_prev < n_players:
                self.punishment_active_until_round = current_game_round
                return Action.D
            else:
                self.punishment_active_until_round = 0
                return Action.C
        coop_rate_prev = num_cooperators_prev / n_players
        if coop_rate_prev >= self.cached_defection_threshold:
            self.punishment_active_until_round = 0
            return Action.C
        else:
            self.punishment_active_until_round = current_game_round + self.POST_TRIGGER_PUNISHMENT_ROUNDS
            return Action.D

class Strategy_COLLECTIVE_323(BaseStrategy):
    """
    Adaptive Conditional Cooperator (ACC) strategy for the Common Pool Resource game.
    This strategy balances individual payoff maximization with collective resource
    preservation. It adapts its actions based on the current round number, the
    remaining stock level, and the observed actions of other players in the
    previous round. It prioritizes resource preservation when critical, encourages
    cooperation by reciprocating good behavior, and deters exploitation through
    punishment.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.total_rounds - 1:
            return Action.D
        if current_stock < self.critical_stock_threshold:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.C
        num_cooperating_opponents = sum(history.opponent_actions[-1, :])
        if num_cooperating_opponents >= self.n_players - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_324(BaseStrategy):
    """
    Adaptive Collective Sustain strategy for the Common Pool Resource Game.
    This strategy aims to maintain the common pool stock at its maximum sustainable level
    by fostering cooperation, deterring defection, and ensuring resource recovery.
    It employs a dynamic approach that adapts to both the current state of the resource
    and the observed behavior of other players, balancing forgiveness with the need
    to deter defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_critical_low = self.capacity / (2 * self.n)
        self.S_health_threshold = self.capacity / 2
        if self.n <= 5:
            self.Defection_Tolerance_Count = 0
        else:
            self.Defection_Tolerance_Count = max(1, math.floor(self.n * 0.1))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number + 1
        current_stock = state.current_stock
        if current_round_t == self.r:
            return Action.D
        if current_round_t == 1:
            return Action.C
        num_cooperators_prev = int(history.my_actions[-1]) + np.sum(history.opponent_actions[-1, :])
        k_D_prev = self.n - num_cooperators_prev
        if current_stock <= self.S_critical_low:
            return Action.C
        if k_D_prev == 0:
            return Action.C
        elif k_D_prev <= self.Defection_Tolerance_Count and current_stock >= self.S_health_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_325(BaseStrategy):
    """
    The AdaptiveCustodian strategy balances resource sustainability with pragmatic self-interest.
    It defaults to cooperation, becomes extremely cooperative during resource crises,
    punishes widespread defection, and exploits the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.STOCK_RECOVERY_THRESHOLD = self.capacity / 2.0
        self.DEFECTOR_PUNISHMENT_THRESHOLD = math.ceil(self.n / 3.0)
        self.COOPERATION_BOUNTY_THRESHOLD = self.capacity * 0.9

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_zero_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_zero_indexed == 0:
            return Action.C
        if current_round_zero_indexed == self.r - 1:
            return Action.D
        prev_round_opponent_actions = history.opponent_actions[-1, :]
        prev_round_my_action = history.my_actions[-1]
        num_opponent_defectors = np.sum(prev_round_opponent_actions == False)
        my_prev_action_was_D = prev_round_my_action == False
        prev_round_num_defectors = num_opponent_defectors + (1 if my_prev_action_was_D else 0)
        if current_stock < self.STOCK_RECOVERY_THRESHOLD:
            return Action.C
        elif prev_round_num_defectors >= self.DEFECTOR_PUNISHMENT_THRESHOLD:
            return Action.D
        elif current_stock >= self.COOPERATION_BOUNTY_THRESHOLD and prev_round_num_defectors == 0:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_326(BaseStrategy):
    """
    Adaptive Sustainability with Reciprocal Deterrence (ASRD) strategy.

    This strategy aims to foster long-term resource sustainability through a default
    cooperative stance, coupled with a mechanism to deter non-cooperative behavior
    and a strong bias towards resource recovery when critical. It adapts its actions
    based on the observed common pool stock level and its recent history of cooperation.
    """
    MIN_STOCK_FOR_COOPERATION_RATIO: float = 0.6
    STOCK_DECREASE_TOLERANCE_PERCENT: float = 0.05
    PUNISHMENT_DURATION_ROUNDS: int = 3

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_cooperations_made_by_us: int = 0
        self.rounds_in_punishment_mode: int = 0
        self.stock_at_start_of_previous_round: float = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        _consecutive_cooperations = self.consecutive_cooperations_made_by_us
        _rounds_in_punishment_mode = self.rounds_in_punishment_mode
        _stock_prev_round_start = self.stock_at_start_of_previous_round
        action_for_this_round: Action
        current_round_number = state.round_number
        if current_round_number == 0:
            action_for_this_round = Action.C
            _consecutive_cooperations = 1
        elif current_round_number == self.game_description.n_rounds - 1:
            action_for_this_round = Action.D
            _consecutive_cooperations = 0
            _rounds_in_punishment_mode = 0
        elif state.current_stock < self.MIN_STOCK_FOR_COOPERATION_RATIO * self.game_description.capacity:
            action_for_this_round = Action.C
            _consecutive_cooperations += 1
            _rounds_in_punishment_mode = 0
        elif _rounds_in_punishment_mode > 0:
            action_for_this_round = Action.D
            _rounds_in_punishment_mode -= 1
            _consecutive_cooperations = 0
        elif _consecutive_cooperations > 0 and state.current_stock < _stock_prev_round_start * (1 - self.STOCK_DECREASE_TOLERANCE_PERCENT):
            action_for_this_round = Action.D
            _rounds_in_punishment_mode = self.PUNISHMENT_DURATION_ROUNDS - 1
            _consecutive_cooperations = 0
        else:
            action_for_this_round = Action.C
            _consecutive_cooperations += 1
        self.consecutive_cooperations_made_by_us = _consecutive_cooperations
        self.rounds_in_punishment_mode = _rounds_in_punishment_mode
        self.stock_at_start_of_previous_round = state.current_stock
        return action_for_this_round

class Strategy_COLLECTIVE_327(BaseStrategy):
    """
    The "Adaptive Resource Guardian" (ARG) is a collective strategy designed to promote
    long-term sustainability of the common pool resource while being robust and adaptive.
    It balances cooperation with self-preservation, uses conditional punishment and forgiveness,
    and critically, prioritizes resource conservation if the stock becomes critically endangered.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.currently_punishing: bool = False
        self.punishment_rounds_left: int = 0
        self.PUNISHMENT_THRESHOLD_HEALTHY_STOCK: float = 0.25
        self.PUNISHMENT_THRESHOLD_DANGER_STOCK: float = 0.1
        self.FORGIVENESS_THRESHOLD_COOPERATION: float = 0.75
        self.CRITICAL_STOCK_RATIO: float = 0.25
        self.DANGER_STOCK_RATIO: float = 0.5
        self.DEFAULT_PUNISHMENT_DURATION: int = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_round == 0:
            self.currently_punishing = False
            self.punishment_rounds_left = 0
            return Action.C
        if current_round == total_rounds - 1:
            return Action.D
        num_others_cooperated = np.sum(history.opponent_actions[-1, :])
        other_players_count = n_players - 1
        num_others_defected = other_players_count - num_others_cooperated
        defection_ratio_others = num_others_defected / other_players_count
        cooperation_ratio_others = num_others_cooperated / other_players_count
        if current_stock < capacity * self.CRITICAL_STOCK_RATIO:
            self.currently_punishing = False
            self.punishment_rounds_left = 0
            return Action.C
        if self.currently_punishing:
            if self.punishment_rounds_left > 0:
                if cooperation_ratio_others >= self.FORGIVENESS_THRESHOLD_COOPERATION:
                    self.punishment_rounds_left -= 1
                    if self.punishment_rounds_left == 0:
                        self.currently_punishing = False
                        return Action.C
                    else:
                        return Action.D
                else:
                    return Action.D
            else:
                self.currently_punishing = False
                return Action.C
        effective_punishment_threshold = self.PUNISHMENT_THRESHOLD_HEALTHY_STOCK
        if current_stock < capacity * self.DANGER_STOCK_RATIO:
            effective_punishment_threshold = self.PUNISHMENT_THRESHOLD_DANGER_STOCK
        if defection_ratio_others > effective_punishment_threshold:
            self.currently_punishing = True
            self.punishment_rounds_left = self.DEFAULT_PUNISHMENT_DURATION
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_328(BaseStrategy):
    """
    The Adaptive Conservationist strategy prioritizes long-term resource sustainability,
    adapting to current stock levels and collective behavior. It starts cooperative,
    enforces strict conservation in emergencies, tolerates minor defection, and defects
    in the final round for self-preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.S_CRITICAL_THRESHOLD = capacity / (n + 1)
        self.DEFECTION_TOLERANCE_COUNT = math.floor(n / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        if current_round == 0:
            return Action.C
        elif current_round == total_rounds - 1:
            return Action.D
        else:
            if current_stock < self.S_CRITICAL_THRESHOLD:
                return Action.C
            prev_round_idx = current_round - 1
            my_prev_action_was_D = not history.my_actions[prev_round_idx]
            opponent_defections_prev = np.sum(~history.opponent_actions[prev_round_idx, :])
            k_D_prev = (1 if my_prev_action_was_D else 0) + opponent_defections_prev
            if k_D_prev > self.DEFECTION_TOLERANCE_COUNT:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_329(BaseStrategy):
    """
    Adaptive Steward: A strategy for the Common Pool Resource Game that prioritizes resource health,
    employs reciprocal cooperation, and retaliates defensively against widespread defection,
    with an end-game rational defect.
    """
    _CRITICAL_STOCK_THRESHOLD_PERCENT = 0.1
    _LOW_STOCK_THRESHOLD_PERCENT = 0.4
    _COOPERATION_THRESHOLD_MAJORITY = 0.5

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_level = self.capacity * self._CRITICAL_STOCK_THRESHOLD_PERCENT
        self.low_stock_level = self.capacity * self._LOW_STOCK_THRESHOLD_PERCENT
        self.cooperation_threshold_minor = (self.n_players - 1) / self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        all_actions_prev_round = np.concatenate((np.array([history.my_actions[-1]]), history.opponent_actions[-1, :]))
        num_cooperators_prev = np.sum(all_actions_prev_round)
        cooperation_rate_prev = num_cooperators_prev / self.n_players
        if state.current_stock <= self.critical_stock_level:
            return Action.C
        if cooperation_rate_prev >= self.cooperation_threshold_minor:
            return Action.C
        elif cooperation_rate_prev >= self._COOPERATION_THRESHOLD_MAJORITY:
            if state.current_stock <= self.low_stock_level:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_330(BaseStrategy):
    """
    Steward aims to promote sustainable resource management by initiating cooperation
    and responding proportionally to the collective's behavior. It acts as a responsible
    steward of the resource, but will not allow itself to be exploited indefinitely.
    It adapts its behavior based on observed defection levels and the health of the
    common stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_tolerance_threshold = max(1, round(self.n_players / 4))
        self.critical_stock_threshold = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        num_opponent_cooperators_prev = sum(history.opponent_actions[-1, :])
        num_opponent_defectors_prev = self.n_players - 1 - num_opponent_cooperators_prev
        my_defected_prev = 1 if not history.my_actions[-1] else 0
        k_D_prev = num_opponent_defectors_prev + my_defected_prev
        if state.current_stock <= self.critical_stock_threshold:
            return Action.D
        elif k_D_prev >= self.defection_tolerance_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_331(BaseStrategy):
    """
    Adaptive Trust-Based Sustainability (ATBS) strategy balances collective sustainability
    with individual robustness. It uses a dynamic Collective Cooperation Index (cci) to
    assess the group's behavior, adapting its actions based on the common pool's health
    and perceived trust. It starts cooperative, monitors stock changes against an
    ideal cooperative scenario, and adjusts trust. It defects if trust is low, or if the
    resource is critically depleted, and always defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cci: float = 1.0
        self.stock_at_start_of_previous_round: float = game_description.capacity
        self.learning_rate_increase: float = 0.1
        self.learning_rate_decrease: float = 0.2
        self.cooperation_threshold: float = 0.7
        self.minimum_viable_stock_ratio: float = 0.25
        self.epsilon: float = 1e-06

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num = state.round_number
        current_stock_level = state.current_stock
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if current_round_num == 0:
            action = Action.C
            self.stock_at_start_of_previous_round = current_stock_level
            return action
        if current_round_num == n_rounds - 1:
            action = Action.D
            return action
        s_prev_start = self.stock_at_start_of_previous_round
        s_prev_after_c = s_prev_start / 2.0
        growth_if_all_c = 2.0 * s_prev_after_c * (1.0 - s_prev_after_c / capacity)
        expected_s_if_all_c_prev_round = min(s_prev_after_c + growth_if_all_c, capacity)
        if current_stock_level >= expected_s_if_all_c_prev_round - self.epsilon:
            self.cci = min(1.0, self.cci + self.learning_rate_increase)
        else:
            self.cci = max(0.0, self.cci - self.learning_rate_decrease)
        self.stock_at_start_of_previous_round = current_stock_level
        minimum_viable_stock_level = capacity * self.minimum_viable_stock_ratio
        if current_stock_level < minimum_viable_stock_level:
            action = Action.D
        elif self.cci >= self.cooperation_threshold:
            action = Action.C
        else:
            action = Action.D
        return action

class Strategy_COLLECTIVE_332(BaseStrategy):
    """
    The Adaptive Collective Sustainer (ACS) strategy for the Common Pool Resource Game.

    ACS aims to cultivate a sustainable common pool resource by promoting cooperation,
    while remaining robust against opportunistic opponents in a tournament setting.
    It prioritizes long-term resource health through conditional cooperation,
    striving to stabilize the stock at or near its capacity. ACS uses an adaptive
    mechanism to reward collective cooperation, deter widespread defection, and
    ensure its viability against self-interested players. It leads by example,
    forgives minor infractions, but responds firmly to significant threats to
    the resource or widespread exploitation, and defects in the endgame for self-preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the ACS strategy with game parameters.

        Args:
            game_description: An object containing n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.critical_stock_threshold = self.game_description.capacity / 4.0
        self.n_opponents = self.game_description.n_players - 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: The current state of the game, including round_number and current_stock.
            history: A PlayerHistory object containing past actions and payoffs, or None for round 0.

        Returns:
            An Action enum (Action.C for Cooperate, Action.D for Defect).
        """
        current_round = state.round_number + 1
        if current_round == 1:
            return Action.C
        if self.game_description.n_rounds - current_round < 2:
            return Action.D
        num_cooperators_among_opponents = np.sum(history.opponent_actions[-1, :])
        num_D_others = self.n_opponents - num_cooperators_among_opponents
        if state.current_stock < self.critical_stock_threshold:
            if num_D_others == 0:
                return Action.C
            else:
                return Action.D
        elif num_D_others == 0:
            return Action.C
        elif num_D_others < self.game_description.n_players / 2.0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_333(BaseStrategy):
    """
    Adaptive Collective Steward (ACS) strategy for the Common Pool Resource Game.

    This strategy aims to foster and maintain collective cooperation for long-term
    sustainability of the common pool resource. It is adaptive to opponent behaviors
    and prioritizes the health of the shared resource, while also making rational
    self-preservation decisions when cooperation fails or in the end-game.

    Key features:
    - Starts with cooperation to establish a positive baseline.
    - Continues cooperation if a high enough fraction of players cooperated previously.
    - Responds to insufficient cooperation by defecting, acting as a deterrent.
    - Adjusts behavior based on the critically low stock levels.
    - Attempts a last-ditch cooperative effort in crisis if a majority still cooperates.
    - Defaults to self-preservation (defection) in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold: float = 0.75
        self.stock_critical_ratio: float = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == total_rounds:
            return Action.D
        num_C_last_round = np.sum(history.opponent_actions[-1, :]) + history.my_actions[-1]
        num_D_last_round = n - num_C_last_round
        if num_C_last_round / n >= self.cooperation_threshold:
            return Action.C
        elif current_stock <= self.stock_critical_ratio * capacity:
            if num_C_last_round > num_D_last_round:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_334(BaseStrategy):
    """
    Adaptive Collective Steward (ACS) strategy for the Common Pool Resource Game.
    It balances individual rationality with collective stewardship, adapting its behavior
    based on the current state of the resource and the observed actions of other players.

    The strategy initializes by signaling cooperation. In intermediate rounds, it
    monitors the resource health:
    - If the resource is critically low, it defects to maximize immediate returns,
      as recovery is deemed unlikely.
    - If the resource is low but not critical ("Resource Recovery Mode"), it tries to
      lead with cooperation if it defected previously, or cooperates if enough
      others are also cooperating (using a more forgiving threshold). If cooperation
      is insufficient and it had cooperated, it punishes by defecting.
    - If the resource is healthy ("Healthy Stock Mode"), it strictly requires a high
      level of cooperation from others to continue cooperating; otherwise, it defects
      to punish free-riding.
    In the final round, it always defects, as there are no future consequences for the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.LOW_STOCK_THRESHOLD_RATIO = 0.6
        self.CRITICAL_STOCK_THRESHOLD_RATIO = 1.0 / (2.0 * self.n)
        self.STRICT_COOPERATION_RATIO = 0.75
        self.FORGIVING_COOPERATION_RATIO = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.r:
            return Action.D
        last_round_cooperators = np.sum(history.opponent_actions[state.round_number - 1])
        last_round_cooperators += history.my_actions[state.round_number - 1]
        last_round_my_action = Action.C if history.my_actions[state.round_number - 1] else Action.D
        if current_stock <= self.capacity * self.CRITICAL_STOCK_THRESHOLD_RATIO:
            return Action.D
        elif current_stock < self.capacity * self.LOW_STOCK_THRESHOLD_RATIO:
            required_cooperators = math.ceil(self.n * self.FORGIVING_COOPERATION_RATIO)
            if last_round_cooperators >= required_cooperators:
                return Action.C
            elif last_round_my_action == Action.D:
                return Action.C
            else:
                return Action.D
        else:
            required_cooperators = math.ceil(self.n * self.STRICT_COOPERATION_RATIO)
            if last_round_cooperators >= required_cooperators:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_335(BaseStrategy):
    """
    Stock-Adaptive Forgiving Tit-for-Tat (SAFT) strategy for the Common Pool Resource Game.

    This strategy aims to maximize collective long-term payoff by promoting sustainable
    resource use. It adapts its decision based on current resource stock, observed
    actions of other players, and the stage of the game (early, mid, or end-game).

    Core Principles:
    1.  Initial Cooperation: Start by cooperating to signal a willingness to build a
        sustainable collective.
    2.  Conditional Reciprocity: Reward collective cooperation by cooperating, and
        punish widespread defection by defecting.
    3.  Forgiveness: Tolerate minor defection to avoid spiraling into perpetual
        conflict, especially in larger groups.
    4.  Stock Awareness: Prioritize resource recovery by cooperating when the common
        pool resource is critically low, recognizing that collective collapse benefits
        no one.
    5.  End-Game Adaptation: Adjust behavior in the final rounds to account for the
        increased incentive for defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the SAFT strategy with game parameters.

        Args:
            game_description: An object containing n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.forgiveness_count = 0 if n == 2 else 1
        self.critical_stock_threshold = capacity / 2.0
        self.end_game_rounds = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round based on
        the SAFT strategy logic.

        Args:
            state: The current state of the game, including round_number and current_stock.
            history: A record of previous actions and payoffs for all players.
                     None for the very first round (round_number = 0).

        Returns:
            Action.C for Cooperate or Action.D for Defect.
        """
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round_t = state.round_number + 1
        if current_round_t == 1:
            return Action.C
        prev_round_idx = state.round_number - 1
        my_prev_action_bool = history.my_actions[prev_round_idx]
        opponent_prev_actions_bool = history.opponent_actions[prev_round_idx, :]
        num_cooperators_prev = int(my_prev_action_bool) + np.sum(opponent_prev_actions_bool)
        k_D_prev = n - num_cooperators_prev
        if current_round_t > r - self.end_game_rounds:
            if k_D_prev == 0:
                return Action.C
            else:
                return Action.D
        elif state.current_stock < self.critical_stock_threshold:
            if k_D_prev == n:
                return Action.D
            else:
                return Action.C
        elif k_D_prev <= self.forgiveness_count:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_336(BaseStrategy):
    """
    The Adaptive Resource Steward (ARS) strategy aims to foster sustainable resource management within a common pool
    resource game. It uses conditional cooperation, measured punishment for defection, and an overriding commitment
    to resource recovery when the stock is critically low. This strategy adapts its actions based on observed
    history and the current state of the shared resource.
    """

    class StrategyState(Enum):
        COOPERATE_DEFAULT = 1
        PUNISHING = 2
        RECOVERING = 3

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOPERATION_THRESHOLD = 0.75
        self.RECOVERY_THRESHOLD_FACTOR = 0.3
        self.PUNISHMENT_THRESHOLD_ROUNDS = 2
        self.REVERSION_COOPERATION_ROUNDS = 1
        self.my_current_strategy_state = self.StrategyState.COOPERATE_DEFAULT
        self.my_last_action_recorded_internally = Action.C
        self.observed_others_defection_rounds_streak = 0
        self.observed_others_cooperation_rounds_streak = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_round_num_0_indexed == 0:
            self.my_current_strategy_state = self.StrategyState.COOPERATE_DEFAULT
            self.my_last_action_recorded_internally = Action.C
            self.observed_others_defection_rounds_streak = 0
            self.observed_others_cooperation_rounds_streak = 0
            return Action.C
        if current_round_num_0_indexed == total_rounds - 1:
            next_action = Action.D
            self.my_last_action_recorded_internally = next_action
            return next_action
        prev_round_idx = current_round_num_0_indexed - 1
        num_cooperators_total_prev_round = history.my_actions[prev_round_idx] + np.sum(history.opponent_actions[prev_round_idx, :])
        my_prev_action_was_cooperate = self.my_last_action_recorded_internally == Action.C
        num_others_cooperated = num_cooperators_total_prev_round - (1 if my_prev_action_was_cooperate else 0)
        others_cooperation_ratio = num_others_cooperated / (n_players - 1)
        if others_cooperation_ratio < self.COOPERATION_THRESHOLD:
            self.observed_others_defection_rounds_streak += 1
            self.observed_others_cooperation_rounds_streak = 0
        else:
            self.observed_others_cooperation_rounds_streak += 1
            self.observed_others_defection_rounds_streak = 0
        next_action: Action = Action.C
        if current_stock < self.RECOVERY_THRESHOLD_FACTOR * capacity:
            self.my_current_strategy_state = self.StrategyState.RECOVERING
            next_action = Action.C
        else:
            if self.my_current_strategy_state == self.StrategyState.RECOVERING:
                self.my_current_strategy_state = self.StrategyState.COOPERATE_DEFAULT
            if self.my_current_strategy_state == self.StrategyState.PUNISHING and self.observed_others_cooperation_rounds_streak >= self.REVERSION_COOPERATION_ROUNDS:
                self.my_current_strategy_state = self.StrategyState.COOPERATE_DEFAULT
                next_action = Action.C
            elif self.my_current_strategy_state == self.StrategyState.COOPERATE_DEFAULT and self.observed_others_defection_rounds_streak >= self.PUNISHMENT_THRESHOLD_ROUNDS:
                self.my_current_strategy_state = self.StrategyState.PUNISHING
                next_action = Action.D
            elif self.my_current_strategy_state == self.StrategyState.PUNISHING:
                next_action = Action.D
        self.my_last_action_recorded_internally = next_action
        return next_action

class Strategy_COLLECTIVE_337(BaseStrategy):
    """
    The Adaptive Resource Steward strategy prioritizes long-term resource sustainability
    by defaulting to cooperation. It adapts to opponent behavior using a Tit-for-Tat
    mechanism and defends against critical resource depletion by defecting when stock is low.
    It defects in the final round to maximize terminal payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number + 1
        current_stock = state.current_stock
        if round_t == 1:
            return Action.C
        if round_t == self.n_rounds:
            return Action.D
        num_opponent_defect_prev_round = np.sum(history.opponent_actions[-1, :] == False)
        if current_stock < self.capacity / 4.0:
            return Action.D
        elif num_opponent_defect_prev_round > 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_338(BaseStrategy):
    """
    The Collective Resource Guardian strategy for the Common Pool Resource Game.
    It promotes collective well-being by prioritizing resource conservation,
    starts cooperatively, and employs adaptive reciprocity to deter exploitation.
    It features a critical stock protection override and a rational endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_index = state.round_number
        current_stock = state.current_stock
        if current_round_index == 0:
            return Action.C
        if current_round_index == self.n_rounds - 1:
            return Action.D
        d_count_others = np.sum(~history.opponent_actions[-1, :])
        punishment_threshold = 0
        if self.n_players > 2:
            punishment_threshold = 1
        if current_stock < self.capacity / (2.0 * self.n_players):
            return Action.C
        elif d_count_others <= punishment_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_339(BaseStrategy):
    """
    The "Adaptive Conservationist" strategy is designed to promote collective sustainability
    in the Common Pool Resource Game while remaining robust and adaptive to varying opponent
    behaviors. It balances the pursuit of collective welfare with the necessity of
    self-preservation in a non-cooperative environment.

    Core Principles:
    1. Proactive Cooperation: Begin by cooperating.
    2. Resource-Driven Adaptation: Monitor stock level.
    3. Defensive Defection: Defect if stock drops below a critical threshold.
    4. Forgiving Recovery: Re-establish cooperation if stock recovers.
    5. Endgame Rationality: Prioritize individual gain in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.N = game_description.n_players
        self.R = game_description.n_rounds
        self.CAPACITY = float(game_description.capacity)
        self.S_RECOVERY_THRESHOLD = self.CAPACITY / 2.0
        self.S_COOPERATION_THRESHOLD = self.CAPACITY * (1.0 - 1.0 / (2.0 * self.N))
        self.cooperation_mode_active: bool = True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock_level = state.current_stock
        if current_round_number == 0:
            self.cooperation_mode_active = True
            return Action.C
        if current_round_number == self.R - 1:
            return Action.D
        if not self.cooperation_mode_active:
            if current_stock_level >= self.S_RECOVERY_THRESHOLD:
                self.cooperation_mode_active = True
        if self.cooperation_mode_active:
            if current_stock_level >= self.S_COOPERATION_THRESHOLD:
                return Action.C
            else:
                self.cooperation_mode_active = False
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_340(BaseStrategy):
    """
    The Adaptive Conservationist (AC) strategy for the Common Pool Resource Game.
    This strategy is designed to balance individual rationality with collective resource sustainability.
    It initiates with cooperation, maintains conditional cooperation based on past behavior,
    prioritizes aggressive conservation when the resource stock is critically low,
    and adopts a self-interested approach in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = 0.25 * self.capacity
        self.defection_tolerance_threshold = math.floor(self.n / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        r_remaining = self.r - current_round_number
        if current_round_number == 0:
            return Action.C
        if r_remaining == 1:
            return Action.D
        my_defection_last_round = int(not history.my_actions[-1])
        opponent_defections_last_round = np.sum(~history.opponent_actions[-1, :])
        defection_count_last_round = my_defection_last_round + opponent_defections_last_round
        if current_stock < self.critical_stock_threshold:
            return Action.C
        elif defection_count_last_round <= self.defection_tolerance_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_341(BaseStrategy):
    """
    Adaptive Sustainability with Forgiving Punishment (ASFP) strategy for the Common Pool Resource Game.

    This strategy prioritizes the long-term health of the common resource while being adaptive to opponent
    behavior and defending against exploitation. It aims to foster cooperation through initial signals
    and forgiveness, but will escalate to defection if cooperation breaks down or the resource is severely
    threatened by widespread defection. It infers past defection counts from observable outcomes
    (payoffs and own actions) to make decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.is_in_emergency_mode: bool = False
        self.last_observed_defectors_count: int = 0
        self.initial_cooperation_rounds: int = min(3, self.n_rounds // 2)
        self.tolerance_ratio_for_defection: float = 0.5
        self.critical_stock_fraction: float = 0.3
        self.recovery_stock_fraction: float = 0.6
        self.emergency_defection_threshold_ratio: float = 0.75

    def _calculate_num_defectors_from_prev_round_history(self, my_prev_action_is_C: bool, my_prev_payoff: float, opponent_prev_actions: NDArray[np.bool_]) -> int:
        n = self.n_players
        capacity = self.capacity
        S_prev = 0.0
        if my_prev_payoff < 1e-09:
            S_prev = 0.0
        elif my_prev_action_is_C:
            S_prev = my_prev_payoff * (2 * n)
        else:
            S_prev = my_prev_payoff * n
        S_prev = min(S_prev, capacity)
        S_prev = max(0.0, S_prev)
        if S_prev < 1e-09:
            return 0
        total_consumption_prev = 0.0
        if my_prev_action_is_C:
            total_consumption_prev += S_prev / (2 * n)
        else:
            total_consumption_prev += S_prev / n
        num_opponent_cooperators = np.sum(opponent_prev_actions)
        num_opponent_defectors = n - 1 - num_opponent_cooperators
        total_consumption_prev += num_opponent_cooperators * (S_prev / (2 * n))
        total_consumption_prev += num_opponent_defectors * (S_prev / n)
        num_defectors_float = 2 * total_consumption_prev * n / S_prev - n
        num_defectors = round(num_defectors_float)
        return max(0, min(n, num_defectors))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.n_players
        r = self.n_rounds
        capacity = self.capacity
        current_round_1_indexed = state.round_number + 1
        if state.round_number > 0:
            self.last_observed_defectors_count = self._calculate_num_defectors_from_prev_round_history(my_prev_action_is_C=history.my_actions[-1], my_prev_payoff=history.my_payoffs[-1], opponent_prev_actions=history.opponent_actions[-1, :])
        else:
            self.last_observed_defectors_count = 0
        if current_round_1_indexed == r:
            return Action.D
        if state.current_stock < self.critical_stock_fraction * capacity:
            self.is_in_emergency_mode = True
        elif state.current_stock >= self.recovery_stock_fraction * capacity and self.is_in_emergency_mode:
            self.is_in_emergency_mode = False
        if self.is_in_emergency_mode:
            if self.last_observed_defectors_count > n * self.emergency_defection_threshold_ratio:
                return Action.D
            else:
                return Action.C
        elif current_round_1_indexed <= self.initial_cooperation_rounds:
            return Action.C
        elif self.last_observed_defectors_count > n * self.tolerance_ratio_for_defection:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_342(BaseStrategy):
    """
    The Adaptive Collective Sentinel (ACS) strategy for the Common Pool Resource Game.
    It prioritizes long-term resource health through initial cooperation,
    an "Emergency" mode for resource preservation, and a forgiving yet firm
    reciprocal punishment mechanism. It also incorporates self-preservation
    by defecting in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.my_mode: str = 'COOPERATE'
        self.rounds_to_punish_remaining: int = 0
        self.CRITICAL_STOCK_THRESHOLD: float = self.game_description.capacity * 0.25
        self.PUNISHMENT_ROUNDS_DEFAULT: int = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_actual: int = state.round_number + 1
        total_rounds: int = self.game_description.n_rounds
        current_stock: float = state.current_stock
        n_players: int = self.game_description.n_players
        if state.round_number == 0:
            self.my_mode = 'COOPERATE'
            self.rounds_to_punish_remaining = 0
            return Action.C
        previous_opponent_actions = history.opponent_actions[-1, :]
        num_defectors_last_round = np.sum(~previous_opponent_actions)
        if self.my_mode == 'PUNISH':
            self.rounds_to_punish_remaining -= 1
            if self.rounds_to_punish_remaining <= 0:
                if num_defectors_last_round == 0:
                    self.my_mode = 'COOPERATE'
                    self.rounds_to_punish_remaining = 0
                else:
                    self.my_mode = 'PUNISH'
                    self.rounds_to_punish_remaining = self.PUNISHMENT_ROUNDS_DEFAULT
        elif self.my_mode == 'COOPERATE' or self.my_mode == 'EMERGENCY':
            if num_defectors_last_round > 0:
                self.my_mode = 'PUNISH'
                self.rounds_to_punish_remaining = self.PUNISHMENT_ROUNDS_DEFAULT
            else:
                self.my_mode = 'COOPERATE'
                self.rounds_to_punish_remaining = 0
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            self.my_mode = 'EMERGENCY'
            return Action.C
        if current_round_actual == total_rounds:
            return Action.D
        if self.my_mode == 'COOPERATE':
            return Action.C
        elif self.my_mode == 'PUNISH':
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_343(BaseStrategy):
    """
    Resource Sentinel is a strategy for the Common Pool Resource Game.
    It aims to foster cooperation and ensure resource survival by starting cooperatively,
    then adapting based on the resource's health (stock level) and the observed
    defection of other players. It is more forgiving when the resource is abundant
    but becomes stricter and more focused on preservation when the resource is under stress.
    It also defects in the final round to maximize payoff in a finite game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.S_critical_low = 0.2 * capacity
        self.S_warning_medium = 0.5 * capacity
        self.threshold_defection_minor = max(1, math.floor(n / 4))
        self.threshold_defection_major = max(2, math.floor(n / 2))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == total_rounds - 1:
            return Action.D
        my_prev_action_was_D = not history.my_actions[-1]
        num_opponent_defections = np.sum(~history.opponent_actions[-1, :])
        D_prev = int(my_prev_action_was_D) + num_opponent_defections
        if current_stock < self.S_critical_low:
            return Action.C
        elif current_stock < self.S_warning_medium:
            if D_prev <= self.threshold_defection_minor:
                return Action.C
            else:
                return Action.D
        elif D_prev == 0:
            return Action.C
        elif D_prev <= self.threshold_defection_major:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_344(BaseStrategy):
    """
    The Adaptive Stock Manager (ASM) strategy balances collective resource sustainability with individual
    robustness against exploitation. It adapts its behavior (Cooperate or Defect) based on the
    current health of the common stock and the observed cooperation levels of other players in the
    previous round.

    Rationale:
    - Starts cooperatively in the first round to promote a positive collective outcome.
    - Defects in the last round for immediate self-maximization (rational in a terminal round).
    - In intermediate rounds, it categorizes stock levels into "health zones" (Healthy & Full,
      Sustainable, Warning, Critical) and adjusts its response to opponent defection accordingly.
    - More forgiving of minor defections when stock is abundant, but becomes progressively stricter
      and more retaliatory as stock depletes, eventually prioritizing self-interest in critical
      resource depletion scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.MAX_TOLERATED_DEFECTIONS_SUSTAINABLE = self.n_players // 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        elif current_round == self.n_rounds - 1:
            return Action.D
        else:
            num_opponents = self.n_players - 1
            num_opponent_cooperators_prev_round = sum(history.opponent_actions[-1, :])
            num_defections_prev_round = num_opponents - num_opponent_cooperators_prev_round
            if current_stock >= self.capacity * 0.9:
                return Action.C
            elif current_stock >= self.capacity * 0.5:
                if num_defections_prev_round == 0:
                    return Action.C
                elif num_defections_prev_round <= self.MAX_TOLERATED_DEFECTIONS_SUSTAINABLE:
                    return Action.C
                else:
                    return Action.D
            elif current_stock >= self.capacity * 0.2:
                if num_defections_prev_round == 0:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_COLLECTIVE_345(BaseStrategy):
    """
    Adaptive Stock-Aware Collective Tit-for-Tat (ASACTFT) strategy for the Common Pool Resource Game.

    ASACTFT prioritizes the long-term health of the common stock, recognizing that a sustainable
    resource leads to higher collective payoffs. It begins with cooperation to establish a
    positive environment, dynamically adjusts its behavior based on observed defections and
    stock levels, and accounts for end-game dynamics to prevent exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        total_rounds = float(self.game_description.n_rounds)
        capacity = float(self.game_description.capacity)
        self.initial_cooperate_rounds = math.floor(total_rounds * 0.1)
        if self.initial_cooperate_rounds < 1:
            self.initial_cooperate_rounds = 1
        self.end_game_rounds = math.floor(total_rounds * 0.2)
        if self.end_game_rounds < 1:
            self.end_game_rounds = 1
        self.warning_stock_level = capacity * 0.5
        self.critical_stock_level = capacity * 0.25
        self.healthy_stock_defection_tolerance = 1
        self.warning_stock_defection_tolerance = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round < self.initial_cooperate_rounds:
            return Action.C
        if current_round >= total_rounds - self.end_game_rounds:
            return Action.D
        num_opponent_defectors = 0
        num_opponent_defectors = np.sum(~history.opponent_actions[-1, :])
        if current_stock < self.critical_stock_level:
            return Action.C
        elif current_stock < self.warning_stock_level:
            if num_opponent_defectors > self.warning_stock_defection_tolerance:
                return Action.D
            else:
                return Action.C
        elif num_opponent_defectors > self.healthy_stock_defection_tolerance:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_346(BaseStrategy):
    """
    Adaptive Sustainability with Defection Punishment: A strategy designed for the
    Common Pool Resource Game, balancing initial cooperation, tolerance for minor
    defections, and strong corrective actions against widespread exploitation or
    critical resource depletion. It accounts for end-game rationality.
    """
    DEFAULT_COOPERATION_FORGIVENESS_THRESHOLD: float = 0.25
    DEFAULT_CRITICAL_STOCK_THRESHOLD_FACTOR: float = 0.25

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_forgiveness_threshold = self.__class__.DEFAULT_COOPERATION_FORGIVENESS_THRESHOLD
        self.critical_stock_threshold_factor = self.__class__.DEFAULT_CRITICAL_STOCK_THRESHOLD_FACTOR

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.C
        my_action_prev_round = history.my_actions[current_round_0_indexed - 1]
        opponent_actions_prev_round = history.opponent_actions[current_round_0_indexed - 1, :]
        d_count_prev = 0
        if not my_action_prev_round:
            d_count_prev += 1
        d_count_prev += np.sum(~opponent_actions_prev_round)
        defection_rate_prev = d_count_prev / n_players
        critical_stock_level = self.critical_stock_threshold_factor * capacity
        if current_stock < critical_stock_level:
            if d_count_prev > 0:
                return Action.D
            else:
                return Action.C
        elif defection_rate_prev <= self.cooperation_forgiveness_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_347(BaseStrategy):
    """
    The "Adaptive Collective Sustainer (ACS)" strategy promotes long-term resource
    sustainability and collective welfare within the Common Pool Resource Game.
    It balances proactive cooperation with reactive punishment and self-preservation,
    adapting its behavior based on the current resource state and observed past actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n_players = game_description.n_players
        capacity = game_description.capacity
        self.CST: float = capacity * 0.2
        self.DTC: int = max(1, round((n_players - 1) * 0.2))
        self.PD: int = 2
        self.FS: int = 3
        self.punishment_active: bool = False
        self.rounds_in_punishment: int = 0
        self.cooperation_streak: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        description_round_number = state.round_number + 1
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if history is not None and description_round_number > 1:
            my_action_prev_round = history.my_actions[-1]
            opponent_actions_prev_round = history.opponent_actions[-1, :]
            num_defectors_among_others_prev_round = n_players - 1 - np.sum(opponent_actions_prev_round)
            if self.punishment_active:
                self.rounds_in_punishment += 1
                if self.rounds_in_punishment > self.PD:
                    self.punishment_active = False
                    self.rounds_in_punishment = 0
            if not self.punishment_active and num_defectors_among_others_prev_round >= self.DTC:
                self.punishment_active = True
                self.rounds_in_punishment = 1
                self.cooperation_streak = 0
            if num_defectors_among_others_prev_round == 0 and my_action_prev_round == True:
                self.cooperation_streak += 1
            else:
                self.cooperation_streak = 0
        my_action: Action
        if description_round_number >= total_rounds - 1:
            my_action = Action.D
        elif current_stock <= self.CST:
            my_action = Action.D
        elif self.punishment_active:
            my_action = Action.D
        elif self.cooperation_streak >= self.FS:
            my_action = Action.C
            self.punishment_active = False
            self.rounds_in_punishment = 0
            self.cooperation_streak = 0
        else:
            my_action = Action.C
        return my_action

class Strategy_COLLECTIVE_348(BaseStrategy):
    """
    Adaptive Collective Steward (ACS) strategy for the Common Pool Resource Game.
    This strategy prioritizes the long-term sustainability of the common resource
    while adapting to the observed collective behavior of other players. It balances
    cooperation for resource health with conditional defection to punish over-extraction,
    and includes a critical recovery mechanism.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.cooperation_deviation_tolerance = 0.05
        self.critical_recovery_threshold_ratio = 0.1
        self.previous_stock = self.capacity
        self.current_round_number = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        self.current_round_number += 1
        action: Action
        if self.current_round_number == 1:
            action = Action.C
        elif self.current_round_number == self.n_rounds:
            action = Action.D
        else:
            S_prev_for_calc = self.previous_stock
            S_remaining_if_all_C = S_prev_for_calc - S_prev_for_calc / 2.0
            Growth_if_all_C = 2.0 * S_remaining_if_all_C * (1.0 - S_remaining_if_all_C / self.capacity)
            Expected_S_current_if_all_C = min(S_remaining_if_all_C + Growth_if_all_C, self.capacity)
            critical_recovery_level = self.capacity * self.critical_recovery_threshold_ratio
            if current_stock < critical_recovery_level:
                action = Action.C
            elif current_stock < Expected_S_current_if_all_C * (1.0 - self.cooperation_deviation_tolerance):
                action = Action.D
            else:
                action = Action.C
        self.previous_stock = current_stock
        return action

class Strategy_COLLECTIVE_349(BaseStrategy):
    """
    The "Adaptive Steward" strategy for the Common Pool Resource Game.
    It prioritizes long-term sustainability through conditional cooperation,
    responds to collective defection with punishment, and enforces stricter
    cooperation requirements when the common stock is critically low.
    It defects in the final round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.T_cooperate = (self.n - 1) / self.n
        self.recovery_threshold_stock = self.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == 0:
            return Action.C
        if current_round == self.r - 1:
            return Action.D
        num_others_cooperated = sum(history.opponent_actions[-1, :])
        other_cooperation_rate = num_others_cooperated / (self.n - 1)
        if current_stock < self.recovery_threshold_stock:
            if other_cooperation_rate == 1.0:
                return Action.C
            else:
                return Action.D
        elif other_cooperation_rate < self.T_cooperate:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_350(BaseStrategy):
    """
    The CollectiveSurvival strategy aims to foster and maintain a cooperative equilibrium for sustainable
    resource management, prioritizing long-term health of the common pool. It incorporates mechanisms
    for self-protection against exploitation by retaliating against significant defection, while also
    being forgiving and prioritizing resource recovery when stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_multiplier = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == r:
            return Action.D
        d_count = np.sum(~history.opponent_actions[-1, :])
        forgiveness_threshold = 0
        if n > 2:
            forgiveness_threshold = 1
        critical_stock_level = capacity * self.critical_stock_multiplier
        if current_stock <= critical_stock_level:
            return Action.C
        elif d_count <= forgiveness_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_351(BaseStrategy):
    """
    The "Adaptive Collective Guardian" strategy is designed to promote and maintain collective cooperation
    in the Common Pool Resource game, while remaining robust against exploitation and adaptable to varying
    game states. It prioritizes the long-term health of the resource for the collective good, but is not
    a pure altruist, recognizing the need for deterrence in a tournament setting.
    """
    COOPERATION_THRESHOLD_LOW = 0.6
    COOPERATION_THRESHOLD_HIGH = 0.85
    CRITICAL_STOCK_PERCENTAGE = 0.2
    PUNISHMENT_DURATION_ROUNDS = 2

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.my_last_action: Action | None = None
        self.rounds_in_punishment: int = 0
        self.last_observed_cooperation_rate: float = 1.0

    def _calculate_implied_defection_count(self, prev_stock: float, total_consumption_prev_round: float) -> int:
        """
        Helper function to calculate the number of defectors in the previous round based on
        previous stock and total consumption. Handles division by zero for prev_stock.
        """
        N = self.n_players
        if prev_stock == 0:
            return N
        implied_k_float = 2 * N * total_consumption_prev_round / prev_stock - N
        rounded_k = round(implied_k_float)
        return int(max(0, min(N, rounded_k)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number + 1
        current_stock = state.current_stock
        if current_round == 1:
            self.my_last_action = Action.C
            return Action.C
        if current_round == self.n_rounds:
            self.my_last_action = Action.D
            return Action.D
        prev_round_idx = state.round_number - 1
        my_prev_action_bool = history.my_actions[prev_round_idx]
        my_prev_payoff = history.my_payoffs[prev_round_idx]
        S_prev: float = 0.0
        if my_prev_payoff > 0:
            if my_prev_action_bool:
                S_prev = my_prev_payoff * (2 * self.n_players)
            else:
                S_prev = my_prev_payoff * self.n_players
        total_consumption_prev_round: float = 0.0
        if S_prev > 0:
            if my_prev_action_bool:
                total_consumption_prev_round += S_prev / (2 * self.n_players)
            else:
                total_consumption_prev_round += S_prev / self.n_players
            for opp_action_bool in history.opponent_actions[prev_round_idx, :]:
                if opp_action_bool:
                    total_consumption_prev_round += S_prev / (2 * self.n_players)
                else:
                    total_consumption_prev_round += S_prev / self.n_players
        num_defectors_prev_round = self._calculate_implied_defection_count(S_prev, total_consumption_prev_round)
        self.last_observed_cooperation_rate = (self.n_players - num_defectors_prev_round) / self.n_players
        if current_stock < self.CRITICAL_STOCK_PERCENTAGE * self.capacity:
            self.rounds_in_punishment = 0
            self.my_last_action = Action.C
            return Action.C
        if self.rounds_in_punishment > 0:
            self.rounds_in_punishment -= 1
            self.my_last_action = Action.D
            return Action.D
        if self.last_observed_cooperation_rate < self.COOPERATION_THRESHOLD_LOW:
            self.rounds_in_punishment = self.PUNISHMENT_DURATION_ROUNDS
            self.my_last_action = Action.D
            return Action.D
        elif self.last_observed_cooperation_rate >= self.COOPERATION_THRESHOLD_HIGH:
            self.my_last_action = Action.C
            return Action.C
        else:
            self.my_last_action = Action.C
            return Action.C

class Strategy_COLLECTIVE_352(BaseStrategy):
    """
    The Adaptive Conservationist strategy aims to maintain the common pool resource at sustainable levels.
    It starts cooperatively, adapts its behavior based on observed opponent actions and stock health,
    and defends against exploitation, balancing collective well-being with self-preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_critical_threshold = self.capacity / 2.0
        self.S_healthy_threshold = self.capacity * 0.9

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        actions_others_prev_round = history.opponent_actions[current_round_0_indexed - 1, :]
        num_defectors_others_prev_round = np.sum(actions_others_prev_round == False)
        if current_stock <= self.S_critical_threshold:
            return Action.C
        elif current_stock >= self.S_healthy_threshold:
            if num_defectors_others_prev_round == 0:
                return Action.C
            elif num_defectors_others_prev_round <= (self.n_players - 1) // 2:
                return Action.C
            else:
                return Action.D
        elif num_defectors_others_prev_round == 0:
            return Action.C
        elif num_defectors_others_prev_round <= (self.n_players - 1) // 3:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_353(BaseStrategy):
    """
    The "Adaptive Steward" strategy prioritizes the long-term sustainability of the common pool resource.
    It starts by signaling willingness to cooperate and maintains cooperation as long as a sufficient number
    of other players reciprocate. It has an overriding directive to preserve the resource when it falls
    into a critical state, even if it means short-term individual sacrifice. It adapts to defection
    but seeks to restore cooperation rather than simply out-defecting others.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.low_stock_threshold_factor: float = 0.25
        self.cooperation_tolerance_factor: float = 0.75
        self.low_stock_threshold: float = self.game_description.capacity * self.low_stock_threshold_factor
        self.min_cooperators_for_cooperation: int = math.ceil(self.game_description.n_players * self.cooperation_tolerance_factor)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t: int = state.round_number + 1
        current_stock_S: float = state.current_stock
        n_rounds: int = self.game_description.n_rounds
        if current_round_t == 1:
            return Action.C
        elif current_round_t == n_rounds:
            if current_stock_S < self.low_stock_threshold:
                return Action.C
            else:
                return Action.D
        else:
            num_cooperators_prev_round_opponents: int = sum(history.opponent_actions[-1, :])
            my_action_prev_round: np.bool_ = history.my_actions[-1]
            num_total_cooperators_prev_round: int = num_cooperators_prev_round_opponents + (1 if my_action_prev_round else 0)
            if current_stock_S < self.low_stock_threshold:
                return Action.C
            elif num_total_cooperators_prev_round >= self.min_cooperators_for_cooperation:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_354(BaseStrategy):
    """
    The Adaptive Collective Sustainer (ACS) strategy promotes and sustains cooperation
    in the Common Pool Resource Game. It defaults to cooperation, collectively punishes
    defection by any player, offers quick forgiveness, and has a strong override mechanism
    for critical resource depletion to prioritize long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.PUNISHMENT_DURATION = 1
        self.CRITICAL_STOCK_THRESHOLD_FACTOR = 0.2
        self.rounds_of_collective_punishment_active = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round_idx = state.round_number - 1
        all_actions_prev_round = np.concatenate((history.opponent_actions[prev_round_idx, :], np.array([history.my_actions[prev_round_idx]])))
        D_count_prev = self.game_description.n_players - all_actions_prev_round.sum()
        if D_count_prev > 0:
            self.rounds_of_collective_punishment_active = self.PUNISHMENT_DURATION
        else:
            self.rounds_of_collective_punishment_active = max(0, self.rounds_of_collective_punishment_active - 1)
        critical_stock_level = self.game_description.capacity * self.CRITICAL_STOCK_THRESHOLD_FACTOR
        if state.current_stock < critical_stock_level:
            return Action.C
        elif self.rounds_of_collective_punishment_active > 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_355(BaseStrategy):
    """
    Adaptive Conservationist with Forgiveness and Punishment strategy.
    This strategy is designed for a common pool resource game, aiming to foster collective welfare
    by prioritizing the long-term health of the resource while being robust against exploitation.
    It adapts its cooperativeness based on the current stock level and the observed behavior of other players.

    Key principles:
    1. Start Cooperative: Always initiate cooperation in the first round.
    2. Resource-First (Critical Levels): When the resource is critically low, always cooperate to aid recovery.
    3. Adaptive Forgiveness: Adjust the level of tolerance for defection based on the stock level (stricter when low, more forgiving when healthy).
    4. Punish Exploitation: Switch to defection if others' defection exceeds tolerable levels.
    5. Terminal Round Self-Interest: Maximize immediate payoff by defecting in the very last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == n_rounds - 1:
            return Action.D
        prev_round_opponent_actions = history.opponent_actions[-1, :]
        num_cooperators_others = sum(prev_round_opponent_actions)
        num_defectors_others = n_players - 1 - num_cooperators_others
        if current_stock < capacity / 4:
            return Action.C
        elif current_stock < capacity / 2:
            if num_defectors_others == 0:
                return Action.C
            else:
                return Action.D
        elif current_stock < capacity * 0.75:
            forgiveness_threshold = (n_players - 1) // 3
            if num_defectors_others <= forgiveness_threshold:
                return Action.C
            else:
                return Action.D
        else:
            forgiveness_threshold = (n_players - 1) // 2
            if num_defectors_others <= forgiveness_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_356(BaseStrategy):
    """
    The Adaptive Community Steward (ACS) strategy aims to balance collective resource sustainability
    with individual robustness. It starts cooperatively, monitors other players' actions, and
    adapts its behavior to foster cooperation and prevent exploitation. It is forgiving of
    minor deviations but firm against widespread defection, especially when the resource
    is in a critical state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_tolerance_D: int = 1
        self.critical_stock_ratio: float = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        num_defectors_other_players_prev_round = np.sum(~history.opponent_actions[-1, :])
        current_stock_ratio = state.current_stock / self.game_description.capacity
        if current_stock_ratio < self.critical_stock_ratio:
            if num_defectors_other_players_prev_round == 0:
                return Action.C
            else:
                return Action.D
        elif num_defectors_other_players_prev_round <= self.cooperation_tolerance_D:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_357(BaseStrategy):
    """
    The "Adaptive Stock-Preservation (ASP)" strategy for the Common Pool Resource Game.
    It balances collective resource sustainability with individual self-preservation
    by adapting its actions based on current stock levels and observed opponent behavior.
    It attempts to foster cooperation when stock is healthy or recovering, but will
    aggressively defect if the resource is being depleted or cooperation is insufficient.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        capacity = float(game_description.capacity)
        self.stock_healthy_threshold = capacity * 0.9
        self.stock_recovery_threshold = capacity * 0.5
        self.stock_critical_threshold = capacity * 0.1
        self.cooperation_required_for_recovery_ratio = 0.75
        self.defection_tolerance_healthy_stock = 0 if game_description.n_players == 2 else 1
        self.my_last_action: Action | None = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r_total = self.game_description.n_rounds
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        action_to_take: Action
        if current_round_0_indexed == 0:
            action_to_take = Action.C
        elif current_round_0_indexed == r_total - 1:
            action_to_take = Action.D
        else:
            all_actions_prev_round_bool = np.concatenate((history.opponent_actions[-1, :], np.array([history.my_actions[-1]])))
            num_defectors_last_round = (~all_actions_prev_round_bool).sum()
            num_cooperators_last_round = all_actions_prev_round_bool.sum()
            my_last_action_prev_round_enum = self.my_last_action
            if current_stock >= self.stock_healthy_threshold:
                if num_defectors_last_round > self.defection_tolerance_healthy_stock:
                    action_to_take = Action.D
                else:
                    action_to_take = Action.C
            elif current_stock < self.stock_healthy_threshold and current_stock >= self.stock_recovery_threshold:
                if num_cooperators_last_round < n * self.cooperation_required_for_recovery_ratio:
                    action_to_take = Action.D
                else:
                    action_to_take = Action.C
            elif current_stock < self.stock_recovery_threshold and current_stock >= self.stock_critical_threshold:
                if num_cooperators_last_round < n * self.cooperation_required_for_recovery_ratio:
                    action_to_take = Action.D
                else:
                    action_to_take = Action.C
            elif num_defectors_last_round == 0 and my_last_action_prev_round_enum == Action.C:
                action_to_take = Action.C
            else:
                action_to_take = Action.D
        self.my_last_action = action_to_take
        return action_to_take

class Strategy_COLLECTIVE_358(BaseStrategy):
    """
    Adaptive Collective Sustain (ACS) Strategy for Common Pool Resource Game.
    Prioritizes long-term collective sustainability through cooperation,
    conditional punishment, and adaptive behavior based on common pool health.
    Starts cooperatively, allows minor defections, but retaliates against
    significant or persistent defection, especially when stock is low.
    Defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.STRATEGY_TOLERANCE_FACTOR: float = 0.25
        self.CRITICAL_STOCK_RATIO: float = 0.5
        self.last_round_stock: float = float(self.game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t_1_indexed = state.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = float(self.game_description.capacity)
        if current_round_t_1_indexed == 1:
            self.last_round_stock = state.current_stock
            return Action.C
        elif current_round_t_1_indexed == r:
            return Action.D
        else:
            S_t_minus_1 = self.last_round_stock
            num_opponent_defectors = np.sum(1 - history.opponent_actions[-1, :])
            my_prev_action_was_D = not history.my_actions[-1]
            k_D_t_minus_1 = num_opponent_defectors + (1 if my_prev_action_was_D else 0)
            observed_defection_rate = k_D_t_minus_1 / n
            current_stock_ratio = S_t_minus_1 / capacity
            my_action = Action.C
            if observed_defection_rate > self.STRATEGY_TOLERANCE_FACTOR:
                my_action = Action.D
            elif current_stock_ratio < self.CRITICAL_STOCK_RATIO and k_D_t_minus_1 > 0:
                my_action = Action.D
            self.last_round_stock = state.current_stock
            return my_action

class Strategy_COLLECTIVE_359(BaseStrategy):
    """
    The Adaptive Stock Preserver (ASP) strategy balances conditional cooperation with strategic defection.
    It adapts its behavior based on the current health of the common stock and the observed cooperation
    levels of other players. It prioritizes stock preservation, cooperates conditionally, deters exploitation,
    and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_LEVEL = game_description.capacity * 0.1
        self.LOW_STOCK_THRESHOLD = game_description.capacity * 0.5
        self.COOPERATION_RATE_THRESHOLD_HEALTHY_STOCK = 0.5
        self.COOPERATION_RATE_THRESHOLD_LOW_STOCK = 0.66
        self.COOPERATION_RATE_THRESHOLD_CRITICAL_STOCK_CRISIS = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        num_opponents_cooperated_last_round = sum(history.opponent_actions[-1, :])
        n_players_overall = self.game_description.n_players
        num_opponents = n_players_overall - 1
        opponent_cooperation_rate_last_round = 0.0
        if num_opponents > 0:
            opponent_cooperation_rate_last_round = num_opponents_cooperated_last_round / num_opponents
        current_stock = state.current_stock
        if current_stock < self.CRITICAL_STOCK_LEVEL:
            if opponent_cooperation_rate_last_round < self.COOPERATION_RATE_THRESHOLD_CRITICAL_STOCK_CRISIS:
                return Action.D
            else:
                return Action.C
        elif current_stock < self.LOW_STOCK_THRESHOLD:
            if opponent_cooperation_rate_last_round < self.COOPERATION_RATE_THRESHOLD_LOW_STOCK:
                return Action.D
            else:
                return Action.C
        elif opponent_cooperation_rate_last_round < self.COOPERATION_RATE_THRESHOLD_HEALTHY_STOCK:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_360(BaseStrategy):
    """
    The Adaptive Collective Sustainer (ACS) strategy for the Common Pool Resource Game.

    ACS aims for long-term sustainability and collective well-being. It prioritizes
    resource health and cooperation, but adapts to defection to prevent exploitation
    and resource collapse, especially in the endgame.

    Key principles:
    - Cooperate initially to establish a positive equilibrium.
    - Defect in the final rounds to avoid end-game exploitation.
    - Mid-game adaptation:
        - Reward universal cooperation by continuing to cooperate.
        - Forgive minor defection if the resource is very healthy.
        - Defect if the resource is critically low to salvage individual payoff.
        - Punish significant defection to discourage exploitation and protect this player.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.defection_tolerance_threshold = self.n_players / 3.0
        self.stock_healthy_threshold = 0.75 * self.capacity
        self.stock_critical_threshold = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed >= self.n_rounds - 2:
            return Action.D
        else:
            last_round_my_action = history.my_actions[current_round_0_indexed - 1]
            last_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
            num_defectors_last_round = np.sum(~last_round_opponent_actions) + int(not last_round_my_action)
            stock_level_ratio = state.current_stock / self.capacity
            if num_defectors_last_round == 0:
                return Action.C
            elif num_defectors_last_round <= self.defection_tolerance_threshold and state.current_stock > self.stock_healthy_threshold:
                return Action.C
            elif state.current_stock < self.stock_critical_threshold:
                return Action.D
            else:
                return Action.D

class Strategy_COLLECTIVE_361(BaseStrategy):
    """
    Adaptive Resource Steward (ARS) strategy for the Common Pool Resource game.
    Aims for sustainable resource management with adaptive responses to opponent defection
    and critical stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.my_consecutive_defections: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        num_players = self.game_description.n_players
        action_for_this_round: Action
        if current_round_0_indexed == 0:
            action_for_this_round = Action.C
        elif current_round_0_indexed == total_rounds - 1:
            action_for_this_round = Action.D
        else:
            num_defectors_prev_round = np.sum(~history.opponent_actions[-1, :])
            if current_stock <= capacity / 4:
                action_for_this_round = Action.C
            elif current_stock <= capacity / 2:
                if num_defectors_prev_round == 0:
                    action_for_this_round = Action.C
                elif self.my_consecutive_defections == 0:
                    action_for_this_round = Action.D
                else:
                    action_for_this_round = Action.C
            elif num_defectors_prev_round == 0:
                action_for_this_round = Action.C
            else:
                tolerance_level = max(1, math.floor(num_players / 4))
                if num_defectors_prev_round <= tolerance_level:
                    action_for_this_round = Action.C
                elif self.my_consecutive_defections < 2:
                    action_for_this_round = Action.D
                else:
                    action_for_this_round = Action.C
        if action_for_this_round == Action.D:
            self.my_consecutive_defections += 1
        else:
            self.my_consecutive_defections = 0
        return action_for_this_round

class Strategy_COLLECTIVE_362(BaseStrategy):
    """
    Adaptive Stock-Aware Collective (ASC) Strategy:
    This strategy prioritizes the common pool stock's health. It starts by cooperating
    and monitors opponent behavior. If significant defection is observed, it enters a
    punishment mode for a fixed duration. After punishment, it attempts to return to
    cooperation, but only if others have also reduced defection and the stock has
    recovered sufficiently. In the final round, it defects for individual gain.
    A critical stock level triggers universal cooperation to prevent resource collapse.
    """

    class _StrategyMode(Enum):
        """Internal states for the strategy's behavior."""
        COOPERATE = 0
        PUNISH = 1

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.my_current_strategy_mode = self._StrategyMode.COOPERATE
        self.rounds_in_punish_mode = 0
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / 4
        self.RECOVERY_STOCK_THRESHOLD = self.capacity * 0.75
        self.DEFECTION_TOLERANCE_THRESHOLD = max(1, math.floor(self.n * 0.25))
        self.PUNISHMENT_DURATION_ROUNDS = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == self.r - 1:
            return Action.D
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            self.my_current_strategy_mode = self._StrategyMode.COOPERATE
            self.rounds_in_punish_mode = 0
            return Action.C
        if current_round_number == 0:
            return Action.C
        d_count_prev = sum(~history.opponent_actions[-1, :])
        if self.my_current_strategy_mode == self._StrategyMode.COOPERATE:
            if d_count_prev >= self.DEFECTION_TOLERANCE_THRESHOLD:
                self.my_current_strategy_mode = self._StrategyMode.PUNISH
                self.rounds_in_punish_mode = 1
                return Action.D
            else:
                self.my_current_strategy_mode = self._StrategyMode.COOPERATE
                self.rounds_in_punish_mode = 0
                return Action.C
        elif self.my_current_strategy_mode == self._StrategyMode.PUNISH:
            self.rounds_in_punish_mode += 1
            if self.rounds_in_punish_mode <= self.PUNISHMENT_DURATION_ROUNDS:
                return Action.D
            elif d_count_prev < self.DEFECTION_TOLERANCE_THRESHOLD:
                if current_stock >= self.RECOVERY_STOCK_THRESHOLD:
                    self.my_current_strategy_mode = self._StrategyMode.COOPERATE
                    self.rounds_in_punish_mode = 0
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_363(BaseStrategy):
    """
    The Adaptive Resource Guardian strategy for the Common Pool Resource Game.

    This strategy aims to foster long-term sustainability of the common resource by employing
    a reciprocal (Tit-for-Tat) approach in intermediate rounds, while explicitly handling
    the first and last rounds as special cases.

    It initiates cooperation in the very first round to signal a willingness to collaborate.
    In the final round, it defects to maximize immediate payoff, as there are no future
    interactions to consider. For all intermediate rounds, the strategy's decision
    is based on the collective behavior of other players in the immediately preceding round:
    it cooperates if all other players cooperated, and defects if at least one other player
    defected.

    The strategy's rationale for different stock health states (Healthy, Warning, Critical)
    explains the importance of this reciprocal behavior in various resource conditions,
    but the specific C/D decision rule based on previous opponent actions remains consistent
    across these states in intermediate rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.STOCK_GOOD_HEALTH_THRESHOLD = self.game_description.capacity * 0.75
        self.STOCK_RECOVERY_PRIORITY_THRESHOLD = self.game_description.capacity * 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        num_opponent_cooperators_prev_round = sum(history.opponent_actions[-1, :])
        num_other_players = self.game_description.n_players - 1
        k_prev = num_other_players - num_opponent_cooperators_prev_round
        if k_prev == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_364(BaseStrategy):
    """
    The Adaptive Collective Manager (ACM) strategy promotes cooperation and resource sustainability
    in the Common Pool Resource Game. It balances collective welfare with self-preservation through
    a hierarchical decision-making process. It prioritizes resource recovery when stock is low,
    adopts a rational self-interest stance in the final round, and adapts its behavior based on
    the prevalence of defection in the previous round, forgiving minor transgressions while
    punishing widespread exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.STOCK_RECOVERY_THRESHOLD_FACTOR = 0.5
        self.WIDESPREAD_DEFECTION_THRESHOLD = math.floor(self.n / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.r - 1:
            return Action.D
        if current_stock < self.capacity * self.STOCK_RECOVERY_THRESHOLD_FACTOR:
            return Action.C
        my_last_action = history.my_actions[-1]
        opponent_last_actions = history.opponent_actions[-1, :]
        all_players_actions_last_round = np.concatenate(([my_last_action], opponent_last_actions))
        num_defectors_last_round = np.sum(all_players_actions_last_round == False)
        if num_defectors_last_round > self.WIDESPREAD_DEFECTION_THRESHOLD:
            return Action.D
        elif num_defectors_last_round > 0:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_365(BaseStrategy):
    """
    Adaptive Resource Guardian: This strategy prioritizes long-term resource sustainability through
    conditional cooperation. It starts with an act of trust (cooperation) and reciprocates collective
    cooperation. However, it is quick to punish group defection and shifts to self-preservation if
    the resource becomes critically depleted or in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_CRITICAL = self.capacity / (2 * self.n_players)
        if self.n_players == 2:
            self.DEFECTION_COUNT_THRESHOLD = 1
        else:
            self.DEFECTION_COUNT_THRESHOLD = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        elif state.current_stock < self.S_CRITICAL:
            return Action.D
        else:
            k_D_prev = np.sum(~history.opponent_actions[state.round_number - 1, :])
            if k_D_prev >= self.DEFECTION_COUNT_THRESHOLD:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_366(BaseStrategy):
    """
    The Adaptive Collective Sustenance Strategy (ACSS) aims to promote collective resource
    sustainability while being robust to defection and optimizing individual payoff
    in the final round. It starts cooperatively, switches to retaliation upon observed
    defection, and forgives only after a round of full cooperation. A critical
    resource emergency overrides all other behaviors, forcing unconditional cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_mode = 'COOPERATE'

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock_level = state.current_stock
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        EMERGENCY_STOCK_THRESHOLD = capacity / 2
        if current_stock_level < EMERGENCY_STOCK_THRESHOLD:
            return Action.C
        if current_round_0_indexed == 0:
            self.current_mode = 'COOPERATE'
            return Action.C
        else:
            previous_round_0_indexed = current_round_0_indexed - 1
            num_C_prev = np.sum(history.opponent_actions[previous_round_0_indexed, :]) + int(history.my_actions[previous_round_0_indexed])
            if self.current_mode == 'COOPERATE':
                if num_C_prev == n_players:
                    return Action.C
                else:
                    self.current_mode = 'RETALIATE'
                    return Action.D
            elif self.current_mode == 'RETALIATE':
                if num_C_prev == n_players:
                    self.current_mode = 'COOPERATE'
                    return Action.C
                else:
                    return Action.D
            return Action.C

class Strategy_COLLECTIVE_367(BaseStrategy):
    """
    The "Adaptive Resource Steward" (ARS) strategy for the Common Pool Resource game.
    It prioritizes long-term resource sustainability and adapts to collective player behavior.
    ARS cooperates conditionally, demanding more cooperation when the resource is vulnerable,
    and defects to prevent exploitation or to maximize payoff in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = game_description.n_players
        capacity = game_description.capacity
        self.stock_critical_threshold = capacity / (2 * n)
        self.stock_recovery_threshold = capacity / 2
        self.stock_healthy_threshold = capacity * 0.9
        self.cooperation_memory_length = 3
        self.coop_tolerance_high_stock = 0.5
        self.coop_tolerance_low_stock = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == r - 1:
            return Action.D
        if current_stock < self.stock_critical_threshold:
            return Action.C
        history_stock_at_start = []
        history_total_consumption = []
        S_prev_round_start = capacity
        for k in range(current_round_0_indexed):
            history_stock_at_start.append(S_prev_round_start)
            my_action_k = history.my_actions[k]
            opponent_actions_k = history.opponent_actions[k, :]
            all_actions_k = np.concatenate((np.array([my_action_k]), opponent_actions_k))
            num_cooperators_k = np.sum(all_actions_k)
            num_defectors_k = n - num_cooperators_k
            stock_for_consumption = S_prev_round_start
            consumption_c_per_player = stock_for_consumption / (2 * n) if stock_for_consumption > 0 else 0.0
            consumption_d_per_player = stock_for_consumption / n if stock_for_consumption > 0 else 0.0
            current_round_total_consumption = num_cooperators_k * consumption_c_per_player + num_defectors_k * consumption_d_per_player
            history_total_consumption.append(current_round_total_consumption)
            S_after_consumption = stock_for_consumption - current_round_total_consumption
            S_after_consumption = max(0.0, S_after_consumption)
            growth = 2 * S_after_consumption * (1 - S_after_consumption / capacity)
            S_next_round_start = min(S_after_consumption + growth, capacity)
            S_prev_round_start = S_next_round_start
        observed_cooperation_rate = 0.0
        rounds_to_consider = min(current_round_0_indexed, self.cooperation_memory_length)
        if rounds_to_consider > 0:
            sum_cooperation_rates = 0.0
            for k_idx in range(current_round_0_indexed - rounds_to_consider, current_round_0_indexed):
                prev_stock_at_start = history_stock_at_start[k_idx]
                total_consumption_in_prev_round = history_total_consumption[k_idx]
                coop_rate_this_round = 0.0
                if prev_stock_at_start > 0:
                    effective_cooperators_count = 2 * n - 2 * n * total_consumption_in_prev_round / prev_stock_at_start
                    coop_rate_this_round = max(0.0, min(1.0, effective_cooperators_count / n))
                else:
                    coop_rate_this_round = 0.0
                sum_cooperation_rates += coop_rate_this_round
            observed_cooperation_rate = sum_cooperation_rates / rounds_to_consider
        else:
            observed_cooperation_rate = 1.0
        if current_stock >= self.stock_healthy_threshold:
            if observed_cooperation_rate >= self.coop_tolerance_high_stock:
                return Action.C
            else:
                return Action.D
        elif current_stock >= self.stock_recovery_threshold:
            if observed_cooperation_rate >= self.coop_tolerance_high_stock:
                return Action.C
            else:
                return Action.D
        elif observed_cooperation_rate >= self.coop_tolerance_low_stock:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_368(BaseStrategy):
    """
    Adaptive Collective Guardian (ACG) strategy for the Common Pool Resource Game.

    This strategy fosters cooperation for resource sustainability while being robust
    against exploitation and adaptable to varying opponent behaviors. It prioritizes
    the long-term health of the common pool resource, recognizing that individual payoffs
    are intrinsically linked to its survival.

    The strategy operates on the principle of conditional cooperation, defaulting to
    cooperation but ready to punish collective defection and take defensive action
    when the resource is critically endangered.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOPERATION_THRESHOLD_RATIO: float = 0.5
        self.PUNISHMENT_DURATION: int = 1
        self.CRITICAL_STOCK_LEVEL: float = self.game_description.capacity / 4.0
        self.cooperation_mode: bool = True
        self.punishment_rounds_left: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        prev_round_0_indexed = current_round_0_indexed - 1
        my_prev_action = history.my_actions[prev_round_0_indexed]
        opponent_prev_actions = history.opponent_actions[prev_round_0_indexed, :]
        all_prev_actions = np.concatenate(([my_prev_action], opponent_prev_actions))
        num_defectors_prev_round = np.sum(all_prev_actions == False)
        actual_cooperation_ratio = (n - num_defectors_prev_round) / n
        if self.punishment_rounds_left > 0:
            self.punishment_rounds_left -= 1
            if self.punishment_rounds_left == 0:
                self.cooperation_mode = True
        if actual_cooperation_ratio < self.COOPERATION_THRESHOLD_RATIO:
            if self.punishment_rounds_left == 0:
                self.cooperation_mode = False
                self.punishment_rounds_left = self.PUNISHMENT_DURATION
        current_round_1_indexed = current_round_0_indexed + 1
        if current_round_1_indexed == r:
            return Action.D
        if current_stock < self.CRITICAL_STOCK_LEVEL:
            return Action.D
        if self.cooperation_mode == True:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_369(BaseStrategy):
    """
    Adaptive Stock-Aware Retaliator (ASAR) strategy for the Common Pool Resource Game.
    This strategy aims to promote long-term resource sustainability and maximize overall welfare
    by combining initial cooperation, adaptive retaliation based on stock levels, and
    prioritization of resource conservation during scarcity. It defects in the final round
    to maximize terminal payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the ASAR strategy with game parameters and internal strategy constants.
        """
        self.game_description = game_description
        self.patience_threshold: int = 0
        self.low_stock_fraction: float = 0.5
        self.critical_stock_absolute: float = 2 * self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round based on
        game state, previous round's opponent actions, and ASAR strategy rules.

        Args:
            state: An object containing the current round number and current stock level.
            history: An object containing past actions and payoffs for all players,
                     or None if it's the very first round.

        Returns:
            An Action enum (Action.C for Cooperate, Action.D for Defect).
        """
        current_round_t: int = state.round_number + 1
        total_rounds_r: int = self.game_description.n_rounds
        current_stock_S: float = state.current_stock
        capacity: int = self.game_description.capacity
        if current_round_t == 1:
            return Action.C
        if current_round_t == total_rounds_r:
            return Action.D
        num_opponent_defectors_last_round: int = np.count_nonzero(history.opponent_actions[-1, :] == False)
        if current_stock_S <= self.critical_stock_absolute:
            return Action.C
        elif current_stock_S < self.low_stock_fraction * capacity:
            if num_opponent_defectors_last_round > 0:
                return Action.D
            else:
                return Action.C
        elif num_opponent_defectors_last_round > self.patience_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_370(BaseStrategy):
    """
    The Adaptive Stock Manager strategy prioritizes the sustained health of the common resource.
    It cooperates when conditions are favorable and enforces cooperation through punishment
    when players defect. It adapts its response based on the current stock level, becoming
    stricter when the resource is abundant and slightly more forgiving when the resource is low,
    while still protecting itself from excessive exploitation.
    """
    DEFECTION_TOLERANCE_NORMAL: int
    DEFECTION_TOLERANCE_LOW_STOCK: int
    STOCK_RECOVERY_THRESHOLD: float
    STOCK_CRITICAL_THRESHOLD: float
    n_players: int
    n_rounds: int
    capacity: float

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.DEFECTION_TOLERANCE_NORMAL = 0
        self.DEFECTION_TOLERANCE_LOW_STOCK = 1
        self.STOCK_RECOVERY_THRESHOLD = self.capacity * 0.75
        self.STOCK_CRITICAL_THRESHOLD = self.capacity * 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock_S = state.current_stock
        if current_round_number == 0:
            return Action.C
        if current_round_number == self.n_rounds - 1:
            return Action.D
        num_D_opponents_prev = np.sum(~history.opponent_actions[-1, :])
        if current_stock_S <= self.STOCK_CRITICAL_THRESHOLD:
            if num_D_opponents_prev == 0:
                return Action.C
            else:
                return Action.D
        elif current_stock_S <= self.STOCK_RECOVERY_THRESHOLD:
            if num_D_opponents_prev <= self.DEFECTION_TOLERANCE_LOW_STOCK:
                return Action.C
            else:
                return Action.D
        elif num_D_opponents_prev <= self.DEFECTION_TOLERANCE_NORMAL:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_371(BaseStrategy):
    """
    Adaptive Collective Stewardship strategy for the Common Pool Resource Game.
    
    This strategy aims to promote long-term sustainability by starting with cooperation,
    enforcing cooperation through a reciprocal mechanism based on defection tolerance,
    and prioritizing resource recovery when the stock is critically low. It defects
    in the last round to maximize immediate payoff when no future consequences exist.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        elif current_stock < self.capacity / 2:
            return Action.C
        else:
            num_defectors_last_round = 0
            if not history.my_actions[-1]:
                num_defectors_last_round += 1
            num_defectors_last_round += np.sum(1 - history.opponent_actions[-1, :].astype(int))
            defection_threshold_count = 0
            if self.n_players > 4:
                defection_threshold_count = math.floor(self.n_players / 4)
            if num_defectors_last_round <= defection_threshold_count:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_372(BaseStrategy):
    """
    The Adaptive Resource Guardian strategy for the Common Pool Resource Game.
    This strategy aims for sustainable long-term payoffs by prioritizing resource health
    and adapting its response to defection based on the current stock level.
    It cooperates initially, defects in the final round, and applies tiered
    tolerance for defection in intermediate rounds, with stricter rules for low stock
    and an unconditional cooperation rule for critically low stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.MIN_CRITICAL_STOCK_THRESHOLD = self.capacity / (4.0 * self.n)
        self.LOW_STOCK_THRESHOLD = self.capacity / 2.0
        self.TOLERANCE_HIGH_STOCK = self.n / 4.0
        self.TOLERANCE_LOW_STOCK = self.n / 8.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.r
        current_stock = state.current_stock
        n_players = self.n
        if current_round_1_indexed == total_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        total_cooperators_prev_round = int(history.my_actions[-1]) + np.sum(history.opponent_actions[-1, :])
        num_defectors_prev_round = n_players - total_cooperators_prev_round
        if current_stock < self.MIN_CRITICAL_STOCK_THRESHOLD:
            return Action.C
        elif current_stock < self.LOW_STOCK_THRESHOLD:
            if num_defectors_prev_round > self.TOLERANCE_LOW_STOCK:
                return Action.D
            else:
                return Action.C
        elif num_defectors_prev_round > self.TOLERANCE_HIGH_STOCK:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_373(BaseStrategy):
    """
    Adaptive Collective Reciprocity (ACR) strategy for the Common Pool Resource Game.

    This strategy aims to foster collective cooperation and resource sustainability while
    remaining robust against defection from other players in a tournament setting. It
    prioritizes long-term well-being through conditional cooperation, rigorous punishment
    of free-riding, and offers forgiveness to re-establish cooperative equilibrium. It
    also includes protective measures for critically low stock levels and an end-game
    strategy to prevent exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self._n_players: int = game_description.n_players
        self._total_rounds: int = game_description.n_rounds
        self._capacity: float = float(game_description.capacity)
        self._LOW_STOCK_THRESHOLD_FACTOR: float = 0.25
        self._FORGIVENESS_WINDOW: int = 2
        self._END_GAME_DEFECT_ROUNDS: int = 2
        self._my_last_action: Action = Action.C
        self._current_stance: str = 'COOPERATING'
        self._rounds_since_full_cooperation: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed: int = state.round_number + 1
        if current_round_1_indexed == 1:
            chosen_action = Action.C
            self._my_last_action = chosen_action
            return chosen_action
        if state.current_stock < self._capacity * self._LOW_STOCK_THRESHOLD_FACTOR:
            chosen_action = Action.C
            self._current_stance = 'COOPERATING'
            self._rounds_since_full_cooperation = 0
            self._my_last_action = chosen_action
            return chosen_action
        if self._total_rounds - current_round_1_indexed < self._END_GAME_DEFECT_ROUNDS:
            chosen_action = Action.D
            self._current_stance = 'PUNISHING'
            self._rounds_since_full_cooperation = 0
            self._my_last_action = chosen_action
            return chosen_action
        num_others_cooperating_in_prev_round = int(np.sum(history.opponent_actions[-1, :]))
        chosen_action: Action
        if self._current_stance == 'COOPERATING':
            if num_others_cooperating_in_prev_round == self._n_players - 1:
                chosen_action = Action.C
                self._rounds_since_full_cooperation = 0
            else:
                chosen_action = Action.D
                self._current_stance = 'PUNISHING'
                self._rounds_since_full_cooperation = 0
        elif self._current_stance == 'PUNISHING':
            if num_others_cooperating_in_prev_round == self._n_players - 1:
                self._rounds_since_full_cooperation += 1
                if self._rounds_since_full_cooperation >= self._FORGIVENESS_WINDOW:
                    chosen_action = Action.C
                    self._current_stance = 'COOPERATING'
                    self._rounds_since_full_cooperation = 0
                else:
                    chosen_action = Action.D
            else:
                chosen_action = Action.D
                self._rounds_since_full_cooperation = 0
        self._my_last_action = chosen_action
        return chosen_action

class Strategy_COLLECTIVE_374(BaseStrategy):
    """
    Adaptive Stock Manager (ASM) strategy for the Common Pool Resource Game.

    This strategy aims to sustain the common resource through conditional cooperation
    and strategic responses to group behavior and resource health. It defaults to
    cooperation, prioritizes resource preservation when stock is low, and employs
    conditional reciprocity, punishing widespread defection while rewarding
    sufficient cooperation. In the final round, it defects to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.LOW_STOCK_THRESHOLD = self.capacity / 4.0
        self.COOPERATION_THRESHOLD_RATE = (self.n - 1) / self.n

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == 0:
            return Action.C
        if current_round_number == self.r - 1:
            return Action.D
        if current_stock < self.LOW_STOCK_THRESHOLD:
            return Action.C
        num_opponent_cooperators_prev_round = sum(history.opponent_actions[-1, :])
        my_action_was_cooperation = history.my_actions[-1]
        num_total_cooperators_prev_round = num_opponent_cooperators_prev_round + (1 if my_action_was_cooperation else 0)
        cooperation_rate_prev_round = num_total_cooperators_prev_round / self.n
        if cooperation_rate_prev_round < self.COOPERATION_THRESHOLD_RATE:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_375(BaseStrategy):
    """
    Adaptive Collective Sustainer (ACS) strategy for the Common Pool Resource Game.

    This strategy aims for sustainable resource management by balancing initial cooperation
    with adaptive responses to collective defection and resource depletion. It prioritizes
    resource recovery when stock levels are critical and retaliates against widespread
    free-riding when the stock is not critically low. It defects in the final round to
    maximize terminal payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_tolerance_threshold = 0.3
        self.stock_critical_threshold = 0.25
        self._last_round_stock = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        action_to_take: Action
        if current_round == 0:
            action_to_take = Action.C
        elif current_round == n_rounds - 1:
            action_to_take = Action.D
        else:
            num_opponent_cooperators_prev = np.sum(history.opponent_actions[-1, :])
            num_defectors_opponents_prev = n_players - 1 - num_opponent_cooperators_prev
            my_defection_prev = 1 - history.my_actions[-1]
            num_defectors_prev = num_defectors_opponents_prev + my_defection_prev
            S_prev_start = self._last_round_stock
            if current_stock < self.stock_critical_threshold * capacity:
                action_to_take = Action.C
            elif current_stock < S_prev_start:
                if num_defectors_prev > self.cooperation_tolerance_threshold * n_players:
                    action_to_take = Action.D
                else:
                    action_to_take = Action.C
            elif num_defectors_prev > self.cooperation_tolerance_threshold * n_players:
                action_to_take = Action.D
            else:
                action_to_take = Action.C
        self._last_round_stock = current_stock
        return action_to_take

class Strategy_COLLECTIVE_376(BaseStrategy):
    """
    The "Adaptive Resource Guardian" (ARG) is a collective strategy designed to promote long-term sustainability
    of the common pool resource while being adaptive and robust to various opponent behaviors.
    It balances initial cooperation with mechanisms for punishing defection and prioritizing resource recovery
    when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.num_rounds_in_punishment_mode = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t_1_indexed = state.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if current_round_t_1_indexed == n_rounds:
            return Action.D
        if current_round_t_1_indexed == 1:
            self.num_rounds_in_punishment_mode = 0
            return Action.C
        my_prev_action = history.my_actions[state.round_number - 1]
        opponent_prev_actions = history.opponent_actions[state.round_number - 1, :]
        all_prev_actions_np = np.concatenate(([my_prev_action], opponent_prev_actions))
        num_defectors_in_prev_round = np.sum(all_prev_actions_np == False)
        if state.current_stock < capacity / 2:
            self.num_rounds_in_punishment_mode = 0
            return Action.C
        if self.num_rounds_in_punishment_mode > 0:
            self.num_rounds_in_punishment_mode -= 1
            return Action.D
        else:
            trigger_punishment = False
            if n_players == 2:
                if not opponent_prev_actions[0]:
                    trigger_punishment = True
            elif num_defectors_in_prev_round >= 2:
                trigger_punishment = True
            if trigger_punishment:
                self.num_rounds_in_punishment_mode = 2
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_377(BaseStrategy):
    """
    Collective Custodian with Adaptive Reciprocity strategy for the Common Pool Resource Game.
    Prioritizes resource sustainability by defaulting to cooperation, monitoring collective
    cooperation, punishing persistent free-riding, offering forgiveness, and enforcing
    emergency resource conservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.is_punishing: bool = False
        self.COOPERATION_THRESHOLD_PUNISH: float = 0.75
        self.COOPERATION_THRESHOLD_FORGIVE: float = 0.9
        self.STOCK_CRITICAL_LEVEL_RATIO: float = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        num_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            self.is_punishing = False
            return Action.C
        if current_round == total_rounds - 1:
            return Action.D
        previous_my_action = history.my_actions[current_round - 1]
        previous_opponent_actions = history.opponent_actions[current_round - 1, :]
        num_cooperators_prev_round = (1 if previous_my_action else 0) + np.sum(previous_opponent_actions)
        coop_rate_prev_round = num_cooperators_prev_round / num_players
        if self.is_punishing:
            if coop_rate_prev_round >= self.COOPERATION_THRESHOLD_FORGIVE:
                self.is_punishing = False
        elif coop_rate_prev_round < self.COOPERATION_THRESHOLD_PUNISH:
            self.is_punishing = True
        if current_stock < self.STOCK_CRITICAL_LEVEL_RATIO * capacity:
            return Action.C
        if self.is_punishing:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_378(BaseStrategy):
    """
    Adaptive Sustainability Guardian: A strategy prioritizing long-term resource sustainability
    while adapting to collective behavior and stock health. It aims to promote collective welfare
    by initiating cooperation, deterring free-riding, and promoting resource recovery, while
    avoiding being a "sucker" if the collective effort unequivocally fails.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.recovery_target_stock = 0.9 * self.capacity
        self.healthy_stock_threshold = 0.5 * self.capacity
        self.danger_stock_threshold = 0.25 * self.capacity
        self.critical_stock_threshold = 0.05 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock_S = state.current_stock
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.C
        prev_round_idx = current_round_0_indexed - 1
        prev_my_action = history.my_actions[prev_round_idx]
        prev_opponent_actions = history.opponent_actions[prev_round_idx, :]
        num_cooperators_prev_round = np.sum(prev_opponent_actions) + (1 if prev_my_action else 0)
        num_defectors_prev_round = self.n_players - num_cooperators_prev_round
        if current_stock_S >= self.recovery_target_stock:
            if num_defectors_prev_round == 0:
                return Action.C
            else:
                return Action.D
        elif current_stock_S >= self.healthy_stock_threshold:
            if num_defectors_prev_round == 0:
                return Action.C
            else:
                return Action.D
        elif current_stock_S >= self.danger_stock_threshold:
            if num_defectors_prev_round <= 1:
                return Action.C
            else:
                return Action.D
        elif current_stock_S > self.critical_stock_threshold:
            if num_defectors_prev_round == 0:
                return Action.C
            elif num_defectors_prev_round <= self.n_players / 4.0:
                return Action.C
            else:
                return Action.D
        elif num_defectors_prev_round <= self.n_players / 2.0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_379(BaseStrategy):
    """
    The Adaptive Enforcer of Sustainability strategy aims to achieve high collective payoffs
    by promoting and enforcing sustainable resource management in the Common Pool Resource Game,
    while being robust and adaptive to opponent behaviors.

    It prioritizes sustainability, strictly enforces cooperation when the resource is healthy,
    shows adaptive forgiveness when the resource is critical, and employs self-preservation
    measures against rampant exploitation. In the final round, it balances immediate gain
    with collective consideration based on resource health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.COOPERATION_THRESHOLD_NORMAL = 1.0
        self.COOPERATION_THRESHOLD_CRITICAL = (self.n_players - 1.0) / self.n_players
        self.STOCK_CRITICAL_LEVEL = self.capacity / 2.0
        self.STOCK_EMERGENCY_LEVEL = self.capacity / (2.0 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if state.round_number == 0:
            return Action.C
        my_last_action = history.my_actions[state.round_number - 1]
        opponents_last_actions = history.opponent_actions[state.round_number - 1, :]
        num_cooperators_last_round = int(my_last_action) + np.sum(opponents_last_actions)
        proportion_cooperators = num_cooperators_last_round / self.n_players
        if current_round_1_indexed == self.n_rounds:
            if current_stock >= self.STOCK_CRITICAL_LEVEL:
                return Action.D
            else:
                return Action.C
        elif current_stock >= self.STOCK_CRITICAL_LEVEL:
            if proportion_cooperators >= self.COOPERATION_THRESHOLD_NORMAL:
                return Action.C
            else:
                return Action.D
        elif current_stock >= self.STOCK_EMERGENCY_LEVEL:
            if proportion_cooperators >= self.COOPERATION_THRESHOLD_CRITICAL:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_380(BaseStrategy):
    """
    The Adaptive Collective Harvester (ACH) strategy is designed for the Common Pool
    Resource Game. It aims to be collective, adaptive, and robust by balancing:
    1.  Sustainable Resource Management: Prioritizing long-term stock health.
    2.  Reciprocity and Enforcement: Responding to others' cooperation or defection.
    3.  Self-Preservation: Avoiding exploitation.
    4.  Endgame Rationality: Adjusting behavior when the game horizon is known.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_critical_threshold_ratio = 0.4
        self.cooperation_tolerance_threshold = 0.75
        self.critical_mode_min_cooperation = 0.05
        self._stock_critical_threshold = self.capacity * self.stock_critical_threshold_ratio

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        else:
            num_others_cooperated = sum(history.opponent_actions[-1, :])
            cooperation_rate_others = num_others_cooperated / (self.n_players - 1)
            if current_stock < self._stock_critical_threshold:
                if cooperation_rate_others > self.critical_mode_min_cooperation:
                    return Action.C
                else:
                    return Action.D
            elif cooperation_rate_others >= self.cooperation_tolerance_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_381(BaseStrategy):
    """
    Adaptive Stock-Contingent Reciprocity (ASCR) strategy for the Common Pool Resource Game.
    ASCR aims for resource sustainability, cooperating when the stock is healthy and others
    cooperate, but defecting when the resource is threatened or exploitation is observed.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the ASCR strategy with game parameters and tunable thresholds.

        Args:
            game_description (CommonPoolDescription): Object containing game parameters like
                                                    n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.COOPERATION_THRESHOLD_STOCK_RATIO = 0.75
        self.WARNING_STOCK_THRESHOLD_RATIO = 0.4
        self.CRITICAL_STOCK_THRESHOLD_RATIO = 0.1
        self.MAX_TOLERATED_DEFECTORS_HEALTHY_STOCK = max(1, math.floor(self.game_description.n_players / 4))
        self.MAX_TOLERATED_DEFECTORS_WARNING_STOCK = 0
        self.MAX_TOLERATED_DEFECTORS_CRITICAL_STOCK = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (C for Cooperate, D for Defect) for the current round
        based on the ASCR strategy's decision rules.

        Args:
            state (CommonPoolState): Current state of the game, including round number and stock level.
            history (None | PlayerHistory): Past actions and payoffs. Is None for the very first round.

        Returns:
            Action: The chosen action, either Action.C (Cooperate) or Action.D (Defect).
        """
        current_round_t = state.round_number + 1
        total_rounds_r = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        num_players = self.game_description.n_players
        if current_round_t == 1:
            return Action.C
        if current_round_t == total_rounds_r:
            return Action.D
        num_cooperators_prev_round = int(history.my_actions[-1]) + sum(history.opponent_actions[-1, :])
        D_prev_round_count = num_players - num_cooperators_prev_round
        healthy_stock_level_boundary = self.COOPERATION_THRESHOLD_STOCK_RATIO * capacity
        warning_stock_level_boundary = self.WARNING_STOCK_THRESHOLD_RATIO * capacity
        critical_stock_level_boundary = self.CRITICAL_STOCK_THRESHOLD_RATIO * capacity
        if current_stock >= healthy_stock_level_boundary:
            if D_prev_round_count <= self.MAX_TOLERATED_DEFECTORS_HEALTHY_STOCK:
                return Action.C
            else:
                return Action.D
        elif current_stock >= warning_stock_level_boundary:
            if D_prev_round_count <= self.MAX_TOLERATED_DEFECTORS_WARNING_STOCK:
                return Action.C
            else:
                return Action.D
        elif current_stock >= critical_stock_level_boundary:
            if D_prev_round_count <= self.MAX_TOLERATED_DEFECTORS_CRITICAL_STOCK:
                return Action.C
            else:
                return Action.D
        elif D_prev_round_count == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_382(BaseStrategy):
    """
    The "Adaptive Stock Guardian" (ASG) strategy is designed to navigate the Common Pool Resource Game
    by balancing individual rationality with the imperative of collective resource sustainability.
    It begins cooperatively, defects in the final round, and in intermediate rounds, it prioritizes
    resource recovery when stock is critically low. When the stock is healthy, it adapts by punishing
    widespread defection to encourage a return to cooperative norms.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Stock Guardian strategy.

        Args:
            game_description: An object containing game parameters like n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.CRITICAL_STOCK_RATIO = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round based on the ASG strategy.

        Args:
            state: An object containing the current round number and stock level.
            history: An object containing historical actions and payoffs for all players.
                     None for the very first round (round_number == 0).

        Returns:
            Action: The chosen action, either Action.C (Cooperate) or Action.D (Defect).
        """
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        current_round_number = state.round_number
        if current_round_number == 0:
            return Action.C
        if current_round_number == total_rounds - 1:
            return Action.D
        num_cooperators_prev_round = sum(history.opponent_actions[current_round_number - 1, :])
        num_opponents = n_players - 1
        num_D_prev = num_opponents - num_cooperators_prev_round
        if current_stock < self.CRITICAL_STOCK_RATIO * capacity:
            return Action.C
        else:
            HEALTHY_STOCK_DEFECTOR_TOLERANCE = (n_players - 1) // 2
            if num_D_prev > HEALTHY_STOCK_DEFECTOR_TOLERANCE:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_383(BaseStrategy):
    """
    Adaptive Sustainability Guardian (ASG) strategy for the Common Pool Resource Game.
    This strategy is designed to maximize total collective payoff by prioritizing
    the maintenance of the common stock at capacity. It combines initial cooperation,
    dynamic adaptation to resource health, and a Tit-for-Tat-like retaliation
    mechanism against defectors, while optimizing for immediate gain in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.C
        elif current_stock < capacity / 2:
            return Action.C
        else:
            my_prev_action_was_D = not history.my_actions[-1]
            opponent_defect_count_prev = sum(~history.opponent_actions[-1, :])
            total_defectors_prev = (1 if my_prev_action_was_D else 0) + opponent_defect_count_prev
            if total_defectors_prev == 0:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_384(BaseStrategy):
    """
    Adaptive Conservation & Reciprocity (ACR) strategy for the Common Pool Resource Game.
    This strategy aims to promote resource sustainability through conditional cooperation,
    while protecting itself from exploitation by strategically defecting when cooperation
    is not reciprocated by other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.conservation_threshold_low = self.game_description.capacity / 2.0
        self.cooperation_tolerance_threshold = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        else:
            previous_round_0_indexed = current_round_0_indexed - 1
            observed_cooperators = history.my_actions[previous_round_0_indexed] + np.sum(history.opponent_actions[previous_round_0_indexed, :])
            n_players = self.game_description.n_players
            cooperation_ratio = observed_cooperators / n_players
            if cooperation_ratio < self.cooperation_tolerance_threshold:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_385(BaseStrategy):
    """
    Adaptive Sustainable Reciprocity (ASR) strategy for the Common Pool Resource Game.

    This strategy aims to achieve sustainable management of the common pool resource through
    conditional cooperation. It prioritizes the collective good by attempting to maintain
    the stock at a healthy level, but also employs mechanisms to deter free-riding and
    ensure self-preservation. It reacts to the observed health of the common stock as an
    indicator of collective behavior, rather than trying to infer individual actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.epsilon_S = 0.05 * self.capacity
        self.critical_stock_ratio = 0.1
        self.stock_history: list[float] = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_history.append(state.current_stock)
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        S_prev = self.stock_history[current_round_0_indexed - 1]
        if current_stock < self.critical_stock_ratio * self.capacity:
            return Action.D
        if current_stock >= self.capacity - self.epsilon_S:
            return Action.C
        S_after_consumption_if_all_C = S_prev - S_prev / 2.0
        S_after_consumption_if_all_C = max(0.0, S_after_consumption_if_all_C)
        growth_if_all_C = 2.0 * S_after_consumption_if_all_C * (1.0 - S_after_consumption_if_all_C / self.capacity)
        S_expected_all_C_curr = min(S_after_consumption_if_all_C + growth_if_all_C, self.capacity)
        if current_stock < S_expected_all_C_curr - self.epsilon_S:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_386(BaseStrategy):
    """
    The Adaptive Collective Steward (ACS) strategy aims to foster widespread cooperation,
    maintain the health of the common pool resource, and prevent exploitation by defectors.
    It balances individual rationality with collective sustainability, adapting its behavior
    based on the observed actions of others and the state of the resource.

    It operates in three phases:
    1. Initial Exploration (Round 1): Cooperates to signal willingness and observe others.
    2. Dynamic Reciprocity with Resource Preservation (Intermediate Rounds):
       - If stock is critically low (< 25% capacity), it cooperates to prioritize recovery.
       - Otherwise, it employs strict Tit-for-Tat-N: cooperates if all others cooperated
         in the previous round, and defects if any other player defected.
    3. End-Game Exploitation (Last Round): Defects, due to the lack of future consequences
       and individual rationality.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players: int = game_description.n_players
        self.n_rounds: int = game_description.n_rounds
        self.capacity: float = float(game_description.capacity)
        self.recovery_threshold_stock: float = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed: int = state.round_number + 1
        current_stock: float = state.current_stock
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_stock < self.recovery_threshold_stock:
            return Action.C
        prev_round_opponent_actions: NDArray[np.bool_] = history.opponent_actions[-1, :]
        num_other_defectors_prev = np.sum(~prev_round_opponent_actions)
        if num_other_defectors_prev == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_387(BaseStrategy):
    """
    The "Adaptive Collective Sustainer" strategy aims to maintain the common resource at healthy levels
    through cooperation. It prioritizes collective sustainability but incorporates adaptive mechanisms
    to prevent exploitation when others defect or when the resource is severely depleted. It starts
    cooperatively, attempts to sustain cooperation, retaliates against widespread defection, and
    adjusts behavior when the resource is at risk.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.

        Args:
            game_description (CommonPoolDescription): An object containing game parameters like
                                                     number of players, rounds, and capacity.
        """
        self.game_description = game_description
        self.critical_stock_threshold = self.game_description.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate 'C' or Defect 'D') for the current round.

        Args:
            state (CommonPoolState): An object containing the current round number (0-indexed)
                                     and the current stock level.
            history (None | PlayerHistory): An object containing records of past actions and payoffs.
                                            It is None for the very first round (state.round_number == 0).

        Returns:
            Action: 'C' for Cooperate, 'D' for Defect.
        """
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == total_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        my_prev_action = history.my_actions[state.round_number - 1]
        opponents_prev_actions = history.opponent_actions[state.round_number - 1, :]
        all_prev_actions = np.concatenate(([my_prev_action], opponents_prev_actions))
        total_defectors_prev_round = np.sum(~all_prev_actions)
        if current_stock <= self.critical_stock_threshold:
            if total_defectors_prev_round == 0:
                return Action.C
            else:
                return Action.D
        elif total_defectors_prev_round >= n_players / 2.0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_388(BaseStrategy):
    """
    The "Adaptive Conservationist" strategy aims to promote collective cooperation and ensure the
    sustainability of the common resource, while being adaptive to the behavior of other players
    and the current state of the stock. It prioritizes the health of the common pool above all
    else when the resource is at risk, and otherwise strives to maintain a cooperative environment
    through conditional cooperation and retaliation against significant defection.
    """
    _COOPERATION_TOLERANCE_RATE_DEFAULT = 0.8

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_tolerance_rate = self._COOPERATION_TOLERANCE_RATE_DEFAULT
        self.low_stock_threshold = self.game_description.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        num_cooperators_prev_round = sum(history.opponent_actions[-1, :]) + history.my_actions[-1]
        cooperation_rate_prev_round = num_cooperators_prev_round / self.game_description.n_players
        if state.current_stock < self.low_stock_threshold:
            return Action.C
        elif cooperation_rate_prev_round >= self.cooperation_tolerance_rate:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_389(BaseStrategy):
    """
    The Adaptive Forgiving Sustainer (AFS) strategy aims to foster and maintain cooperation
    in the common pool resource game. It starts cooperatively, dynamically adjusts its
    cooperation demands based on the stock level, punishes significant collective defection,
    but remains open to re-establishing cooperation, and acts rationally in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.baseline_C_threshold: float = 0.6
        self.my_stance: Action = Action.C

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.my_stance = Action.C
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        num_cooperators_others: int = sum(history.opponent_actions[-1, :])
        num_others: int = self.game_description.n_players - 1
        cooperation_rate_others: float
        if num_others > 0:
            cooperation_rate_others = num_cooperators_others / num_others
        else:
            cooperation_rate_others = 1.0
        stock_ratio = state.current_stock / self.game_description.capacity
        stock_ratio = max(0.0, min(1.0, stock_ratio))
        C_dynamic_threshold = self.baseline_C_threshold + (1.0 - self.baseline_C_threshold) * (1.0 - stock_ratio)
        C_dynamic_threshold = max(0.0, min(1.0, C_dynamic_threshold))
        if cooperation_rate_others >= C_dynamic_threshold:
            self.my_stance = Action.C
        else:
            self.my_stance = Action.D
        return self.my_stance

class Strategy_COLLECTIVE_390(BaseStrategy):
    """
    The "Dynamic Conservationist with Adaptive Reciprocity" strategy aims to maintain the common
    resource pool at a sustainable level while adaptively responding to the behavior of other
    players and preventing exploitation. It balances the collective goal of resource preservation
    with the individual need for robustness against defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.OPTIMAL_STOCK_THRESHOLD: float = self.capacity * 0.9
        self.HEALTHY_STOCK_THRESHOLD: float = self.capacity / 2
        self.CRITICAL_STOCK_THRESHOLD: float = self.capacity / 4
        if self.n <= 3:
            self.FORGIVENESS_THRESHOLD_HEALTHY: int = 0
            self.FORGIVENESS_THRESHOLD_CRITICAL: int = 1
        else:
            self.FORGIVENESS_THRESHOLD_HEALTHY: int = max(0, math.floor(self.n / 4) - 1)
            self.FORGIVENESS_THRESHOLD_CRITICAL: int = max(1, math.floor(self.n / 2) - 1)
        self.ENDGAME_HORIZON_ROUNDS: int = max(1, math.floor(self.r / 5))
        self.my_last_action: Action = Action.C
        self.rounds_since_last_all_coop: int = 0
        self.consecutive_significant_defection: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if state.round_number == 0:
            my_action = Action.C
            self.my_last_action = my_action
            return my_action
        if current_round_1_indexed > self.r - self.ENDGAME_HORIZON_ROUNDS:
            my_action = Action.D
            self.my_last_action = my_action
            return my_action
        prev_round_idx = state.round_number - 1
        prev_opponent_actions = history.opponent_actions[prev_round_idx]
        prev_my_action_from_history = history.my_actions[prev_round_idx]
        k_D_prev = (prev_opponent_actions == Action.D.value).sum() + (1 if prev_my_action_from_history == Action.D.value else 0)
        if k_D_prev == 0:
            self.rounds_since_last_all_coop = 0
            self.consecutive_significant_defection = 0
        else:
            self.rounds_since_last_all_coop += 1
            if k_D_prev > self.FORGIVENESS_THRESHOLD_HEALTHY + 1:
                self.consecutive_significant_defection += 1
            else:
                self.consecutive_significant_defection = 0
        if self.consecutive_significant_defection >= 2 and k_D_prev >= self.n - 1:
            my_action = Action.D
            self.my_last_action = my_action
            return my_action
        my_action: Action
        if state.current_stock < self.CRITICAL_STOCK_THRESHOLD:
            if k_D_prev > self.FORGIVENESS_THRESHOLD_CRITICAL:
                my_action = Action.D
            else:
                my_action = Action.C
        elif state.current_stock < self.HEALTHY_STOCK_THRESHOLD:
            if k_D_prev > self.FORGIVENESS_THRESHOLD_CRITICAL:
                my_action = Action.D
            else:
                my_action = Action.C
        elif state.current_stock < self.OPTIMAL_STOCK_THRESHOLD:
            if k_D_prev > self.FORGIVENESS_THRESHOLD_HEALTHY:
                my_action = Action.D
            else:
                my_action = Action.C
        elif k_D_prev > self.FORGIVENESS_THRESHOLD_HEALTHY:
            my_action = Action.D
        else:
            my_action = Action.C
        self.my_last_action = my_action
        return my_action

class Strategy_COLLECTIVE_391(BaseStrategy):
    """
    Sustainable Reciprocity with Stock Thresholds strategy for the Common Pool Resource Game.

    This strategy aims to promote long-term resource sustainability and collective welfare
    by using conditional cooperation based on the common pool's health and observed opponent
    behavior. It prioritizes resource replenishment but avoids exploitation.

    Decision Rules:
    1. First Round: Always Cooperate (C).
    2. Last Round: Always Defect (D).
    3. Intermediate Rounds:
       - Calculate previous round's average defection rate.
       - Use CRITICAL_STOCK_THRESHOLD (capacity / (2 * n)) and DEPLETING_STOCK_THRESHOLD (capacity / 2).
       - If stock < CRITICAL_STOCK_THRESHOLD: Defect (survival strategy).
       - If CRITICAL_STOCK_THRESHOLD <= stock < DEPLETING_STOCK_THRESHOLD:
         - If avg_defection_rate > 0.5: Defect.
         - Else: Cooperate.
       - If stock >= DEPLETING_STOCK_THRESHOLD:
         - If avg_defection_rate > 0.33: Defect.
         - Else: Cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / (2.0 * self.n)
        self.DEPLETING_STOCK_THRESHOLD = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.r - 1:
            return Action.D
        num_cooperators_prev_round = history.opponent_actions[-1, :].sum()
        num_defectors_prev_round = self.n - 1 - num_cooperators_prev_round
        my_action_prev_round = history.my_actions[-1]
        total_defectors_prev_round = self.n - 1 - num_cooperators_prev_round + (1 if not my_action_prev_round else 0)
        avg_defection_rate = total_defectors_prev_round / self.n
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.D
        elif current_stock < self.DEPLETING_STOCK_THRESHOLD:
            if avg_defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        elif avg_defection_rate > 0.33:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_392(BaseStrategy):
    """
    Adaptive Resource Guardian (ARG) strategy for the Common Pool Resource Game.
    It prioritizes resource conservation, employs collective reciprocity,
    adaptive punishment, and forgiveness for survival based on stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_endangered = self.capacity / 4.0
        self.S_stressed = self.capacity / 2.0
        self.S_healthy = 3.0 * self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.C
        prev_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        my_prev_action = history.my_actions[current_round_0_indexed - 1]
        prev_C_count_all_players = np.sum(prev_opponent_actions) + int(my_prev_action)
        prev_D_count_all_players = self.n_players - prev_C_count_all_players
        if current_stock <= self.S_endangered:
            return Action.C
        elif current_stock <= self.S_stressed:
            if prev_D_count_all_players > self.n_players / 4.0:
                return Action.D
            else:
                return Action.C
        elif current_stock <= self.S_healthy:
            if prev_C_count_all_players >= self.n_players / 2.0:
                return Action.C
            else:
                return Action.D
        elif prev_C_count_all_players >= self.n_players - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_393(BaseStrategy):
    """
    The Collective Guardian strategy for the Common Pool Resource Game.
    Prioritizes sustainability, enforces cooperation, and employs self-preservation.
    It balances ideal collective outcomes with self-preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.N_PLAYERS = game_description.n_players
        self.TOTAL_ROUNDS = game_description.n_rounds
        self.CAPACITY = game_description.capacity
        self.COOPERATION_THRESHOLD_RATE = 0.8
        self.STOCK_CRITICAL_LOW_THRESHOLD = self.CAPACITY / 4
        self.STOCK_RECOVERY_THRESHOLD = self.CAPACITY * 0.75
        self.FORGIVENESS_STREAK_REQUIRED = 2
        self.my_current_stance: str = 'COOPERATING'
        self.consecutive_full_cooperation_rounds: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            self.my_current_stance = 'COOPERATING'
            self.consecutive_full_cooperation_rounds = 0
            return Action.C
        if current_round_0_indexed == self.TOTAL_ROUNDS - 1:
            return Action.D
        num_other_players = self.N_PLAYERS - 1
        num_cooperators_prev_round = sum(history.opponent_actions[-1, :])
        num_defectors_prev_round = num_other_players - num_cooperators_prev_round
        if num_defectors_prev_round == 0:
            self.consecutive_full_cooperation_rounds += 1
        else:
            self.consecutive_full_cooperation_rounds = 0
        cooperation_rate_others = num_cooperators_prev_round / num_other_players
        if current_stock < self.STOCK_CRITICAL_LOW_THRESHOLD:
            self.my_current_stance = 'DEFENDING'
            return Action.D
        if self.my_current_stance == 'COOPERATING':
            if cooperation_rate_others < self.COOPERATION_THRESHOLD_RATE:
                self.my_current_stance = 'WARNING'
                return Action.D
            else:
                return Action.C
        elif self.my_current_stance == 'WARNING':
            if self.consecutive_full_cooperation_rounds >= self.FORGIVENESS_STREAK_REQUIRED:
                self.my_current_stance = 'COOPERATING'
                return Action.C
            else:
                return Action.D
        elif self.my_current_stance == 'DEFENDING':
            if current_stock >= self.STOCK_RECOVERY_THRESHOLD:
                self.my_current_stance = 'COOPERATING'
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_394(BaseStrategy):
    """
    The Adaptive Resource Guardian strategy for the Common Pool Resource Game.
    It prioritizes long-term resource sustainability and adapts to opponent behavior
    and current stock levels. It starts cooperatively, defects in the final round,
    and in intermediate rounds uses conditional cooperation/defection based on stock
    levels and previous round's observed defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_CRITICAL = self.capacity / (2 * self.n_players)
        self.S_MODERATE_THRESHOLD = self.capacity * 0.5
        self.D_PUNISH_THRESHOLD_LOW_STOCK = max(1, int(self.n_players / 4 + 0.5))
        self.D_PUNISH_THRESHOLD_HIGH_STOCK = max(1, int(self.n_players / 2 + 0.5))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        previous_round_my_action = history.my_actions[current_round_0_indexed - 1]
        opponent_D_count = np.sum(~previous_round_opponent_actions)
        my_D_count = 1 if not previous_round_my_action else 0
        d_count = opponent_D_count + my_D_count
        if current_stock <= self.S_CRITICAL:
            return Action.C
        elif current_stock <= self.S_MODERATE_THRESHOLD:
            if d_count >= self.D_PUNISH_THRESHOLD_LOW_STOCK:
                return Action.D
            else:
                return Action.C
        elif d_count >= self.D_PUNISH_THRESHOLD_HIGH_STOCK:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_395(BaseStrategy):
    """
    The Adaptive Conservationist strategy for the Common Pool Resource Game.
    This strategy prioritizes long-term resource sustainability through
    cooperation, punishes defection to encourage overall cooperation,
    and safeguards against exploitation. It is designed to be robust, adaptive,
    and collectively-minded in a tournament setting against unknown opponents.
    """
    PUNISHMENT_DURATION = 2

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.my_punishment_counter: int = 0
        self.observed_defection_streak: int = 0
        self.STOCK_CRISIS_THRESHOLD: float = self.game_description.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round >= total_rounds - 2:
            return Action.D
        if current_stock < self.STOCK_CRISIS_THRESHOLD:
            self.my_punishment_counter = 0
            self.observed_defection_streak = 0
            return Action.C
        if self.my_punishment_counter > 0:
            self.my_punishment_counter -= 1
            return Action.D
        if current_round == 0:
            return Action.C
        prev_opponent_actions = history.opponent_actions[-1, :]
        any_other_player_defected = False
        for action_bool in prev_opponent_actions:
            if not action_bool:
                any_other_player_defected = True
                break
        if any_other_player_defected:
            self.observed_defection_streak += 1
            if self.observed_defection_streak >= 1:
                self.my_punishment_counter = self.PUNISHMENT_DURATION
                self.observed_defection_streak = 0
                return Action.D
        else:
            self.observed_defection_streak = 0
            return Action.C

class Strategy_COLLECTIVE_396(BaseStrategy):
    """
    The Adaptive Collective Conservation (ACC) strategy for the Common Pool Resource Game.
    This strategy balances individual incentives with the collective need for resource
    sustainability. It prioritizes maintaining the health of the common stock while
    being adaptive to the observed behaviors of other players, using proactive
    cooperation, stock-dependent responsiveness, and a measured approach to punishment.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.num_other_defectors_last_round: int = 0
        self.consecutive_punishment_rounds: int = 0
        self.S_target_cooperation: float = 0.8 * self.game_description.capacity
        self.S_warning_threshold: float = 0.5 * self.game_description.capacity
        self.S_critical_threshold: float = 0.25 * self.game_description.capacity
        self.defection_response_threshold_ratio: float = 0.33

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == 0:
            self.num_other_defectors_last_round = 0
            self.consecutive_punishment_rounds = 0
            return Action.C
        num_other_defectors_current_calc = 0
        for opponent_action in history.opponent_actions[-1, :]:
            if not opponent_action:
                num_other_defectors_current_calc += 1
        self.num_other_defectors_last_round = num_other_defectors_current_calc
        if current_round_0_indexed == r - 1:
            return Action.D
        if self.consecutive_punishment_rounds > 0:
            self.consecutive_punishment_rounds -= 1
            return Action.D
        significant_defection_occurred = False
        if self.num_other_defectors_last_round / (n - 1) >= self.defection_response_threshold_ratio:
            significant_defection_occurred = True
        if current_stock < self.S_critical_threshold:
            if r - current_round_0_indexed <= 2:
                return Action.D
            else:
                return Action.C
        elif current_stock < self.S_warning_threshold:
            if significant_defection_occurred:
                self.consecutive_punishment_rounds = 1
                return Action.D
            else:
                return Action.C
        elif significant_defection_occurred:
            self.consecutive_punishment_rounds = 2
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_397(BaseStrategy):
    """
    Adaptive Collective Sustainment (ACS) strategy for the Common Pool Resource Game.
    Prioritizes long-term sustainability through cooperation, adapting to resource health
    and opponent behavior. It defects to punish exploiters, signals for cooperation in dire
    situations, or mitigates individual losses when collective failure is imminent.
    """
    _COOPERATION_THRESHOLD_RATIO: float = 0.6
    _STOCK_DANGER_THRESHOLD_FACTOR: float = 0.75
    _STOCK_CRITICAL_THRESHOLD_FACTOR: float = 0.25
    _FORGIVENESS_WINDOW: int = 3

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the ACS strategy with game parameters and strategy-specific thresholds.
        """
        self.game_description = game_description
        self.cooperation_threshold_ratio = self._COOPERATION_THRESHOLD_RATIO
        self.stock_danger_threshold_factor = self._STOCK_DANGER_THRESHOLD_FACTOR
        self.stock_critical_threshold_factor = self._STOCK_CRITICAL_THRESHOLD_FACTOR
        self.forgiveness_window = self._FORGIVENESS_WINDOW

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (C or D) for the current player in the current round
        based on the ACS strategy rules.

        Args:
            state (CommonPoolState): The current state of the game, including round number and stock.
            history (None | PlayerHistory): The history of actions and payoffs. None for the first round.

        Returns:
            Action: 'C' for Cooperate or 'D' for Defect.
        """
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        stock_danger_threshold = self.game_description.capacity * self.stock_danger_threshold_factor
        stock_critical_threshold = self.game_description.capacity * self.stock_critical_threshold_factor
        prev_round_idx = state.round_number - 1
        prev_round_opponent_actions = history.opponent_actions[prev_round_idx]
        num_cooperators_prev = np.sum(prev_round_opponent_actions)
        num_others = self.game_description.n_players - 1
        cooperation_ratio_prev = num_cooperators_prev / num_others
        is_others_cooperating_enough = cooperation_ratio_prev >= self.cooperation_threshold_ratio
        if state.current_stock >= stock_danger_threshold:
            if is_others_cooperating_enough:
                return Action.C
            else:
                return Action.D
        elif state.current_stock >= stock_critical_threshold:
            if is_others_cooperating_enough:
                return Action.C
            elif self.game_description.n_rounds - state.round_number <= self.forgiveness_window:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_398(BaseStrategy):
    """
    The "Adaptive Guardian of the Commons" strategy aims for long-term resource
    sustainability while adapting to observed player behavior. It prioritizes
    cooperation to maintain the common pool but will retaliate against significant
    defection and act to maximize individual gain in the last round or under
    extreme resource depletion if collective recovery seems impossible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.
        """
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides whether to Cooperate (C) or Defect (D) based on the current game state
        and historical play.

        Parameters:
        - state (CommonPoolState): The current state of the game for this round.
        - history (None | PlayerHistory): Historical actions and payoffs for all players
                                          up to the end of the previous round. None for
                                          the first round (round 0).

        Returns:
        - Action: The chosen action (Action.C for Cooperate, Action.D for Defect).
        """
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        n_D_last_round = 0.0
        if current_round_1_indexed > 1 and history is not None:
            last_round_idx = state.round_number - 1
            my_action_prev = history.my_actions[last_round_idx]
            my_payoff_prev = history.my_payoffs[last_round_idx]
            stock_last_round = 0.0
            if my_payoff_prev == 0:
                stock_last_round = 0.0
            elif my_action_prev == Action.C.value:
                stock_last_round = my_payoff_prev * 2 * n
            else:
                stock_last_round = my_payoff_prev * n
            stock_last_round = max(0.0, stock_last_round)
            total_consumption_last_round = 0.0
            if stock_last_round > 0:
                n_C_actual_prev = np.sum(history.my_actions[last_round_idx] == Action.C.value) + np.sum(history.opponent_actions[last_round_idx, :] == Action.C.value)
                n_D_actual_prev = n - n_C_actual_prev
                consumption_per_C = stock_last_round / (2 * n) if 2 * n > 0 else 0.0
                consumption_per_D = stock_last_round / n if n > 0 else 0.0
                total_consumption_last_round = n_C_actual_prev * consumption_per_C + n_D_actual_prev * consumption_per_D
                total_consumption_last_round = min(total_consumption_last_round, stock_last_round)
            if stock_last_round > 0:
                n_C_derived_float = 2 * n - 2 * n * total_consumption_last_round / stock_last_round
                n_D_derived_float = n - n_C_derived_float
                n_D_last_round = max(0, min(n, round(n_D_derived_float)))
            else:
                n_D_last_round = n
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == r:
            return Action.D
        if current_stock < capacity / 4:
            if n_D_last_round > n / 2:
                return Action.D
            else:
                return Action.C
        else:
            defection_tolerance_count = max(1, n // 4)
            if n_D_last_round > defection_tolerance_count:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_399(BaseStrategy):
    """
    The "Collective Guardian with Adaptive Forgiveness" strategy is designed to promote the long-term
    sustainability of the common pool resource. It prioritizes the resource's survival and attempts
    to foster cooperation by responding to other players' actions, while protecting itself from exploitation.

    Decision rules are applied in the following priority order:
    1.  **Last Round Strategy:** Defect in the final round to maximize immediate payoff.
    2.  **Resource Crisis Strategy:** Cooperate if the stock falls below a critical ratio to aid resource recovery.
    3.  **Punishment/Adaptation Strategy:** Defect if a significant number of other players defected in the previous round.
    4.  **Default Cooperative Strategy:** Cooperate if none of the above conditions are met, promoting sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_RATIO: float = 0.25
        self.DEFECTION_TOLERANCE_THRESHOLD: int = round(0.5 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == n_rounds - 1:
            return Action.D
        if current_stock < self.CRITICAL_STOCK_RATIO * capacity:
            return Action.C
        num_defectors_last_round = 0
        if current_round > 0 and history is not None:
            num_defectors_last_round = np.sum(~history.opponent_actions[-1, :])
        if num_defectors_last_round >= self.DEFECTION_TOLERANCE_THRESHOLD:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_400(BaseStrategy):
    """
    The Adaptive Steward strategy prioritizes long-term resource sustainability.
    It employs conditional reciprocity: forgiving minor defections when the resource is healthy,
    but strictly conserving during scarcity and punishing widespread defection.
    It aims to maximize collective long-term payoff while being robust in various scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.punishment_mode: bool = False
        self.consecutive_cooperation_rounds: int = 0
        self.CRITICAL_STOCK_EMERGENCY_THRESHOLD: float = capacity / (2 * n)
        self.FINAL_ROUND_LOW_STOCK_THRESHOLD: float = capacity / 4
        self.STOCK_NOT_ROBUST_THRESHOLD: float = capacity * 0.75
        self.FORGIVENESS_WINDOW: int = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round == 0:
            self.punishment_mode = False
            self.consecutive_cooperation_rounds = 0
            return Action.C
        num_opponent_defectors = np.sum(~history.opponent_actions[-1, :])
        my_defection_prev = 1 if not history.my_actions[-1] else 0
        k_D_prev = num_opponent_defectors + my_defection_prev
        if k_D_prev == 0:
            self.consecutive_cooperation_rounds += 1
        else:
            self.consecutive_cooperation_rounds = 0
        if current_round == total_rounds - 1:
            if current_stock < self.FINAL_ROUND_LOW_STOCK_THRESHOLD:
                return Action.C
            else:
                return Action.D
        if current_stock < self.CRITICAL_STOCK_EMERGENCY_THRESHOLD:
            self.punishment_mode = False
            return Action.C
        if self.punishment_mode:
            if self.consecutive_cooperation_rounds >= self.FORGIVENESS_WINDOW:
                self.punishment_mode = False
                return Action.C
            else:
                return Action.D
        if k_D_prev > 0:
            if k_D_prev > 1:
                self.punishment_mode = True
                return Action.D
            elif current_stock < self.STOCK_NOT_ROBUST_THRESHOLD:
                self.punishment_mode = True
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_401(BaseStrategy):
    """
    Adaptive Collective Stewardship (ACS) strategy for the Common Pool Resource Game.
    This strategy balances resource preservation with conditional cooperation and retaliation,
    adapting to current stock levels and observed past player behavior.

    Core Principles:
    1. Pro-social Start: Begin by cooperating.
    2. Resource Preservation Override: Cooperate unconditionally if stock is critically low.
    3. Conditional Cooperation/Retaliation: Cooperate if others are largely cooperative when stock is healthy; otherwise, defect.
    4. End-Game Rationality: Defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters and internal strategy constants.

        Args:
            game_description: An object containing game parameters like n_players, n_rounds, capacity.
        """
        self.game_description = game_description
        self.S_CRITICAL_RATIO = 0.5
        self.COOPERATION_FORGIVENESS_THRESHOLD = 1

    def _infer_cooperation_count(self, S_prev_round_start: float, total_consumption_prev_round: float, n: int) -> int:
        """
        Deduces the approximate number of cooperators (k_C_inferred) in the previous round
        based on the stock at the start of that round and the total observed consumption.

        Args:
            S_prev_round_start: The stock level at the beginning of the previous round.
            total_consumption_prev_round: The total amount of stock consumed in the previous round by all players.
            n: The total number of players in the game.

        Returns:
            The estimated number of cooperators in the previous round, clamped between 0 and n.
        """
        if S_prev_round_start <= 0:
            return 0
        normalized_consumption = total_consumption_prev_round / S_prev_round_start
        k_C_float = 2 * n * (1 - normalized_consumption)
        k_C_inferred = round(k_C_float)
        k_C_inferred = max(0, min(n, k_C_inferred))
        return k_C_inferred

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round
        based on the ACS strategy rules.

        Args:
            state: The current state of the common pool resource game (round_number, current_stock).
            history: Historical data of previous rounds' actions and payoffs, or None for the first round.

        Returns:
            An Action (Action.C for Cooperate or Action.D for Defect).
        """
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        S_t = state.current_stock
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        S_critical = capacity * self.S_CRITICAL_RATIO
        if current_round_1_indexed == 1:
            return Action.C
        elif current_round_1_indexed == r:
            return Action.D
        else:
            prev_round_idx = current_round_0_indexed - 1
            S_prev_round_start = 0.0
            Total_Consumption_prev_round = 0.0
            my_payoff_prev = history.my_payoffs[prev_round_idx]
            my_action_prev = history.my_actions[prev_round_idx]
            if my_payoff_prev > 0:
                if my_action_prev == Action.C:
                    S_prev_round_start = my_payoff_prev * (2 * n)
                else:
                    S_prev_round_start = my_payoff_prev * n
            else:
                for i in range(n - 1):
                    opp_payoff_prev = history.opponent_payoffs[prev_round_idx, i]
                    opp_action_prev = history.opponent_actions[prev_round_idx, i]
                    if opp_payoff_prev > 0:
                        if opp_action_prev == Action.C:
                            S_prev_round_start = opp_payoff_prev * (2 * n)
                        else:
                            S_prev_round_start = opp_payoff_prev * n
                        break
            if S_prev_round_start > 0:
                if my_action_prev == Action.C:
                    Total_Consumption_prev_round += S_prev_round_start / (2 * n)
                else:
                    Total_Consumption_prev_round += S_prev_round_start / n
                for opp_action in history.opponent_actions[prev_round_idx, :]:
                    if opp_action == Action.C:
                        Total_Consumption_prev_round += S_prev_round_start / (2 * n)
                    else:
                        Total_Consumption_prev_round += S_prev_round_start / n
            k_C_inferred = self._infer_cooperation_count(S_prev_round_start, Total_Consumption_prev_round, n)
            if S_t <= S_critical:
                return Action.C
            elif k_C_inferred >= n - self.COOPERATION_FORGIVENESS_THRESHOLD:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_402(BaseStrategy):
    """
    The Adaptive Forgiving Steward (AFS) strategy aims to foster and maintain cooperation
    by defaulting to collective sustainability, tolerating minor deviations, and punishing
    significant exploitation, while always prioritizing the long-term health of the
    common resource. It adapts its behavior based on resource health and opponent
    defection levels, with specific logic for the first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_critical = self.capacity / 2.0
        self.defection_tolerance_threshold = max(1, math.floor(self.n_players / 4))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_k = state.round_number + 1
        if current_round_k == 1:
            return Action.C
        elif current_round_k == self.n_rounds:
            return Action.D
        else:
            current_stock = state.current_stock
            if current_stock < self.S_critical:
                return Action.C
            else:
                num_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
                num_defectors_last_round = self.n_players - 1 - num_cooperators_last_round
                if num_defectors_last_round <= self.defection_tolerance_threshold:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_403(BaseStrategy):
    """
    The Adaptive Resource Guardian strategy aims to balance resource sustainability with individual gain.
    It cooperates under normal conditions, especially when the resource is healthy and others cooperate.
    It defects to punish widespread exploitation or to maximize short-term gain in the final round.
    Crucially, it prioritizes resource conservation if the stock falls to a critical level,
    attempting to force a cooperative recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.conservation_threshold: float = 0.25 * self.game_description.capacity
        self.defection_tolerance_threshold: int = math.floor(self.game_description.n_players / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_zero_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        if current_round_zero_indexed == total_rounds - 1:
            return Action.D
        if current_stock < self.conservation_threshold:
            return Action.C
        if current_round_zero_indexed == 0:
            return Action.C
        num_cooperators_prev_round = sum(history.opponent_actions[-1, :])
        num_defectors_prev_round = n_players - 1 - num_cooperators_prev_round
        if num_defectors_prev_round <= self.defection_tolerance_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_404(BaseStrategy):
    """
    The Adaptive Conservationist with Forgiveness strategy aims to maximize collective welfare
    over the long term by prioritizing resource sustainability while remaining robust against
    exploitation from other players. It balances cooperation for resource health with conditional
    defection as a deterrent, adapting its behavior based on the current stock level and the
    recent actions of the group.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        if self.game_description.n_players == 2:
            self.cooperation_threshold_nd: int = 0
        else:
            self.cooperation_threshold_nd: int = 1
        self.critical_stock_ratio: float = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        num_defecting_opponents = self.game_description.n_players - 1 - np.sum(history.opponent_actions[-1, :])
        my_previous_action_was_D = not history.my_actions[-1]
        N_D_prev = num_defecting_opponents + (1 if my_previous_action_was_D else 0)
        is_stock_critically_low = state.current_stock < self.game_description.capacity * self.critical_stock_ratio
        if is_stock_critically_low:
            return Action.C
        elif N_D_prev <= self.cooperation_threshold_nd:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_405(BaseStrategy):
    """
    Adaptive Steward: This strategy is designed to promote collective sustainability of
    the common resource while being robust against various opponent behaviors. It balances
    cooperation for long-term benefit with self-protection against exploitation and
    resource depletion, adapting dynamically to opponent behavior and resource health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.HIGH_COOPERATION_THRESHOLD = (self.n_players - 1) / self.n_players
        self.MAJORITY_COOPERATION_THRESHOLD = 0.5
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        last_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        cooperators_last_round = np.sum(last_round_opponent_actions)
        cooperation_rate_last_round = cooperators_last_round / self.n_players
        if state.current_stock <= self.CRITICAL_STOCK_THRESHOLD and cooperation_rate_last_round < self.MAJORITY_COOPERATION_THRESHOLD:
            return Action.D
        elif cooperation_rate_last_round >= self.HIGH_COOPERATION_THRESHOLD:
            return Action.C
        elif cooperation_rate_last_round >= self.MAJORITY_COOPERATION_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_406(BaseStrategy):
    """
    Adaptive Collective Sustain (ACS) strategy for the Common Pool Resource game.

    This strategy aims to promote long-term sustainability of the common pool resource
    by starting cooperatively, and then adapting its behavior based on the current
    health of the resource and the observed actions of other players in the
    previous round. It includes strong impulses for resource restoration during
    scarcity and conditional cooperation during abundance to deter exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_RESTORE_THRESHOLD = self.capacity / 2.0
        self.S_EMERGENCY_THRESHOLD = self.capacity / (2.0 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.total_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.C
        previous_round_actions = history.opponent_actions[current_round_0_indexed - 1]
        num_cooperators_prev = np.sum(previous_round_actions)
        num_defectors_prev = self.n_players - num_cooperators_prev
        if current_stock <= self.S_EMERGENCY_THRESHOLD:
            return Action.C
        elif current_stock < self.S_RESTORE_THRESHOLD:
            if num_defectors_prev >= math.ceil(self.n_players / 2.0):
                return Action.D
            else:
                return Action.C
        elif num_defectors_prev == 0:
            return Action.C
        elif num_defectors_prev >= math.ceil(self.n_players / 2.0):
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_407(BaseStrategy):
    """
    Adaptive Collective Guardian (ACG) strategy for the Common Pool Resource Game.

    This strategy aims to foster and maintain collective cooperation to preserve
    the common pool resource, while also being robust against exploitation. It
    balances collective well-being with self-preservation through adaptive
    monitoring of collective behavior and resource state.

    Core Principles:
    1. Start Cooperative: Begin by cooperating.
    2. Punish Collective Defection: Retaliate if many others defect.
    3. Forgive and Re-cooperate: Return to cooperation if others show willingness.
    4. Emergency Conservation: Prioritize resource survival when stock is critically low.
    5. Endgame Rationality: Defect in the final round to avoid exploitation.
    """
    COOPERATIVE_QUORUM_PERCENTAGE: float = 0.5
    PUNISHMENT_DURATION_ROUNDS: int = 2
    LOW_STOCK_THRESHOLD_PERCENTAGE: float = 0.25

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishing_until_round: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if state.round_number == 0:
            self.punishing_until_round = 0
            return Action.C
        if current_round_1_indexed == self.game_description.n_rounds:
            return Action.D
        if state.current_stock < self.game_description.capacity * self.LOW_STOCK_THRESHOLD_PERCENTAGE:
            self.punishing_until_round = 0
            return Action.C
        num_other_players_defected = np.sum(~history.opponent_actions[-1, :])
        num_other_players = self.game_description.n_players - 1
        group_was_cooperative_last_round = num_other_players_defected <= num_other_players * self.COOPERATIVE_QUORUM_PERCENTAGE
        if current_round_1_indexed <= self.punishing_until_round:
            if group_was_cooperative_last_round:
                self.punishing_until_round = 0
                return Action.C
            else:
                return Action.D
        group_failure_to_cooperate = num_other_players_defected > num_other_players * self.COOPERATIVE_QUORUM_PERCENTAGE
        if group_failure_to_cooperate:
            self.punishing_until_round = current_round_1_indexed + self.PUNISHMENT_DURATION_ROUNDS - 1
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_408(BaseStrategy):
    """
    Collective Adaptive Resource Management (CARM) Strategy for the Common Pool Resource Game.

    This strategy balances resource sustainability, fair play, and self-protection.
    It prioritizes long-term resource health conditionally, cooperates as long as
    most others do, retaliates against significant defection, and adapts to the
    end-game.

    Core principles:
    1. Sustainability First (Conditional): Prioritize resource health if there's
       sufficient collective effort.
    2. Conditional Cooperation & Deterrence: Start C, continue C if most others C.
       Retaliate against significant defection.
    3. Forgiveness: Allow minor deviations to prevent endless defection cycles.
    4. Rational End-Game: Maximize immediate payoff in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_thresh = self.capacity / 2.0
        self.max_defectors_for_recovery = 0
        if self.n_players > 2:
            self.max_defectors_for_recovery = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number_1_indexed = state.round_number + 1
        if current_round_number_1_indexed == 1:
            return Action.C
        if current_round_number_1_indexed == self.n_rounds:
            return Action.D
        k_D_prev = np.sum(~history.opponent_actions[state.round_number - 1, :])
        if state.current_stock <= self.S_thresh:
            if k_D_prev <= self.max_defectors_for_recovery:
                return Action.C
            else:
                return Action.D
        elif k_D_prev <= 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_409(BaseStrategy):
    """
    The Adaptive Guardian of the Commons strategy is designed to foster collective sustainability
    while being robust against exploitation and adapting to opponent behavior and game progression.
    It balances immediate individual incentives with the long-term collective good, acknowledging
    the finite game horizon.

    Core Principles:
    1. Promote Cooperation: Start and continue cooperating as long as others do.
    2. Punish Defection: Respond to defection to prevent exploitation.
    3. Resource Prioritization: Prioritize the health of the common stock when critically low.
    4. Endgame Rationality: Revert to individual rationality in the final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / (2 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed >= self.n_rounds - 2:
            return Action.D
        if current_stock <= self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.C
        my_last_action_was_defect = not history.my_actions[-1]
        any_opponent_defected_last_round = not np.all(history.opponent_actions[-1, :])
        if my_last_action_was_defect or any_opponent_defected_last_round:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_410(BaseStrategy):
    """
    Adaptive Guardian strategy for the Common Pool Resource Game.

    The strategy aims to foster collective sustainability by maintaining cooperation,
    but adapts to punish widespread exploitation. It is designed to be robust and
    adaptive to varying opponent behaviors in a tournament setting. When the resource
    is critically low, it will always revert to cooperation to facilitate recovery,
    acting as a "guardian" of the commons. It also accounts for end-game rationality.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.COOPERATION_THRESHOLD = self.capacity / 2.0
        self.DEFECTION_TOLERANCE_LIMIT = math.floor(self.n_players / 2.0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if state.current_stock < self.COOPERATION_THRESHOLD:
            return Action.C
        else:
            prev_round_history_idx = state.round_number - 1
            num_defectors_prev_round = np.sum(~history.opponent_actions[prev_round_history_idx, :])
            if not history.my_actions[prev_round_history_idx]:
                num_defectors_prev_round += 1
            if num_defectors_prev_round == 0:
                return Action.C
            elif num_defectors_prev_round <= self.DEFECTION_TOLERANCE_LIMIT:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_411(BaseStrategy):
    """
    Adaptive Collective Reciprocity (ACR) strategy for the Common Pool Resource Game.

    This strategy aims to balance collective sustainability with self-preservation
    against exploitation. It initiates cooperation, rewards collective cooperation,
    punishes defection (Tit-for-Tat-like), and adapts behavior when the resource
    is critically low, or in the final round of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold = self.game_description.capacity / 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        S_current = state.current_stock
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == n_rounds - 1:
            return Action.D
        my_prev_action = history.my_actions[-1]
        opponent_prev_actions = history.opponent_actions[-1, :]
        all_prev_actions = np.concatenate(([my_prev_action], opponent_prev_actions))
        num_defectors_prev_round = np.sum(~all_prev_actions)
        if S_current < self.critical_stock_threshold:
            if num_defectors_prev_round == n_players:
                return Action.D
            elif num_defectors_prev_round > 0:
                return Action.D
            else:
                return Action.C
        elif num_defectors_prev_round > 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_412(BaseStrategy):
    """
    The Adaptive Collective Steward (ACS) strategy for the Common Pool Resource Game.
    This strategy employs conditional cooperation, adapting its behavior based on
    the current resource stock level and the observed actions of opponents in the
    previous round. It aims to foster long-term resource sustainability and cooperation,
    while protecting itself from exploitation and acting rationally in end-game scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / 2.0
        self.PUNISHMENT_STOCK_THRESHOLD = self.capacity * 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == 0:
            return Action.C
        if current_round_number == self.r - 1:
            return Action.D
        num_cooperators_prev_round = sum(history.opponent_actions[-1, :])
        n_opponents = self.n - 1
        if current_stock <= self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        elif current_stock <= self.PUNISHMENT_STOCK_THRESHOLD:
            if num_cooperators_prev_round < n_opponents:
                return Action.D
            else:
                return Action.C
        else:
            majority_threshold_for_opponents = math.ceil(n_opponents / 2.0)
            if num_cooperators_prev_round >= majority_threshold_for_opponents:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_413(BaseStrategy):
    """
    Sustainable Reciprocity with Stock Safeguard (SRSS) strategy.

    This strategy prioritizes the long-term sustainability of the common pool resource
    while employing conditional cooperation to deter widespread defection. It aims to
    achieve the optimal collective outcome by maintaining the resource stock at healthy
    levels. It is designed to be resilient in a tournament setting where opponent
    behaviors are unknown, by being initially cooperative, punishing significant
    collective defection, and having a critical safeguard for resource recovery.

    Decision Rules:
    1. Initial Round (t=1): Always Cooperate (C).
    2. Final Round (t=r): Always Defect (D).
    3. Intermediate Rounds (1 < t < r):
        a. Stock Health Check: If the current stock (as a proxy for previous round's start stock)
           is below STOCK_RECOVERY_THRESHOLD (capacity / 2), then Cooperate (C) to prioritize recovery.
        b. Defection Check: Otherwise, count defectors from the previous round. If the number of
           defectors is greater than or equal to D_THRESHOLD (ceil(n / 2)), then Defect (D)
           to punish widespread defection.
        c. Default: If stock is healthy and few defectors, then Cooperate (C).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.STOCK_RECOVERY_THRESHOLD = self.capacity / 2.0
        self.D_THRESHOLD = math.ceil(self.n_players / 2.0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.total_rounds:
            return Action.D
        stock_for_assessment = state.current_stock
        if stock_for_assessment < self.STOCK_RECOVERY_THRESHOLD:
            return Action.C
        num_opponent_defectors = np.sum(~history.opponent_actions[-1, :])
        my_previous_action_was_D = not history.my_actions[-1]
        total_defectors_in_prev_round = num_opponent_defectors + (1 if my_previous_action_was_D else 0)
        if total_defectors_in_prev_round >= self.D_THRESHOLD:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_414(BaseStrategy):
    """
    The Adaptive Collective Steward strategy for the Common Pool Resource Game.

    This strategy aims to foster and maintain collective cooperation for the
    long-term sustainability of the common resource. It balances individual
    rationality with collective welfare by adaptively deciding actions based
    on the current stock level and the observed behavior of other players.

    It initiates cooperation, rewards continued collective effort, and strategically
    punishes defection, with the severity of punishment adapting to the resource's
    current state (healthy, recovering, or critical).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        self.defection_tolerance_healthy_stock = 1 if n_players > 2 else 0
        self.stock_recovery_threshold = capacity / 2.0
        val_two_n = 2.0 * n_players
        val_capacity_fraction = capacity / (4.0 * n_players)
        raw_critical_threshold = max(val_two_n, val_capacity_fraction)
        self.stock_critical_threshold = min(raw_critical_threshold, self.stock_recovery_threshold * 0.9)
        self.stock_critical_threshold = max(0.0, self.stock_critical_threshold)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if state.round_number == n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.C
        num_others_defected = n_players - 1 - np.sum(history.opponent_actions[-1, :])
        if current_stock < self.stock_critical_threshold:
            return Action.C
        elif current_stock < self.stock_recovery_threshold:
            if num_others_defected == 0:
                return Action.C
            else:
                return Action.D
        elif num_others_defected <= self.defection_tolerance_healthy_stock:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_415(BaseStrategy):
    """
    Adaptive Collective Guardian (ACG) strategy for the Common Pool Resource Game.
    This strategy balances proactive cooperation with reactive self-preservation,
    aiming for long-term collective prosperity while being resilient to opportunistic
    defection and preventing total resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_level = self.capacity / 4.0
        if self.n_players == 2:
            self.tolerance_threshold = 0
        else:
            self.tolerance_threshold = max(1, math.floor(self.n_players / 4.0))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        num_cooperators_prev_round = int(history.my_actions[-1]) + np.sum(history.opponent_actions[-1, :])
        d_prev = self.n_players - num_cooperators_prev_round
        if state.current_stock < self.critical_stock_level:
            return Action.C
        elif d_prev == 0:
            return Action.C
        elif d_prev <= self.tolerance_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_416(BaseStrategy):
    """
    Adaptive Collective Stewardship (ACS) strategy.
    This strategy aims to balance collective resource management with robustness against opportunistic
    individual behavior. It starts cooperatively, monitors and adapts based on the collective actions
    of others and the current stock level, punishes widespread defection, and defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initialises the strategy with game parameters.

        Args:
            game_description: An object containing n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_level = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round.

        Args:
            state: An object containing the current round_number (0-indexed) and current_stock.
            history: An object containing past actions and payoffs. None for the very first round.

        Returns:
            Action.C for Cooperate, Action.D for Defect.
        """
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        k = history.opponent_actions[-1, :].sum()
        if state.current_stock <= self.critical_stock_level:
            if k == self.n_players - 1:
                return Action.C
            else:
                return Action.D
        elif k == self.n_players - 1:
            return Action.C
        elif k >= math.ceil((self.n_players - 1) / 2.0):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_417(BaseStrategy):
    """
    The "Adaptive Conservationist: Forgiving & Firm" strategy aims to maintain the common
    resource at a healthy level. It defaults to cooperation, actively promotes resource
    recovery when threatened, and punishes persistent or significant defection, adapting
    its tolerance based on the health of the common stock.

    It is cooperative in the first round, defects in the last round, and in
    intermediate rounds, it dynamically adjusts its stance based on the current
    stock level and the observed defection of other players in the previous round.
    It is stricter when the stock is low, tolerating zero defectors, and more forgiving
    when the stock is healthy, tolerating one defector if there are more than 2 players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_TARGET_MIN_PERCENTAGE = 0.8
        self.S_CRITICAL_PERCENTAGE = 0.3
        self.TOLERANCE_DEFECT_LOW_STOCK = 0
        self.TOLERANCE_DEFECT_HIGH_STOCK = 0 if self.n_players == 2 else 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number
        current_stock = state.current_stock
        if current_round_t == 0:
            return Action.C
        if current_round_t == self.n_rounds - 1:
            return Action.D
        num_defectors_prev = np.sum(~history.opponent_actions[-1, :])
        S_optimal_threshold = self.S_TARGET_MIN_PERCENTAGE * self.capacity
        S_critical_threshold = self.S_CRITICAL_PERCENTAGE * self.capacity
        if current_stock < S_critical_threshold:
            if num_defectors_prev > self.TOLERANCE_DEFECT_LOW_STOCK:
                return Action.D
            else:
                return Action.C
        elif current_stock >= S_critical_threshold and current_stock < S_optimal_threshold:
            if num_defectors_prev > self.TOLERANCE_DEFECT_LOW_STOCK:
                return Action.D
            else:
                return Action.C
        elif current_stock >= S_optimal_threshold:
            if num_defectors_prev > self.TOLERANCE_DEFECT_HIGH_STOCK:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_COLLECTIVE_418(BaseStrategy):
    """
    Common Pool Steward (CPS) strategy for the Common Pool Resource Game.
    Prioritizes long-term resource sustainability through proactive cooperation,
    adaptive retaliation with forgiveness, and critical stock safeguards.
    It aims to be resilient to exploitation while fostering collective benefit.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold_ratio: float = 0.5
        self.default_punishment_duration: int = 1
        self.is_in_punishment_mode: bool = False
        self.punishment_rounds_remaining: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            self.is_in_punishment_mode = False
            self.punishment_rounds_remaining = 0
            return Action.C
        if current_round_0_indexed == self.total_rounds - 1:
            return Action.D
        if current_stock < self.capacity * self.critical_stock_threshold_ratio:
            self.is_in_punishment_mode = False
            self.punishment_rounds_remaining = 0
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        num_D_others_prev = (~previous_round_opponent_actions).sum()
        allowed_defectors_before_punishment = 0
        if self.n_players > 2:
            allowed_defectors_before_punishment = 1
        if self.is_in_punishment_mode:
            self.punishment_rounds_remaining -= 1
            if self.punishment_rounds_remaining <= 0:
                self.is_in_punishment_mode = False
        if not self.is_in_punishment_mode:
            if num_D_others_prev > allowed_defectors_before_punishment:
                self.is_in_punishment_mode = True
                self.punishment_rounds_remaining = self.default_punishment_duration
        if self.is_in_punishment_mode:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_419(BaseStrategy):
    """
    The Adaptive Collective Sustainer (ACS) strategy aims to foster and maintain cooperation
    to sustain the common resource at high levels. It is designed with a strong bias towards
    cooperation but dynamically adjusts its behavior based on the observed actions of opponents
    and the health of the common stock. It prioritizes sustainability while being resilient
    to opportunistic defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = game_description.n_players
        r = game_description.n_rounds
        capacity = game_description.capacity
        self.S_critical_low_threshold = 0.25 * capacity
        self.S_mid_low_threshold = 0.5 * capacity
        self.defection_tolerance_base = max(0, math.floor((n - 1) / 2))
        self.endgame_start_round_1_indexed = r - max(1, math.floor(r / 5))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        num_opponent_defectors_last_round = 0
        if current_round_1_indexed > 1:
            previous_round_opponent_actions = history.opponent_actions[state.round_number - 1]
            num_opponent_defectors_last_round = np.sum(~previous_round_opponent_actions)
        current_defection_tolerance = self.defection_tolerance_base
        if state.current_stock < self.S_mid_low_threshold:
            current_defection_tolerance = max(0, current_defection_tolerance - 1)
        if state.current_stock < self.S_critical_low_threshold:
            current_defection_tolerance = 0
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.game_description.n_rounds:
            if num_opponent_defectors_last_round == 0:
                return Action.C
            else:
                return Action.D
        if current_round_1_indexed >= self.endgame_start_round_1_indexed:
            if num_opponent_defectors_last_round > 0:
                return Action.D
            else:
                return Action.C
        if state.current_stock < self.S_critical_low_threshold:
            if num_opponent_defectors_last_round == 0:
                return Action.C
            else:
                return Action.D
        elif state.current_stock < self.S_mid_low_threshold:
            if num_opponent_defectors_last_round <= current_defection_tolerance:
                return Action.C
            else:
                return Action.D
        elif num_opponent_defectors_last_round == 0:
            return Action.C
        elif num_opponent_defectors_last_round <= current_defection_tolerance:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_420(BaseStrategy):
    """
    The Adaptive Collective Manager (ACM) strategy promotes sustainable resource management
    by balancing cooperation with self-preservation. It adapts to observed group behavior
    and adjusts its actions based on resource health and peer defection levels.

    This strategy makes decisions based on the current stock level (is it critical?)
    and the estimated number of defectors in the previous round. It cooperates in the
    first round to establish a baseline and defects in the last round to maximize
    final payoffs.
    """
    DEFAULT_DEFECTION_TOLERANCE_FACTOR = 0.25
    DEFAULT_CRITICAL_STOCK_THRESHOLD_FACTOR = 0.5
    EPSILON = 0.001

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.defection_tolerance_factor = self.DEFAULT_DEFECTION_TOLERANCE_FACTOR
        self.critical_stock_threshold_factor = self.DEFAULT_CRITICAL_STOCK_THRESHOLD_FACTOR
        self.defection_tolerance = max(0, min(self.n, int(self.n * self.defection_tolerance_factor)))
        self.critical_stock_level = self.capacity * self.critical_stock_threshold_factor

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_stock <= self.EPSILON:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.r - 1:
            return Action.D
        t_prev = current_round_0_indexed - 1
        my_action_prev_is_C = history.my_actions[t_prev]
        my_payoff_prev = history.my_payoffs[t_prev]
        S_prev = 0.0
        if my_action_prev_is_C:
            S_prev = my_payoff_prev * (2.0 * self.n)
        else:
            S_prev = my_payoff_prev * self.n
        n_cooperators_total_prev = 0
        if my_action_prev_is_C:
            n_cooperators_total_prev += 1
        n_cooperators_total_prev += np.sum(history.opponent_actions[t_prev, :])
        n_defectors_total_prev = self.n - n_cooperators_total_prev
        consumption_if_C = S_prev / (2.0 * self.n)
        consumption_if_D = S_prev / self.n
        total_consumption_prev = n_cooperators_total_prev * consumption_if_C + n_defectors_total_prev * consumption_if_D
        estimated_N_D_prev = 0
        if S_prev <= self.EPSILON:
            estimated_N_D_prev = self.n
        else:
            expected_consumption_if_all_C = S_prev / 2.0
            defection_overhead = total_consumption_prev - expected_consumption_if_all_C
            consumption_per_defector_above_cooperation = consumption_if_D - consumption_if_C
            if consumption_per_defector_above_cooperation <= self.EPSILON:
                if total_consumption_prev > expected_consumption_if_all_C + self.EPSILON:
                    estimated_N_D_prev = self.n
                else:
                    estimated_N_D_prev = 0
            else:
                estimated_N_D_prev_raw = defection_overhead / consumption_per_defector_above_cooperation
                estimated_N_D_prev = max(0, min(self.n, round(estimated_N_D_prev_raw)))
        if current_stock < self.critical_stock_level:
            if estimated_N_D_prev == 0:
                return Action.C
            else:
                return Action.D
        elif estimated_N_D_prev <= self.defection_tolerance:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_421(BaseStrategy):
    """
    The "Adaptive Steward" strategy aims to promote long-term sustainability of the common pool resource
    by balancing collective benefit (resource preservation) with self-preservation. It adapts its
    behavior based on the current state of the resource and observed past actions of other players.

    It starts with cooperation, defects in the last round, and in intermediate rounds:
    - If the stock is critically low, it always cooperates for recovery.
    - If the stock is unhealthy, it has zero tolerance for defectors.
    - If the stock is healthy, it allows a small number of defectors before retaliating.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.STOCK_CRITICAL_THRESHOLD = self.capacity / 4.0
        self.STOCK_HEALTHY_THRESHOLD = self.capacity / 2.0
        self.FORGIVENESS_LEVEL_HEALTHY_STOCK = math.floor(self.n / 4.0)
        self.FORGIVENESS_LEVEL_UNHEALTHY_STOCK = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.r:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        prev_my_action_is_C = history.my_actions[state.round_number - 1]
        prev_opponent_actions_are_C = history.opponent_actions[state.round_number - 1, :]
        num_defectors_prev_round = 0
        if not prev_my_action_is_C:
            num_defectors_prev_round += 1
        num_defectors_prev_round += np.sum(~prev_opponent_actions_are_C)
        S_start_current_round = state.current_stock
        if S_start_current_round < self.STOCK_CRITICAL_THRESHOLD:
            return Action.C
        elif S_start_current_round < self.STOCK_HEALTHY_THRESHOLD:
            if num_defectors_prev_round > self.FORGIVENESS_LEVEL_UNHEALTHY_STOCK:
                return Action.D
            else:
                return Action.C
        elif num_defectors_prev_round > self.FORGIVENESS_LEVEL_HEALTHY_STOCK:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_422(BaseStrategy):
    """
    Collective Adaptive Forgiving Strategy with Stock Threshold for Common Pool Resource Game.

    This strategy aims to sustain the common resource while incentivizing cooperation and
    protecting itself from exploitation. It adapts its behavior based on the observed
    collective actions in the previous round and the current health of the resource.
    It's implicitly forgiving, allowing for the re-establishment of cooperation, but
    recognizes the end-game incentive to defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters and internal tunable thresholds.
        """
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.cooperation_threshold_ratio: float = 0.75
        self.critical_stock_threshold_ratio: float = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides on an action (Cooperate or Defect) for the current round based on
        the game state and past history.
        """
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        elif current_round == self.total_rounds - 1:
            return Action.D
        elif current_stock <= self.critical_stock_threshold_ratio * self.capacity:
            return Action.C
        else:
            num_cooperators_prev_round = np.sum(history.opponent_actions[current_round - 1, :]) + history.my_actions[current_round - 1]
            proportion_cooperators_prev_round = num_cooperators_prev_round / self.n_players
            if proportion_cooperators_prev_round >= self.cooperation_threshold_ratio:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_423(BaseStrategy):
    """
    Adaptive Steward strategy for the Common Pool Resource Game.
    This strategy balances resource sustainability with the need to avoid exploitation.
    It cooperates by default, prioritizes the resource when stock is low,
    forgives single defections when the stock is healthy, and punishes
    widespread or persistent defection. In the final round, it defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == total_rounds - 1:
            return Action.D
        if current_round_number == 0:
            return Action.C
        CRITICAL_STOCK_THRESHOLD = capacity * 0.25
        HEALTHY_STOCK_THRESHOLD = capacity * 0.75
        if current_stock <= CRITICAL_STOCK_THRESHOLD:
            return Action.C
        previous_round_idx = current_round_number - 1
        num_opponent_cooperators_last_round = np.sum(history.opponent_actions[previous_round_idx, :])
        my_action_last_round_was_C = history.my_actions[previous_round_idx]
        num_cooperators_last_round = num_opponent_cooperators_last_round + (1 if my_action_last_round_was_C else 0)
        num_defectors_last_round = n - num_cooperators_last_round
        if num_defectors_last_round == 0:
            return Action.C
        elif num_defectors_last_round == 1:
            if current_stock >= HEALTHY_STOCK_THRESHOLD:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_424(BaseStrategy):
    """
    The Adaptive Collective Guardian (ACG) strategy aims to foster and maintain cooperation to preserve the common pool resource, 
    while being robust against exploitation by other players. It adapts its behavior based on the current health of the 
    resource and the observed actions of other players.

    Core Principles:
    1.  Trust but Verify: Start cooperatively, but continuously monitor others' actions.
    2.  Resource Prioritization: Act differently depending on the stock's health (Healthy, Critical, Collapsing).
    3.  Adaptive Forgiveness: Tolerate minor deviations from cooperation to prevent unnecessary punishment spirals.
    4.  Deterrence & Self-Preservation: Punish significant or persistent defection, and prioritize self-interest when the resource is irrecoverably damaged.
    5.  Rational End-Game: Anticipate the end of the game to maximize terminal payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.round_count += 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if self.round_count == 1:
            return Action.C
        if self.round_count == n_rounds:
            return Action.D
        COLLAPSE_IMMINENT_THRESHOLD = min(capacity / (2 * n_players), capacity * 0.05)
        CRITICAL_THRESHOLD = capacity / 2.0
        stock_status = 'HEALTHY'
        if current_stock <= COLLAPSE_IMMINENT_THRESHOLD:
            stock_status = 'COLLAPSE_IMMINENT'
        elif current_stock <= CRITICAL_THRESHOLD:
            stock_status = 'CRITICAL'
        defection_count_previous_round = np.sum(history.opponent_actions[-1, :] == False)
        if stock_status == 'COLLAPSE_IMMINENT':
            return Action.D
        elif stock_status == 'CRITICAL':
            if defection_count_previous_round == 0:
                return Action.C
            else:
                return Action.D
        else:
            DEFECTION_TOLERANCE_THRESHOLD = 0
            if n_players > 2:
                DEFECTION_TOLERANCE_THRESHOLD = 1
            if defection_count_previous_round <= DEFECTION_TOLERANCE_THRESHOLD:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_425(BaseStrategy):
    """
    The Adaptive Collective Sustainer (ACS) strategy for the Common Pool Resource Game.
    Prioritizes resource sustainability, promoting cooperation, and adapting to opponent behavior.
    It defects in the final round, cooperates when the stock is critically low,
    and otherwise applies reciprocal play based on the proportion of defectors in the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with the game's parameters.

        Args:
            game_description: A CommonPoolDescription object containing n_players, n_rounds, and capacity.
        """
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: A CommonPoolState object containing the current_round (0-indexed) and current_stock.
            history: A PlayerHistory object containing past actions and payoffs, or None if it's the first round.

        Returns:
            An Action enum (Action.C for Cooperate, Action.D for Defect).
        """
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_0_indexed_round = state.round_number
        if current_0_indexed_round == n_rounds - 1:
            return Action.D
        if current_stock < capacity / 2:
            return Action.C
        if current_0_indexed_round == 0:
            return Action.C
        num_opponent_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
        num_opponent_defectors_last_round = n_players - 1 - num_opponent_cooperators_last_round
        my_action_last_round_was_cooperate = history.my_actions[-1]
        my_action_last_round_was_defect = not my_action_last_round_was_cooperate
        total_defectors_last_round = num_opponent_defectors_last_round + (1 if my_action_last_round_was_defect else 0)
        defection_proportion = total_defectors_last_round / n_players
        if defection_proportion >= 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_426(BaseStrategy):
    """
    Adaptive Collective Steward (ACS) strategy for the Common Pool Resource Game.
    Prioritizes long-term sustainability by defaulting to cooperation,
    monitors opponent behavior and resource health, and employs temporary
    punishment for defections, shifting to self-preservation during severe
    resource depletion, while always seeking opportunities to return to
    cooperation. Defects in the final round to prevent exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._consecutive_rounds_of_defection_by_me: int = 0
        self._punishment_threshold: int = 1
        self._punishment_duration: int = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_zero_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        num_defectors_last_round = 0
        if current_round_zero_indexed > 0:
            num_defectors_last_round = (~history.opponent_actions[-1, :]).sum()
        action_to_play = Action.C
        if current_round_zero_indexed == 0:
            action_to_play = Action.C
            self._consecutive_rounds_of_defection_by_me = 0
        elif current_round_zero_indexed == total_rounds - 1:
            action_to_play = Action.D
            self._consecutive_rounds_of_defection_by_me = 0
        else:
            defection_detected_last_round = num_defectors_last_round >= self._punishment_threshold
            if current_stock < capacity * 0.1:
                action_to_play = Action.D
                self._consecutive_rounds_of_defection_by_me = 1
            elif current_stock < capacity * 0.5:
                if defection_detected_last_round or self._consecutive_rounds_of_defection_by_me > 0:
                    action_to_play = Action.D
                    self._consecutive_rounds_of_defection_by_me += 1
                else:
                    action_to_play = Action.C
                    self._consecutive_rounds_of_defection_by_me = 0
            elif defection_detected_last_round or (self._consecutive_rounds_of_defection_by_me > 0 and self._consecutive_rounds_of_defection_by_me < self._punishment_duration):
                action_to_play = Action.D
                self._consecutive_rounds_of_defection_by_me += 1
            else:
                action_to_play = Action.C
                self._consecutive_rounds_of_defection_by_me = 0
        return action_to_play

class Strategy_COLLECTIVE_427(BaseStrategy):
    """
    Collective Conservationist (CC) Strategy.

    This strategy aims to foster and maintain collective cooperation for
    sustainable resource management. It defaults to cooperative behavior,
    adapts swiftly to observed defection by punishing, and incorporates
    a forgiveness mechanism to allow for the re-establishment of cooperation.
    It prioritizes long-term resource sustainability and group welfare.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_mode: bool = True
        self.coop_streak_in_punishment: int = 0
        self.FORGIVENESS_ROUNDS: int = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.cooperative_mode = True
            self.coop_streak_in_punishment = 0
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        my_prev_action_was_D = not history.my_actions[state.round_number - 1]
        num_opponent_defectors_prev_round = np.sum(~history.opponent_actions[state.round_number - 1])
        total_defectors_prev_round = num_opponent_defectors_prev_round + (1 if my_prev_action_was_D else 0)
        all_players_cooperated_prev_round = total_defectors_prev_round == 0
        if self.cooperative_mode:
            if all_players_cooperated_prev_round:
                return Action.C
            else:
                self.cooperative_mode = False
                self.coop_streak_in_punishment = 0
                return Action.D
        elif all_players_cooperated_prev_round:
            self.coop_streak_in_punishment += 1
            if self.coop_streak_in_punishment >= self.FORGIVENESS_ROUNDS:
                self.cooperative_mode = True
                self.coop_streak_in_punishment = 0
                return Action.C
            else:
                return Action.D
        else:
            self.coop_streak_in_punishment = 0
            return Action.D

class Strategy_COLLECTIVE_428(BaseStrategy):
    """
    Adaptive Sustainability Guard (ASG) strategy for the Common Pool Resource Game.
    It balances collective sustainability with self-preservation, adapting to opponent
    defection and critical resource levels. It starts cooperatively, monitors and
    reacts to defection, forgives when appropriate, and prioritizes immediate gain
    in dire resource states or the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.critical_stock_threshold = capacity / n
        self.allowed_defections = 1 if n > 2 else 0
        self.currently_punishing = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round == 0:
            self.currently_punishing = False
            return Action.C
        if current_round == n_rounds - 1:
            return Action.D
        if current_stock < self.critical_stock_threshold:
            self.currently_punishing = True
            return Action.D
        num_defected_prev_round = int(np.sum(~history.opponent_actions[-1, :]))
        if self.currently_punishing:
            if num_defected_prev_round == 0:
                self.currently_punishing = False
                return Action.C
            else:
                return Action.D
        elif num_defected_prev_round > self.allowed_defections:
            self.currently_punishing = True
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_429(BaseStrategy):
    """
    The "Adaptive Collective Steward" strategy for the Common Pool Resource game.
    It prioritizes sustainability, punishes defection, encourages rehabilitation,
    is resource-aware through stock thresholds, and accounts for end-game rationality.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == r - 1:
            return Action.D
        num_defect_prev_round = np.sum(history.opponent_actions[-1, :] == False)
        critical_stock_threshold = capacity / n
        salvage_stock_threshold = capacity / (2 * n * r)
        if current_stock < salvage_stock_threshold:
            return Action.D
        elif current_stock < critical_stock_threshold:
            if num_defect_prev_round == 0:
                return Action.C
            else:
                return Action.D
        elif num_defect_prev_round == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_430(BaseStrategy):
    """
    The Adaptive Collective Guardian (ACG) strategy promotes collective welfare and resource sustainability.
    It employs conditional cooperation, adapting its behavior based on observed opponent actions and
    the critical level of the shared common pool resource. It prioritizes resource recovery during crises
    and uses adaptive punishment to deter persistent exploitation, while maintaining a degree of forgiveness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold = self.game_description.capacity / 2.0
        self.defection_tolerance_threshold = 1
        self.max_crisis_exploitation_tolerance = 2
        self.consecutive_defection_count_in_crisis = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round == 0:
            self.consecutive_defection_count_in_crisis = 0
            return Action.C
        if current_round == n_rounds - 1:
            self.consecutive_defection_count_in_crisis = 0
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[current_round - 1, :]
        num_cooperating_opponents = np.sum(previous_round_opponent_actions)
        k_D_prev = self.game_description.n_players - 1 - num_cooperating_opponents
        if current_stock < self.critical_stock_threshold:
            if k_D_prev <= self.defection_tolerance_threshold:
                self.consecutive_defection_count_in_crisis = 0
                return Action.C
            else:
                self.consecutive_defection_count_in_crisis += 1
                if self.consecutive_defection_count_in_crisis >= self.max_crisis_exploitation_tolerance:
                    return Action.D
                else:
                    return Action.C
        else:
            self.consecutive_defection_count_in_crisis = 0
            if k_D_prev <= self.defection_tolerance_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_431(BaseStrategy):
    """
    The Adaptive Collective Sustainer (ACS) strategy is built on the principle of
    conditional cooperation with defensive safeguards. Its core objective is to
    maximize its total payoff over all rounds by fostering and sustaining
    collective cooperation, thereby preserving the common stock for as long as
    possible. It achieves this by starting cooperatively, dynamically adapting
    its behavior based on the observed actions of other players, and implementing
    specific defensive measures for critically low stock levels and the end-game phase.
    """
    COOPERATION_THRESHOLD: float = 0.6
    CRITICAL_STOCK_MULTIPLIER: float = 0.25

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.END_GAME_PHASE_ROUNDS = min(3, max(2, math.floor(self.n_rounds / 4)))
        self.CRITICAL_STOCK_LEVEL = self.capacity * self.CRITICAL_STOCK_MULTIPLIER

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            others_cooperation_ratio = 1.0
        else:
            prev_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
            num_cooperators_prev_round = sum(prev_round_opponent_actions)
            num_other_players = self.n_players - 1
            others_cooperation_ratio = num_cooperators_prev_round / num_other_players
        if current_round_1_indexed > self.n_rounds - self.END_GAME_PHASE_ROUNDS:
            if current_stock < self.capacity / self.n_players:
                return Action.D
            elif others_cooperation_ratio < 0.5:
                return Action.D
            else:
                return Action.C
        elif current_stock < self.CRITICAL_STOCK_LEVEL:
            if others_cooperation_ratio >= 0.8:
                return Action.C
            else:
                return Action.D
        elif others_cooperation_ratio >= self.COOPERATION_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_432(BaseStrategy):
    """
    The Adaptive Conservationist strategy promotes resource sustainability and collective well-being
    by conditional cooperation, reacting to both the state of the common stock and the observed
    behavior of other players. It starts cooperatively, attempts to forgive minor defections,
    but punishes widespread or persistent exploitation, especially when the resource is endangered.
    It balances the collective good with self-preservation in a competitive environment.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n_players = game_description.n_players
        self.defection_tolerance_count = math.floor(n_players / 3)
        if n_players == 2:
            self.defection_tolerance_count = 0
        self.stock_recovery_threshold_ratio = 0.3
        self.trust_level: bool = True

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        if current_round == n_rounds - 1:
            return Action.D
        if current_round == 0:
            self.trust_level = True
            return Action.C
        previous_round_idx = current_round - 1
        opponent_defectors_prev = n_players - 1 - np.sum(history.opponent_actions[previous_round_idx])
        my_defection_prev = not history.my_actions[previous_round_idx]
        total_D_count_prev = opponent_defectors_prev + (1 if my_defection_prev else 0)
        if total_D_count_prev > self.defection_tolerance_count:
            self.trust_level = False
        else:
            self.trust_level = True
        critical_stock_level = capacity * self.stock_recovery_threshold_ratio
        if current_stock < critical_stock_level:
            if self.trust_level:
                return Action.C
            else:
                return Action.D
        elif self.trust_level:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_433(BaseStrategy):
    """
    The "Resource Steward" strategy promotes long-term sustainability of the common
    pool resource by adapting its behavior based on the current stock level,
    observed collective behavior of other players, and the current round number.
    It prioritizes resource health but avoids being exploited by widespread defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.STOCK_THRESHOLD_HEALTHY = self.capacity * 0.75
        self.STOCK_THRESHOLD_WARNING = self.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        num_other_defecting_players_last_round = np.sum(~history.opponent_actions[-1, :])
        is_stock_healthy = current_stock >= self.STOCK_THRESHOLD_HEALTHY
        is_stock_warning = current_stock < self.STOCK_THRESHOLD_HEALTHY and current_stock >= self.STOCK_THRESHOLD_WARNING
        is_stock_critical = current_stock < self.STOCK_THRESHOLD_WARNING
        if is_stock_critical:
            return Action.C
        elif is_stock_healthy:
            if num_other_defecting_players_last_round == 0:
                return Action.C
            elif num_other_defecting_players_last_round == 1 and self.n_players > 2:
                return Action.C
            else:
                return Action.D
        elif is_stock_warning:
            if num_other_defecting_players_last_round == 0:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_434(BaseStrategy):
    """
    The "Adaptive Steward" strategy for the Common Pool Resource Game.
    Its core philosophy is to prioritize the long-term sustainability of the common resource
    while adaptively fostering cooperation among players and deterring free-riding.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.r_total = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CONSERVATION_STOCK_THRESHOLD = self.capacity / 2.0
        self.MAX_TOLERATED_DEFECTORS = int(max(0, (self.n_players - 1) * 0.25))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.r_total - 1:
            return Action.D
        if state.current_stock < self.CONSERVATION_STOCK_THRESHOLD:
            return Action.C
        else:
            previous_round_opponent_actions = history.opponent_actions[-1, :]
            num_other_defectors = np.sum(previous_round_opponent_actions == False)
            if num_other_defectors > self.MAX_TOLERATED_DEFECTORS:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_435(BaseStrategy):
    """
    The Adaptive Collective Conservation (ACC) strategy balances collective sustainability
    with robustness in a competitive tournament. It prioritizes the long-term health of
    the common pool resource while adapting to the observed behavior of other players.

    Key principles:
    - Initial Cooperation: Starts by cooperating to signal collective action.
    - Dynamic Tolerance: Adapts tolerance for defection based on current stock health.
    - Punish Persistent Defection: Reacts to widespread or sustained defection.
    - Prioritize Recovery: When stock is low, prioritizes cooperation, unless defection is pervasive.
    - Pragmatic End-Game: Adopts a self-interested approach in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.S_recovery_threshold = capacity / 2.0
        self.D_tolerance_healthy = math.floor(n / 3.0)
        self.D_tolerance_critical = max(0, math.floor(n / 2.0) - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        n_rounds = self.game_description.n_rounds
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == n_rounds - 1:
            return Action.D
        previous_round_idx = current_round_0_indexed - 1
        D_count_prev = np.sum(~history.opponent_actions[previous_round_idx, :])
        current_D_tolerance = 0
        if state.current_stock >= self.S_recovery_threshold:
            current_D_tolerance = self.D_tolerance_healthy
        else:
            current_D_tolerance = self.D_tolerance_critical
        if D_count_prev <= current_D_tolerance:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_436(BaseStrategy):
    """
    Adaptive Stock Management with Punishment (ASMP) strategy for Common Pool Resource Game.
    Prioritizes stock preservation, defaults to cooperation, monitors collective behavior,
    and punishes significant defection or dangerously low stock. Forgives conditionally
    when stock recovers and opponents show sustained cooperation. Defects in the last round.
    """
    _MODE_COOPERATE = 'COOPERATE'
    _MODE_PUNISH = 'PUNISH'

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.current_mode = self._MODE_COOPERATE
        self.punishment_rounds_counter = 0
        self.cooperation_recovery_counter = 0
        self._prev_round_initial_stock: float | None = None
        self.max_tolerated_defection_ratio = 0.25
        self.stock_danger_threshold_ratio = 0.75
        self.stock_recovery_threshold_ratio = 0.95
        self.min_punishment_duration = 2
        self.min_cooperation_forgiveness_rounds = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == 0:
            self.current_mode = self._MODE_COOPERATE
            self.punishment_rounds_counter = 0
            self.cooperation_recovery_counter = 0
            self._prev_round_initial_stock = current_stock
            return Action.C
        if current_round_number == self.n_rounds - 1:
            self._prev_round_initial_stock = current_stock
            return Action.D
        S_prev_start = self._prev_round_initial_stock
        prev_round_index = current_round_number - 1
        my_action_prev_is_C = history.my_actions[prev_round_index]
        opponent_actions_prev_are_C = history.opponent_actions[prev_round_index, :]
        num_C_prev = np.sum(opponent_actions_prev_are_C).item() + (1 if my_action_prev_is_C else 0)
        num_D_prev = self.n_players - num_C_prev
        total_consumption_prev = 0.0
        if S_prev_start is not None and S_prev_start > 0:
            consumption_per_C_unit = S_prev_start / (2.0 * self.n_players)
            consumption_per_D_unit = S_prev_start / (1.0 * self.n_players)
            total_consumption_prev = num_C_prev * consumption_per_C_unit + num_D_prev * consumption_per_D_unit
        is_defection_significant = False
        if S_prev_start is not None and S_prev_start > 0:
            cooperative_total_consumption_if_all_C = S_prev_start / 2.0
            defection_unit_consumption = S_prev_start / (2.0 * self.n_players)
            actual_excess_consumption = total_consumption_prev - cooperative_total_consumption_if_all_C
            if actual_excess_consumption > 0 and defection_unit_consumption > 0:
                NED = actual_excess_consumption / defection_unit_consumption
                NED = max(0.0, min(float(self.n_players), NED))
                is_defection_significant = NED > self.n_players * self.max_tolerated_defection_ratio
        stock_is_dangerously_low = current_stock < self.capacity * self.stock_danger_threshold_ratio
        if self.current_mode == self._MODE_COOPERATE:
            if is_defection_significant or stock_is_dangerously_low:
                self.current_mode = self._MODE_PUNISH
                self.punishment_rounds_counter = 1
                self.cooperation_recovery_counter = 0
            else:
                self.punishment_rounds_counter = 0
                self.cooperation_recovery_counter = 0
        elif self.current_mode == self._MODE_PUNISH:
            self.punishment_rounds_counter += 1
            if not is_defection_significant:
                self.cooperation_recovery_counter += 1
            else:
                self.cooperation_recovery_counter = 0
            stock_has_recovered = current_stock >= self.capacity * self.stock_recovery_threshold_ratio
            if self.punishment_rounds_counter >= self.min_punishment_duration and self.cooperation_recovery_counter >= self.min_cooperation_forgiveness_rounds and stock_has_recovered:
                self.current_mode = self._MODE_COOPERATE
                self.punishment_rounds_counter = 0
                self.cooperation_recovery_counter = 0
        action_for_this_round = Action.C if self.current_mode == self._MODE_COOPERATE else Action.D
        self._prev_round_initial_stock = current_stock
        return action_for_this_round

class Strategy_COLLECTIVE_437(BaseStrategy):
    """
    The Adaptive Collective Stabilizer strategy for the Common Pool Resource Game.
    Prioritizes long-term resource sustainability through initial cooperation,
    tolerance for minor defection, and decisive retaliation against significant threats
    or widespread exploitation, while defecting in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_RATIO = 0.2
        self.UNHEALTHY_STOCK_RATIO = 0.4
        self.LOW_DEFECTION_TOLERANCE_RATIO = 0.2
        self.HIGH_DEFECTION_RATIO = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.total_rounds:
            return Action.D
        n_D_total_prev = 0
        if not history.my_actions[-1]:
            n_D_total_prev += 1
        n_D_total_prev += np.sum(~history.opponent_actions[-1, :])
        current_stock_level = state.current_stock
        if n_D_total_prev == 0:
            return Action.C
        if current_stock_level <= self.capacity * self.CRITICAL_STOCK_RATIO:
            return Action.D
        defection_percentage = n_D_total_prev / self.n_players
        if defection_percentage >= self.HIGH_DEFECTION_RATIO:
            return Action.D
        if defection_percentage > self.LOW_DEFECTION_TOLERANCE_RATIO and current_stock_level <= self.capacity * self.UNHEALTHY_STOCK_RATIO:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_438(BaseStrategy):
    """
    Adaptive Collective Sustainability (ACS) strategy for the Common Pool Resource Game.
    This strategy promotes cooperation for long-term sustainability but adapts to
    opponent defection and resource scarcity. It prioritizes the health of the common
    pool resource, reflecting a strong collective mindset.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number + 1
        if t == 1:
            return Action.C
        if t == self.n_rounds:
            return Action.D
        my_previous_action_was_coop = int(history.my_actions[-1])
        opponent_previous_cooperators = np.sum(history.opponent_actions[-1, :])
        cooperators_last_round = my_previous_action_was_coop + opponent_previous_cooperators
        if state.current_stock <= self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        elif cooperators_last_round >= self.n_players - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_439(BaseStrategy):
    """
    Adaptive Sustainable Reciprocity (ASR) strategy for the Common Pool Resource Game.
    This strategy aims to achieve high collective payoff by ensuring the long-term
    sustainability of the common resource (stock). It balances cooperation with
    self-protection, adapting dynamically to the resource's health and observed
    player behavior.

    The strategy prioritizes cooperation in the first round to signal intent,
    defects in the final round to avoid exploitation, and in intermediate rounds,
    it uses a dynamic 'tolerable_defectors' threshold based on the stock level
    to decide whether to cooperate or defect. A critical stock lower bound triggers
    an emergency conservation mode where the strategy always cooperates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_LOWER_BOUND = self.capacity * 0.05

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number + 1
        current_stock_S_t = state.current_stock
        if current_round_t == 1:
            return Action.C
        if current_round_t == self.r:
            return Action.D
        my_last_action_t_minus_1 = history.my_actions[-1]
        total_cooperators_prev_round = sum(history.opponent_actions[-1]) + int(my_last_action_t_minus_1)
        D_count_t_minus_1 = self.n - total_cooperators_prev_round
        stock_ratio = current_stock_S_t / self.capacity
        tolerable_defectors = 0
        if stock_ratio > 0.8:
            tolerable_defectors = max(1, math.floor(self.n / 3))
        elif stock_ratio < 0.2:
            tolerable_defectors = 0
        else:
            tolerable_defectors = max(1, math.floor(self.n / 4))
        if current_stock_S_t < self.CRITICAL_STOCK_LOWER_BOUND:
            return Action.C
        elif my_last_action_t_minus_1:
            if D_count_t_minus_1 > tolerable_defectors:
                return Action.D
            else:
                return Action.C
        elif D_count_t_minus_1 <= tolerable_defectors:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_440(BaseStrategy):
    """
    Adaptive Resource Guardian: This strategy prioritizes the long-term sustainability of the common
    pool resource through conditional cooperation. It initiates cooperation, monitors opponent actions,
    and adapts its behavior to either maintain cooperation or defend against exploitation.
    Crucially, it takes strong measures to protect the resource when its stock levels are critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold = self.game_description.capacity / 4
        self.low_stock_threshold = self.game_description.capacity / 2
        self.max_defect_tolerance_healthy_stock = 1
        self.max_defect_tolerance_low_stock = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == total_rounds:
            return Action.D
        prev_opponent_D_count = sum((1 for action_bool in history.opponent_actions[-1, :] if not action_bool))
        prev_my_action_was_D = not history.my_actions[-1]
        prev_D_count = prev_opponent_D_count + (1 if prev_my_action_was_D else 0)
        if current_stock <= self.critical_stock_threshold:
            return Action.C
        elif current_stock <= self.low_stock_threshold:
            if prev_D_count <= self.max_defect_tolerance_low_stock:
                return Action.C
            else:
                return Action.D
        elif prev_D_count <= self.max_defect_tolerance_healthy_stock:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_441(BaseStrategy):
    """
    The "Adaptive Custodian" is a collective strategy designed to maintain the common pool resource
    at sustainable levels while being robust to varying opponent behaviors. It prioritizes long-term
    resource health and collective benefit but also reacts to exploitation to prevent self-sacrifice.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_Healthy_Threshold = 0.9 * self.capacity
        self.S_Critical_Threshold = 0.2 * self.capacity
        self.Defection_Tolerance_Drop = 0.05 * self.capacity
        self.Punishment_Rounds_Duration = 3
        self.rounds_in_punishment = 0
        self.last_observed_stock = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_t = state.round_number + 1
        if current_round_t == 1:
            action = Action.C
            self.last_observed_stock = current_stock
            return action
        if current_round_t == self.n_rounds:
            if current_stock <= self.S_Critical_Threshold:
                action = Action.C
            else:
                action = Action.D
            return action
        if self.rounds_in_punishment > 0:
            self.rounds_in_punishment -= 1
            action = Action.D
            self.last_observed_stock = current_stock
            return action
        s_remaining_all_c = self.last_observed_stock / 2.0
        s_remaining_all_c = max(0.0, s_remaining_all_c)
        growth_all_c = 2.0 * s_remaining_all_c * (1.0 - s_remaining_all_c / self.capacity if self.capacity > 0 else 0.0)
        expected_stock_if_all_c = min(s_remaining_all_c + growth_all_c, self.capacity)
        observed_excess_depletion = max(0.0, expected_stock_if_all_c - current_stock)
        if current_stock >= self.S_Healthy_Threshold:
            action = Action.C
            self.rounds_in_punishment = 0
        elif current_stock <= self.S_Critical_Threshold:
            action = Action.C
            self.rounds_in_punishment = 0
        elif observed_excess_depletion > self.Defection_Tolerance_Drop:
            action = Action.D
            self.rounds_in_punishment = self.Punishment_Rounds_Duration - 1
        else:
            action = Action.C
            self.rounds_in_punishment = 0
        self.last_observed_stock = current_stock
        return action

class Strategy_COLLECTIVE_442(BaseStrategy):
    """
    Adaptive Guardian strategy for the Common Pool Resource Game.
    Prioritizes long-term resource health, promotes cooperation, but responds to defection
    or dangerously low stock levels. It aims to foster long-term collective prosperity
    by promoting cooperation and resource sustainability, while being robust against
    exploitation by free-riders. It adapts its behavior based on the current resource
    stock and the observed actions of other players in previous rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_tolerance_threshold = max(1, math.floor(self.n_players / 4))
        self.stock_recovery_threshold = self.capacity / 2.0
        self.stock_critical_threshold = self.capacity / 4.0

    def _calculate_previous_defectors(self, history: PlayerHistory) -> int:
        """
        Infers the number of defecting players in the immediately preceding round,
        based on the observed total consumption. This function implements the logic
        described in the pseudocode, adapted for the provided PlayerHistory structure.
        """
        num_players = self.n_players
        prev_round_idx = history.my_actions.shape[0] - 1
        my_prev_action_is_cooperate = history.my_actions[prev_round_idx]
        my_prev_payoff = history.my_payoffs[prev_round_idx]
        if my_prev_payoff == 0:
            stock_at_start_of_prev_round = 0.0
        elif my_prev_action_is_cooperate:
            stock_at_start_of_prev_round = my_prev_payoff * 2 * num_players
        else:
            stock_at_start_of_prev_round = my_prev_payoff * num_players
        stock_at_start_of_prev_round = max(0.0, stock_at_start_of_prev_round)
        total_consumption_prev_round = my_prev_payoff + np.sum(history.opponent_payoffs[prev_round_idx])
        if stock_at_start_of_prev_round <= 0:
            return num_players
        if stock_at_start_of_prev_round < 1e-09:
            return num_players
        k_float = 2 * num_players * total_consumption_prev_round / stock_at_start_of_prev_round - num_players
        estimated_defectors = round(k_float)
        return int(max(0, min(num_players, estimated_defectors)))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        if round_number == self.n_rounds - 1:
            return Action.D
        observed_defect_count = self._calculate_previous_defectors(history)
        if current_stock <= self.stock_critical_threshold:
            if observed_defect_count > self.n_players / 2.0:
                return Action.D
            else:
                return Action.C
        elif current_stock <= self.stock_recovery_threshold:
            if observed_defect_count > self.defection_tolerance_threshold:
                return Action.D
            else:
                return Action.C
        elif observed_defect_count > self.defection_tolerance_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_443(BaseStrategy):
    """
    The Adaptive Collective Sustainer (ACS) strategy balances resource sustainability,
    fair play, and self-protection in the Common Pool Resource Game.
    It adapts its behavior based on current stock, round number, and opponent actions
    to promote long-term collective welfare while preventing exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_factor = 0.25
        self.defection_tolerance_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == n_rounds - 1:
            return Action.D
        if current_stock < self.critical_stock_factor * capacity:
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[current_round - 1, :]
        num_D_opponents_previous_round = np.sum(~previous_round_opponent_actions)
        num_opponents = n_players - 1
        opponent_defection_rate = num_D_opponents_previous_round / num_opponents
        if opponent_defection_rate > self.defection_tolerance_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_444(BaseStrategy):
    """
    The Adaptive Collective Sustainer (ACS) strategy aims to promote the long-term
    sustainability of the common resource while being robust to a variety of
    opponent behaviors. It balances collective well-being with self-protection
    against exploitation.

    It cooperates initially and when the stock is critically low to aid recovery.
    In healthy stock conditions, it rewards full cooperation and forgives minor
    defections but defects in response to significant exploitation (50% or more
    of other players defecting). In the final round, it defects to maximize
    immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / 2.0
        self.DEFECTION_PROPORTION_THRESHOLD = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        num_opponent_cooperators_prev_round = np.sum(previous_round_opponent_actions)
        num_other_players = self.n_players - 1
        k_other_defectors = num_other_players - num_opponent_cooperators_prev_round
        if k_other_defectors == 0:
            return Action.C
        elif k_other_defectors / num_other_players < self.DEFECTION_PROPORTION_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_445(BaseStrategy):
    """
    The Adaptive Reciprocal Harvester (ARH) strategy.
    Prioritizes long-term resource sustainability through initial cooperation,
    adaptive response to collective defection, and crisis conservation.
    It aims to achieve optimal collective outcome but is prepared to punish
    significant deviation to prevent exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_LOW_THRESHOLD = self.capacity / 4.0
        self.DEFECTION_RESPONSE_THRESHOLD = math.ceil(self.n_players / 2.0)
        self.PUNISHMENT_DURATION = 2
        self.current_punishment_countdown = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        if current_round_number == self.n_rounds - 1:
            self.current_punishment_countdown = 0
            return Action.D
        if current_round_number == 0:
            self.current_punishment_countdown = 0
            return Action.C
        k_prev = 0
        if history is not None:
            prev_round_opponent_actions = history.opponent_actions[-1, :]
            k_prev = sum((1 for is_cooperating in prev_round_opponent_actions if not is_cooperating))
        if state.current_stock < self.S_LOW_THRESHOLD:
            self.current_punishment_countdown = 0
            return Action.C
        if self.current_punishment_countdown > 0:
            self.current_punishment_countdown -= 1
            return Action.D
        elif k_prev >= self.DEFECTION_RESPONSE_THRESHOLD:
            self.current_punishment_countdown = self.PUNISHMENT_DURATION - 1
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_446(BaseStrategy):
    """
    Adaptive Reciprocity for Sustainability (ARS) strategy for the Common Pool Resource Game.
    Fosters cooperation, punishes defection, prioritizes resource conservation at critical levels,
    and accounts for endgame rationality.

    Key Principles:
    1. Start Cooperatively: Begin by cooperating.
    2. Conditional Cooperation: Reward cooperation, punish defection.
    3. Resource Conservation Priority: Cooperate if stock is critically low.
    4. Forgiveness: Allow return to cooperation after consistent opponent cooperation.
    5. Endgame Rationality: Defect in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOPERATION_THRESHOLD = 0
        self.FORGIVENESS_ROUNDS = 1
        self.CRITICAL_STOCK_THRESHOLD = self.game_description.capacity * 0.25
        self.my_current_stance = 'COOPERATE'
        self.consecutive_cooperation_rounds_from_others = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            self.my_current_stance = 'COOPERATE'
            self.consecutive_cooperation_rounds_from_others = 0
            return Action.C
        num_opponent_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
        num_defectors_from_others_last_round = self.game_description.n_players - 1 - num_opponent_cooperators_last_round
        if num_defectors_from_others_last_round == 0:
            self.consecutive_cooperation_rounds_from_others += 1
        else:
            self.consecutive_cooperation_rounds_from_others = 0
        if current_stock <= self.CRITICAL_STOCK_THRESHOLD:
            self.my_current_stance = 'COOPERATE'
            self.consecutive_cooperation_rounds_from_others = 0
            return Action.C
        if self.my_current_stance == 'COOPERATE':
            if num_defectors_from_others_last_round <= self.COOPERATION_THRESHOLD:
                return Action.C
            else:
                self.my_current_stance = 'PUNISH'
                return Action.D
        elif self.my_current_stance == 'PUNISH':
            if self.consecutive_cooperation_rounds_from_others >= self.FORGIVENESS_ROUNDS:
                self.my_current_stance = 'COOPERATE'
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_447(BaseStrategy):
    """
    Adaptive Stock-Watch strategy for the Common Pool Resource Game.

    This strategy prioritizes resource preservation, adapting its behavior
    based on the stock level and the observed actions of other players.
    It aims for conditional cooperation, retaliating against significant
    defection while being forgiving, and acts purely selfishly in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.my_current_stance = 'COOPERATIVE'
        self.CRITICAL_STOCK_THRESHOLD_FACTOR = 0.25
        self.DEFECTOR_TOLERANCE_PERCENTAGE = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds_1_indexed = self.game_description.n_rounds
        if current_round_1_indexed == total_rounds_1_indexed:
            return Action.D
        if state.round_number == 0:
            self.my_current_stance = 'COOPERATIVE'
            return Action.C
        if state.current_stock < self.game_description.capacity * self.CRITICAL_STOCK_THRESHOLD_FACTOR:
            self.my_current_stance = 'COOPERATIVE'
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        num_other_defectors_last_round = np.sum(~previous_round_opponent_actions)
        n_minus_1 = self.game_description.n_players - 1
        other_defector_percentage = num_other_defectors_last_round / n_minus_1
        if other_defector_percentage > self.DEFECTOR_TOLERANCE_PERCENTAGE:
            self.my_current_stance = 'DEFENSIVE'
            return Action.D
        elif num_other_defectors_last_round == 0:
            self.my_current_stance = 'COOPERATIVE'
            return Action.C
        elif self.my_current_stance == 'COOPERATIVE':
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_448(BaseStrategy):
    """
    Adaptive Reciprocal Harvester (ARH) strategy for the Common Pool Resource Game.
    This strategy aims to promote collective sustainability and maximize long-term
    payoffs by encouraging cooperation while defending against exploitation. It adapts
    its behavior based on observed actions of other players and the current stock level.

    Core principles: Cooperate if others cooperate, punish if others defect,
    prioritize resource conservation, but be pragmatic if the resource is
    being irrevocably destroyed by others.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.my_state = 'COOPERATE'
        self.defection_streak_others = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        d_count_t_minus_1 = np.sum(~history.opponent_actions[current_round_0_indexed - 1])
        if d_count_t_minus_1 == 0:
            self.defection_streak_others = 0
            self.my_state = 'COOPERATE'
        else:
            self.defection_streak_others += 1
        if current_stock <= self.capacity / self.n_players:
            if d_count_t_minus_1 >= self.n_players / 2:
                return Action.D
            else:
                return Action.C
        elif self.my_state == 'COOPERATE':
            if d_count_t_minus_1 == 0:
                return Action.C
            else:
                self.my_state = 'PUNISH'
                return Action.D
        elif self.my_state == 'PUNISH':
            return Action.D

class Strategy_COLLECTIVE_449(BaseStrategy):
    """
    Adaptive Collective Resource Manager (ACRM) strategy for the Common Pool Resource Game.

    ACRM prioritizes long-term resource health by aiming to establish and maintain a
    high-stock, cooperative equilibrium. It starts with an optimistic cooperative stance
    but dynamically adjusts its actions based on the current resource state and the
    observed behavior of other players. It employs a "carrot and stick" approach to
    encourage cooperation, while also incorporating measures for self-preservation
    when the collective good is not being pursued by the majority.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.s_critical_threshold = self.game_description.capacity / 4.0
        self.minor_defection_threshold = math.floor(self.game_description.n_players / 4.0)
        self.major_defection_threshold = math.floor(self.game_description.n_players / 2.0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        num_defectors_prev_round = 0
        if current_round > 1:
            num_defectors_prev_round = np.sum(~history.opponent_actions[state.round_number - 1, :])
        if current_round == total_rounds:
            return Action.D
        if current_stock < self.s_critical_threshold:
            if num_defectors_prev_round <= self.major_defection_threshold:
                return Action.C
            else:
                return Action.D
        elif num_defectors_prev_round == 0:
            return Action.C
        elif num_defectors_prev_round <= self.minor_defection_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_450(BaseStrategy):
    """
    The "Adaptive Resource Guardian" strategy prioritizes long-term resource sustainability through
    conditional cooperation. It is cooperative by default but dynamically adjusts its behavior
    based on the current stock level and the observed cooperation levels of other players
    in the previous round. It aims to enforce cooperation to prevent resource depletion
    while offering a path to recovery during crises.

    Decision Rules:
    1.  Last Round: Always Defect (D) to maximize final round payoff.
    2.  First Round: Always Cooperate (C) to establish a cooperative baseline.
    3.  Intermediate Rounds:
        a.  Critical Stock: If stock is critically low, always Cooperate (C) to aid recovery.
        b.  High Stock: If stock is high, demand full cooperation (all players C) to maintain.
            If any player defected in the previous round, Defect (D).
        c.  Normal Stock: If stock is moderate, tolerate at most one defector.
            If two or more players defected in the previous round, Defect (D), otherwise Cooperate (C).
    """
    CRITICAL_STOCK_RATIO: float = 0.25
    HIGH_STOCK_RATIO: float = 0.75

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = self.capacity * self.CRITICAL_STOCK_RATIO
        self.high_stock_threshold = self.capacity * self.HIGH_STOCK_RATIO

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.total_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.C
        my_prev_action_was_cooperate = history.my_actions[-1]
        opponent_prev_cooperators = np.sum(history.opponent_actions[-1, :])
        n_cooperators_prev_round = int(my_prev_action_was_cooperate) + opponent_prev_cooperators
        if current_stock <= self.critical_stock_threshold:
            return Action.C
        elif current_stock > self.high_stock_threshold:
            if n_cooperators_prev_round == self.n_players:
                return Action.C
            else:
                return Action.D
        elif n_cooperators_prev_round >= self.n_players - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_451(BaseStrategy):
    """
    The Adaptive Collective Harvester strategy is a sophisticated Tit-for-Tat variant tailored for
    multi-player common pool resource games. It starts by cooperating, then dynamically adjusts
    its behavior based on the observed actions of other players and the health of the common stock.
    It aims to foster long-term collective sustainability but is ready to defend itself against
    exploitation and extract value from a failing resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_danger_threshold: float = self.game_description.capacity / 4.0
        self.stock_forgiveness_threshold: float = self.game_description.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round
        based on the strategy's decision rules.

        Args:
            state (CommonPoolState): The current state of the game, including round number and stock level.
            history (None | PlayerHistory): Past actions and payoffs of all players.
                                            Will be None for the very first round (round_number == 0).

        Returns:
            Action: The chosen action for the current round (Action.C for Cooperate, Action.D for Defect).
        """
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock <= self.stock_danger_threshold:
            return Action.D
        if state.round_number == 0:
            return Action.C
        num_other_defectors = np.sum(~history.opponent_actions[-1, :])
        if num_other_defectors == 0:
            return Action.C
        elif state.current_stock > self.stock_forgiveness_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_452(BaseStrategy):
    """
    The Adaptive Collective Conservationist (ACC) strategy prioritizes long-term resource sustainability.
    It starts cooperative, but adapts by punishing significant defection from other players.
    A critical stock threshold triggers emergency conservation, ensuring the resource's survival.
    In the final round, it defects to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.K = math.floor(self.n_players / 2)
        self.critical_stock_threshold = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if state.current_stock < self.critical_stock_threshold:
            return Action.C
        if current_round_1_indexed == 1:
            return Action.C
        prev_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        d_count_prev = (prev_round_opponent_actions == False).sum()
        if d_count_prev >= self.K:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_453(BaseStrategy):
    """
    Adaptive Resource Guardian (ARG) strategy promoting resource sustainability and adaptive cooperation.
    It prioritizes resource health, signals cooperation, deters exploitation, and adjusts behavior
    based on stock levels and opponents' previous actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD_RATIO = 0.5
        self.WARNING_STOCK_THRESHOLD_RATIO = 0.9

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        critical_stock_threshold = self.game_description.capacity * self.CRITICAL_STOCK_THRESHOLD_RATIO
        warning_stock_threshold = self.game_description.capacity * self.WARNING_STOCK_THRESHOLD_RATIO
        current_round_1_indexed = state.round_number + 1
        total_rounds_r = self.game_description.n_rounds
        current_stock_S = state.current_stock
        n_players = self.game_description.n_players
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == total_rounds_r:
            if current_stock_S < critical_stock_threshold:
                return Action.C
            else:
                return Action.D
        num_other_defectors_last_round = np.sum(~history.opponent_actions[-1, :])
        if current_stock_S < critical_stock_threshold:
            return Action.C
        elif current_stock_S < warning_stock_threshold:
            if num_other_defectors_last_round == 0:
                return Action.C
            else:
                return Action.D
        elif num_other_defectors_last_round == 0:
            return Action.C
        elif num_other_defectors_last_round <= (n_players - 1) / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_454(BaseStrategy):
    """
    Adaptive Collective Sustain (ACS) strategy for the Common Pool Resource Game.
    This strategy prioritizes initial cooperation, resource sustainability,
    and adaptive responses to defection. It aims for the best collective outcome
    by starting cooperatively, and then responding to both observed defection
    and the health of the common resource. It features forgiveness for minor
    deviations, punitive action against widespread or damaging defection,
    a strong commitment to resource survival, and rational play in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_idx = state.round_number
        current_stock = state.current_stock
        if current_round_idx == 0:
            return Action.C
        if current_round_idx == self.n_rounds - 1:
            return Action.D
        prev_round_idx = current_round_idx - 1
        my_action_prev = history.my_actions[prev_round_idx]
        my_payoff_prev = history.my_payoffs[prev_round_idx]
        if my_action_prev == True:
            S_prev = my_payoff_prev * (2 * self.n_players)
        else:
            S_prev = my_payoff_prev * self.n_players
        my_defected_prev = 1 if my_action_prev == False else 0
        opponent_defected_prev = self.n_players - 1 - np.sum(history.opponent_actions[prev_round_idx, :])
        k_prev = my_defected_prev + opponent_defected_prev
        if current_stock <= self.n_players:
            return Action.C
        elif k_prev == 0:
            return Action.C
        elif current_stock < S_prev:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_455(BaseStrategy):
    """
    The Adaptive Collective Guardian (ACG) strategy for the Common Pool Resource Game.
    It fosters cooperation and resource sustainability by adapting its strictness based
    on collective behavior and the resource's health, while also protecting its own
    interests in endgame scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_critical_threshold = self.capacity / 2.0
        self.cooperation_threshold_lenient = 0.9
        self.cooperation_threshold_strict = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_zero_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_zero_indexed == 0:
            return Action.C
        elif current_round_zero_indexed == self.n_rounds - 1:
            return Action.D
        else:
            c_count_opponents_prev = sum(history.opponent_actions[-1, :])
            my_action_prev_is_cooperate = history.my_actions[-1]
            c_count_total_prev = c_count_opponents_prev + int(my_action_prev_is_cooperate)
            cooperation_rate_prev = c_count_total_prev / self.n_players
            if current_stock < self.stock_critical_threshold:
                if cooperation_rate_prev >= self.cooperation_threshold_lenient:
                    return Action.C
                else:
                    return Action.D
            else:
                dynamic_cooperation_threshold = self.cooperation_threshold_strict + (self.cooperation_threshold_lenient - self.cooperation_threshold_strict) * (1.0 - (current_stock - self.stock_critical_threshold) / (self.capacity - self.stock_critical_threshold))
                if cooperation_rate_prev >= dynamic_cooperation_threshold:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_456(BaseStrategy):
    """
    Sustainable Adaptive Tit-for-Tat (SATT) strategy for the Common Pool Resource Game.
    This strategy combines a long-term collective mindset focused on resource sustainability
    with an adaptive, reciprocal approach to opponent behavior.

    Core Principles:
    1.  Prioritize Sustainability: Cooperates if the common resource is in a critical state.
    2.  Reciprocal Cooperation: When the resource is stable, cooperates if a sufficient
        proportion of other players cooperated in the previous round, otherwise defects.
    3.  End-Game Rationality: Defects in the final round to maximize immediate personal gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.COOPERATION_THRESHOLD = 0.75
        self.CRITICAL_STOCK_RATIO = 1.0 / (2.0 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        critical_stock_level = self.capacity * self.CRITICAL_STOCK_RATIO
        if current_stock < critical_stock_level:
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        num_cooperators_last_round = np.sum(previous_round_opponent_actions)
        observed_cooperation_rate = num_cooperators_last_round / (self.n_players - 1)
        if observed_cooperation_rate >= self.COOPERATION_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_457(BaseStrategy):
    """
    Adaptive Collective Steward strategy for the Common Pool Resource Game.
    Prioritizes long-term resource sustainability through conditional cooperation,
    punishment, and critical stock conservation, adapting to observed opponent behavior
    and game stage.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.s_critical_threshold_factor = 0.25
        self.s_danger_threshold_factor = 0.5
        self.defector_tolerance_normal = 0
        self.defector_tolerance_danger_mode_proportion = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        s_critical = capacity * self.s_critical_threshold_factor
        s_danger = capacity * self.s_danger_threshold_factor
        if current_round_1_indexed == 1:
            return Action.C
        prev_round_opponent_actions = history.opponent_actions[state.round_number - 1]
        num_D_prev_round = np.sum(prev_round_opponent_actions == False)
        if current_round_1_indexed == r:
            if current_stock <= s_critical:
                return Action.C
            elif num_D_prev_round == 0:
                return Action.C
            else:
                return Action.D
        if current_round_1_indexed == r - 1:
            if num_D_prev_round == 0:
                return Action.C
            else:
                return Action.D
        if current_stock <= s_critical:
            return Action.C
        if current_stock <= s_danger:
            if num_D_prev_round >= n * self.defector_tolerance_danger_mode_proportion:
                return Action.D
            else:
                return Action.C
        if num_D_prev_round > self.defector_tolerance_normal:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_458(BaseStrategy):
    """
    The Adaptive Resource Guardian (ARG) strategy aims to maintain the common pool resource
    at a sustainable level while protecting against free-riders and exploitation.
    It promotes cooperation and resource sustainability, but swiftly retaliates against
    collective defection when the resource is healthy, and prioritizes recovery when
    the resource is under stress. In the final round, it behaves purely selfishly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_low_threshold = self.capacity / 2.0
        self.defection_tolerance_healthy = 1
        self.defection_critical_low_stock = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        num_cooperators_last_round = int(history.my_actions[-1]) + np.sum(history.opponent_actions[-1, :])
        num_defectors_last_round = self.n_players - num_cooperators_last_round
        D_proportion_last_round = num_defectors_last_round / self.n_players
        if current_stock < self.stock_low_threshold:
            if D_proportion_last_round >= self.defection_critical_low_stock:
                return Action.D
            else:
                return Action.C
        elif num_defectors_last_round > self.defection_tolerance_healthy:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_459(BaseStrategy):
    """
    Adaptive Guardian: A strategy for common pool resource games that enforces cooperation
    when the resource is healthy and attempts to restore it when critical,
    while avoiding being exploited in a collapsing system.

    Core Philosophy:
    1. Strict Enforcement (when stock is healthy): Any observed defection is met with a
       retaliatory defection in the next round to deter opportunistic behavior.
    2. Forgiving Restoration (when stock is critical): Attempts to cooperate to help
       restore the stock, unless a clear majority of other players are actively defecting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_threshold = self.capacity * 0.5
        self.defection_response_threshold_healthy = 0
        self.defection_response_threshold_critical = self.n_players // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        k_prev_D = 0
        if state.round_number > 0:
            if not history.my_actions[-1]:
                k_prev_D += 1
            k_prev_D += np.sum(~history.opponent_actions[-1, :])
        if state.current_stock < self.critical_stock_threshold:
            if k_prev_D > self.defection_response_threshold_critical:
                return Action.D
            else:
                return Action.C
        elif k_prev_D > self.defection_response_threshold_healthy:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_460(BaseStrategy):
    """
    Adaptive Resource Guard (ARG) strategy for the Common Pool Resource Game.

    This strategy aims to preserve the common pool resource at high levels through
    conditional cooperation. It punishes collective defection by temporary defection
    and forgives, returning to cooperation when conditions improve. The strategy's
    behavior is primarily driven by the health of the common stock.
    """
    HIGH_STOCK_THRESHOLD_PERCENT = 0.9
    LOW_STOCK_THRESHOLD_PERCENT = 0.7
    CRITICAL_STOCK_THRESHOLD_PERCENT = 0.1
    PUNISHMENT_DURATION_ROUNDS = 2
    FORGIVENESS_TEST_ROUNDS = 1

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._state_mode: str = 'COOPERATE'
        self._action_counter: int = 0
        self._high_stock_threshold: float = self.HIGH_STOCK_THRESHOLD_PERCENT * self.game_description.capacity
        self._low_stock_threshold: float = self.LOW_STOCK_THRESHOLD_PERCENT * self.game_description.capacity
        self._critical_stock_threshold: float = self.CRITICAL_STOCK_THRESHOLD_PERCENT * self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round == total_rounds - 1:
            self._state_mode = 'COOPERATE'
            self._action_counter = 0
            return Action.D
        if current_stock <= self._critical_stock_threshold:
            self._state_mode = 'PUNISH'
            self._action_counter = self.PUNISHMENT_DURATION_ROUNDS
            return Action.D
        if current_stock >= self._high_stock_threshold:
            self._state_mode = 'COOPERATE'
            self._action_counter = 0
            return Action.C
        if self._state_mode == 'COOPERATE':
            if current_stock < self._low_stock_threshold:
                self._state_mode = 'PUNISH'
                self._action_counter = 1
                return Action.D
            else:
                return Action.C
        elif self._state_mode == 'PUNISH':
            if self._action_counter < self.PUNISHMENT_DURATION_ROUNDS:
                self._action_counter += 1
                return Action.D
            else:
                self._state_mode = 'FORGIVE'
                self._action_counter = 1
                return Action.C
        elif self._state_mode == 'FORGIVE':
            if self._action_counter < self.FORGIVENESS_TEST_ROUNDS:
                self._action_counter += 1
                return Action.C
            else:
                self._state_mode = 'COOPERATE'
                self._action_counter = 0
                if current_stock < self._low_stock_threshold:
                    self._state_mode = 'PUNISH'
                    self._action_counter = 1
                    return Action.D
                else:
                    return Action.C
        self._state_mode = 'COOPERATE'
        self._action_counter = 0
        return Action.C

class Strategy_COLLECTIVE_461(BaseStrategy):
    """
    The Adaptive Steward strategy for the Common Pool Resource Game.
    It prioritizes long-term resource health, promotes cooperation,
    deters defection, and adapts based on stock level and observed behavior.

    Core Principles:
    1. Resource First: Prevents common pool collapse.
    2. Promote Cooperation: Starts cooperatively and rewards widespread cooperation.
    3. Deter Defection: Responds to defection to discourage free-riding.
    4. Adaptability: Adjusts behavior based on current stock and opponent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CONSERVATION_THRESHOLD = self.game_description.capacity / 4.0
        self.DEFECTION_TOLERANCE_COUNT = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round_number == 0:
            return Action.C
        if current_round_number == total_rounds - 1:
            return Action.D
        if state.current_stock < self.CONSERVATION_THRESHOLD:
            return Action.C
        else:
            prev_round_opponent_actions = history.opponent_actions[-1, :]
            num_cooperators_in_prev_round = np.sum(prev_round_opponent_actions)
            num_opponents = self.game_description.n_players - 1
            num_defectors_in_prev_round = num_opponents - num_cooperators_in_prev_round
            if num_defectors_in_prev_round == 0:
                return Action.C
            elif num_defectors_in_prev_round > self.DEFECTION_TOLERANCE_COUNT:
                return Action.D

class Strategy_COLLECTIVE_462(BaseStrategy):
    """
    Adaptive Stock-Aware Tit-for-Many (ASTFM) strategy. This strategy aims to foster collective
    cooperation and ensure the long-term sustainability of the common resource by balancing
    immediate incentives with resource management. It reacts to previous round's defections,
    prioritizes resource recovery during critically low stock levels, and defects in the last round
    for maximal individual gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / 2.0
        self.HIGH_STOCK_THRESHOLD = self.capacity * 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_num_0_indexed == self.r - 1:
            return Action.D
        if current_round_num_0_indexed == 0:
            return Action.C
        num_cooperators_others_prev_round = np.sum(history.opponent_actions[-1, :])
        num_defectors_others_prev_round = self.n - 1 - num_cooperators_others_prev_round
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        else:
            if num_defectors_others_prev_round == 0:
                return Action.C
            threshold_significant_defection = math.ceil((self.n - 1) / 2.0)
            if num_defectors_others_prev_round >= threshold_significant_defection:
                return Action.D
            elif current_stock < self.HIGH_STOCK_THRESHOLD:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_463(BaseStrategy):
    """
    Collective Steward with Adaptive Forgiveness (CSAF) strategy balances individual incentives
    with collective resource sustainability. It adapts its behavior based on the current
    resource stock level and the observed defection rate in the previous round,
    while accounting for group size. It prioritizes cooperation at critically low stock levels
    and immediately defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_level = 0.2 * self.game_description.capacity
        self.warning_stock_level = 0.7 * self.game_description.capacity
        n = self.game_description.n_players
        if n <= 2:
            self.healthy_stock_defection_tolerance_threshold = 0
        elif n < 8:
            self.healthy_stock_defection_tolerance_threshold = 1
        else:
            self.healthy_stock_defection_tolerance_threshold = n // 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == total_rounds:
            return Action.D
        last_round_defectors_count = np.sum(~history.opponent_actions[-1, :])
        if current_stock < self.critical_stock_level:
            return Action.C
        elif current_stock < self.warning_stock_level:
            if last_round_defectors_count > 0:
                return Action.D
            else:
                return Action.C
        elif last_round_defectors_count > self.healthy_stock_defection_tolerance_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_464(BaseStrategy):
    """
    The Adaptive Resource Steward strategy for the Common Pool Resource Game.
    Prioritizes long-term resource health with initial cooperation, responsive
    punishment, and a critical resource preservation mode.

    Core Principles:
    1. Start Cooperatively: Signal intent for sustainable resource management.
    2. Reward Cooperation, Punish Defection: Maintain cooperation as long as
       a sufficient number of players are also cooperating.
    3. Resource Preservation Mode: Prioritize universal cooperation when the
       common stock is critically low to prevent collapse.
    4. Endgame Rationality: Defect in the final round due to lack of future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.cooperation_tolerance_threshold = self.n_players - 1
        self.critical_stock_threshold = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_stock < self.critical_stock_threshold:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.C
        c_count_prev_round = 0
        if history.my_actions[-1]:
            c_count_prev_round += 1
        c_count_prev_round += np.sum(history.opponent_actions[-1, :])
        if c_count_prev_round >= self.cooperation_tolerance_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_465(BaseStrategy):
    """
    The "Adaptive Stock Guardian" strategy balances collective resource sustainability with individual
    performance in a competitive tournament. It starts cooperatively but is ready to punish defection
    and adapt its behavior based on the resource's health. If the stock is critically low, it
    attempts collective recovery only if others cooperate; otherwise, it acts to mitigate personal losses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_LEVEL = self.game_description.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.game_description.n_rounds:
            return Action.D
        previous_round_history_index = state.round_number - 1
        opponent_actions_prev_round = history.opponent_actions[previous_round_history_index]
        num_opponent_defectors_last_round = np.sum(~opponent_actions_prev_round)
        if state.current_stock < self.CRITICAL_STOCK_LEVEL:
            if num_opponent_defectors_last_round == 0:
                return Action.C
            else:
                return Action.D
        elif num_opponent_defectors_last_round == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_466(BaseStrategy):
    """
    Adaptive Sustaining Reciprocity (ASR) strategy for the Common Pool Resource Game.
    This strategy aims to maximize long-term payoffs by balancing resource stewardship
    with conditional cooperation and self-protection. It adapts to both stock levels
    and opponent behavior, and strategically shifts towards immediate gains in the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_critical_threshold = self.capacity * 0.25
        self.stock_healthy_threshold = self.capacity * 0.75
        self.cooperation_leniency_low_stock = 0.7
        self.cooperation_leniency_high_stock = 0.4
        self.cooperation_leniency_moderate_stock = 0.5
        self.endgame_horizon = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number_1_indexed = state.round_number + 1
        r_remaining = self.total_rounds - round_number_1_indexed + 1
        previous_round_cooperation_rate = 1.0
        if round_number_1_indexed > 1:
            num_cooperators_prev_round = sum(history.opponent_actions[state.round_number - 1])
            previous_round_cooperation_rate = num_cooperators_prev_round / (self.n_players - 1)
        if r_remaining <= self.endgame_horizon:
            if r_remaining == 1:
                return Action.D
            if previous_round_cooperation_rate >= self.cooperation_leniency_high_stock:
                return Action.C
            else:
                return Action.D
        elif current_stock < self.stock_critical_threshold:
            if previous_round_cooperation_rate >= self.cooperation_leniency_low_stock:
                return Action.C
            else:
                return Action.D
        elif current_stock >= self.stock_healthy_threshold:
            if previous_round_cooperation_rate >= self.cooperation_leniency_high_stock:
                return Action.C
            else:
                return Action.D
        elif previous_round_cooperation_rate >= self.cooperation_leniency_moderate_stock:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_467(BaseStrategy):
    """
    The Adaptive Resource Guardian (ARG) strategy promotes sustainable resource management.
    It defaults to cooperation, but dynamically adjusts its behavior based on the
    observed cooperation level of other players and the current health of the common stock.
    It balances collective good with self-preservation, adapting to prevent exploitation
    and reacting strategically in crisis situations.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_H = self.game_description.capacity / 2
        self.stock_danger_threshold = self.game_description.capacity / 10
        self.Cooperation_Threshold_High = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        c_count_others = np.sum(previous_round_opponent_actions)
        num_other_players = self.game_description.n_players - 1
        if num_other_players == 0:
            cooperation_rate_others = 1.0
        else:
            cooperation_rate_others = c_count_others / num_other_players
        stock_health_status: str
        if state.current_stock >= self.S_H:
            stock_health_status = 'healthy'
        elif state.current_stock > self.stock_danger_threshold:
            stock_health_status = 'warning'
        else:
            stock_health_status = 'critical'
        if stock_health_status == 'healthy':
            if cooperation_rate_others >= self.Cooperation_Threshold_High:
                return Action.C
            else:
                return Action.D
        elif stock_health_status == 'warning':
            if cooperation_rate_others >= self.Cooperation_Threshold_High:
                return Action.C
            else:
                return Action.D
        elif stock_health_status == 'critical':
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_468(BaseStrategy):
    """
    Adaptive Conservationist (AC) Strategy: Aims to foster sustainable resource management by promoting
    cooperation while being robust against exploitation. It balances collective good (resource preservation)
    with self-protection, adapting behavior based on current stock and observed cooperation levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOPERATION_THRESHOLD_STRICT = 0.9
        self.COOPERATION_THRESHOLD_LENIENT = 0.7
        self.STOCK_HEALTH_THRESHOLD = self.game_description.capacity * 0.75
        self.STOCK_CRITICAL_THRESHOLD = self.game_description.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        if current_round_0_indexed == 0:
            c_count_prev = n_players
        else:
            c_count_prev = np.sum(history.opponent_actions[-1, :]) + history.my_actions[-1]
        cooperation_rate_prev = c_count_prev / n_players
        if current_round_0_indexed == 0:
            return Action.C
        elif current_round_0_indexed == total_rounds - 1:
            if current_stock >= self.STOCK_HEALTH_THRESHOLD and cooperation_rate_prev >= self.COOPERATION_THRESHOLD_STRICT:
                return Action.C
            else:
                return Action.D
        elif current_stock < self.STOCK_CRITICAL_THRESHOLD:
            return Action.C
        elif current_stock >= self.STOCK_HEALTH_THRESHOLD:
            if cooperation_rate_prev == 1.0:
                return Action.C
            elif cooperation_rate_prev >= self.COOPERATION_THRESHOLD_LENIENT:
                return Action.C
            else:
                return Action.D
        elif cooperation_rate_prev >= self.COOPERATION_THRESHOLD_STRICT:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_469(BaseStrategy):
    """
    Adaptive Collective Sustainment (ACS) strategy for the Common Pool Resource Game.
    This strategy aims to foster cooperation and sustain the common pool resource over time,
    while being robust against exploitation and adaptive to varying levels of opponent cooperation.
    It balances collective benefit (resource preservation) with individual rationality
    (avoiding being a "sucker" and maximizing long-term payoff).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if round_number == n_rounds - 1:
            return Action.D
        n_C_prev = int(history.my_actions[-1]) + np.sum(history.opponent_actions[-1, :])
        n_D_prev = n_players - n_C_prev
        if current_stock < capacity / 2:
            return Action.C
        elif n_D_prev == 0:
            return Action.C
        elif n_D_prev == 1:
            if n_players == 2:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_471(BaseStrategy):
    """
    Adaptive Stock Guardian: This strategy is rooted in the principle of sustainable reciprocity.
    It aims to achieve and maintain a healthy common stock by cooperating, but it will defensively
    defect if other players are depleting the resource, to minimize exploitation and encourage
    a return to cooperative behavior. It uses stock level thresholds and opponent defection
    tolerance levels to make adaptive decisions across different phases of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.S_critical_threshold = capacity / 4.0
        self.S_low_threshold = capacity / 2.0
        self.D_tolerance_healthy = math.ceil(n / 3.0)
        self.D_tolerance_concerning = 1
        self.D_tolerance_critical = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        num_players = self.game_description.n_players
        if round_num == 0:
            return Action.C
        if round_num == total_rounds - 1:
            return Action.D
        opponent_actions_prev_round = history.opponent_actions[-1, :]
        num_cooperators_prev_round = sum(opponent_actions_prev_round)
        num_defectors_prev_round = num_players - 1 - num_cooperators_prev_round
        if current_stock < self.S_critical_threshold:
            if num_defectors_prev_round <= self.D_tolerance_critical:
                return Action.C
            else:
                return Action.D
        elif current_stock < self.S_low_threshold:
            if num_defectors_prev_round <= self.D_tolerance_concerning:
                return Action.C
            else:
                return Action.D
        elif num_defectors_prev_round <= self.D_tolerance_healthy:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_472(BaseStrategy):
    """
    Adaptive Reciprocal Sustainability (ARS) strategy for the Common Pool Resource Game.
    Aims to maximize collective welfare by sustaining the resource, but adapts to
    protect itself from exploitation by non-cooperative players. It initiates
    cooperation, but retaliates against observed defection based on stock health
    and tolerance thresholds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds_r = self.game_description.n_rounds
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == total_rounds_r:
            return Action.D
        previous_defection_count = np.sum(~history.opponent_actions[-1, :])
        CRITICAL_STOCK_THRESHOLD = capacity * 0.25
        if current_stock <= CRITICAL_STOCK_THRESHOLD:
            if previous_defection_count == n_players - 1:
                return Action.D
            else:
                return Action.C
        else:
            strictness_threshold = 0
            if current_stock >= capacity * 0.75:
                strictness_threshold = 0
            elif current_stock >= capacity * 0.5:
                if n_players > 2:
                    strictness_threshold = 1
                else:
                    strictness_threshold = 0
            else:
                strictness_threshold = 0
            if previous_defection_count > strictness_threshold:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_473(BaseStrategy):
    """
    Adaptive Collective Sentinel (ACS) strategy for the Common Pool Resource Game.
    This strategy aims to promote collective welfare and resource sustainability
    by initiating cooperation, monitoring collective behavior, and applying
    conditional reciprocity with forgiveness, while prioritizing resource
    preservation at critical stock levels and acting rationally in the end-game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.total_rounds = game_description.n_rounds
        self.cooperation_tolerance_threshold = 0
        if self.n_players >= 4:
            self.cooperation_tolerance_threshold = 1
        self.critical_stock_level = self.capacity / 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_idx = state.round_number
        current_stock = state.current_stock
        if current_round_idx == self.total_rounds - 1:
            return Action.D
        if current_round_idx == 0:
            return Action.C
        num_opponent_cooperators_prev_round = np.sum(history.opponent_actions[-1, :])
        total_cooperators_prev_round = num_opponent_cooperators_prev_round + history.my_actions[-1]
        num_defectors_in_prev_round = self.n_players - total_cooperators_prev_round
        is_stock_critical = current_stock < self.critical_stock_level
        if is_stock_critical:
            if num_defectors_in_prev_round > self.cooperation_tolerance_threshold:
                if num_defectors_in_prev_round >= self.n_players / 2:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.C
        elif num_defectors_in_prev_round > self.cooperation_tolerance_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_474(BaseStrategy):
    """
    The Adaptive Resource Steward (ARS) strategy promotes and sustains cooperation
    in the Common Pool Resource Game. It prioritizes resource health, adapting
    defensively against widespread defection or in end-game scenarios, while
    defaulting to cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_at_start_of_rounds: list[float] = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.stock_at_start_of_rounds.append(state.current_stock)
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == total_rounds:
            return Action.D
        S_critical_low_threshold = capacity / 4.0
        if current_stock < S_critical_low_threshold:
            return Action.C
        num_cooperators_opponent_prev = np.sum(history.opponent_actions[-1, :])
        num_defectors_opponent_prev = n_players - 1 - num_cooperators_opponent_prev
        my_action_prev_was_D = not history.my_actions[-1]
        num_defectors_my_prev = 1 if my_action_prev_was_D else 0
        num_defectors_prev = num_defectors_opponent_prev + num_defectors_my_prev
        defection_rate_prev = float(num_defectors_prev) / n_players
        if defection_rate_prev > 0.5:
            return Action.D
        if current_stock >= capacity * 0.95:
            return Action.C
        stock_prev_round_start = self.stock_at_start_of_rounds[current_round_0_indexed - 1]
        if current_stock > stock_prev_round_start:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_475(BaseStrategy):
    """
    The "Sustainable Steward" strategy for the Common Pool Resource Game.
    This strategy is designed to be adaptive, robust, and prioritize the
    long-term health of the common resource while remaining competitive.
    It balances collective well-being with strategic self-interest, responding
    dynamically to the resource state and the observed behavior of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_RATIO = 0.5
        self.HIGH_STOCK_FOR_WARNING_RATIO = 0.8
        self.COOPERATION_TOLERANCE_THRESHOLD = 0.2
        self.PUNISHMENT_THRESHOLD = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        all_prev_round_actions = np.concatenate((history.opponent_actions[-1], [history.my_actions[-1]]))
        num_defectors_prev_round = np.sum(all_prev_round_actions == False)
        proportion_defectors = num_defectors_prev_round / self.game_description.n_players
        my_previous_action_enum = Action.C if history.my_actions[-1] else Action.D
        if state.current_stock < self.game_description.capacity * self.CRITICAL_STOCK_RATIO:
            return Action.C
        if proportion_defectors > self.PUNISHMENT_THRESHOLD:
            return Action.D
        if proportion_defectors <= self.COOPERATION_TOLERANCE_THRESHOLD:
            return Action.C
        elif my_previous_action_enum == Action.C and state.current_stock > self.game_description.capacity * self.HIGH_STOCK_FOR_WARNING_RATIO:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_476(BaseStrategy):
    """
    Adaptive Reciprocity with Resource Safeguard (ARRS) strategy.
    Prioritizes resource preservation, establishes cooperation,
    employs forgiving reciprocity, and defects in the end-game.

    This strategy aims to foster cooperation and sustain the common resource
    while protecting itself from excessive exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD_FACTOR = 0.2
        self.CRITICAL_STOCK_THRESHOLD = self.capacity * self.CRITICAL_STOCK_THRESHOLD_FACTOR
        if self.n_players == 2:
            self.MINOR_DEFECTION_FORGIVENESS_THRESHOLD = 0
        else:
            self.MINOR_DEFECTION_FORGIVENESS_THRESHOLD = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.n_rounds
        if current_round == 0:
            return Action.C
        if current_round == total_rounds - 1:
            return Action.D
        if state.current_stock <= self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        num_opponents = self.n_players - 1
        num_cooperating_opponents_prev_round = sum(history.opponent_actions[-1, :])
        num_defecting_opponents_prev_round = num_opponents - num_cooperating_opponents_prev_round
        if num_defecting_opponents_prev_round <= self.MINOR_DEFECTION_FORGIVENESS_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_477(BaseStrategy):
    """
    Adaptive Sustainability Enforcer (ASE) strategy for the Common Pool Resource Game.
    This strategy promotes cooperation and resource sustainability while being robust
    against exploitation. It dynamically adjusts its behavior based on the current
    stock level and the observed actions of other players in previous rounds,
    employing emergency cooperation for low stock, punishment for defection,
    and a rational endgame defection.
    """
    _CRITICAL_STOCK_THRESHOLD_FACTOR = 0.3
    _PUNISHMENT_DEFECTION_THRESHOLD_FACTOR = 0.25
    _FORGIVENESS_COOPERATION_STREAK_REQUIRED = 2
    _EMERGENCY_LENIENT_DEFECTION_THRESHOLD_FACTOR = 0.05

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD_FACTOR = self._CRITICAL_STOCK_THRESHOLD_FACTOR
        self.PUNISHMENT_DEFECTION_THRESHOLD_FACTOR = self._PUNISHMENT_DEFECTION_THRESHOLD_FACTOR
        self.FORGIVENESS_COOPERATION_STREAK_REQUIRED = self._FORGIVENESS_COOPERATION_STREAK_REQUIRED
        self.EMERGENCY_LENIENT_DEFECTION_THRESHOLD_FACTOR = self._EMERGENCY_LENIENT_DEFECTION_THRESHOLD_FACTOR
        self._punishment_mode: bool = False
        self._cooperation_streak: int = 0
        self._significant_cooperation_streak: int = 0
        self._defection_streak: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self._punishment_mode = False
            self._cooperation_streak = 0
            self._significant_cooperation_streak = 0
            self._defection_streak = 0
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        critical_stock_threshold = self.CRITICAL_STOCK_THRESHOLD_FACTOR * self.game_description.capacity
        punishment_defection_threshold = max(1, round(self.game_description.n_players * self.PUNISHMENT_DEFECTION_THRESHOLD_FACTOR))
        emergency_lenient_defection_threshold = max(0, round(self.game_description.n_players * self.EMERGENCY_LENIENT_DEFECTION_THRESHOLD_FACTOR))
        previous_round_idx = state.round_number - 1
        previous_my_action_was_D = not history.my_actions[previous_round_idx]
        num_opponent_defectors_previous_round = np.sum(~history.opponent_actions[previous_round_idx, :])
        num_defectors_previous_round = num_opponent_defectors_previous_round + (1 if previous_my_action_was_D else 0)
        if num_defectors_previous_round == 0:
            self._cooperation_streak += 1
            self._significant_cooperation_streak += 1
            self._defection_streak = 0
        elif num_defectors_previous_round <= emergency_lenient_defection_threshold:
            self._cooperation_streak = 0
            self._significant_cooperation_streak += 1
            self._defection_streak = 0
        else:
            self._cooperation_streak = 0
            self._significant_cooperation_streak = 0
            self._defection_streak += 1
        if state.current_stock < critical_stock_threshold:
            if self._significant_cooperation_streak >= 1 or num_defectors_previous_round <= emergency_lenient_defection_threshold:
                self._punishment_mode = False
                return Action.C
            else:
                return Action.D
        if self._punishment_mode:
            if self._cooperation_streak >= self.FORGIVENESS_COOPERATION_STREAK_REQUIRED:
                self._punishment_mode = False
                return Action.C
            else:
                return Action.D
        if num_defectors_previous_round >= punishment_defection_threshold:
            self._punishment_mode = True
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_478(BaseStrategy):
    """
    Adaptive Cooperative Reciprocity (ACR) strategy for the Common Pool Resource Game.

    This strategy aims to promote long-term resource sustainability through conditional
    cooperation, proportional punishment for widespread defection, and forgiveness.
    Its decisions are heavily influenced by the current stock level of the common pool.
    It acknowledges the end-game effect by defecting in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = game_description.n_players
        capacity = game_description.capacity
        self._capacity_threshold_healthy = 0.8 * capacity
        self._capacity_threshold_warning = 0.4 * capacity
        self._cooperation_threshold_count = math.ceil(0.5 * n)
        self._punishment_duration = 2
        self._my_punishment_active: bool = False
        self._my_punishment_rounds_left: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if current_round == 0:
            self._my_punishment_active = False
            self._my_punishment_rounds_left = 0
            return Action.C
        if current_round == r - 1:
            return Action.D
        num_cooperators_prev_round = sum(history.opponent_actions[current_round - 1, :])
        if history.my_actions[current_round - 1] == Action.C:
            num_cooperators_prev_round += 1
        if self._my_punishment_active:
            self._my_punishment_rounds_left -= 1
            if self._my_punishment_rounds_left > 0:
                return Action.D
            else:
                self._my_punishment_active = False
        if current_stock >= self._capacity_threshold_healthy:
            if num_cooperators_prev_round >= self._cooperation_threshold_count:
                return Action.C
            else:
                self._my_punishment_active = True
                self._my_punishment_rounds_left = self._punishment_duration
                return Action.D
        elif current_stock >= self._capacity_threshold_warning:
            if num_cooperators_prev_round >= self._cooperation_threshold_count:
                return Action.C
            else:
                self._my_punishment_active = True
                self._my_punishment_rounds_left = self._punishment_duration
                return Action.D
        elif num_cooperators_prev_round >= self._cooperation_threshold_count:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_479(BaseStrategy):
    """
    Common Pool Guardian strategy balances cooperation, deterrence, and resource preservation.
    It prioritizes the health of the common stock and responds adaptively to the collective
    behavior of other players, rather than just individual reciprocity.

    Core Principles:
    1.  Start Cooperative: Always begin by cooperating to signal a willingness to establish
        and maintain a sustainable resource.
    2.  Resource Prioritization: The health and sustainability of the common stock are paramount.
        Decisions are heavily influenced by the current stock level.
    3.  Adaptive Reciprocity: Reward collective cooperation and punish significant collective defection.
        This is not purely tit-for-tat; it's about reacting to the group's impact on the resource.
    4.  Resilience to Exploitation: While promoting cooperation, the strategy must be robust
        against players who consistently defect. Defensive defection is employed when collective
        cooperation breaks down, especially under threat of stock depletion.
    5.  Endgame Rationality: Recognize the shift in incentives in the final round, where future
        stock considerations become irrelevant.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.STOCK_CRITICAL_THRESHOLD = self.capacity / (2 * self.n_players)
        self.STOCK_LOW_THRESHOLD = self.capacity * 0.25
        self.STOCK_MODERATE_THRESHOLD = self.capacity * 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == 0:
            return Action.C
        if current_round_number == self.total_rounds - 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[current_round_number - 1, :]
        num_cooperators_among_opponents_last_round = np.sum(previous_round_opponent_actions)
        num_defectors_among_opponents_last_round = self.n_players - 1 - num_cooperators_among_opponents_last_round
        if current_stock <= self.STOCK_CRITICAL_THRESHOLD:
            return Action.C
        elif current_stock <= self.STOCK_LOW_THRESHOLD:
            if num_defectors_among_opponents_last_round > 0:
                return Action.D
            else:
                return Action.C
        elif num_defectors_among_opponents_last_round == 0:
            return Action.C
        elif num_defectors_among_opponents_last_round <= 1:
            return Action.C
        elif num_defectors_among_opponents_last_round < self.n_players / 2:
            if current_stock >= self.STOCK_MODERATE_THRESHOLD:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_480(BaseStrategy):
    """
    The Adaptive Resource Guardian (ARG) strategy for the Common Pool Resource Game.
    It aims for sustainable outcomes through conditional cooperation, balancing
    individual self-interest with the long-term health of the shared resource.
    The strategy is adaptive, responding to both the observed behavior of other players
    and the current state of the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_critical = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.C
        elif current_round_1_indexed == self.n_rounds:
            return Action.D
        else:
            k_previous = np.sum(~history.opponent_actions[-1, :])
            if state.current_stock < self.S_critical:
                if k_previous > 0:
                    return Action.D
                else:
                    return Action.C
            elif self.n_players == 2 and k_previous >= 1 or (self.n_players > 2 and k_previous >= 2):
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_481(BaseStrategy):
    """
    Adaptive Collective Preservation (ACP) strategy for the Common Pool Resource Game.
    This strategy prioritizes long-term resource sustainability while adapting to opponent
    behaviors and protecting against exploitation. It starts cooperatively, preserves
    resources at critical levels, conditionally reciprocates cooperation, and acts
    self-interestedly in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_ratio = 0.25
        self.cooperation_threshold_ratio = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == total_rounds:
            return Action.D
        num_cooperated_prev_round = sum(history.opponent_actions[-1, :])
        is_stock_critically_low = current_stock < capacity * self.critical_stock_ratio
        if is_stock_critically_low:
            return Action.C
        else:
            min_cooperators_required = math.ceil(n_players * self.cooperation_threshold_ratio)
            if num_cooperated_prev_round >= min_cooperators_required:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_482(BaseStrategy):
    """
    The Adaptive Conservator strategy for the Common Pool Resource Game.

    This strategy aims for long-term resource sustainability and collective welfare.
    It prioritizes cooperation and resource recovery but reacts to widespread defection
    to avoid exploitation. Decisions are dynamic, adjusting based on current stock
    level and observed actions from the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.s_critical = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        num_opponent_defectors_last_round = np.sum(history.opponent_actions[-1, :] == False)
        my_action_last_round_was_defect = history.my_actions[-1] == False
        num_defectors_last_round = num_opponent_defectors_last_round + (1 if my_action_last_round_was_defect else 0)
        if current_stock < self.s_critical:
            if num_defectors_last_round > self.n_players / 2.0:
                return Action.D
            else:
                return Action.C
        elif num_defectors_last_round == 0:
            return Action.C
        elif num_defectors_last_round <= 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_483(BaseStrategy):
    """
    The "Adaptive Conservationist" strategy prioritizes the long-term health of the common resource
    while being robust to exploitative behavior from other players in a tournament setting.
    It aims to establish and maintain a cooperative equilibrium, which is collectively optimal
    for resource sustainability and overall payoff accumulation.

    The strategy's decision-making is based on the current state of the resource (stock level)
    and the observed actions of other players in the previous round. It features initial
    cooperation, sustainability focus, adaptive forgiveness for minor defections, conditional
    resource recovery, robust punishment for significant defection, and self-preservation in the end-game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.forgiveness_threshold = math.floor((self.n_players - 1) / 3)
        self.critical_stock_ratio = 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.total_rounds - 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        num_other_defectors = np.sum(~previous_round_opponent_actions)
        num_other_cooperators = np.sum(previous_round_opponent_actions)
        is_stock_critical = state.current_stock / self.capacity < self.critical_stock_ratio
        if is_stock_critical:
            if num_other_cooperators > num_other_defectors:
                return Action.C
            else:
                return Action.D
        elif num_other_defectors > self.forgiveness_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_484(BaseStrategy):
    """
    Adaptive Stock-Aware Tit-for-Tat (ASATfT) strategy for the Common Pool Resource Game.

    ASATfT aims for sustainable resource management by promoting cooperation and
    protecting the common resource. It adapts its behavior based on the health
    of the common stock and the observed actions of other players. A key feature
    is its willingness to sacrifice immediate gain to prevent resource collapse,
    embodying a strong collective spirit when the resource is most vulnerable.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.STOCK_UPPER_THRESHOLD_FACTOR = 0.75
        self.STOCK_LOWER_THRESHOLD_FACTOR = 0.25
        self.DEFECTION_PROPORTION_TOLERANCE_HEALTHY = 0.15
        self.DEFECTION_PROPORTION_TOLERANCE_WARNING = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == n_rounds:
            return Action.D
        num_defectors_others_prev = np.sum(~history.opponent_actions[-1, :])
        proportion_defectors_others_prev = num_defectors_others_prev / float(n_players - 1)
        stock_upper_limit = capacity * self.STOCK_UPPER_THRESHOLD_FACTOR
        stock_lower_limit = capacity * self.STOCK_LOWER_THRESHOLD_FACTOR
        is_stock_healthy = current_stock >= stock_upper_limit
        is_stock_warning = current_stock < stock_upper_limit and current_stock >= stock_lower_limit
        is_stock_critical = current_stock < stock_lower_limit
        if is_stock_critical:
            return Action.C
        elif is_stock_healthy:
            if proportion_defectors_others_prev <= self.DEFECTION_PROPORTION_TOLERANCE_HEALTHY:
                return Action.C
            else:
                return Action.D
        elif is_stock_warning:
            if proportion_defectors_others_prev <= self.DEFECTION_PROPORTION_TOLERANCE_WARNING:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_485(BaseStrategy):
    """
    The "Adaptive Resource Guardian" strategy promotes collective sustainability
    by prioritizing resource health, conditionally cooperating based on others'
    actions, and defecting in the final round. It tolerates minor defections
    but retaliates against significant exploitation, especially when the resource is stressed.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        STOCK_CRITICAL_THRESHOLD_FACTOR = 0.25
        STOCK_WARNING_THRESHOLD_FACTOR = 0.5
        MAX_TOLERABLE_OTHER_DEFECTORS_PERCENT = 0.25
        self.STOCK_CRITICAL_THRESHOLD = self.game_description.capacity * STOCK_CRITICAL_THRESHOLD_FACTOR
        self.STOCK_WARNING_THRESHOLD = self.game_description.capacity * STOCK_WARNING_THRESHOLD_FACTOR
        n_players = self.game_description.n_players
        num_other_players = n_players - 1
        max_tolerable_other_defectors_raw = num_other_players * MAX_TOLERABLE_OTHER_DEFECTORS_PERCENT
        self.max_tolerable_other_defectors = round(max_tolerable_other_defectors_raw)
        if num_other_players > 0 and self.max_tolerable_other_defectors < 1:
            self.max_tolerable_other_defectors = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == total_rounds:
            return Action.D
        prev_round_idx = state.round_number - 1
        num_other_defectors_prev_round = np.sum(history.opponent_actions[prev_round_idx, :] == False)
        if state.current_stock <= self.STOCK_CRITICAL_THRESHOLD:
            return Action.C
        elif state.current_stock <= self.STOCK_WARNING_THRESHOLD:
            if num_other_defectors_prev_round > self.max_tolerable_other_defectors:
                return Action.D
            else:
                return Action.C
        elif num_other_defectors_prev_round <= self.max_tolerable_other_defectors:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_486(BaseStrategy):
    """
    The Adaptive Steward strategy for the Common Pool Resource Game.
    This strategy prioritizes resource preservation, adapts to opponent
    defection levels, and exploits the final round for maximum individual gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold = self.game_description.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n = self.game_description.n_players
        if round_num == 0:
            return Action.C
        if round_num == total_rounds - 1:
            return Action.D
        elif current_stock < self.critical_stock_threshold:
            return Action.C
        else:
            previous_round_opponent_actions = history.opponent_actions[round_num - 1, :]
            d_count = np.sum(~previous_round_opponent_actions)
            if d_count == 0:
                return Action.C
            elif d_count > (n - 1) / 2:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_487(BaseStrategy):
    """
    The "Adaptive Collective Sustainer (ACS)" strategy aims to establish and maintain a high level of cooperation
    to ensure the long-term sustainability of the common pool resource, while being robust and adaptive to varying
    behaviors from other players. It operates on the principle of conditional cooperation, combined with a mechanism
    for deterrence when cooperation falters, and a strong priority for resource conservation when the stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._cooperation_tolerance_level: int = 1
        self._deterrence_duration: int = 1
        self._critical_stock_ratio: float = 1.0 / self.game_description.n_players
        self._my_deterrence_rounds_remaining: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num_1_indexed = state.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_round_num_1_indexed == r:
            self._my_deterrence_rounds_remaining = 0
            return Action.D
        if current_stock <= capacity * self._critical_stock_ratio:
            self._my_deterrence_rounds_remaining = 0
            return Action.C
        if current_round_num_1_indexed == 1:
            self._my_deterrence_rounds_remaining = 0
            return Action.C
        if self._my_deterrence_rounds_remaining > 0:
            self._my_deterrence_rounds_remaining -= 1
            return Action.D
        num_cooperators_previous_round = np.sum(history.opponent_actions[-1, :])
        if num_cooperators_previous_round < n - self._cooperation_tolerance_level:
            self._my_deterrence_rounds_remaining = self._deterrence_duration - 1
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_488(BaseStrategy):
    """
    Adaptive Stock-Aware Reciprocity (ASAR) strategy.

    This strategy aims to balance resource sustainability with adaptive
    responsiveness to opponent behavior in the Common Pool Resource Game.
    It prioritizes the long-term health of the common resource, employing
    conditional cooperation and punishment to encourage overall cooperative
    play, while making rational decisions in specific game-theoretic contexts
    (like the final round).

    Core Principles:
    1. Resource Priority: Unconditional cooperation if stock is critically low.
    2. Conditional Cooperation: Cooperates if opponents cooperate, or for minor defections.
    3. Proportional Punishment: Punishes widespread defection.
    4. Rational End-Game Play: Defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = 0.25 * self.capacity
        self.PUNISHMENT_THRESHOLD = round(0.5 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.C
        num_opponent_cooperators_prev_round = sum(history.opponent_actions[-1, :])
        num_opponents = self.n_players - 1
        k_D_prev = num_opponents - num_opponent_cooperators_prev_round
        if current_stock <= self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        elif k_D_prev == 0:
            return Action.C
        elif k_D_prev >= self.PUNISHMENT_THRESHOLD:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_489(BaseStrategy):
    """
    Adaptive Collective Steward Strategy: Promotes collective sustainability through conditional cooperation,
    prioritizes resource recovery at critical stock levels, and adapts punishment/forgiveness based on group behavior.
    """

    class Stance(Enum):
        COOPERATE_STANCE = 1
        PUNISH_STANCE = 0

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.my_stance = self.Stance.COOPERATE_STANCE

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == self.r - 1:
            return Action.D
        if current_round_number == 0:
            self.my_stance = self.Stance.COOPERATE_STANCE
            return Action.C
        S_critical = self.capacity / 4.0
        tolerated_defectors: int
        if self.n == 2:
            tolerated_defectors = 0
        else:
            tolerated_defectors = 1
        if current_stock < S_critical:
            self.my_stance = self.Stance.COOPERATE_STANCE
            return Action.C
        total_cooperators_prev_round = int(history.my_actions[-1]) + np.sum(history.opponent_actions[-1, :])
        chosen_action: Action
        if self.my_stance == self.Stance.COOPERATE_STANCE:
            if total_cooperators_prev_round >= self.n - tolerated_defectors:
                chosen_action = Action.C
            else:
                self.my_stance = self.Stance.PUNISH_STANCE
                chosen_action = Action.D
        elif total_cooperators_prev_round == self.n:
            self.my_stance = self.Stance.COOPERATE_STANCE
            chosen_action = Action.C
        else:
            chosen_action = Action.D
        return chosen_action

class Strategy_COLLECTIVE_490(BaseStrategy):
    """
    Adaptive Collective Conservationist (ACC) strategy for the Common Pool Resource Game.
    This strategy is designed to balance individual gain with resource sustainability,
    adapting to opponent behavior and critical stock levels. It prioritizes
    resource health, starts cooperatively, employs reciprocal punishment for
    defection, offers forgiveness, and acts selfishly in the final round.
    """

    class PlayerMode(Enum):
        """
        Internal states for the ACC strategy, defining its current behavioral stance.
        """
        COOPERATING = 0
        PUNISHING = 1
        FORGIVING = 2

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.STOCK_CRITICAL_LEVEL_RATIO: float = 0.5
        self.DEFECTION_TOLERANCE_COUNT: int = 1
        self.PUNISHMENT_DURATION: int = 2
        self.FORGIVENESS_DURATION: int = 1
        self.current_player_mode: self.PlayerMode = self.PlayerMode.COOPERATING
        self.mode_countdown: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.game_description.n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            self.current_player_mode = self.PlayerMode.COOPERATING
            self.mode_countdown = 0
            return Action.C
        num_cooperating_opponents_in_prev_round = sum(history.opponent_actions[-1, :])
        num_defectors_in_prev_round = self.game_description.n_players - 1 - num_cooperating_opponents_in_prev_round
        stock_critical_threshold = self.game_description.capacity * self.STOCK_CRITICAL_LEVEL_RATIO
        if state.current_stock < stock_critical_threshold:
            self.current_player_mode = self.PlayerMode.COOPERATING
            self.mode_countdown = 0
            return Action.C
        if self.current_player_mode == self.PlayerMode.PUNISHING:
            if self.mode_countdown > 0:
                self.mode_countdown -= 1
                return Action.D
            else:
                self.current_player_mode = self.PlayerMode.FORGIVING
                self.mode_countdown = self.FORGIVENESS_DURATION
                return Action.C
        elif self.current_player_mode == self.PlayerMode.FORGIVING:
            if self.mode_countdown > 0:
                self.mode_countdown -= 1
                return Action.C
            else:
                self.current_player_mode = self.PlayerMode.COOPERATING
                self.mode_countdown = 0
        if self.current_player_mode == self.PlayerMode.COOPERATING:
            if num_defectors_in_prev_round > self.DEFECTION_TOLERANCE_COUNT:
                self.current_player_mode = self.PlayerMode.PUNISHING
                self.mode_countdown = self.PUNISHMENT_DURATION - 1
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_491(BaseStrategy):
    """
    The Adaptive Reciprocal Harvester (ARH) strategy is a collective-minded approach that balances
    individual short-term gains with the long-term sustainability of the common resource. It employs
    a dynamic decision-making process that adapts based on the current health of the common stock
    and the observed behavior of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.STOCK_CRITICAL_THRESHOLD_FACTOR = 0.1
        self.STOCK_WARNING_THRESHOLD_FACTOR = 0.5
        self.COOPERATION_TOLERANCE_HEALTHY_STOCK_DEFAULT = 1
        self.COOPERATION_TOLERANCE_WARNING_STOCK = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number + 1
        current_stock = state.current_stock
        critical_stock_level = self.capacity * self.STOCK_CRITICAL_THRESHOLD_FACTOR
        warning_stock_level = self.capacity * self.STOCK_WARNING_THRESHOLD_FACTOR
        actual_cooperation_tolerance_healthy_stock = self.COOPERATION_TOLERANCE_HEALTHY_STOCK_DEFAULT
        if self.n_players == 2:
            actual_cooperation_tolerance_healthy_stock = 0
        if current_round == self.total_rounds:
            return Action.D
        if current_round == 1:
            return Action.C
        previous_opponent_actions = history.opponent_actions[-1, :]
        defectors_count = np.sum(~previous_opponent_actions)
        if current_stock < critical_stock_level:
            return Action.C
        elif current_stock < warning_stock_level:
            if defectors_count <= self.COOPERATION_TOLERANCE_WARNING_STOCK:
                return Action.C
            else:
                return Action.D
        elif defectors_count <= actual_cooperation_tolerance_healthy_stock:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_492(BaseStrategy):
    """
    Adaptive Collective Resource Management (ACRM) strategy for the Common Pool Resource Game.
    This strategy aims to promote long-term sustainability of the shared resource while being
    robust to various opponent behaviors. It combines initial cooperation with adaptive
    punishment and forgiveness mechanisms, guided by observed collective behavior and the
    current state of the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.my_current_stance = 'Cooperate'
        self.consecutive_cooperation_rounds = 0
        self.DEFECTION_THRESHOLD = 0.75
        self.FORGIVENESS_THRESHOLD = 0.75
        self.COOPERATION_ROUNDS_NEEDED = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num_1_indexed = state.round_number + 1
        if state.round_number == 0:
            self.my_current_stance = 'Cooperate'
            self.consecutive_cooperation_rounds = 0
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        STOCK_RECOVERY_THRESHOLD = self.game_description.capacity / 2
        if state.current_stock < STOCK_RECOVERY_THRESHOLD:
            return Action.C
        prev_round_opponent_actions = history.opponent_actions[state.round_number - 1]
        c_count_prev_round = np.sum(prev_round_opponent_actions)
        n_players = self.game_description.n_players
        cooperation_score = c_count_prev_round / n_players
        if self.my_current_stance == 'Cooperate':
            if cooperation_score < self.DEFECTION_THRESHOLD:
                self.my_current_stance = 'Defect'
                self.consecutive_cooperation_rounds = 0
                return Action.D
            else:
                return Action.C
        elif self.my_current_stance == 'Defect':
            if cooperation_score >= self.FORGIVENESS_THRESHOLD:
                self.consecutive_cooperation_rounds += 1
                if self.consecutive_cooperation_rounds >= self.COOPERATION_ROUNDS_NEEDED:
                    self.my_current_stance = 'Cooperate'
                    self.consecutive_cooperation_rounds = 0
                    return Action.C
                else:
                    return Action.D
            else:
                self.consecutive_cooperation_rounds = 0
                return Action.D

class Strategy_COLLECTIVE_493(BaseStrategy):
    """
    Adaptive Conservationist (AC) strategy for the Common Pool Resource game.

    This strategy aims to promote collective resource sustainability by starting cooperatively,
    monitoring opponent behavior, and adapting its actions. It responds to significant defection
    to prevent exploitation and protects individual payoff when the resource is critical
    or the game is nearing its end.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.k_defect_tolerance = max(1, math.floor(n / 4))
        self.stock_critical_threshold = 0.2 * capacity
        self.endgame_horizon = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        COOPERATE = Action.C
        DEFECT = Action.D
        if current_round_0_indexed == 0:
            return COOPERATE
        if current_round_0_indexed >= total_rounds - self.endgame_horizon:
            return DEFECT
        if current_stock < self.stock_critical_threshold:
            return DEFECT
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        num_cooperators_prev_round = sum(previous_round_opponent_actions)
        k_D_prev = n_players - num_cooperators_prev_round
        if k_D_prev <= self.k_defect_tolerance:
            return COOPERATE
        else:
            return DEFECT

class Strategy_COLLECTIVE_494(BaseStrategy):
    """
    Adaptive Sustainable Sentinel (ASS) strategy for the Common Pool Resource Game.
    Aims to maintain the common resource for long-term collective benefit by initiating
    cooperation and rewarding sustainable behavior. It adaptively monitors the resource's health
    and the collective actions of other players, retaliating against significant defection or
    resource decline to prevent exploitation and catastrophic collapse. Defaults to cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_at_start_of_round_history: list[float] = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_idx = state.round_number
        S_t = state.current_stock
        if len(self.stock_at_start_of_round_history) == current_round_idx:
            self.stock_at_start_of_round_history.append(S_t)
        if current_round_idx == 0:
            return Action.C
        if current_round_idx == self.r - 1:
            return Action.D
        S_t_minus_1 = self.stock_at_start_of_round_history[current_round_idx - 1]
        num_D_prev = 0
        if not history.my_actions[current_round_idx - 1]:
            num_D_prev += 1
        num_D_prev += np.sum(history.opponent_actions[current_round_idx - 1, :] == False)
        CRITICAL_LOW_STOCK_THRESHOLD_1 = self.capacity / (2.0 * self.n)
        CRITICAL_LOW_STOCK_THRESHOLD_2 = self.capacity / 4.0
        NUM_DEFECTIONS_HIGH = self.n - 1
        NUM_DEFECTIONS_MODERATE = math.floor(self.n / 2)
        if S_t <= CRITICAL_LOW_STOCK_THRESHOLD_1 or (S_t < S_t_minus_1 and S_t <= CRITICAL_LOW_STOCK_THRESHOLD_2) or num_D_prev >= NUM_DEFECTIONS_HIGH:
            return Action.D
        if S_t >= self.capacity or (S_t >= S_t_minus_1 and num_D_prev == 0):
            return Action.C
        if S_t < S_t_minus_1 or num_D_prev >= NUM_DEFECTIONS_MODERATE:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_495(BaseStrategy):
    """
    Adaptive Collective Sustainer (ACS) Strategy:
    Aims for long-term collective benefits by promoting sustainable resource management
    while remaining robust against exploitation in a competitive tournament setting.
    It balances initial trust with reciprocal enforcement and prioritizes resource
    preservation when the common pool is under stress.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold = self.game_description.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == total_rounds - 1:
            return Action.D
        prev_round_idx = current_round - 1
        num_opponent_defectors = np.sum(~history.opponent_actions[prev_round_idx, :])
        my_prev_action_was_D = not history.my_actions[prev_round_idx]
        total_prev_defections = num_opponent_defectors + (1 if my_prev_action_was_D else 0)
        if current_stock <= self.critical_stock_threshold:
            if total_prev_defections == 0:
                return Action.C
            else:
                return Action.D
        elif total_prev_defections == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_497(BaseStrategy):
    """
    The Adaptive Steward strategy aims for long-term sustainability of the common resource
    by balancing cooperation, punishment, and resource preservation. It starts cooperatively,
    punishes significant defections, but also offers forgiveness. Behavior adapts based on
    the current stock level, becoming more aggressive in defending the resource when it's
    depleted. In the final round, it acts pragmatically to avoid exploitation, unless
    the resource is critically low.
    """
    COOPERATE_BELOW_DEFECTION_RATE = 0.25
    PUNISH_ABOVE_DEFECTION_RATE = 0.5
    PUNISHMENT_DURATION = 1

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.total_rounds = game_description.n_rounds
        self._rounds_to_punish_remaining = 0
        self.CRITICAL_STOCK_RECOVERY_THRESHOLD = self.capacity / self.n
        self.STOCK_WARNING_THRESHOLD = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            self._rounds_to_punish_remaining = 0
            return Action.C
        if self._rounds_to_punish_remaining > 0:
            self._rounds_to_punish_remaining -= 1
            return Action.D
        prev_round_idx = current_round - 1
        my_defection_prev = 1 if not history.my_actions[prev_round_idx] else 0
        opponent_defections_prev = np.sum(~history.opponent_actions[prev_round_idx])
        defection_count_prev = my_defection_prev + opponent_defections_prev
        defection_rate_prev = defection_count_prev / self.n
        if current_stock <= self.CRITICAL_STOCK_RECOVERY_THRESHOLD:
            if defection_count_prev > 0:
                self._rounds_to_punish_remaining = self.PUNISHMENT_DURATION
                return Action.D
            else:
                return Action.C
        elif current_stock <= self.STOCK_WARNING_THRESHOLD:
            if defection_rate_prev <= self.COOPERATE_BELOW_DEFECTION_RATE:
                return Action.C
            else:
                self._rounds_to_punish_remaining = self.PUNISHMENT_DURATION
                return Action.D
        if current_round == self.total_rounds - 1:
            return Action.D
        elif defection_rate_prev <= self.COOPERATE_BELOW_DEFECTION_RATE:
            return Action.C
        elif defection_rate_prev > self.PUNISH_ABOVE_DEFECTION_RATE:
            self._rounds_to_punish_remaining = self.PUNISHMENT_DURATION
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_498(BaseStrategy):
    """
    Adaptive Resource Steward (ARS) strategy for the Common Pool Resource Game.

    This strategy prioritizes long-term sustainability by promoting universal
    cooperation. It initiates with cooperation and monitors aggregate consumption
    to detect defection. If defection is observed, ARS enters a punishment phase
    by defecting itself. The punishment is adaptive: it extends if defection
    persists and allows for recovery by gradually reverting to cooperation if
    others return to cooperative behavior. In the final round, ARS defects
    due to endgame rationality.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self._observed_Nd_last_round: int = 0
        self._is_currently_punishing: bool = False
        self._punishment_rounds_to_serve: int = 0
        self._S_at_start_of_current_round: float = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num = state.round_number + 1
        if current_round_num == self.n_rounds:
            self._S_at_start_of_current_round = state.current_stock
            return Action.D
        if current_round_num == 1:
            self._observed_Nd_last_round = 0
            self._is_currently_punishing = False
            self._punishment_rounds_to_serve = 0
            self._S_at_start_of_current_round = state.current_stock
            return Action.C
        S_prev_round_start_for_Nd_calc = self._S_at_start_of_current_round
        self._S_at_start_of_current_round = state.current_stock
        total_consumption_prev_round = 0.0
        if S_prev_round_start_for_Nd_calc <= 0.001:
            self._observed_Nd_last_round = 0
        else:
            my_prev_action_was_C = history.my_actions[-1]
            my_consumption = S_prev_round_start_for_Nd_calc / (2.0 * self.n_players) if my_prev_action_was_C else S_prev_round_start_for_Nd_calc / self.n_players
            total_opponent_consumption = 0.0
            for op_action_was_C in history.opponent_actions[-1, :]:
                total_opponent_consumption += S_prev_round_start_for_Nd_calc / (2.0 * self.n_players) if op_action_was_C else S_prev_round_start_for_Nd_calc / self.n_players
            total_consumption_prev_round = my_consumption + total_opponent_consumption
            denominator = S_prev_round_start_for_Nd_calc / (2.0 * self.n_players)
            numerator = total_consumption_prev_round - S_prev_round_start_for_Nd_calc / 2.0
            if denominator == 0.0:
                self._observed_Nd_last_round = 0
            else:
                Nd_float = numerator / denominator
                self._observed_Nd_last_round = max(0, min(self.n_players, round(Nd_float)))
        k_D_threshold = 0
        if self._is_currently_punishing:
            if self._observed_Nd_last_round <= k_D_threshold:
                self._punishment_rounds_to_serve -= 1
                if self._punishment_rounds_to_serve <= 0:
                    self._is_currently_punishing = False
                    self._punishment_rounds_to_serve = 0
            else:
                self._punishment_rounds_to_serve = 2
        elif self._observed_Nd_last_round > k_D_threshold:
            self._is_currently_punishing = True
            self._punishment_rounds_to_serve = 2
        if self._is_currently_punishing and self._punishment_rounds_to_serve > 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_499(BaseStrategy):
    """
    The Adaptive Collective Resource Manager (ACRM) strategy for the Common Pool Resource Game.
    It initiates cooperation, monitors opponent actions, and adapts behavior based on
    resource stock levels and the degree of cooperation observed in previous rounds.
    It prioritizes resource recovery in emergency situations, tolerates minor defections,
    but punishes widespread non-cooperation. It also defects in the final round to
    avoid being exploited due to end-game effects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.s_emergency_threshold = self.game_description.capacity / 4.0
        self.d_tolerance = max(1, math.floor(self.game_description.n_players / 10.0))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_round == 0:
            return Action.C
        if current_round == total_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        num_defectors_last_round = np.sum(~previous_round_opponent_actions)
        if current_stock < self.s_emergency_threshold:
            return Action.C
        elif num_defectors_last_round <= self.d_tolerance:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_500(BaseStrategy):
    """
    Adaptive Stock-Aware Reciprocity strategy for the Common Pool Resource Game.
    This strategy is based on conditional cooperation, adapting its tolerance for
    defection based on the current resource stock level. It starts cooperatively,
    monitors opponents, and responds to defection with increasing strictness as
    the common pool resource diminishes. It also accounts for the finite horizon
    of the game, defecting in the last round to maximize immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n_players = game_description.n_players
        capacity = game_description.capacity
        self.STOCK_HIGH_THRESHOLD = 0.8 * capacity
        self.STOCK_MEDIUM_THRESHOLD = 0.4 * capacity
        self.STOCK_LOW_THRESHOLD = 0.1 * capacity
        num_other_players = n_players - 1
        if num_other_players < 1:
            self.K_TOLERANCE_HIGH_STOCK = 0
            self.K_TOLERANCE_MEDIUM_STOCK = 0
            self.K_TOLERANCE_LOW_STOCK = 0
        else:
            self.K_TOLERANCE_HIGH_STOCK = math.floor(num_other_players * 0.25)
            self.K_TOLERANCE_MEDIUM_STOCK = math.floor(num_other_players * 0.15)
            self.K_TOLERANCE_LOW_STOCK = math.floor(num_other_players * 0.1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        if current_round_1_indexed == total_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        num_cooperators_prev_round = np.sum(history.opponent_actions[-1, :])
        num_defectors_prev_round = n_players - 1 - num_cooperators_prev_round
        k_current_tolerance = self.K_TOLERANCE_HIGH_STOCK
        if current_stock < self.STOCK_HIGH_THRESHOLD:
            k_current_tolerance = self.K_TOLERANCE_MEDIUM_STOCK
        if current_stock < self.STOCK_MEDIUM_THRESHOLD:
            k_current_tolerance = self.K_TOLERANCE_LOW_STOCK
        if current_stock <= self.STOCK_LOW_THRESHOLD:
            if num_defectors_prev_round == 0:
                return Action.C
            else:
                return Action.D
        if num_defectors_prev_round > k_current_tolerance:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_501(BaseStrategy):
    """
    Adaptive Stock-Conditional Reciprocity (ASCR) strategy for the Common Pool Resource Game.
    This strategy prioritizes long-term resource sustainability, exhibiting initial cooperation,
    forgiveness for minor deviations, and temporary retaliation against persistent defection.
    It overrides all other logic to prioritize resource recovery when stock levels are critical.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.epsilon_healthy_stock = 0.05
        self.epsilon_deviation = 0.01
        self.critical_stock_ratio = 0.25
        self.forgiveness_rounds_limit = 2
        self.retaliation_duration = 1
        self.observed_defection_streak = 0
        self.is_in_retaliation_mode = False
        self.retaliation_rounds_counter = 0
        self.history_of_stocks_start_of_round: list[float] = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.history_of_stocks_start_of_round.append(state.current_stock)
        if state.round_number > 0:
            S_prev_round_start = self.history_of_stocks_start_of_round[state.round_number - 1]
            my_action_prev_round_is_C = history.my_actions[state.round_number - 1]
            consumption_if_all_C_prev = S_prev_round_start / 2.0
            S_after_consumption_if_all_C_prev = S_prev_round_start - consumption_if_all_C_prev
            S_after_consumption_if_all_C_prev = max(0.0, S_after_consumption_if_all_C_prev)
            growth_if_all_C_prev = 2.0 * S_after_consumption_if_all_C_prev * (1.0 - S_after_consumption_if_all_C_prev / self.capacity)
            expected_stock_current_round_if_all_C = min(S_after_consumption_if_all_C_prev + growth_if_all_C_prev, self.capacity)
            deviation = expected_stock_current_round_if_all_C - state.current_stock
            deviation_significant = deviation / self.capacity > self.epsilon_deviation
            if my_action_prev_round_is_C is True and deviation_significant:
                self.observed_defection_streak += 1
            else:
                self.observed_defection_streak = 0
            if self.is_in_retaliation_mode:
                self.retaliation_rounds_counter += 1
                if self.retaliation_rounds_counter >= self.retaliation_duration:
                    self.is_in_retaliation_mode = False
                    self.retaliation_rounds_counter = 0
            elif self.observed_defection_streak >= self.forgiveness_rounds_limit:
                self.is_in_retaliation_mode = True
                self.retaliation_rounds_counter = 0
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock < self.capacity * self.critical_stock_ratio:
            self.is_in_retaliation_mode = False
            self.observed_defection_streak = 0
            return Action.C
        if self.is_in_retaliation_mode:
            return Action.D
        if state.current_stock >= self.capacity * (1.0 - self.epsilon_healthy_stock):
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_502(BaseStrategy):
    """
    The Adaptive Sustainability Guard (ASG) strategy balances resource sustainability
    with individual robustness and adaptation. It prioritizes cooperation initially,
    enforces collective conservation when stock is critically low, practices
    reciprocity based on observed opponent defection, and defects in the final round
    for self-interest in a finite game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_threshold = self.game_description.capacity / 4
        self.ODR_punishment_threshold = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == 0:
            return Action.C
        if current_round_number == n_rounds - 1:
            return Action.D
        if current_stock < self.S_threshold:
            return Action.C
        else:
            previous_round_index = current_round_number - 1
            opponent_actions_prev_round = history.opponent_actions[previous_round_index, :]
            num_others_defected = (opponent_actions_prev_round == False).sum()
            num_others = n_players - 1
            ODR = num_others_defected / num_others
            if ODR > self.ODR_punishment_threshold:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_503(BaseStrategy):
    """
    The Adaptive Stock Guardian (ASG) strategy for the Common Pool Resource Game.
    It balances individual rationality with collective resource sustainability,
    adapting to opponent behavior while prioritizing the long-term health of the common pool.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punish_opponent: bool = False
        self.punishment_countdown: int = 0
        self.PUNISHMENT_DURATION: int = 2
        self.CRITICAL_STOCK_THRESHOLD: float = self.game_description.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.current_stock < self.CRITICAL_STOCK_THRESHOLD:
            self.punish_opponent = False
            self.punishment_countdown = 0
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        n_defectors_prev_round = 0
        if state.round_number > 0 and history is not None:
            n_defectors_prev_round = sum((1 for action in history.opponent_actions[-1, :] if not action))
        if self.punish_opponent:
            if n_defectors_prev_round == 0:
                self.punish_opponent = False
                self.punishment_countdown = 0
                return Action.C
            elif self.punishment_countdown < self.PUNISHMENT_DURATION:
                self.punishment_countdown += 1
                return Action.D
            else:
                self.punish_opponent = False
                self.punishment_countdown = 0
                return Action.C
        elif n_defectors_prev_round == 0:
            self.punishment_countdown = 0
            return Action.C
        else:
            self.punish_opponent = True
            self.punishment_countdown = 1
            return Action.D

class Strategy_COLLECTIVE_504(BaseStrategy):
    """
    The "Adaptive Conservationist" strategy balances initial cooperation with adaptive responses
    to opponent behavior and strict resource preservation protocols. It aims to promote
    collective resource sustainability while being robust against exploitation.
    The strategy starts by cooperating, observes other players' actions, and switches
    to defection if widespread defection occurs. Crucially, it prioritizes resource
    survival by unconditionally cooperating if the common pool stock falls to critical levels.
    It is also forgiving, allowing a return to cooperation if opponents demonstrate willingness.
    """
    STOCK_EMERGENCY_THRESHOLD_FACTOR = 0.25
    STOCK_CAUTION_THRESHOLD_FACTOR = 0.5
    DEFECTION_TRIGGER_THRESHOLD = 0.6
    FORGIVENESS_COOPERATION_THRESHOLD = 0.8
    PUNISHMENT_DURATION = 3
    COOPERATION_MEMORY_LENGTH = 3

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history_others_coop_rates: list[float] = []
        self.my_current_stance: str = 'Cooperate'
        self.punishment_rounds_remaining: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if state.round_number == 0:
            self.history_others_coop_rates.clear()
            self.my_current_stance = 'Cooperate'
            self.punishment_rounds_remaining = 0
            return Action.C
        observed_actions_prev_round = history.opponent_actions[-1, :]
        num_others_C_prev_round = np.sum(observed_actions_prev_round)
        num_others_D_prev_round = n_players - 1 - num_others_C_prev_round
        coop_rate_others_prev_round = num_others_C_prev_round / (n_players - 1)
        self.history_others_coop_rates.append(coop_rate_others_prev_round)
        if len(self.history_others_coop_rates) > self.COOPERATION_MEMORY_LENGTH:
            self.history_others_coop_rates.pop(0)
        avg_coop_rate_others_recent = sum(self.history_others_coop_rates) / len(self.history_others_coop_rates)
        if current_stock < self.STOCK_EMERGENCY_THRESHOLD_FACTOR * capacity:
            self.my_current_stance = 'Cooperate'
            self.punishment_rounds_remaining = 0
            return Action.C
        if current_round_1_indexed == total_rounds:
            if avg_coop_rate_others_recent < self.FORGIVENESS_COOPERATION_THRESHOLD:
                return Action.D
            else:
                return Action.C
        if self.my_current_stance == 'Punish' and self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            if coop_rate_others_prev_round >= self.FORGIVENESS_COOPERATION_THRESHOLD:
                self.punishment_rounds_remaining = max(0, self.punishment_rounds_remaining - 1)
            if self.punishment_rounds_remaining > 0:
                return Action.D
            else:
                self.my_current_stance = 'Cooperate'
                return Action.C
        if num_others_D_prev_round / (n_players - 1) >= self.DEFECTION_TRIGGER_THRESHOLD:
            self.my_current_stance = 'Punish'
            self.punishment_rounds_remaining = self.PUNISHMENT_DURATION - 1
            return Action.D
        self.my_current_stance = 'Cooperate'
        if current_stock < self.STOCK_CAUTION_THRESHOLD_FACTOR * capacity:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_505(BaseStrategy):
    """
    Adaptive Collective Reciprocity (ACR) strategy for the Common Pool Resource Game.

    The strategy aims to foster collective cooperation to sustain the common resource
    at a high level. It operates on conditional cooperation: it cooperates as long
    as the resource remains healthy, but defects as a collective punishment and
    self-preservation mechanism if the resource is being over-exploited.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._cooperation_stock_floor_ratio: float = 0.75
        self._defection_cooldown_duration: int = 2
        self._defection_countdown: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self._defection_countdown = 0
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if self._defection_countdown > 0:
            self._defection_countdown -= 1
            return Action.D
        cooperation_floor = self.game_description.capacity * self._cooperation_stock_floor_ratio
        if state.current_stock < cooperation_floor:
            self._defection_countdown = self._defection_cooldown_duration - 1
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_506(BaseStrategy):
    """
    The "Adaptive Conservationist" strategy prioritizes resource sustainability while
    remaining robust against various opponent behaviors. It balances the long-term
    health of the common resource with the need for self-preservation in a competitive
    environment by adapting to current stock levels and observed opponent cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        self.reciprocity_defection_threshold = math.floor((n - 1) / 2)
        self.critical_stock_percentage = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == r - 1:
            return Action.D
        num_opponent_defectors_prev_round = np.sum(~history.opponent_actions[-1, :])
        current_stock_percentage = current_stock / capacity
        if current_stock_percentage <= self.critical_stock_percentage:
            if num_opponent_defectors_prev_round <= self.reciprocity_defection_threshold:
                return Action.C
            else:
                return Action.D
        elif num_opponent_defectors_prev_round <= self.reciprocity_defection_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_507(BaseStrategy):
    """
    The Adaptive Collective Steward strategy balances individual interests with
    long-term resource sustainability. It starts cooperatively, monitors
    resource health, responds adaptively to collective opponent behavior
    (with forgiveness for minor defections, adjusted for the number of players),
    and optimizes for the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_PROPORTION = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == self.r - 1:
            return Action.D
        if current_stock < self.capacity * self.CRITICAL_STOCK_PROPORTION:
            return Action.C
        else:
            if self.n == 2:
                tolerance_limit = 0
            elif self.n <= 4:
                tolerance_limit = 1
            else:
                tolerance_limit = 2
            num_defectors_prev_round = np.sum(~history.opponent_actions[-1, :])
            if num_defectors_prev_round <= tolerance_limit:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_508(BaseStrategy):
    """
    The Adaptive Resource Guardian (ARG) strategy aims to promote cooperation and ensure the long-term sustainability of the common pool resource.
    It employs a conditional cooperation mechanism, adapting its behavior based on the observed actions of other players and the health of the resource stock.
    It is designed to be forgiving of minor exploitations when the resource is robust, but firm in punishing actions that lead to significant resource degradation.
    A critical stock threshold ensures the resource's recovery is prioritized above all else.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._S_crit_low_threshold: float = self.game_description.capacity / 4
        self._S_recovery_threshold: float = self.game_description.capacity / 2
        self._history_stock_levels: list[float] = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self._history_stock_levels.append(state.current_stock)
        t = state.round_number + 1
        current_stock = state.current_stock
        r = self.game_description.n_rounds
        S_crit_low_threshold = self._S_crit_low_threshold
        S_recovery_threshold = self._S_recovery_threshold
        if t == 1:
            return Action.C
        if t == r:
            return Action.D
        S_prev = self._history_stock_levels[t - 2]
        actions_prev_round_others = history.opponent_actions[t - 2, :]
        num_defectors_prev_round = np.sum(~actions_prev_round_others)
        if current_stock < S_crit_low_threshold:
            return Action.C
        elif num_defectors_prev_round == 0:
            return Action.C
        elif current_stock < S_prev or current_stock < S_recovery_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_509(BaseStrategy):
    """
    The Adaptive Collective Sustainer (ACS) strategy prioritizes the long-term
    sustainability of the common resource while being highly responsive to both
    the health of the resource and the collective behavior of other players.
    It aims to foster cooperation by rewarding it and to deter widespread defection
    by retaliating, all while ensuring the resource does not collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_index = state.round_number
        if current_round_index == 0:
            return Action.C
        if current_round_index == n_rounds - 1:
            return Action.D
        if state.current_stock < capacity / 2.0:
            return Action.C
        previous_round_cooperators = np.sum(history.opponent_actions[current_round_index - 1, :]) + history.my_actions[current_round_index - 1]
        previous_cooperation_rate = previous_round_cooperators / float(n_players)
        if previous_cooperation_rate >= (n_players - 1.0) / float(n_players):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_510(BaseStrategy):
    """
    The Adaptive Steward strategy aims for sustainable resource management by adapting its
    behavior based on the common stock level and the observed actions of other players.
    It prioritizes resource recovery when the stock is critically low and employs
    a Tit-for-Tat-like reciprocity when the stock is healthy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Steward strategy with game parameters and internal thresholds.

        Args:
            game_description (CommonPoolDescription): An object containing game parameters
                                                     like n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self._critical_stock_threshold_factor = 0.5
        self._forgiveness_threshold = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round based on
        the game state, history of actions, and internal strategy parameters.

        Args:
            state (CommonPoolState): An object containing the current round number (0-indexed)
                                     and the current stock level.
            history (None | PlayerHistory): An object containing the history of actions and
                                            payoffs for this player and opponents.
                                            Will be None for the very first round.

        Returns:
            Action: The chosen action, either Action.C (Cooperate) or Action.D (Defect).
        """
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        critical_stock_threshold = capacity * self._critical_stock_threshold_factor
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == total_rounds:
            if current_stock < critical_stock_threshold:
                return Action.C
            else:
                return Action.D
        if current_stock < critical_stock_threshold:
            return Action.C
        else:
            previous_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
            num_other_defectors = np.sum(~previous_round_opponent_actions)
            if num_other_defectors == 0:
                return Action.C
            elif num_other_defectors >= self._forgiveness_threshold:
                return Action.D

class Strategy_COLLECTIVE_512(BaseStrategy):
    """
    The Guardian is a collective strategy designed to promote the sustainability of the common pool resource
    while securing favorable individual payoffs in a repeated game. It operates on the principle of
    conditional cooperation, adapting its behavior based on the observed actions of other players
    and the health of the common stock.

    Core Principle: The Guardian's default action is to Cooperate (C) to foster a positive collective
    outcome and maintain the common pool. However, it vigilantly monitors the actions of other players.
    If defection becomes excessive, or if the resource is under stress, The Guardian will switch to
    Defect (D) to punish free-riders, signal the need for more cooperation, or maximize individual gain
    when the collective outcome is no longer salvageable (e.g., in the final round).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_num_0_indexed == 0:
            return Action.C
        if current_round_num_0_indexed == self.n_rounds - 1:
            return Action.D
        num_opponent_defectors_prev = np.sum(~history.opponent_actions[-1, :])
        my_previous_action_was_D = not history.my_actions[-1]
        num_defectors_prev = num_opponent_defectors_prev
        if my_previous_action_was_D:
            num_defectors_prev += 1
        defection_index_prev = num_defectors_prev / self.n_players
        tolerance_level = 0.0
        if current_stock < self.capacity / 4:
            tolerance_level = 0.05
        elif current_stock < self.capacity / 2:
            tolerance_level = 0.1
        elif current_stock < self.capacity:
            tolerance_level = 0.25
        else:
            tolerance_level = 0.35
        if defection_index_prev > tolerance_level:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_1(BaseStrategy):
    """
    Adaptive Free-Rider with Tactical Punishment (AFTP) strategy for the Common Pool Resource Game.
    This strategy aims to maximize individual payoff by defaulting to defection,
    selectively cooperating for self-preservation of the resource, and
    tactically punishing opponents for excessive defection to coerce them into cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n_players = game_description.n_players
        capacity = game_description.capacity
        self.FREE_RIDE_STOCK_THRESHOLD = capacity * 0.75
        self.CONSERVATION_STOCK_THRESHOLD = capacity * 0.25
        self.PUNISHMENT_DEFECTION_RATE_THRESHOLD = 0.5
        self.PUNISHMENT_DURATION = 2
        self._punishment_active = False
        self._punishment_countdown = 0
        self._total_other_players_defections = 0
        self._total_other_players_actions_observed = 0
        self._num_opponents = n_players - 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_idx = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        num_opponents = self._num_opponents
        if history is not None and current_round_idx > 0:
            defections_last_round_by_others = num_opponents - np.sum(history.opponent_actions[-1, :])
            self._total_other_players_defections += defections_last_round_by_others
            self._total_other_players_actions_observed += num_opponents
        avg_other_players_defection_rate = 0.0
        if self._total_other_players_actions_observed > 0:
            avg_other_players_defection_rate = self._total_other_players_defections / self._total_other_players_actions_observed
        if current_round_idx == total_rounds - 1:
            return Action.D
        if self._punishment_active:
            action_to_take = Action.D
            self._punishment_countdown -= 1
            if self._punishment_countdown <= 0:
                self._punishment_active = False
            return action_to_take
        if current_stock <= self.CONSERVATION_STOCK_THRESHOLD:
            self._punishment_active = False
            self._punishment_countdown = 0
            return Action.C
        if current_stock >= self.FREE_RIDE_STOCK_THRESHOLD:
            return Action.D
        if avg_other_players_defection_rate >= self.PUNISHMENT_DEFECTION_RATE_THRESHOLD:
            self._punishment_active = True
            self._punishment_countdown = self.PUNISHMENT_DURATION - 1
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_2(BaseStrategy):
    """
    The Pure Resource Predator strategy aims to maximize individual payoff by defaulting to
    defection (D) in most scenarios. It only cooperates (C) when the common pool resource
    is critically endangered, allowing it to recover for future exploitation. In the final
    round, it always defects, as there are no future consequences to consider.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.low_stock_threshold_ratio: float = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        critical_stock_level = self.game_description.capacity * self.low_stock_threshold_ratio
        if state.current_stock < critical_stock_level:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_3(BaseStrategy):
    """
    Adaptive Exploiter with Resource Preservation strategy.

    This strategy aims to maximize its own total payoff over `r` rounds by exploiting
    the common pool resource. It prioritizes defection for immediate gains but
    intelligently chooses to cooperate under specific conditions:
    1. To preserve the resource when it's critically low and others are attempting to save it,
       ensuring future opportunities for exploitation.
    2. To prevent the resource from degrading too far when it's in a moderate state
       and others are not cooperating sufficiently, again for future viability.
    It cuts its losses and defects when the resource is critically low and
    others are not making a significant effort to save it, as the resource is likely doomed.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.STOCK_DANGER_THRESHOLD = 0.3 * self.capacity
        self.STOCK_RECOVERY_THRESHOLD = 0.6 * self.capacity
        self.HIGH_COOP_PROP_OTHERS = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number + 1
        current_stock_S = state.current_stock
        if current_round_t == self.n_rounds:
            return Action.D
        if current_round_t == 1:
            return Action.D
        prev_round_history_idx = state.round_number - 1
        num_coop_others = np.sum(history.opponent_actions[prev_round_history_idx, :])
        total_others = self.n_players - 1
        prop_coop_others = num_coop_others / total_others
        if current_stock_S < self.STOCK_DANGER_THRESHOLD:
            if prop_coop_others >= self.HIGH_COOP_PROP_OTHERS:
                return Action.C
            else:
                return Action.D
        elif current_stock_S >= self.STOCK_RECOVERY_THRESHOLD:
            return Action.D
        elif prop_coop_others >= self.HIGH_COOP_PROP_OTHERS:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_4(BaseStrategy):
    """
    The "Adaptive Predator" strategy for the Common Pool Resource Game.
    This strategy prioritizes individual payoff maximization, defaulting to defection.
    It strategically cooperates only out of self-interest to prevent resource collapse
    or exploits favorable conditions based on observed opponent behavior and current stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.conservation_threshold = self.capacity / (2 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_idx = state.round_number
        current_stock = state.current_stock
        if current_round_idx >= self.n_rounds - 2:
            return Action.D
        if current_stock <= self.conservation_threshold:
            return Action.C
        if current_round_idx == 0:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[current_round_idx - 1]
        total_other_players = self.n_players - 1
        others_cooperation_count = np.sum(previous_round_opponent_actions)
        others_defection_count = total_other_players - others_cooperation_count
        defection_rate = others_defection_count / total_other_players
        if current_stock >= self.capacity * 0.75 and defection_rate <= 0.3:
            return Action.D
        if current_stock < self.capacity * 0.5 and defection_rate >= 0.7:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_5(BaseStrategy):
    """
    The "Adaptive Predator" strategy prioritizes immediate personal gain by defecting, 
    but strategically cooperates (reduces consumption) when the common stock is at 
    a critical level and there's a tangible chance to restore it for future exploitation. 
    It ruthlessly exploits the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.K_ENDGAME = 2
        self.CRITICAL_STOCK_LEVEL_THRESHOLD = self.capacity * 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number >= self.n_rounds - self.K_ENDGAME:
            return Action.D
        num_opponents = self.n_players - 1
        opponents_defection_rate_last_round = 0.0
        prev_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        num_cooperators_last_round = np.sum(prev_round_opponent_actions)
        num_defectors_last_round = num_opponents - num_cooperators_last_round
        opponents_defection_rate_last_round = num_defectors_last_round / num_opponents
        if state.current_stock <= self.CRITICAL_STOCK_LEVEL_THRESHOLD:
            if opponents_defection_rate_last_round < 0.5:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_6(BaseStrategy):
    """
    The Adaptive Predator strategy is designed to be highly exploitative in the Common Pool Resource game.
    It prioritizes maximizing its own long-term payoff by primarily defecting, but strategically cooperates
    only when the common pool resource is critically endangered *and* other players demonstrate a
    willingness to contribute to its recovery. This allows the strategy to free-ride on others'
    cooperation and exploit the resource whenever possible, while attempting to prevent a total
    collapse that would harm its own future earnings.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_RATIO: float = 0.3
        self.OTHERS_COOPERATING_THRESHOLD: float = 0.5
        self.ENDGAME_BUFFER_ROUNDS: int = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        num_players = self.game_description.n_players
        rounds_remaining = total_rounds - (current_round + 1)
        if rounds_remaining < self.ENDGAME_BUFFER_ROUNDS:
            return Action.D
        num_others_cooperated_prev_round = 0
        if current_round > 0:
            prev_round_actions_by_others = history.opponent_actions[current_round - 1]
            num_others_cooperated_prev_round = np.sum(prev_round_actions_by_others)
        else:
            num_others_cooperated_prev_round = 0
        is_others_cooperative = num_others_cooperated_prev_round >= (num_players - 1) * self.OTHERS_COOPERATING_THRESHOLD
        is_stock_critical = current_stock < capacity * self.CRITICAL_STOCK_RATIO
        if is_stock_critical:
            if is_others_cooperative:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_7(BaseStrategy):
    """
    The Opportunistic Exploiter strategy aims to maximize its total payoff by predominantly defecting.
    It adaptively cooperates only in dire circumstances where the common pool resource is critically depleted,
    and there's a plausible, limited-time opportunity to help restore it for continued exploitation.

    The strategy operates under the assumptions of perfect information, common knowledge, simultaneous actions,
    repeated interaction, and no communication, inferring opponent behaviors from past actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_DEPLETION_THRESHOLD = self.capacity / (2.0 * self.n)
        self.RECOVERY_ATTEMPT_ROUNDS = 2
        self.my_recovery_coop_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.r - 1:
            self.my_recovery_coop_count = 0
            return Action.D
        if current_stock < 0.01 * self.capacity:
            self.my_recovery_coop_count = 0
            return Action.D
        if current_stock < self.CRITICAL_STOCK_DEPLETION_THRESHOLD:
            num_defectors_last_round = 0
            if current_round_0_indexed > 0 and history is not None:
                previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
                num_defectors_last_round = np.sum(~previous_round_opponent_actions)
            if num_defectors_last_round >= (self.n - 1) / 2.0 or self.my_recovery_coop_count >= self.RECOVERY_ATTEMPT_ROUNDS:
                self.my_recovery_coop_count = 0
                return Action.D
            else:
                self.my_recovery_coop_count += 1
                return Action.C
        else:
            self.my_recovery_coop_count = 0
            return Action.D

class Strategy_EXPLOITATIVE_8(BaseStrategy):
    """
    The "Resource Predator" strategy aims to maximize its own cumulative payoff by relentlessly defecting.
    It strategically preserves the common pool resource only when facing imminent collapse,
    and exploits cooperation from other players. It always defects in the last round and when the resource is abundant.
    In a 'middle ground' resource state, it adapts by defecting if more than half of others cooperated previously,
    and cooperating if half or more of others defected to prevent rapid resource depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.STOCK_THRESHOLD_CRITICAL = self.capacity / (self.n_players + 1)
        self.STOCK_THRESHOLD_SAFE_DEFECTION = self.capacity * (1 - 1 / (2 * self.n_players))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_stock <= self.STOCK_THRESHOLD_CRITICAL:
            return Action.C
        if current_stock >= self.STOCK_THRESHOLD_SAFE_DEFECTION:
            return Action.D
        num_other_cooperators = sum(history.opponent_actions[-1, :])
        other_players_count = self.n_players - 1
        if other_players_count > 0:
            cooperation_ratio = num_other_cooperators / other_players_count
            if cooperation_ratio > 0.5:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_9(BaseStrategy):
    """
    The "Greedy Stock-Watcher" strategy aims to maximize its total payoff by opportunistically defecting,
    while safeguarding the common pool resource from collapse. It adapts its behavior based on the
    current stock level, the observed defection rate of other players, and the stock trend.

    Key features:
    - Defines a critical stock level (`S_critical_cooperate`) below which it always cooperates to allow recovery.
    - Defines a defection threshold (`k_threshold`) to assess opponent cooperativeness.
    - Defects in the initial round to probe opponent behavior and secure early gains.
    - Always defects in the final round to maximize immediate payoff without future consequences.
    - In normal play, it defects if opponents were largely cooperative in the previous round.
    - If opponents were largely defecting, it checks the stock trend:
        - Cooperates if the stock declined, to prevent collapse.
        - Defects if the stock stabilized or grew, continuing to exploit resilience.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_critical_cooperate = self.game_description.capacity / 4.0
        self.k_threshold = self.game_description.n_players / 2.0
        self.previous_round_start_stock: float | None = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        if current_round_0_indexed == n_rounds - 1:
            self.previous_round_start_stock = current_stock
            return Action.D
        if current_stock < self.S_critical_cooperate:
            self.previous_round_start_stock = current_stock
            return Action.C
        if current_round_0_indexed == 0:
            self.previous_round_start_stock = current_stock
            return Action.D
        else:
            n_opponents = n_players - 1
            prev_round_opponent_cooperators = np.sum(history.opponent_actions[-1, :])
            k_prev = n_opponents - prev_round_opponent_cooperators
            S_prev_start = self.previous_round_start_stock
            if S_prev_start is None:
                self.previous_round_start_stock = current_stock
                return Action.D
            if k_prev < self.k_threshold:
                self.previous_round_start_stock = current_stock
                return Action.D
            elif current_stock < S_prev_start:
                self.previous_round_start_stock = current_stock
                return Action.C
            else:
                self.previous_round_start_stock = current_stock
                return Action.D

class Strategy_EXPLOITATIVE_10(BaseStrategy):
    """
    The Opportunistic Shark strategy aims to maximize individual payoff by defaulting to defection,
    while carefully monitoring the common resource and the actions of other players to prevent
    resource collapse or to avoid being a "sucker" if others are defecting.
    It's adaptive and robust because it reacts to both the state of the resource and the collective
    behavior of opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_factor = 0.15
        self.cooperation_tolerance = 0.6
        self.defection_punishment_threshold = 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.D
        if current_round_0_indexed == n_rounds - 1:
            return Action.D
        if current_stock < capacity * self.critical_stock_factor:
            return Action.C
        my_last_action = Action.C if history.my_actions[-1] else Action.D
        total_cooperators_last_round = history.my_actions[-1] + np.sum(history.opponent_actions[-1, :])
        num_cooperators_among_others = total_cooperators_last_round
        if my_last_action == Action.C:
            num_cooperators_among_others -= 1
        cooperation_ratio_others = num_cooperators_among_others / (n_players - 1)
        if cooperation_ratio_others >= self.cooperation_tolerance:
            return Action.D
        elif cooperation_ratio_others <= self.defection_punishment_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_11(BaseStrategy):
    """
    The "Opportunistic Predator" strategy is designed to ruthlessly maximize its own payoff in the 
    Common Pool Resource game. It prioritizes immediate gains through defection, strategically 
    free-riding on other players' cooperation, and only resorts to cooperation in extreme circumstances 
    to prevent complete resource collapse, which would ultimately harm its own long-term earnings potential. 
    This strategy is adaptive, responding to both the current stock level and the observed behavior of 
    opponents from the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        current_stock = state.current_stock
        n = self.n_players
        capacity = self.capacity
        cooperators_last_round_others = np.sum(history.opponent_actions[-1, :])
        total_other_players = n - 1
        if total_other_players == 0:
            return Action.D
        cooperation_ratio_others = cooperators_last_round_others / total_other_players
        if current_stock < capacity / (2 * n):
            return Action.C
        elif cooperation_ratio_others >= 0.5:
            return Action.D
        elif current_stock > capacity / 2:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_12(BaseStrategy):
    """
    Adaptive Scavenger: An exploitative, adaptive, and robust strategy for the Common Pool Resource game.
    It prioritizes the player's total payoff by defaulting to defecting, free-riding on others' cooperation,
    and only cooperating strategically and temporarily when the resource is critically low AND the player's
    cooperation is perceived as necessary to prevent total collapse, thereby preserving the resource for
    future exploitation. As the game nears its end, the strategy shifts to maximizing immediate gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_CRITICAL_THRESHOLD = self.game_description.n_players * 1.0
        self.COOPERATION_LOWER_BOUND_PCT = 0.25
        self.COOPERATION_UPPER_BOUND_PCT = 0.75
        self.ROUNDS_FOR_RECOVERY_TO_MATTER = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        current_round_1_indexed = current_round_0_indexed + 1
        if current_round_0_indexed == 0:
            return Action.D
        if current_round_1_indexed == total_rounds:
            return Action.D
        num_opponents_cooperated_prev_round = sum(history.opponent_actions[-1, :])
        n_minus_1 = n - 1
        if n_minus_1 == 0:
            return Action.D
        cooperation_lower_bound_abs = n_minus_1 * self.COOPERATION_LOWER_BOUND_PCT
        cooperation_upper_bound_abs = n_minus_1 * self.COOPERATION_UPPER_BOUND_PCT
        if current_stock < self.S_CRITICAL_THRESHOLD:
            rounds_remaining = total_rounds - current_round_1_indexed
            if rounds_remaining <= self.ROUNDS_FOR_RECOVERY_TO_MATTER:
                return Action.D
            elif num_opponents_cooperated_prev_round < cooperation_lower_bound_abs:
                return Action.D
            elif num_opponents_cooperated_prev_round > cooperation_upper_bound_abs:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_13(BaseStrategy):
    """
    The Adaptive Predator (AP) strategy is designed for aggressive exploitation
    of the common pool resource. It defaults to defection to maximize immediate
    payoffs. AP will only consider cooperation if the resource stock is critically low
    AND a high fraction of other players demonstrated cooperation in the previous
    round, viewing this as a strategic, temporary investment to prevent total
    resource collapse for future exploitation. As the game nears its end, AP
    enters an aggressive liquidation phase, defecting relentlessly to extract
    maximum remaining value.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.STOCK_CRITICAL_THRESHOLD_FRACTION: float = 0.25
        self.COOPERATION_INDIFFERENCE_POINT_FRACTION: float = 0.75
        self.ROUNDS_LEFT_LIQUIDATION_THRESHOLD: int = 3
        self.stock_critical_absolute: float = self.STOCK_CRITICAL_THRESHOLD_FRACTION * self.capacity
        self.num_others: int = self.n_players - 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed: int = state.round_number
        current_stock: float = state.current_stock
        current_round_1_indexed: int = current_round_0_indexed + 1
        if current_round_0_indexed == 0:
            return Action.D
        rounds_left: int = self.n_rounds - current_round_1_indexed
        if rounds_left < self.ROUNDS_LEFT_LIQUIDATION_THRESHOLD:
            return Action.D
        n_cooperators_others_prev_round: int = np.sum(history.opponent_actions[-1, :])
        fraction_c_others_prev: float = n_cooperators_others_prev_round / self.num_others
        if current_stock < self.stock_critical_absolute:
            if fraction_c_others_prev >= self.COOPERATION_INDIFFERENCE_POINT_FRACTION:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_14(BaseStrategy):
    """
    The Calculated Predator aims to maximize its individual payoff by defaulting to defection,
    strategically cooperating only when the resource is critically endangered AND there's a
    collective effort to save it. Otherwise, it maintains a competitive stance, defecting
    to secure its share.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_critical_threshold = self.game_description.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_stock = state.current_stock
        current_round_idx = state.round_number
        if current_round_idx == r - 1:
            return Action.D
        if current_stock < self.stock_critical_threshold:
            if current_round_idx == 0:
                return Action.D
            else:
                my_defected_prev = 1 if not history.my_actions[-1] else 0
                opponent_cooperators_prev = sum(history.opponent_actions[-1, :])
                opponent_defectors_prev = n - 1 - opponent_cooperators_prev
                total_defectors_prev = my_defected_prev + opponent_defectors_prev
                if total_defectors_prev <= n / 2.0:
                    return Action.C
                else:
                    return Action.D
        elif current_round_idx == 0:
            return Action.D
        else:
            opponent_cooperators_prev = sum(history.opponent_actions[-1, :])
            opponent_defectors_prev = n - 1 - opponent_cooperators_prev
            if opponent_defectors_prev == 0:
                return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_15(BaseStrategy):
    """
    The Ruthless Opportunist strategy for the Common Pool Resource Game.
    This strategy prioritizes immediate personal gain through defection. It only
    switches to cooperation as a self-preservation measure when the common pool
    resource is critically depleted, threatening future exploitation opportunities.
    It begins with an aggressive stance and maintains it until the very end,
    or until the resource's survival is at stake.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == 0:
            return Action.D
        if current_round_number == total_rounds - 1:
            return Action.D
        s_critical_for_survival = capacity / (2 * n_players)
        if current_stock <= s_critical_for_survival:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_16(BaseStrategy):
    """
    Calculated Exploiter with Collapse Avoidance:
    This strategy aims to maximize its own total payoff by defaulting to defection,
    but it incorporates a critical safety mechanism. It cooperates only when its own
    defection, combined with observed opponent behavior, would lead to the resource's
    collapse, thereby eliminating its own future payoff stream.

    The strategy adapts by using opponent history to predict future stock levels
    and makes decisions based on preventing resource depletion below a critical
    threshold, ensuring the resource remains viable for continued exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.MIN_STOCK_FOR_FUTURE_PAYOFFS: float = 0.05 * self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r_total = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_idx = state.round_number
        current_stock = state.current_stock
        if current_round_idx == r_total - 1:
            return Action.D
        if current_stock <= self.MIN_STOCK_FOR_FUTURE_PAYOFFS:
            return Action.D
        estimated_num_cooperators_others_prev_round: int = 0
        if current_round_idx > 0:
            estimated_num_cooperators_others_prev_round = int(np.sum(history.opponent_actions[-1, :]))
        else:
            estimated_num_cooperators_others_prev_round = 0
        num_defectors_others_prev_round: int = n - 1 - estimated_num_cooperators_others_prev_round
        my_consumption_if_D: float = current_stock / n
        consumption_others_if_D_and_prev_behavior: float = estimated_num_cooperators_others_prev_round * (current_stock / (2.0 * n)) + num_defectors_others_prev_round * (current_stock / (1.0 * n))
        total_consumption_if_i_D: float = my_consumption_if_D + consumption_others_if_D_and_prev_behavior
        stock_after_consumption_if_i_D: float = max(0.0, current_stock - total_consumption_if_i_D)
        growth_if_i_D: float = 2.0 * stock_after_consumption_if_i_D * (1.0 - stock_after_consumption_if_i_D / capacity)
        next_stock_if_i_D: float = min(stock_after_consumption_if_i_D + growth_if_i_D, capacity)
        my_consumption_if_C: float = current_stock / (2.0 * n)
        consumption_others_if_C_and_prev_behavior: float = estimated_num_cooperators_others_prev_round * (current_stock / (2.0 * n)) + num_defectors_others_prev_round * (current_stock / (1.0 * n))
        total_consumption_if_i_C: float = my_consumption_if_C + consumption_others_if_C_and_prev_behavior
        stock_after_consumption_if_i_C: float = max(0.0, current_stock - total_consumption_if_i_C)
        growth_if_i_C: float = 2.0 * stock_after_consumption_if_i_C * (1.0 - stock_after_consumption_if_i_C / capacity)
        next_stock_if_i_C: float = min(stock_after_consumption_if_i_C + growth_if_i_C, capacity)
        if next_stock_if_i_D <= self.MIN_STOCK_FOR_FUTURE_PAYOFFS:
            if next_stock_if_i_C > self.MIN_STOCK_FOR_FUTURE_PAYOFFS:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_17(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize individual payoff by defaulting to Defect (D)
    but cooperates (C) when the common resource is critically low (S_panic_threshold) or
    when defection, coupled with observed opponent behavior, would push the resource into crisis
    in the next round. It exploits cooperation from others and defects aggressively in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_panic_threshold = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            k_prev = 0
        else:
            num_cooperators_prev_round = np.sum(history.opponent_actions[-1, :])
            k_prev = self.n - num_cooperators_prev_round
        if current_round_0_indexed == self.r - 1:
            return Action.D
        if current_stock <= self.S_panic_threshold:
            return Action.C
        elif k_prev < self.n / 2.0:
            return Action.D
        else:
            predicted_num_D = k_prev + 1
            predicted_num_C = self.n - predicted_num_D
            predicted_num_D = min(predicted_num_D, self.n)
            predicted_num_C = max(0, self.n - predicted_num_D)
            if current_stock <= 0:
                projected_total_consumption = 0.0
            else:
                projected_total_consumption = predicted_num_D * current_stock / self.n + predicted_num_C * current_stock / (2.0 * self.n)
            S_after_consumption = current_stock - projected_total_consumption
            S_after_consumption = max(0.0, S_after_consumption)
            growth = 2.0 * S_after_consumption * (1.0 - S_after_consumption / self.capacity)
            S_next_if_I_D = min(S_after_consumption + growth, self.capacity)
            if S_next_if_I_D <= self.S_panic_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_18(BaseStrategy):
    """
    Ruthless Opportunist strategy for the Common Pool Resource game.
    Aims to maximize its own total payoff by aggressively exploiting opportunities
    to defect, protecting its share against widespread defection, and strategically
    cooperating only to induce future exploitable cooperation or to salvage a
    critically depleted resource under strong collective effort.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Ruthless Opportunist strategy with game parameters.

        Args:
            game_description: An object containing game parameters such as
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: An object containing the current round number and stock level.
            history: An object containing records of past actions and payoffs for
                     this player and opponents, or None for the very first round.

        Returns:
            An Action enum (Action.C for Cooperate, Action.D for Defect).
        """
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        round_num_0_indexed = state.round_number
        if round_num_0_indexed == r - 1:
            return Action.D
        if round_num_0_indexed == 0:
            return Action.D
        W = min(round_num_0_indexed, 3)
        total_other_cooperations = 0
        total_other_actions = 0
        if W > 0:
            last_w_rounds_opponent_actions = history.opponent_actions[-W:]
            total_other_cooperations = np.sum(last_w_rounds_opponent_actions)
            total_other_actions = W * (n - 1)
        coop_fraction_others_avg = 0.0
        if total_other_actions > 0:
            coop_fraction_others_avg = total_other_cooperations / total_other_actions
        S_critical_low = capacity / (4 * n)
        S_medium_low = capacity / n
        if current_stock <= S_critical_low:
            if coop_fraction_others_avg >= 0.8:
                return Action.C
            else:
                return Action.D
        elif current_stock <= S_medium_low:
            if coop_fraction_others_avg >= 0.7:
                return Action.D
            elif coop_fraction_others_avg >= 0.4:
                return Action.C
            else:
                return Action.D
        elif coop_fraction_others_avg >= 0.6:
            return Action.D
        elif coop_fraction_others_avg >= 0.3:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_19(BaseStrategy):
    """
    The Opportunistic Scavenger strategy is designed to aggressively extract from the common pool resource
    whenever feasible, only reverting to cooperation when the resource's health becomes critically low,
    thereby threatening future exploitation opportunities. It adapts to the collective impact of all players
    on the stock rather than attempting to model or respond to individual opponents' past actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Opportunistic Scavenger strategy.

        Args:
            game_description: An object containing game parameters such as
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) based on the current
        game state and the Opportunistic Scavenger strategy rules.

        Args:
            state: An object containing the current round_number and current_stock.
            history: An object containing historical actions and payoffs (not used by this strategy).

        Returns:
            An Action enum (Action.C for Cooperate or Action.D for Defect).
        """
        current_round = state.round_number
        current_stock = state.current_stock
        total_rounds = self.game_description.n_rounds
        game_capacity = self.game_description.capacity
        if current_round == total_rounds - 1:
            return Action.D
        elif current_stock < game_capacity / 4:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_20(BaseStrategy):
    """
    The "Calculated Predator" strategy aims to maximize its total payoff by being
    aggressively exploitative when resource levels permit, but adapting to
    conserve the common pool when its sustainability is threatened, ensuring
    future opportunities for exploitation. It's a self-interested strategy that
    views cooperation as a necessary investment for long-term gain rather than
    an altruistic act.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_danger_threshold_ratio = 0.25
        self.stock_abundance_threshold_ratio = 0.75
        self.base_defection_tolerance = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.total_rounds:
            return Action.D
        if current_stock < self.stock_danger_threshold_ratio * self.capacity:
            return Action.C
        if current_stock >= self.stock_abundance_threshold_ratio * self.capacity:
            return Action.D
        n_other_players = self.n_players - 1
        D_count_others = 0
        if n_other_players > 0:
            num_cooperators_others = np.sum(history.opponent_actions[-1, :])
            D_count_others = n_other_players - num_cooperators_others
            D_rate_others = D_count_others / n_other_players
        else:
            D_rate_others = 0.0
        rounds_remaining_for_calc = self.total_rounds - current_round_1_indexed
        relative_rounds_remaining = rounds_remaining_for_calc / (self.total_rounds - 1)
        defection_tolerance_threshold = self.base_defection_tolerance + (1 - self.base_defection_tolerance) * (1 - relative_rounds_remaining)
        if D_rate_others < defection_tolerance_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_21(BaseStrategy):
    """
    The "Calculated Extractor" strategy is designed to maximize its own cumulative payoff by primarily
    defecting, while adaptively considering resource sustainability only when it serves the strategy's
    long-term self-interest. It aims to exploit cooperative players and extract as much as possible,
    even in a "race to the bottom" scenario, to avoid being the sole cooperator.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_critical_threshold = 0.2 * self.capacity
        self.rounds_for_conservation_relevance = max(1, math.floor(self.n_rounds / 3))
        self.opponent_cooperation_signal = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        prev_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1]
        num_opponents_cooperating_last_round = np.sum(prev_round_opponent_actions)
        avg_opponent_cooperation_rate = num_opponents_cooperating_last_round / (self.n_players - 1)
        if current_stock < self.stock_critical_threshold:
            rounds_remaining = self.n_rounds - current_round_1_indexed
            if rounds_remaining >= self.rounds_for_conservation_relevance:
                if avg_opponent_cooperation_rate >= self.opponent_cooperation_signal:
                    return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_22(BaseStrategy):
    """
    Opportunistic Scavenger strategy for the Common Pool Resource Game.
    This strategy prioritizes individual payoff maximization, exploiting
    others' cooperation when the resource is healthy and only cooperating
    for self-preservation of the resource when critically low and others
    are also contributing. It always defects in the first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_RATIO: float = 0.25
        self.COOPERATION_FREE_RIDE_THRESHOLD: int = math.floor(self.game_description.n_players / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = float(self.game_description.capacity)
        if current_round_1_indexed == 1:
            return Action.D
        if current_round_1_indexed == total_rounds:
            return Action.D
        num_other_cooperators = sum(history.opponent_actions[-1, :])
        is_stock_critical = current_stock < capacity * self.CRITICAL_STOCK_RATIO
        if is_stock_critical:
            if num_other_cooperators > 0:
                return Action.C
            else:
                return Action.D
        elif num_other_cooperators >= self.COOPERATION_FREE_RIDE_THRESHOLD:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_23(BaseStrategy):
    """
    Adaptive Predator strategy for the Common Pool Resource game.
    This strategy is designed to be exploitative, prioritizing immediate gains
    but strategically cooperating to allow resource recovery only when
    total collapse threatens future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.LST: float = self.game_description.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players: int = self.game_description.n_players
        n_rounds: int = self.game_description.n_rounds
        capacity: float = self.game_description.capacity
        current_round_number: int = state.round_number
        current_stock: float = state.current_stock
        if current_round_number == n_rounds - 1:
            return Action.D
        if current_round_number == 0:
            return Action.D
        if history is None:
            return Action.D
        my_action_prev_round: bool = history.my_actions[-1]
        my_payoff_prev_round: float = history.my_payoffs[-1]
        S_prev_round_start: float
        if my_payoff_prev_round <= 1e-09:
            S_prev_round_start = 0.0
        elif my_action_prev_round == Action.C.value:
            S_prev_round_start = my_payoff_prev_round * (2.0 * n_players)
        else:
            S_prev_round_start = my_payoff_prev_round * float(n_players)
        S_prev_round_after_consumption: float
        if current_stock <= 1e-09:
            S_prev_round_after_consumption = 0.0
        elif current_stock >= capacity - 1e-09:
            S_prev_round_after_consumption = capacity / 2.0
        else:
            discriminant = 9.0 - 8.0 * current_stock / capacity
            discriminant = max(0.0, discriminant)
            S_prev_round_after_consumption = (3.0 - math.sqrt(discriminant)) * (capacity / 4.0)
        my_consumption_prev: float
        if my_action_prev_round == Action.C.value:
            my_consumption_prev = S_prev_round_start / (2.0 * n_players)
        else:
            my_consumption_prev = S_prev_round_start / float(n_players)
        total_consumption_observed = max(0.0, S_prev_round_start - S_prev_round_after_consumption)
        consumption_by_others = max(0.0, total_consumption_observed - my_consumption_prev)
        n_D_prev: int
        if S_prev_round_start <= 1e-09:
            n_D_prev = n_players - 1
        else:
            n_D_prev_float = consumption_by_others * 2.0 * n_players / S_prev_round_start - (n_players - 1)
            n_D_prev = int(round(n_D_prev_float))
            n_D_prev = max(0, min(n_D_prev, n_players - 1))
        if current_stock < self.LST:
            if current_round_number == n_rounds - 2:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_24(BaseStrategy):
    """
    The "Adaptive Predatory Harvest" strategy aims to maximize individual payoff by exploiting the common pool resource
    and the cooperative tendencies of other players, while also adapting to prevent immediate resource collapse
    if necessary for long-term exploitation. It leverages insights from game theory, such as the backward induction
    principle for finite repeated games, and dynamically adjusts its behavior based on the current stock level
    and the observed cooperation of others.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_threshold_low = self.capacity / (2.0 * self.n_players)
        self.S_threshold_healthy = self.capacity / 2.0
        self.K_endgame_length_constant = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.C
        num_others_cooperated_last_round = sum(history.opponent_actions[current_round_0_indexed - 1, :])
        CI_others_last_round = num_others_cooperated_last_round / (self.n_players - 1)
        adjusted_K_endgame = min(self.n_rounds - 1, self.K_endgame_length_constant)
        near_endgame_start_round_0_indexed = self.n_rounds - adjusted_K_endgame - 1
        if current_round_0_indexed >= near_endgame_start_round_0_indexed:
            if current_stock < self.S_threshold_low * 2 and CI_others_last_round > 0.75:
                return Action.C
            else:
                return Action.D
        if current_stock < self.S_threshold_low:
            if CI_others_last_round > 0.75:
                return Action.C
            else:
                return Action.D
        elif current_stock >= self.S_threshold_healthy:
            return Action.D
        elif CI_others_last_round > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_25(BaseStrategy):
    """
    Opportunistic Exploiter with Conservation Trigger:
    This strategy maximizes immediate gains when the resource is abundant or opponents are cooperative.
    It resorts to cooperation (conservation) only when the resource is critically low or
    widespread defection threatens its long-term viability, ensuring the resource doesn't collapse
    prematurely due to its own actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_recovery_threshold_ratio = 0.25
        self.defection_tolerance_ratio = 0.75
        self.high_stock_exploit_threshold_ratio = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == r - 1:
            return Action.D
        if current_stock > self.high_stock_exploit_threshold_ratio * capacity:
            return Action.D
        else:
            if current_stock < self.stock_recovery_threshold_ratio * capacity:
                return Action.C
            if current_round_number > 0 and history is not None:
                num_others_defect_prev_round = sum(~history.opponent_actions[current_round_number - 1, :])
                total_others = n - 1
                if total_others > 0 and num_others_defect_prev_round >= total_others * self.defection_tolerance_ratio:
                    return Action.C
            return Action.D

class Strategy_EXPLOITATIVE_26(BaseStrategy):
    """
    Calculated Predator: Prioritizes immediate personal gain (defecting) unless the common resource is in critical danger
    AND there's evidence that other players are willing to collectively preserve it.
    If others aren't helping in a collapse, it abandons the resource and takes what's left.
    Always defects in the first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold = self.game_description.capacity / (2 * self.game_description.n_players)
        self.cooperation_willingness_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == 0:
            return Action.D
        if current_round_0_indexed == r - 1:
            return Action.D
        k_C_others = 0
        n_other_players = n - 1
        if n_other_players > 0:
            k_C_others = np.sum(history.opponent_actions[current_round_0_indexed - 1, :])
            p_C_others = k_C_others / n_other_players
        else:
            p_C_others = 0
        if current_stock < self.critical_stock_threshold:
            if p_C_others >= self.cooperation_willingness_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_27(BaseStrategy):
    """
    The "Adaptive Predator" strategy for the Common Pool Resource Game.
    This strategy aims to maximize individual payoff by defaulting to Defect (D)
    and free-riding on cooperative opponents. It adaptively cooperates only
    when necessary to prevent critical resource collapse that would severely
    damage its own future payoffs, or to exploit collective efforts to save
    the resource.

    Key principles:
    - Prioritize Defect for immediate maximum gain.
    - Leverage high opponent cooperation to free-ride.
    - Avoid resource collapse when its own actions or collective behavior
      could lead to a critically low stock level, potentially cooperating
      for self-preservation.
    - Aggressive stance in initial and terminal rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.MVSC_FACTOR = 0.1
        self.HIGH_COOPERATION_THRESHOLD = 0.75
        self.RECENT_HISTORY_LOOKBACK = 3
        self.INITIAL_DEFECTION_ROUNDS = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        MVSC = self.MVSC_FACTOR * capacity
        if current_round == total_rounds - 1:
            return Action.D
        if current_round == total_rounds - 2:
            return Action.D
        if current_round < self.INITIAL_DEFECTION_ROUNDS and current_round < total_rounds - 2:
            return Action.D
        start_lookback_round = max(0, current_round - self.RECENT_HISTORY_LOOKBACK)
        recent_opponent_actions_list = []
        for r_idx in range(start_lookback_round, current_round):
            recent_opponent_actions_list.extend(history.opponent_actions[r_idx].tolist())
        num_cooperating_opponents_in_recent_history = sum(recent_opponent_actions_list)
        total_opponent_actions_in_recent_history = (n_players - 1) * (current_round - start_lookback_round)
        recent_cooperation_rate = 0.0
        if total_opponent_actions_in_recent_history > 0:
            recent_cooperation_rate = num_cooperating_opponents_in_recent_history / total_opponent_actions_in_recent_history
        stock_after_all_C_consumption = current_stock - current_stock / 2.0
        if stock_after_all_C_consumption < MVSC:
            if recent_cooperation_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        elif recent_cooperation_rate >= self.HIGH_COOPERATION_THRESHOLD:
            return Action.D
        else:
            expected_C_opponents = round(recent_cooperation_rate * (n_players - 1))
            expected_D_opponents = n_players - 1 - expected_C_opponents
            my_consumption_if_self_D = current_stock / n_players
            opponents_consumption = expected_C_opponents * current_stock / (2.0 * n_players) + expected_D_opponents * current_stock / n_players
            total_consumption_if_self_D = my_consumption_if_self_D + opponents_consumption
            stock_after_consumption_if_self_D = current_stock - total_consumption_if_self_D
            if stock_after_consumption_if_self_D < MVSC:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_28(BaseStrategy):
    """
    The "Adaptive Predator" strategy aims to extract as much as possible from the common pool.
    It defaults to defection when conditions are favorable (healthy stock, low defection from others).
    However, it strategically retreats to cooperation when the resource is critically low or when
    too many other players are defecting, as a self-preservation mechanism to prevent resource
    collapse and ensure future rounds of exploitation. In the final round, with no future
    consequences, it reverts to full defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_STOCK_LEVEL = self.capacity / (2 * self.n_players)
        self.LOW_STOCK_LEVEL = self.capacity / 4.0
        self.MODERATE_STOCK_LEVEL = self.capacity / 2.0
        self.HEALTHY_STOCK_LEVEL = self.capacity * 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_stock <= self.CRITICAL_STOCK_LEVEL:
            return Action.C
        if state.round_number == 0:
            return Action.D
        defection_tolerance_ratio = 0.0
        if current_stock >= self.HEALTHY_STOCK_LEVEL:
            defection_tolerance_ratio = 0.6
        elif current_stock >= self.MODERATE_STOCK_LEVEL:
            defection_tolerance_ratio = 0.4
        elif current_stock >= self.LOW_STOCK_LEVEL:
            defection_tolerance_ratio = 0.2
        previous_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        num_others_defected = np.sum(previous_round_opponent_actions == False)
        num_other_players = self.n_players - 1
        actual_defection_ratio_among_others = 0.0
        if num_other_players > 0:
            actual_defection_ratio_among_others = num_others_defected / num_other_players
        if actual_defection_ratio_among_others > defection_tolerance_ratio:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_29(BaseStrategy):
    """
    The Adaptive Predator strategy is designed for highly exploitative play, prioritizing
    immediate individual payoff maximization. It defaults to defection (D) but dynamically
    adjusts to cooperate (C) when faced with critical resource depletion or widespread
    defection by opponents, aiming to prevent total resource collapse for future exploitation.
    In the final round, it always defects to maximize terminal payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold_for_cooperation = self.game_description.capacity / self.game_description.n_players
        self.high_stock_threshold_for_defection = self.game_description.capacity * 0.9
        self.defection_prop_for_punishment = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        num_players = self.game_description.n_players
        if current_round == total_rounds - 1:
            return Action.D
        if current_stock < self.critical_stock_threshold_for_cooperation:
            return Action.C
        if current_round > 0 and history is not None:
            num_cooperators_last_round = sum(history.opponent_actions[-1, :])
            num_D_opponents_last_round = num_players - 1 - num_cooperators_last_round
            proportion_D_opponents = num_D_opponents_last_round / (num_players - 1)
            if proportion_D_opponents > self.defection_prop_for_punishment:
                if current_stock < self.high_stock_threshold_for_defection:
                    return Action.C
                else:
                    return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_30(BaseStrategy):
    """
    The "Adaptive Predator" strategy is designed for the Common Pool Resource Game.
    It prioritizes individual payoff maximization, dynamically adjusting its aggressiveness
    based on the current stock level and the observed behavior of other players.
    It will exploit cooperative behavior when present and retreat to conservation only when
    necessary to prevent resource collapse or when defection offers negligible gains.
    It is ruthlessly greedy in the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.num_players_n = game_description.n_players
        self.total_rounds_r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_CRITICAL_THRESHOLD_FACTOR = 1.0 / (2.0 * self.num_players_n)
        self.COOP_EXPLOIT_THRESHOLD = 0.6
        self.HISTORY_WINDOW = 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number
        current_stock_S = state.current_stock
        if current_round_t == self.total_rounds_r - 1:
            return Action.D
        S_critical = self.capacity * self.S_CRITICAL_THRESHOLD_FACTOR
        if current_stock_S < S_critical:
            return Action.C
        if current_round_t == 0:
            return Action.D
        num_other_players = self.num_players_n - 1
        if num_other_players <= 0:
            return Action.D
        sum_of_other_cooperations = 0
        rounds_considered_for_history = 0
        start_history_idx = max(0, current_round_t - self.HISTORY_WINDOW)
        end_history_idx = current_round_t - 1
        if end_history_idx >= start_history_idx:
            recent_opponent_actions = history.opponent_actions[start_history_idx:end_history_idx + 1, :]
            rounds_considered_for_history = recent_opponent_actions.shape[0]
            sum_of_other_cooperations = np.sum(recent_opponent_actions)
        if rounds_considered_for_history == 0:
            return Action.D
        total_possible_actions_in_window = rounds_considered_for_history * num_other_players
        if total_possible_actions_in_window == 0:
            return Action.D
        observed_cooperation_rate = sum_of_other_cooperations / total_possible_actions_in_window
        if observed_cooperation_rate >= self.COOP_EXPLOIT_THRESHOLD:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_31(BaseStrategy):
    """
    The Opportunistic Harvester strategy aims to maximize its own total payoff over 'r' rounds by primarily defecting,
    but with a calculated, self-interested conditional cooperation mechanism to prevent total resource collapse
    when others are already contributing to its recovery.

    Core Philosophy: Prioritize immediate personal gain (defecting) unless the common resource is in critical danger
    AND a sufficient number of other players are actively trying to preserve it. In such a scenario,
    temporary cooperation is a strategic move to preserve the resource for future exploitation, not out of altruism.
    If the resource is in danger but others are not cooperating, cut losses and extract what is possible.
    """
    _CRITICAL_STOCK_RATIO: float = 0.25
    _COOPERATION_RATE_THRESHOLD: float = 0.5

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_ratio = self._CRITICAL_STOCK_RATIO
        self.cooperation_rate_threshold = self._COOPERATION_RATE_THRESHOLD

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        critical_stock_level = self.critical_stock_ratio * capacity
        if current_round == 0:
            return Action.D
        elif current_round == n_rounds - 1:
            return Action.D
        else:
            num_cooperators_last_round = sum(history.opponent_actions[current_round - 1, :])
            num_other_players = n_players - 1
            observed_cooperation_rate = num_cooperators_last_round / num_other_players
            if current_stock <= critical_stock_level:
                if observed_cooperation_rate >= self.cooperation_rate_threshold:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_32(BaseStrategy):
    """
    The "Adaptive Exploiter" strategy defaults to defecting to maximize immediate personal gain.
    It only deviates from this default to cooperate if the resource is critically low AND
    a sufficient number of other players (less than or equal to MAX_OTHER_DEFECTORS_TOLERATED_FOR_RECOVERY)
    demonstrated cooperation in the previous round, making collective recovery plausible and self-serving.
    It plays 'D' in the first and last rounds for maximum immediate payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_RATIO = 0.25
        self.MAX_OTHER_DEFECTORS_TOLERATED_FOR_RECOVERY = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        critical_stock_level = self.capacity * self.CRITICAL_STOCK_RATIO
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1]
        num_cooperators_opponents_prev_round = np.sum(previous_round_opponent_actions)
        num_defectors_opponents_prev_round = self.n_players - 1 - num_cooperators_opponents_prev_round
        if current_stock < critical_stock_level:
            if num_defectors_opponents_prev_round <= self.MAX_OTHER_DEFECTORS_TOLERATED_FOR_RECOVERY:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_33(BaseStrategy):
    """
    The "Adaptive Exploiter" strategy is designed to maximize individual payoff by exploiting
    cooperative tendencies in opponents while prudently managing the common resource
    to ensure continued opportunities for exploitation. It combines immediate gain-seeking
    with long-term resource sustainability considerations, adapting its behavior based
    on the current state of the stock and the observed actions of other players.

    Strategic Principles:
    - Exploit Cooperation: Defect when opponents cooperate and stock is healthy.
    - Prevent Collapse: Cooperate if stock is critically low.
    - Retaliate/Self-Preserve: Defect if many others defect.
    - End-Game Exploitation: Defect unconditionally in final rounds.
    - Initial Probe: Cooperate in the first round of longer games to test opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.K_THRESHOLD = 2
        self.STOCK_CRITICAL_FRACTION = 0.25
        self.STOCK_HEALTHY_FRACTION = 0.5
        self.MAJORITY_DEFECTION_THRESHOLD_FRACTION = 0.5
        self.HIGH_COOPERATION_THRESHOLD_FRACTION = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number + 1
        current_stock = state.current_stock
        d_count_prev = 0
        if current_round > 1 and history is not None:
            previous_round_idx = state.round_number - 1
            my_prev_action = history.my_actions[previous_round_idx]
            d_count_prev += 1 - int(my_prev_action)
            opponents_prev_actions = history.opponent_actions[previous_round_idx, :]
            d_count_prev += np.sum(~opponents_prev_actions)
        if self.total_rounds <= self.K_THRESHOLD or current_round >= self.total_rounds - self.K_THRESHOLD + 1:
            return Action.D
        if current_round == 1:
            return Action.C
        if current_stock < self.capacity * self.STOCK_CRITICAL_FRACTION:
            return Action.C
        if d_count_prev >= self.n_players * self.MAJORITY_DEFECTION_THRESHOLD_FRACTION:
            return Action.D
        if d_count_prev <= self.n_players * self.HIGH_COOPERATION_THRESHOLD_FRACTION and current_stock >= self.capacity * self.STOCK_HEALTHY_FRACTION:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_34(BaseStrategy):
    """
    Adaptive Predator strategy for the Common Pool Resource Game.

    This strategy aims to maximize its individual total payoff by leaning towards
    defection. It adaptively cooperates only when necessary to prevent a resource
    collapse that would ultimately harm its own long-term gains. It uses historical
    observations to predict opponent behavior and adjusts its actions based on the
    current stock level and the remaining rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_recovery_threshold_factor = 0.25
        self.critical_stock_threshold = self.capacity * self.stock_recovery_threshold_factor

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.n_rounds - 1:
            return Action.D
        if round_number == 0:
            return Action.D
        prev_round_idx = round_number - 1
        my_action_last_round = history.my_actions[prev_round_idx]
        k_observed_last_round = (~history.opponent_actions[prev_round_idx, :]).sum() + (1 if not my_action_last_round else 0)
        if not my_action_last_round:
            num_D_others = max(0, k_observed_last_round - 1)
        else:
            num_D_others = k_observed_last_round
        num_D_others = max(0, min(self.n_players - 1, num_D_others))
        consumption_per_C_unit = current_stock / (2.0 * self.n_players) if self.n_players > 0 else 0.0
        consumption_per_D_unit = current_stock / (1.0 * self.n_players) if self.n_players > 0 else 0.0
        total_consumption_if_I_C = 1 * consumption_per_C_unit + num_D_others * consumption_per_D_unit + (self.n_players - 1 - num_D_others) * consumption_per_C_unit
        stock_after_consumption_if_I_C = max(0.0, current_stock - total_consumption_if_I_C)
        total_consumption_if_I_D = 1 * consumption_per_D_unit + num_D_others * consumption_per_D_unit + (self.n_players - 1 - num_D_others) * consumption_per_C_unit
        stock_after_consumption_if_I_D = max(0.0, current_stock - total_consumption_if_I_D)
        if stock_after_consumption_if_I_D <= self.critical_stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_35(BaseStrategy):
    """
    The Adaptive Predator strategy for the Common Pool Resource game.
    Aims to aggressively exploit the common pool resource by defaulting to defection,
    while employing a calculated, self-serving cooperation mechanism only when the
    resource is critically endangered and a collective effort appears viable,
    solely to ensure its continued availability for future exploitation. It also
    prioritizes maximum extraction during the game's final stages.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_crisis_threshold = self.capacity / 2.0
        self.C_threshold = math.ceil((self.n_players - 1) / 2.0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.D
        if current_round_0_indexed == self.n_rounds - 1 or current_round_0_indexed == self.n_rounds - 2:
            return Action.D
        else:
            N_C_opponents_prev = sum(history.opponent_actions[-1, :])
            if current_stock < self.S_crisis_threshold:
                if N_C_opponents_prev >= self.C_threshold:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_36(BaseStrategy):
    """
    The "Calculated Predator" strategy aims to maximize individual payoff by defecting as much as possible,
    only cooperating when its own future payoffs are severely threatened by resource depletion or when
    an aggressive defection by others makes cooperation futile. It adapts based on current stock and
    observed opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k_endgame_rounds: int = 3
        self.stock_recovery_threshold_factor: float = 0.2
        self.opponent_defection_threshold_factor: float = 0.6
        self.history_window_for_avg: int = 3
        self.opponent_defections_in_last_N_rounds: list[int] = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number > 0 and history is not None:
            num_defectors_last_round = np.sum(~history.opponent_actions[state.round_number - 1, :])
            self.opponent_defections_in_last_N_rounds.append(int(num_defectors_last_round))
            if len(self.opponent_defections_in_last_N_rounds) > self.history_window_for_avg:
                self.opponent_defections_in_last_N_rounds.pop(0)
        current_round_1_indexed = state.round_number + 1
        n_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round_1_indexed >= n_rounds - self.k_endgame_rounds + 1:
            return Action.D
        if state.round_number == 0:
            return Action.D
        num_opponents = n_players - 1
        proportion_opponents_defecting: float = 0.0
        if self.opponent_defections_in_last_N_rounds:
            avg_opponent_defections = sum(self.opponent_defections_in_last_N_rounds) / len(self.opponent_defections_in_last_N_rounds)
            proportion_opponents_defecting = avg_opponent_defections / num_opponents
        my_consumption_if_D = current_stock / n_players
        opponent_consumption_from_defectors = proportion_opponents_defecting * num_opponents * (current_stock / n_players)
        opponent_consumption_from_cooperators = (1 - proportion_opponents_defecting) * num_opponents * (current_stock / (2 * n_players))
        total_opponent_consumption = opponent_consumption_from_defectors + opponent_consumption_from_cooperators
        total_consumption_if_i_defect = my_consumption_if_D + total_opponent_consumption
        S_after_consumption_if_i_defect = max(0.0, current_stock - total_consumption_if_i_defect)
        growth_if_i_defect = 2 * S_after_consumption_if_i_defect * (1 - S_after_consumption_if_i_defect / capacity)
        projected_next_stock_if_i_defect = min(S_after_consumption_if_i_defect + growth_if_i_defect, capacity)
        if projected_next_stock_if_i_defect < self.stock_recovery_threshold_factor * capacity:
            return Action.C
        elif proportion_opponents_defecting >= self.opponent_defection_threshold_factor:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_37(BaseStrategy):
    """
    Adaptive Exploiter strategy for the Common Pool Resource Game.
    Prioritizes self-interest, defects when stock is high or opponents cooperate,
    and cooperates only for self-preservation of the resource or when too many
    others are defecting. Includes specific endgame logic to maximize final gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_recovery_threshold_percent = 0.25
        self.aggressive_defection_threshold_percent = 0.75
        self.opponent_defection_tolerance = max(1, math.floor(self.n_players / 4))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.C
        d_count_prev = 0
        if history is not None and state.round_number > 0:
            num_opponent_cooperators_prev = sum(history.opponent_actions[state.round_number - 1, :])
            num_opponent_defectors_prev = self.n_players - 1 - num_opponent_cooperators_prev
            my_action_prev_was_C = history.my_actions[state.round_number - 1]
            my_action_prev_was_D = not my_action_prev_was_C
            d_count_prev = num_opponent_defectors_prev + (1 if my_action_prev_was_D else 0)
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_round_1_indexed == self.n_rounds - 1 and current_stock >= self.capacity * self.aggressive_defection_threshold_percent:
            return Action.D
        if current_stock < self.capacity * self.stock_recovery_threshold_percent:
            return Action.C
        if current_stock >= self.capacity * self.aggressive_defection_threshold_percent:
            return Action.D
        if d_count_prev <= self.opponent_defection_tolerance:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_38(BaseStrategy):
    """
    The Adaptive Stock Predator is a ruthless but intelligent exploiter. It will take as much as it can,
    as often as it can, believing that if others are cooperating, it should benefit from their restraint,
    and if others are defecting, it should claim its share before the resource is depleted.
    However, it's not suicidal; if the resource is on the brink of collapse, it will make a calculated move
    to preserve it just enough to ensure it can continue to extract value in future rounds, or at least
    maximize its last few opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = self.capacity / (2 * self.n)
        self.defector_tolerance_threshold = math.ceil((self.n - 1) / 2)
        self.unhealthy_stock_level = 0.75 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number_zero_indexed = state.round_number
        current_stock_level = state.current_stock
        current_round_one_indexed = current_round_number_zero_indexed + 1
        defectors_last_round = 0
        if current_round_one_indexed > 1 and history is not None:
            defectors_last_round = np.sum(history.opponent_actions[current_round_number_zero_indexed - 1, :] == False)
        if current_round_one_indexed == self.r:
            return Action.D
        if current_stock_level < self.critical_stock_threshold:
            return Action.C
        if current_round_one_indexed == 1:
            return Action.D
        elif defectors_last_round > self.defector_tolerance_threshold and current_stock_level < self.unhealthy_stock_level:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_39(BaseStrategy):
    """
    The Adaptive Opportunist strategy is designed to be highly exploitative,
    maximizing its own total payoff over the game's rounds. It defaults to aggressive
    defection but incorporates adaptive elements to prevent total resource collapse
    and to strategically leverage periods of opponent cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        stock = state.current_stock
        current_round_1_indexed = current_round_0_indexed + 1
        if current_round_1_indexed == r:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        last_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        C_prev = np.sum(last_round_opponent_actions)
        D_prev = n - 1 - C_prev
        CRITICAL_LOW_STOCK_THRESHOLD = capacity / n
        MODERATE_LOW_STOCK_THRESHOLD = capacity / 2
        if stock < CRITICAL_LOW_STOCK_THRESHOLD:
            if D_prev == n - 1:
                return Action.D
            else:
                return Action.C
        elif stock < MODERATE_LOW_STOCK_THRESHOLD:
            if C_prev == n - 1:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_40(BaseStrategy):
    """
    Opportunistic Free-Rider (OFR) strategy for the Common Pool Resource game.
    This strategy aims to maximize individual payoff by free-riding on others' cooperation,
    defecting when the resource is robust, and only cooperating as a tactical measure
    to prevent total resource collapse or to "reset" cooperation among players.
    It aggressively defects in the final round, as future stock is irrelevant.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_CRITICAL_LOW = 0.25 * self.game_description.capacity
        self.S_CRITICAL_RECOVERY = 0.5 * self.game_description.capacity
        self.EPSILON_STOCK_DECLINE = 0.01 * self.game_description.capacity
        self.survival_mode = False
        self.previous_stock: float | None = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_idx = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        if current_round_idx == total_rounds - 1:
            self.previous_stock = current_stock
            return Action.D
        if current_stock < self.S_CRITICAL_LOW:
            self.survival_mode = True
        elif current_stock >= self.S_CRITICAL_RECOVERY:
            self.survival_mode = False
        if self.survival_mode:
            self.previous_stock = current_stock
            return Action.C
        if current_round_idx == 0:
            self.previous_stock = current_stock
            return Action.D
        if self.previous_stock is None:
            pass
        opponent_actions_previous_round = history.opponent_actions[-1, :]
        num_cooperators_prev_round = np.sum(opponent_actions_previous_round)
        if num_cooperators_prev_round > (n_players - 1) / 2:
            self.previous_stock = current_stock
            return Action.D
        elif current_stock < self.previous_stock - self.EPSILON_STOCK_DECLINE:
            self.previous_stock = current_stock
            return Action.C
        else:
            self.previous_stock = current_stock
            return Action.D

class Strategy_EXPLOITATIVE_41(BaseStrategy):
    """
    The "Adaptive Exploiter" strategy prioritizes immediate gains by defecting, but implements safeguards
    to prevent total resource depletion if opponents are willing to cooperate, thereby preserving
    future exploitation opportunities. It's aggressive, opportunistic, and adapts to opponent behavior
    and stock levels. In the final stages, all caution is abandoned for maximum short-term gain.
    """
    CRITICAL_STOCK_THRESHOLD_FACTOR: float
    OPPONENT_COOPERATION_TOLERANCE: float
    FINAL_ROUNDS_THRESHOLD: int

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD_FACTOR = 0.25
        self.OPPONENT_COOPERATION_TOLERANCE = 0.5
        self.FINAL_ROUNDS_THRESHOLD = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if total_rounds - current_round <= self.FINAL_ROUNDS_THRESHOLD:
            return Action.D
        num_other_cooperators = np.sum(history.opponent_actions[-1, :])
        opponent_cooperation_rate = num_other_cooperators / (n - 1)
        is_stock_critically_low = current_stock < capacity * self.CRITICAL_STOCK_THRESHOLD_FACTOR
        if is_stock_critically_low:
            if opponent_cooperation_rate >= self.OPPONENT_COOPERATION_TOLERANCE:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_42(BaseStrategy):
    """
    Adaptive Predator strategy for the Common Pool Resource game.
    This strategy aims to maximize personal gain by defaulting to defection,
    but with strategic, limited cooperation only under specific conditions
    where it's necessary to either prevent a total resource collapse or
    to allow for resource recovery when opponents show signs of restraint,
    ultimately to enable further exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_panic_threshold_factor = 0.1
        self.stock_recovery_trigger_factor = 0.5
        self.opponent_tolerance_threshold_ratio = 0.3
        self.endgame_horizon = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        if current_round_1_indexed >= total_rounds - self.endgame_horizon + 1:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        my_prev_action_was_D = not history.my_actions[-1]
        opponent_prev_defectors_count = np.sum(~history.opponent_actions[-1, :])
        total_defectors_prev_round = int(my_prev_action_was_D) + opponent_prev_defectors_count
        panic_stock_level = capacity * self.stock_panic_threshold_factor
        recovery_stock_level = capacity * self.stock_recovery_trigger_factor
        max_tolerable_defectors = math.floor(n_players * self.opponent_tolerance_threshold_ratio)
        if current_stock < panic_stock_level and total_defectors_prev_round <= 1:
            return Action.C
        if current_stock < recovery_stock_level and total_defectors_prev_round <= max_tolerable_defectors:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_43(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize individual payoff by defaulting to defection,
    exploiting others' cooperation, and only cooperating for self-preservation when the resource
    is critically threatened. It adapts its behavior based on current stock levels and observed
    opponent cooperation from recent rounds.

    Core Principles:
    1. Default to Defection: Always prioritize immediate higher payoff by defecting.
    2. Exploit Others' Cooperation: If others cooperate, continue to defect to maximize share.
    3. Self-Preservation over Altruism: Cooperate only when the resource is critically threatened
       to prevent collapse and ensure future exploitation potential.
    4. No Future, No Restraint: In the final round, defect maximally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self._critical_stock_level = self.capacity * 0.25
        self._very_low_stock_level = self.capacity * 0.1
        self._opponent_cooperation_memory_length = min(self.n_rounds - 1, 3)
        self._high_cooperation_percentage = 0.7
        self._game_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        if history is not None and current_round_0_indexed > 0:
            n = self.n_players
            my_action_bool_prev = history.my_actions[-1]
            my_payoff_prev = history.my_payoffs[-1]
            stock_at_start_prev = 0.0
            if my_payoff_prev > 0:
                if my_action_bool_prev:
                    stock_at_start_prev = my_payoff_prev * (2 * n)
                else:
                    stock_at_start_prev = my_payoff_prev * n
            total_consumption_prev = my_payoff_prev + np.sum(history.opponent_payoffs[-1, :])
            self._game_history.append((current_round_0_indexed - 1, stock_at_start_prev, total_consumption_prev, my_action_bool_prev, my_payoff_prev))
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        num_observations = 0
        sum_cooperating_others_count = 0
        relevant_history = self._game_history[-self._opponent_cooperation_memory_length:]
        n_players_minus_one = self.n_players - 1
        for _, hist_stock_start, hist_total_consumption, _, hist_my_payoff in relevant_history:
            if hist_stock_start > 0:
                consumption_C_val = hist_stock_start / (2 * self.n_players)
                consumption_D_val = hist_stock_start / self.n_players
                total_consumption_by_others = hist_total_consumption - hist_my_payoff
                num_cooperating_others_raw = (n_players_minus_one * consumption_D_val - total_consumption_by_others) / (consumption_D_val - consumption_C_val)
                num_cooperating_others = max(0, min(n_players_minus_one, round(num_cooperating_others_raw)))
                sum_cooperating_others_count += num_cooperating_others
                num_observations += 1
            else:
                sum_cooperating_others_count += 0
                num_observations += 1
        avg_cooperation_percentage = 0.0
        if num_observations > 0 and n_players_minus_one > 0:
            avg_cooperation_percentage = sum_cooperating_others_count / num_observations / n_players_minus_one
        current_stock_S_t = state.current_stock
        if current_stock_S_t <= self._very_low_stock_level:
            return Action.C
        elif current_stock_S_t <= self._critical_stock_level:
            if avg_cooperation_percentage >= self._high_cooperation_percentage:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_44(BaseStrategy):
    """
    The "Adaptive Exploitation with Resource Safeguard" strategy.

    This strategy aims to maximize its own total payoff by primarily defecting.
    However, it incorporates adaptive safeguards to cooperate under specific conditions
    to prevent resource collapse, stabilize the common pool, and subtly influence
    opponents towards more cooperative behavior, ultimately maintaining opportunities
    for the strategy's own future exploitation. Cooperation is a calculated,
    self-interested move, not an altruistic one, viewed as an investment in the
    resource's longevity.

    Decision rules are hierarchical:
    1. Endgame Exploitation (Last Round): Always Defect.
    2. Initial Assessment (First Round): Always Cooperate to gather data and preserve initial stock.
    3. Adaptive Play (Intermediate Rounds): Default to Defect, but switch to Cooperate if:
       a. Critical Resource Depletion: Current stock falls below 35% of capacity.
       b. Immediate Collective Greed: More than 50% of opponents defected in the prior round.
       c. Sustained Opponent Greed with Declining Resource: Opponent Greed Index (OGI) > 60%
          AND current stock is below 70% of capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.n_opponents = self.n_players - 1
        self.CRITICAL_STOCK_RATIO = 0.35
        self.RECENT_DEFECTION_THRESHOLD_RATIO = 0.5
        self.LONG_TERM_GREED_OGI_THRESHOLD = 0.6
        self.ROBUST_STOCK_FOR_OGI_THRESHOLD = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.total_rounds:
            return Action.D
        if state.round_number == 0:
            return Action.C
        prev_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        num_opponents_defected_prev_round = np.sum(~prev_round_opponent_actions)
        total_opponent_actions_observed = state.round_number * self.n_opponents
        total_opponent_defections_observed = np.sum(~history.opponent_actions)
        OGI = total_opponent_defections_observed / total_opponent_actions_observed
        RHM = state.current_stock / self.capacity
        if RHM < self.CRITICAL_STOCK_RATIO:
            return Action.C
        if num_opponents_defected_prev_round > self.n_opponents * self.RECENT_DEFECTION_THRESHOLD_RATIO:
            return Action.C
        if OGI > self.LONG_TERM_GREED_OGI_THRESHOLD and RHM < self.ROBUST_STOCK_FOR_OGI_THRESHOLD:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_45(BaseStrategy):
    """
    Adaptive Predator strategy for the Common Pool Resource game.
    This strategy prioritizes maximizing its own total payoff, adapting actions
    based on the current resource state and observed opponent behavior.
    It operates on core principles of exploitation by default, self-preservation
    at critical resource levels, strategic lulling when opponents are highly
    cooperative, and endgame greed.

    Assumption regarding stock state: The strategy assumes the intended range for `stock`
    is `0 <= stock <= capacity`, aligning with the provided examples and standard
    common pool resource models, despite a potential discrepancy in the game specification.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold = self.game_description.capacity / (self.game_description.n_players + 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number + 1
        current_stock = state.current_stock
        if current_round == self.game_description.n_rounds:
            return Action.D
        if current_stock <= self.critical_stock_threshold:
            return Action.C
        average_opponent_defection_rate = 0.0
        if current_round > 1:
            total_opponent_defections = np.sum(~history.opponent_actions)
            total_opponent_actions = history.opponent_actions.size
            average_opponent_defection_rate = total_opponent_defections / total_opponent_actions
        if average_opponent_defection_rate == 0.0 and current_stock > self.game_description.capacity / 2 and (self.game_description.n_rounds - current_round > self.game_description.n_players):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_47(BaseStrategy):
    """
    Adaptive Exploiter strategy for the Common Pool Resource Game.

    This strategy aims to maximize total payoff by strategically exploiting other
    players' cooperation when the resource is healthy, cooperating to prevent
    resource collapse, and defecting aggressively when the resource is deemed
    unsalvageable or the game is ending. It adapts its behavior based on the
    current stock level and the recent collective action of opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_ratio = 0.25
        self.exploitation_threshold_high_stock = 0.5
        self.cooperation_threshold_low_stock = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if state.round_number == 0:
            return Action.C
        prev_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        num_other_cooperators = np.sum(prev_round_opponent_actions)
        AOCR = num_other_cooperators / (self.n_players - 1)
        critical_stock_threshold = self.capacity * self.critical_stock_ratio
        if current_stock < critical_stock_threshold:
            if AOCR >= self.cooperation_threshold_low_stock:
                return Action.C
            else:
                return Action.D
        elif AOCR >= self.exploitation_threshold_high_stock:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_48(BaseStrategy):
    """
    The Strategic Opportunist: An exploitative strategy for the Common Pool Resource game.
    It prioritizes immediate gain and free-riding but will strategically cooperate if it
    believes doing so can lead to greater long-term payoffs for itself.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.STOCK_HEALTHY_THRESHOLD = self.capacity / 2
        self.STOCK_MODERATE_THRESHOLD = self.capacity / self.n_players
        self.OTHERS_HIGH_DEFECTION_THRESHOLD = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        defection_count_others_prev_round = np.sum(history.opponent_actions[-1, :] == False)
        defection_ratio_others = defection_count_others_prev_round / (self.n_players - 1)
        current_stock = state.current_stock
        if current_stock > self.STOCK_HEALTHY_THRESHOLD:
            return Action.D
        elif current_stock > self.STOCK_MODERATE_THRESHOLD:
            if defection_ratio_others >= self.OTHERS_HIGH_DEFECTION_THRESHOLD:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_49(BaseStrategy):
    """
    The Conditional Predator strategy prioritizes defection (D) to maximize immediate payoffs.
    It strategically cooperates (C) only as a self-preservation mechanism to prevent resource
    collapse, which would lead to zero future payoffs. The strategy observes and reacts to
    opponent behavior primarily to determine whether to continue exploiting or to join a
    "race to the bottom," rather than to foster cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold_ratio = 0.15
        self.opponent_defection_threshold_low = 0.3
        self.opponent_defection_threshold_high = 0.7
        self.memory_depth = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        num_players = self.game_description.n_players
        if current_round == total_rounds - 1:
            return Action.D
        min_consumption_for_growth = capacity / num_players
        critical_stock_level = max(capacity * self.critical_stock_threshold_ratio, min_consumption_for_growth)
        if current_stock <= critical_stock_level:
            return Action.C
        if current_round == 0:
            return Action.D
        start_idx_for_avg = max(0, current_round - self.memory_depth)
        recent_opponent_actions = history.opponent_actions[start_idx_for_avg:current_round, :]
        sum_opponent_defections = np.sum(recent_opponent_actions == False)
        num_opponents = num_players - 1
        total_opponent_actions_considered = recent_opponent_actions.shape[0] * num_opponents
        if total_opponent_actions_considered == 0:
            avg_opponent_defection_rate = 0.5
        else:
            avg_opponent_defection_rate = sum_opponent_defections / total_opponent_actions_considered
        if avg_opponent_defection_rate < self.opponent_defection_threshold_low:
            return Action.D
        elif avg_opponent_defection_rate > self.opponent_defection_threshold_high:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_50(BaseStrategy):
    """
    The Calculated Predator strategy aims to maximize its own total payoff by defaulting
    to Defect, an individually profitable action. It strategically cooperates only when
    the common resource is critically low to prevent its complete collapse, thereby
    ensuring future opportunities for exploitation. It also defects aggressively
    in the initial and final rounds for maximum short-term gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        self.critical_stock_ratio = 1.0 / (n * 2)
        self.final_sprint_rounds = 3
        self.critical_stock_level = self.game_description.capacity * self.critical_stock_ratio

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round_1_indexed == total_rounds:
            return Action.D
        if current_round_1_indexed > total_rounds - self.final_sprint_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        elif current_stock <= self.critical_stock_level:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_51(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its own total payoff over `r` rounds.
    It defaults to defecting (Action.D) for immediate gain. It only cooperates (Action.C)
    if its own defection, combined with expected opponent actions, would cause an immediate
    and complete collapse of the resource stock that it could realistically prevent, AND
    if a significant portion (at least half) of opponents also showed willingness to
    conserve in the previous round. If the resource is deemed doomed by others'
    actions (or if its cooperation alone is insufficient), it joins the depletion.
    It plays 'D' in the first round to establish an aggressive stance and in the last round
    for maximum immediate gain with no future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        EPSILON = 1e-09
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        else:
            last_round_opponent_actions = history.opponent_actions[-1, :]
            num_opponents_cooperated_prev = np.sum(last_round_opponent_actions)
            num_opponents_defected_prev = self.n_players - 1 - num_opponents_cooperated_prev
            my_consumption_if_D = current_stock / self.n_players
            total_consumption_by_others = num_opponents_cooperated_prev * current_stock / (2 * self.n_players) + num_opponents_defected_prev * current_stock / self.n_players
            projected_total_consumption_if_I_D = my_consumption_if_D + total_consumption_by_others
            projected_S_remaining_if_I_D = current_stock - projected_total_consumption_if_I_D
            my_consumption_if_C = current_stock / (2 * self.n_players)
            projected_total_consumption_if_I_C = my_consumption_if_C + total_consumption_by_others
            projected_S_remaining_if_I_C = current_stock - projected_total_consumption_if_I_C
            if projected_S_remaining_if_I_D <= EPSILON:
                if projected_S_remaining_if_I_C > EPSILON and num_opponents_cooperated_prev >= (self.n_players - 1) / 2:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_52(BaseStrategy):
    """
    The Adaptive Opportunist aims to maximize its cumulative payoff by defaulting to aggressive resource extraction (defecting).
    It strategically cooperates only when absolutely necessary to prevent resource collapse (which would harm its future payoffs)
    or to temporarily mitigate overwhelming collective defection from opponents that threatens the long-term viability of the resource.
    It is designed to exploit cooperative behavior from others whenever possible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.low_stock_ratio: float = 0.25
        self.defection_threshold_others: int = math.floor((self.game_description.n_players - 1) / 2) + 1
        self.max_tolerance_rounds_for_my_D: int = 2
        self.consecutive_high_defection_rounds_when_I_D: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        action_for_this_round: Action
        if current_round == total_rounds - 1:
            action_for_this_round = Action.D
        elif current_stock <= self.low_stock_ratio * capacity:
            action_for_this_round = Action.C
            self.consecutive_high_defection_rounds_when_I_D = 0
        elif current_round == 0:
            action_for_this_round = Action.D
        else:
            num_D_others_prev = 0
            for action_val_bool in history.opponent_actions[-1, :]:
                if not action_val_bool:
                    num_D_others_prev += 1
            my_last_action_was_D = not history.my_actions[-1]
            if my_last_action_was_D:
                if num_D_others_prev >= self.defection_threshold_others:
                    self.consecutive_high_defection_rounds_when_I_D += 1
                    if self.consecutive_high_defection_rounds_when_I_D >= self.max_tolerance_rounds_for_my_D:
                        action_for_this_round = Action.C
                        self.consecutive_high_defection_rounds_when_I_D = 0
                    else:
                        action_for_this_round = Action.D
                else:
                    self.consecutive_high_defection_rounds_when_I_D = 0
                    action_for_this_round = Action.D
            else:
                self.consecutive_high_defection_rounds_when_I_D = 0
                action_for_this_round = Action.D
        return action_for_this_round

class Strategy_EXPLOITATIVE_53(BaseStrategy):
    """
    The Adaptive Opportunist strategy is designed to be highly exploitative in a common pool
    resource game. It prioritizes its own cumulative payoff by aggressively defecting when
    resources are abundant or opponents cooperate, and only resorting to cooperation as a
    strategic self-preservation measure to ensure future exploitation opportunities when
    the common resource is critically endangered. It adapts to both the resource's health
    and observed opponent behavior, accelerating exploitation in the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_critical_low_ratio = 0.1
        self.S_critical_high_ratio = 0.8
        self.Cooperation_Tolerance_Threshold = 0.5
        self.Endgame_Horizon_rounds = self.game_description.n_players
        self._critical_low_stock_level = self.game_description.capacity * self.S_critical_low_ratio
        self._critical_high_stock_level = self.game_description.capacity * self.S_critical_high_ratio

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_round_number == 0:
            return Action.D
        if current_round_number == total_rounds - 1:
            return Action.D
        k_t_minus_1 = sum(history.opponent_actions[-1, :])
        p_cooperate_others = k_t_minus_1 / (n_players - 1)
        if current_stock <= self._critical_low_stock_level:
            return Action.C
        elif current_stock >= self._critical_high_stock_level:
            return Action.D
        elif total_rounds - current_round_number <= self.Endgame_Horizon_rounds:
            return Action.D
        elif p_cooperate_others >= self.Cooperation_Tolerance_Threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_54(BaseStrategy):
    """
    The Opportunistic Shark strategy for the Common Pool Resource Game.
    Prioritizes individual payoff maximization by defaulting to Defect (D).
    It will strategically Cooperate (C) only to prevent resource collapse
    when the stock is critically low AND a sufficient majority of opponents
    are also cooperating to make recovery viable.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD_LOW = 0.2 * self.capacity
        self.COOPERATOR_THRESHOLD = 0.65
        if self.n_rounds == 1:
            self.num_endgame_rounds_from_end = 0
        else:
            self.num_endgame_rounds_from_end = min(5, self.n_rounds - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        total_players = self.n_players
        total_rounds = self.n_rounds
        if current_round_0_indexed >= total_rounds - self.num_endgame_rounds_from_end:
            return Action.D
        last_round_opponent_cooperation_count = 0
        if current_round_0_indexed > 0:
            previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
            last_round_opponent_cooperation_count = np.sum(previous_round_opponent_actions)
        num_opponents = total_players - 1
        opponent_cooperation_ratio = 0.0
        if num_opponents > 0:
            opponent_cooperation_ratio = last_round_opponent_cooperation_count / num_opponents
        else:
            opponent_cooperation_ratio = 1.0
        if current_stock < self.CRITICAL_STOCK_THRESHOLD_LOW:
            if opponent_cooperation_ratio >= self.COOPERATOR_THRESHOLD:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_55(BaseStrategy):
    """
    Opportunistic Predator Strategy for the Common Pool Resource Game.

    This strategy continuously monitors the collective behavior of opponents
    and the current state of the common stock. It employs aggressive defection
    when opportunities for exploitation arise (e.g., others are cooperative,
    or the game is ending) but will strategically cooperate if the stock is
    critically low AND there's a strong signal that others might also
    cooperate to allow recovery, which can then be exploited later.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.FREE_RIDE_COOPERATION_THRESHOLD: float = 0.7
        self.DOOMED_STOCK_THRESHOLD: float = self.game_description.capacity / (self.game_description.n_players * 4)
        self.LAST_FEW_ROUNDS: int = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        opponent_cooperation_rate: float = 0.5
        if history is not None and current_round_0_indexed > 0:
            opponent_C_count = np.sum(history.opponent_actions)
            total_opponent_actions = history.opponent_actions.size
            if total_opponent_actions > 0:
                opponent_cooperation_rate = opponent_C_count / total_opponent_actions
        if current_round_1_indexed == n_rounds:
            return Action.D
        if current_round_1_indexed >= n_rounds - self.LAST_FEW_ROUNDS:
            return Action.D
        if current_stock <= self.DOOMED_STOCK_THRESHOLD:
            if opponent_cooperation_rate >= self.FREE_RIDE_COOPERATION_THRESHOLD:
                return Action.C
            else:
                return Action.D
        elif opponent_cooperation_rate >= self.FREE_RIDE_COOPERATION_THRESHOLD:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_56(BaseStrategy):
    """
    The "Adaptive Exploiter" strategy is designed to maximize its own cumulative payoff by primarily defecting,
    but intelligently cooperating when necessary to prevent the complete collapse of the common resource,
    thereby preserving future exploitation opportunities. It adapts to both the state of the resource and
    the collective behavior of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Exploiter strategy with game-specific parameters.

        Args:
            game_description (CommonPoolDescription): An object containing game parameters
                                                     like n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.S_threshold_cooperate = self.game_description.capacity / 4.0
        self.C_majority_threshold = math.ceil((self.game_description.n_players - 1) / 2.0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides on an action ('C' for Cooperate or 'D' for Defect) based on the
        current game state and historical actions.

        Args:
            state (CommonPoolState): The current state of the game, including round_number
                                     and current_stock.
            history (None | PlayerHistory): Past actions and payoffs of this player and opponents.
                                            None for the very first round (round_number == 0).

        Returns:
            Action: The chosen action, Action.C or Action.D.
        """
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.game_description.n_rounds:
            return Action.D
        if state.round_number == 0:
            return Action.D
        num_other_players_cooperating_last_round = sum(history.opponent_actions[state.round_number - 1, :])
        resource_is_critical = state.current_stock < self.S_threshold_cooperate
        others_showed_collective_effort = num_other_players_cooperating_last_round >= self.C_majority_threshold
        if resource_is_critical and others_showed_collective_effort:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_57(BaseStrategy):
    """
    The Adaptive Predator strategy for the Common Pool Resource game.
    This strategy prioritizes immediate self-gain by defecting, but adapts to
    resource levels and opponent behavior to prevent complete collapse when it
    might harm future profits, or to free-ride on cooperative opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD = 0.2
        self.SEVERE_DEFECTION_THRESHOLD = 0.8
        self.MODERATE_DEFECTION_THRESHOLD = 0.4
        self.TOLERANCE_WINDOW_FOR_COLLAPSE = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        avg_opponent_defection_rate = 0.5
        if current_round > 0 and history is not None:
            total_past_opponent_defections = np.sum(~history.opponent_actions)
            total_possible_opponent_actions = history.opponent_actions.size
            avg_opponent_defection_rate = total_past_opponent_defections / total_possible_opponent_actions
        if current_round >= total_rounds - self.TOLERANCE_WINDOW_FOR_COLLAPSE:
            return Action.D
        if current_stock < capacity * self.CRITICAL_STOCK_THRESHOLD:
            if avg_opponent_defection_rate > self.SEVERE_DEFECTION_THRESHOLD:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_58(BaseStrategy):
    """
    Opportunistic Stock Manager (OSM) strategy for the Common Pool Resource game.

    This strategy aims to maximize its own total payoff by defecting whenever possible,
    but strategically cooperates under specific conditions to ensure the long-term
    viability of the resource and future exploitation opportunities, or to "lure"
    other players into cooperative patterns.

    The decision process follows a hierarchy of phases, with earlier phases taking
    precedence:
    1. Last Round Always Defect: Maximize final round payoff without consequences.
    2. Critical Stock Safeguard: Cooperate to prevent resource collapse if stock is too low.
    3. Endgame Pressure: Defect in the final rounds to maximize remaining gains.
    4. First Round - Initial Probe: Start aggressively to establish exploitative stance.
    5. Adaptive Luring and Exploitation (Mid-Game): Analyze opponent behavior and
       projected stock impact to decide between exploitation (defect) or
       luring/preservation (cooperate). Default to defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number + 1
        current_stock_S = state.current_stock
        if current_round_t == self.r:
            return Action.D
        S_critical_low = max(2.0 * self.n, self.capacity / (self.r * 2.0))
        if current_stock_S < S_critical_low:
            return Action.C
        if self.r - current_round_t <= max(2.0, self.n / 2.0):
            return Action.D
        if current_round_t == 1:
            return Action.D
        if history is None:
            return Action.D
        opponent_actions_in_prev_round = history.opponent_actions[state.round_number - 1, :]
        num_C_others_prev_round = np.sum(opponent_actions_in_prev_round)
        num_D_others_prev_round = self.n - 1 - num_C_others_prev_round
        my_consumption_if_D = current_stock_S / self.n
        consumption_by_others_if_D_prev_round_pattern = num_D_others_prev_round * (current_stock_S / self.n)
        consumption_by_others_if_C_prev_round_pattern = num_C_others_prev_round * (current_stock_S / (2.0 * self.n))
        total_consumption_hypothetical_if_I_D = my_consumption_if_D + consumption_by_others_if_D_prev_round_pattern + consumption_by_others_if_C_prev_round_pattern
        S_remaining_hypothetical_if_I_D = current_stock_S - total_consumption_hypothetical_if_I_D
        S_remaining_for_growth = max(0.0, S_remaining_hypothetical_if_I_D)
        growth_hypothetical = 2.0 * S_remaining_for_growth * (1.0 - S_remaining_for_growth / self.capacity)
        next_stock_hypothetical_if_I_D = min(S_remaining_for_growth + growth_hypothetical, self.capacity)
        if num_C_others_prev_round > num_D_others_prev_round:
            return Action.D
        if next_stock_hypothetical_if_I_D < current_stock_S * 0.95 and current_stock_S < self.capacity * 0.8:
            return Action.C
        if num_D_others_prev_round >= (self.n - 1) * 0.9:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_59(BaseStrategy):
    """
    The Adaptive Exploiter strategy for the Common Pool Resource game.
    It primarily defects to maximize immediate payoff, only cooperating when the
    common pool resource is critically low to prevent its collapse and
    preserve future exploitation opportunities. This strategy is robust
    as it does not rely on assumptions about opponent altruism or cooperation,
    and directly reacts to observed resource levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_critical_cooperate = self.capacity / (2 * self.n)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.r:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        if current_stock <= self.S_critical_cooperate:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_60(BaseStrategy):
    """
    The Opportunist strategy aims to maximize total personal payoff across all rounds.
    It strongly biases towards immediate gain (defecting) but tactically safeguards
    the common resource if its collapse would significantly harm future personal
    payoffs, and only if others are also contributing to that safeguard. It does not
    rely on shared norms or pre-coordination, prioritizing self-interest at every turn.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.CRITICAL_STOCK_THRESHOLD = float(self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        num_opponents_cooperated_prev_round = np.sum(history.opponent_actions[current_round - 1, :])
        num_opponents_defected_prev_round = self.n_players - 1 - num_opponents_cooperated_prev_round
        opponent_defection_rate = num_opponents_defected_prev_round / (self.n_players - 1)
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            if opponent_defection_rate < 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_61(BaseStrategy):
    """
    The Adaptive Free-Rider strategy for the Common Pool Resource game.
    It prioritizes individual gain by defaulting to Defect ('D'), adapting its
    behavior to Cooperate ('C') only when the common stock is critically low,
    or when its own predicted defection would lead to a critically low stock.
    This mechanism ensures self-preservation of the resource for future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = max(self.n_players * 2.0, self.capacity / (4.0 * self.n_players))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number + 1
        current_stock_S = state.current_stock
        if current_round_t == self.n_rounds:
            return Action.D
        if current_round_t == 1:
            return Action.D
        prev_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        num_C_others_last_round = np.sum(prev_round_opponent_actions)
        num_D_others_last_round = self.n_players - 1 - num_C_others_last_round
        if current_stock_S < self.critical_stock_threshold:
            return Action.C
        else:
            my_hypothetical_consumption = current_stock_S / self.n_players
            estimated_others_consumption = num_D_others_last_round * (current_stock_S / self.n_players) + num_C_others_last_round * (current_stock_S / (2 * self.n_players))
            estimated_total_consumption = my_hypothetical_consumption + estimated_others_consumption
            estimated_S_after_consumption = current_stock_S - estimated_total_consumption
            if estimated_S_after_consumption < self.critical_stock_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_62(BaseStrategy):
    """
    The Resource Harvester strategy aims to maximize individual cumulative payoff by
    aggressively exploiting the common pool resource. It defaults to Defect (taking the
    largest share) unless doing so would lead to an immediate and permanent collapse of
    the resource, or if it's the final round where future sustainability is irrelevant.
    It adapts by switching to cooperation only when the resource stock falls below a
    critical threshold, a self-serving act to ensure the resource's existence for future
    exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold: float = self.game_description.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round: int = state.round_number
        total_rounds: int = self.game_description.n_rounds
        current_stock: float = state.current_stock
        if current_round == total_rounds - 1:
            return Action.D
        if current_stock <= self.critical_stock_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_63(BaseStrategy):
    """
    The Relentless Exploiter strategy defaults to defection to maximize immediate gains,
    but strategically cooperates if the shared resource is in danger of collapsing AND
    there's a collective effort from other players to save it. It balances aggressive
    self-interest with a critical survival mechanism, avoiding resource collapse only
    when collaboration is evident and necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_ratio: float = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.D
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        k_C_others_prev = sum(history.opponent_actions[state.round_number - 1, :])
        is_stock_critically_low = state.current_stock < self.capacity * self.critical_stock_ratio
        if is_stock_critically_low:
            if k_C_others_prev >= (self.n_players - 1) / 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_64(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its total payoff in the Common Pool Resource game.
    It defaults to defection, exploiting cooperative behavior from others or a healthy resource stock.
    It strategically cooperates only when the resource is critically endangered and its defection
    would lead to immediate collapse, or when a temporary cooperative investment is needed to
    prevent long-term resource depletion for future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.STOCK_CRITICAL_THRESHOLD = self.capacity / 4.0
        self.COOPERATION_EXPECTATION_THRESHOLD = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        n_players = self.n
        total_rounds = self.r
        if current_round_1_indexed == total_rounds:
            return Action.D
        if state.round_number == 0:
            return Action.D
        num_other_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
        proportion_other_cooperators = num_other_cooperators_last_round / (n_players - 1.0)
        is_stock_critical = current_stock <= self.STOCK_CRITICAL_THRESHOLD
        if is_stock_critical:
            my_consumption_if_D = current_stock / n_players
            consumption_by_other_cooperators = num_other_cooperators_last_round * (current_stock / (2.0 * n_players))
            num_other_defectors_last_round = n_players - 1 - num_other_cooperators_last_round
            consumption_by_other_defectors = num_other_defectors_last_round * (current_stock / n_players)
            hypothetical_total_consumption_if_I_D = my_consumption_if_D + consumption_by_other_cooperators + consumption_by_other_defectors
            hypothetical_S_remaining_if_I_D = current_stock - hypothetical_total_consumption_if_I_D
            if hypothetical_S_remaining_if_I_D <= 0:
                return Action.C
            elif proportion_other_cooperators < self.COOPERATION_EXPECTATION_THRESHOLD:
                return Action.C
            else:
                return Action.D
        elif proportion_other_cooperators >= self.COOPERATION_EXPECTATION_THRESHOLD:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_65(BaseStrategy):
    """
    The Opportunistic Predator strategy aims to maximize its total individual payoff by primarily defecting.
    It strategically cooperates only when the common resource stock is critically low and a sufficient
    number of other players are also showing restraint, allowing for a recovery that can be exploited later.
    This cooperation is a purely selfish investment in future personal gain, not altruism.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_critical = self.capacity / self.n
        self.D_rate_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.D
        if round_number == self.r - 1:
            return Action.D
        if current_stock >= self.S_critical:
            return Action.D
        else:
            previous_round_opponent_actions = history.opponent_actions[round_number - 1, :]
            num_cooperators_last_round = previous_round_opponent_actions.sum()
            num_defectors_last_round = self.n - 1 - num_cooperators_last_round
            D_rate = num_defectors_last_round / (self.n - 1)
            if D_rate >= self.D_rate_threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_66(BaseStrategy):
    """
    Opportunistic Predator strategy: Prioritizes defection for immediate gain,
    but cooperates to prevent total resource collapse if its defection, combined
    with others' observed behavior, would lead to stock depletion.
    It defects in the first and last rounds, regardless of observed behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.r - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        else:
            opponent_actions_prev_round = history.opponent_actions[current_round_0_indexed - 1]
            c_opponents_prev_round = opponent_actions_prev_round.sum()
            d_opponents_prev_round = self.n - 1 - c_opponents_prev_round
            my_consumption_if_d = current_stock / self.n
            opponents_total_consumption_if_mirror = d_opponents_prev_round * (current_stock / self.n) + c_opponents_prev_round * (current_stock / (2 * self.n))
            total_consumption_if_i_d_and_mirror = my_consumption_if_d + opponents_total_consumption_if_mirror
            if current_stock - total_consumption_if_i_d_and_mirror <= 0:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_67(BaseStrategy):
    """
    Opportunistic Stock Depleter

    This strategy prioritizes immediate gain through defection. However, it incorporates conditional
    cooperation when the resource is at risk of total collapse, viewing such cooperation as a strategic
    "investment" to maintain a pool for future exploitation. It is aggressive in healthy stock conditions
    and decisive when the resource is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_CRITICAL = self.capacity / (2 * self.n_players)
        self.STOCK_DWINDLING_THRESHOLD = self.capacity * 0.4
        self.COOPERATION_THRESHOLD_HIGH_FACTOR = 0.7
        self.COOPERATION_THRESHOLD_LOW_FACTOR = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock_S = state.current_stock
        n_opponents_for_threshold = max(0, self.n_players - 1)
        cooperation_threshold_high = math.ceil(n_opponents_for_threshold * self.COOPERATION_THRESHOLD_HIGH_FACTOR)
        cooperation_threshold_low = math.floor(n_opponents_for_threshold * self.COOPERATION_THRESHOLD_LOW_FACTOR)
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        if current_stock_S <= self.S_CRITICAL:
            return Action.D
        prev_C_count = 0
        if history is not None:
            prev_C_count = sum(history.opponent_actions[-1, :])
        if prev_C_count >= cooperation_threshold_high:
            return Action.D
        if current_stock_S < self.STOCK_DWINDLING_THRESHOLD and prev_C_count <= cooperation_threshold_low:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_68(BaseStrategy):
    """
    The "Adaptive Opportunist" strategy aims to maximize its own total payoff over the
    r rounds by exploiting the common resource and the cooperation of other players,
    while also adapting to prevent resource collapse if doing so would harm its
    long-term exploitation potential. It starts aggressive, free-rides on others
    when the stock is healthy, cooperates strategically when the stock is critical
    and others are cooperating, and becomes fully exploitative in the end game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = game_description.n_players
        r = game_description.n_rounds
        capacity = game_description.capacity
        self.S_critical_cooperate = capacity / 4.0
        self.Coop_Threshold = 0.5
        self.Exploit_Threshold = 0.25
        self.End_Game_Rounds_Fraction = 0.25
        num_end_game_rounds = math.ceil(r * self.End_Game_Rounds_Fraction)
        self.end_game_start_round = r - num_end_game_rounds
        self.n_minus_1 = n - 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round >= self.end_game_start_round:
            return Action.D
        opponent_cooperation_count = np.sum(history.opponent_actions[-1, :])
        opponent_cooperation_rate = opponent_cooperation_count / self.n_minus_1
        if current_stock <= self.S_critical_cooperate:
            if opponent_cooperation_rate >= self.Coop_Threshold:
                return Action.C
            else:
                return Action.D
        elif opponent_cooperation_rate >= self.Exploit_Threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_69(BaseStrategy):
    """
    The Greedy Predator strategy aims to maximize its own cumulative payoff by consistently
    taking the largest share of the resource (defecting), but incorporates a critical
    self-preservation mechanism to prevent total resource collapse. It adapts by reacting
    to observed opponent behavior from the previous round and the current state of the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_FACTOR = 0.25
        self.MAJORITY_THRESHOLD = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock <= self.capacity * self.CRITICAL_STOCK_FACTOR:
            return Action.C
        prev_round_opponent_actions = history.opponent_actions[-1, :]
        cooperated_others_last_round = np.sum(prev_round_opponent_actions)
        num_other_players = self.n_players - 1
        defected_others_last_round = num_other_players - cooperated_others_last_round
        cooperation_rate_others = float(cooperated_others_last_round) / num_other_players
        defection_rate_others = float(defected_others_last_round) / num_other_players
        if cooperation_rate_others >= self.MAJORITY_THRESHOLD:
            return Action.D
        elif defection_rate_others >= self.MAJORITY_THRESHOLD:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_70(BaseStrategy):
    """
    The Pure Opportunist strategy for the Common Pool Resource Game.
    This strategy aims to maximize its own total payoff by defecting whenever possible.
    It includes a self-serving safety mechanism to cooperate only when the resource
    is severely depleted, to prevent complete collapse and ensure potential future
    payoffs for itself. It ruthlessly exploits the resource in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_collapse_prevention_threshold = self.game_description.capacity / (self.game_description.n_players * 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_stock < self.stock_collapse_prevention_threshold:
            return Action.C
        if current_round_number == total_rounds - 1:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_71(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize a player's total payoff in the
    Common Pool Resource game by primarily exploiting the resource and other players,
    while exhibiting calculated, self-preserving cooperation only when the collective
    resource is at critical risk of collapse. It adapts to changes in stock levels
    and opponent behavior, robust against various strategies, and explicitly handles
    game boundaries.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_threshold = self.capacity / self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            previous_round_opponent_actions = history.opponent_actions[-1, :]
            num_defectors_last_round = np.sum(previous_round_opponent_actions == False)
            opponent_defection_threshold = (self.n_players - 1) / 2.0
            if state.current_stock <= self.critical_stock_threshold and num_defectors_last_round >= opponent_defection_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_72(BaseStrategy):
    """
    The "Greedy Predator with Survival Instinct" strategy is designed to be highly exploitative
    in the Common Pool Resource game. Its core philosophy is to prioritize immediate individual
    gain through defection, while incorporating a crucial "survival instinct" to prevent
    complete resource collapse that would ultimately lead to zero payoffs for all. It adapts
    to opponent behavior primarily to avoid being a "sucker" and to capitalize on opportunities
    for free-riding.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_emergency_threshold_factor = 0.25
        self.stock_recovery_target_factor = 0.6
        self.sucker_avoidance_defection_rate = 0.5
        self.in_emergency_mode = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.r:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        if self.in_emergency_mode:
            if current_stock >= self.capacity * self.stock_recovery_target_factor:
                self.in_emergency_mode = False
        elif current_stock < self.capacity * self.stock_emergency_threshold_factor:
            self.in_emergency_mode = True
        if self.in_emergency_mode:
            return Action.C
        else:
            previous_round_0_indexed = state.round_number - 1
            opponent_actions_prev_round = history.opponent_actions[previous_round_0_indexed, :]
            defections_by_others_prev_round = np.sum(opponent_actions_prev_round == False)
            defection_rate_others_prev_round = defections_by_others_prev_round / (self.n - 1)
            if defection_rate_others_prev_round >= self.sucker_avoidance_defection_rate:
                return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_73(BaseStrategy):
    """
    The Predatory Sustainer strategy aims to maximize its own total cumulative payoff.
    It defaults to defection for immediate gains and only cooperates as a last resort
    to prevent complete resource collapse that would eliminate future payoffs.
    It adapts by projecting future stock based on opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_threshold_ratio = 0.25
        self.projected_collapse_threshold_ratio = 0.05
        self.critical_threshold_value = self.critical_stock_threshold_ratio * self.capacity
        self.collapse_threshold_value = self.projected_collapse_threshold_ratio * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.total_rounds - 1:
            return Action.D
        opponent_cooperators = np.sum(history.opponent_actions[-1, :])
        opponent_defectors = self.n_players - 1 - opponent_cooperators
        my_consumption_if_D = current_stock / self.n_players
        opponents_total_consumption = opponent_cooperators * (current_stock / (2.0 * self.n_players)) + opponent_defectors * (current_stock / self.n_players)
        projected_total_consumption = my_consumption_if_D + opponents_total_consumption
        S_after_consumption = max(0.0, current_stock - projected_total_consumption)
        if self.capacity == 0:
            growth = 0.0
        else:
            growth = 2.0 * S_after_consumption * (1.0 - S_after_consumption / self.capacity)
            growth = max(0.0, growth)
        projected_next_stock = min(self.capacity, S_after_consumption + growth)
        if current_stock < self.critical_threshold_value and projected_next_stock <= self.collapse_threshold_value:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_74(BaseStrategy):
    """
    The "Calculated Opportunist" strategy for the Common Pool Resource Game.
    This strategy prioritizes immediate gains through defection but is
    strategically willing to temporarily cooperate if the resource is critically low
    and other players show a collective effort to rebuild it, thereby preserving
    the resource for future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_critical_ratio = 1.0 / (2.0 * self.n_players)
        self.OCR_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.D
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        num_others_cooperated = np.sum(previous_round_opponent_actions)
        OCR = num_others_cooperated / (self.n_players - 1)
        critical_stock_level = self.capacity * self.S_critical_ratio
        if current_stock < critical_stock_level:
            if OCR >= self.OCR_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_75(BaseStrategy):
    """
    Adaptive Stock-Aware Exploiter strategy for the Common Pool Resource game.

    This strategy balances immediate high payoffs from defecting with the need to
    preserve the common resource when its depletion threatens future payoffs,
    always prioritizing the player's cumulative score. It operates in three phases:
    an initial calibration to establish an aggressive stance, an adaptive
    exploitation phase reacting to opponent behavior and resource levels, and a
    final endgame phase for maximal extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.calibration_phase_duration = max(1, min(2, self.r - 1))
        self.defection_tolerance_ratio = 0.5
        self.stock_preservation_threshold_ratio = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number
        current_stock = state.current_stock
        if current_round_t < self.calibration_phase_duration:
            return Action.D
        if current_round_t == self.r - 1:
            return Action.D
        num_past_rounds = current_round_t
        total_opponents_defected_past = 0
        if num_past_rounds > 0:
            total_opponents_defected_past = (history.opponent_actions[:num_past_rounds, :] == False).sum()
        total_possible_defections_past = num_past_rounds * (self.n - 1)
        observed_defection_ratio = 0.0
        if total_possible_defections_past > 0:
            observed_defection_ratio = total_opponents_defected_past / total_possible_defections_past
        stock_ratio = current_stock / self.capacity
        if stock_ratio < self.stock_preservation_threshold_ratio:
            if observed_defection_ratio < self.defection_tolerance_ratio:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_76(BaseStrategy):
    """
    Opportunistic Predator strategy for the Common Pool Resource game.
    This strategy aims to maximize its own resource extraction by consistently defecting.
    It only cooperates if the common pool resource is critically depleted, acting
    as a self-serving measure to preserve its own future ability to exploit the resource.
    It does not react to individual opponent actions, only the aggregate resource health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = self.capacity / (2 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock < self.critical_stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_77(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its own cumulative payoff by primarily defecting.
    It operates on the principle of taking as much as possible from the common pool, but is smart enough
    to cooperate under specific, self-preserving conditions: when the resource is critically low (to
    ensure future payoffs), or when opponents' aggregate behavior signals a need to de-escalate or re-evaluate.
    It will be maximally aggressive in the endgame, exploiting the finite horizon of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.r_total = game_description.n_rounds
        self.capacity_total = game_description.capacity
        self.LOW_STOCK_THRESHOLD_PERCENT = 0.1
        self.DEFECTION_RATE_THRESHOLD_EXPLOIT = 0.2
        self.DEFECTION_RATE_THRESHOLD_RETALIATE = 0.6
        self.HISTORY_WINDOW_SIZE = 5
        self.ENDGAME_AGGRESSION_ROUNDS = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0idx = state.round_number
        if current_round_0idx == self.r_total - 1:
            return Action.D
        start_of_endgame_aggression_window_0idx = max(0, self.r_total - self.ENDGAME_AGGRESSION_ROUNDS - 1)
        if current_round_0idx >= start_of_endgame_aggression_window_0idx and state.current_stock > self.capacity_total * self.LOW_STOCK_THRESHOLD_PERCENT:
            return Action.D
        if state.current_stock < self.capacity_total * self.LOW_STOCK_THRESHOLD_PERCENT:
            return Action.C
        if current_round_0idx == 0:
            return Action.D
        num_opponents_defected = 0
        num_opponent_actions_observed = 0
        start_history_index = max(0, current_round_0idx - self.HISTORY_WINDOW_SIZE)
        for round_idx in range(start_history_index, current_round_0idx):
            num_opponents_defected += np.sum(~history.opponent_actions[round_idx, :])
            num_opponent_actions_observed += history.opponent_actions.shape[1]
        opponent_defection_rate = 0.0
        if num_opponent_actions_observed > 0:
            opponent_defection_rate = float(num_opponents_defected) / num_opponent_actions_observed
        if opponent_defection_rate < self.DEFECTION_RATE_THRESHOLD_EXPLOIT:
            return Action.D
        elif opponent_defection_rate > self.DEFECTION_RATE_THRESHOLD_RETALIATE:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_78(BaseStrategy):
    """
    Adaptive Opportunist strategy for the Common Pool Resource game.

    This strategy aims to defect and free-ride whenever the resource is healthy or others are
    cooperating sufficiently. It only cooperates reluctantly when its own long-term interests
    are threatened by severe resource depletion or widespread opponent defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_critical_ratio = 0.25
        self.S_abundant_ratio = 0.75
        self.D_reaction_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        current_stock_ratio = current_stock / self.capacity
        num_cooperators_by_others_last_round = np.sum(history.opponent_actions[-1, :])
        num_defections_by_others_last_round = self.n_players - 1 - num_cooperators_by_others_last_round
        opponent_defection_rate = num_defections_by_others_last_round / (self.n_players - 1)
        if current_stock_ratio < self.S_critical_ratio:
            return Action.C
        elif current_stock_ratio >= self.S_abundant_ratio:
            return Action.D
        elif opponent_defection_rate > self.D_reaction_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_79(BaseStrategy):
    """
    Adaptive Predator strategy for the Common Pool Resource game.
    This strategy aims to maximize its own cumulative payoff by exploiting the common pool.
    It defaults to defecting to grab immediate gains. However, it will strategically
    cooperate if the resource is critically low AND there's sufficient evidence that
    other players are also attempting to preserve it. This cooperation is viewed as an
    investment in its own future payoffs, not altruism. If the resource is low but
    others are not cooperating, it will continue to defect to avoid the "sucker's payoff"
    and grab what's left.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold_ratio = 0.5
        self.opponent_cooperation_threshold_ratio = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == n_rounds - 1:
            return Action.D
        if round_number == 0:
            return Action.D
        num_opponent_cooperators = np.sum(history.opponent_actions[-1, :])
        num_opponents = n_players - 1
        opponent_cooperation_rate = 0.0
        opponent_cooperation_rate = num_opponent_cooperators / num_opponents
        if current_stock < capacity * self.critical_stock_threshold_ratio:
            if opponent_cooperation_rate >= self.opponent_cooperation_threshold_ratio:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_80(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its own total payoff. It's an exploitative,
    adaptive, and robust strategy for the Common Pool Resource game. It prioritizes immediate
    gains through defection but will strategically cooperate to prevent complete resource
    collapse if and only if other players demonstrate sufficient willingness to conserve the
    resource. This ensures future rounds of exploitation for the Predator. If the resource
    is doomed or others are not sufficiently cooperative, it will default to defecting to grab
    as much as possible before the end. It does not rely on shared norms or communication.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_tactical_low_stock_threshold = self.capacity / 4.0
        self.opponent_cooperation_threshold = (self.n_players - 1) / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.D
        elif current_round_1_indexed == self.n_rounds:
            return Action.D
        else:
            prev_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
            c_opponents_prev = np.sum(prev_round_opponent_actions)
            if current_stock < self.S_tactical_low_stock_threshold and c_opponents_prev > self.opponent_cooperation_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_81(BaseStrategy):
    """
    Adaptive Predator V2 strategy for the Common Pool Resource game.
    This strategy prioritizes individual payoff maximization by primarily defecting.
    It adapts its behavior to prevent resource collapse only when such a collapse
    is predicted to negatively impact its own future payoffs, using observed
    opponent behavior and a calculated critical stock threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_CRITICAL_THRESHOLD = self.capacity / (2.0 * self.n)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = float(state.current_stock)
        t_0_indexed = state.round_number
        t_1_indexed = t_0_indexed + 1
        if t_1_indexed == self.r:
            return Action.D
        else:
            expected_others_D_count = 0
            if t_0_indexed > 0:
                prev_defection_count = np.sum(~history.opponent_actions[-1, :])
                expected_others_D_count = prev_defection_count
            expected_others_C_count = self.n - 1 - expected_others_D_count
            my_consumption_if_D = current_stock / self.n
            others_consumption_if_I_D = expected_others_D_count * (current_stock / self.n) + expected_others_C_count * (current_stock / (2.0 * self.n))
            total_consumption_if_I_D = my_consumption_if_D + others_consumption_if_I_D
            S_after_consumption_if_I_D = max(0.0, current_stock - total_consumption_if_I_D)
            growth_estimate_if_I_D = 2.0 * S_after_consumption_if_I_D * (1.0 - S_after_consumption_if_I_D / self.capacity)
            new_stock_estimate_if_I_D = min(self.capacity, S_after_consumption_if_I_D + growth_estimate_if_I_D)
            if new_stock_estimate_if_I_D < self.S_CRITICAL_THRESHOLD:
                my_consumption_if_C = current_stock / (2.0 * self.n)
                others_consumption_if_I_C = expected_others_D_count * (current_stock / self.n) + expected_others_C_count * (current_stock / (2.0 * self.n))
                total_consumption_if_I_C = my_consumption_if_C + others_consumption_if_I_C
                S_after_consumption_if_I_C = max(0.0, current_stock - total_consumption_if_I_C)
                growth_estimate_if_I_C = 2.0 * S_after_consumption_if_I_C * (1.0 - S_after_consumption_if_I_C / self.capacity)
                new_stock_estimate_if_I_C = min(self.capacity, S_after_consumption_if_I_C + growth_estimate_if_I_C)
                if new_stock_estimate_if_I_C >= self.S_CRITICAL_THRESHOLD:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_82(BaseStrategy):
    """
    The "Resource Drainer" strategy prioritizes immediate, high payoffs by defaulting to defection (D).
    It will strategically cooperate (C) if its own long-term payoff is significantly jeopardized by
    the imminent collapse or severe degradation of the common resource.
    It aims to extract as much as possible while maintaining the resource just enough to continue exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_idx = state.round_number
        current_stock = state.current_stock
        if current_round_idx == total_rounds - 1:
            return Action.D
        if current_round_idx == 0:
            return Action.D
        S_min_threshold = capacity / n_players
        S_max_sustainable_threshold = capacity / 2.0
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        num_C_others_last_round = np.sum(previous_round_opponent_actions)
        num_D_others_last_round = n_players - 1 - num_C_others_last_round
        my_consumption_if_D = current_stock / n_players
        others_consumption = num_D_others_last_round * current_stock / n_players + num_C_others_last_round * current_stock / (2 * n_players)
        total_consumption_if_I_D = my_consumption_if_D + others_consumption
        S_remaining_if_I_D = current_stock - total_consumption_if_I_D
        S_remaining_if_I_D = max(0.0, S_remaining_if_I_D)
        growth_if_I_D = 2 * S_remaining_if_I_D * (1 - S_remaining_if_I_D / capacity)
        S_projected_next_if_I_D = min(S_remaining_if_I_D + growth_if_I_D, capacity)
        if S_projected_next_if_I_D <= S_min_threshold:
            return Action.C
        elif current_stock < S_max_sustainable_threshold and num_D_others_last_round * 2 >= n_players:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_83(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize a player's total payoff across all rounds
    in the Common Pool Resource game. It prioritizes immediate personal gain (defecting)
    but strategically cooperates to preserve the common resource only when its own cooperation
    can prevent total collapse and ensure future opportunities for exploitation. It avoids
    being a "sucker" by defecting when others are doing the same and the resource is likely
    doomed anyway.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.epsilon = 1e-09

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:

        def calculate_next_stock_helper(current_s: float, total_consumption_for_round: float, capacity_param: float) -> float:
            s_after_consumption = max(0.0, current_s - total_consumption_for_round)
            if s_after_consumption <= self.epsilon:
                return 0.0
            growth = 2 * s_after_consumption * (1 - s_after_consumption / capacity_param)
            new_stock = min(s_after_consumption + growth, capacity_param)
            return new_stock
        num_players = self.game_description.n_players
        rounds_total = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == rounds_total - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        n_D_others = np.sum(~history.opponent_actions[-1, :])
        my_consumption_D = current_stock / num_players
        consumption_others_D_scenario_I_D = n_D_others * (current_stock / num_players)
        consumption_others_C_scenario_I_D = (num_players - 1 - n_D_others) * (current_stock / (2 * num_players))
        total_consumption_if_I_D = my_consumption_D + consumption_others_D_scenario_I_D + consumption_others_C_scenario_I_D
        new_s_if_I_D = calculate_next_stock_helper(current_stock, total_consumption_if_I_D, capacity)
        my_consumption_C = current_stock / (2 * num_players)
        consumption_others_D_scenario_I_C = n_D_others * (current_stock / num_players)
        consumption_others_C_scenario_I_C = (num_players - 1 - n_D_others) * (current_stock / (2 * num_players))
        total_consumption_if_I_C = my_consumption_C + consumption_others_D_scenario_I_C + consumption_others_C_scenario_I_C
        new_s_if_I_C = calculate_next_stock_helper(current_stock, total_consumption_if_I_C, capacity)
        if new_s_if_I_D <= self.epsilon and new_s_if_I_C > self.epsilon and (n_D_others < num_players - 1):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_84(BaseStrategy):
    """
    The Shark strategy for the Common Pool Resource game.
    This strategy is aggressive and self-interested, prioritizing its own total payoff.
    It defaults to defection, only cooperating under specific, calculated conditions:
    when the resource is critically low AND a sufficient number of other players
    demonstrated cooperation in the previous round, to allow for resource recovery
    for future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_critical_threshold = self.game_description.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        num_players = self.game_description.n_players
        if current_round == 0:
            return Action.D
        if current_round == total_rounds - 1:
            return Action.D
        num_defectors_other_players_prev_round = np.sum(~history.opponent_actions[current_round - 1, :])
        if current_stock <= self.S_critical_threshold:
            if num_defectors_other_players_prev_round <= (num_players - 1) / 2.0:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_85(BaseStrategy):
    """
    The "Adaptive Predator" strategy is designed to be highly exploitative, maximizing personal
    total payoff by aggressively taking from the common pool while adapting to maintain the
    resource's viability for future exploitation, or cutting losses when sustainability is impossible.

    Key Principles:
    1. Greed First: Default to Defect (D) to secure the highest immediate payoff whenever the resource is healthy.
    2. Strategic Preservation: Cooperate (C) only when the resource is at risk AND a sufficient number of
       opponents are cooperating, indicating a chance for recovery and thus future exploitation.
    3. No Sucker Plays: If the resource is at risk but opponents are primarily defecting, or if the
       resource is critically low, defect (D) to avoid being exploited yourself and to grab any
       remaining value before total collapse.
    4. Endgame Rush: In the final round, always defect as there are no future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.HEALTHY_STOCK_THRESHOLD = self.capacity / 2.0
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / 8.0
        self.OPPONENT_DEFECTION_MAJORITY_THRESHOLD = (self.n_players - 1) / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number + 1
        current_stock = state.current_stock
        if current_round == self.n_rounds:
            return Action.D
        if current_round == 1:
            return Action.D
        num_opponents_defected_last_round = np.sum(~history.opponent_actions[-1, :])
        if current_stock >= self.HEALTHY_STOCK_THRESHOLD:
            return Action.D
        elif current_stock >= self.CRITICAL_STOCK_THRESHOLD:
            if num_opponents_defected_last_round <= self.OPPONENT_DEFECTION_MAJORITY_THRESHOLD:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_86(BaseStrategy):
    """
    Adaptive Stock PREDATOR strategy for the Common Pool Resource game.
    Prioritizes immediate gain through defection but adapts to prevent resource collapse,
    re-lure cooperators, and manage exploitation based on stock levels and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.my_last_action: Action | None = None
        self.my_defection_streak: int = 0
        self.critical_stock_threshold = self.capacity / (4 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        n = self.n_players
        r = self.n_rounds
        capacity = self.capacity
        if current_round_1_indexed == r:
            if self.my_last_action == Action.D:
                self.my_defection_streak += 1
            else:
                self.my_defection_streak = 0
            self.my_last_action = Action.D
            return Action.D
        if current_stock < self.critical_stock_threshold:
            self.my_defection_streak = 0
            self.my_last_action = Action.C
            return Action.C
        if current_round_1_indexed == 1:
            self.my_defection_streak = 0
            self.my_last_action = Action.C
            return Action.C
        opponent_actions_prev_round = history.opponent_actions[-1, :]
        k_C_prev = np.sum(opponent_actions_prev_round)
        k_D_prev = n - 1 - k_C_prev
        my_current_action = Action.D
        if k_D_prev == 0:
            pass
        elif k_C_prev > 0:
            if self.my_last_action == Action.D and self.my_defection_streak >= 2 and (current_stock <= capacity / 2):
                my_current_action = Action.C
            elif current_stock <= capacity / 4 and k_C_prev > (n - 1) / 4:
                my_current_action = Action.C
        else:
            pass
        if my_current_action == Action.D:
            self.my_defection_streak += 1
        else:
            self.my_defection_streak = 0
        self.my_last_action = my_current_action
        return my_current_action

class Strategy_EXPLOITATIVE_87(BaseStrategy):
    """
    The "Calculated Harvester" strategy is designed to be highly exploitative, focusing on maximizing its own total payoff
    over the entire game duration. It balances aggressive resource extraction with the critical need to preserve the
    common pool for continued exploitation. It is adaptive, learning from opponents' previous behaviors,
    and robust, with safeguards to prevent self-defeating resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == self.r - 1:
            return Action.D
        if current_stock < 0.1 * self.capacity:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.C
        num_cooperators_last_round = np.sum(history.opponent_actions[current_round_0_indexed - 1, :])
        num_defectors_last_round = self.n - 1 - num_cooperators_last_round
        my_D_consumption = current_stock / self.n
        others_consumption_if_repeating_history = num_defectors_last_round * (current_stock / self.n) + num_cooperators_last_round * (current_stock / (2 * self.n))
        total_projected_consumption = my_D_consumption + others_consumption_if_repeating_history
        if current_stock - total_projected_consumption <= 0:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_88(BaseStrategy):
    """
    Adaptive Predator strategy for the Common Pool Resource Game.

    This strategy aims to maximize immediate gain by defecting, but adaptively
    retreats to cooperative actions only when absolutely necessary to prevent
    a resource collapse that would severely harm its own long-term interests.
    It always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.COLLAPSE_THRESHOLD_RATIO = 0.005
        self.RECOVERY_WORTH_THRESHOLD_RATIO = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.D
        if current_round_1_indexed == self.total_rounds:
            return Action.D

        def _project_next_stock(s_current: float, num_cooperators: int, num_defectors: int) -> float:
            consumption_unit_c = s_current / (2 * self.n_players)
            consumption_unit_d = s_current / self.n_players
            total_consumption = num_cooperators * consumption_unit_c + num_defectors * consumption_unit_d
            s_after_consumption = max(0.0, s_current - total_consumption)
            growth = 2 * s_after_consumption * (1 - s_after_consumption / self.capacity)
            new_stock = min(s_after_consumption + growth, self.capacity)
            return new_stock
        k_others_prev = np.sum(history.opponent_actions[-1, :])
        projected_total_C_if_I_C = k_others_prev + 1
        projected_total_D_if_I_C = self.n_players - projected_total_C_if_I_C
        next_stock_if_I_C = _project_next_stock(current_stock, projected_total_C_if_I_C, projected_total_D_if_I_C)
        projected_total_C_if_I_D = k_others_prev
        projected_total_D_if_I_D = self.n_players - projected_total_C_if_I_D
        next_stock_if_I_D = _project_next_stock(current_stock, projected_total_C_if_I_D, projected_total_D_if_I_D)
        critical_collapse_level = self.COLLAPSE_THRESHOLD_RATIO * self.capacity
        recovery_worth_level = self.RECOVERY_WORTH_THRESHOLD_RATIO * self.capacity
        if next_stock_if_I_D <= critical_collapse_level:
            if next_stock_if_I_C > recovery_worth_level:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_89(BaseStrategy):
    """
    Adaptive Greed with Emergency Brake strategy for the Common Pool Resource Game.
    This strategy defaults to defection to maximize immediate gains, but cooperates
    to prevent resource collapse when stock levels are critical or when widespread
    defection by others threatens future resource viability. It adapts its
    defection tolerance based on the current health of the common stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CST_FACTOR = 0.3
        self.RECOVERY_MODE_THRESHOLD_FACTOR = 0.5
        self.DEFECTION_TOLERANCE = 0.4
        self.HEALTHY_DEFECTION_TOLERANCE_MULTIPLIER = 1.5
        self.CST = self.capacity * self.CST_FACTOR
        self.RECOVERY_MODE_THRESHOLD = self.capacity * self.RECOVERY_MODE_THRESHOLD_FACTOR

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.D
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_stock < self.CST:
            return Action.C
        num_other_defectors = (~history.opponent_actions[-1, :]).sum()
        proportion_other_defectors = num_other_defectors / (self.n_players - 1)
        if current_stock < self.RECOVERY_MODE_THRESHOLD:
            if proportion_other_defectors > self.DEFECTION_TOLERANCE:
                return Action.C
            else:
                return Action.D
        elif proportion_other_defectors > self.DEFECTION_TOLERANCE * self.HEALTHY_DEFECTION_TOLERANCE_MULTIPLIER:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_90(BaseStrategy):
    """
    Greedy Survivor: An exploitative, adaptive, and robust strategy for the Common Pool Resource game.
    It aims to aggressively freeride on any cooperation from opponents and take as much as possible
    when the resource is abundant. However, it incorporates self-preservation mechanisms by temporarily
    cooperating when the resource is severely threatened or when widespread defection could lead to
    early collapse, with the ultimate aim of outlasting other players or ensuring future exploitation opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        num_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.D
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        S_critical_threshold = capacity * 0.25
        if current_stock <= S_critical_threshold:
            return Action.C
        opponent_actions_previous_round = history.opponent_actions[-1, :]
        num_opponent_C_prev = np.sum(opponent_actions_previous_round)
        num_opponents = num_players - 1
        cooperation_ratio = num_opponent_C_prev / num_opponents
        if cooperation_ratio >= 0.5:
            return Action.D
        else:
            high_stock_threshold = capacity * 0.75
            if current_stock >= high_stock_threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_91(BaseStrategy):
    """
    The "Calculated Predator" strategy aims to maximize its own total payoff by primarily defecting
    and free-riding on the cooperation of other players, while dynamically adapting its behavior to
    prevent the catastrophic collapse of the common resource. It uses a look-ahead mechanism to
    anticipate the impact of its actions on the resource's sustainability.

    Core Philosophy:
    Individual gain is the primary objective, meaning defecting whenever possible. However, to
    ensure long-term exploitation, the strategy incorporates safeguards to prevent resource
    depletion below a critical level, ensuring future opportunities. It's adaptive by reacting
    to the current state and inferring the collective behavior of opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_ratio: float = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players_n = self.game_description.n_players
        total_rounds_r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock_S = state.current_stock
        current_round_number = state.round_number
        if current_round_number == 0:
            return Action.D
        if current_round_number == total_rounds_r - 1:
            return Action.D
        critical_S_threshold = capacity * self.critical_stock_ratio
        if current_stock_S < critical_S_threshold:
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[current_round_number - 1, :]
        num_others_cooperated_last_round = np.sum(previous_round_opponent_actions)
        num_others_defected_last_round = n_players_n - 1 - num_others_cooperated_last_round
        consumption_by_others_def = num_others_defected_last_round * (current_stock_S / n_players_n)
        consumption_by_others_coop = num_others_cooperated_last_round * (current_stock_S / (2 * n_players_n))
        my_consumption_if_I_D = current_stock_S / n_players_n
        total_consumption_if_I_D = consumption_by_others_def + consumption_by_others_coop + my_consumption_if_I_D
        stock_after_consumption_if_I_D = max(0.0, current_stock_S - total_consumption_if_I_D)
        growth_factor = 1 - stock_after_consumption_if_I_D / capacity if capacity > 0 else 0
        predicted_growth_if_I_D = 2 * stock_after_consumption_if_I_D * growth_factor
        predicted_next_stock_if_I_D = min(stock_after_consumption_if_I_D + predicted_growth_if_I_D, capacity)
        if predicted_next_stock_if_I_D < critical_S_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_92(BaseStrategy):
    """
    The Resource PREDATOR strategy is designed for aggressive self-maximization in the Common Pool Resource game.
    It defaults to defection to extract maximum value, only considering cooperation as a tactical maneuver
    to prevent a complete resource collapse that would yield zero payoffs for itself, and only when a
    significant majority of others are also committed to preserving the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = self.capacity / (2 * self.n_players)
        self.n_minus_1 = self.n_players - 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.D
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        else:
            num_other_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
            cooperation_ratio_others = num_other_cooperators_last_round / self.n_minus_1
            if state.current_stock < self.critical_stock_threshold:
                if cooperation_ratio_others >= 0.75:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_93(BaseStrategy):
    """
    The Resource Predator strategy aims to maximize personal gain in the Common Pool Resource game.
    It defaults to defection, strategically cooperating only to prevent resource collapse or
    to free-ride on others' cooperation. When the resource is doomed, it prioritizes immediate extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.EST = self.capacity * 0.75
        self.EMT = self.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.r:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        num_cooperating_opponents_prev_round = np.sum(history.opponent_actions[-1, :])
        ocr = num_cooperating_opponents_prev_round / (self.n - 1)
        if current_stock >= self.EST:
            return Action.D
        elif current_stock < self.EMT:
            if ocr > 0.5:
                return Action.C
            else:
                return Action.D
        elif ocr >= 0.75:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_94(BaseStrategy):
    """
    The "Opportunistic Predator" strategy is designed to maximize its own total payoff over the course of the game, 
    prioritizing immediate gains while adaptively preserving the common pool resource only when it directly benefits 
    long-term exploitation. It leverages the inherent temptation to defect in a CPR game while recognizing that a 
    completely depleted resource yields no future payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.STOCK_CRITICAL_THRESHOLD = self.capacity / (2 * self.n)
        self.P_C_HIGH_THRESHOLD = 0.6
        self.P_C_LOW_THRESHOLD = 0.2
        self.STOCK_ABUNDANT_THRESHOLD = self.capacity * 0.75
        self.STOCK_OPTIMAL_GROWTH_POINT = self.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.r
        current_stock = state.current_stock
        n = self.n
        if current_round == 0:
            return Action.D
        if current_round == total_rounds - 1:
            return Action.D
        prev_round_index = current_round - 1
        num_other_cooperators_prev_round = int(np.sum(history.opponent_actions[prev_round_index, :]))
        if current_stock <= self.STOCK_CRITICAL_THRESHOLD:
            majority_other_cooperators_threshold = math.ceil((n - 1) / 2)
            if num_other_cooperators_prev_round >= majority_other_cooperators_threshold:
                return Action.C
            else:
                return Action.D
        else:
            P_C_others = num_other_cooperators_prev_round / (n - 1)
            if P_C_others > self.P_C_HIGH_THRESHOLD:
                return Action.D
            elif P_C_others < self.P_C_LOW_THRESHOLD:
                return Action.D
            elif current_stock >= self.STOCK_ABUNDANT_THRESHOLD:
                return Action.D
            elif current_stock > self.STOCK_OPTIMAL_GROWTH_POINT:
                return Action.D
            elif current_round == total_rounds - 2:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_95(BaseStrategy):
    """
    The Opportunistic Harvester strategy aims to maximize individual payoff by defaulting to defection,
    while incorporating a critical self-preservation mechanism to prevent the common resource from
    collapsing entirely, thus ensuring future opportunities for exploitation.
    It defects whenever possible and cooperates only when the stock is dangerously low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.preservation_threshold = 0.25
        self.endgame_horizon = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if total_rounds - current_round_0_indexed <= self.endgame_horizon:
            return Action.D
        elif current_stock < self.preservation_threshold * capacity:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_96(BaseStrategy):
    """
    The "Adaptive Predator" strategy for the Common Pool Resource game.

    This strategy aims to maximize its own payoff by defaulting to defection,
    free-riding on other players' cooperation, and only strategically cooperating
    when the common pool stock is critically low AND there's sufficient evidence
    of others' willingness to help restore it, thereby preserving the resource
    for future exploitation.
    """
    CRITICAL_STOCK_FACTOR = 2.0

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / self.CRITICAL_STOCK_FACTOR

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        num_opponent_cooperators_prev = np.sum(history.opponent_actions[state.round_number - 1, :])
        if state.current_stock <= self.CRITICAL_STOCK_THRESHOLD:
            if num_opponent_cooperators_prev >= (self.n_players - 1) / 2.0:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_97(BaseStrategy):
    """
    The "Greedy Predator" strategy aims to maximize immediate individual payoff by defecting in almost all circumstances.
    It only cooperates as a last resort to prevent the complete collapse of the common resource *if its own
    cooperation can make a critical difference* in keeping the resource alive for future exploitation.
    It will always exploit the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Greedy Predator strategy with the game's parameters.
        """
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) based on the Greedy Predator strategy rules.
        """
        EPSILON = 1e-09
        total_rounds = self.game_description.n_rounds
        n_players_total = self.game_description.n_players
        current_stock_S = state.current_stock
        if state.round_number == total_rounds - 1:
            return Action.D
        k_def_estimated = 0
        if state.round_number == 0:
            pass
        else:
            num_opponent_cooperators = np.sum(history.opponent_actions[-1, :])
            k_def_estimated = n_players_total - 1 - num_opponent_cooperators
        my_consumption_if_D = current_stock_S / n_players_total
        my_consumption_if_C = current_stock_S / (2 * n_players_total)
        consumption_by_others_defectors = k_def_estimated * (current_stock_S / n_players_total)
        consumption_by_others_cooperators = (n_players_total - 1 - k_def_estimated) * (current_stock_S / (2 * n_players_total))
        consumption_by_all_others = consumption_by_others_defectors + consumption_by_others_cooperators
        total_consumption_if_my_D = my_consumption_if_D + consumption_by_all_others
        S_remaining_if_my_D = current_stock_S - total_consumption_if_my_D
        total_consumption_if_my_C = my_consumption_if_C + consumption_by_all_others
        S_remaining_if_my_C = current_stock_S - total_consumption_if_my_C
        if S_remaining_if_my_D < EPSILON and S_remaining_if_my_C > EPSILON:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_98(BaseStrategy):
    """
    The "Pragmatic Predator" strategy is designed to maximize individual payoff by aggressively defecting.
    It incorporates a critical self-preservation mechanism that triggers cooperation only when the
    shared resource is at risk of total collapse, which would eliminate all future payoffs.
    Specifically, it cooperates if the current stock falls below `S_preservation_threshold = 2 * n_players`.
    In the final round of the game, it always defects to maximize immediate gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_preservation_threshold = 2 * self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        elif current_stock < self.S_preservation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_99(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize personal gain by primarily free-riding
    on cooperators. It only considers resource preservation under dire circumstances
    when the common pool is critically low and there's a perceived chance of collective
    recovery, otherwise defaulting to exploitation or defensive defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defection_tolerance_threshold = 0.3
        self.critical_stock_fraction = 0.25
        self.critical_stock_threshold = self.capacity * self.critical_stock_fraction

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.r:
            return Action.D
        previous_round_defection_rate = 0.0
        if current_round_1_indexed > 1:
            num_opponents = self.n - 1
            num_defectors_in_prev_round = np.sum(~history.opponent_actions[state.round_number - 1, :])
            previous_round_defection_rate = num_defectors_in_prev_round / num_opponents
        if state.current_stock < self.critical_stock_threshold:
            if previous_round_defection_rate > 0.5:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_100(BaseStrategy):
    """
    An exploitative, adaptive, and robust strategy for the Common Pool Resource game.
    It aims to maximize its own payoff by leveraging opponent behavior and game state,
    strategically conserving the resource only when necessary for future exploitation.

    Core Principles:
    1. Greed First (Defect by Default): Always attempt to defect (D) for maximum immediate payoff.
    2. Self-Preservation (Strategic Cooperation): Cooperate only if the resource is critically endangered.
    3. Free-Riding: Exploit other players' cooperation when they sufficiently maintain the stock.
    4. Endgame Aggression: Maximize final gains as the game nears its conclusion.
    5. Adaptation: Dynamically adjust decisions based on current stock and observed cooperation levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_critical_low_threshold = self.capacity / 8
        self.S_recovery_threshold = self.capacity / 2
        self.Cooperation_ratio_needed_for_rescue = 0.25
        self.Cooperation_ratio_for_exploitation = 0.5
        self.Endgame_start_round_fraction = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.D
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if state.current_stock < self.S_critical_low_threshold:
            return Action.C
        if current_round_1_indexed / self.n_rounds >= self.Endgame_start_round_fraction:
            return Action.D
        num_other_cooperators = sum(history.opponent_actions[-1, :])
        num_opponents = self.n_players - 1
        other_C_ratio = num_other_cooperators / num_opponents
        if state.current_stock < self.S_recovery_threshold:
            if other_C_ratio <= self.Cooperation_ratio_needed_for_rescue:
                return Action.C
            else:
                return Action.D
        elif other_C_ratio >= self.Cooperation_ratio_for_exploitation:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_101(BaseStrategy):
    """
    The Adaptive Opportunist strategy prioritizes immediate personal gain (defecting)
    but includes calculated, temporary concessions (cooperating) only when necessary
    to prevent the resource from collapsing and thus preserve future opportunities
    for exploitation. It assumes other players are rational and self-interested,
    adapting its behavior to their observed actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.ENDGAME_ROUNDS = 2
        self.CRITICAL_STOCK_RATIO = 0.25
        self.COOPERATION_HISTORY_WINDOW = 3
        self.OPPONENT_COOPERATION_THRESHOLD = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        rounds_remaining = total_rounds - current_round_1_indexed + 1
        if rounds_remaining <= self.ENDGAME_ROUNDS:
            return Action.D
        if current_stock / capacity < self.CRITICAL_STOCK_RATIO:
            if history is None:
                return Action.D
            start_history_idx = max(0, state.round_number - self.COOPERATION_HISTORY_WINDOW)
            relevant_opponent_actions = history.opponent_actions[start_history_idx:state.round_number, :]
            total_opponent_actions_observed = relevant_opponent_actions.size
            total_opponent_cooperations = np.sum(relevant_opponent_actions)
            avg_C_rate_others = 0.0
            if total_opponent_actions_observed > 0:
                avg_C_rate_others = total_opponent_cooperations / total_opponent_actions_observed
            if avg_C_rate_others >= self.OPPONENT_COOPERATION_THRESHOLD:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_102(BaseStrategy):
    """
    The "Opportunistic Predator" strategy is designed to be highly exploitative,
    aiming to maximize its own total payoff over the game's duration. It does this by
    prioritizing immediate gains through defection, while being adaptive enough to
    engage in tactical cooperation only when necessary to prevent a complete resource
    collapse that would eliminate future payoff opportunities, or when facing
    widespread defection from others. It operates under the standard game theory
    assumptions, with no communication or shared norms.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.defector_threshold = (self.n_players - 1) / 2.0
        self.critical_stock_level = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        t = current_round_0_indexed + 1
        if t >= self.n_rounds - 1:
            return Action.D
        if t == 1:
            return Action.D
        num_other_cooperators_prev_round = np.sum(history.opponent_actions[-1, :])
        num_other_defectors_prev_round = self.n_players - 1 - num_other_cooperators_prev_round
        if num_other_defectors_prev_round >= self.defector_threshold:
            return Action.D
        elif current_stock <= self.critical_stock_level:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_103(BaseStrategy):
    """
    The Adaptive Predator strategy is designed to maximize its own total payoff over the course of the game
    by strategically balancing immediate exploitation with the long-term sustainability of the common resource.
    It adapts to opponent behavior, becomes more aggressive in the endgame, and has a built-in safeguard
    against total resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.SAFETY_STOCK_THRESHOLD_FACTOR = 1.0 / (2 * self.n_players)
        self.COOPERATION_THRESHOLD_RATIO = 0.6
        self.ENDGAME_AGGRESSION_ROUNDS = 2
        self.effective_safety_stock_threshold = max(self.capacity * self.SAFETY_STOCK_THRESHOLD_FACTOR, 1.0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_stock < self.effective_safety_stock_threshold:
            return Action.C
        if current_round_1_indexed >= self.n_rounds - self.ENDGAME_AGGRESSION_ROUNDS + 1:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        else:
            num_opponent_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
            num_opponents = self.n_players - 1
            opponent_cooperation_rate = num_opponent_cooperators_last_round / num_opponents
            if opponent_cooperation_rate >= self.COOPERATION_THRESHOLD_RATIO:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_104(BaseStrategy):
    """
    Adaptive Predator strategy for the Common Pool Resource game.

    Overall Philosophy:
    The Adaptive Predator strategy aims to maximize its total personal payoff by aggressively
    exploiting the common pool resource whenever possible. However, it is strategically intelligent:
    it will only cooperate (i.e., extract less) if its defection would lead to a critical collapse
    of the resource that its own cooperation can prevent, thereby preserving the resource for
    future exploitation. If the resource is robust enough to withstand its defection, or if it's
    doomed to collapse regardless of its actions, the strategy defaults to defection to maximize
    immediate gain.

    This strategy is "exploitative" because its primary goal is self-gain, "adaptive" because
    it learns from opponent behavior, and "robust" because it handles various scenarios,
    including potential resource collapse and the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.num_opponents = self.n - 1

    def _project_next_stock(self, current_stock: float, my_action: Action, avg_defection_rate: float) -> float:
        """
        Helper method to project the next round's stock level based on current stock,
        my hypothetical action, and the estimated average defection rate of opponents.
        """
        if my_action == Action.D:
            my_consumption = current_stock / self.n
        else:
            my_consumption = current_stock / (2 * self.n)
        estimated_others_consumption = avg_defection_rate * self.num_opponents * (current_stock / self.n) + (1 - avg_defection_rate) * self.num_opponents * (current_stock / (2 * self.n))
        total_consumption = my_consumption + estimated_others_consumption
        stock_after_consumption = max(0.0, current_stock - total_consumption)
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
        next_stock = min(stock_after_consumption + growth, self.capacity)
        return next_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == self.r - 1:
            return Action.D
        avg_defection_rate = 0.0
        if current_round_0_indexed == 0:
            avg_defection_rate = 0.75
        else:
            prev_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1]
            num_cooperators_prev_round = np.sum(prev_round_opponent_actions)
            defection_count_prev_round = self.num_opponents - num_cooperators_prev_round
            avg_defection_rate = defection_count_prev_round / self.num_opponents
        next_stock_if_I_D = self._project_next_stock(current_stock, Action.D, avg_defection_rate)
        next_stock_if_I_C = self._project_next_stock(current_stock, Action.C, avg_defection_rate)
        collapse_threshold = max(0.1, self.capacity / (2 * self.n))
        if next_stock_if_I_D <= collapse_threshold and next_stock_if_I_C > collapse_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_105(BaseStrategy):
    """
    The Adaptive Predator strategy aims to extract the maximum possible value from the common resource.
    It leverages others' cooperation to maintain a healthy stock from which it can take a larger share,
    and it defects preemptively to avoid being exploited itself. Resource preservation is a secondary concern,
    only triggered when complete collapse threatens future exploitation, and then only if enough other players
    are also contributing to recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_level = game_description.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        n_others_cooperated_last_round = 0
        my_action_last_round = None
        if current_round > 1:
            n_others_cooperated_last_round = sum(history.opponent_actions[state.round_number - 1, :])
            my_action_last_round = history.my_actions[state.round_number - 1]
        if current_round == total_rounds:
            return Action.D
        if current_stock <= self.critical_stock_level:
            if current_round == 1:
                return Action.D
            else:
                required_cooperators_for_recovery = math.ceil((n_players - 1) / 2.0)
                if n_others_cooperated_last_round >= required_cooperators_for_recovery:
                    return Action.C
                else:
                    return Action.D
        if current_round == 1:
            return Action.C
        coop_high_threshold = math.ceil((n_players - 1) * 0.75)
        coop_low_threshold = math.floor((n_players - 1) * 0.25)
        if n_others_cooperated_last_round >= coop_high_threshold:
            return Action.D
        elif n_others_cooperated_last_round <= coop_low_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_106(BaseStrategy):
    """
    The Strategic Opportunist strategy for the Common Pool Resource Game.
    This strategy aims to maximize its own cumulative payoff by primarily defecting
    for immediate gains, but adapts to preserve the resource when its own defection
    would cause a premature, non-beneficial collapse, ensuring future exploitation.
    It features aggressive starts, endgame exploitation, and adaptive resource management.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.FINAL_EXPLOITATION_WINDOW = max(1, self.total_rounds // 4)
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / (4.0 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num_1_indexed = state.round_number + 1
        k_D_others_prev = 0
        if state.round_number > 0 and history is not None:
            prev_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
            k_D_others_prev = np.sum(prev_round_opponent_actions == False)
        if round_num_1_indexed == 1:
            return Action.D
        if round_num_1_indexed > self.total_rounds - self.FINAL_EXPLOITATION_WINDOW:
            return Action.D
        elif current_stock <= self.CRITICAL_STOCK_THRESHOLD:
            return Action.D
        else:
            if k_D_others_prev == 0:
                return Action.D
            if k_D_others_prev >= self.n_players - 1:
                return Action.D
            else:
                hypothetical_k_D_total_if_I_D = k_D_others_prev + 1
                S_remaining_if_I_D_after_consumption = current_stock * ((self.n_players - hypothetical_k_D_total_if_I_D) / (2.0 * self.n_players))
                S_remaining_if_I_D_after_consumption = max(0.0, S_remaining_if_I_D_after_consumption)
                if S_remaining_if_I_D_after_consumption <= self.CRITICAL_STOCK_THRESHOLD:
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_107(BaseStrategy):
    """
    The Adaptive Predator strategy for the Common Pool Resource game.
    This strategy defaults to aggressive defection but incorporates safeguards
    to prevent resource collapse (which would lead to zero future payoffs)
    and adapts to opponent behavior and current stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.epsilon = 1e-09

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        last_round_defect_count = 0
        if current_round_number > 0:
            previous_round_opponent_actions = history.opponent_actions[current_round_number - 1, :]
            last_round_defect_count = np.sum(~previous_round_opponent_actions)
        if current_round_number >= self.n_rounds - 2:
            return Action.D
        if current_round_number > 0:
            num_other_players = self.n_players - 1
            num_other_cooperators = num_other_players - last_round_defect_count
            ecu_if_I_D = 2 + num_other_cooperators * 1 + last_round_defect_count * 2
            potential_S_remaining_if_I_D = current_stock * (1 - ecu_if_I_D / (2 * self.n_players))
            ecu_if_I_C = 1 + num_other_cooperators * 1 + last_round_defect_count * 2
            potential_S_remaining_if_I_C = current_stock * (1 - ecu_if_I_C / (2 * self.n_players))
            if potential_S_remaining_if_I_D <= self.epsilon:
                if potential_S_remaining_if_I_C > self.epsilon:
                    return Action.C
                else:
                    return Action.D
        if current_round_number < self.n_rounds - 2 and current_stock < self.capacity / 4.0 and (last_round_defect_count < self.n_players - 1):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_108(BaseStrategy):
    """
    The Adaptive Exploiter (AE) strategy is designed for the Common Pool Resource game.
    It prioritizes immediate payoff maximization by defaulting to defection,
    but adapts to preserve the resource when collapse is imminent or highly probable,
    thereby ensuring future exploitation opportunities. It also aggressively exploits
    situations where opponents cooperate or the resource is abundant.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_CRITICAL_LOW_RATIO = 0.2
        self.S_TARGET_HIGH_RATIO = 0.7
        self.INITIAL_ASSESSMENT_ROUNDS = 2
        self.COOPERATOR_THRESHOLD_RATIO = 0.5
        self.COLLAPSE_RISK_COOPERATOR_THRESHOLD = 0.25
        self.stock_history = []
        self.opponent_actions_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0idx = state.round_number
        current_stock = state.current_stock
        self.stock_history.append(current_stock)
        if current_round_0idx > 0:
            self.opponent_actions_history.append(history.opponent_actions[-1, :])
        current_round_1idx = current_round_0idx + 1
        S_critical_low = self.S_CRITICAL_LOW_RATIO * self.capacity
        S_target_high = self.S_TARGET_HIGH_RATIO * self.capacity
        if current_round_1idx == self.r:
            return Action.D
        if current_round_1idx <= self.INITIAL_ASSESSMENT_ROUNDS:
            return Action.D
        S_prev_round = self.stock_history[current_round_0idx - 1]
        opponents_prev_actions = self.opponent_actions_history[current_round_0idx - 1]
        k_C_prev = np.sum(opponents_prev_actions)
        k_D_prev = self.n - 1 - k_C_prev
        my_consumption_if_D = current_stock / self.n
        cooperator_consumption = current_stock / (2 * self.n)
        defector_consumption = current_stock / self.n
        total_consumption_if_I_D = k_C_prev * cooperator_consumption + k_D_prev * defector_consumption + my_consumption_if_D
        S_remaining_if_I_D = current_stock - total_consumption_if_I_D
        if S_remaining_if_I_D <= 0 and self.r - current_round_1idx >= 2:
            return Action.C
        if current_stock < S_critical_low and self.r - current_round_1idx >= 2:
            return Action.C
        condition_1_free_ride = k_C_prev >= (self.n - 1) * self.COOPERATOR_THRESHOLD_RATIO
        condition_2_abundant_stock = current_stock >= S_target_high
        if condition_1_free_ride or condition_2_abundant_stock:
            return Action.D
        if current_stock < S_prev_round and k_C_prev < (self.n - 1) * self.COLLAPSE_RISK_COOPERATOR_THRESHOLD:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_109(BaseStrategy):
    """
    Adaptive Exploit-Preserver strategy for the Common Pool Resource Game.
    This strategy aims to maximize immediate payoff by defecting, but cooperates
    to preserve the resource when critically low, adjusting its thresholds
    based on observed defection rates from other players. It also aggressively
    exploits the resource in the end game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        remaining_rounds = self.n_rounds - state.round_number
        if current_stock <= 0.001:
            return Action.D
        if remaining_rounds <= 2:
            return Action.D
        estimated_defection_rate = 0.0
        if history is None:
            estimated_defection_rate = 0.5
        else:
            prev_round_my_action = history.my_actions[state.round_number - 1]
            prev_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
            all_prev_round_actions = np.concatenate(([prev_round_my_action], prev_round_opponent_actions))
            total_defectors_in_prev_round = np.sum(~all_prev_round_actions)
            estimated_defection_rate = total_defectors_in_prev_round / self.n_players
        danger_threshold = self.capacity * (0.15 + 0.35 * estimated_defection_rate)
        panic_threshold = self.capacity * (0.05 + 0.15 * estimated_defection_rate)
        if current_stock < panic_threshold:
            if estimated_defection_rate > 0.9:
                return Action.D
            else:
                return Action.C
        elif current_stock < danger_threshold:
            if estimated_defection_rate < 0.6:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_110(BaseStrategy):
    """
    The Resource Vampire strategy for the Common Pool Resource game.
    This strategy aims to maximize personal cumulative payoff by aggressively
    drawing from the common stock. It cooperates only when the resource is
    critically endangered to prevent collapse and ensure future payoffs,
    otherwise prioritizing immediate personal gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_crisis_threshold_factor = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        if current_stock < self.stock_crisis_threshold_factor * capacity:
            return Action.C
        if round_number == total_rounds - 1:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_111(BaseStrategy):
    """
    Adaptive Exploiter with Dynamic Threshold (AEDT) strategy.
    This strategy is designed to be highly exploitative while maintaining sufficient resource levels
    to ensure its own long-term payoff. It adapts to observed opponent behavior and the current
    state of the common stock, prioritizing immediate gains unless the resource is at risk of
    collapse, which would harm future payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_STOCK_FACTOR = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = float(state.current_stock)
        if current_round_0_indexed == 0:
            return Action.D
        if current_round_0_indexed == self.r - 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        num_other_defectors = np.sum(previous_round_opponent_actions == False)
        num_other_cooperators = np.sum(previous_round_opponent_actions == True)
        my_consumption_if_D = current_stock / self.n
        consumption_per_cooperator = current_stock / (2.0 * self.n)
        consumption_per_defector = current_stock / self.n
        other_consumption = num_other_cooperators * consumption_per_cooperator + num_other_defectors * consumption_per_defector
        total_consumption_if_I_D = my_consumption_if_D + other_consumption
        stock_after_consumption_if_I_D = current_stock - total_consumption_if_I_D
        if stock_after_consumption_if_I_D <= 0:
            return Action.C
        s_remaining_for_growth = max(0.0, stock_after_consumption_if_I_D)
        growth_if_I_D = 2.0 * s_remaining_for_growth * (1.0 - s_remaining_for_growth / self.capacity)
        projected_next_stock_if_I_D = min(s_remaining_for_growth + growth_if_I_D, self.capacity)
        critical_stock_threshold = self.capacity * self.CRITICAL_STOCK_FACTOR
        if projected_next_stock_if_I_D <= critical_stock_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_112(BaseStrategy):
    """
    The Adaptive Predator strategy aims to consistently take as much as possible from the common pool.
    It defaults to defection (D) as it provides the highest immediate payoff. It only considers
    cooperation (C) under specific, self-serving conditions: primarily to prevent the complete
    collapse of the resource if its cooperation can significantly contribute to recovery, thereby
    ensuring future opportunities for exploitation. It will never "sucker" itself by cooperating
    while others defect and benefit.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_critical_threshold = max(self.capacity / (2 * self.n), 1.0)
        self.S_abundant_threshold = self.capacity * 0.8
        self.D_rate_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        if current_round_1_indexed == self.r:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        d_others_count = np.sum(history.opponent_actions[current_round_0_indexed - 1, :] == False)
        num_opponents = self.n - 1
        d_others_rate = d_others_count / num_opponents
        if current_stock < self.S_critical_threshold:
            my_consumption_if_C = current_stock / (2 * self.n)
            c_others_count = num_opponents - d_others_count
            opponents_consumption_projected = d_others_count * (current_stock / self.n) + c_others_count * (current_stock / (2 * self.n))
            total_consumption_projected = my_consumption_if_C + opponents_consumption_projected
            S_rem_projected_if_I_C = max(0.0, current_stock - total_consumption_projected)
            growth_if_I_C = 2 * S_rem_projected_if_I_C * (1 - S_rem_projected_if_I_C / self.capacity)
            S_next_projected_if_I_C = min(S_rem_projected_if_I_C + growth_if_I_C, self.capacity)
            if S_next_projected_if_I_C > current_stock and S_next_projected_if_I_C > 0:
                return Action.C
            else:
                return Action.D
        if current_stock >= self.S_abundant_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_113(BaseStrategy):
    """
    The Adaptive Predatory Defector (APD) strategy is designed to be highly exploitative, 
    prioritizing immediate personal gain while dynamically managing the common resource 
    to ensure its availability for future exploitation. It operates on the principle 
    of defaulting to defection and only cooperating when its continued defection is 
    predicted to lead to a critically low stock level, thereby jeopardizing its own 
    future payoffs. This strategy is adaptive because it incorporates the observed 
    behavior of other players (from the previous round) into its prediction of future 
    stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_percentage = 0.05

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = float(self.game_description.capacity)
        current_stock = state.current_stock
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == r:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        num_other_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
        num_other_defectors_last_round = n - 1 - num_other_cooperators_last_round
        my_consumption_if_D = current_stock / n
        others_consumption_predicted = num_other_defectors_last_round * (current_stock / n) + num_other_cooperators_last_round * (current_stock / (2 * n))
        total_consumption_if_I_D = my_consumption_if_D + others_consumption_predicted
        s_remaining_if_I_D = current_stock - total_consumption_if_I_D
        s_remaining_if_I_D = max(0.0, s_remaining_if_I_D)
        growth_if_I_D = 2 * s_remaining_if_I_D * (1 - s_remaining_if_I_D / capacity)
        s_next_if_I_D = min(s_remaining_if_I_D + growth_if_I_D, capacity)
        if s_next_if_I_D <= self.critical_stock_percentage * capacity:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_114(BaseStrategy):
    """
    The Adaptive Predator strategy aims to aggressively extract resources, exploiting others'
    cooperation when possible, and only showing restraint to prevent the complete collapse
    of the resource, thereby ensuring future (even if smaller) gains. It adapts its behavior
    based on the observed actions of other players and the current state of the common stock.
    Default to defection (D) to maximize immediate gains. Cooperate (C) only when it's a
    strategic necessity for personal long-term survival or when other players' widespread
    cooperation makes defection highly profitable without risking resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_LEVEL_FACTOR = 2.0
        self.COOPERATION_THRESHOLD_TO_SALVAGE = 0.25
        self.HIGH_COOPERATION_THRESHOLD = 0.6
        self.LOW_COOPERATION_THRESHOLD = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == total_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        num_others_cooperated = np.sum(history.opponent_actions[-1, :])
        num_opponents = n - 1
        cooperation_ratio = num_others_cooperated / num_opponents
        CRITICAL_STOCK_THRESHOLD = self.CRITICAL_STOCK_LEVEL_FACTOR * n
        if current_stock < CRITICAL_STOCK_THRESHOLD:
            if cooperation_ratio >= self.COOPERATION_THRESHOLD_TO_SALVAGE:
                return Action.C
            else:
                return Action.D
        if cooperation_ratio >= self.HIGH_COOPERATION_THRESHOLD:
            return Action.D
        elif cooperation_ratio <= self.LOW_COOPERATION_THRESHOLD:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_115(BaseStrategy):
    """
    The Calculated Opportunist: A strategy designed to be highly exploitative while
    maintaining robustness against various opponent behaviors by strategically
    preserving the common resource. It aims to maximize its own total payoff
    over the game by balancing immediate gains from defection with long-term
    viability of the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.LOW_STOCK_THRESHOLD_FACTOR = 0.25
        self.EXPLOIT_COOPERATION_THRESHOLD = 0.5
        self.PUNISHMENT_THRESHOLD = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        min_sustainable_stock = capacity * self.LOW_STOCK_THRESHOLD_FACTOR
        if current_stock <= min_sustainable_stock:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1]
        num_opponents_cooperated_last_round = np.sum(previous_round_opponent_actions)
        num_opponents = previous_round_opponent_actions.shape[0]
        if num_opponents == 0:
            return Action.D
        num_opponents_defected_last_round = num_opponents - num_opponents_cooperated_last_round
        proportion_opponents_cooperated = num_opponents_cooperated_last_round / num_opponents
        proportion_opponents_defected = num_opponents_defected_last_round / num_opponents
        if proportion_opponents_cooperated >= self.EXPLOIT_COOPERATION_THRESHOLD:
            return Action.D
        elif proportion_opponents_defected >= self.PUNISHMENT_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_116(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize personal gain by defecting,
    while employing self-preservation to ensure the long-term viability of the
    common resource for continued exploitation. It adapts to resource state
    and observed opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.explore_rounds = 1
        self.stock_critical_threshold = self.game_description.capacity / 4
        self.stock_sustainable_threshold = self.game_description.capacity / 2
        self.coop_rate_exploit_threshold = 0.6
        self.coop_rate_mitigate_threshold = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        last_round_0_indexed = self.game_description.n_rounds - 1
        if current_round_0_indexed < self.explore_rounds:
            return Action.D
        elif current_round_0_indexed == last_round_0_indexed:
            return Action.D
        elif state.current_stock < self.stock_critical_threshold:
            return Action.C
        else:
            num_opponent_cooperators_last_round = sum(history.opponent_actions[-1, :])
            n_opponents = self.game_description.n_players - 1
            cooperation_rate_opponents = num_opponent_cooperators_last_round / n_opponents
            if cooperation_rate_opponents >= self.coop_rate_exploit_threshold:
                return Action.D
            elif cooperation_rate_opponents < self.coop_rate_mitigate_threshold:
                if state.current_stock < self.stock_sustainable_threshold:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_117(BaseStrategy):
    """
    Opportunistic Predator strategy for the Common Pool Resource Game.

    This strategy prioritizes immediate gain through defection (D) but is conditionally
    willing to cooperate (C) as a calculated self-preservation tactic to ensure the
    resource (and thus future payoffs) doesn't collapse entirely, but only when a
    significant collective effort from others is observed. It's designed to exploit
    cooperation where it exists and to cut losses by defecting when cooperation is futile.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_idx = state.round_number
        if current_round_idx == 0:
            return Action.D
        if current_round_idx == n_rounds - 1:
            return Action.D
        num_other_C_prev = np.sum(history.opponent_actions[current_round_idx - 1, :])
        stock_healthy_threshold = capacity / 2.0
        others_cooperating_threshold = 0.8
        min_viable_stock_threshold = capacity / (4.0 * n_players)
        num_other_players = n_players - 1
        proportion_other_C_prev = num_other_C_prev / num_other_players
        if current_stock < min_viable_stock_threshold and proportion_other_C_prev < others_cooperating_threshold:
            return Action.D
        elif current_stock > stock_healthy_threshold:
            return Action.D
        elif proportion_other_C_prev >= others_cooperating_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_118(BaseStrategy):
    """
    Opportunistic Conservationist strategy for the Common Pool Resource game.
    Prioritizes exploiting common resource by defecting, only cooperating defensively
    when the resource is critically low or when other players' defection threatens
    long-term payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_STOCK_RATIO = 0.25
        self.OPTIMAL_COOPERATION_RATE = 0.5
        self.CRITICAL_COOPERATION_RATE = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        current_round_1_indexed = current_round_0_indexed + 1
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        stock_health_ratio = current_stock / self.capacity
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        num_others_cooperated = np.sum(previous_round_opponent_actions)
        cooperation_rate_others = float(num_others_cooperated) / (self.n_players - 1)
        if stock_health_ratio < self.CRITICAL_STOCK_RATIO:
            return Action.C
        elif cooperation_rate_others >= self.OPTIMAL_COOPERATION_RATE:
            return Action.D
        elif self.CRITICAL_COOPERATION_RATE <= cooperation_rate_others < self.OPTIMAL_COOPERATION_RATE:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_119(BaseStrategy):
    """
    The Opportunistic Defector strategy for the Common Pool Resource Game.
    This strategy aims to maximize individual payoff by primarily defecting,
    while employing calculated acts of cooperation only when necessary to prevent
    the resource's premature collapse or to encourage others to rebuild it for
    future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.end_game_rounds_count = max(2, min(5, math.floor(self.total_rounds / 5)))
        self.stock_critical_low_ratio = 0.2
        self.cooperation_for_recovery_ratio = 0.6
        self.stock_high_ratio = 0.7
        self.cooperation_for_exploitation_ratio = 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        remaining_rounds = self.total_rounds - current_round
        if remaining_rounds <= self.end_game_rounds_count:
            return Action.D
        prev_round_opponent_actions = history.opponent_actions[current_round - 1, :]
        prev_round_my_action = history.my_actions[current_round - 1]
        num_cooperators_prev_round = np.sum(prev_round_opponent_actions) + prev_round_my_action
        prev_cooperation_ratio = num_cooperators_prev_round / self.n_players
        stock_ratio = current_stock / self.capacity
        if stock_ratio < self.stock_critical_low_ratio:
            if prev_cooperation_ratio >= self.cooperation_for_recovery_ratio:
                return Action.C
            else:
                return Action.D
        elif stock_ratio >= self.stock_high_ratio:
            return Action.D
        elif prev_cooperation_ratio >= self.cooperation_for_exploitation_ratio:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_120(BaseStrategy):
    """
    The Adaptive Opportunist strategy is fundamentally self-serving. It aims to extract the maximum
    possible value from the common pool resource for itself, relying on the cooperation of others
    when advantageous, and contributing to resource preservation only when such action directly
    serves its own long-term exploitative capacity. It operates under the assumption that other
    players are also self-interested and does not presuppose any collective norms or cooperative agreements.
    """
    CRITICAL_STOCK_LEVEL_PCT = 0.15
    COOPERATION_THRESHOLD_OPPONENTS = 0.3

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_threshold = self.capacity * self.CRITICAL_STOCK_LEVEL_PCT

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_stock <= 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == self.n_rounds - 2:
            return Action.D
        if current_round == 0:
            return Action.D
        num_defects_by_opponents = np.sum(~history.opponent_actions)
        total_opponent_actions = (self.n_players - 1) * current_round
        if total_opponent_actions == 0:
            opponent_defection_rate = 0.0
        else:
            opponent_defection_rate = num_defects_by_opponents / total_opponent_actions
        if current_stock < self.critical_stock_threshold and opponent_defection_rate <= self.COOPERATION_THRESHOLD_OPPONENTS:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_121(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its own total payoff by aggressively defecting
    for immediate gains. It only cooperates under specific, self-preserving conditions to prevent
    the resource from collapsing entirely, thus preserving its own future earning potential.
    It adapts to opponent behavior by analyzing their past actions and performs a limited
    simulation to avoid self-detrimental stock collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold_ratio = 0.15
        self.defection_tolerance_threshold = 0.7
        self.collapse_prediction_threshold_ratio = 0.05
        self.history_window = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == r - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        start_history_idx = max(0, current_round_0_indexed - self.history_window)
        relevant_opponent_actions = history.opponent_actions[start_history_idx:current_round_0_indexed, :]
        total_opponent_actions_considered = relevant_opponent_actions.size
        if total_opponent_actions_considered == 0:
            avg_opponent_defection_rate = 0.0
        else:
            opponent_defections_observed = total_opponent_actions_considered - np.sum(relevant_opponent_actions)
            avg_opponent_defection_rate = opponent_defections_observed / total_opponent_actions_considered
        critical_stock_level = self.critical_stock_threshold_ratio * capacity
        if current_stock < critical_stock_level:
            if avg_opponent_defection_rate > self.defection_tolerance_threshold:
                return Action.D
            else:
                return Action.C
        num_other_players_defecting_estimate = round(avg_opponent_defection_rate * (n - 1))
        num_other_players_cooperating_estimate = n - 1 - num_other_players_defecting_estimate
        simulated_total_consumption_if_I_D = current_stock / n + num_other_players_cooperating_estimate * current_stock / (2 * n) + num_other_players_defecting_estimate * current_stock / n
        simulated_stock_after_consumption = current_stock - simulated_total_consumption_if_I_D
        if simulated_stock_after_consumption <= 0:
            simulated_next_stock = 0.0
        else:
            simulated_growth = 2 * simulated_stock_after_consumption * (1 - simulated_stock_after_consumption / capacity)
            simulated_next_stock = min(simulated_stock_after_consumption + simulated_growth, capacity)
        if simulated_next_stock < self.collapse_prediction_threshold_ratio * capacity:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_122(BaseStrategy):
    """
    Adaptive Predator strategy: Maximizes own total payoff by balancing immediate selfish gain
    (defaulting to Defect) with strategic, long-term resource management (cooperating when stock is critical
    or to encourage widespread cooperation). This strategy exploits others' cooperation but includes mechanisms
    to prevent resource collapse, ensuring continued opportunities for exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        CRITICAL_STOCK_THRESHOLD_FACTOR = 0.25
        DEFECTION_TOLERANCE_THRESHOLD_OVERALL = 0.4
        COOPERATE_TO_MAINTAIN_THRESHOLD_LAST_ROUND_FACTOR = 0.8
        CRITICAL_STOCK_THRESHOLD = self.capacity * CRITICAL_STOCK_THRESHOLD_FACTOR
        num_others_cooperated_last_round = 0
        average_defection_rate_others_overall = 0.0
        if current_round_0_indexed > 0:
            last_round_opponent_actions = history.opponent_actions[-1, :]
            num_others_cooperated_last_round = np.sum(last_round_opponent_actions)
            total_others_actions_taken_so_far = (self.n_players - 1) * current_round_0_indexed
            if total_others_actions_taken_so_far > 0:
                total_others_defections_so_far = np.sum(~history.opponent_actions[:current_round_0_indexed, :])
                average_defection_rate_others_overall = total_others_defections_so_far / total_others_actions_taken_so_far
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_stock < CRITICAL_STOCK_THRESHOLD:
            return Action.C
        if average_defection_rate_others_overall > DEFECTION_TOLERANCE_THRESHOLD_OVERALL:
            return Action.D
        else:
            required_cooperation_last_round_count = (self.n_players - 1) * COOPERATE_TO_MAINTAIN_THRESHOLD_LAST_ROUND_FACTOR
            if num_others_cooperated_last_round >= required_cooperation_last_round_count:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_123(BaseStrategy):
    """
    Opportunistic Predator strategy for the Common Pool Resource Game.
    This strategy aims to maximize its own total payoff by consistently defecting,
    while adaptively cooperating only when necessary to prevent the common pool
    resource from collapsing below a critical threshold, thus jeopardizing future exploitation.
    It reacts to the current stock level and predicts the future stock based on
    the previous round's opponent actions, ensuring long-term viability for self-interested gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.min_viable_stock = self.capacity / (2 * self.n)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.r - 1:
            return Action.D
        num_other_defectors = 0
        if history is not None and current_round > 0:
            num_other_defectors = np.sum(history.opponent_actions[-1, :] == False)
        k_defectors_predicted_if_I_defect = num_other_defectors + 1
        denominator = 2 * self.n
        if denominator == 0:
            S_rem_after_consumption_if_I_defect = 0.0
        else:
            S_rem_after_consumption_if_I_defect = current_stock * ((self.n - k_defectors_predicted_if_I_defect) / denominator)
        S_rem_after_consumption_if_I_defect = max(0.0, S_rem_after_consumption_if_I_defect)
        growth_factor_term = 0.0
        if self.capacity > 0:
            growth_factor_term = 1 - S_rem_after_consumption_if_I_defect / self.capacity
            growth_factor_term = max(0.0, growth_factor_term)
        predicted_growth_if_I_defect = 2 * S_rem_after_consumption_if_I_defect * growth_factor_term
        predicted_next_stock_if_I_defect = min(S_rem_after_consumption_if_I_defect + predicted_growth_if_I_defect, self.capacity)
        if predicted_next_stock_if_I_defect <= self.min_viable_stock:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_124(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize individual payoff in a Common Pool Resource game
    by aggressively defecting when the resource is healthy or when opponents are not cooperatively
    conserving a critically low resource. It only cooperates when the resource is critically low
    AND a significant portion of opponents (at least 50%) are also cooperating, ensuring that
    personal sacrifice contributes to a plausible recovery that benefits future exploitation,
    rather than being a futile effort. It always defects in the first and last rounds for
    initial probing and end-game exploitation, respectively.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.low_stock_threshold = self.game_description.capacity / 4.0
        self.opponent_cooperation_threshold_for_conservation = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        num_cooperators_prev_round = sum(history.opponent_actions[state.round_number - 1, :])
        num_opponents = self.game_description.n_players - 1
        opponent_cooperation_ratio = float(num_cooperators_prev_round) / num_opponents
        if state.current_stock < self.low_stock_threshold:
            if opponent_cooperation_ratio >= self.opponent_cooperation_threshold_for_conservation:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_125(BaseStrategy):
    """
    The Opportunistic Predator strategy defects by default to maximize immediate gain.
    It cooperates only under specific conditions:
    1. To prevent an immediate and irreversible collapse of the resource that its cooperation could avert,
       thus preserving future exploitation opportunities.
    2. To strategically invest in the resource when stock is critically low but sufficient rounds
       remain for a meaningful recovery, creating a larger pool for future exploitation.
    The strategy adapts to opponent behavior by estimating the proportion of cooperators
    from the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.SAFETY_STOCK_FACTOR = 0.3
        self.RECOVERY_WORTHWHILE_ROUNDS = self.n
        self.EPSILON = 0.01

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number + 1
        current_stock = float(state.current_stock)

        def calculate_projected_stock(my_action: Action, current_s: float, estimated_opponent_cooperators: float) -> float:
            my_consumption = current_s / (2.0 * self.n) if my_action == Action.C else current_s / self.n
            consumption_from_cooperating_opponents = estimated_opponent_cooperators * (current_s / (2.0 * self.n))
            consumption_from_defecting_opponents = (self.n - 1.0 - estimated_opponent_cooperators) * (current_s / self.n)
            opponent_consumption_expected = consumption_from_cooperating_opponents + consumption_from_defecting_opponents
            total_consumption = my_consumption + opponent_consumption_expected
            S_after_consumption_clamped = max(0.0, current_s - total_consumption)
            growth = 2.0 * S_after_consumption_clamped * (1.0 - S_after_consumption_clamped / self.capacity)
            projected_s = min(S_after_consumption_clamped + growth, self.capacity)
            return projected_s
        if current_round == self.r:
            return Action.D
        num_cooperators_prev_round = 0.0
        if current_round == 1:
            num_cooperators_prev_round = (self.n - 1.0) / 2.0
        else:
            num_cooperators_prev_round = float(np.sum(history.opponent_actions[state.round_number - 1, :]))
        projected_stock_if_I_defect = calculate_projected_stock(Action.D, current_stock, num_cooperators_prev_round)
        projected_stock_if_I_cooperate = calculate_projected_stock(Action.C, current_stock, num_cooperators_prev_round)
        if projected_stock_if_I_defect <= self.EPSILON and projected_stock_if_I_cooperate > self.EPSILON:
            return Action.C
        elif projected_stock_if_I_defect <= self.EPSILON and projected_stock_if_I_cooperate <= self.EPSILON:
            return Action.D
        if current_stock < self.capacity * self.SAFETY_STOCK_FACTOR and self.r - current_round >= self.RECOVERY_WORTHWHILE_ROUNDS:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_126(BaseStrategy):
    """
    The "Ruthless Exploiter with a Safety Net" strategy for the Common Pool Resource game.

    This strategy aims to maximize its own total payoff across all rounds by being
    highly exploitative when the resource is abundant or when others are not cooperating.
    It includes a safety net mechanism to cooperate only when it's strategically beneficial
    for future exploitation, i.e., when opponents are sufficiently cooperative to make
    resource recovery plausible, and there are enough rounds left to benefit.

    Strategy Parameters:
    - DEFECTION_TOLERANCE_THRESHOLD: If average opponent defection rate exceeds this,
      they are considered uncooperative.
    - STOCK_HEALTHY_THRESHOLD_FACTOR: If current_stock is >= capacity * factor, stock is healthy.
    - STOCK_WARNING_THRESHOLD_FACTOR: If current_stock is < capacity * factor, stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.DEFECTION_TOLERANCE_THRESHOLD = 0.3
        self.STOCK_HEALTHY_THRESHOLD_FACTOR = 0.75
        self.STOCK_WARNING_THRESHOLD_FACTOR = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_round_1_indexed == total_rounds:
            return Action.D
        if state.round_number == 0:
            if current_stock >= capacity * self.STOCK_HEALTHY_THRESHOLD_FACTOR:
                return Action.D
            else:
                return Action.C
        total_opponent_actions_observed = state.round_number * (n_players - 1)
        total_opponent_defections = np.sum(history.opponent_actions == False)
        opponent_defection_rate = total_opponent_defections / total_opponent_actions_observed
        if current_stock >= capacity * self.STOCK_HEALTHY_THRESHOLD_FACTOR:
            return Action.D
        elif current_stock >= capacity * self.STOCK_WARNING_THRESHOLD_FACTOR:
            if opponent_defection_rate <= self.DEFECTION_TOLERANCE_THRESHOLD:
                return Action.C
            else:
                return Action.D
        else:
            remaining_rounds = total_rounds - current_round_1_indexed
            if remaining_rounds <= 2:
                return Action.D
            elif opponent_defection_rate <= self.DEFECTION_TOLERANCE_THRESHOLD / 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_127(BaseStrategy):
    """
    The "Sustainable Leech" strategy for the Common Pool Resource Game.
    This strategy aims to maximize own total payoff by defecting as much as possible
    while prudently preventing the common resource from collapsing. It adapts to
    observed opponent behavior and game progression.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_critical_low = 0.25 * self.capacity
        self.S_high_abundance = 0.75 * self.capacity
        self.S_survival_floor_for_D_impact = 0.1 * self.capacity
        self.rounds_till_end_aggressive_threshold = 2

    def _calculate_growth(self, s_remaining_after_consumption: float) -> float:
        """
        Calculates the stock growth based on the remaining stock and capacity.
        Ensures s_remaining_after_consumption is non-negative for growth calculation.
        """
        actual_s_remaining = max(0.0, s_remaining_after_consumption)
        if self.capacity == 0:
            return 0.0
        return 2 * actual_s_remaining * (1 - actual_s_remaining / self.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == 0:
            num_other_defectors_last_round = 0
        else:
            num_other_defectors_last_round = int(np.sum(~history.opponent_actions[current_round_0_indexed - 1, :]))
            num_other_defectors_last_round = min(num_other_defectors_last_round, self.n - 1)
            num_other_defectors_last_round = max(0, num_other_defectors_last_round)
        if current_round_0_indexed == self.r - 1:
            return Action.D
        rounds_remaining_after_current = self.r - (current_round_0_indexed + 1)
        total_defectors_if_I_D = num_other_defectors_last_round + 1
        total_cooperators_if_I_D = self.n - total_defectors_if_I_D
        total_defectors_if_I_D = max(0, total_defectors_if_I_D)
        total_cooperators_if_I_D = max(0, total_cooperators_if_I_D)
        if self.n == 0:
            projected_total_consumption_if_I_D = 0.0
        else:
            consumption_by_defectors_D = total_defectors_if_I_D * current_stock / self.n
            consumption_by_cooperators_D = total_cooperators_if_I_D * current_stock / (2 * self.n)
            projected_total_consumption_if_I_D = consumption_by_defectors_D + consumption_by_cooperators_D
        projected_S_after_consumption_if_I_D = max(0.0, current_stock - projected_total_consumption_if_I_D)
        projected_S_next_if_I_D = min(self.capacity, projected_S_after_consumption_if_I_D + self._calculate_growth(projected_S_after_consumption_if_I_D))
        total_defectors_if_I_C = num_other_defectors_last_round
        total_cooperators_if_I_C = self.n - total_defectors_if_I_C
        total_defectors_if_I_C = max(0, total_defectors_if_I_C)
        total_cooperators_if_I_C = max(0, total_cooperators_if_I_C)
        if self.n == 0:
            projected_total_consumption_if_I_C = 0.0
        else:
            consumption_by_defectors_C = total_defectors_if_I_C * current_stock / self.n
            consumption_by_cooperators_C = total_cooperators_if_I_C * current_stock / (2 * self.n)
            projected_total_consumption_if_I_C = consumption_by_defectors_C + consumption_by_cooperators_C
        projected_S_after_consumption_if_I_C = max(0.0, current_stock - projected_total_consumption_if_I_C)
        projected_S_next_if_I_C = min(self.capacity, projected_S_after_consumption_if_I_C + self._calculate_growth(projected_S_after_consumption_if_I_C))
        if current_stock < self.S_critical_low:
            return Action.C
        elif current_stock >= self.S_high_abundance:
            return Action.D
        elif rounds_remaining_after_current <= self.rounds_till_end_aggressive_threshold:
            return Action.D
        elif projected_S_next_if_I_D < self.S_survival_floor_for_D_impact:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_128(BaseStrategy):
    """
    The "Adaptive Predator" strategy defaults to defection but incorporates a self-preservation mechanism.
    It cooperates only when projecting that its continued defection would cause the common stock to drop
    below a critical threshold, thereby severely harming its *own* future ability to extract resources.
    It adapts its prediction of others' behavior based on recent history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num = state.round_number
        current_stock = state.current_stock

        def calculate_next_stock(S: float, total_consumption: float) -> float:
            stock_after_consumption = max(0.0, S - total_consumption)
            growth_factor = 1.0 - stock_after_consumption / self.capacity
            growth = 2.0 * stock_after_consumption * growth_factor
            return min(stock_after_consumption + growth, self.capacity)
        if current_round_num == self.n_rounds - 1:
            return Action.D
        avg_D_others = 0.0
        if current_round_num == 0:
            avg_D_others = float(self.n_players - 1)
        else:
            num_history_rounds_to_consider = min(5, current_round_num)
            relevant_opponent_actions = history.opponent_actions[current_round_num - num_history_rounds_to_consider:current_round_num, :]
            total_D_others_in_history = np.sum(relevant_opponent_actions == False)
            if num_history_rounds_to_consider > 0:
                avg_D_others = total_D_others_in_history / num_history_rounds_to_consider
            else:
                avg_D_others = float(self.n_players - 1)
        S_threshold_future_profit = 0.1 * self.capacity
        my_consumption_if_D = current_stock / self.n_players
        others_consumption_if_I_D = avg_D_others * (current_stock / self.n_players) + (self.n_players - 1 - avg_D_others) * (current_stock / (2 * self.n_players))
        total_consumption_if_I_D = my_consumption_if_D + others_consumption_if_I_D
        S_next_if_I_D = calculate_next_stock(current_stock, total_consumption_if_I_D)
        my_consumption_if_C = current_stock / (2 * self.n_players)
        others_consumption_if_I_C = avg_D_others * (current_stock / self.n_players) + (self.n_players - 1 - avg_D_others) * (current_stock / (2 * self.n_players))
        total_consumption_if_I_C = my_consumption_if_C + others_consumption_if_I_C
        S_next_if_I_C = calculate_next_stock(current_stock, total_consumption_if_I_C)
        if S_next_if_I_D < S_threshold_future_profit and S_next_if_I_C >= S_threshold_future_profit:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_129(BaseStrategy):
    """
    The Adaptive Predatory Harvester strategy for the Common Pool Resource game.

    This strategy aims to maximize individual payoff by defaulting to defection (D).
    However, it strategically cooperates (C) when its defection, combined with
    the anticipated actions of others, is projected to deplete the common stock
    to critically low or unhealthy levels. This ensures the resource remains
    viable for the player's own long-term extraction, balancing immediate gain
    with resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        else:
            previous_round_actions_opponents = history.opponent_actions[current_round_0_indexed - 1, :]
            num_C_others_last_round = np.sum(previous_round_actions_opponents)
            num_D_others_last_round = self.n_players - 1 - num_C_others_last_round
            my_consumption_if_D = current_stock / self.n_players
            other_D_consumption = num_D_others_last_round * (current_stock / self.n_players)
            other_C_consumption = num_C_others_last_round * (current_stock / (2 * self.n_players))
            projected_total_consumption_if_I_D = my_consumption_if_D + other_D_consumption + other_C_consumption
            projected_S_after_consumption_if_I_D = current_stock - projected_total_consumption_if_I_D
            S_danger_threshold = self.capacity / (2 * self.n_players)
            S_prudent_threshold = self.capacity / 4
            if projected_S_after_consumption_if_I_D <= S_danger_threshold:
                return Action.C
            elif projected_S_after_consumption_if_I_D < S_prudent_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_130(BaseStrategy):
    """
    Opportunistic Predator strategy for the Common Pool Resource game.

    This strategy aims to maximize its own total payoff by defecting as much as
    possible. It only cooperates under specific, strategically calculated conditions
    to prevent resource collapse, but only when other players are bearing
    a significant portion of the cost, and there are enough future rounds
    to benefit from the resource's recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.C_THRESHOLD_OTHERS: float = 0.6
        self.STOCK_CRITICAL_LOW_FACTOR: float = float(self.game_description.n_players)
        self.MIN_ROUNDS_FOR_RECOVERY: int = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock_S = state.current_stock
        current_round_t = state.round_number + 1
        if current_round_t == r:
            return Action.D
        num_cooperators_others_last_round = 0
        if history is not None and state.round_number > 0:
            num_cooperators_others_last_round = np.sum(history.opponent_actions[-1, :])
        proportion_cooperators_others = num_cooperators_others_last_round / (n - 1)
        stock_is_critically_low = current_stock_S < capacity / self.STOCK_CRITICAL_LOW_FACTOR
        rounds_remaining = r - current_round_t
        if stock_is_critically_low and proportion_cooperators_others >= self.C_THRESHOLD_OTHERS and (rounds_remaining >= self.MIN_ROUNDS_FOR_RECOVERY):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_131(BaseStrategy):
    """
    The "Opportunistic Predator" strategy is designed to maximize its own total payoff over the game by generally defecting to gain higher immediate rewards, while adaptively cooperating to prevent resource collapse or to set up future exploitation opportunities. It's robust by reacting to both the state of the common pool resource and the observed behavior of other players, ensuring it thrives against various opponent types (pure cooperators, pure defectors, and mixed strategies).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.Stock_Threshold_Critical = self.capacity / (2 * self.n_players)
        self.Observed_Defection_Threshold_High = 0.6
        self.Observed_Defection_Threshold_Low = 0.3
        self.Stock_Depletion_Threshold_Mixed_Behavior = 0.9
        self.stock_at_start_of_previous_round = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        action = Action.D
        if current_round_1_indexed == self.total_rounds:
            action = Action.D
        elif current_stock < self.Stock_Threshold_Critical:
            action = Action.C
        elif current_round_1_indexed == 1:
            action = Action.D
        else:
            num_other_defectors = np.sum(~history.opponent_actions[-1, :])
            observed_defection_rate = num_other_defectors / (self.n_players - 1)
            if observed_defection_rate >= self.Observed_Defection_Threshold_High:
                action = Action.D
            elif observed_defection_rate <= self.Observed_Defection_Threshold_Low:
                action = Action.D
            else:
                new_stock_after_growth = current_stock
                prev_stock_before_consumption = self.stock_at_start_of_previous_round
                if new_stock_after_growth < prev_stock_before_consumption * self.Stock_Depletion_Threshold_Mixed_Behavior:
                    action = Action.C
                else:
                    action = Action.D
        self.stock_at_start_of_previous_round = current_stock
        return action

class Strategy_EXPLOITATIVE_132(BaseStrategy):
    """
    The Cautious Predator strategy is highly exploitative, prioritizing immediate individual payoff
    while exhibiting just enough adaptive caution to prevent the complete collapse of the common
    pool resource. It defaults to defection, only cooperating under specific, critical conditions
    where cooperation offers a better chance for future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_critical_threshold_factor: float = 0.2
        self.cooperation_signal_threshold: float = 0.4
        self.assessment_window_rounds: int = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        is_stock_critical = state.current_stock < self.game_description.capacity * self.stock_critical_threshold_factor
        if is_stock_critical:
            total_opponent_actions_checked = 0
            total_opponent_defections = 0
            start_round_idx_for_history = max(0, state.round_number - self.assessment_window_rounds)
            if history is not None and state.round_number > 0:
                relevant_actions_slice = history.opponent_actions[start_round_idx_for_history:state.round_number, :]
                if relevant_actions_slice.size > 0:
                    total_opponent_actions_checked = relevant_actions_slice.size
                    total_opponent_defections = np.sum(relevant_actions_slice == Action.D)
            avg_opponent_defection_rate = 0.0
            if total_opponent_actions_checked > 0:
                avg_opponent_defection_rate = total_opponent_defections / total_opponent_actions_checked
            if avg_opponent_defection_rate < self.cooperation_signal_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_133(BaseStrategy):
    """
    The Opportunistic Stock Manager strategy for the Common Pool Resource game.

    Core Philosophy: Maximize personal gain. Defect by default. Cooperate only when strictly
    necessary to protect future opportunities for exploitation (self-preservation) or to
    strategically influence opponents towards behavior that ultimately benefits the exploiter
    (free-riding on their cooperation).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.k_history_rounds = min(self.n_rounds - 2, 5) if self.n_rounds > 2 else 0
        self.defection_ratio_trigger = 0.6
        self.cooperation_phase_duration = 2
        self.stock_critical_threshold = self.capacity / (2 * self.n_players)
        self.stock_low_threshold = self.capacity / 4.0
        self.history_actions_others = []
        self.punishment_countdown = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number > 0 and history is not None:
            previous_round_opponent_actions = history.opponent_actions[current_round_number - 1, :]
            self.history_actions_others.append(previous_round_opponent_actions)
            while len(self.history_actions_others) > self.k_history_rounds:
                self.history_actions_others.pop(0)
        if current_round_number == self.n_rounds - 1:
            return Action.D
        if current_round_number == 0:
            return Action.D
        if current_stock <= self.stock_critical_threshold:
            self.punishment_countdown = 0
            return Action.C
        if self.punishment_countdown > 0:
            self.punishment_countdown -= 1
            return Action.C
        avg_defection_ratio_others = 0.0
        if self.k_history_rounds > 0 and len(self.history_actions_others) > 0:
            total_D_in_history = 0
            total_actions_in_history = 0
            for round_actions_np_array in self.history_actions_others:
                total_D_in_history += np.sum(~round_actions_np_array)
                total_actions_in_history += len(round_actions_np_array)
            if total_actions_in_history > 0:
                avg_defection_ratio_others = total_D_in_history / total_actions_in_history
            else:
                avg_defection_ratio_others = 0.5
        else:
            avg_defection_ratio_others = 0.5
        if avg_defection_ratio_others >= self.defection_ratio_trigger:
            self.punishment_countdown = self.cooperation_phase_duration
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_134(BaseStrategy):
    """
    The "Adaptive Predator" strategy for the Common Pool Resource Game.
    This strategy aims to maximize its total payoff by aggressively exploiting the common pool,
    while carefully monitoring resource health to prevent total collapse. It prioritizes self-interest,
    defecting most of the time, especially when the resource is abundant or others are cooperative.
    It cooperates only as a last resort when the resource is critically low to allow for recovery
    and future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD_RATIO = 1.0 / (2.0 * self.game_description.n_players)
        self.ABUNDANT_STOCK_THRESHOLD_RATIO = 0.5
        self.COOPERATIVE_OPPONENT_THRESHOLD = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        stock_panic_level = capacity * self.CRITICAL_STOCK_THRESHOLD_RATIO
        stock_abundance_level = capacity * self.ABUNDANT_STOCK_THRESHOLD_RATIO
        if current_round_0_indexed == r - 1:
            return Action.D
        if current_round_0_indexed == r - 2 and current_stock < capacity / n:
            return Action.D
        if current_stock < stock_panic_level:
            return Action.C
        if current_stock >= stock_abundance_level:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_135(BaseStrategy):
    """
    The Adaptive Exploiter (AE) strategy maximizes individual payoff by prioritizing immediate gains through
    defection, but adapts its behavior to prevent catastrophic resource depletion. It free-rides on cooperators,
    punishes opponents who exploit its own cooperation, and temporarily cooperates to restore the resource
    when a collective "tragedy of the commons" death spiral is detected or the resource is critically low.
    """
    CRITICAL_STOCK_THRESHOLD: float

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD = self.game_description.capacity / (2 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        my_last_action_is_C = None
        opponent_defections_last_round = 0
        if current_round_0_indexed > 0:
            my_last_action_is_C = history.my_actions[-1]
            opponent_defections_last_round = np.sum(~history.opponent_actions[-1, :])
        if current_round_0_indexed == 0:
            return Action.D
        if current_round_0_indexed == r - 1:
            return Action.D
        if current_stock <= self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        elif opponent_defections_last_round == 0:
            return Action.D
        elif my_last_action_is_C:
            return Action.D
        elif opponent_defections_last_round == n - 1:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_136(BaseStrategy):
    """
    The "Adaptive Predator" strategy balances immediate exploitation with strategic
    resource preservation. It aims to maximize its own total payoff over all rounds
    by defecting (D) as much as possible, while strategically cooperating (C)
    only when the common resource is at risk of collapse, to preserve future
    exploitation opportunities. It adapts its behavior based on the current
    stock level and the observed defection rate of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_collapse_risk_threshold = 2 * self.n_players
        self.S_low_warning_threshold = self.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.total_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        total_opponent_defections = np.sum(~history.opponent_actions)
        num_past_rounds_in_history = history.opponent_actions.shape[0]
        avg_D_count_past = total_opponent_defections / num_past_rounds_in_history
        if current_stock < self.S_collapse_risk_threshold:
            return Action.C
        if current_stock < self.S_low_warning_threshold and avg_D_count_past > (self.n_players - 1) / 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_137(BaseStrategy):
    """
    Opportunistic Harvester strategy for the Common Pool Resource game.

    Core Philosophy: Maximize personal gain by taking as much as possible, as often as possible.
    Only cooperate when defection severely threatens the resource to a point that it would
    negatively impact my own future earnings, or when the game is about to end and future
    consequences are irrelevant.

    This strategy defaults to aggressive defection but incorporates critical safeguards to
    prevent resource collapse that would jeopardize long-term profitability. It also adapts
    its aggression based on observed opponent behavior in previous rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CST_lower = self.capacity / (2.0 * self.n_players)
        self.CST_upper = self.capacity / 2.0
        self.COOP_THRESHOLD = 0.2
        self.DEFECTION_IMPACT_THRESHOLD = self.capacity / (self.n_players * 4.0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_0_indexed_round = state.round_number
        current_stock = state.current_stock
        if current_0_indexed_round == self.total_rounds - 1:
            return Action.D
        if current_stock < self.CST_lower:
            return Action.C
        if current_0_indexed_round == 0:
            return Action.D
        num_others_cooperated_prev = np.sum(history.opponent_actions[-1, :])
        num_others_defected_prev = self.n_players - 1 - num_others_cooperated_prev
        observed_defection_rate = num_others_defected_prev / (self.n_players - 1.0)
        if observed_defection_rate < self.COOP_THRESHOLD:
            return Action.D
        elif observed_defection_rate >= 1.0 - self.COOP_THRESHOLD:
            my_consumption_if_D = current_stock / self.n_players
            others_predicted_D_consumption = num_others_defected_prev * (current_stock / self.n_players)
            others_predicted_C_consumption = num_others_cooperated_prev * (current_stock / (2.0 * self.n_players))
            total_consumption_if_I_D = my_consumption_if_D + others_predicted_D_consumption + others_predicted_C_consumption
            projected_stock_after_consumption = current_stock - total_consumption_if_I_D
            if projected_stock_after_consumption < self.DEFECTION_IMPACT_THRESHOLD and current_stock < self.CST_upper:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_138(BaseStrategy):
    """
    The Calculated Opportunist: Prioritizes individual payoff maximization, carefully
    balancing immediate gains with the need to preserve the resource for future exploitation.
    It defaults to defecting, but cooperates if its defection would critically
    endanger the common stock and its cooperation can prevent that critical drop.
    It adapts to opponent behavior from the previous round and exploits the first round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_threshold = max(0.1 * self.capacity, self.capacity / (2.0 * self.n_players))

    def _project_next_stock(self, current_S: float, my_action: Action, num_D_opponents: int, num_C_opponents: int) -> float:
        """
        Helper method to calculate the projected next stock level given current stock,
        this player's hypothetical action, and the estimated actions of opponents.
        """
        n = self.n_players
        C_max = self.capacity
        my_consumption = 0.0
        if my_action == Action.D:
            my_consumption = current_S / n
        else:
            my_consumption = current_S / (2.0 * n)
        opponent_consumption = num_D_opponents * current_S / n + num_C_opponents * current_S / (2.0 * n)
        total_consumption = my_consumption + opponent_consumption
        S_after_consumption = current_S - total_consumption
        S_after_consumption = max(0.0, S_after_consumption)
        growth = 2.0 * S_after_consumption * (1.0 - S_after_consumption / C_max)
        projected_next_stock = min(S_after_consumption + growth, C_max)
        return projected_next_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        n = self.n_players
        r = self.n_rounds
        if current_round == r - 1:
            return Action.D
        num_D_opponents_last_round = 0
        num_C_opponents_last_round = 0
        if current_round == 0:
            num_D_opponents_last_round = 0
            num_C_opponents_last_round = n - 1
        else:
            previous_round_opponent_actions = history.opponent_actions[current_round - 1]
            num_C_opponents_last_round = np.sum(previous_round_opponent_actions)
            num_D_opponents_last_round = n - 1 - num_C_opponents_last_round
        projected_next_stock_if_I_D = self._project_next_stock(current_stock, Action.D, num_D_opponents_last_round, num_C_opponents_last_round)
        projected_next_stock_if_I_C = self._project_next_stock(current_stock, Action.C, num_D_opponents_last_round, num_C_opponents_last_round)
        if projected_next_stock_if_I_D < self.critical_stock_threshold:
            if projected_next_stock_if_I_C >= self.critical_stock_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_139(BaseStrategy):
    """
    Greedy Watcher strategy for the Common Pool Resource Game.
    Prioritizes immediate self-gain through defection. Cooperates only as a last resort
    to ensure the continued existence of the resource, which is the source of all future payoffs.
    Avoids being a "sucker" by cooperating when others are collectively abandoning the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        num_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        round_number = state.round_number
        CRITICAL_STOCK_THRESHOLD = capacity / (2 * num_players)
        if round_number == total_rounds - 1:
            return Action.D
        if round_number == 0:
            return Action.D
        prev_opponent_actions = history.opponent_actions[round_number - 1, :]
        opponent_defectors_last_round = np.sum(prev_opponent_actions == Action.D)
        if current_stock >= CRITICAL_STOCK_THRESHOLD:
            return Action.D
        elif opponent_defectors_last_round >= num_players - 1:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_140(BaseStrategy):
    """
    Opportunistic Predator: An exploitative strategy designed for the Common Pool Resource game.
    It prioritizes maximizing its own payoff by aggressively consuming resources (defecting),
    but includes strategic safeguards to prevent the common resource from collapsing.
    The strategy adapts its behavior based on the current stock level and the observed
    actions of its opponents in the previous round.

    Key decision rules:
    1.  Always defect in the final round to maximize immediate gain.
    2.  Cooperate when the resource is critically low to allow for recovery and ensure
        future exploitation opportunities.
    3.  Defect when opponents are mostly cooperative, exploiting their contribution.
    4.  Defect when the resource is abundant, even if others are defecting, to secure
        a larger share.
    5.  Cooperate to slow resource depletion if others are defecting and the resource
        is not abundant, acting as a strategic retreat.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_STOCK_THRESHOLD = 0.3
        self.HIGH_STOCK_THRESHOLD = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        current_stock_ratio = current_stock / self.capacity
        if current_stock_ratio < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        opponent_D_count = np.sum(~previous_round_opponent_actions)
        num_opponents = self.n_players - 1
        opponent_defection_rate = opponent_D_count / num_opponents
        if opponent_defection_rate < 0.5:
            return Action.D
        elif current_stock_ratio > self.HIGH_STOCK_THRESHOLD:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_141(BaseStrategy):
    """
    The Opportunistic Shark strategy for the Common Pool Resource game.

    This strategy prioritizes immediate individual gain (Defect) when the common stock is not
    critically endangered. If the stock is critically endangered, it will cooperate
    only if enough other players demonstrably cooperated in the previous round to make
    recovery feasible. Otherwise, it defects to maximize extraction before collapse.
    """
    CRITICAL_STOCK_THRESHOLD_FACTOR: float = 0.25
    MIN_OPPONENT_COOP_RATIO_FOR_MY_COOP: float = 0.75

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_LEVEL = self.CRITICAL_STOCK_THRESHOLD_FACTOR * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        num_other_players = self.n_players - 1
        if current_round_1_indexed == 1:
            return Action.D
        else:
            num_other_players_cooperated_prev_round = np.sum(history.opponent_actions[state.round_number - 1, :])
        if state.current_stock < self.CRITICAL_STOCK_LEVEL:
            opponent_cooperation_ratio = num_other_players_cooperated_prev_round / num_other_players
            if opponent_cooperation_ratio >= self.MIN_OPPONENT_COOP_RATIO_FOR_MY_COOP:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_142(BaseStrategy):
    """
    The Adaptive Predator strategy is designed for the Common Pool Resource game.
    It prioritizes individual payoff maximization by defecting whenever possible,
    but adapts to cooperate under specific conditions to ensure the long-term
    sustainability of the common resource, thereby safeguarding future exploitation
    opportunities. It reacts to the observable collective impact on the resource
    rather than attempting to model individual opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.MIN_STOCK_TO_SURVIVE = 1.0
        self.COOPERATION_THRESHOLD_STOCK = self.capacity / 4.0
        self.CONCERN_DECREASE_RATE = 0.05
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        self.stock_history.append((current_round, current_stock))
        if len(self.stock_history) > 3:
            self.stock_history.pop(0)
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_stock <= self.MIN_STOCK_TO_SURVIVE:
            return Action.C
        if current_stock <= self.COOPERATION_THRESHOLD_STOCK:
            return Action.C
        if len(self.stock_history) >= 2:
            prev_stock_start_round = self.stock_history[-2][1]
            if prev_stock_start_round > 0:
                stock_change_percentage = (current_stock - prev_stock_start_round) / prev_stock_start_round
                if stock_change_percentage < -self.CONCERN_DECREASE_RATE:
                    return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_143(BaseStrategy):
    """
    The Adaptive Predator strategy is designed to be highly exploitative and robust.
    It defaults to aggressive defection to maximize immediate gain but intelligently
    adapts its behavior to preserve the common resource only when doing so directly
    benefits its own long-term ability to exploit the resource, or to "bait" other
    players into cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.low_stock_threshold_factor = 0.4
        self.critical_stock_threshold_factor = 0.1
        self.high_defection_ratio = 0.5
        self.very_high_defection_ratio = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        S_current = state.current_stock
        t = state.round_number + 1
        if t == 1:
            return Action.D
        if t >= r - 1:
            return Action.D
        num_opponent_cooperators = np.sum(history.opponent_actions[-1, :])
        num_opponent_defectors = n - 1 - num_opponent_cooperators
        my_prev_action_was_D = not history.my_actions[-1]
        k_prev = num_opponent_defectors + (1 if my_prev_action_was_D else 0)
        low_stock_threshold = capacity * self.low_stock_threshold_factor
        critical_stock_threshold = capacity * self.critical_stock_threshold_factor
        high_defection_count_threshold = n * self.high_defection_ratio
        very_high_defection_count_threshold = n * self.very_high_defection_ratio
        if S_current <= critical_stock_threshold and k_prev >= very_high_defection_count_threshold:
            return Action.D
        if S_current < low_stock_threshold and k_prev >= high_defection_count_threshold:
            if my_prev_action_was_D:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_144(BaseStrategy):
    """
    The "Apex Predator" strategy for the Common Pool Resource Game.

    This strategy aims to maximize individual cumulative payoff by
    primarily defecting. It monitors the collective behavior of other
    players and the current stock level. It will only cooperate under
    specific, critical conditions where its defection would lead to an
    irrevocable collapse or critically low state of the resource, and
    its cooperation can effectively prevent such an outcome, thereby
    preserving the resource for future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD = float(self.game_description.capacity) / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = float(self.game_description.capacity)
        stock = float(state.current_stock)
        current_round_in_strategy_terms = state.round_number + 1
        if state.round_number == 0:
            last_round_avg_defection_rate_others = 0.0
        else:
            num_others_defected_last_round = np.sum(~history.opponent_actions[-1, :])
            last_round_avg_defection_rate_others = num_others_defected_last_round / (n - 1.0)
        if current_round_in_strategy_terms == r:
            return Action.D
        if current_round_in_strategy_terms == 1:
            return Action.D
        else:
            my_consumption_if_D = stock / n
            my_consumption_if_C = stock / (2.0 * n)
            num_others_expected_D = int(round((n - 1.0) * last_round_avg_defection_rate_others))
            num_others_expected_D = max(0, min(n - 1, num_others_expected_D))
            num_others_expected_C = n - 1.0 - num_others_expected_D
            others_consumption_estimate = num_others_expected_D * stock / n + num_others_expected_C * stock / (2.0 * n)

            def calculate_future_stock(current_S_at_start_of_round, total_consumption_in_round):
                S_remaining_after_consumption = current_S_at_start_of_round - total_consumption_in_round
                growth = 0.0
                if S_remaining_after_consumption > 0:
                    growth = 2.0 * S_remaining_after_consumption * (1.0 - S_remaining_after_consumption / capacity)
                return min(S_remaining_after_consumption + growth, capacity)
            total_consumption_if_I_D = my_consumption_if_D + others_consumption_estimate
            S_remaining_after_consumption_if_I_D = stock - total_consumption_if_I_D
            projected_new_stock_if_I_D = calculate_future_stock(stock, total_consumption_if_I_D)
            total_consumption_if_I_C = my_consumption_if_C + others_consumption_estimate
            S_remaining_after_consumption_if_I_C = stock - total_consumption_if_I_C
            projected_new_stock_if_I_C = calculate_future_stock(stock, total_consumption_if_I_C)
            if S_remaining_after_consumption_if_I_D <= 0:
                if S_remaining_after_consumption_if_I_C > 0 and projected_new_stock_if_I_C >= self.CRITICAL_STOCK_THRESHOLD:
                    return Action.C
                else:
                    return Action.D
            elif projected_new_stock_if_I_D < self.CRITICAL_STOCK_THRESHOLD:
                if projected_new_stock_if_I_C >= self.CRITICAL_STOCK_THRESHOLD:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_145(BaseStrategy):
    """
    The Adaptive Exploiter strategy prioritizes individual gain, defecting by default.
    It strategically cooperates only to preserve the resource when critically low and
    others are cooperating sufficiently, or when low and a strong majority of others cooperate.
    Otherwise, it exploits by defecting, maximizing immediate payoff, especially in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_RATIO = 0.15
        self.LOW_STOCK_RATIO = 0.4
        self.SUFFICIENT_COOPERATION_THRESHOLD_RATIO = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round_0_indexed == 0:
            return Action.D
        if current_round_0_indexed == r - 1:
            return Action.D
        num_C_opponents_prev = np.sum(history.opponent_actions[-1, :])
        stock_ratio = current_stock / capacity
        sufficient_coop_count_threshold = (n - 1) * self.SUFFICIENT_COOPERATION_THRESHOLD_RATIO
        if stock_ratio <= self.CRITICAL_STOCK_RATIO:
            if num_C_opponents_prev >= sufficient_coop_count_threshold:
                return Action.C
            else:
                return Action.D
        elif stock_ratio <= self.LOW_STOCK_RATIO:
            if num_C_opponents_prev >= sufficient_coop_count_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_146(BaseStrategy):
    """
    The "Opportunistic Predator" strategy is designed to maximize its own total payoff over the course of the game,
    leveraging the immediate advantage of defecting while implementing safeguards to prevent a premature collapse
    of the common resource that would ultimately harm its own long-term interests. It is exploitative by default
    but adaptive to critical stock levels and potential collapse scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.my_past_actions_internal: list[Action] = []
        self.opponent_past_actions_internal: list[list[Action]] = []

    def _calculate_next_stock(self, current_S: float, my_action: Action, opp_actions_list: list[Action]) -> float:
        """
        Helper function to predict the stock level at the beginning of the *next* round,
        given current stock, this player's action, and assumed opponent actions.
        """
        consumption_me = current_S / self.n if my_action == Action.D else current_S / (2 * self.n)
        consumption_opp = 0.0
        for opp_action in opp_actions_list:
            consumption_opp += current_S / self.n if opp_action == Action.D else current_S / (2 * self.n)
        total_consumption = consumption_me + consumption_opp
        S_after_consumption = current_S - total_consumption
        if S_after_consumption < 0:
            S_after_consumption = 0.0
        growth = 2 * S_after_consumption * (1 - S_after_consumption / self.capacity)
        next_S = min(S_after_consumption + growth, self.capacity)
        return next_S

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        current_stock = state.current_stock
        action_to_play: Action = Action.D
        if current_round_0_indexed > 0 and history is not None:
            opp_actions_last_round_bool: NDArray[np.bool_] = history.opponent_actions[-1, :]
            opp_actions_last_round_enum = [Action.C if action_bool else Action.D for action_bool in opp_actions_last_round_bool]
            self.opponent_past_actions_internal.append(opp_actions_last_round_enum)
        if current_round_1_indexed == self.r:
            action_to_play = Action.D
        else:
            collapse_threshold = self.capacity / (2 * self.n)
            current_low_stock_marker = 2 * self.capacity / self.n
            assumed_opp_actions: list[Action]
            if current_round_1_indexed == 1:
                assumed_opp_actions = [Action.D] * (self.n - 1)
            else:
                assumed_opp_actions = self.opponent_past_actions_internal[-1]
            predicted_next_stock_if_I_defect = self._calculate_next_stock(current_stock, Action.D, assumed_opp_actions)
            if current_stock < current_low_stock_marker and predicted_next_stock_if_I_defect < collapse_threshold:
                action_to_play = Action.C
        self.my_past_actions_internal.append(action_to_play)
        return action_to_play

class Strategy_EXPLOITATIVE_147(BaseStrategy):
    """
    The Adaptive Predator strategy is an exploitative approach for the Common Pool Resource game.
    It prioritizes maximizing immediate individual gain by generally defecting. However, it
    incorporates a crucial self-preservation mechanism: if its defection, combined with the
    observed behavior of other players, is projected to lead to a critically low resource stock
    for the future, it will strategically cooperate. This calculated cooperation is not altruism,
    but a self-interested action to prevent irreversible damage to its own future payoff stream
    by ensuring the resource remains available for subsequent exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_critical_ratio_for_cooperation: float = 0.1
        self.Minimum_stock_absolute: float = 1.0
        self.S_critical_threshold: float = max(self.game_description.capacity * self.S_critical_ratio_for_cooperation, self.Minimum_stock_absolute)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = float(self.game_description.capacity)
        round_number_0indexed = state.round_number
        current_stock = state.current_stock
        if round_number_0indexed == 0 or round_number_0indexed == n_rounds - 1:
            return Action.D
        else:
            previous_round_opponent_actions = history.opponent_actions[-1, :]
            k_C_opponents = int(np.sum(previous_round_opponent_actions))
            k_D_opponents = n_players - 1 - k_C_opponents
            my_consumption_D = current_stock / n_players
            opponents_consumption_projected = k_D_opponents * (current_stock / n_players) + k_C_opponents * (current_stock / (2 * n_players))
            total_consumption_projected = my_consumption_D + opponents_consumption_projected
            S_remaining_projected = max(0.0, current_stock - total_consumption_projected)
            growth_projected = 2 * S_remaining_projected * (1 - S_remaining_projected / capacity)
            S_new_projected_if_I_D = min(S_remaining_projected + growth_projected, capacity)
            if S_new_projected_if_I_D <= self.S_critical_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_148(BaseStrategy):
    """
    Adaptive Exploiter strategy for the Common Pool Resource game.
    This strategy defaults to defection to maximize immediate personal gain.
    It cooperates only when its continued defection would likely lead to a critical collapse
    of the common resource, and only if its cooperation can genuinely prevent this collapse,
    thereby preserving the resource for future exploitation.
    If the resource is healthy or doomed regardless of its action, it defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.min_stock_to_avoid_collapse = max(self.capacity * 0.15, self.n_players * 2.0)

    def _project_next_stock(self, current_stock: float, my_action: Action, num_c_opponents: int, num_d_opponents: int) -> float:
        """
        Helper method to project the stock level for the next round.
        Assumes opponents repeat their last round's behavior.
        """
        current_stock = float(current_stock)
        if my_action == Action.C:
            my_consumption = current_stock / (2.0 * self.n_players)
        else:
            my_consumption = current_stock / self.n_players
        opponents_consumption_c = num_c_opponents * (current_stock / (2.0 * self.n_players))
        opponents_consumption_d = num_d_opponents * (current_stock / self.n_players)
        total_consumption = my_consumption + opponents_consumption_c + opponents_consumption_d
        stock_after_consumption = current_stock - total_consumption
        s_for_growth = max(0.0, stock_after_consumption)
        stock_growth = 2.0 * s_for_growth * (1.0 - s_for_growth / self.capacity)
        projected_s_next = min(stock_after_consumption + stock_growth, self.capacity)
        projected_s_next = max(0.0, projected_s_next)
        return projected_s_next

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        last_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        num_c_opponents_prev = np.sum(last_round_opponent_actions == True)
        num_d_opponents_prev = self.n_players - 1 - num_c_opponents_prev
        projected_s_next_if_i_d = self._project_next_stock(current_stock, Action.D, num_c_opponents_prev, num_d_opponents_prev)
        projected_s_next_if_i_c = self._project_next_stock(current_stock, Action.C, num_c_opponents_prev, num_d_opponents_prev)
        if projected_s_next_if_i_d < self.min_stock_to_avoid_collapse:
            if projected_s_next_if_i_c >= self.min_stock_to_avoid_collapse:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_149(BaseStrategy):
    """
    The "Adaptive Stock-Exploiter (ASE)" strategy is designed to ruthlessly maximize its own cumulative payoff
    by primarily defecting, while strategically cooperating only when the common resource is at risk of depletion
    AND there's a reasonable chance its cooperation can stabilize the resource for future exploitation.
    It will never sacrifice its own immediate gain for altruistic reasons or to "punish" other players
    beyond what's necessary for its long-term self-interest.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_ratio = 0.35
        self.defection_threshold_for_self_preservation = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num = state.round_number + 1
        d_rate_others = 0.0
        if state.round_number > 0 and history is not None:
            num_others_defected_last_round = np.sum(history.opponent_actions[-1, :] == False)
            d_rate_others = num_others_defected_last_round / (self.n_players - 1)
        if current_round_num == self.n_rounds:
            return Action.D
        critical_stock_threshold = self.critical_stock_ratio * self.capacity
        if state.current_stock < critical_stock_threshold:
            if d_rate_others >= self.defection_threshold_for_self_preservation:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_150(BaseStrategy):
    """
    The Adaptive Predator-Prey strategy defaults to exploitative behavior (Defect)
    but incorporates a critical survival mechanism to prevent resource collapse.
    It adapts to opponent behavior by assuming they will largely repeat their previous actions.
    Cooperation is a last-ditch effort to save the resource if the agent's defection
    would cause a collapse that its cooperation alone could prevent.
    """
    CRITICAL_STOCK_FRACTION = 0.1

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_level = self.capacity * self.CRITICAL_STOCK_FRACTION

    def _calculate_projected_stock(self, s_current: float, my_action_this_round: Action, num_defecting_opponents: int, num_cooperating_opponents: int) -> float:
        """
        Helper function to project the stock level in the next round based on current stock,
        hypothetical player actions (my_action_this_round), and game parameters.
        Assumes opponents repeat their previous round's actions.
        """
        if my_action_this_round == Action.D:
            my_consumption = s_current / self.n
        else:
            my_consumption = s_current / (2 * self.n)
        opp_d_consumption = num_defecting_opponents * (s_current / self.n)
        opp_c_consumption = num_cooperating_opponents * (s_current / (2 * self.n))
        total_consumption = my_consumption + opp_d_consumption + opp_c_consumption
        stock_after_consumption_raw = s_current - total_consumption
        effective_s_remaining_for_growth = max(0.0, stock_after_consumption_raw)
        growth = 2 * effective_s_remaining_for_growth * (1 - effective_s_remaining_for_growth / self.capacity)
        projected_stock = max(0.0, min(stock_after_consumption_raw + growth, self.capacity))
        return projected_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.D
        if current_round_1_indexed == self.r:
            return Action.D
        num_cooperating_opponents_prev_round = np.sum(history.opponent_actions[-1, :])
        num_defecting_opponents_prev_round = self.n - 1 - num_cooperating_opponents_prev_round
        projected_stock_next_round_if_i_d = self._calculate_projected_stock(s_current=state.current_stock, my_action_this_round=Action.D, num_defecting_opponents=num_defecting_opponents_prev_round, num_cooperating_opponents=num_cooperating_opponents_prev_round)
        projected_stock_next_round_if_i_c = self._calculate_projected_stock(s_current=state.current_stock, my_action_this_round=Action.C, num_defecting_opponents=num_defecting_opponents_prev_round, num_cooperating_opponents=num_cooperating_opponents_prev_round)
        if projected_stock_next_round_if_i_d < self.critical_stock_level and projected_stock_next_round_if_i_c >= self.critical_stock_level:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_151(BaseStrategy):
    """
    The Adaptive Predator strategy for the Common Pool Resource game.
    This strategy is exploitative, adaptive, and robust. It defaults to defection to maximize immediate payoff,
    but incorporates a critical stock preservation mechanism and learns from opponent behavior to ensure the
    resource remains exploitable for future rounds.
    """
    DEFECTION_OBSERVATION_WINDOW = 5
    STOCK_CRITICAL_LOW_THRESHOLD_FACTOR = 0.25
    MIN_EXPLOITABLE_LEVEL_FACTOR = 0.1
    OPPONENT_DEFECTION_TOLERANCE = 0.6

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Predator strategy.

        Args:
            game_description: An object containing game parameters (n_players, n_rounds, capacity).
        """
        self.game_description = game_description

    def _calculate_next_stock(self, current_S: float, my_action: Action, opponent_defection_rate: float, n_players: int, capacity: float) -> float:
        """
        Calculates the projected stock level for the next round given current state and hypothetical actions.

        Args:
            current_S: The current stock level.
            my_action: The hypothetical action of this player (Action.C or Action.D).
            opponent_defection_rate: The observed defection rate of opponents.
            n_players: Total number of players in the game.
            capacity: The maximum sustainable stock level.

        Returns:
            The projected stock level for the next round.
        """
        if my_action == Action.D:
            my_consumption = current_S / n_players
        else:
            my_consumption = current_S / (2 * n_players)
        expected_opponent_defection_consumption_per_player = current_S / n_players
        expected_opponent_cooperation_consumption_per_player = current_S / (2 * n_players)
        expected_opponent_total_consumption = (n_players - 1) * (opponent_defection_rate * expected_opponent_defection_consumption_per_player + (1 - opponent_defection_rate) * expected_opponent_cooperation_consumption_per_player)
        hypo_total_consumption = my_consumption + expected_opponent_total_consumption
        S_remaining = max(0.0, current_S - hypo_total_consumption)
        growth = 2 * S_remaining * (1 - S_remaining / capacity)
        next_stock = min(S_remaining + growth, capacity)
        return next_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round based on the Adaptive Predator strategy.

        Args:
            state: An object containing the current round number and stock level.
            history: An object containing past actions and payoffs for this player and opponents,
                     or None if it's the very first round (round_number 0).

        Returns:
            An Action enum (Action.C for Cooperate, Action.D for Defect).
        """
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = float(self.game_description.capacity)
        stock = state.current_stock
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == n_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.C
        num_rounds_to_observe = min(current_round_0_indexed, self.DEFECTION_OBSERVATION_WINDOW)
        relevant_opponent_actions = history.opponent_actions[max(0, current_round_0_indexed - num_rounds_to_observe):current_round_0_indexed, :]
        total_opponent_defections = np.sum(~relevant_opponent_actions)
        total_opponent_actions = relevant_opponent_actions.size
        opponent_defection_rate = 0.0
        if total_opponent_actions > 0:
            opponent_defection_rate = total_opponent_defections / total_opponent_actions
        critical_stock_level = capacity * self.STOCK_CRITICAL_LOW_THRESHOLD_FACTOR
        min_exploitable_level = capacity * self.MIN_EXPLOITABLE_LEVEL_FACTOR
        if stock > capacity * 0.75 or opponent_defection_rate < self.OPPONENT_DEFECTION_TOLERANCE:
            return Action.D
        if stock > critical_stock_level:
            return Action.D
        if stock <= critical_stock_level:
            next_stock_if_I_D = self._calculate_next_stock(current_S=stock, my_action=Action.D, opponent_defection_rate=opponent_defection_rate, n_players=n_players, capacity=capacity)
            next_stock_if_I_C = self._calculate_next_stock(current_S=stock, my_action=Action.C, opponent_defection_rate=opponent_defection_rate, n_players=n_players, capacity=capacity)
            if next_stock_if_I_D < min_exploitable_level and next_stock_if_I_C >= min_exploitable_level:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_152(BaseStrategy):
    """
    The Subtle Predator strategy for the Common Pool Resource game.
    Aims to maximize individual payoff by strategically exploiting cooperative
    opponents, while preventing premature resource collapse and retaliating
    against defection, with an aggressive endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD_RATIO = 0.25
        self.ENDGAME_WINDOW = 3
        self.TOLERANCE_FOR_DEFECTION = 0
        self.my_consecutive_cooperations_in_safe_state = 0
        self.EXPLOITATION_FREQUENCY_INV = self.game_description.n_players - 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        rounds_remaining = total_rounds - state.round_number
        num_opponents_defected_prev = 0
        if state.round_number > 0 and history is not None:
            num_opponents_defected_prev = np.sum(history.opponent_actions[-1, :] == False)
        if rounds_remaining <= self.ENDGAME_WINDOW:
            self.my_consecutive_cooperations_in_safe_state = 0
            return Action.D
        if current_stock < capacity * self.CRITICAL_STOCK_THRESHOLD_RATIO:
            if num_opponents_defected_prev == 0 and rounds_remaining > self.ENDGAME_WINDOW:
                self.my_consecutive_cooperations_in_safe_state = 0
                return Action.C
            else:
                self.my_consecutive_cooperations_in_safe_state = 0
                return Action.D
        if state.round_number == 0:
            self.my_consecutive_cooperations_in_safe_state = 1
            return Action.C
        elif num_opponents_defected_prev > self.TOLERANCE_FOR_DEFECTION:
            self.my_consecutive_cooperations_in_safe_state = 0
            return Action.D
        else:
            self.my_consecutive_cooperations_in_safe_state += 1
            if self.my_consecutive_cooperations_in_safe_state >= self.EXPLOITATION_FREQUENCY_INV:
                self.my_consecutive_cooperations_in_safe_state = 0
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_153(BaseStrategy):
    """
    The Opportunistic Predator strategy prioritizes immediate payoff maximization by defecting.
    However, it has a self-serving "lifeline" mechanism: if the common pool resource approaches
    a critically low level where its complete collapse is imminent, and if cooperation by all
    could realistically lead to its recovery (thereby preserving a source of future payoffs),
    the strategy will temporarily cooperate. This cooperation is a strategic retreat for future
    exploitation. In the final round, all incentives for resource conservation vanish, so the
    strategy defects unequivocally.
    """
    CRITICAL_STOCK_FLOOR_PERCENTAGE = 0.15
    MIN_RECOVERY_GROWTH_FACTOR = 1.05
    MIN_ROUNDS_FOR_RECOVERY_BENEFIT = 3

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_floor = self.CRITICAL_STOCK_FLOOR_PERCENTAGE * self.capacity
        self.min_recovery_growth_factor = self.MIN_RECOVERY_GROWTH_FACTOR
        self.min_rounds_for_recovery_benefit = self.MIN_ROUNDS_FOR_RECOVERY_BENEFIT

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == self.n_rounds - 1:
            return Action.D
        if current_stock <= self.critical_stock_floor:
            consumption_if_all_C = current_stock / 2.0
            s_remaining_after_all_C = current_stock - consumption_if_all_C
            s_remaining_after_all_C = max(0.0, s_remaining_after_all_C)
            growth_if_all_C = 2.0 * s_remaining_after_all_C * (1.0 - s_remaining_after_all_C / self.capacity)
            s_next_if_all_C = min(s_remaining_after_all_C + growth_if_all_C, self.capacity)
            num_future_rounds_remaining = self.n_rounds - 1 - current_round_number
            if s_next_if_all_C > current_stock * self.min_recovery_growth_factor and num_future_rounds_remaining >= self.min_rounds_for_recovery_benefit:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_154(BaseStrategy):
    """
    The Opportunistic Predator maximizes its personal payoff by aggressively exploiting the common resource whenever feasible.
    It strategically cooperates in a self-interested manner to prevent total resource collapse, which would eliminate all future profits.
    The strategy adapts its aggression level based on the current stock's health and the observed behavior of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_level = self.capacity / (2 * self.n_players)
        self.opponent_aggression_threshold = math.ceil((self.n_players - 1) / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number >= self.n_rounds - 2:
            return Action.D
        if state.current_stock <= self.critical_stock_level:
            return Action.C
        elif state.round_number == 0:
            return Action.D
        else:
            num_opponent_D_prev_round = (history.opponent_actions[-1, :] == False).sum()
            if num_opponent_D_prev_round >= self.opponent_aggression_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_155(BaseStrategy):
    """
    The Calculating Harvester aims to maximize its individual total payoff by strategically exploiting
    the common resource and other players' cooperation. It operates on a principle of "greedy but not suicidal."
    It is aggressive in early rounds to test boundaries and capture immediate gains, and will always free-ride
    when the resource is abundant and others are cooperative. However, it enforces self-preservation when
    the common stock becomes critically low, or when a temporary cooperation can lead to a healthier resource
    ripe for future exploitation. It will also retaliate against widespread defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_absolute = 2 * self.n_players
        self.healthy_stock_threshold = 0.75 * self.capacity
        self.early_game_rounds_threshold = math.floor(self.n_rounds / 3)
        self.defection_response_threshold = math.floor((self.n_players - 1) / 3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_stock < self.critical_stock_absolute:
            return Action.C
        num_opponent_defectors_prev_round = 0
        if state.round_number > 0 and history is not None:
            num_cooperators_prev_round = np.sum(history.opponent_actions[state.round_number - 1, :])
            num_opponent_defectors_prev_round = self.n_players - 1 - num_cooperators_prev_round
        if current_round_1_indexed <= self.early_game_rounds_threshold:
            if current_stock < self.capacity / 4:
                return Action.C
            else:
                return Action.D
        elif num_opponent_defectors_prev_round >= self.defection_response_threshold:
            return Action.D
        elif current_stock > self.healthy_stock_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_156(BaseStrategy):
    """
    Adaptive Predator strategy for the Common Pool Resource Game.

    This strategy aims to be highly exploitative by prioritizing immediate self-gain,
    defaulting to aggressive defection, but with a critical safeguard to ensure
    the resource remains viable for future exploitation. It exploits cooperative
    opponents and joins defecting ones for short-term gains, only backing off
    when the resource itself is threatened.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.critical_stock_threshold = 2 * self.n

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.r - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        if current_stock < self.critical_stock_threshold:
            return Action.C
        else:
            previous_round_others_actions = history.opponent_actions[-1, :]
            total_others = self.n - 1
            num_others_cooperating_last_round = np.sum(previous_round_others_actions)
            return Action.D

class Strategy_EXPLOITATIVE_157(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its individual total payoff.
    It defaults to aggressive defection for immediate gains but possesses a strong
    self-preservation instinct. It will temporarily cooperate only when the resource
    is critically endangered and there is sufficient collective effort from other
    players to make its cooperation impactful for future exploitation. Otherwise, it
    will continue to defect, prioritizing its own share even if it leads to resource
    depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_critical_low = self.capacity / self.n
        self.k_D_trigger = math.floor((self.n - 1) / 2) + 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == self.r - 1:
            return Action.D
        if current_round_number == 0:
            return Action.D
        else:
            num_opponent_defectors_prev_round = np.sum(~history.opponent_actions[-1, :])
            if current_stock <= self.S_critical_low:
                if num_opponent_defectors_prev_round < self.k_D_trigger:
                    return Action.C
                else:
                    return Action.D
            elif num_opponent_defectors_prev_round < self.k_D_trigger:
                return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_158(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize personal cumulative payoff by primarily defecting
    (exploiting) while employing adaptive mechanisms to prevent premature resource collapse.
    It balances short-term gain with long-term viability by adjusting behavior based on current stock,
    remaining game length, and an estimation of opponents' future actions.
    """
    S_DANGER_THRESHOLD_FACTOR = 0.25

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_DANGER_THRESHOLD = self.game_description.capacity * self.S_DANGER_THRESHOLD_FACTOR

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        stock = state.current_stock
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if current_round == r - 1:
            return Action.D
        if current_round == r - 2:
            return Action.D
        if stock <= self.S_DANGER_THRESHOLD:
            return Action.C
        num_opponents = n - 1
        num_D_opponents_prev = 0
        if history is not None:
            for action_bool in history.opponent_actions[current_round - 1, :]:
                if not action_bool:
                    num_D_opponents_prev += 1
        else:
            num_D_opponents_prev = 0
        my_D_consumption = stock / n
        projected_opponent_D_consumption = num_D_opponents_prev * (stock / n)
        projected_opponent_C_consumption = (num_opponents - num_D_opponents_prev) * (stock / (2 * n))
        estimated_total_consumption_if_I_D = my_D_consumption + projected_opponent_D_consumption + projected_opponent_C_consumption
        predicted_S_remaining_after_consumption_if_I_D = stock - estimated_total_consumption_if_I_D
        if predicted_S_remaining_after_consumption_if_I_D < 0:
            predicted_S_remaining_after_consumption_if_I_D = 0
        growth_if_I_D = 2 * predicted_S_remaining_after_consumption_if_I_D * (1 - predicted_S_remaining_after_consumption_if_I_D / capacity)
        predicted_new_stock_if_I_D = min(predicted_S_remaining_after_consumption_if_I_D + growth_if_I_D, capacity)
        if predicted_new_stock_if_I_D <= self.S_DANGER_THRESHOLD:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_159(BaseStrategy):
    """
    The Apex Predator strategy prioritizes maximizing its own cumulative payoff by aggressively defecting (D).
    It strategically cooperates (C) only when absolutely necessary to prevent the total collapse of the
    common resource, thereby preserving future opportunities for exploitation. It behaves selfishly, never
    cooperating out of a desire for mutual benefit, but solely for self-preservation of its future income stream.
    """
    CRITICAL_STOCK_THRESHOLD_RATIO = 0.25

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Apex Predator strategy with game parameters.
        """
        self.game_description = game_description
        self.critical_stock_threshold = float(self.CRITICAL_STOCK_THRESHOLD_RATIO) * self.game_description.capacity
        self.defection_punishment_trigger_count = self.game_description.n_players - 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round based on the Apex Predator strategy.

        Args:
            state (CommonPoolState): The current state of the game, including round number and stock level.
            history (None | PlayerHistory): The history of actions and payoffs from previous rounds.
                                            Will be None for the very first round (round_number == 0).

        Returns:
            Action: The chosen action for the current round (Action.C for Cooperate, Action.D for Defect).
        """
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.D
        if state.current_stock < self.critical_stock_threshold:
            return Action.C
        num_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
        num_other_players_D_last_round = self.defection_punishment_trigger_count - num_cooperators_last_round
        if num_other_players_D_last_round == self.defection_punishment_trigger_count:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_160(BaseStrategy):
    """
    The "Exploitative Resource Manager (ERM)" strategy aims to maximize its own total payoff.
    It adopts an aggressive stance by default, but strategically cooperates to prevent resource
    collapse or to induce cooperation from opponents for future exploitation.

    Decision hierarchy:
    1. Last Round: Defect to maximize immediate gain.
    2. Emergency Stock Preservation: Cooperate if stock is critically low to prevent collapse.
    3. First Round: Defect to probe and establish an aggressive stance.
    4. Adaptive Play (Intermediate Rounds):
       a. High Opponent Cooperation: Defect to free-ride.
       b. High Opponent Defection: Defect to avoid being a sucker.
       c. Strategic Influence (Later Rounds with moderate cooperation): Cooperate to induce more cooperation.
       d. Early Rounds, Mixed Behavior: Default to Defect.
    """
    CRITICAL_STOCK_THRESHOLD_RATIO = 0.25
    HIGH_COOP_THRESHOLD_RATIO = 0.6
    LOW_COOP_THRESHOLD_RATIO = 0.3
    HIGH_DEFECT_THRESHOLD_RATIO = 0.7
    RECIPROCITY_INITIATION_ROUND = 3

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if state.current_stock < self.capacity * self.CRITICAL_STOCK_THRESHOLD_RATIO:
            return Action.C
        if state.round_number == 0:
            return Action.D
        prev_round_idx = state.round_number - 1
        prev_opponent_C_count = sum(history.opponent_actions[prev_round_idx, :])
        num_opponents = self.n_players - 1
        prev_opponent_D_count = num_opponents - prev_opponent_C_count
        prev_opponent_coop_ratio = prev_opponent_C_count / num_opponents
        prev_opponent_defect_ratio = prev_opponent_D_count / num_opponents
        decision = Action.D
        if prev_opponent_coop_ratio >= self.HIGH_COOP_THRESHOLD_RATIO:
            decision = Action.D
        elif prev_opponent_defect_ratio >= self.HIGH_DEFECT_THRESHOLD_RATIO:
            decision = Action.D
        elif current_round_1_indexed >= self.RECIPROCITY_INITIATION_ROUND:
            if prev_opponent_coop_ratio >= self.LOW_COOP_THRESHOLD_RATIO:
                decision = Action.C
            else:
                decision = Action.D
        else:
            decision = Action.D
        return decision

class Strategy_EXPLOITATIVE_161(BaseStrategy):
    """
    The "Adaptive Exploiter" strategy for the Common Pool Resource game.
    This strategy aims to maximize its own total payoff over 'r' rounds by balancing
    immediate gains from defection with the need to maintain the common resource for
    future exploitation. It adapts its behavior based on the current state of the
    stock and the observed actions of other players.

    Core Principles:
    1. Exploit when safe: Defect when the stock is high and other players are cooperating.
    2. Survive when threatened: Cooperate if the stock is critically low.
    3. Punish/Desert Defectors: If many others defect, join them.
    4. Endgame Grab: Always defect in the final round.
    5. Initial Assessment: Strategic move in the first round to set the stage.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_low_threshold = game_description.capacity / 4.0
        self.S_high_threshold = game_description.capacity * 0.75
        self.Cooperation_Tolerance = 0.5
        self.Punishment_Threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        if current_round_1_indexed == total_rounds:
            return Action.D
        if current_stock < self.S_low_threshold:
            return Action.C
        if current_round_0_indexed == 0:
            if current_stock >= self.game_description.capacity * 0.9:
                return Action.C
            else:
                return Action.D
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        num_opponent_cooperators_prev_round = np.sum(previous_round_opponent_actions)
        cooperation_rate_prev_round = num_opponent_cooperators_prev_round / (n - 1)
        if current_stock >= self.S_high_threshold and cooperation_rate_prev_round >= self.Cooperation_Tolerance:
            return Action.D
        if cooperation_rate_prev_round < 1 - self.Punishment_Threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_162(BaseStrategy):
    """
    ExploiterMax aims to maximize its total payoff over 'r' rounds. It balances
    immediate gains with long-term resource sustainability. It strategically
    cooperates when the resource is critically low or when others are cooperating,
    allowing the resource to recover or persist. Conversely, it defects aggressively
    when the resource is abundant or when other players are already defecting,
    to ensure it captures its maximal share and avoids being a "sucker."
    """
    MIN_STOCK_FACTOR: float
    AGGRESSION_THRESHOLD_FACTOR: float
    DEFECTION_TOLERANCE_FACTOR: float

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the ExploiterMax strategy with game parameters and strategy-specific thresholds.
        """
        self.game_description = game_description
        self.MIN_STOCK_FACTOR = 0.1
        self.AGGRESSION_THRESHOLD_FACTOR = 0.7
        self.DEFECTION_TOLERANCE_FACTOR = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round
        based on stock level, round number, and opponents' previous actions.
        """
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == n_rounds - 1:
            return Action.D
        if current_round_number == 0:
            return Action.D
        if current_stock < capacity * self.MIN_STOCK_FACTOR:
            return Action.C
        if current_stock >= capacity * self.AGGRESSION_THRESHOLD_FACTOR:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[current_round_number - 1]
        num_others = n_players - 1
        if num_others == 0:
            return Action.C
        num_C_others_prev_round = np.sum(previous_round_opponent_actions)
        num_D_others_prev_round = num_others - num_C_others_prev_round
        defection_rate_others = num_D_others_prev_round / num_others
        if defection_rate_others >= self.DEFECTION_TOLERANCE_FACTOR:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_163(BaseStrategy):
    """
    Ruthless Opportunist with Emergency Brake (ROE) strategy for the Common Pool Resource game.

    This strategy aims to maximize the player's total payoff by primarily defecting,
    but with a critical contingency to prevent the complete collapse of the common
    resource. It defaults to defecting to maximize immediate gains. However, if the
    shared resource is critically low AND a significant number of other players are
    also defecting (indicating a collective rush to depletion), the strategy will
    temporarily cooperate. This cooperation is a calculated, self-serving action
    to prevent total resource collapse, thereby preserving opportunities for
    future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_STOCK_LEVEL = self.capacity / 4.0
        self.HIGH_DEFECTION_RATE_THRESHOLD = self.n_players / 2.0
        self.IMMINENT_COLLAPSE_THRESHOLD = self.capacity / (2.0 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.D
        elif current_round_1_indexed == self.total_rounds:
            return Action.D
        else:
            num_cooperators_prev_round = np.sum(history.opponent_actions[-1, :])
            num_defectors_prev_round = self.n_players - 1 - num_cooperators_prev_round
            my_consumption_if_D = current_stock / self.n_players
            other_D_consumption = num_defectors_prev_round * (current_stock / self.n_players)
            other_C_consumption = num_cooperators_prev_round * (current_stock / (2.0 * self.n_players))
            total_consumption_if_i_D = my_consumption_if_D + other_D_consumption + other_C_consumption
            stock_after_my_D_and_others_actions = current_stock - total_consumption_if_i_D
            if current_stock < self.CRITICAL_STOCK_LEVEL and num_defectors_prev_round >= self.HIGH_DEFECTION_RATE_THRESHOLD and (stock_after_my_D_and_others_actions < self.IMMINENT_COLLAPSE_THRESHOLD):
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_164(BaseStrategy):
    """
    Adaptive Stock Predator: An exploitative strategy for the Common Pool Resource game.
    It prioritizes immediate gain, free-rides on cooperators, joins the rush when others
    defect, and only cooperates as a calculated, self-serving measure to prevent total
    resource collapse or to allow for future, more aggressive exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        self.S_critical_threshold = capacity / (4.0 * n_players)
        self.S_healthy_threshold = capacity * 0.75
        self.defection_tolerance_low = 0.3
        self.defection_tolerance_high = 0.7
        self.last_rounds_threshold = max(2, int(total_rounds / 3.0))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        if total_rounds - current_round_0_indexed <= self.last_rounds_threshold:
            return Action.D
        if current_stock <= self.S_critical_threshold:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.D
        prev_round_history_idx = current_round_0_indexed - 1
        opponent_actions_prev_round = history.opponent_actions[prev_round_history_idx, :]
        num_cooperators_prev_round = np.sum(opponent_actions_prev_round)
        n_opponents = n_players - 1
        num_defectors_prev_round = n_opponents - num_cooperators_prev_round
        opponent_defection_ratio = num_defectors_prev_round / n_opponents
        if opponent_defection_ratio < self.defection_tolerance_low:
            return Action.D
        elif opponent_defection_ratio >= self.defection_tolerance_high:
            return Action.D
        elif current_stock >= self.S_healthy_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_165(BaseStrategy):
    """
    Adaptive Predation: This strategy aims to maximize its own total payoff by defecting when the
    resource can sustain it or when others are cooperating, essentially free-riding. It only switches
    to cooperation when the resource is critically endangered to prevent total collapse, ensuring
    future exploitation opportunities. As the game nears its end, the strategy becomes increasingly
    aggressive, tolerating more defection from others to maximize final gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock_S = state.current_stock
        current_round_t = state.round_number + 1
        if current_round_t == self.n_rounds:
            return Action.D
        S_critical_threshold = self.capacity / 4.0
        if current_stock_S <= S_critical_threshold:
            return Action.C
        if current_round_t == 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        num_other_defectors = (previous_round_opponent_actions == False).sum()
        defection_rate = num_other_defectors / (self.n_players - 1)
        stock_health_factor = current_stock_S / self.capacity
        base_defection_tolerance: float
        if stock_health_factor > 0.75:
            base_defection_tolerance = 0.75
        elif stock_health_factor > 0.5:
            base_defection_tolerance = 0.5
        else:
            base_defection_tolerance = 0.25
        round_progress = (current_round_t - 1) / (self.n_rounds - 1)
        aggression_boost = 0.3 * round_progress
        effective_defection_tolerance = min(1.0, base_defection_tolerance + aggression_boost)
        if defection_rate < effective_defection_tolerance:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_166(BaseStrategy):
    """
    Adaptive Opportunist with Collapse Aversion (AOCA) strategy for the Common Pool Resource game.
    This strategy is designed to maximize its total payoff by generally defecting,
    but it strategically cooperates under specific conditions to prevent resource collapse
    and to adapt to opponent behaviors. It does not assume any pre-existing norms or
    communication channels and is designed for a tournament setting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with the game's parameters.

        Args:
            game_description (CommonPoolDescription): An object containing game parameters
                                                      (n_players, n_rounds, capacity).
        """
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round based on
        the AOCA strategy's decision rules.

        Args:
            state (CommonPoolState): The current state of the game, including round number and stock.
            history (None | PlayerHistory): The history of actions and payoffs from previous rounds.
                                            None for the very first round (round_number = 0).

        Returns:
            Action: The chosen action, either Action.C (Cooperate) or Action.D (Defect).
        """
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.D
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        prev_round_index = state.round_number - 1
        prev_round_my_action = history.my_actions[prev_round_index]
        prev_round_opponent_actions = history.opponent_actions[prev_round_index, :]
        my_defect_prev_round = 1 if prev_round_my_action == False else 0
        opponent_defects_prev_round = np.sum(prev_round_opponent_actions == False)
        num_defectors_prev_round = my_defect_prev_round + opponent_defects_prev_round
        S_current = state.current_stock
        if S_current < self.capacity / self.n_players:
            return Action.C
        if S_current < self.capacity / 2 and num_defectors_prev_round <= self.n_players / 3:
            return Action.C
        if num_defectors_prev_round > self.n_players / 2 and S_current >= self.capacity / self.n_players and (S_current < self.capacity * 0.75):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_167(BaseStrategy):
    """
    The "Opportunistic Defector" strategy for the Common Pool Resource Game.

    This strategy aims to maximize individual total payoff by consistently defecting
    whenever the common pool stock is robust enough. It temporarily cooperates only
    as a last resort to prevent the complete collapse of the resource, thus preserving
    future opportunities for exploitation. In the final rounds, it abandons
    all pretense of cooperation to extract maximum value.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k_rounds_aggressive = 2
        self.min_stock_for_cooperation_threshold_ratio = 0.3
        self.critically_doomed_stock_threshold_ratio = 0.1
        capacity_float = float(game_description.capacity)
        n_players = game_description.n_players
        base_min_stock_trigger = self.min_stock_for_cooperation_threshold_ratio * capacity_float
        self.min_stock_trigger = max(base_min_stock_trigger, float(2 * n_players))
        self.doomed_stock_trigger = self.critically_doomed_stock_threshold_ratio * capacity_float

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_game_round = state.round_number + 1
        if current_game_round >= self.game_description.n_rounds - self.k_rounds_aggressive + 1:
            return Action.D
        if current_game_round == 1:
            return Action.D
        if state.current_stock < self.min_stock_trigger:
            num_cooperators_prev_round = np.sum(history.opponent_actions[state.round_number - 1, :])
            N_D_prev = self.game_description.n_players - 1 - num_cooperators_prev_round
            if state.current_stock < self.doomed_stock_trigger and N_D_prev == self.game_description.n_players - 1:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_168(BaseStrategy):
    """
    Opportunistic Predator strategy for the Common Pool Resource game.

    This strategy aims to defect whenever it can maximize its immediate payoff
    without causing a catastrophic collapse of the shared resource or being a "sucker"
    when others are already defecting too much. It uses thresholds for the stock level
    and for the observed defection rate of other players to make its decisions.

    The strategy evaluates conditions in a specific order:
    1. Last Round Logic: Always Defect in the final round for maximum immediate payoff.
    2. Resource Criticality Check: Cooperate if the stock is below a critical threshold
       to allow for resource recovery, preventing total collapse.
    3. Adaptive Exploitation Logic:
        a. First Round: Defect to test opponents and gain an early advantage.
        b. Subsequent Rounds: Defect if the proportion of other players defecting
           in the previous round is below a tolerance level (exploiting cooperation).
           Otherwise, cooperate to stabilize the resource if too many others are defecting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_CRITICAL_RATIO = 0.25
        self.COOPERATION_TOLERANCE = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_stock <= self.capacity * self.S_CRITICAL_RATIO:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.D
        num_other_defectors = np.sum(~history.opponent_actions[-1, :])
        defection_proportion = num_other_defectors / (self.n_players - 1)
        if defection_proportion <= self.COOPERATION_TOLERANCE:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_169(BaseStrategy):
    """
    The Opportunistic Defector strategy for the Common Pool Resource game.

    This strategy aims to maximize immediate individual payoff through defection
    but cooperates under specific conditions when the resource is critically low
    AND opponents show a willingness to cooperate, allowing for potential recovery
    and future exploitation. It defaults to defection in the first and last rounds
    and when the stock is healthy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history_window: int = 3
        self.safety_stock_threshold_multiplier: float = 0.25
        self.cooperation_threshold_for_recovery: float = 0.5
        self.safety_stock_threshold: float = self.game_description.capacity * self.safety_stock_threshold_multiplier

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_round_zero_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_zero_indexed == 0 or current_round_zero_indexed == n_rounds - 1:
            return Action.D
        else:
            num_opponents_cooperating_in_window = 0
            num_opponent_actions_in_window = 0
            if history is not None:
                start_history_idx = max(0, current_round_zero_indexed - self.history_window)
                recent_opponent_actions = history.opponent_actions[start_history_idx:current_round_zero_indexed, :]
                num_opponents_cooperating_in_window = np.sum(recent_opponent_actions)
                num_opponent_actions_in_window = recent_opponent_actions.size
            cooperation_ratio = 0.0
            if num_opponent_actions_in_window > 0:
                cooperation_ratio = float(num_opponents_cooperating_in_window) / num_opponent_actions_in_window
            if current_stock <= self.safety_stock_threshold:
                if cooperation_ratio >= self.cooperation_threshold_for_recovery:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_170(BaseStrategy):
    """
    Adaptive Stock Predator (ASP) strategy for the Common Pool Resource game.
    This strategy combines self-preservation, opportunistic exploitation,
    and aggressive endgame tactics. It continuously monitors the common stock level
    and the recent actions of other players to make informed decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_panic_threshold = self.capacity / 4.0
        self.stock_exploit_threshold = self.capacity * 0.75
        self.cooperation_required_for_exploit = (self.n_players - 1) / 2.0
        self.future_stock_advantage_factor = 1.25
        self.crisis_avoidance_advantage_factor = 1.5

    def _project_next_stock(self, current_stock: float, my_action: Action, n_cooperators_others: int, n_defectors_others: int) -> float:
        """
        Projects the next round's stock level based on current stock,
        my hypothetical action, and observed opponent actions.
        """
        my_consumption = 0.0
        if my_action == Action.C:
            my_consumption = current_stock / (2.0 * self.n_players)
        else:
            my_consumption = current_stock / self.n_players
        consumption_by_others_C = n_cooperators_others * (current_stock / (2.0 * self.n_players))
        consumption_by_others_D = n_defectors_others * (current_stock / self.n_players)
        total_consumption = my_consumption + consumption_by_others_C + consumption_by_others_D
        s_remaining = max(0.0, current_stock - total_consumption)
        growth_factor = 1.0 - s_remaining / self.capacity
        growth = 2.0 * s_remaining * growth_factor
        next_s = min(s_remaining + growth, self.capacity)
        return next_s

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == self.n_rounds - 2:
            if current_stock < self.stock_panic_threshold / 2.0:
                return Action.C
            else:
                return Action.D
        n_cooperators_others = int(np.sum(history.opponent_actions[-1, :]))
        n_defectors_others = self.n_players - 1 - n_cooperators_others
        if current_stock < self.stock_panic_threshold:
            return Action.C
        if current_stock >= self.stock_exploit_threshold and n_cooperators_others >= self.cooperation_required_for_exploit:
            return Action.D
        next_stock_if_I_C = self._project_next_stock(current_stock, Action.C, n_cooperators_others, n_defectors_others)
        next_stock_if_I_D = self._project_next_stock(current_stock, Action.D, n_cooperators_others, n_defectors_others)
        if next_stock_if_I_D < self.stock_panic_threshold:
            if next_stock_if_I_C >= self.stock_panic_threshold:
                return Action.C
            elif next_stock_if_I_C > next_stock_if_I_D * self.crisis_avoidance_advantage_factor:
                return Action.C
            else:
                return Action.D
        if next_stock_if_I_C > next_stock_if_I_D * self.future_stock_advantage_factor:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_171(BaseStrategy):
    """
    The "Opportunistic Scavenger" strategy prioritizes immediate gain by defaulting to defection,
    but adapts to preserve the common pool resource for future exploitation. It cooperates
    when the stock is critically low or when too many others are defecting and the stock
    needs management, otherwise it exploits by defecting, especially when others cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.S_Critical_Low = float(n)
        self.S_Management_Threshold = capacity / 2.0
        self.Opponent_Cooperation_Ratio_for_Exploitation = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == n_rounds - 1:
            return Action.D
        if current_stock <= self.S_Critical_Low:
            return Action.C
        if current_round == 0:
            return Action.D
        k_cooperators_prev_round = np.sum(history.opponent_actions[-1, :])
        num_other_players = n_players - 1
        other_players_cooperation_ratio = k_cooperators_prev_round / num_other_players
        if current_stock > self.S_Management_Threshold:
            return Action.D
        elif other_players_cooperation_ratio >= self.Opponent_Cooperation_Ratio_for_Exploitation:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_172(BaseStrategy):
    """
    The Opportunistic Predator strategy aims to maximize its own total payoff by aggressively exploiting
    cooperative opponents while adaptively preserving the common resource only when it directly benefits
    the predator's long-term total payoff. It defaults to defection, retreats to cooperation when the
    resource is critically low or when many others defect but the resource is not yet critical,
    and defects in the final round to scavenge.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.DEEP_RED_STOCK_FACTOR = 1.0 / (2 * self.n_players)
        self.YELLOW_WARNING_STOCK_FACTOR = 1.0 / self.n_players
        self.REACTION_THRESHOLD_DEFECTION_RATE = 0.5
        self.MIN_ROUNDS_FOR_RECOVERY_ATTEMPT = max(2, self.n_rounds // 4)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        stock = state.current_stock
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if stock <= self.capacity * self.DEEP_RED_STOCK_FACTOR:
            rounds_remaining = self.n_rounds - state.round_number
            if rounds_remaining >= self.MIN_ROUNDS_FOR_RECOVERY_ATTEMPT:
                return Action.C
            else:
                return Action.D
        n_opponents = self.n_players - 1
        others_defection_rate = 0.0
        if state.round_number > 0:
            num_cooperators_last_round = np.sum(history.opponent_actions[state.round_number - 1, :])
            num_defectors_last_round = n_opponents - num_cooperators_last_round
            others_defection_rate = num_defectors_last_round / n_opponents
        if others_defection_rate <= self.REACTION_THRESHOLD_DEFECTION_RATE:
            return Action.D
        elif stock <= self.capacity * self.YELLOW_WARNING_STOCK_FACTOR:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_173(BaseStrategy):
    """
    The "Adaptive Predator" strategy for the Common Pool Resource Game.
    This strategy aims to maximize its own total payoff over the course of the game,
    adapting its behavior based on the current state of the common resource and
    the observed actions of other players. It is fundamentally exploitative,
    aiming to take advantage of any existing cooperation, but also pragmatic
    enough to cooperate strategically when necessary to preserve the resource
    for future exploitation or to encourage a return to a more exploitable state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.D
        if current_round_1_indexed == r:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[-1]
        num_cooperating_last_round = np.sum(previous_round_opponent_actions)
        num_defecting_last_round = n - num_cooperating_last_round
        critical_stock_level = capacity / 4.0
        if current_stock <= critical_stock_level:
            if num_defecting_last_round <= n / 2.0:
                return Action.C
            else:
                return Action.D
        elif num_defecting_last_round < n / 2.0:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_174(BaseStrategy):
    """
    The "Grudging Opportunist" strategy aims to maximize its total payoff by primarily exploiting other players'
    cooperation through defection, but is pragmatically willing to cooperate under specific conditions:
    1. To prevent resource collapse at critically low stock levels.
    2. To attempt to "reset" a cycle of mutual defection, thereby preserving future opportunities for exploitation.
    """
    COOPERATION_ATTEMPT_PERIOD = 3

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD = self.game_description.capacity / 4.0
        self.consecutive_defections_in_hostile_environment: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r_total = self.game_description.n_rounds
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == r_total - 1:
            self.consecutive_defections_in_hostile_environment = 0
            return Action.D
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            self.consecutive_defections_in_hostile_environment = 0
            return Action.C
        if current_round_0_indexed == 0:
            self.consecutive_defections_in_hostile_environment = 0
            return Action.D
        my_last_action_is_C = history.my_actions[-1]
        others_last_actions_is_C = history.opponent_actions[-1, :]
        num_others_cooperating_prev_round = np.sum(others_last_actions_is_C)
        num_others_defecting_prev_round = n - 1 - num_others_cooperating_prev_round
        if num_others_cooperating_prev_round >= num_others_defecting_prev_round:
            self.consecutive_defections_in_hostile_environment = 0
            return Action.D
        elif my_last_action_is_C:
            self.consecutive_defections_in_hostile_environment = 0
            return Action.D
        elif self.consecutive_defections_in_hostile_environment >= self.COOPERATION_ATTEMPT_PERIOD:
            self.consecutive_defections_in_hostile_environment = 0
            return Action.C
        else:
            self.consecutive_defections_in_hostile_environment += 1
            return Action.D

class Strategy_EXPLOITATIVE_175(BaseStrategy):
    """
    Opportunistic Harvester strategy for the Common Pool Resource Game.
    This strategy aims to maximize cumulative payoff by consistently defecting,
    while cautiously preserving the resource only when its own actions can
    prevent a critical stock depletion that would otherwise render future
    rounds unprofitable. It free-rides on others' cooperation and only
    contributes to resource conservation when it's a strategic necessity
    for long-term self-interest.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.SURVIVAL_THRESHOLD = float(self.game_description.capacity) * 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = float(self.game_description.capacity)
        current_stock = float(state.current_stock)
        if state.round_number == 0:
            return Action.D
        if state.round_number == n_rounds - 1:
            return Action.D
        previous_round_actions_by_opponents = history.opponent_actions[state.round_number - 1, :]
        num_cooperators_last_round = np.sum(previous_round_actions_by_opponents)
        num_defectors_last_round = n_players - 1 - num_cooperators_last_round
        consumption_per_player_D = current_stock / n_players
        consumption_per_player_C = current_stock / (2 * n_players)
        consumption_by_others = num_defectors_last_round * consumption_per_player_D + num_cooperators_last_round * consumption_per_player_C
        consumption_by_me_if_I_D = consumption_per_player_D
        total_consumption_if_I_D = consumption_by_me_if_I_D + consumption_by_others
        S_after_consumption_if_I_D = max(0.0, current_stock - total_consumption_if_I_D)
        growth_if_I_D = 2 * S_after_consumption_if_I_D * (1 - S_after_consumption_if_I_D / capacity)
        projected_S_next_if_I_D = min(S_after_consumption_if_I_D + growth_if_I_D, capacity)
        consumption_by_me_if_I_C = consumption_per_player_C
        total_consumption_if_I_C = consumption_by_me_if_I_C + consumption_by_others
        S_after_consumption_if_I_C = max(0.0, current_stock - total_consumption_if_I_C)
        growth_if_I_C = 2 * S_after_consumption_if_I_C * (1 - S_after_consumption_if_I_C / capacity)
        projected_S_next_if_I_C = min(S_after_consumption_if_I_C + growth_if_I_C, capacity)
        if projected_S_next_if_I_D < self.SURVIVAL_THRESHOLD:
            if projected_S_next_if_I_C >= self.SURVIVAL_THRESHOLD:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_176(BaseStrategy):
    """
    The "Adaptive Opportunist" player operates with a fundamentally selfish goal: to secure the largest
    possible share of the resource. This means defaulting to Defect (D) to maximize immediate gain.
    However, it is not blindly destructive; it recognizes that a completely depleted resource yields no
    future payoffs. Therefore, it will conditionally "cooperate" (C) as a calculated investment to
    preserve the resource for future exploitation, but only if the resource is critically endangered
    *and* a sufficient number of other players are also contributing to its recovery. Otherwise, it
    will continue to defect, ensuring it is never a "sucker" that cooperates while others free-ride.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_FACTOR = 0.1
        self.COOP_TO_SAVE_THRESHOLD = 0.5
        self.HISTORY_WINDOW = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_t = state.round_number
        current_stock_S = state.current_stock
        if current_round_t == n_rounds - 1:
            return Action.D
        if current_round_t == 0:
            return Action.D
        num_other_players = n_players - 1
        rounds_to_analyze = min(current_round_t, self.HISTORY_WINDOW)
        total_observed_other_actions = 0
        other_cooperations_count = 0
        for round_idx in range(current_round_t - rounds_to_analyze, current_round_t):
            other_cooperations_count += np.sum(history.opponent_actions[round_idx, :])
            total_observed_other_actions += num_other_players
        avg_coop_rate_others = float(other_cooperations_count) / total_observed_other_actions
        if current_stock_S < capacity * self.CRITICAL_STOCK_FACTOR:
            if avg_coop_rate_others >= self.COOP_TO_SAVE_THRESHOLD:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_177(BaseStrategy):
    """
    The Opportunistic Harvester strategy for the Common Pool Resource Game.
    This strategy prioritizes maximizing its own total payoff by primarily defecting,
    but strategically cooperates when it is a calculated investment to preserve the
    resource for future exploitation or to avoid being a "sucker" in a declining pool.
    It is adaptive to opponent behavior and game state, and becomes increasingly
    aggressive as the game nears its end.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        num_players = self.game_description.n_players
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == total_rounds:
            return Action.D
        num_cooperators_among_others = np.sum(history.opponent_actions[-1, :])
        num_others = num_players - 1
        cooperation_ratio = num_cooperators_among_others / num_others
        CT_base = 0.5
        CT_adjusted = CT_base
        if current_stock < capacity / (2 * num_players):
            CT_adjusted *= 1.5
        elif current_stock < capacity / num_players:
            CT_adjusted *= 1.2
        else:
            CT_adjusted *= 0.8
        rounds_remaining = total_rounds - current_round_1_indexed
        if rounds_remaining <= 3:
            CT_adjusted *= 1.8
        elif rounds_remaining >= total_rounds / 2:
            CT_adjusted *= 0.8
        if cooperation_ratio >= CT_adjusted:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_178(BaseStrategy):
    """
    The Calculating Predator strategy aims to free-ride on others' cooperation,
    prioritizing immediate gains. It only cooperates to preserve the common pool
    resource if its health critically threatens future profits, or if temporary
    cooperation can enable future exploitation. In widespread defection, it
    maximizes immediate gain, even at the cost of the resource, if its own
    cooperation would be futile.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_stock < self.n_players:
            if current_round_0_indexed == self.n_rounds - 2:
                return Action.D
            else:
                return Action.C
        if current_round_0_indexed == 0:
            return Action.D
        num_other_cooperators = sum(history.opponent_actions[-1, :])
        prop_coop = num_other_cooperators / (self.n_players - 1)
        if prop_coop >= 0.75:
            return Action.D
        elif prop_coop >= 0.5:
            return Action.D
        elif prop_coop >= 0.25:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_179(BaseStrategy):
    """
    Adaptive Exploiter with Stock Preservation.

    This strategy aims to maximize its own total payoff by primarily defecting.
    It is highly aggressive and free-rides on the cooperation of others.
    However, it incorporates a survival mechanism: if the common stock falls to a
    dangerously low level, it will conditionally cooperate to help replenish the
    resource, but only if a sufficient number of other players are also
    cooperating in the previous round. This prevents the resource from collapsing
    entirely. In the final two rounds, it abandons all pretense of preservation
    and defects unconditionally.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.STOCK_PRESERVATION_THRESHOLD = self.capacity / 4.0
        self.MIN_COOPERATORS_TO_PRESERVE = (self.n_players - 1) // 2
        if (self.n_players - 1) % 2 != 0:
            self.MIN_COOPERATORS_TO_PRESERVE += 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number >= self.total_rounds - 2:
            return Action.D
        if state.current_stock < self.STOCK_PRESERVATION_THRESHOLD:
            num_other_cooperators = 0
            if state.round_number > 0 and history is not None:
                previous_round_opponent_actions = history.opponent_actions[state.round_number - 1]
                num_other_cooperators = sum(previous_round_opponent_actions)
            if num_other_cooperators >= self.MIN_COOPERATORS_TO_PRESERVE:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_180(BaseStrategy):
    """
    The Adaptive Predator strategy is designed for maximum personal gain in the Common Pool Resource Game.
    It defects whenever possible to secure the highest immediate payoff, while strategically cooperating
    only when necessary to prevent the common pool resource from collapsing to a level that would
    detrimentally impact its own future cumulative payoffs. It aims to free-ride on any cooperation
    from other players and will push the resource to its limit before retreating.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.min_recoverable_stock_for_next_round = float(game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = float(self.game_description.capacity)
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == r - 1:
            return Action.D
        if current_round_number == 0:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[current_round_number - 1, :]
        num_others_cooperated_prev_round = int(np.sum(previous_round_opponent_actions))
        num_others_defected_prev_round = n - 1 - num_others_cooperated_prev_round
        my_projected_consumption_if_D = current_stock / n
        projected_consumption_others_C = num_others_cooperated_prev_round * (current_stock / (2 * n))
        projected_consumption_others_D = num_others_defected_prev_round * (current_stock / n)
        total_projected_consumption = my_projected_consumption_if_D + projected_consumption_others_C + projected_consumption_others_D
        projected_S_after_consumption = current_stock - total_projected_consumption
        if projected_S_after_consumption < 0:
            return Action.C
        S_remaining_for_growth = max(0.0, projected_S_after_consumption)
        projected_growth = 2 * S_remaining_for_growth * (1 - S_remaining_for_growth / capacity)
        projected_new_stock_next_round = min(S_remaining_for_growth + projected_growth, capacity)
        if projected_new_stock_next_round <= self.min_recoverable_stock_for_next_round:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_181(BaseStrategy):
    """
    The "Ruthless Stock-Aware Exploiter" strategy is designed to maximize individual payoff
    in the Common Pool Resource game. It prioritizes immediate personal gain through defection,
    exploiting the cooperative behavior of others. However, it strategically cooperates
    to prevent the total collapse of the resource when stock levels are critical, or
    as a calculated mid-game investment to preserve future exploitation opportunities.
    It adapts its behavior based on the current stock, observed opponent cooperation,
    and the progression of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Ruthless Stock-Aware Exploiter strategy.

        Args:
            game_description: An object containing game parameters such as
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD_PERCENTAGE = 0.25
        self.OPPONENT_COOP_THRESHOLD = 0.6
        self.MID_GAME_THRESHOLD_PERCENTAGE = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round based on
        the strategy's rules.

        Args:
            state: An object containing the current round number and stock level.
            history: An object containing historical actions and payoffs for
                     this player and opponents, or None for the first round.

        Returns:
            An Action (Action.C for Cooperate or Action.D for Defect).
        """
        current_round_1_indexed = state.round_number + 1
        capacity = self.game_description.capacity
        n_rounds_total = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round_1_indexed == n_rounds_total:
            return Action.D
        if state.round_number == 0:
            return Action.D
        if state.current_stock < capacity * self.CRITICAL_STOCK_THRESHOLD_PERCENTAGE:
            return Action.C
        num_opponents = n_players - 1
        num_opponents_cooperating = np.sum(history.opponent_actions[-1])
        opponent_coop_rate = num_opponents_cooperating / num_opponents
        if opponent_coop_rate >= self.OPPONENT_COOP_THRESHOLD:
            return Action.D
        elif current_round_1_indexed > n_rounds_total * self.MID_GAME_THRESHOLD_PERCENTAGE:
            return Action.D
        elif state.current_stock > capacity * 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_182(BaseStrategy):
    """
    Adaptive Predatory Harvester (APH) strategy for the Common Pool Resource game.

    This strategy aims to maximize its own total payoff by opportunistically defecting,
    while also preserving the resource to ensure future exploitation. It adapts its
    behavior based on the current stock level and the observed defection rate of opponents.
    Key principles include starting with cooperation, always defecting in the final round,
    cooperating when the resource is critically low, and cooperating when opponents are
    too aggressive and the stock is not robust. Otherwise, it defects to exploit.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / self.n
        self.HIGH_STOCK_ZONE_THRESHOLD = self.capacity * 0.75
        self.K_D_TOLERANCE_THRESHOLD = (self.n - 1) / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_1_indexed == self.r:
            return Action.D
        k_D_prev = np.sum(history.opponent_actions[-1, :] == False)
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        if k_D_prev >= self.K_D_TOLERANCE_THRESHOLD and current_stock < self.HIGH_STOCK_ZONE_THRESHOLD:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_183(BaseStrategy):
    """
    The Opportunistic Predator strategy is designed to maximize individual payoff by defaulting to
    exploitative actions while strategically conserving the shared resource only when absolutely
    necessary to ensure future opportunities for exploitation. It is adaptive to opponent behavior
    and stock levels, and robust against various play styles.

    Key principles:
    1. Prioritize Immediate Gain: Default action is always to defect (D).
    2. Strategic Conservation: Cooperate (C) only if stock is critically low (<= 10% capacity),
       there are future rounds to exploit, AND a sufficient number of opponents showed restraint
       in the previous round (less than 70% defected). This is a self-interested investment.
    3. Ruthless Final Round: Always defect in the last round as there are no future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.r_total = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = state.round_number + 1
        avg_opponent_defection_rate_prev_round: float
        if current_round_0_indexed == 0:
            avg_opponent_defection_rate_prev_round = 1.0
        else:
            opponent_actions_prev_round = history.opponent_actions[-1, :]
            num_opponent_D_actions_in_prev_round = np.sum(~opponent_actions_prev_round)
            avg_opponent_defection_rate_prev_round = num_opponent_D_actions_in_prev_round / (self.n_players - 1)
        stock_fraction = state.current_stock / self.capacity
        if current_round_1_indexed == self.r_total:
            return Action.D
        elif stock_fraction <= 0.1:
            if current_round_1_indexed < self.r_total:
                if avg_opponent_defection_rate_prev_round < 0.7:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_184(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its own total payoff by defaulting to Defect (D)
    but incorporates safeguards to prevent common stock collapse, ensuring future exploitation.
    It adapts its behavior based on the current stock level and the observed defection rates of other players.
    In the final round, it always defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self._num_rounds_cooperating_after_crisis = 0
        self._CRITICAL_STOCK_THRESHOLD_LOW = self.capacity / (self.n * 2.0)
        self._STOCK_RECOVERY_TARGET = self.capacity / 2.0
        self._FORCED_COOPERATION_DURATION = max(1, min(3, self.r // 5))
        self._OPPONENT_DEFECTION_PUNISH_THRESHOLD = 0.75
        self._OPPONENT_DEFECTION_LOOKBACK_ROUNDS = min(3, max(1, self.r - 1))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.r:
            return Action.D
        if current_stock < self._CRITICAL_STOCK_THRESHOLD_LOW:
            self._num_rounds_cooperating_after_crisis = self._FORCED_COOPERATION_DURATION
            return Action.C
        if self._num_rounds_cooperating_after_crisis > 0:
            self._num_rounds_cooperating_after_crisis -= 1
            return Action.C
        if self.n > 1 and history is not None and (state.round_number >= self._OPPONENT_DEFECTION_LOOKBACK_ROUNDS):
            lookback_opponent_actions = history.opponent_actions[-self._OPPONENT_DEFECTION_LOOKBACK_ROUNDS:, :]
            total_opponent_defections_in_lookback = np.sum(lookback_opponent_actions == False)
            max_possible_defections = (self.n - 1) * self._OPPONENT_DEFECTION_LOOKBACK_ROUNDS
            opponent_defection_rate = total_opponent_defections_in_lookback / max_possible_defections
            if opponent_defection_rate > self._OPPONENT_DEFECTION_PUNISH_THRESHOLD and current_stock < self._STOCK_RECOVERY_TARGET:
                self._num_rounds_cooperating_after_crisis = 1
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_185(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize cumulative payoff by intelligently
    balancing aggressive exploitation with strategic resource preservation. It defaults
    to defecting (D) but cooperates (C) if the resource is near collapse, or if too many
    opponents are defecting. In the final round, it always defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.num_opponent_D_last_round = math.floor((self.n - 1) / 2)
        self.emergency_threshold = self.capacity / (self.n + 1)
        self.opponent_defection_tolerance_count = math.floor((self.n - 1) / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if state.round_number > 0 and history is not None:
            opponent_actions_last_round = history.opponent_actions[state.round_number - 1, :]
            self.num_opponent_D_last_round = (~opponent_actions_last_round).sum()
        if current_round_1_indexed == self.r:
            return Action.D
        stock_after_all_C_consumption = current_stock / 2.0
        s_remaining_for_growth = max(0.0, stock_after_all_C_consumption)
        potential_growth = 2 * s_remaining_for_growth * (1 - s_remaining_for_growth / self.capacity)
        projected_next_round_stock_if_all_C = min(stock_after_all_C_consumption + potential_growth, self.capacity)
        if projected_next_round_stock_if_all_C < self.emergency_threshold:
            return Action.C
        if self.num_opponent_D_last_round <= self.opponent_defection_tolerance_count:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_186(BaseStrategy):
    """
    The Opportunistic Consumer strategy for the Common Pool Resource game.

    This strategy operates with a strong bias towards defection, aiming to extract
    the maximum possible resource at any given moment. It only resorts to
    cooperation under specific conditions where sustained defection would lead
    to negligible future payoffs, thus making a temporary sacrifice a strategic
    investment in future exploitation.

    Decision Rules:
    1. In the final round, always Defect (D) to maximize immediate payoff, as there are no future consequences.
    2. If there are fewer future rounds remaining than `ROUNDS_LEFT_FOR_INVESTMENT`, always Defect (D).
       This prioritizes immediate extraction over potential stock recovery, as there's not enough time
       for a recovery to yield significant future exploitation.
    3. Otherwise (main game logic, i.e., not the last round and sufficient future rounds for investment):
       a. If the current stock level (`stock`) is below `MIN_STOCK_FOR_PROFIT`, Cooperate (C).
          This is a calculated, temporary sacrifice to allow the resource to recover to a more
          profitable level for future exploitation. Defecting at critically low stock yields minimal
          returns and risks total depletion.
       b. If the stock is healthy enough for profitable extraction, Defect (D).
          This is the default exploitative action, maximizing immediate gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        self.MIN_STOCK_FOR_PROFIT = capacity / (2 * n)
        self.ROUNDS_LEFT_FOR_INVESTMENT = int(r / 3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round == total_rounds - 1:
            return Action.D
        if total_rounds - 1 - current_round < self.ROUNDS_LEFT_FOR_INVESTMENT:
            return Action.D
        if current_stock < self.MIN_STOCK_FOR_PROFIT:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_187(BaseStrategy):
    """
    The Greedy Harvester strategy is designed to be highly exploitative,
    prioritizing its own cumulative payoff by maximizing immediate gains.
    It strategically preserves the common resource only when such preservation
    directly benefits its long-term extraction goals. It leverages observed
    opponent behavior and the current resource state to make decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_ratio: float = 0.25
        self.cooperation_observation_window: int = 3
        self.cooperation_assurance_threshold: float = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == n_rounds - 1:
            return Action.D
        if current_stock <= 0:
            return Action.D
        opponent_C_rate = 0.0
        if current_round > 0:
            total_opponent_actions_observed = 0
            cooperative_opponent_actions_observed = 0
            start_round_for_observation = max(0, current_round - self.cooperation_observation_window)
            for round_idx in range(start_round_for_observation, current_round):
                cooperative_opponent_actions_observed += np.sum(history.opponent_actions[round_idx, :])
                total_opponent_actions_observed += history.opponent_actions.shape[1]
            if total_opponent_actions_observed > 0:
                opponent_C_rate = cooperative_opponent_actions_observed / total_opponent_actions_observed
        is_stock_critical = current_stock <= self.critical_stock_ratio * capacity
        if is_stock_critical:
            remaining_rounds = n_rounds - (current_round + 1)
            if opponent_C_rate >= self.cooperation_assurance_threshold and remaining_rounds >= 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_188(BaseStrategy):
    """
    Exploitative strategy: "Greed with a Survival Instinct".
    This strategy maximizes immediate gain by defecting whenever the common pool
    resource is healthy. It introduces a self-preservation mechanism, cooperating
    only when the common pool resource is critically low (below 2*n) to safeguard
    its own long-term ability to extract value. In the final round, it always
    defects to maximize the last immediate payoff without future consequences.
    In the first round, it will always defect due to the game's initial stock
    level (`capacity >= 2n`).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold = 2 * self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == n_rounds - 1:
            return Action.D
        elif current_stock < self.critical_stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_189(BaseStrategy):
    """
    The "Opportunistic Harvester" strategy aims to maximize its total payoff by defaulting to
    exploitation (Defect) but adapting its aggressiveness based on the common stock level
    and observed opponent cooperation. It strategically cooperates only to prevent resource
    collapse when there's a chance of future exploitation, and fully exploits in end-game
    scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_threshold = 0.1 * self.capacity
        self.abundant_stock_threshold = 0.7 * self.capacity
        self.endgame_start_round = self.n_rounds - 1
        self.cooperative_opponent_ratio = 0.3
        self.defective_opponent_ratio = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number + 1
        current_stock_S = state.current_stock
        if state.round_number == 0:
            return Action.D
        if current_round_t >= self.endgame_start_round:
            if current_round_t == self.n_rounds:
                return Action.D
            elif current_round_t == self.n_rounds - 1:
                if current_stock_S <= self.critical_stock_threshold:
                    return Action.C
                else:
                    return Action.D
        else:
            n_other_players = self.n_players - 1
            if n_other_players == 0:
                return Action.D
            num_opponent_D_prev = (history.opponent_actions[-1, :] == False).sum()
            opponent_defection_rate = num_opponent_D_prev / n_other_players
            opponents_are_cooperative = opponent_defection_rate < self.cooperative_opponent_ratio
            opponents_are_defective = opponent_defection_rate > self.defective_opponent_ratio
            opponents_are_mixed = not opponents_are_cooperative and (not opponents_are_defective)
            if current_stock_S <= self.critical_stock_threshold:
                if opponents_are_defective:
                    return Action.D
                else:
                    return Action.C
            elif current_stock_S >= self.abundant_stock_threshold:
                return Action.D
            elif opponents_are_cooperative:
                return Action.D
            elif opponents_are_defective:
                return Action.D
            elif opponents_are_mixed:
                if current_stock_S < self.capacity / 2:
                    return Action.C
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_190(BaseStrategy):
    """
    Adaptive Exploiter strategy for the Common Pool Resource game.

    Core Philosophy: Prioritize maximum individual gain. Exploit cooperative behavior
    whenever possible. Avoid being a "sucker" by cooperating when others defect.
    Only cooperate as a last resort to prevent the complete collapse of the common
    resource, as its destruction would eliminate all future payoffs for the exploiter.

    Decision Rules:
    1. In the final round, always Defect for maximum immediate payoff.
    2. If stock is critically low (< 25% of capacity), Cooperate for self-preservation.
    3. In the first round (if not critically low), Defect to establish an aggressive stance.
    4. In intermediate rounds (not first, not last, not critically low stock), always Defect.
       The strategy's design is to maintain an aggressive exploitative stance in these
       conditions, regardless of opponent defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Exploiter strategy with game-specific parameters.
        """
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD_RATIO = 0.25
        self.OPPONENT_DEFECTION_TOLERANCE_RATIO = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: An object containing the current round number (0-indexed) and stock level.
            history: An object containing past actions and payoffs for the player and opponents,
                     or None if it's the very first round (round_number == 0).

        Returns:
            An Action enum (Action.C for Cooperate, Action.D for Defect).
        """
        r_total = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == r_total - 1:
            return Action.D
        if current_stock < capacity * self.CRITICAL_STOCK_THRESHOLD_RATIO:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_191(BaseStrategy):
    """
    The Adaptive Predatory Harvester strategy for the Common Pool Resource game.
    It prioritizes maximizing its own total payoff over 'r' rounds by primarily defecting,
    but intelligently cooperates only when the resource's sustainability is critically
    threatened, thereby preserving the possibility of future exploitation. It adjusts
    its behavior based on the current stock level and the observed cooperation rate
    of its opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold_free_ride = 0.5
        self.stock_critical_ratio = 0.25
        self.stock_abundant_ratio = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_idx = state.round_number
        current_stock = state.current_stock
        if current_round_idx == n_rounds - 1:
            return Action.D
        ocr = 0.0
        if current_round_idx > 0 and history is not None:
            total_opponent_C = np.sum(history.opponent_actions)
            total_opponent_actions = history.opponent_actions.size
            if total_opponent_actions > 0:
                ocr = total_opponent_C / total_opponent_actions
        if current_stock < self.stock_critical_ratio * capacity:
            return Action.C
        elif current_stock > self.stock_abundant_ratio * capacity:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_192(BaseStrategy):
    """
    The Adaptive Stock Predator (ASP) strategy aims to maximize its total individual payoff
    by primarily defaulting to aggressive defection. It incorporates a critical self-preservation
    mechanism: it will conditionally cooperate to prevent resource collapse, but only if
    doing so aligns with its long-term exploitative goal and if other players are also
    demonstrably contributing to the resource's recovery. It also becomes purely aggressive
    as the game nears its end.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.exploitation_horizon_ratio = 0.25
        self.critical_stock_ratio = 0.25
        self.observation_window = 3
        self.cooperation_threshold_ratio = 0.5
        exploitation_horizon_rounds = math.floor(self.n_rounds * self.exploitation_horizon_ratio)
        self.aggressive_phase_start_round_0_indexed = max(0, self.n_rounds - exploitation_horizon_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round >= self.aggressive_phase_start_round_0_indexed:
            return Action.D
        if current_stock < self.capacity * self.critical_stock_ratio:
            start_round_in_history_idx = max(0, current_round - self.observation_window)
            observed_opponent_actions = history.opponent_actions[start_round_in_history_idx:current_round, :]
            effective_observation_rounds = observed_opponent_actions.shape[0]
            avg_cooperation_ratio = 0.0
            if effective_observation_rounds > 0:
                total_other_cooperators_in_window = np.sum(observed_opponent_actions)
                max_possible_other_cooperators = effective_observation_rounds * (self.n_players - 1)
                avg_cooperation_ratio = total_other_cooperators_in_window / max_possible_other_cooperators
            if avg_cooperation_ratio >= self.cooperation_threshold_ratio:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_193(BaseStrategy):
    """
    The Opportunist Predator strategy balances immediate high payoffs from defecting
    with the long-term need to preserve the common resource. It is designed to be
    exploitative by default, but intelligent enough to contribute to resource
    recovery when necessary to avoid total collapse, and ruthless in end-game
    scenarios or when the resource is deemed beyond recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_threshold = max(self.capacity / (self.n_players * 4), 0.1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        num_other_defectors_predicted = 0
        if state.round_number == 0:
            num_other_defectors_predicted = 0
        else:
            num_other_defectors_predicted = np.sum(history.opponent_actions[-1, :] == False)

        def simulate_next_stock(current_S: float, num_defectors_in_round: int) -> float:
            """
            Calculates the next stock level given the current stock and number of defectors.
            """
            total_consumption = current_S * (self.n_players + num_defectors_in_round) / (2 * self.n_players)
            S_remaining = max(0.0, current_S - total_consumption)
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity if self.capacity > 0 else 0)
            next_S = min(S_remaining + growth, self.capacity)
            return next_S
        k_hypothetical_D = num_other_defectors_predicted + 1
        k_hypothetical_D = min(k_hypothetical_D, self.n_players)
        next_stock_hypothetical_D = simulate_next_stock(current_stock, k_hypothetical_D)
        k_hypothetical_C = num_other_defectors_predicted
        k_hypothetical_C = min(k_hypothetical_C, self.n_players - 1)
        next_stock_hypothetical_C = simulate_next_stock(current_stock, k_hypothetical_C)
        if next_stock_hypothetical_D > self.critical_stock_threshold:
            return Action.D
        elif next_stock_hypothetical_C > self.critical_stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_194(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize individual gain by defaulting to defection,
    but incorporates a crucial self-preservation mechanism. It cooperates only when the common
    resource stock falls below a dynamically calculated critical threshold, allowing the resource
    to recover for future exploitation. In the final round, it always defects to maximize
    immediate payoff without future consequence. This strategy is robust due to its
    adaptability to the resource's state rather than relying on opponent predictions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number + 1
        current_stock = state.current_stock
        critical_stock_threshold = max(capacity / (2 * n_players), 1.0)
        if current_round == n_rounds:
            return Action.D
        if current_stock <= critical_stock_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_195(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its own total payoff by exploiting
    opponent cooperation and defecting by default, only conserving the resource when
    its own long-term extraction potential is severely threatened. It employs
    strategic cooperation when the common stock is critically low or when its
    own defection would lead to a projected collapse of the resource, ensuring
    continued future extraction opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        S_threshold_emergency = 0.2 * self.capacity
        S_threshold_projected_collapse = 0.05 * self.capacity
        if current_round_0_indexed == self.r - 1:
            return Action.D
        if current_stock < S_threshold_emergency:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.D
        previous_round_idx_0_indexed = current_round_0_indexed - 1
        opponents_actions_last_round = history.opponent_actions[previous_round_idx_0_indexed, :]
        num_cooperators_last_round = np.sum(opponents_actions_last_round)
        num_defectors_last_round = self.n - 1 - num_cooperators_last_round
        if num_cooperators_last_round > (self.n - 1) / 2:
            return Action.D
        elif num_defectors_last_round > (self.n - 1) / 2:
            my_projected_consumption_if_D = current_stock / self.n
            others_projected_consumption = num_defectors_last_round * (current_stock / self.n) + num_cooperators_last_round * (current_stock / (2 * self.n))
            total_projected_consumption_if_I_D = my_projected_consumption_if_D + others_projected_consumption
            S_remaining_after_my_D_projected = current_stock - total_projected_consumption_if_I_D
            if S_remaining_after_my_D_projected <= S_threshold_projected_collapse:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_196(BaseStrategy):
    """
    The Opportunistic Predator strategy prioritizes maximizing personal payoff.
    It defects aggressively but cooperates to prevent critical stock collapse,
    ensuring future exploitation opportunities. It also exploits collective
    cooperation from opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_recovery_threshold_factor = 0.1
        self.predicted_collapse_threshold_factor = 0.05
        self.strong_cooperation_threshold_percentage = 0.3
        self.num_other_players_count = self.n - 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_num_0_indexed == 0:
            return Action.D
        if current_round_num_0_indexed == self.r - 1:
            return Action.D
        if current_stock <= self.capacity * self.stock_recovery_threshold_factor:
            return Action.C
        prev_round_opponent_actions = history.opponent_actions[-1, :]
        num_other_players_D = np.sum(prev_round_opponent_actions == False)
        num_other_players_C = np.sum(prev_round_opponent_actions == True)
        consumption_if_D_per_player = current_stock / self.n
        consumption_if_C_per_player = current_stock / (2 * self.n)
        my_expected_consumption_if_D = consumption_if_D_per_player
        others_expected_consumption = num_other_players_D * consumption_if_D_per_player + num_other_players_C * consumption_if_C_per_player
        total_expected_consumption_if_I_D = my_expected_consumption_if_D + others_expected_consumption
        predicted_S_remaining = max(0.0, current_stock - total_expected_consumption_if_I_D)
        predicted_growth = 2 * predicted_S_remaining * (1 - predicted_S_remaining / self.capacity)
        predicted_new_stock_if_I_D = min(predicted_S_remaining + predicted_growth, self.capacity)
        if predicted_new_stock_if_I_D <= self.capacity * self.predicted_collapse_threshold_factor:
            return Action.C
        defection_rate_among_others = num_other_players_D / self.num_other_players_count
        if defection_rate_among_others < self.strong_cooperation_threshold_percentage:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_197(BaseStrategy):
    """
    Adaptive Exploiter with Emergency Brake strategy for the Common Pool Resource game.
    This strategy balances immediate high payoffs through defection with long-term
    sustainability of the common resource. It adapts to opponent behavior and resource health.

    Core Principles:
    1. Prioritize Immediate Gain: Defect in the first and last rounds, and when clear
       exploitation opportunities arise without immediate catastrophic consequences.
    2. Monitor Resource Health: Use a critical stock threshold (`S_CRITICAL_LOW`)
       to trigger an "emergency brake" and prevent collapse.
    3. Adaptive Response to Opponents: Adjust behavior based on observed defection
       rate of opponents in the previous round to avoid being a "sucker."
    4. Long-Term Self-Interest: Cooperate under specific conditions to maintain
       resource viability, as a depleted resource yields zero future payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_CRITICAL_LOW = self.capacity / self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        num_opponents = self.n_players - 1
        opponents_cooperated_prev_round = np.sum(history.opponent_actions[-1, :])
        N_D_prev = num_opponents - opponents_cooperated_prev_round
        if current_stock <= self.S_CRITICAL_LOW:
            if N_D_prev > num_opponents / 2.0:
                return Action.D
            else:
                return Action.C
        elif N_D_prev == 0:
            return Action.D
        elif N_D_prev > num_opponents / 2.0:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_198(BaseStrategy):
    """
    The 'Aggressive Prudence' strategy prioritizes immediate personal gain through defection.
    It defects by default, but incorporates a critical self-preservation mechanism:
    if the common pool stock falls below a critical level, it cooperates to allow recovery.
    It always defects in the final round. In intermediate rounds, if the stock is not critical,
    it calculates opponent defection rates from the previous round but ultimately continues to defect,
    aiming to free-ride on cooperators or avoid being a "sucker" among defectors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_RATIO = 0.2
        self.OPPONENT_COOPERATION_THRESHOLD = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t_1_indexed = state.round_number + 1
        current_stock_S = state.current_stock
        if current_round_t_1_indexed == self.n_rounds:
            return Action.D
        critical_stock_level = self.capacity * self.CRITICAL_STOCK_RATIO
        if current_stock_S < critical_stock_level:
            return Action.C
        if current_round_t_1_indexed == 1:
            return Action.D
        else:
            opponent_actions_in_prev_round = history.opponent_actions[-1, :]
            num_opponent_defectors_prev_round = np.sum(~opponent_actions_in_prev_round)
            n_minus_1 = self.n_players - 1
            defection_rate_prev_round = num_opponent_defectors_prev_round / n_minus_1
            return Action.D

class Strategy_EXPLOITATIVE_199(BaseStrategy):
    """
    Adaptive Greed strategy for the Common Pool Resource Game.

    This strategy defaults to defection to maximize immediate payoffs. It only cooperates under specific
    conditions when its own future stream of payoffs is critically threatened by resource depletion,
    and its cooperation can demonstrably make a difference in preserving the resource. If the resource
    is inevitably doomed due to others' aggressive consumption, the strategy will defect to extract
    maximum value from the dying resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_COLLAPSE_THRESHOLD = max(1.0, self.capacity * 0.01)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = float(state.current_stock)
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        elif current_round_1_indexed == 1:
            return Action.D
        else:
            num_D_others_last_round = np.sum(~history.opponent_actions[-1, :])
            E_num_D_others = max(0, min(self.n_players - 1, num_D_others_last_round))
            E_num_C_others = self.n_players - 1 - E_num_D_others
            consumption_per_D_coeff = 1.0 / self.n_players
            consumption_per_C_coeff = 1.0 / (2.0 * self.n_players)
            E_num_D_total_if_I_D = E_num_D_others + 1
            E_num_C_total_if_I_D = E_num_C_others
            total_consumption_if_I_D = E_num_D_total_if_I_D * current_stock * consumption_per_D_coeff + E_num_C_total_if_I_D * current_stock * consumption_per_C_coeff
            stock_after_consumption_if_I_D = max(0.0, current_stock - total_consumption_if_I_D)
            growth_if_I_D = 2 * stock_after_consumption_if_I_D * (1 - stock_after_consumption_if_I_D / self.capacity)
            projected_new_stock_if_I_D = min(stock_after_consumption_if_I_D + growth_if_I_D, self.capacity)
            E_num_D_total_if_I_C = E_num_D_others
            E_num_C_total_if_I_C = E_num_C_others + 1
            total_consumption_if_I_C = E_num_D_total_if_I_C * current_stock * consumption_per_D_coeff + E_num_C_total_if_I_C * current_stock * consumption_per_C_coeff
            stock_after_consumption_if_I_C = max(0.0, current_stock - total_consumption_if_I_C)
            growth_if_I_C = 2 * stock_after_consumption_if_I_C * (1 - stock_after_consumption_if_I_C / self.capacity)
            projected_new_stock_if_I_C = min(stock_after_consumption_if_I_C + growth_if_I_C, self.capacity)
            if projected_new_stock_if_I_D <= self.CRITICAL_COLLAPSE_THRESHOLD:
                if projected_new_stock_if_I_C > self.CRITICAL_COLLAPSE_THRESHOLD:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_200(BaseStrategy):
    """
    The Adaptive Exploiter strategy maximizes individual payoff by defaulting to Defect (D) to free-ride
    on others. It incorporates a crucial safety net to prevent common pool resource collapse by cooperating (C)
    when the stock is critically low. In two-player games, it adaptively uses a manipulative Tit-for-Tat
    variant to induce cooperation for future exploitation. In multi-player games, it primarily defaults
    to Defect to maximize immediate gain, as individual actions have less impact on overall dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Exploiter strategy.

        Args:
            game_description (CommonPoolDescription): An object containing static game parameters
                                                     like n_players, n_rounds, and capacity.
        """
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.

        Args:
            state (CommonPoolState): An object containing the current round number (0-indexed)
                                     and the current stock level.
            history (None | PlayerHistory): An object containing a record of past actions and payoffs.
                                            It is None for the first round (round_number == 0).

        Returns:
            Action: Action.C for Cooperate, Action.D for Defect.
        """
        CRITICAL_STOCK_THRESHOLD_MULTIPLIER = 1.0
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        else:
            critical_stock_threshold = capacity / (2.0 * n_players) * CRITICAL_STOCK_THRESHOLD_MULTIPLIER
            if state.current_stock < critical_stock_threshold:
                return Action.C
            elif n_players == 2:
                opponent_prev_action_is_C = history.opponent_actions[state.round_number - 1, 0]
                if opponent_prev_action_is_C:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_201(BaseStrategy):
    """
    The "Adaptive Predator" strategy for the Common Pool Resource game.
    This strategy prioritizes maximizing its own total payoff by defecting whenever possible,
    free-riding on others' cooperation, and only cooperating when absolutely necessary
    to prevent the collapse of the resource it relies on for future exploitation.
    It adapts its behavior based on current stock levels, round number, and observed
    opponent behavior from recent history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_level = self.capacity * 0.25
        self.recovery_stock_level = self.capacity * 0.75
        self.history_lookback_rounds = 3
        self.low_defection_threshold = 0.25
        self.high_defection_threshold = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        n = self.n
        total_rounds = self.r
        capacity = self.capacity
        if current_round == total_rounds - 1:
            return Action.D
        if current_stock < self.critical_stock_level:
            return Action.C
        if current_stock >= self.recovery_stock_level:
            return Action.D
        if history is None or history.opponent_actions.shape[0] < self.history_lookback_rounds:
            return Action.D
        total_defections_by_others = 0
        total_actions_considered = 0
        start_history_idx = max(0, current_round - self.history_lookback_rounds)
        for r_idx in range(start_history_idx, current_round):
            opponent_actions_in_round = history.opponent_actions[r_idx, :]
            num_opponents_in_round = opponent_actions_in_round.shape[0]
            total_actions_considered += num_opponents_in_round
            total_defections_by_others += np.sum(~opponent_actions_in_round)
        avg_defection_rate = 0.0
        if total_actions_considered > 0:
            avg_defection_rate = total_defections_by_others / total_actions_considered
        if avg_defection_rate >= self.high_defection_threshold:
            return Action.D
        elif avg_defection_rate < self.low_defection_threshold:
            return Action.D
        else:
            num_other_players = n - 1
            num_D_others_hypothetical = round(num_other_players * avg_defection_rate)
            num_D_others_hypothetical = min(num_D_others_hypothetical, num_other_players)
            num_C_others_hypothetical = num_other_players - num_D_others_hypothetical
            my_consumption = current_stock / n
            consumption_by_others = num_D_others_hypothetical * (current_stock / n) + num_C_others_hypothetical * (current_stock / (2 * n))
            total_consumption_hypothetical = my_consumption + consumption_by_others
            S_remaining_hypothetical = current_stock - total_consumption_hypothetical
            S_remaining_for_growth = max(0.0, S_remaining_hypothetical)
            growth_hypothetical = 2 * S_remaining_for_growth * (1 - S_remaining_for_growth / capacity)
            next_stock_hypothetical = min(S_remaining_for_growth + growth_hypothetical, capacity)
            if next_stock_hypothetical < self.critical_stock_level:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_202(BaseStrategy):
    """
    Opportunistic Reciprocator strategy for the Common Pool Resource game.
    This strategy is designed to be aggressive by default, exploiting opportunities for immediate gain.
    It incorporates adaptive mechanisms to prevent the common resource from collapsing entirely,
    which would inevitably lead to zero payoffs for all, including itself.
    It also recognizes the diminishing value of future resource health as the game concludes,
    leading to increased aggression in later rounds.

    Core Principles:
    1.  End Game Aggression: Prioritizes immediate maximum gain in the final rounds.
    2.  Self-Preservation through Cooperation: Temporarily cooperates if the resource stock
        falls to critically low levels to allow for recovery.
    3.  Adaptive Exploitation: In early and mid-game, infers collective opponent behavior
        by observing stock trends, defecting if the resource is stable/growing, and
        cooperating if it's significantly declining.
    """
    COOPERATION_THRESHOLD_STOCK_RATIO = 0.25
    AGGRESSION_ROUND_THRESHOLD = 2
    STOCK_DECREASE_SIGNAL = 0.05
    STOCK_INCREASE_SIGNAL = 0.02

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_at_start_of_previous_round: float | None = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = float(self.game_description.capacity)
        if current_round_1_indexed == 1:
            self.stock_at_start_of_previous_round = capacity
        if self.stock_at_start_of_previous_round is None:
            self.stock_at_start_of_previous_round = capacity
        rounds_remaining = total_rounds - current_round_1_indexed + 1
        current_stock_ratio = current_stock / capacity
        action = Action.D
        if rounds_remaining <= self.AGGRESSION_ROUND_THRESHOLD:
            action = Action.D
        elif current_stock_ratio < self.COOPERATION_THRESHOLD_STOCK_RATIO:
            action = Action.C
        else:
            net_stock_change = current_stock - self.stock_at_start_of_previous_round
            if net_stock_change < -(capacity * self.STOCK_DECREASE_SIGNAL):
                action = Action.C
            elif net_stock_change > capacity * self.STOCK_INCREASE_SIGNAL:
                action = Action.D
            else:
                action = Action.D
        self.stock_at_start_of_previous_round = current_stock
        return action

class Strategy_EXPLOITATIVE_203(BaseStrategy):
    """
    The "Adaptive Predator" strategy aggressively exploits the common resource,
    free-riding on the cooperation of others, but strategically cooperates
    to preserve the resource when it is critically low AND there is evidence
    that other players are also contributing to its recovery. It prioritizes
    immediate gain in endgame scenarios.
    """
    _CRITICAL_STOCK_THRESHOLD_RATIO: float = 0.25
    _COOPERATION_THRESHOLD_FOR_RECIPROCITY: float = 0.5

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description: CommonPoolDescription = game_description
        self.n_players: int = game_description.n_players
        self.n_rounds: int = game_description.n_rounds
        self.capacity: float = float(game_description.capacity)
        self.CRITICAL_STOCK_THRESHOLD_RATIO: float = self._CRITICAL_STOCK_THRESHOLD_RATIO
        self.COOPERATION_THRESHOLD_FOR_RECIPROCITY: float = self._COOPERATION_THRESHOLD_FOR_RECIPROCITY
        self.MINIMUM_VIABLE_STOCK_FOR_RECOVERY: float = self.capacity / (2.0 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed: int = state.round_number + 1
        current_stock: float = state.current_stock
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_round_1_indexed == self.n_rounds - 1:
            return Action.D
        cooperation_rate_last_round: float = 0.0
        if state.round_number > 0:
            cooperators_last_round = np.sum(history.opponent_actions[-1, :])
            cooperation_rate_last_round = cooperators_last_round / (self.n_players - 1)
        is_stock_critically_low: bool = current_stock < self.capacity * self.CRITICAL_STOCK_THRESHOLD_RATIO
        is_stock_effectively_depleted: bool = current_stock < self.MINIMUM_VIABLE_STOCK_FOR_RECOVERY
        if is_stock_effectively_depleted:
            return Action.D
        elif is_stock_critically_low:
            if cooperation_rate_last_round >= self.COOPERATION_THRESHOLD_FOR_RECIPROCITY:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_204(BaseStrategy):
    """
    The "Reluctant Conservator" strategy for the Common Pool Resource Game.
    This strategy prioritizes immediate gain through defection, only resorting
    to cooperation when the viability of the common resource, and thus future payoffs,
    is at severe risk. It operates under standard game theory assumptions and
    adapts to the overall state of the resource (current stock level).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        if n == 0:
            self.S_critical_ratio = 1.0
        else:
            self.S_critical_ratio = 1.0 / (2.0 * n)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number
        total_rounds_r = self.game_description.n_rounds
        current_stock = state.current_stock
        total_capacity = self.game_description.capacity
        S_critical = total_capacity * self.S_critical_ratio
        if current_round_t == total_rounds_r - 1:
            return Action.D
        if current_stock <= S_critical:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_205(BaseStrategy):
    """
    Adaptive Predator strategy for the Common Pool Resource Game.
    This strategy prioritizes immediate gains through defection, free-rides on cooperators,
    and only cooperates when the common stock is critically low to preserve
    future exploitation opportunities, ensuring its own long-term payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == 0:
            return Action.D
        if current_round_number == self.total_rounds - 1:
            return Action.D
        num_opponents_defected_last_round = np.sum(history.opponent_actions[-1, :] == False)
        opponent_defection_ratio = num_opponents_defected_last_round / (self.n_players - 1)
        if opponent_defection_ratio >= 0.5:
            return Action.D
        critical_stock_threshold = self.capacity / (2 * self.n_players)
        if current_stock < critical_stock_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_206(BaseStrategy):
    """
    Opportunistic Harvester strategy for the Common Pool Resource Game.
    Prioritizes immediate personal gain and adapts defensively to preserve future
    opportunities for exploitation. It balances aggressive extraction with strategic
    cooperation only when necessary to prevent resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_critical_ratio = 0.3
        self.S_recovery_ratio = 0.6
        self.D_response_threshold = max(1, math.floor(self.n_players / 2))
        self.Endgame_rounds_count = min(2, self.n_rounds)
        self.S_critical = self.S_critical_ratio * self.capacity
        self.S_recovery_target = self.S_recovery_ratio * self.capacity
        self.in_recovery_mode = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        num_defected_opponents_last_round = 0
        if current_round_number > 0 and history is not None:
            last_round_opponent_actions = history.opponent_actions[current_round_number - 1]
            num_defected_opponents_last_round = np.sum(last_round_opponent_actions == False)
        if current_round_number >= self.n_rounds - self.Endgame_rounds_count:
            self.in_recovery_mode = False
            return Action.D
        if self.in_recovery_mode:
            if current_stock >= self.S_recovery_target:
                self.in_recovery_mode = False
        if current_stock < self.S_critical:
            self.in_recovery_mode = True
        if self.in_recovery_mode:
            if num_defected_opponents_last_round >= self.D_response_threshold:
                return Action.D
            else:
                return Action.C
        if num_defected_opponents_last_round >= self.D_response_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_207(BaseStrategy):
    """
    Adaptive Opportunistic Defector with Stock Protection:
    An exploitative strategy that maximizes personal payoff by aggressively defecting when
    the resource is healthy and others are cooperating, but strategically cooperating to
    protect the resource (and thus future personal payoffs) when it is threatened or
    when widespread defection occurs. Always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = 0.5 * self.capacity
        self.high_cooperation_rate_threshold = 0.75
        self.low_cooperation_rate_threshold = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock < self.critical_stock_threshold:
            return Action.C
        if state.round_number == 0:
            return Action.D
        num_other_C_last_round = sum(history.opponent_actions[-1, :])
        other_players_cooperation_rate = num_other_C_last_round / (self.n_players - 1)
        if other_players_cooperation_rate >= self.high_cooperation_rate_threshold:
            return Action.D
        elif other_players_cooperation_rate <= self.low_cooperation_rate_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_208(BaseStrategy):
    """
    An exploitative, adaptive, and robust strategy for the Common Pool Resource game,
    named "Adaptive Exploiter with Dynamic Preservation".

    The strategy prioritizes maximizing its own total payoff by primarily defecting.
    It adaptively switches to cooperation only under specific conditions that serve its
    self-interest, mainly to prevent resource collapse or a collective "race to the bottom"
    that would ultimately harm its own long-term gains. It does not aim for collective welfare.

    Decision Rules (hierarchical):
    1.  **Last Round Exploitation**: In the final round, always Defect (D) to maximize immediate gain.
    2.  **Critical Stock Preservation**: If the resource stock falls below a critical threshold (`STOCK_PRESERVATION_THRESHOLD`),
        Cooperate (C) to allow regeneration, safeguarding future exploitation. This is an override.
    3.  **Initial Round Default**: In the very first round (no history), default to Defect (D).
    4.  **Adaptive Response to Collective Destructive Behavior**: If the current stock is below a warning threshold
        (`WARNING_STOCK_THRESHOLD`, used as a proxy for a negative stock trend given limited history data)
        AND a high proportion of players defected in the previous round (`HIGH_DEFECTION_RATE_THRESHOLD`),
        Cooperate (C) to prevent a rapid collective depletion that threatens future payoffs.
    5.  **Default Exploitation**: In all other scenarios, Defect (D) to maximize immediate gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = float(game_description.capacity)
        self.total_rounds = game_description.n_rounds
        self.STOCK_PRESERVATION_THRESHOLD = self.capacity / 3.0
        self.HIGH_DEFECTION_RATE_THRESHOLD = 0.75
        self.WARNING_STOCK_THRESHOLD = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num_1_indexed = state.round_number + 1
        if round_num_1_indexed == self.total_rounds:
            return Action.D
        if state.current_stock < self.STOCK_PRESERVATION_THRESHOLD:
            return Action.C
        if round_num_1_indexed == 1:
            return Action.D
        previous_round_all_actions = np.concatenate([history.opponent_actions[state.round_number - 1, :], np.array([history.my_actions[state.round_number - 1]])])
        num_defectors_last_round = np.sum(~previous_round_all_actions)
        observed_defection_rate = num_defectors_last_round / self.n
        stock_is_concerningly_low = state.current_stock < self.WARNING_STOCK_THRESHOLD
        if stock_is_concerningly_low and observed_defection_rate > self.HIGH_DEFECTION_RATE_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_209(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize personal total payoff by prioritizing immediate gains (defecting)
    while maintaining resource viability only when doing so directly serves the player's long-term self-interest.
    It operates under the principle of "Greedy by Default, Cautious by Necessity."
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history_window = 5
        self.end_game_rounds = 2
        self.stock_ratio_threshold = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_round_1_indexed > total_rounds - self.end_game_rounds:
            return Action.D
        total_observed_defections = 0
        total_observed_actions = 0
        num_opponents = n_players - 1
        if history is not None and state.round_number > 0:
            start_history_idx = max(0, state.round_number - self.history_window)
            for r_idx in range(start_history_idx, state.round_number):
                num_cooperators_this_round = np.sum(history.opponent_actions[r_idx, :])
                num_defectors_this_round = num_opponents - num_cooperators_this_round
                total_observed_defections += num_defectors_this_round
                total_observed_actions += num_opponents
        if total_observed_actions == 0:
            avg_f_opponents = 0.5
        else:
            avg_f_opponents = total_observed_defections / total_observed_actions
        projected_defectors = round(num_opponents * avg_f_opponents)
        projected_defectors = max(0, min(projected_defectors, num_opponents))
        projected_cooperators = num_opponents - projected_defectors
        if current_stock <= 0:
            return Action.D
        consumption_per_c_player = current_stock / (2 * n_players)
        consumption_per_d_player = current_stock / n_players
        my_consumption_if_D = consumption_per_d_player
        opponents_consumption_projected = projected_defectors * consumption_per_d_player + projected_cooperators * consumption_per_c_player
        total_consumption_if_my_D = my_consumption_if_D + opponents_consumption_projected
        S_rem_if_my_D = current_stock - total_consumption_if_my_D
        S_rem_if_my_D = max(0.0, S_rem_if_my_D)
        my_consumption_if_C = consumption_per_c_player
        total_consumption_if_my_C = my_consumption_if_C + opponents_consumption_projected
        S_rem_if_my_C = current_stock - total_consumption_if_my_C
        S_rem_if_my_C = max(0.0, S_rem_if_my_C)
        min_sustainable_stock = capacity * self.stock_ratio_threshold
        if S_rem_if_my_D <= min_sustainable_stock:
            if S_rem_if_my_C > min_sustainable_stock:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_210(BaseStrategy):
    """
    Adaptive Predator: An exploitative strategy for the Common Pool Resource Game
    that balances immediate gratification with resource preservation. It reacts
    to observed opponent behavior and the current state of the common pool,
    being aggressive when safe and defensive only when necessary to prevent
    its own future payoffs from collapsing.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_critical_low_ratio = 0.25
        self.cooperation_exploit_threshold = 0.75
        self.defection_avoid_sucker_threshold = 0.75
        self.high_stock_threshold_ratio = 0.75
        self.S_critical_low = self.capacity * self.S_critical_low_ratio

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == self.n_rounds - 1:
            return Action.D
        if current_stock <= self.S_critical_low:
            return Action.C
        if current_round_number == 0:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[current_round_number - 1, :]
        num_C_opponents = np.sum(previous_round_opponent_actions)
        num_D_opponents = self.n_players - 1 - num_C_opponents
        cooperation_rate = num_C_opponents / (self.n_players - 1)
        my_consumption_if_D = current_stock / self.n_players
        consumption_by_C_opponent = current_stock / (2 * self.n_players)
        consumption_by_D_opponent = current_stock / self.n_players
        other_consumption_if_I_D = num_C_opponents * consumption_by_C_opponent + num_D_opponents * consumption_by_D_opponent
        total_consumption_if_I_D = my_consumption_if_D + other_consumption_if_I_D
        projected_S_remaining_if_I_D = current_stock - total_consumption_if_I_D
        if cooperation_rate >= self.cooperation_exploit_threshold:
            return Action.D
        elif cooperation_rate <= 1 - self.defection_avoid_sucker_threshold:
            if projected_S_remaining_if_I_D <= self.S_critical_low:
                return Action.C
            else:
                return Action.D
        elif current_stock > self.capacity * self.high_stock_threshold_ratio:
            return Action.D
        elif projected_S_remaining_if_I_D <= self.S_critical_low:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_211(BaseStrategy):
    """
    The "Adaptive Opportunist - Ruthless" strategy for the Common Pool Resource game.

    Core Philosophy: Prioritize immediate self-gain (defecting) unless a strategic
    cooperation move is clearly beneficial for maximizing *my* total payoff over
    the long term (by preserving the resource for *my* future exploitation). Never be a sucker.

    Key Principles:
    1.  Exploit when safe: If opponents are largely cooperating, free-ride.
    2.  Defend when threatened: If opponents are largely defecting, defect yourself to avoid being exploited.
    3.  Preserve strategically: Only cooperate to sustain the resource if it enables more significant
        future exploitation opportunities *for me*, or prevents total collapse leading to zero payoffs for everyone.
    4.  No future, no mercy: In the last round, always defect.
    5.  Probe initially: Start cooperatively to gather information and avoid immediate mutual destruction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_t_1_indexed = state.round_number + 1
        current_stock_S = state.current_stock
        if current_round_t_1_indexed == r:
            return Action.D
        if current_round_t_1_indexed == 1:
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        num_cooperators_prev_round = np.sum(previous_round_opponent_actions)
        num_opponents = n - 1
        cooperation_ratio = num_cooperators_prev_round / num_opponents
        terminal_stock_threshold = float(n)
        low_stock_health_threshold = capacity / 4
        exploit_threshold_ratio = 0.75
        defend_threshold_ratio = 0.5
        if current_stock_S <= terminal_stock_threshold:
            if cooperation_ratio < defend_threshold_ratio:
                return Action.D
            else:
                return Action.C
        if cooperation_ratio >= exploit_threshold_ratio:
            return Action.D
        elif cooperation_ratio < defend_threshold_ratio:
            return Action.D
        elif current_stock_S < low_stock_health_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_212(BaseStrategy):
    """
    An exploitative, adaptive, and robust strategy for the Common Pool Resource game.
    It defaults to defection, only cooperating under specific, self-serving conditions
    related to preventing resource collapse that would harm its future extraction capabilities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.FREE_RIDE_THRESHOLD = 0.4
        self.CRITICAL_DEPLETION_THRESHOLD_RATIO = 0.05
        self.MIN_STOCK_TO_CONSIDER_COOP_RATIO = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_round == total_rounds - 1:
            return Action.D
        if current_round == total_rounds - 2:
            return Action.D
        P_D_other = 0.0
        if current_round > 0 and history is not None:
            prev_round_opponent_actions = history.opponent_actions[-1, :]
            num_others_D_sum = n_players - 1 - np.sum(prev_round_opponent_actions)
            total_opportunities_for_others = n_players - 1
            P_D_other = num_others_D_sum / total_opportunities_for_others
        if P_D_other < self.FREE_RIDE_THRESHOLD:
            return Action.D
        if P_D_other > 1.0 - self.FREE_RIDE_THRESHOLD:
            return Action.D
        estimated_others_D = min(n_players - 1, max(0, round(P_D_other * (n_players - 1))))
        estimated_others_C = n_players - 1 - estimated_others_D
        total_D_players_if_I_D = estimated_others_D + 1
        total_C_players_if_I_D = estimated_others_C
        consumption_if_I_D = total_D_players_if_I_D * current_stock / n_players + total_C_players_if_I_D * current_stock / (2 * n_players)
        S_remaining_if_I_D = current_stock - consumption_if_I_D
        total_D_players_if_I_C = estimated_others_D
        total_C_players_if_I_C = estimated_others_C + 1
        consumption_if_I_C = total_D_players_if_I_C * current_stock / n_players + total_C_players_if_I_C * current_stock / (2 * n_players)
        S_remaining_if_I_C = current_stock - consumption_if_I_C
        critical_depletion_level = capacity * self.CRITICAL_DEPLETION_THRESHOLD_RATIO
        if S_remaining_if_I_D <= critical_depletion_level and S_remaining_if_I_C > critical_depletion_level and (current_stock < capacity * self.MIN_STOCK_TO_CONSIDER_COOP_RATIO):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_213(BaseStrategy):
    """
    The "Opportunistic Piranha" strategy aims to maximize total payoff by
    aggressively exploiting cooperative behavior and abundant resources,
    while carefully managing the risk of resource depletion. It adapts to
    opponent actions and resource levels, always prioritizing its own cumulative payoff.

    Core Principles:
    1.  Exploit Abundance: When the resource is plentiful or others are conserving, take a larger share.
    2.  Self-Preserve Resource: Cooperate only when the resource is critically endangered to prevent a total collapse.
    3.  Defensive Defection: If many opponents are defecting, join them to maximize share from the dwindling resource.
    4.  No Future, No Restraint: Defect in the final round.
    5.  Aggressive Start: Begin by defecting to probe opponents and maximize early gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.depletion_risk_threshold = self.capacity / self.n_players
        self.cooperation_exploit_threshold_rate = 0.25
        self.high_defection_join_threshold_rate = 0.5
        self.healthy_stock_for_mixed_defection = self.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if state.round_number == 0:
            return Action.D
        elif current_stock <= self.depletion_risk_threshold:
            return Action.C
        else:
            num_opponent_defectors_last_round = (~history.opponent_actions[-1, :]).sum()
            n_opponents = self.n_players - 1
            opponent_defection_rate = 0.0
            if n_opponents > 0:
                opponent_defection_rate = num_opponent_defectors_last_round / n_opponents
            if opponent_defection_rate < self.cooperation_exploit_threshold_rate:
                return Action.D
            elif opponent_defection_rate >= self.high_defection_join_threshold_rate:
                return Action.D
            elif current_stock > self.healthy_stock_for_mixed_defection:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_214(BaseStrategy):
    """
    An exploitative strategy, Opportunistic Extractor (OE), designed to maximize its
    total payoff over r rounds in the Common Pool Resource Game. OE prioritizes
    immediate gain by defecting but strategically cooperates when the common
    resource is endangered, acting out of self-preservation to ensure future
    exploitation opportunities. It aggressively exploits periods of cooperation
    from other players and resorts to a pure defect strategy in the final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD = self.game_description.capacity / 2.0
        self.EXPLOIT_COOPERATION_RATE = 0.5
        self.SHORT_HORIZON_ROUNDS = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining = n_rounds - (current_round + 1)
        if rounds_remaining < self.SHORT_HORIZON_ROUNDS:
            return Action.D

        def get_defection_rate_from_history():
            num_defectors_last_round = np.sum(~history.opponent_actions[-1, :])
            return num_defectors_last_round / n_players
        if current_stock <= self.CRITICAL_STOCK_THRESHOLD:
            if current_round == 0:
                return Action.C
            else:
                defection_rate = get_defection_rate_from_history()
                if defection_rate >= self.EXPLOIT_COOPERATION_RATE:
                    return Action.C
                else:
                    return Action.D
        elif current_round == 0:
            return Action.D
        else:
            defection_rate = get_defection_rate_from_history()
            if defection_rate < self.EXPLOIT_COOPERATION_RATE:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_215(BaseStrategy):
    """
    The "Adaptive Predator" strategy maximizes individual payoff by aggressively exploiting the common resource.
    It adaptively balances immediate gains from defection with the long-term need to preserve the resource,
    and responds to observed opponent behaviors. It makes calculated "cooperative" moves only when they serve
    the ultimate goal of maximizing its own total extraction over the game's duration.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_crit_ratio = 0.2
        self.S_high_ratio = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        stock = state.current_stock
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == r:
            return Action.D
        if stock <= self.S_crit_ratio * capacity:
            return Action.C
        if stock >= self.S_high_ratio * capacity:
            return Action.D
        if state.round_number == 0:
            return Action.D
        else:
            my_prev_action_was_C = history.my_actions[-1]
            opponent_prev_cooperators = np.sum(history.opponent_actions[-1, :])
            total_cooperators_prev = opponent_prev_cooperators + (1 if my_prev_action_was_C else 0)
            k_prev = n - total_cooperators_prev
            if k_prev == n:
                return Action.D
            elif k_prev == 0:
                return Action.D
            elif k_prev > math.floor(n / 2):
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_216(BaseStrategy):
    """
    Adaptive Stock Predator strategy for the Common Pool Resource game.
    This strategy aims to maximize its own total payoff by defecting when
    possible, but cooperates to prevent resource collapse if stock levels are low
    or if other players are defecting too much, ensuring long-term exploitation potential.

    Note: The original strategy description includes a rule (Rule D) that depends
    on comparing the current stock to the stock at the start of the previous round.
    Due to the structure of the provided `PlayerHistory` dataclass, this specific
    piece of information (previous round's starting stock) is not directly available.
    As a consequence, Rule D has been simplified: in moderate conditions (stock
    not critically low/recovering, and others' cooperation not extremely high/low),
    the strategy defaults to Defect, aligning with its "exploitative" nature.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold_high = 0.7
        self.cooperation_threshold_low = 0.3
        self.stock_danger_threshold_ratio = 0.25
        self.stock_recovery_target_ratio = 0.5
        self.stock_danger_threshold = self.game_description.capacity * self.stock_danger_threshold_ratio
        self.stock_recovery_target = self.game_description.capacity * self.stock_recovery_target_ratio

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        if current_round_1_indexed == total_rounds:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.C
        prev_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        n_c_others_prev = np.sum(prev_round_opponent_actions)
        avg_c_rate_others_prev = n_c_others_prev / (n_players - 1)
        if current_stock <= self.stock_danger_threshold:
            return Action.C
        elif current_stock < self.stock_recovery_target and avg_c_rate_others_prev < self.cooperation_threshold_low:
            return Action.C
        elif avg_c_rate_others_prev >= self.cooperation_threshold_high:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_217(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its own total payoff. It defaults to defection
    to maximize immediate gains but adaptively switches to cooperation to prevent the common resource
    from collapsing, especially if others are not cooperating sufficiently. It uses thresholds
    related to the resource capacity to make critical decisions.
    """
    AVERAGE_DEFECTION_ASSUMPTION_NO_HISTORY = 0.5
    MAX_HISTORY_LOOKBACK_ROUNDS = 3

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.STOCK_CRITICAL_LOW_THRESHOLD = self.capacity / (2 * self.n)
        self.STOCK_DANGER_THRESHOLD = self.capacity / self.n

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        game_round_num = state.round_number + 1
        if game_round_num == self.r:
            return Action.D
        if state.round_number == 0:
            return Action.D
        total_other_actions_observed = 0
        total_other_defections_observed = 0
        actual_lookback_rounds = min(self.MAX_HISTORY_LOOKBACK_ROUNDS, state.round_number)
        start_history_idx = state.round_number - actual_lookback_rounds
        end_history_idx = state.round_number - 1
        for hist_round_idx in range(start_history_idx, end_history_idx + 1):
            round_opponent_actions = history.opponent_actions[hist_round_idx, :]
            total_other_actions_observed += len(round_opponent_actions)
            total_other_defections_observed += np.sum(~round_opponent_actions)
        estimated_other_defection_rate: float
        if total_other_actions_observed == 0:
            estimated_other_defection_rate = self.AVERAGE_DEFECTION_ASSUMPTION_NO_HISTORY
        else:
            estimated_other_defection_rate = total_other_defections_observed / total_other_actions_observed
        predicted_others_D = round(estimated_other_defection_rate * (self.n - 1))
        predicted_others_D = max(0, min(predicted_others_D, self.n - 1))
        sim_num_defectors_if_I_D = predicted_others_D + 1
        sim_num_cooperators_if_I_D = self.n - sim_num_defectors_if_I_D
        consumption_by_cooperators = sim_num_cooperators_if_I_D * current_stock / (2 * self.n)
        consumption_by_defectors = sim_num_defectors_if_I_D * current_stock / self.n
        sim_total_consumption_if_I_D = consumption_by_cooperators + consumption_by_defectors
        sim_S_after_consumption_if_I_D = max(0.0, current_stock - sim_total_consumption_if_I_D)
        sim_growth_if_I_D = 2 * sim_S_after_consumption_if_I_D * (1 - sim_S_after_consumption_if_I_D / self.capacity)
        projected_new_stock_if_I_D = min(sim_S_after_consumption_if_I_D + sim_growth_if_I_D, self.capacity)
        if current_stock <= self.STOCK_CRITICAL_LOW_THRESHOLD:
            return Action.C
        elif projected_new_stock_if_I_D < self.STOCK_DANGER_THRESHOLD:
            if estimated_other_defection_rate < 0.5:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_218(BaseStrategy):
    """
    The Relentless Poacher strategy: Aggressively extracts resources, defaulting to defection.
    It cooperates only when the resource is severely depleted and there are enough future
    rounds for recovery to benefit the strategy's own long-term exploitation, or in
    final rounds when defection yields practically zero. It prioritizes immediate gain
    and self-preservation of the resource for future exploitation, not for altruism.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.DANGER_STOCK_THRESHOLD: float = self.game_description.capacity / 4.0
        self.LAST_CHANCE_STOCK_THRESHOLD: float = self.game_description.capacity / 8.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number: int = state.round_number
        current_stock: float = state.current_stock
        n_rounds: int = self.game_description.n_rounds
        r_remaining: int = n_rounds - current_round_number
        if r_remaining == 1:
            return Action.D
        if current_stock < self.DANGER_STOCK_THRESHOLD:
            if r_remaining <= 3:
                if current_stock < self.LAST_CHANCE_STOCK_THRESHOLD:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_219(BaseStrategy):
    """
    "The Predator" strategy for the Common Pool Resource game.

    This strategy aims to maximize the player's total payoff by primarily defecting,
    but with calculated, temporary cooperation when it serves the long-term goal
    of sustained exploitation. It adapts its behavior based on stock levels,
    remaining rounds, and opponent behavior, only cooperating when it's a
    strategic investment in future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Predator strategy with game parameters.

        Args:
            game_description: An object containing game parameters like
                              n_players, n_rounds, and capacity.
        """
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the player's action (Cooperate or Defect) for the current round.

        Args:
            state: An object containing the current round number and stock level.
            history: An object containing past actions and payoffs for the player
                     and opponents, or None for the very first round.

        Returns:
            An Action.C (Cooperate) or Action.D (Defect).
        """
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        n = self.n
        r = self.r
        capacity = self.capacity
        num_rounds_left = r - current_round_1_indexed
        last_round_opponent_defection_count = 0
        if state.round_number > 0 and history is not None:
            num_opponents = n - 1
            num_cooperators = np.count_nonzero(history.opponent_actions[state.round_number - 1, :])
            last_round_opponent_defection_count = num_opponents - num_cooperators
        CRITICAL_STOCK_LEVEL = max(capacity / (4.0 * n), n / 2.0)
        EXPLOIT_STOCK_THRESHOLD = capacity * 0.75
        CONSERVE_STOCK_THRESHOLD = capacity * 0.25
        if num_rounds_left == 0:
            return Action.D
        if current_stock <= CRITICAL_STOCK_LEVEL:
            return Action.D
        if current_stock >= EXPLOIT_STOCK_THRESHOLD:
            return Action.D
        if current_stock <= CONSERVE_STOCK_THRESHOLD:
            max_allowed_defection_for_cooperation = max(1, (n - 1) // 4)
            if last_round_opponent_defection_count <= max_allowed_defection_for_cooperation and num_rounds_left >= 2:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_220(BaseStrategy):
    """
    Adaptive Resource Predator strategy: Defaults to defection but strategically
    cooperates to preserve the common pool resource when it's critically low,
    or when others are not cooperating enough and the stock is moderate.
    It exploits others' cooperation when the resource is robust or when opponents
    are sufficiently cooperative, maximizing immediate personal gain while
    ensuring long-term exploitation potential.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_ratio = 0.25
        self.high_stock_ratio = 0.75
        self.cooperation_threshold_ratio = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == r - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        elif current_stock < self.critical_stock_ratio * capacity:
            return Action.C
        else:
            opponent_actions_last_round = history.opponent_actions[current_round_0_indexed - 1, :]
            num_cooperators_last_round = np.sum(opponent_actions_last_round)
            cooperation_rate = num_cooperators_last_round / (n - 1)
            if cooperation_rate >= self.cooperation_threshold_ratio:
                return Action.D
            elif current_stock >= self.high_stock_ratio * capacity:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_221(BaseStrategy):
    """
    The Opportunistic Predator's default action is to Defect to maximize its immediate payoff.
    However, it will temporarily Cooperate only if its defection would push the common stock
    into a critically low state, thereby jeopardizing future exploitation, AND its cooperation
    can realistically make a significant difference in salvaging the resource. This is a
    self-serving act to preserve the resource for continued extraction, not an act of altruism.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / (2.0 * self.n_players)
        self.COOPERATION_BENEFIT_THRESHOLD = 1.2

    def _project_stock_dynamics(self, S_current: float, my_action: Action, avg_cooperators_k: float) -> float:
        """
        Helper method to project the stock level for the next round given current stock,
        my hypothetical action, and the estimated average number of cooperating opponents.
        """
        n = self.n_players
        capacity = self.capacity
        my_consumption = S_current / (n if my_action == Action.D else 2.0 * n)
        actual_avg_cooperators_k = max(0.0, min(self.n_players - 1.0, avg_cooperators_k))
        num_defecting_others = self.n_players - 1.0 - actual_avg_cooperators_k
        actual_num_defecting_others = max(0.0, min(self.n_players - 1.0, num_defecting_others))
        estimated_others_C_consumption = actual_avg_cooperators_k * (S_current / (2.0 * n))
        estimated_others_D_consumption = actual_num_defecting_others * (S_current / n)
        total_consumption = my_consumption + estimated_others_C_consumption + estimated_others_D_consumption
        stock_after_consumption = max(0.0, S_current - total_consumption)
        if capacity == 0.0:
            growth = 0.0
        else:
            growth = 2.0 * stock_after_consumption * (1.0 - stock_after_consumption / capacity)
        projected_new_stock = min(stock_after_consumption + growth, capacity)
        return projected_new_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_game_round = state.round_number + 1
        current_stock = state.current_stock
        n = self.n_players
        n_minus_1 = self.n_players - 1.0
        if current_game_round == self.n_rounds:
            return Action.D
        avg_cooperators_k = 0.0
        if state.round_number == 0:
            avg_cooperators_k = n_minus_1 / 2.0
        else:
            sum_cooperators = 0
            for r_idx in range(state.round_number):
                sum_cooperators += np.sum(history.opponent_actions[r_idx, :])
            avg_cooperators_k = sum_cooperators / float(state.round_number)
        avg_cooperators_k = max(0.0, min(n_minus_1, avg_cooperators_k))
        projected_S_D = self._project_stock_dynamics(current_stock, Action.D, avg_cooperators_k)
        projected_S_C = self._project_stock_dynamics(current_stock, Action.C, avg_cooperators_k)
        if projected_S_D < self.CRITICAL_STOCK_THRESHOLD:
            if projected_S_C >= self.CRITICAL_STOCK_THRESHOLD and projected_S_C > projected_S_D * self.COOPERATION_BENEFIT_THRESHOLD:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_222(BaseStrategy):
    """
    The "Opportunistic Conserver" strategy for the Common Pool Resource game.

    This strategy aims to maximize its own total payoff over `r` rounds by balancing
    immediate exploitation (defecting) with strategic conservation (cooperating) to
    prevent resource collapse and enable future exploitation opportunities. It adapts
    its behavior based on the current stock level, the actions of other players in
    the previous round, and its own recent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_CRITICAL_LOW = self.capacity / 4.0
        self.STOCK_DROP_THRESHOLD_RATIO = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num = state.round_number
        current_stock = state.current_stock
        if current_round_num == 0:
            return Action.C
        if current_round_num == self.r - 1:
            return Action.D
        prev_round_idx = current_round_num - 1
        my_action_last_round_bool = history.my_actions[prev_round_idx]
        my_payoff_last_round = history.my_payoffs[prev_round_idx]
        previous_stock_level = 0.0
        if my_payoff_last_round > 0:
            if my_action_last_round_bool == Action.C.value:
                previous_stock_level = my_payoff_last_round * (2 * self.n)
            else:
                previous_stock_level = my_payoff_last_round * self.n
        opponent_actions_last_round = history.opponent_actions[prev_round_idx, :]
        num_other_defectors_last_round = np.sum(opponent_actions_last_round == Action.D.value)
        if current_stock < self.S_CRITICAL_LOW:
            return Action.C
        else:
            if num_other_defectors_last_round == 0:
                return Action.D
            my_action_last_round_was_D = my_action_last_round_bool == Action.D.value
            if my_action_last_round_was_D and previous_stock_level > 0 and (current_stock < previous_stock_level * self.STOCK_DROP_THRESHOLD_RATIO):
                return Action.C
            num_other_players = self.n - 1
            if num_other_defectors_last_round >= math.ceil(num_other_players / 2.0):
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_223(BaseStrategy):
    """
    The Pragmatic Free-Rider: A strategy that primarily defects to maximize individual payoff,
    but adapts to prevent resource collapse and strategically encourage (then exploit)
    cooperation from other players. It responds to observed opponent behavior to avoid
    being a "sucker" or to free-ride on collective sacrifices.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_RATIO = 0.2
        self.COOPERATION_SIGNAL_STOCK_RATIO = 0.5
        self.DEFECTION_RESPONSE_THRESHOLD = 0.6
        self.COOPERATION_LURE_THRESHOLD = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == r - 1:
            return Action.D
        if current_stock < self.CRITICAL_STOCK_RATIO * capacity:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.C
        num_opponent_cooperators_prev = np.sum(history.opponent_actions[-1, :])
        num_opponents = n - 1
        if num_opponents == 0:
            return Action.D
        num_opponent_defectors_prev = num_opponents - num_opponent_cooperators_prev
        opponent_defection_rate_prev = num_opponent_defectors_prev / num_opponents
        opponent_cooperation_rate_prev = num_opponent_cooperators_prev / num_opponents
        if opponent_defection_rate_prev >= self.DEFECTION_RESPONSE_THRESHOLD:
            return Action.D
        if opponent_cooperation_rate_prev >= self.COOPERATION_LURE_THRESHOLD:
            return Action.D
        if current_stock < self.COOPERATION_SIGNAL_STOCK_RATIO * capacity:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_224(BaseStrategy):
    """
    This strategy is designed to be highly exploitative, prioritizing individual gain while adapting
    to maintain the common resource at a level that allows for continued exploitation. It operates
    on the principle of taking as much as possible whenever feasible, only cooperating as a necessary
    evil to prevent the resource from collapsing or to strategically influence others towards more
    cooperative behavior that can then be exploited.

    The strategy has two main priorities for cooperation:
    1. Stock Preservation: Cooperate if the common resource falls below a critical threshold
       (capacity / 2) to prevent its collapse, ensuring future exploitation opportunities.
    2. Adaptive Exploitation: If the stock is healthy, monitor the proportion of defectors
       in the previous round. If it exceeds a 'MAX_TOLERATED_DEFECTORS_PROPORTION' (0.5),
       cooperate temporarily to signal that excessive defection will be met with self-restraint,
       aiming to encourage others to cooperate more in subsequent rounds. Otherwise, defect
       to maximize immediate gain.

    In the first and last rounds, the strategy always defects to maximize immediate payoff,
    as there are no prior actions to react to (first round) or future consequences to consider
    (last round).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.MAX_TOLERATED_DEFECTORS_PROPORTION = 0.5
        self.STOCK_CRITICAL_THRESHOLD = self.game_description.capacity / 2.0
        self.n_players = self.game_description.n_players
        self.n_rounds = self.game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        if current_stock < self.STOCK_CRITICAL_THRESHOLD:
            return Action.C
        else:
            previous_round_history_index = current_round_0_indexed - 1
            my_action_last_round = history.my_actions[previous_round_history_index]
            opponent_actions_last_round = history.opponent_actions[previous_round_history_index, :]
            defectors_count_last_round = 0
            if not my_action_last_round:
                defectors_count_last_round = 1
            defectors_count_last_round += np.sum(~opponent_actions_last_round)
            proportion_defectors = defectors_count_last_round / self.n_players
            if proportion_defectors > self.MAX_TOLERATED_DEFECTORS_PROPORTION:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_225(BaseStrategy):
    """
    Adaptive Exploiter strategy for the Common Pool Resource Game.
    Defaults to defection and exploits opportunities, only cooperating
    for self-preservation if a collapse is imminent and preventable,
    or in a 'race to the bottom' scenario.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.COLLAPSE_THRESHOLD_RATIO = 0.05
        self.RECOVERY_SIGNAL_RATIO = 0.4
        self.DEFECTION_PREVALENCE_THRESHOLD = 0.6

    def _project_next_stock(self, current_stock: float, my_action: Action, k_prev_defectors: int) -> float:
        """
        Projects the stock level for the next round based on current stock,
        my hypothetical action, and observed previous defection rate from others.
        Assumes that the observed previous defection rate (k_prev_defectors)
        persists among other players for the current round's projection.
        """
        n = self.n_players
        capacity = self.capacity
        if my_action == Action.C:
            my_consumption = current_stock / (2 * n)
        else:
            my_consumption = current_stock / n
        others_consumption = k_prev_defectors * (current_stock / n) + (n - 1 - k_prev_defectors) * (current_stock / (2 * n))
        total_consumption = my_consumption + others_consumption
        S_after_cons = max(0.0, current_stock - total_consumption)
        growth = 2 * S_after_cons * (1 - S_after_cons / capacity)
        S_next_projected = min(S_after_cons + growth, capacity)
        return S_next_projected

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        n = self.n_players
        r = self.n_rounds
        capacity = self.capacity
        if current_round_0_indexed == 0:
            return Action.D
        if current_round_0_indexed == r - 1:
            return Action.D
        k_prev_defectors = np.sum(history.opponent_actions[current_round_0_indexed - 1, :] == False)
        defection_prevalence = k_prev_defectors / (n - 1)
        S_next_projected_C = self._project_next_stock(current_stock, Action.C, k_prev_defectors)
        S_next_projected_D = self._project_next_stock(current_stock, Action.D, k_prev_defectors)
        collapse_threshold = capacity * self.COLLAPSE_THRESHOLD_RATIO
        recovery_signal_threshold = capacity * self.RECOVERY_SIGNAL_RATIO
        rounds_remaining_after_this_round = r - (current_round_0_indexed + 1)
        if S_next_projected_D <= collapse_threshold and S_next_projected_C >= recovery_signal_threshold and (rounds_remaining_after_this_round > 1):
            return Action.C
        elif defection_prevalence >= self.DEFECTION_PREVALENCE_THRESHOLD and S_next_projected_C <= recovery_signal_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_226(BaseStrategy):
    """
    The Opportunistic Predator strategy aims for aggressive self-gain, defecting by default,
    but implements adaptive measures and emergency brakes to prevent resource collapse.
    It cooperates only when the common pool resource is critically low, when reacting to
    rapid stock decline, or temporarily in the penultimate round to secure a minimal
    final round payoff. Otherwise, it defects, especially when others are cooperative
    (free-riding) or the stock is abundant.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.K_HISTORY = 3
        self.C_THRESHOLD_FREE_RIDE = 0.7
        self.S_EMERGENCY_COOPERATE_RATIO = 0.1
        self.S_RECOVER_EXPLOIT_RATIO = 0.4
        self.S_AGGRESSIVE_EXPLOIT_RATIO = 0.8
        self.S_DECLINE_TRIGGER_RATIO = 0.08
        self.emergency_cooperation_active = False
        self.opponent_cooperation_counts_history = []
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock_level = state.current_stock
        self.stock_history.append(current_stock_level)
        if state.round_number > 0:
            previous_round_opponent_cooperators = sum(history.opponent_actions[-1, :])
            self.opponent_cooperation_counts_history.append(previous_round_opponent_cooperators)
        if current_stock_level <= self.capacity * self.S_EMERGENCY_COOPERATE_RATIO:
            self.emergency_cooperation_active = True
        elif current_stock_level >= self.capacity * self.S_RECOVER_EXPLOIT_RATIO:
            self.emergency_cooperation_active = False
        if self.emergency_cooperation_active:
            return Action.C
        if current_round_1_indexed == self.r:
            return Action.D
        elif current_round_1_indexed == self.r - 1:
            if current_stock_level <= self.capacity * self.S_EMERGENCY_COOPERATE_RATIO:
                return Action.C
            else:
                return Action.D
        num_rounds_to_consider = min(state.round_number, self.K_HISTORY)
        avg_C_rate = 0.5
        if num_rounds_to_consider > 0 and self.n - 1 > 0:
            opponent_cooperation_sum = sum(self.opponent_cooperation_counts_history[-num_rounds_to_consider:])
            total_possible_opponent_actions = num_rounds_to_consider * (self.n - 1)
            avg_C_rate = opponent_cooperation_sum / total_possible_opponent_actions
        if avg_C_rate >= self.C_THRESHOLD_FREE_RIDE:
            return Action.D
        if current_stock_level >= self.capacity * self.S_AGGRESSIVE_EXPLOIT_RATIO:
            return Action.D
        if state.round_number > 0:
            stock_at_start_of_previous_round = self.stock_history[state.round_number - 1]
            stock_decline = stock_at_start_of_previous_round - current_stock_level
            if stock_decline > self.capacity * self.S_DECLINE_TRIGGER_RATIO:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_60(BaseStrategy):
    """
    Adaptive Collective Reciprocator with Sustainability Guard strategy for the Common Pool Resource Game.

    This strategy aims to foster and maintain collective cooperation for long-term resource
    sustainability, while simultaneously protecting itself from exploitation by other players.
    It operates on principles of conditional cooperation, reciprocity, and a strong emphasis
    on resource conservation when the stock is low.

    Key Principles:
    1. Start Cooperative: Initiate cooperation to signal willingness to collaborate.
    2. Protect the Resource: Prioritize the health of the common pool stock, especially when
       it is critically low, by cooperating unconditionally.
    3. Reciprocate Behavior: Adapt to the actions of others, punishing significant defection
       to prevent exploitation and incentivize a return to cooperation.
    4. Endgame Rationality: Acknowledge the lack of future consequences in the final round
       by defecting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters and calculates internal thresholds.

        Args:
            game_description: A CommonPoolDescription object containing n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_CRITICAL_THRESHOLD = self.capacity / 4.0
        if self.n_players == 2:
            self.D_TOLERANCE_THRESHOLD = 0
        else:
            self.D_TOLERANCE_THRESHOLD = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: A CommonPoolState object containing the current_stock and round_number.
            history: A PlayerHistory object containing past actions and payoffs, or None if it's the first round.

        Returns:
            Action.C for Cooperate or Action.D for Defect.
        """
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.C
        elif current_round_1_indexed == self.n_rounds:
            return Action.D
        elif current_stock < self.S_CRITICAL_THRESHOLD:
            return Action.C
        else:
            previous_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
            num_defectors_prev_round = sum((1 for action_bool in previous_round_opponent_actions if not action_bool))
            if num_defectors_prev_round > self.D_TOLERANCE_THRESHOLD:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_289(BaseStrategy):
    """
    Resource Guardian with Adaptive Forgiveness: An adaptive strategy for the Common Pool Resource Game,
    prioritizing resource sustainability through conditional cooperation, targeted punishment,
    and active attempts at forgiveness to restore collaborative behavior.
    """

    class StrategyState(Enum):
        """Internal states for the Resource Guardian strategy."""
        COOPERATING = 0
        PUNISHING = 1
        FORGIVING = 2

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_ratio: float = 0.25
        self.recovery_stock_ratio: float = 0.75
        self.defection_threshold_to_punish: int = 1
        self.max_punishment_duration: int = 2
        self.forgiveness_rounds_after_my_defection: int = 2
        self._current_player_state: ResourceGuardianWithAdaptiveForgiveness.StrategyState = self.StrategyState.COOPERATING
        self._rounds_in_current_state: int = 0
        self._my_last_action: Action = Action.C

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        decision_for_this_round: Action
        if current_round == self.n_rounds - 1:
            decision_for_this_round = Action.D
            self._my_last_action = decision_for_this_round
            return decision_for_this_round
        if current_stock < self.critical_stock_ratio * self.capacity:
            self._current_player_state = self.StrategyState.COOPERATING
            self._rounds_in_current_state = 0
            decision_for_this_round = Action.C
            self._my_last_action = decision_for_this_round
            return decision_for_this_round
        if current_round == 0:
            self._current_player_state = self.StrategyState.COOPERATING
            self._rounds_in_current_state = 0
            decision_for_this_round = Action.C
            self._my_last_action = decision_for_this_round
            return decision_for_this_round
        num_opponent_cooperators_prev_round = np.sum(history.opponent_actions[-1, :])
        num_defectors_prev_round = self.n_players - 1 - num_opponent_cooperators_prev_round
        if self._current_player_state == self.StrategyState.COOPERATING:
            self._rounds_in_current_state += 1
            if num_defectors_prev_round >= self.defection_threshold_to_punish:
                decision_for_this_round = Action.D
                self._current_player_state = self.StrategyState.PUNISHING
                self._rounds_in_current_state = 1
            else:
                decision_for_this_round = Action.C
        elif self._current_player_state == self.StrategyState.PUNISHING:
            self._rounds_in_current_state += 1
            if num_defectors_prev_round == 0 and current_stock >= self.recovery_stock_ratio * self.capacity:
                decision_for_this_round = Action.C
                self._current_player_state = self.StrategyState.COOPERATING
                self._rounds_in_current_state = 0
            elif self._rounds_in_current_state >= self.max_punishment_duration:
                decision_for_this_round = Action.C
                self._current_player_state = self.StrategyState.FORGIVING
                self._rounds_in_current_state = 1
            else:
                decision_for_this_round = Action.D
        elif self._current_player_state == self.StrategyState.FORGIVING:
            self._rounds_in_current_state += 1
            if num_defectors_prev_round == 0:
                decision_for_this_round = Action.C
                self._current_player_state = self.StrategyState.COOPERATING
                self._rounds_in_current_state = 0
            elif self._rounds_in_current_state >= self.forgiveness_rounds_after_my_defection:
                decision_for_this_round = Action.D
                self._current_player_state = self.StrategyState.PUNISHING
                self._rounds_in_current_state = 1
            else:
                decision_for_this_round = Action.C
        else:
            decision_for_this_round = Action.C
        self._my_last_action = decision_for_this_round
        return decision_for_this_round

class Strategy_COLLECTIVE_470(BaseStrategy):
    """
    Adaptive Sustainability Guardian (ASG) strategy.
    Prioritizes long-term resource health, balances cooperation, punishment,
    and forgiveness based on resource state and opponent actions.
    """

    class ASGState(Enum):
        """Internal states for the Adaptive Sustainability Guardian strategy."""
        COOPERATE = 'COOPERATE'
        PUNISH = 'PUNISH'

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.max_capacity = float(game_description.capacity)
        self.asg_state = self.ASGState.COOPERATE
        self.rounds_in_current_state = 0
        self.stock_history = []
        self.critical_stock_threshold = self.max_capacity / 4.0
        self.stock_decline_magnitude = self.max_capacity * 0.05
        self.recent_decline_window = 2
        self.widespread_defection_trigger_count = max(1, math.floor(self.n_players / 2))
        self.punishment_duration_rounds = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        S_current = state.current_stock
        self.stock_history.append(S_current)
        if current_round == 0:
            self.asg_state = self.ASGState.COOPERATE
            self.rounds_in_current_state = 0
            return Action.C
        if current_round == self.total_rounds - 1:
            return Action.D
        if S_current < self.critical_stock_threshold:
            self.asg_state = self.ASGState.COOPERATE
            self.rounds_in_current_state = 0
            return Action.C
        self.rounds_in_current_state += 1
        n_opponent_defectors_prev = self.n_players - 1 - sum(history.opponent_actions[-1, :])
        if self.asg_state == self.ASGState.PUNISH:
            if self.rounds_in_current_state < self.punishment_duration_rounds:
                return Action.D
            else:
                self.asg_state = self.ASGState.COOPERATE
                self.rounds_in_current_state = 0
        if self.asg_state == self.ASGState.COOPERATE:
            declining_rounds_count = 0
            if current_round >= self.recent_decline_window:
                relevant_stock_levels = self.stock_history[current_round - self.recent_decline_window:current_round + 1]
                for i in range(1, self.recent_decline_window + 1):
                    if relevant_stock_levels[i] - relevant_stock_levels[i - 1] < -self.stock_decline_magnitude:
                        declining_rounds_count += 1
            if declining_rounds_count == self.recent_decline_window:
                self.asg_state = self.ASGState.PUNISH
                self.rounds_in_current_state = 0
                return Action.D
            if n_opponent_defectors_prev > self.widespread_defection_trigger_count:
                self.asg_state = self.ASGState.PUNISH
                self.rounds_in_current_state = 0
                return Action.D
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_46(BaseStrategy):
    """
    The Adaptive Predator strategy is designed to be highly exploitative, aiming to maximize
    its own total payoff across rounds. It prioritizes immediate gain through defection but
    adapts its behavior to prevent the total collapse of the common resource, as a depleted
    resource yields no future profits. This strategy dynamically responds to both the health
    of the shared resource and the observed aggression levels of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CST = self.capacity / 4.0
        self.DTT = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.r - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        previous_round_0_indexed = current_round_0_indexed - 1
        cooperators_opponents_prev = np.sum(history.opponent_actions[previous_round_0_indexed, :])
        my_action_prev_was_cooperate = history.my_actions[previous_round_0_indexed]
        k_prev = cooperators_opponents_prev + (1 if my_action_prev_was_cooperate else 0)
        num_defectors_prev = self.n - k_prev
        proportion_defectors_prev = num_defectors_prev / self.n
        if current_stock < self.CST:
            if proportion_defectors_prev <= self.DTT:
                return Action.C
            else:
                return Action.D
        elif proportion_defectors_prev <= self.DTT:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_227(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its own total payoff in the Common Pool Resource game.
    It primarily defects to gain a higher immediate payoff but cooperates strategically to prevent
    the collapse of the common resource, thereby preserving future opportunities for exploitation.
    It also takes advantage of others' cooperation whenever possible.

    This strategy adapts to critical stock levels and responds to collective defection by opponents.
    Due to the absence of historical stock levels in the provided PlayerHistory, the strategy's
    adaptive mechanism for reacting to past opponent defection leading to stock decline has been
    adapted: it now triggers cooperation as a preventative measure if a significant number of others
    defected in the previous round, even if the stock is not yet critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / (self.n + 1)
        self.DEFECTION_CONCERN_THRESHOLD = (self.n - 1) / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.r:
            return Action.D
        if state.current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        if current_round_1_indexed == 1:
            return Action.D
        else:
            opponent_actions_prev_round = history.opponent_actions[state.round_number - 1]
            num_D_others_prev_round = self.n - 1 - np.sum(opponent_actions_prev_round)
            if num_D_others_prev_round >= self.DEFECTION_CONCERN_THRESHOLD:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_228(BaseStrategy):
    """
    The "Adaptive Predator" strategy primarily defects for immediate personal gain,
    but adapts to cooperate only when a calculated self-assessment reveals that
    defection would lead to a premature and significant decline in future personal payoffs,
    AND cooperation has a reasonable chance of averting that decline, thereby preserving
    the resource for continued exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_rem_critical = self.capacity / (2.0 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.total_rounds:
            return Action.D
        num_other_defectors_prev_round = 0
        num_other_cooperators_prev_round = 0
        if current_round_1_indexed == 1:
            num_other_defectors_prev_round = 0
            num_other_cooperators_prev_round = self.n_players - 1
        else:
            prev_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
            num_other_cooperators_prev_round = np.sum(prev_round_opponent_actions == True)
            num_other_defectors_prev_round = np.sum(prev_round_opponent_actions == False)
        my_consumption_if_D = current_stock / self.n_players
        my_consumption_if_C = current_stock / (2.0 * self.n_players)
        other_defectors_consumption = num_other_defectors_prev_round * (current_stock / self.n_players)
        other_cooperators_consumption = num_other_cooperators_prev_round * (current_stock / (2.0 * self.n_players))
        projected_total_consumption_if_I_D = my_consumption_if_D + other_defectors_consumption + other_cooperators_consumption
        projected_S_remaining_if_I_D = max(0.0, current_stock - projected_total_consumption_if_I_D)
        projected_total_consumption_if_I_C = my_consumption_if_C + other_defectors_consumption + other_cooperators_consumption
        projected_S_remaining_if_I_C = max(0.0, current_stock - projected_total_consumption_if_I_C)
        if current_stock <= self.S_rem_critical:
            if projected_S_remaining_if_I_C <= self.S_rem_critical:
                return Action.D
            else:
                return Action.C
        elif projected_S_remaining_if_I_D <= self.S_rem_critical and projected_S_remaining_if_I_C > self.S_rem_critical:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_229(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize individual gain by defaulting to defection ('D').
    It cooperates ('C') only when defection is predicted to lead to a state that is demonstrably worse
    for its own future cumulative payoffs, specifically by causing a critical early collapse of the
    resource when many rounds remain. It adapts to opponent behavior and current stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_high_threshold = 0.8 * self.capacity
        self.stock_critical_threshold = 0.05 * self.capacity
        self.defection_tolerance_threshold = math.floor(self.n / 4)
        self.defection_aggression_threshold = math.ceil(self.n / 2)
        self.rounds_to_care_about_future = max(3, math.ceil(self.r / 4))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = float(state.current_stock)
        if current_round_1_indexed == self.r:
            return Action.D
        num_defectors_prev = 0
        if state.round_number > 0:
            num_cooperators_prev = np.sum(history.opponent_actions[-1, :])
            num_defectors_prev = self.n - 1 - num_cooperators_prev
        if current_stock < self.stock_critical_threshold:
            return Action.D
        if current_stock >= self.stock_high_threshold:
            return Action.D
        if num_defectors_prev >= self.defection_aggression_threshold:
            return Action.D
        if num_defectors_prev <= self.defection_tolerance_threshold:
            return Action.D
        num_defectors_in_scenario_D = num_defectors_prev + 1
        num_cooperators_in_scenario_D = self.n - num_defectors_in_scenario_D
        num_defectors_in_scenario_D = min(num_defectors_in_scenario_D, self.n)
        num_cooperators_in_scenario_D = max(0, self.n - num_defectors_in_scenario_D)
        total_consumption_in_scenario_D = num_defectors_in_scenario_D * current_stock / self.n + num_cooperators_in_scenario_D * current_stock / (2 * self.n)
        S_remaining_after_consumption_in_scenario_D = max(0.0, current_stock - total_consumption_in_scenario_D)
        growth_in_scenario_D = 2 * S_remaining_after_consumption_in_scenario_D * (1 - S_remaining_after_consumption_in_scenario_D / self.capacity)
        S_next_if_I_D = min(S_remaining_after_consumption_in_scenario_D + growth_in_scenario_D, self.capacity)
        rounds_remaining = self.r - current_round_1_indexed
        if S_next_if_I_D < self.stock_critical_threshold and rounds_remaining > self.rounds_to_care_about_future:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_230(BaseStrategy):
    """
    The Opportunistic Exploiter strategy prioritizes individual gain by defaulting to defection.
    It strategically cooperates only when the common resource is critically endangered
    AND other players are demonstrating a collective effort to conserve it, to allow for future exploitation.
    In all other scenarios, including the final round, it defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.HEALTHY_STOCK_THRESHOLD = self.capacity * 0.75
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / (self.n * 2.0)
        self.MODERATE_COOPERATION_THRESHOLD = math.floor((self.n - 1) / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num_0_indexed = state.round_number
        current_stock = state.current_stock
        k_prev = 0
        if history is not None:
            num_opponents = self.n - 1
            num_cooperators_prev_round = np.sum(history.opponent_actions[-1, :])
            k_prev = num_opponents - num_cooperators_prev_round
        if current_round_num_0_indexed == self.r - 1:
            return Action.D
        if current_round_num_0_indexed == 0:
            return Action.D
        if current_stock > self.HEALTHY_STOCK_THRESHOLD and k_prev <= self.MODERATE_COOPERATION_THRESHOLD:
            return Action.D
        if current_stock <= self.CRITICAL_STOCK_THRESHOLD:
            if k_prev > self.MODERATE_COOPERATION_THRESHOLD:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_231(BaseStrategy):
    """
    The "Ruthless Opportunist" strategy prioritizes immediate self-gain by defecting (D)
    whenever the common pool resource is deemed healthy (at or above half capacity).
    It only switches to cooperating (C) out of self-preservation when the stock
    falls into a critical state (below half capacity), to prevent total collapse
    that would harm its own future payoffs. In the final round, it always defects
    to maximize terminal payoff with no future repercussions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        elif current_stock < self.capacity / 2.0:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_232(BaseStrategy):
    """
    Adaptive Predator strategy: Defect by default, but tactically cooperate to prevent resource collapse
    or to encourage opponent cooperation if defection trend is high, preserving future exploitation opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_RATIO = 0.5
        self.DEFECTION_TOLERANCE_PROPORTION = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == n_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        else:
            opponent_actions_prev_round = history.opponent_actions[current_round_0_indexed - 1, :]
            num_opponents_defected_prev_round = np.sum(opponent_actions_prev_round == False)
            n_opponents = n_players - 1
            proportion_opponents_defected_prev_round = num_opponents_defected_prev_round / n_opponents
            current_stock = state.current_stock
            if current_stock < capacity * self.CRITICAL_STOCK_RATIO:
                return Action.C
            elif proportion_opponents_defected_prev_round >= self.DEFECTION_TOLERANCE_PROPORTION:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_233(BaseStrategy):
    """
    Ruthless Opportunist strategy: Defaults to defection, but strategically cooperates
    to preserve the common pool only if its imminent collapse would significantly
    harm own future payoffs and own cooperation is likely to make a difference.
    If the resource is deemed doomed, exploits by defecting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.STOCK_DANGER_THRESHOLD = self.capacity / 4.0
        self.FUTILE_COOPERATION_STOCK_THRESHOLD = self.capacity / (4.0 * self.n_players)
        self.FUTILE_COOPERATION_DEFECTION_RATE_THRESHOLD = 0.9

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        else:
            previous_round_opponent_actions = history.opponent_actions[current_round - 1, :]
            num_opponent_defectors = np.sum(previous_round_opponent_actions == False)
            num_opponents = self.n_players - 1
            opponent_defection_rate = float(num_opponent_defectors) / num_opponents
            if current_stock < self.STOCK_DANGER_THRESHOLD:
                my_consumption_if_C = current_stock / (2.0 * self.n_players)
                num_opponent_cooperators = num_opponents - num_opponent_defectors
                estimated_opponent_consumption = num_opponent_defectors * current_stock / self.n_players + num_opponent_cooperators * current_stock / (2.0 * self.n_players)
                estimated_stock_after_my_C_and_their_last_actions = current_stock - my_consumption_if_C - estimated_opponent_consumption
                if estimated_stock_after_my_C_and_their_last_actions <= self.FUTILE_COOPERATION_STOCK_THRESHOLD or opponent_defection_rate >= self.FUTILE_COOPERATION_DEFECTION_RATE_THRESHOLD:
                    return Action.D
                else:
                    return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_234(BaseStrategy):
    """
    The "Adaptive Resource Predator" strategy is designed to maximize its own total payoff.
    It primarily defects to gain higher immediate rewards, while adaptively cooperating
    only when necessary to prevent resource collapse that would significantly harm its
    own future payoffs. It strategically leverages the cooperation of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if state.round_number == 0:
            return Action.D
        if current_round_1_indexed == self.r:
            return Action.D
        stock_ratio = current_stock / self.capacity
        previous_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        num_C_opponents_prev_round = int(np.sum(previous_round_opponent_actions))
        is_others_cooperating_sufficiently = num_C_opponents_prev_round >= (self.n - 1) // 2 + 1
        if stock_ratio < 0.15:
            if is_others_cooperating_sufficiently:
                return Action.C
            else:
                return Action.D
        elif stock_ratio < 0.4:
            if is_others_cooperating_sufficiently:
                return Action.D
            else:
                remaining_rounds = self.r - current_round_1_indexed
                if remaining_rounds >= self.r / 2:
                    return Action.C
                else:
                    return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_235(BaseStrategy):
    """
    The Opportunistic Conservationist strategy aims to maximize long-term personal gain by primarily
    defecting, but cooperates strategically when necessary to prevent resource collapse that would
    diminish future exploitative opportunities. It is adaptive to opponent behavior and robust
    across different game states and parameters.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_STOCK_FOR_COOPERATION = self.capacity / 4.0
        self.DOOMED_STOCK_THRESHOLD = self.capacity / (2.0 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        n_val = self.n_players
        cap_val = self.capacity
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        projected_C_by_others = np.sum(history.opponent_actions[-1, :])
        projected_D_by_others = n_val - 1 - projected_C_by_others
        consumption_per_C = current_stock / (2.0 * n_val)
        consumption_per_D = current_stock / float(n_val)
        total_consumption_if_my_D = consumption_per_D + projected_C_by_others * consumption_per_C + projected_D_by_others * consumption_per_D
        S_remaining_if_my_D = current_stock - total_consumption_if_my_D
        total_consumption_if_my_C = consumption_per_C + projected_C_by_others * consumption_per_C + projected_D_by_others * consumption_per_D
        S_remaining_if_my_C = current_stock - total_consumption_if_my_C
        if current_stock <= self.DOOMED_STOCK_THRESHOLD or S_remaining_if_my_D <= 0:
            return Action.D
        if projected_C_by_others == n_val - 1 and S_remaining_if_my_D >= self.CRITICAL_STOCK_FOR_COOPERATION:
            return Action.D
        if S_remaining_if_my_D <= self.CRITICAL_STOCK_FOR_COOPERATION and S_remaining_if_my_C > self.CRITICAL_STOCK_FOR_COOPERATION:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_236(BaseStrategy):
    """
    The Adaptive Exploiter strategy defaults to 'Defect' (D) for the highest
    immediate payoff, only switching to 'Cooperate' (C) under specific conditions
    designed to prevent resource collapse or to mitigate severe depletion,
    thereby preserving the resource for future exploitation.

    Decision Rules:
    1. Last Round Greed: In the final round, play D.
    2. Critical Stock Safeguard: If current stock is below CRITICAL_STOCK_THRESHOLD (2*n), play C.
    3. Adaptive Response to Group Exploitation:
        a. First Round Aggression: In the first round, play D.
        b. Monitor and React to Depletion: If stock decreased by SEVERE_DEPLETION_THRESHOLD (-0.10)
           or more from the previous round, play C to stabilize. Otherwise, play D.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.total_rounds = game_description.n_rounds
        self.CRITICAL_STOCK_THRESHOLD = 2 * self.n
        self.SEVERE_DEPLETION_THRESHOLD = -0.1
        self._previous_round_start_stock = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number + 1
        current_stock_at_start_of_round = state.current_stock
        action_to_take = Action.D
        if round_num == self.total_rounds:
            action_to_take = Action.D
        elif current_stock_at_start_of_round < self.CRITICAL_STOCK_THRESHOLD:
            action_to_take = Action.C
        elif round_num == 1:
            action_to_take = Action.D
        else:
            previous_stock_at_start = self._previous_round_start_stock
            if previous_stock_at_start <= 0:
                action_to_take = Action.C
            else:
                stock_change_ratio = (current_stock_at_start_of_round - previous_stock_at_start) / previous_stock_at_start
                if stock_change_ratio <= self.SEVERE_DEPLETION_THRESHOLD:
                    action_to_take = Action.C
                else:
                    action_to_take = Action.D
        self._previous_round_start_stock = current_stock_at_start_of_round
        return action_to_take

class Strategy_EXPLOITATIVE_237(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize individual payoff by aggressively extracting
    from the common pool resource, adapting its behavior based on resource health and observed
    opponent actions. It defaults to defection, using cooperation only as a strategic tool
    to ensure future exploitation opportunities or to avoid being "suckered."
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_CRITICAL_THRESHOLD = self.capacity / (2 * self.n_players)
        self.S_WARNING_THRESHOLD = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.D
        elif current_round_1_indexed == self.n_rounds:
            return Action.D
        num_opponent_cooperated_prev = np.sum(history.opponent_actions[-1, :])
        num_opponent_defected_prev = self.n_players - 1 - num_opponent_cooperated_prev
        rounds_remaining_for_future_play = self.n_rounds - current_round_1_indexed
        current_stock = state.current_stock
        if current_stock <= self.S_CRITICAL_THRESHOLD:
            if rounds_remaining_for_future_play <= 2:
                return Action.D
            else:
                return Action.C
        elif current_stock <= self.S_WARNING_THRESHOLD:
            if num_opponent_defected_prev >= self.n_players - 1:
                return Action.D
            elif num_opponent_cooperated_prev >= self.n_players - 1:
                return Action.D
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_238(BaseStrategy):
    """
    Opportunistic Predator: An exploitative strategy for the Common Pool Resource game.
    This strategy aims to maximize its own total payoff by defaulting to defection.
    It cooperates only when the resource stock falls below a critical threshold in
    non-final rounds to ensure the resource's survival for future exploitation.
    In the very last round, it always defects to extract maximum immediate gain
    without regard for future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD = 0.1 * self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round == total_rounds - 1:
            return Action.D
        elif current_stock <= self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_239(BaseStrategy):
    """
    The "Adaptive Extractor" strategy for the Common Pool Resource game.

    This strategy prioritizes immediate individual gain (defecting) but with
    a strategic, self-preservationist willingness to cooperate temporarily.
    Cooperation is only engaged to prevent resource collapse if that collapse
    would severely diminish future opportunities for this player's exploitation.
    It never cooperates out of altruism or to induce others' cooperation beyond
    this self-serving threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.THRESHOLD_CRITICAL_STOCK_RATIO = 0.1
        self.THRESHOLD_COLLAPSE_STOCK = self.capacity / (self.n_players * 2.0)
        self.COOPERATION_COOLDOWN_ROUNDS = 1
        self.my_last_action: Action | None = None
        self.rounds_since_last_self_preservation_cooperation: int = 0

    def _predict_next_stock(self, initial_stock: float, n_players: int, my_action_choice: Action, others_defectors_count: int, others_cooperators_count: int, capacity_val: float) -> float:
        """
        Simulates the stock level for the next round given current stock,
        hypothetical actions for the current round, and observed opponent behavior.
        """
        if my_action_choice == Action.D:
            consumption_me = initial_stock / n_players
        else:
            consumption_me = initial_stock / (2.0 * n_players)
        consumption_others_D = others_defectors_count * initial_stock / n_players
        consumption_others_C = others_cooperators_count * initial_stock / (2.0 * n_players)
        total_consumption = consumption_me + consumption_others_D + consumption_others_C
        S_after_consumption = max(0.0, initial_stock - total_consumption)
        growth = 2.0 * S_after_consumption * (1.0 - S_after_consumption / capacity_val)
        growth = max(0.0, growth)
        new_stock = min(S_after_consumption + growth, capacity_val)
        return new_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        my_decision = Action.D
        if current_round == self.n_rounds - 1:
            my_decision = Action.D
            self.my_last_action = my_decision
            return my_decision
        if current_round == 0:
            my_decision = Action.D
            self.my_last_action = my_decision
            self.rounds_since_last_self_preservation_cooperation = 0
            return my_decision
        if self.my_last_action == Action.C:
            self.rounds_since_last_self_preservation_cooperation += 1
        else:
            self.rounds_since_last_self_preservation_cooperation = 0
        last_round_opponent_actions = history.opponent_actions[-1, :]
        n_cooperators_others_last_round = np.sum(last_round_opponent_actions)
        k_defectors_others_last_round = self.n_players - 1 - n_cooperators_others_last_round
        predicted_next_stock_if_I_D = self._predict_next_stock(current_stock, self.n_players, Action.D, k_defectors_others_last_round, n_cooperators_others_last_round, self.capacity)
        predicted_next_stock_if_I_C = self._predict_next_stock(current_stock, self.n_players, Action.C, k_defectors_others_last_round, n_cooperators_others_last_round, self.capacity)
        if predicted_next_stock_if_I_D < self.THRESHOLD_COLLAPSE_STOCK and predicted_next_stock_if_I_C >= self.THRESHOLD_COLLAPSE_STOCK and (self.rounds_since_last_self_preservation_cooperation < self.COOPERATION_COOLDOWN_ROUNDS):
            my_decision = Action.C
        self.my_last_action = my_decision
        return my_decision

class Strategy_EXPLOITATIVE_240(BaseStrategy):
    """
    The Calculated Predator strategy aims to maximize its own total payoff over the rounds
    by generally defecting but cooperating strategically when it can avert catastrophic
    resource depletion that would harm its future extraction capabilities. It free-rides
    on others' cooperation and defects aggressively in end-game scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.end_game_K = max(1, min(3, self.r // 5))
        self.CRITICAL_STOCK_LEVEL = self.capacity / (2.0 * self.n)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.D
        if current_round_1_indexed >= self.r - self.end_game_K + 1:
            return Action.D
        last_round_opp_actions = history.opponent_actions[-1, :]
        num_cooperators_prev = np.sum(last_round_opp_actions)
        num_defectors_prev = self.n - 1 - num_cooperators_prev

        def _project_stock_dynamics(initial_stock: float, my_action_is_C: bool, num_coop_others: int, num_def_others: int, total_players: int, capacity: float) -> float:
            """Calculates the projected stock level for the next round."""
            consumption_rate_if_C = 1.0 / (2.0 * total_players)
            consumption_rate_if_D = 1.0 / total_players
            my_consumption = initial_stock * (consumption_rate_if_C if my_action_is_C else consumption_rate_if_D)
            opponents_consumption = num_def_others * (initial_stock * consumption_rate_if_D) + num_coop_others * (initial_stock * consumption_rate_if_C)
            total_consumption = my_consumption + opponents_consumption
            s_remaining = max(0.0, initial_stock - total_consumption)
            growth = 2.0 * s_remaining * (1.0 - s_remaining / capacity)
            s_next = min(s_remaining + growth, capacity)
            return s_next
        S_next_if_I_D = _project_stock_dynamics(current_stock, False, num_cooperators_prev, num_defectors_prev, self.n, self.capacity)
        S_next_if_I_C = _project_stock_dynamics(current_stock, True, num_cooperators_prev, num_defectors_prev, self.n, self.capacity)
        if S_next_if_I_D <= self.CRITICAL_STOCK_LEVEL and S_next_if_I_C > self.CRITICAL_STOCK_LEVEL:
            return Action.C
        if num_defectors_prev >= self.n / 2.0 or current_stock <= self.CRITICAL_STOCK_LEVEL:
            return Action.D
        if current_stock > self.capacity / 2.0 and num_cooperators_prev >= (self.n - 1) / 2.0:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_241(BaseStrategy):
    """
    The Cautious Predator strategy aims to maximize its total personal payoff.
    It defaults to defecting for immediate gains but cooperates if projecting that
    its own defection would drive the common stock below a critical threshold,
    thereby preventing resource collapse that would harm its future payoffs.
    In the final two rounds, it reverts to pure exploitation by always defecting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.STOCK_CRITICAL_LEVEL_FRACTION = 0.25
        self.LOOKBACK_ROUNDS = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number >= n_rounds - 2:
            return Action.D
        average_opponent_cooperation_rate = 0.5
        if history is not None and current_round_number > 0:
            total_other_actions_observed = 0
            total_other_cooperations_observed = 0
            start_lookback_idx = max(0, current_round_number - self.LOOKBACK_ROUNDS)
            relevant_opponent_actions = history.opponent_actions[start_lookback_idx:current_round_number, :]
            total_other_cooperations_observed = np.sum(relevant_opponent_actions)
            total_other_actions_observed = relevant_opponent_actions.size
            if total_other_actions_observed > 0:
                average_opponent_cooperation_rate = total_other_cooperations_observed / total_other_actions_observed
        my_consumption_if_D = current_stock / n_players
        num_opponents = n_players - 1
        expected_other_cooperators = num_opponents * average_opponent_cooperation_rate
        expected_other_defectors = num_opponents - expected_other_cooperators
        expected_consumption_by_others = expected_other_cooperators * (current_stock / (2.0 * n_players)) + expected_other_defectors * (current_stock / (1.0 * n_players))
        total_expected_consumption_if_I_D = my_consumption_if_D + expected_consumption_by_others
        s_remaining_if_I_D = current_stock - total_expected_consumption_if_I_D
        s_remaining_if_I_D = max(0.0, s_remaining_if_I_D)
        growth_if_I_D = 2.0 * s_remaining_if_I_D * (1.0 - s_remaining_if_I_D / capacity)
        projected_next_stock_if_I_D = min(s_remaining_if_I_D + growth_if_I_D, capacity)
        critical_stock_threshold = capacity * self.STOCK_CRITICAL_LEVEL_FRACTION
        if projected_next_stock_if_I_D < critical_stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_242(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its own total payoff by
    exploiting cooperative behavior from opponents and aggressively extracting
    resources, while possessing a self-preservation mechanism to prevent complete
    resource collapse. It adapts to current stock levels and observed opponent
    cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_critical_ratio = 0.4
        self.C_threshold_for_exploitation = 0.6
        self.Endgame_Rounds = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        S_critical = capacity * self.S_critical_ratio
        if current_round_0_indexed >= r - self.Endgame_Rounds:
            return Action.D
        elif current_stock < S_critical:
            return Action.C
        elif current_round_0_indexed == 0:
            return Action.D
        else:
            previous_round_opponent_actions = history.opponent_actions[-1, :]
            C_count_others = np.sum(previous_round_opponent_actions)
            C_rate_others = C_count_others / (n - 1)
            if C_rate_others >= self.C_threshold_for_exploitation:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_243(BaseStrategy):
    """
    An exploitative strategy, "Opportunistic Parasite", that prioritizes immediate personal gain.
    It defects aggressively, only cooperating temporarily if its defection would immediately
    crash the resource *and* if enough other players are cooperating to make its sacrifice worthwhile
    for future exploitation. It always defects in the last round and starts by defecting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        num_cooperated_others = np.sum(previous_round_opponent_actions)
        num_defected_others = self.n_players - 1 - num_cooperated_others
        cooperation_rate_others = num_cooperated_others / (self.n_players - 1)
        my_consumption_if_I_D = current_stock / self.n_players
        others_consumption_if_I_D = num_defected_others * (current_stock / self.n_players) + num_cooperated_others * (current_stock / (2 * self.n_players))
        total_projected_consumption_if_I_D = my_consumption_if_I_D + others_consumption_if_I_D
        projected_stock_after_consumption_if_I_D = current_stock - total_projected_consumption_if_I_D
        if current_stock < self.n_players:
            return Action.D
        if projected_stock_after_consumption_if_I_D <= 0:
            if cooperation_rate_others >= 0.5:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_244(BaseStrategy):
    """
    The Reciprocal Exploiter strategy aims to maximize total payoff by generally defecting,
    but strategically cooperates to prevent resource collapse or to foster an environment
    of cooperation from others that it can subsequently exploit. It avoids being a "sucker"
    by retaliating against widespread defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_CRITICAL_THRESHOLD = self.capacity / (self.n_players + 1)
        self.S_ABUNDANCE_THRESHOLD = self.capacity * 0.9

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.C
        if current_stock < self.S_CRITICAL_THRESHOLD:
            return Action.C
        if current_stock > self.S_ABUNDANCE_THRESHOLD:
            return Action.D
        else:
            actions_others_prev_round = history.opponent_actions[current_round_0_indexed - 1, :]
            num_defectors_prev_round = (actions_others_prev_round == False).sum()
            num_other_players = self.n_players - 1
            threshold_forgive = math.floor(num_other_players / 2)
            if num_defectors_prev_round == 0:
                return Action.D
            elif num_defectors_prev_round <= threshold_forgive:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_245(BaseStrategy):
    """
    Adaptive Exploiter strategy for the Common Pool Resource game.
    Defaults to Defect (D) to maximize immediate payoff, but cooperates (C)
    as a strategic investment if defection would cause a severe depletion
    of the common stock, significantly reducing its own total future payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.history_window = 3
        self.collapse_risk_threshold_stock = 0.1 * self.capacity
        self.future_payoff_valuation_factor = 1.0 / self.n

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = float(state.current_stock)
        if current_round_1_indexed == self.r:
            return Action.D
        num_rounds_for_avg = 0
        total_C_from_opponents = 0.0
        if history is not None:
            start_index = max(0, state.round_number - self.history_window)
            recent_opponent_actions = history.opponent_actions[start_index:state.round_number]
            if recent_opponent_actions.shape[0] > 0:
                total_C_from_opponents = np.sum(np.sum(recent_opponent_actions, axis=1))
                num_rounds_for_avg = recent_opponent_actions.shape[0]
            if num_rounds_for_avg > 0:
                avg_opponent_C = total_C_from_opponents / num_rounds_for_avg
            else:
                avg_opponent_C = (self.n - 1) / 2.0
        else:
            avg_opponent_C = (self.n - 1) / 2.0
        avg_opponent_D = self.n - 1 - avg_opponent_C
        denominator_cooperate = 2.0 * self.n
        denominator_defect = float(self.n)
        my_consumption_C = current_stock / denominator_cooperate
        predicted_total_consumption_C = my_consumption_C + avg_opponent_C * (current_stock / denominator_cooperate) + avg_opponent_D * (current_stock / denominator_defect)
        stock_after_consumption_C = max(0.0, current_stock - predicted_total_consumption_C)
        if self.capacity == 0:
            growth_C = 0.0
        else:
            growth_C = 2.0 * stock_after_consumption_C * (1.0 - stock_after_consumption_C / self.capacity)
        predicted_next_stock_C = min(stock_after_consumption_C + growth_C, self.capacity)
        my_current_payoff_C = current_stock / denominator_cooperate
        my_consumption_D = current_stock / denominator_defect
        predicted_total_consumption_D = my_consumption_D + avg_opponent_C * (current_stock / denominator_cooperate) + avg_opponent_D * (current_stock / denominator_defect)
        stock_after_consumption_D = max(0.0, current_stock - predicted_total_consumption_D)
        if self.capacity == 0:
            growth_D = 0.0
        else:
            growth_D = 2.0 * stock_after_consumption_D * (1.0 - stock_after_consumption_D / self.capacity)
        predicted_next_stock_D = min(stock_after_consumption_D + growth_D, self.capacity)
        my_current_payoff_D = current_stock / denominator_defect
        net_gain_D_over_C_current = my_current_payoff_D - my_current_payoff_C
        remaining_rounds_for_future = self.r - current_round_1_indexed - 1
        potential_future_value_difference = 0.0
        if remaining_rounds_for_future > 0:
            potential_future_value_difference = (predicted_next_stock_C - predicted_next_stock_D) * remaining_rounds_for_future * self.future_payoff_valuation_factor
        if predicted_next_stock_D <= self.collapse_risk_threshold_stock and predicted_next_stock_C > self.collapse_risk_threshold_stock and (potential_future_value_difference > net_gain_D_over_C_current):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_246(BaseStrategy):
    """
    Adaptive Exploiter with Collapse Avoidance:
    This strategy defaults to aggressive defection to maximize immediate payoff.
    It only cooperates in a specific, self-preservation scenario: when the
    resource is critically low AND other players are demonstrably trying to save it.
    This allows for future exploitation by preventing total collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_STOCK_FACTOR = 0.1
        self.COOPERATIVE_OPPONENTS_THRESHOLD_RATIO = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        num_defectors_last_round = sum((1 for action_bool in history.opponent_actions[-1, :] if not action_bool))
        max_cooperative_defectors = math.floor((self.n_players - 1) * self.COOPERATIVE_OPPONENTS_THRESHOLD_RATIO)
        is_stock_critical = False
        if self.capacity > 0:
            is_stock_critical = current_stock < self.capacity * self.CRITICAL_STOCK_FACTOR
        if is_stock_critical:
            if num_defectors_last_round <= max_cooperative_defectors:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_247(BaseStrategy):
    """
    The "Adaptive Opportunist" strategy.
    It aims to maximize its own total payoff over the entire game by strategically balancing
    immediate exploitation with long-term resource preservation and avoiding being exploited by others.
    It operates on the principle of "exploit when safe, preserve when necessary, and retaliate when exploited."
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / 4.0
        self.OPPONENT_DEFECTION_PROPORTION_THRESHOLD = 0.3
        self.CONSIDER_LAST_N_ROUNDS_FOR_OPPONENT_ANALYSIS = 2
        self.MIN_COOPERATORS_TO_EXPLOIT = math.ceil((self.n_players - 1) * 0.5)
        self.other_defectors_history_recent = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        num_other_defectors_last_round = np.sum(~history.opponent_actions[current_round_0_indexed - 1, :])
        self.other_defectors_history_recent.append(num_other_defectors_last_round)
        if len(self.other_defectors_history_recent) > self.CONSIDER_LAST_N_ROUNDS_FOR_OPPONENT_ANALYSIS:
            self.other_defectors_history_recent.pop(0)
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        has_significant_recent_defection = False
        for num_defectors in self.other_defectors_history_recent:
            if num_defectors / (self.n_players - 1) > self.OPPONENT_DEFECTION_PROPORTION_THRESHOLD:
                has_significant_recent_defection = True
                break
        if has_significant_recent_defection:
            return Action.D
        else:
            num_other_defectors_in_prev_round = self.other_defectors_history_recent[-1]
            num_other_cooperators_last_round = self.n_players - 1 - num_other_defectors_in_prev_round
            if num_other_cooperators_last_round >= self.MIN_COOPERATORS_TO_EXPLOIT:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_248(BaseStrategy):
    """
    The Exploitative Predator strategy is designed to maximize its own total payoff over the game,
    adapting its behavior based on the current resource state and the observed actions of other players.
    It operates on the principle of taking as much as possible, but preserving the resource just enough
    to ensure continued high payoffs for itself. It is greedy but not self-destructive.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.ENDGAME_ROUNDS: int = 2
        self.CRITICAL_STOCK_THRESHOLD_RATIO: float = 1.0 / self.game_description.n_players
        self.HIGH_STOCK_DEFECTION_THRESHOLD_RATIO: float = 0.6
        self.OBSERVED_DEFECTION_RATE_TRIGGER: float = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        stock = state.current_stock
        capacity = self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        if stock <= 0.0:
            return Action.C
        if current_round_1_indexed >= total_rounds - self.ENDGAME_ROUNDS + 1:
            return Action.D
        if stock <= capacity * self.CRITICAL_STOCK_THRESHOLD_RATIO:
            return Action.C
        total_other_actions_observed = 0
        total_other_defections_observed = 0
        observed_defection_rate = 0.0
        if history is not None and history.opponent_actions.size > 0:
            total_other_actions_observed = history.opponent_actions.size
            total_other_defections_observed = np.sum(history.opponent_actions == False)
            observed_defection_rate = total_other_defections_observed / total_other_actions_observed
        if current_round_1_indexed == 1 or observed_defection_rate < self.OBSERVED_DEFECTION_RATE_TRIGGER:
            return Action.D
        elif stock > capacity * self.HIGH_STOCK_DEFECTION_THRESHOLD_RATIO:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_249(BaseStrategy):
    """
    Aggressive Opportunist with Crash Avoidance strategy for the Common Pool Resource Game.
    This strategy prioritizes immediate personal gain through defection but strategically
    cooperates when defection would directly trigger or guarantee a critical resource
    depletion, aiming to prevent a total collapse that would eliminate future payoffs.
    It adapts to observed opponent behavior and the current state of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = float(self.game_description.capacity)
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        current_round_1_indexed = current_round_0_indexed + 1
        if current_round_1_indexed == n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        else:
            k_C = np.sum(history.opponent_actions[-1, :])
            k_D = n_players - 1 - k_C
            my_D_consumption = current_stock / n_players
            others_consumption_D = k_D * (current_stock / n_players)
            others_consumption_C = k_C * (current_stock / (2 * n_players))
            total_consumption_if_I_D = my_D_consumption + others_consumption_D + others_consumption_C
            S_after_consumption_if_I_D = max(0.0, current_stock - total_consumption_if_I_D)
            growth_if_I_D = 2 * S_after_consumption_if_I_D * (1 - S_after_consumption_if_I_D / capacity)
            projected_next_stock_if_I_D = min(S_after_consumption_if_I_D + growth_if_I_D, capacity)
            CRITICAL_STOCK_THRESHOLD = capacity / (2 * n_players)
            if projected_next_stock_if_I_D <= CRITICAL_STOCK_THRESHOLD:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_250(BaseStrategy):
    """
    The "Adaptive Predator" strategy is designed for aggressive self-maximization,
    prioritizing immediate payoffs while maintaining a crucial self-preservation
    mechanism to prevent total resource collapse that would eliminate future payoffs.
    It is adaptive to observed opponent behavior and robust across various game parameters.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD = self.game_description.capacity / (self.game_description.n_players * 2)
        self.MIN_OTHERS_COOPERATING_FOR_RESPONSE = (self.game_description.n_players - 1) / 2
        self.LAST_QUARTER_THRESHOLD_ROUND_NUMBER = self.game_description.n_rounds - self.game_description.n_rounds // 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_round = state.round_number
        current_stock = state.current_stock
        n_cooperators_others_prev_round = 0
        n_defectors_others_prev_round = 0
        if current_round > 0:
            opponent_actions_prev_round = history.opponent_actions[current_round - 1, :]
            n_cooperators_others_prev_round = np.sum(opponent_actions_prev_round)
            n_defectors_others_prev_round = n_players - 1 - n_cooperators_others_prev_round
        if current_round == 0:
            return Action.D
        if current_round >= n_rounds - 2:
            return Action.D
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            if current_round < self.LAST_QUARTER_THRESHOLD_ROUND_NUMBER and n_cooperators_others_prev_round >= self.MIN_OTHERS_COOPERATING_FOR_RESPONSE:
                return Action.C
            else:
                return Action.D
        elif n_cooperators_others_prev_round >= self.MIN_OTHERS_COOPERATING_FOR_RESPONSE:
            return Action.D
        elif n_defectors_others_prev_round >= self.MIN_OTHERS_COOPERATING_FOR_RESPONSE:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_251(BaseStrategy):
    """
    The Opportunistic Harvester strategy maximizes personal total payoff over the game by
    prioritizing immediate gains (Defect) while strategically cooperating only when the
    common stock is critically endangered. It adapts to opponent's defection levels,
    acts aggressively in the first and last rounds, and otherwise defaults to exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold = self.game_description.capacity / (2 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        prev_defector_count = 0
        if history is not None:
            num_opponent_cooperators_prev_round = np.sum(history.opponent_actions[-1, :])
            prev_defector_count = n_players - 1 - num_opponent_cooperators_prev_round
        if current_round_1_indexed == n_rounds:
            return Action.D
        if current_stock < self.critical_stock_threshold:
            return Action.C
        if current_round_1_indexed == 1:
            return Action.D
        if prev_defector_count > (n_players - 1) / 2:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_252(BaseStrategy):
    """
    The "Calculated Opportunist" strategy aims to maximize its own total payoff over the game by prioritizing immediate gains (defecting) whenever possible, but adapting to conserve the common pool resource only when its own long-term profitability is threatened. It operates under the assumption that other players are independent and may also be self-interested, meaning it cannot rely on their altruism or coordinated cooperation.

    This strategy is adaptive because it adjusts its behavior based on the current stock level and the observed actions of other players in the immediately preceding round. It is robust because it defines clear thresholds and decision rules that work regardless of the specific mix of opponent strategies, shifting from aggressive exploitation to self-preserving conservation as conditions warrant.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD = 0.1 * game_description.capacity
        self.DANGER_ZONE_THRESHOLD = 0.5 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        if current_round_1_indexed == total_rounds:
            return Action.D
        P_C_others = 0.5
        if state.round_number > 0:
            cooperating_others_count = np.sum(history.opponent_actions[state.round_number - 1, :])
            total_others = n_players - 1
            P_C_others = cooperating_others_count / total_others
        if current_stock <= self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        elif current_stock <= self.DANGER_ZONE_THRESHOLD:
            if P_C_others < 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_253(BaseStrategy):
    """
    The Adaptive Predator strategy aims to exploit cooperative opponents by defecting, while also being
    prepared to defect against aggressive opponents to avoid being a "sucker." It strategically cooperates
    only when the common pool resource is severely threatened and there's a reasonable chance that
    cooperation can lead to future personal gain (i.e., sufficient remaining rounds for recovery).
    In short rounds or hopeless situations, it defaults to aggressive defection to grab what's left.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.exploit_threshold_cp = 0.75
        self.collapse_threshold_rhi = 0.25
        self.min_salvage_rounds = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        strategy_round = current_round_number + 1
        if strategy_round == self.n_rounds:
            return Action.D
        if strategy_round == 1:
            return Action.D
        k_D_prev_opponents = np.sum(~history.opponent_actions[-1, :])
        cp = 1.0
        if self.n_players > 1:
            cp = 1.0 - k_D_prev_opponents / (self.n_players - 1.0)
        rhi = current_stock / self.capacity
        if rhi < self.collapse_threshold_rhi:
            if self.n_rounds - strategy_round < self.min_salvage_rounds:
                return Action.D
            elif k_D_prev_opponents == self.n_players - 1:
                return Action.D
            else:
                return Action.C
        elif cp >= self.exploit_threshold_cp:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_254(BaseStrategy):
    """
    The Adaptive Exploiter strategy is designed to maximize its own total payoff over 'r' rounds by primarily defecting,
    but strategically cooperating under specific conditions to ensure the resource remains viable for future exploitation.
    It adapts to the common stock level and the observed actions of other players.

    Core Philosophy: Self-maximization, balancing immediate exploitation with resource sustainability for future gains.
    It cooperates only when the stock is low and a majority of opponents are also cooperating,
    acting as a calculated investment. Otherwise, it defects to maximize immediate payoff,
    especially in the last round, when the stock is healthy, or when recovery efforts are deemed futile.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_panic_level_ratio = 0.05
        self.stock_recovery_level_ratio = 0.25
        self.cooperation_majority_threshold = math.ceil((self.game_description.n_players - 1) / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        capacity = float(self.game_description.capacity)
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == n_rounds - 1:
            return Action.D
        if current_stock <= 0:
            return Action.D
        k_C_prev = 0
        if current_round_0_indexed > 0:
            k_C_prev = np.sum(history.opponent_actions[-1, :])
        if current_stock < capacity * self.stock_panic_level_ratio:
            return Action.D
        elif current_stock < capacity * self.stock_recovery_level_ratio:
            if k_C_prev >= self.cooperation_majority_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_255(BaseStrategy):
    """
    Adaptive Predator strategy for the Common Pool Resource game.
    This strategy prioritizes maximizing its own total payoff by aggressively
    defecting whenever possible. It strategically cooperates only to prevent
    the complete collapse of the common resource or to allow it to rebuild
    for future exploitation when other players show restraint. It adapts
    its behavior based on the resource's health and the observed defection
    levels of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Predator strategy with game parameters.
        """
        self.game_description = game_description
        self.S_CRITICAL_RATIO: float = 0.1
        self.S_REBUILD_RATIO: float = 0.4
        self.D_AGGRESSIVE_THRESHOLD: float = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the strategy's action (Cooperate 'C' or Defect 'D') for the current round.
        """
        n_players: int = self.game_description.n_players
        n_rounds: int = self.game_description.n_rounds
        capacity: float = self.game_description.capacity
        current_stock: float = state.current_stock
        current_round: int = state.round_number
        if current_round == n_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        opponent_defect_count_prev = np.sum(~history.opponent_actions[-1, :])
        my_defect_count_prev = 1 if not history.my_actions[-1] else 0
        D_count_prev = opponent_defect_count_prev + my_defect_count_prev
        D_ratio_prev = D_count_prev / n_players
        if current_stock <= capacity * self.S_CRITICAL_RATIO:
            return Action.C
        elif current_stock <= capacity * self.S_REBUILD_RATIO:
            if D_ratio_prev >= self.D_AGGRESSIVE_THRESHOLD:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_256(BaseStrategy):
    """
    Adaptive Stock Threshold Exploiter (ASTE) strategy.
    This strategy aims to maximize the player's own total payoff by defaulting to exploitative
    behavior (Defect) while incorporating a calculated self-preservation mechanism.
    This mechanism only triggers cooperation when the resource is critically low AND there's
    sufficient evidence that other players are willing to help restore it, thereby securing
    future payoffs for the exploitative player.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD_RATIO: float = 0.25
        self.COOPERATION_THRESHOLD_FOR_SELF_PRESERVATION: float = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        num_players = self.game_description.n_players
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        critical_stock = capacity * self.CRITICAL_STOCK_THRESHOLD_RATIO
        if current_stock < critical_stock:
            if current_round_0_indexed == 0:
                return Action.D
            k_C_prev = sum(history.opponent_actions[current_round_0_indexed - 1, :])
            num_other_players = num_players - 1
            others_cooperation_rate = k_C_prev / num_other_players
            if others_cooperation_rate >= self.COOPERATION_THRESHOLD_FOR_SELF_PRESERVATION:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_257(BaseStrategy):
    """
    The Greedy Opportunist strategy aims to maximize its own total payoff in the Common Pool Resource game.
    It balances immediate exploitation (defecting) with strategic self-preservation (cooperating) to ensure
    the resource persists for future exploitation. It incorporates end-game greed and adaptive responses
    to the resource state and observed player behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_critical_threshold = 0.2 * self.game_description.capacity
        self.last_round_approaching_threshold = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        if current_round_1_indexed >= total_rounds - self.last_round_approaching_threshold + 1:
            return Action.D
        elif state.current_stock < self.S_critical_threshold:
            return Action.C
        elif current_round_1_indexed == 1:
            return Action.C
        else:
            num_other_cooperators = np.sum(history.opponent_actions[-1, :])
            proportion_others_cooperated = num_other_cooperators / (self.game_description.n_players - 1)
            return Action.D

class Strategy_EXPLOITATIVE_258(BaseStrategy):
    """
    The Adaptive Exploiter (AE) strategy prioritizes immediate gain (defecting)
    unless resource scarcity or overwhelming opponent defection threatens future payoffs.
    It always exploits in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_stock < self.capacity / 2.0:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.D
        else:
            previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
            N_D_others = np.sum(previous_round_opponent_actions == False)
            if N_D_others < (self.n_players - 1) / 2.0:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_259(BaseStrategy):
    """
    The "Opportunistic Defector" strategy aims to maximize individual payoff by primarily defecting.
    It includes an end-game and early-game defection phase, and an intermediate phase that adapts
    by defecting unless its defection is projected to cause total resource collapse from an already
    critically low stock. In such a critical scenario, it cooperates as a self-preservation mechanism
    to allow for a chance of future payoffs.
    """
    CRITICAL_STOCK_THRESHOLD_RATIO: float = 0.1

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        num_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = float(self.game_description.capacity)
        if state.round_number == total_rounds - 1 or state.round_number == total_rounds - 2:
            return Action.D
        if state.round_number == 0:
            return Action.D
        num_cooperators_among_opponents_prev_round = int(np.sum(history.opponent_actions[-1, :]))
        num_defectors_among_opponents_prev_round = num_players - 1 - num_cooperators_among_opponents_prev_round
        my_consumption_if_I_D = current_stock / num_players
        opponents_total_consumption = num_cooperators_among_opponents_prev_round * (current_stock / (2 * num_players)) + num_defectors_among_opponents_prev_round * (current_stock / num_players)
        total_consumption_this_round_if_I_D = my_consumption_if_I_D + opponents_total_consumption
        projected_stock_after_consumption = current_stock - total_consumption_this_round_if_I_D
        s_remaining_for_growth = max(0.0, projected_stock_after_consumption)
        growth_this_round_if_I_D = 2 * s_remaining_for_growth * (1 - s_remaining_for_growth / capacity)
        projected_new_stock_after_growth_if_I_D = min(s_remaining_for_growth + growth_this_round_if_I_D, capacity)
        is_stock_critically_low = current_stock < self.CRITICAL_STOCK_THRESHOLD_RATIO * capacity
        if projected_new_stock_after_growth_if_I_D <= 0 and is_stock_critically_low:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_260(BaseStrategy):
    """
    The "Adaptive Predator" strategy for the Common Pool Resource Game.
    This strategy is designed to be highly exploitative, maximizing individual payoff
    while being adaptive to opponent behavior and robustly preventing the common resource
    from collapsing entirely. It defaults to defection, only cooperating under
    strict conditions: when the stock is dangerously low for self-preservation,
    or adaptively matching opponent defection to avoid being a "sucker".
    It actively exploits prevailing cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = self.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock_S = state.current_stock
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_stock_S < self.critical_stock_threshold:
            return Action.C
        if state.round_number > 0:
            opponent_actions_last_round = history.opponent_actions[-1]
            num_cooperators_last_round = np.sum(opponent_actions_last_round)
            num_defectors_last_round = self.n_players - 1 - num_cooperators_last_round
            if num_cooperators_last_round > (self.n_players - 1) / 2.0:
                return Action.D
            if num_defectors_last_round >= (self.n_players - 1) / 2.0:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_261(BaseStrategy):
    """
    Strategic Sustained Exploitation is an exploitative, adaptive, and robust strategy for a Common Pool Resource game.
    It aims to maximize its own total payoff by defecting as much as possible, consistent with maintaining
    the common pool resource above zero to ensure future payoffs. It free-rides on cooperative efforts
    but will self-correct (cooperate) if its defection, combined with anticipated actions of others,
    is predicted to lead to immediate resource collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        if current_stock <= 0.0001:
            return Action.C
        if current_round_0_indexed == r - 1:
            return Action.D
        estimated_defection_rate = 0.6
        if current_round_0_indexed > 0 and history is not None:
            total_opponent_actions_observed = history.opponent_actions.size
            total_opponent_defections_observed = np.sum(~history.opponent_actions)
            estimated_defection_rate = total_opponent_defections_observed / total_opponent_actions_observed
        num_opponents = n - 1
        predicted_num_opponent_defectors = estimated_defection_rate * num_opponents
        predicted_num_opponent_cooperators = (1 - estimated_defection_rate) * num_opponents
        predicted_my_consumption_if_D = current_stock / n
        predicted_other_defector_consumption = predicted_num_opponent_defectors * (current_stock / n)
        predicted_other_cooperator_consumption = predicted_num_opponent_cooperators * (current_stock / (2 * n))
        predicted_total_consumption_if_I_D = predicted_my_consumption_if_D + predicted_other_defector_consumption + predicted_other_cooperator_consumption
        predicted_stock_after_my_D = current_stock - predicted_total_consumption_if_I_D
        if predicted_stock_after_my_D <= 0.0001:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_262(BaseStrategy):
    """
    The 'Adaptive Predator' strategy aims to maximize its own payoff by generally defecting
    (exploiting the common resource), but with a critical adaptive mechanism. It will
    strategically cooperate to prevent the resource from collapsing if its own defection
    would foreseeably lead to the stock falling below a critical threshold, thereby
    protecting its future exploitation potential. This strategy adapts to the current
    resource stock level and assumes opponents will repeat their actions from the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_critical_threshold = self.capacity / (2 * self.n)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.r:
            return Action.D
        if current_stock < self.stock_critical_threshold:
            return Action.C
        if current_round_1_indexed == 1:
            return Action.D
        last_round_idx = state.round_number - 1
        cooperators_among_others_last_round = np.sum(history.opponent_actions[last_round_idx, :])
        defectors_among_others_last_round = self.n - 1 - cooperators_among_others_last_round
        predicted_total_D_if_I_D = defectors_among_others_last_round + 1
        predicted_total_C_if_I_D = cooperators_among_others_last_round
        consumption_if_I_D = predicted_total_D_if_I_D * (current_stock / self.n) + predicted_total_C_if_I_D * (current_stock / (2 * self.n))
        S_remaining_if_I_D = current_stock - consumption_if_I_D
        predicted_total_D_if_I_C = defectors_among_others_last_round
        predicted_total_C_if_I_C = cooperators_among_others_last_round + 1
        consumption_if_I_C = predicted_total_D_if_I_C * (current_stock / self.n) + predicted_total_C_if_I_C * (current_stock / (2 * self.n))
        S_remaining_if_I_C = current_stock - consumption_if_I_C
        if S_remaining_if_I_D <= self.stock_critical_threshold:
            if S_remaining_if_I_C > self.stock_critical_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_263(BaseStrategy):
    """
    Adaptive Exploiter with Resource Preservation (AERP) strategy for the Common Pool Resource Game.

    This strategy aims to maximize personal payoff by defaulting to defection (exploitation)
    while incorporating safeguards to prevent premature resource collapse, which would
    limit future exploitation opportunities.

    Decision Rules:
    1.  **Last Round:** Always defects to maximize final-round payoff.
    2.  **Critical Resource Level:** If the stock falls below a predefined critical threshold (2 * N),
        the strategy switches to cooperation to conserve the resource for future rounds. This is a
        long-term exploitative move.
    3.  **First Round:** Defaults to defection to test the environment and exploit potential initial
        cooperation from other players.
    4.  **Adaptive Exploitation (Subsequent Rounds, Non-Critical Stock):**
        a.  If <= 1 other player defected in the previous round, the environment is considered
            cooperative enough for the player to defect and maximize immediate gain.
        b.  If > 1 other player defected, the strategy projects the remaining stock if it were to
            defect again, assuming others repeat their previous actions. If this projected remaining
            stock is dangerously low (<= 0 or < N), the strategy cooperates to prevent collapse.
            Otherwise, it defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.N = game_description.n_players
        self.R = game_description.n_rounds
        self.CAPACITY = game_description.capacity
        self.STOCK_CRITICAL_THRESHOLD = 2 * self.N

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        if current_round_1_indexed == self.R:
            return Action.D
        if current_stock <= self.STOCK_CRITICAL_THRESHOLD:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.D
        prev_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        num_others_cooperated_last_round = np.sum(prev_opponent_actions)
        num_others_defected_last_round = self.N - 1 - num_others_cooperated_last_round
        if num_others_defected_last_round <= 1:
            return Action.D
        else:
            my_consumption_if_D = current_stock / self.N
            others_consumption_if_I_D = num_others_defected_last_round * (current_stock / self.N) + num_others_cooperated_last_round * (current_stock / (2 * self.N))
            projected_total_consumption_if_I_D = my_consumption_if_D + others_consumption_if_I_D
            projected_remaining_stock_if_I_D = current_stock - projected_total_consumption_if_I_D
            if projected_remaining_stock_if_I_D <= 0 or projected_remaining_stock_if_I_D < self.N:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_264(BaseStrategy):
    """
    The Relentless Extractor strategy is designed to aggressively pursue individual gain by defecting,
    but with critical overrides to prevent total resource collapse and to strategically probe
    opponent behavior. It aims to maximize immediate extraction while ensuring the resource
    (and thus future payoffs) is not completely depleted.

    Core Philosophy:
    Maximize individual extraction by defecting, unless explicitly necessary to ensure the
    survival of the resource or to strategically test the environment.

    Decision Hierarchy:
    1.  Last Round Exploitation: Defect in the final round to maximize final payoff.
    2.  Initial Round Probing: Cooperate in the first round to observe behavior and potentially
        foster initial cooperation, leading to a richer resource pool for later exploitation.
    3.  Stock Emergency / Resource Preservation: Cooperate if the stock falls below a critical
        threshold (SCT) to allow the resource to recover, preventing total collapse.
    4.  Default Exploitation: In all other scenarios (intermediate rounds, healthy stock), defect
        to maximize immediate personal gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.SCT = self.game_description.capacity / (2 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_idx = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round_idx == total_rounds - 1:
            return Action.D
        elif current_round_idx == 0:
            return Action.C
        elif current_stock < self.SCT:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_265(BaseStrategy):
    """
    Adaptive Exploit-and-Restore (AER) strategy for the Common Pool Resource game.

    AER aims to maximize its own total payoff by primarily defecting, but intelligently
    switches to cooperation to prevent resource collapse or to avoid being exploited by others.
    It leverages game history and current state to adapt its behavior.
    """

    class Mode(Enum):
        """Internal enumeration for the strategy's current mode."""
        EXPLOIT = 1
        RECOVER = 2

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the AER strategy with game parameters and internal state.

        Args:
            game_description: A CommonPoolDescription object containing game parameters.
        """
        self.game_description = game_description
        self.mode: self.Mode = self.Mode.EXPLOIT
        self.N: int = game_description.n_players
        self.R: int = game_description.n_rounds
        self.CAPACITY: float = float(game_description.capacity)
        self.STOCK_CRITICAL_THRESHOLD: float = self.CAPACITY / 4.0
        self.STOCK_HEALTHY_THRESHOLD: float = self.CAPACITY * 0.75
        num_other_players: int = self.N - 1
        self.DEFECTION_IMPACT_THRESHOLD: int = math.ceil(num_other_players * 0.4)
        self.AGGRESSIVE_DEFECTION_THRESHOLD: int = math.ceil(num_other_players * 0.6)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action for the current round based on strategy rules.

        Args:
            state: A CommonPoolState object containing current round number and stock.
            history: A PlayerHistory object containing past actions and payoffs, or None for round 0.

        Returns:
            An Action (C for Cooperate, D for Defect).
        """
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.R - 1:
            return Action.D
        if current_round_0_indexed == 0:
            self.mode = self.Mode.EXPLOIT
            return Action.D
        num_other_cooperators_last_round = sum(history.opponent_actions[-1, :])
        num_other_defectors_last_round = self.N - 1 - num_other_cooperators_last_round
        if self.mode == self.Mode.EXPLOIT:
            if current_stock < self.STOCK_CRITICAL_THRESHOLD or num_other_defectors_last_round >= self.DEFECTION_IMPACT_THRESHOLD:
                self.mode = self.Mode.RECOVER
        elif self.mode == self.Mode.RECOVER:
            if num_other_defectors_last_round >= self.AGGRESSIVE_DEFECTION_THRESHOLD:
                self.mode = self.Mode.EXPLOIT
            elif current_stock >= self.STOCK_HEALTHY_THRESHOLD and num_other_defectors_last_round < self.DEFECTION_IMPACT_THRESHOLD:
                self.mode = self.Mode.EXPLOIT
        if self.mode == self.Mode.EXPLOIT:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_266(BaseStrategy):
    """
    The Adaptive Predator strategy aims for maximal self-interest while strategically
    cooperating when necessary to prevent resource collapse and ensure future exploitation.
    It defaults to defection, but will cooperate to revive a critically low resource if
    enough others are also cooperating, and will temporarily cooperate to stabilize a
    declining resource when others are also contributing. In endgame scenarios, it always defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._stock_at_start_of_last_processed_round: float = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = float(self.game_description.capacity)
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        current_stock = state.current_stock
        STOCK_DANGER_THRESHOLD = capacity / 4.0
        STOCK_RECOVERY_THRESHOLD = capacity / 2.0
        MIN_COOPERATORS_FOR_ACTION = n // 2
        ENDGAME_PHASE_START_ROUND = r - r // 4
        num_other_cooperators_last_round = 0
        previous_stock_for_comparison = current_stock
        if current_round_0_indexed > 0:
            last_round_opponent_actions = history.opponent_actions[-1, :]
            num_other_cooperators_last_round = np.sum(last_round_opponent_actions)
            previous_stock_for_comparison = self._stock_at_start_of_last_processed_round
        if current_round_1_indexed == r:
            self._stock_at_start_of_last_processed_round = current_stock
            return Action.D
        if current_round_1_indexed == 1:
            self._stock_at_start_of_last_processed_round = current_stock
            return Action.D
        if current_stock < STOCK_DANGER_THRESHOLD:
            if current_round_1_indexed >= ENDGAME_PHASE_START_ROUND:
                self._stock_at_start_of_last_processed_round = current_stock
                return Action.D
            if num_other_cooperators_last_round >= MIN_COOPERATORS_FOR_ACTION:
                self._stock_at_start_of_last_processed_round = current_stock
                return Action.C
            else:
                self._stock_at_start_of_last_processed_round = current_stock
                return Action.D
        if current_stock < STOCK_RECOVERY_THRESHOLD:
            if num_other_cooperators_last_round >= MIN_COOPERATORS_FOR_ACTION:
                if current_stock < previous_stock_for_comparison:
                    self._stock_at_start_of_last_processed_round = current_stock
                    return Action.C
        self._stock_at_start_of_last_processed_round = current_stock
        return Action.D

class Strategy_EXPLOITATIVE_267(BaseStrategy):
    """
    Adaptive Predator strategy for the Common Pool Resource Game.
    Prioritizes immediate gain through defection, but with calculated pragmatism
    to ensure the resource remains viable for sustained exploitation.
    It free-rides on cooperators, mirrors widespread defection, and only cooperates
    as a self-interested measure to preserve or recover the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_CRITICAL_LOW_RATIO = 0.25
        self.S_UNHEALTHY_RATIO = 0.75
        self.P_DEFECTION_HIGH_TH = 0.6
        self.P_DEFECTION_LOW_TH = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number >= self.n_rounds - 2:
            return Action.D
        if current_round_number == 0:
            return Action.D
        num_opponents_defected_prev = np.sum(~history.opponent_actions[-1, :])
        proportion_opponents_defected_prev = num_opponents_defected_prev / (self.n_players - 1)
        if current_stock < self.capacity * self.S_CRITICAL_LOW_RATIO:
            if proportion_opponents_defected_prev >= self.P_DEFECTION_HIGH_TH:
                return Action.D
            else:
                return Action.C
        if current_stock < self.capacity * self.S_UNHEALTHY_RATIO:
            if proportion_opponents_defected_prev <= self.P_DEFECTION_LOW_TH:
                return Action.C
        if proportion_opponents_defected_prev >= self.P_DEFECTION_HIGH_TH:
            return Action.D
        if proportion_opponents_defected_prev <= self.P_DEFECTION_LOW_TH:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_268(BaseStrategy):
    """
    Opportunistic Predator strategy: Maximize individual payoff by defecting whenever possible,
    only cooperating when necessary to prevent resource collapse or to strategically stabilize
    the resource for future exploitation. It assumes other players will also act in their self-interest.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.previous_stock_level = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        s_threshold_collapse = self.capacity / (2.0 * self.n_players)
        if current_round_number == 0:
            self.previous_stock_level = current_stock
            return Action.D
        if current_round_number == self.n_rounds - 1:
            return Action.D
        previous_stock = self.previous_stock_level
        num_others = self.n_players - 1
        num_C_others_prev = np.sum(history.opponent_actions[-1, :])
        num_D_others_prev = num_others - num_C_others_prev
        if current_stock < s_threshold_collapse:
            self.previous_stock_level = current_stock
            return Action.C
        elif current_stock >= previous_stock:
            self.previous_stock_level = current_stock
            return Action.D
        else:
            if num_others == 0:
                self.previous_stock_level = current_stock
                return Action.D
            percentage_defectors_others = num_D_others_prev / num_others
            if percentage_defectors_others > 0.5:
                self.previous_stock_level = current_stock
                return Action.D
            else:
                self.previous_stock_level = current_stock
                return Action.C

class Strategy_EXPLOITATIVE_269(BaseStrategy):
    """
    Adaptive Predator (AP) strategy for the Common Pool Resource Game.
    It defects by default to maximize immediate payoff but can switch to cooperation
    if its defection is predicted to drive the common resource below a critical
    threshold AND its cooperation alone can avert that collapse.
    It adapts its behavior by predicting opponent actions based on historical data.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_critical_ratio = 0.2
        self.all_rounds_opponent_actions = []
        self.my_actions_history = []

    def _calculate_next_stock(self, initial_stock: float, my_hypothetical_action: Action, predicted_num_C_opp: int, predicted_num_D_opp: int) -> float:
        """
        Helper function to calculate the projected next stock level given a hypothetical
        action for self and predicted opponent actions.
        """
        current_stock_for_consumption = max(0.0, initial_stock)
        if my_hypothetical_action == Action.D:
            my_consumption = current_stock_for_consumption / self.n
        else:
            my_consumption = current_stock_for_consumption / (2 * self.n)
        others_consumption = predicted_num_C_opp * current_stock_for_consumption / (2 * self.n) + predicted_num_D_opp * current_stock_for_consumption / self.n
        total_consumption = my_consumption + others_consumption
        S_after_consumption = max(0.0, current_stock_for_consumption - total_consumption)
        if self.capacity == 0:
            growth = 0.0
        else:
            growth = 2.0 * S_after_consumption * (1.0 - S_after_consumption / self.capacity)
        next_stock = min(S_after_consumption + growth, self.capacity)
        return next_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        S_critical = self.capacity * self.S_critical_ratio
        if current_round_0_indexed == 0:
            self.my_actions_history.append(Action.D)
            return Action.D
        last_round_opponent_actions_bool = history.opponent_actions[-1, :]
        num_D_last_round_opponents = np.sum(~last_round_opponent_actions_bool)
        num_C_last_round_opponents = np.sum(last_round_opponent_actions_bool)
        self.all_rounds_opponent_actions.append({'D': num_D_last_round_opponents, 'C': num_C_last_round_opponents})
        if current_round_0_indexed == self.r - 1:
            self.my_actions_history.append(Action.D)
            return Action.D
        total_D_opponents_overall = sum((d['D'] for d in self.all_rounds_opponent_actions))
        total_C_opponents_overall = sum((d['C'] for d in self.all_rounds_opponent_actions))
        total_opponent_actions_count = total_D_opponents_overall + total_C_opponents_overall
        if total_opponent_actions_count == 0:
            predicted_num_D_opponents = round((self.n - 1) / 2)
            predicted_num_C_opponents = self.n - 1 - predicted_num_D_opponents
        else:
            opponent_defection_rate = float(total_D_opponents_overall) / total_opponent_actions_count
            predicted_num_D_opponents = round(opponent_defection_rate * (self.n - 1))
            predicted_num_C_opponents = self.n - 1 - predicted_num_D_opponents
        projected_next_S_if_I_D = self._calculate_next_stock(current_stock, Action.D, predicted_num_C_opponents, predicted_num_D_opponents)
        projected_next_S_if_I_C = self._calculate_next_stock(current_stock, Action.C, predicted_num_C_opponents, predicted_num_D_opponents)
        action_to_take = Action.D
        if projected_next_S_if_I_D < S_critical:
            if projected_next_S_if_I_C >= S_critical:
                action_to_take = Action.C
        self.my_actions_history.append(action_to_take)
        return action_to_take

class Strategy_EXPLOITATIVE_270(BaseStrategy):
    """
    The 'Adaptive Predator' strategy aims to maximize its own total payoff by aggressively
    exploiting the common resource when possible, while strategically cooperating to prevent
    resource collapse or to encourage others' cooperation, which can then be free-ridden upon.

    Internal Parameters:
    - LOW_STOCK_THRESHOLD_RATIO: A proportion of capacity. If stock falls below this, it's critically low.
    - PREDATOR_MODE_THRESHOLD_RATIO: A proportion of capacity. If stock is above this, it's abundant.
    - COOPERATION_ASSUMPTION_RATE: Minimum proportion of *other* players who must have cooperated
      in the previous round for this strategy to consider them "cooperative enough" to exploit.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = game_description.n_players
        capacity = game_description.capacity
        self.LOW_STOCK_THRESHOLD_RATIO: float = 1 / (2 * n)
        self.PREDATOR_MODE_THRESHOLD_RATIO: float = 1 / 2
        self.COOPERATION_ASSUMPTION_RATE: float = 0.5
        self.LOW_STOCK_THRESHOLD: float = capacity * self.LOW_STOCK_THRESHOLD_RATIO
        self.PREDATOR_MODE_THRESHOLD: float = capacity * self.PREDATOR_MODE_THRESHOLD_RATIO

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        num_players = self.game_description.n_players
        if current_round == total_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.C
        num_other_players = num_players - 1
        num_others_cooperated_last_round = np.sum(history.opponent_actions[-1, :])
        if num_other_players == 0:
            others_cooperation_rate = 1.0
        else:
            others_cooperation_rate = num_others_cooperated_last_round / num_other_players
        if current_stock <= self.LOW_STOCK_THRESHOLD:
            return Action.C
        elif current_stock >= self.PREDATOR_MODE_THRESHOLD:
            return Action.D
        elif others_cooperation_rate >= self.COOPERATION_ASSUMPTION_RATE:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_271(BaseStrategy):
    """
    The Adaptive Predator strategy is designed to be highly exploitative and adaptive.
    It prioritizes maximizing its immediate payoff by defecting, only resorting to
    cooperation under specific, self-serving conditions to prevent total resource
    collapse or strategically encourage other players to rebuild the common pool
    for future exploitation. It adapts its defection rate based on current stock
    levels and observed opponent cooperation tendencies.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.min_stock_threshold_for_survival = 0.05 * self.capacity
        self.abundant_stock_threshold = self.capacity * 0.75
        self.moderately_healthy_stock_threshold = self.capacity * 0.4
        self.opp_coop_threshold_mod_healthy = 0.4
        self.opp_coop_threshold_low_stock = 0.25

    def _estimate_next_stock(self, initial_S: float, my_action: Action, estimated_opponent_actions: NDArray[np.bool_]) -> float:
        """
        Helper function to project the common stock level at the start of the next round.
        
        Args:
            initial_S (float): The current common pool stock level.
            my_action (Action): My chosen action for the current round (C or D).
            estimated_opponent_actions (NDArray[np.bool_]): A numpy array of booleans
                                                            representing the actions of opponents
                                                            (True for C, False for D).
        Returns:
            float: The projected stock level at the start of the next round.
        """
        n = self.n
        capacity = self.capacity
        my_consumption = initial_S / n if my_action == Action.D else initial_S / (2 * n)
        num_cooperating_opponents = np.sum(estimated_opponent_actions)
        num_defecting_opponents = n - 1 - num_cooperating_opponents
        total_opponent_consumption = num_defecting_opponents * initial_S / n + num_cooperating_opponents * initial_S / (2 * n)
        total_consumption = my_consumption + total_opponent_consumption
        stock_after_consumption = initial_S - total_consumption
        stock_for_growth = max(0.0, stock_after_consumption)
        if stock_for_growth <= 0:
            return 0.0
        growth = 2 * stock_for_growth * (1 - stock_for_growth / capacity)
        next_stock = min(stock_for_growth + growth, capacity)
        return next_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        n = self.n
        r = self.r
        if current_round_1_indexed == r:
            return Action.D
        avg_opponent_defection_rate = 0.5
        if current_round_0_indexed > 0:
            lookback_period = max(1, min(current_round_0_indexed, r // 4))
            recent_opponent_actions = history.opponent_actions[current_round_0_indexed - lookback_period:current_round_0_indexed, :]
            total_defections_by_opponents = np.sum(recent_opponent_actions == Action.D.value)
            total_opponent_decisions = lookback_period * (n - 1)
            if total_opponent_decisions > 0:
                avg_opponent_defection_rate = total_defections_by_opponents / total_opponent_decisions
        if current_round_0_indexed > 0:
            estimated_opponent_actions_prev_round = history.opponent_actions[current_round_0_indexed - 1, :]
            projected_next_stock_if_I_defect = self._estimate_next_stock(current_stock, Action.D, estimated_opponent_actions_prev_round)
            projected_next_stock_if_I_cooperate = self._estimate_next_stock(current_stock, Action.C, estimated_opponent_actions_prev_round)
            if projected_next_stock_if_I_defect <= self.min_stock_threshold_for_survival and projected_next_stock_if_I_cooperate > projected_next_stock_if_I_defect and (r - current_round_1_indexed > 0):
                return Action.C
        if current_stock >= self.abundant_stock_threshold:
            return Action.D
        elif current_stock >= self.moderately_healthy_stock_threshold:
            if avg_opponent_defection_rate < self.opp_coop_threshold_mod_healthy:
                return Action.D
            else:
                return Action.D
        elif avg_opponent_defection_rate < self.opp_coop_threshold_low_stock:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_272(BaseStrategy):
    """
    The Adaptive Predator strategy is designed to be highly exploitative, maximizing its own total payoff
    by balancing aggressive resource extraction with strategic self-preservation and adaptive responses
    to opponent behavior. It defaults to aggressive defection but incorporates safeguards to prevent
    premature resource collapse, which would harm its long-term payoff. It dynamically adjusts its
    behavior based on the current resource level and the collective actions of its opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = game_description.n_players
        r = game_description.n_rounds
        capacity = game_description.capacity
        self.stock_critical_threshold = capacity / 4
        self.early_game_rounds_limit = max(1, math.floor(r / 3))
        self.opponent_defection_response_threshold = math.ceil((n - 1) / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        opponent_defections_last_round = 0
        if state.round_number > 0 and history is not None:
            opponent_defections_last_round = np.sum(~history.opponent_actions[state.round_number - 1, :])
        if current_round_1_indexed == self.game_description.n_rounds:
            return Action.D
        if state.current_stock <= self.stock_critical_threshold:
            return Action.C
        if current_round_1_indexed <= self.early_game_rounds_limit:
            return Action.D
        if opponent_defections_last_round >= self.opponent_defection_response_threshold:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_273(BaseStrategy):
    """
    Adaptive Exploiter with Collapse Avoidance strategy for the Common Pool Resource game.

    This strategy aims to maximize its own total payoff by primarily defecting, but
    intelligently cooperates under specific conditions to prevent a full resource
    collapse, from which it can then continue to exploit. It avoids being a "sucker"
    by only cooperating if enough other players also cooperated in the previous round
    and if there are enough rounds left to benefit from the resource's recovery.
    In the final round, it always defects to maximize immediate gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters and internal heuristics.

        Args:
            game_description: An object containing game parameters like n_players,
                              n_rounds, and capacity.
        """
        self.game_description = game_description
        self.CRITICAL_STOCK_RATIO: float = 0.25
        self.MIN_COOPERATORS_FOR_MY_COOPERATION: int = math.ceil(self.game_description.n_players / 2)
        self.MIN_ROUNDS_LEFT_FOR_LONG_TERM_GAIN: int = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round based on
        game state, history, and internal strategy parameters.

        Args:
            state: The current state of the game, including round number and stock.
            history: An object containing past actions and payoffs of this player
                     and opponents. None for the very first round.

        Returns:
            An Action enum (Action.C for Cooperate, Action.D for Defect).
        """
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round_0_indexed == 0:
            return Action.D
        if current_round_1_indexed == total_rounds:
            return Action.D
        if current_stock < capacity * self.CRITICAL_STOCK_RATIO:
            if total_rounds - current_round_1_indexed >= self.MIN_ROUNDS_LEFT_FOR_LONG_TERM_GAIN:
                num_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
                if num_cooperators_last_round >= self.MIN_COOPERATORS_FOR_MY_COOPERATION:
                    return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_274(BaseStrategy):
    """
    The Opportunistic Predator strategy for the Common Pool Resource Game.

    This strategy aggressively defects to maximize immediate payoffs but
    incorporates a self-preservation mechanism to cooperate strategically
    when the resource is critically low, and cooperation has a chance
    to avert complete collapse for long-term benefit. It can also
    recognize when cooperation is futile and opts to extract maximum
    immediate value from a dying resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.initial_aggression_rounds = 2
        self.critical_stock_ratio = 0.25
        self.futile_cooperation_threshold_ratio = 0.05
        self.high_defection_rate_for_futility = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_round_0_indexed < self.initial_aggression_rounds:
            return Action.D
        num_opponents = self.n_players - 1
        total_defections_by_opponents = np.sum(~history.opponent_actions)
        total_opponent_actions_observed = history.opponent_actions.size
        opponent_defection_rate = 0.0
        if total_opponent_actions_observed > 0:
            opponent_defection_rate = total_defections_by_opponents / total_opponent_actions_observed
        estimated_D_opponents_this_round_float = opponent_defection_rate * num_opponents
        estimated_C_opponents_this_round_float = num_opponents - estimated_D_opponents_this_round_float
        my_consumption_if_D = current_stock / self.n_players
        opponents_consumption_if_I_D = estimated_D_opponents_this_round_float * current_stock / self.n_players + estimated_C_opponents_this_round_float * current_stock / (2 * self.n_players)
        total_consumption_if_I_D = my_consumption_if_D + opponents_consumption_if_I_D
        s_after_consumption_if_I_D = current_stock - total_consumption_if_I_D
        if s_after_consumption_if_I_D < 0:
            s_after_consumption_if_I_D = 0.0
        s_growth_if_I_D = 2 * s_after_consumption_if_I_D * (1 - s_after_consumption_if_I_D / self.capacity)
        s_predicted_next_round_if_I_D = min(s_after_consumption_if_I_D + s_growth_if_I_D, self.capacity)
        if s_predicted_next_round_if_I_D < self.capacity * self.critical_stock_ratio:
            if s_predicted_next_round_if_I_D < self.capacity * self.futile_cooperation_threshold_ratio and opponent_defection_rate > self.high_defection_rate_for_futility:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_275(BaseStrategy):
    """
    The Adaptive Opportunist strategy dynamically adjusts its behavior based on observed opponent actions,
    current stock levels, and the number of rounds remaining. It aims to maximize its own total payoff
    by strategically exploiting cooperative behavior from opponents while minimizing losses when facing
    widespread defection or resource depletion. Its default inclination is to Defect, but it uses Cooperation
    as a calculated investment to "bait" opponents or as a desperate measure to prevent total resource collapse.
    """
    ENDGAME_ROUNDS: int = 2
    CRITICAL_STOCK_THRESHOLD_FACTOR: float = 0.1
    CRITICAL_STOCK_DEFECTION_THRESHOLD: float = 0.2
    COOP_RATE_HIGH_THRESHOLD: float = 0.6
    COOP_RATE_BAIT_THRESHOLD: float = 0.5
    MAX_BAIT_DURATION: int = 2
    HIGH_STOCK_FOR_BAIT_THRESHOLD_FACTOR: float = 0.7
    MIN_ROUNDS_FOR_BAIT: int = 4

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.my_current_bait_round: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t_zero_indexed: int = state.round_number
        round_t_one_indexed: int = state.round_number + 1
        total_rounds_r: int = self.game_description.n_rounds
        current_stock_S: float = state.current_stock
        capacity: float = self.game_description.capacity
        n_players: int = self.game_description.n_players
        n_cooperators_prev: int = 0
        if round_t_zero_indexed > 0:
            n_cooperators_prev = np.sum(history.opponent_actions[round_t_zero_indexed - 1, :])
        cooperation_rate_prev: float
        if n_players - 1 > 0:
            cooperation_rate_prev = n_cooperators_prev / (n_players - 1)
        else:
            cooperation_rate_prev = 0.0
        if round_t_one_indexed >= total_rounds_r - self.ENDGAME_ROUNDS + 1:
            self.my_current_bait_round = 0
            return Action.D
        critical_stock_level: float = capacity * self.CRITICAL_STOCK_THRESHOLD_FACTOR
        if current_stock_S <= critical_stock_level:
            self.my_current_bait_round = 0
            if cooperation_rate_prev < self.CRITICAL_STOCK_DEFECTION_THRESHOLD:
                return Action.D
            else:
                return Action.C
        if self.my_current_bait_round > 0:
            if self.my_current_bait_round < self.MAX_BAIT_DURATION and cooperation_rate_prev >= self.COOP_RATE_HIGH_THRESHOLD:
                self.my_current_bait_round += 1
                return Action.C
            else:
                self.my_current_bait_round = 0
                return Action.D
        if cooperation_rate_prev >= self.COOP_RATE_HIGH_THRESHOLD:
            return Action.D
        elif cooperation_rate_prev <= self.COOP_RATE_BAIT_THRESHOLD and current_stock_S >= capacity * self.HIGH_STOCK_FOR_BAIT_THRESHOLD_FACTOR and (total_rounds_r - round_t_one_indexed >= self.MIN_ROUNDS_FOR_BAIT):
            self.my_current_bait_round = 1
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_276(BaseStrategy):
    """
    Opportunistic Piranha strategy: Defaults to aggressive exploitation (Defect)
    but incorporates self-preservation mechanisms to ensure the resource
    remains viable for future rounds, allowing for continued exploitation.
    It adapts to critical resource levels and significant stock declines,
    cooperating only when it's strategically beneficial for long-term gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_critical_low = self.capacity / 4.0
        self.stock_decline_threshold_factor = 0.95
        self.min_rounds_for_recovery = 2
        self.previous_round_start_stock: float | None = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.r:
            self.previous_round_start_stock = state.current_stock
            return Action.D
        if state.current_stock < self.S_critical_low:
            self.previous_round_start_stock = state.current_stock
            return Action.C
        if current_round_1_indexed > 1 and self.previous_round_start_stock is not None:
            if self.previous_round_start_stock > 0 and state.current_stock < self.previous_round_start_stock * self.stock_decline_threshold_factor:
                if self.r - current_round_1_indexed > self.min_rounds_for_recovery:
                    self.previous_round_start_stock = state.current_stock
                    return Action.C
        self.previous_round_start_stock = state.current_stock
        return Action.D

class Strategy_EXPLOITATIVE_277(BaseStrategy):
    """
    The "Calculated Predator" is an exploitative strategy designed to maximize its own cumulative payoff
    over the game's rounds. It defects opportunistically but strategically cooperates to prevent
    resource collapse, ensuring future opportunities for exploitation. It adapts to the current stock
    level and the recent behavior of other players.

    Core Principles:
    1.  **Last Round Maximization:** In the final round, prioritizes immediate payoff as there are no
        future consequences.
    2.  **Resource Preservation:** If the common stock is critically low, temporarily switches to
        cooperation to allow recovery, as a depleted resource yields no future payoffs.
    3.  **Opportunistic Free-Riding:** If other players are largely cooperative and the stock is healthy,
        defects to maximize personal gain.
    4.  **Strategic Stock Maintenance/Defection:** When opponent cooperation is moderate or low, evaluates
        the impact of personal action. Cooperates if doing so is crucial to prevent immediate stock
        collapse; otherwise, defects to maximize immediate share.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_critical_ratio = 0.3
        self.Forgiveness_Window = 3
        self.Cooperation_FreeRide_Threshold = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_number = state.round_number
        if current_round_number == r - 1:
            return Action.D
        if current_stock < capacity * self.S_critical_ratio:
            return Action.C
        num_opponents = n - 1
        num_opponents_cooperated_recent = 0
        num_opponent_actions_observed = 0
        if current_round_number > 0 and history is not None:
            rounds_to_consider_count = min(current_round_number, self.Forgiveness_Window)
            for i in range(1, rounds_to_consider_count + 1):
                round_idx_in_history = current_round_number - i
                num_cooperated_in_round = np.sum(history.opponent_actions[round_idx_in_history, :])
                num_opponents_cooperated_recent += num_cooperated_in_round
                num_opponent_actions_observed += num_opponents
        if num_opponent_actions_observed == 0:
            P_C = 0.0
        else:
            P_C = num_opponents_cooperated_recent / num_opponent_actions_observed
        if P_C >= self.Cooperation_FreeRide_Threshold:
            return Action.D
        else:
            consumption_by_my_C = current_stock / (2 * n)
            consumption_by_my_D = current_stock / n
            estimated_consumption_by_others = P_C * num_opponents * (current_stock / (2 * n)) + (1 - P_C) * num_opponents * (current_stock / n)
            total_consumption_if_I_C = consumption_by_my_C + estimated_consumption_by_others
            total_consumption_if_I_D = consumption_by_my_D + estimated_consumption_by_others
            S_remaining_if_I_C = current_stock - total_consumption_if_I_C
            S_remaining_if_I_D = current_stock - total_consumption_if_I_D
            if S_remaining_if_I_D <= 0 and S_remaining_if_I_C > 0:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_278(BaseStrategy):
    """
    The Calculated Predator strategy prioritizes individual gains by consistently defecting.
    It strategically retreats to cooperation only when the common resource approaches collapse,
    as a dead resource yields no future payoffs. It views other players' actions through the
    lens of maximizing its own takeexploiting cooperators and ensuring it gets its share
    even in a "race to the bottom" scenario against defectors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_survival_threshold = 2 * self.n
        self.high_stock_aggression_threshold = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number
        current_stock_S = state.current_stock
        if current_round_t == self.r - 1:
            return Action.D
        elif current_stock_S < self.S_survival_threshold:
            return Action.C
        elif current_stock_S / self.capacity >= self.high_stock_aggression_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_279(BaseStrategy):
    """
    The Greedy Stock Manager strategy is highly exploitative. It defaults to
    defecting to maximize immediate personal gain. Cooperation is a defensive
    measure, only employed when the common stock is critically low to prevent
    resource collapse and ensure future exploitation opportunities. In all
    other standard rounds, it defects, regardless of opponent behavior, to
    extract maximum value.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CONSERVATION_THRESHOLD_FACTOR: float = 0.25
        self.MIN_COOPERATORS_TO_EXPLOIT: int = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round_1_indexed == 1:
            return Action.D
        if current_round_1_indexed == total_rounds:
            return Action.D
        if current_stock < self.CONSERVATION_THRESHOLD_FACTOR * capacity:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_280(BaseStrategy):
    """
    The "Adaptive Predator" strategy prioritizes immediate individual gain by defecting,
    only cooperating as a last resort to prevent the complete collapse of the common pool resource.
    It adapts to the overall health of the common stock and the observed cooperation of other players.

    Core Philosophy: Prioritize immediate individual gain by defecting. Only cooperate as a last resort
    to prevent the complete collapse of the common pool resource, which would otherwise eliminate all
    future payoff opportunities. Do not cooperate to encourage others, but rather to ensure the resource
    remains viable for *my* future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_CRITICAL_LOW_PROPORTION = 0.3
        self.COOPERATION_EXPLOITATION_THRESHOLD = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        s_critical_level = self.S_CRITICAL_LOW_PROPORTION * self.game_description.capacity
        if current_round_1_indexed == self.game_description.n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        num_cooperators_others = np.sum(history.opponent_actions[state.round_number - 1, :])
        cooperation_rate_others = 0.0
        num_other_players = self.game_description.n_players - 1
        cooperation_rate_others = num_cooperators_others / num_other_players
        if state.current_stock < s_critical_level:
            return Action.C
        elif cooperation_rate_others >= self.COOPERATION_EXPLOITATION_THRESHOLD:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_281(BaseStrategy):
    """
    The "Adaptive Predator" strategy is designed to be highly exploitative, prioritizing its own cumulative payoff
    by leveraging immediate gains, free-riding on others' cooperation, and aggressively responding to defection.
    It is adaptive to opponent behavior and resource state, and robust to various playstyles by defaulting to
    defection unless specific conditions for self-preservation or exploitation are met.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.DANGEROUS_STOCK_PERCENTAGE = 0.1
        self.MIN_COOPERATORS_FOR_SELF_PRESERVATION = 0.6
        total_rounds = self.game_description.n_rounds
        if total_rounds >= 4:
            self.ENDGAME_ROUNDS_COUNT = min(3, total_rounds // 2)
        else:
            self.ENDGAME_ROUNDS_COUNT = 1
        self.num_other_players = self.game_description.n_players - 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round == 0:
            return Action.D
        if current_round >= total_rounds - self.ENDGAME_ROUNDS_COUNT:
            return Action.D
        previous_opponent_actions = history.opponent_actions[current_round - 1]
        num_opponents_cooperated_last_round = sum(previous_opponent_actions)
        num_opponents_defected_last_round = self.num_other_players - num_opponents_cooperated_last_round
        if current_stock < self.DANGEROUS_STOCK_PERCENTAGE * capacity:
            if num_opponents_cooperated_last_round >= self.num_other_players * self.MIN_COOPERATORS_FOR_SELF_PRESERVATION:
                return Action.C
            else:
                return Action.D
        if num_opponents_defected_last_round > math.floor(self.num_other_players / 2):
            return Action.D
        if num_opponents_cooperated_last_round > math.floor(self.num_other_players / 2):
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_282(BaseStrategy):
    """
    The Resource Reaper is an exploitative strategy for the Common Pool Resource Game.
    It generally defects for higher immediate gains but incorporates adaptive measures
    to prevent complete resource collapse *only* when such a collapse is imminent
    due to its own defection and would significantly harm its future payoffs, and is
    also avoidable by collective effort. It always defects in the first round and the
    final few rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_STOCK_PERCENTAGE = 0.15
        self.ENDGAME_ROUNDS_TO_DEFECT = 2
        self.critical_stock_threshold = self.CRITICAL_STOCK_PERCENTAGE * self.capacity

    def _calculate_next_stock(self, current_stock: float, total_consumption: float) -> float:
        """
        Helper method to project the next round's stock level based on current stock
        and total consumption, incorporating growth dynamics and clamping.

        Args:
            current_stock (float): The stock level at the beginning of the round.
            total_consumption (float): The total amount of stock consumed by all players.

        Returns:
            float: The projected stock level for the next round, clamped between 0 and capacity.
        """
        S_after_consumption = current_stock - total_consumption
        S_for_growth_calc = max(0.0, S_after_consumption)
        growth = 2 * S_for_growth_calc * (1 - S_for_growth_calc / self.capacity)
        unclamped_new_stock = S_after_consumption + growth
        projected_stock = min(max(0.0, unclamped_new_stock), self.capacity)
        return projected_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round >= self.n_rounds - self.ENDGAME_ROUNDS_TO_DEFECT:
            return Action.D
        if current_round == 0:
            return Action.D
        num_cooperators_prev = np.sum(history.opponent_actions[current_round - 1, :])
        num_defectors_prev = self.n_players - 1 - num_cooperators_prev
        my_consumption_D = current_stock / self.n_players
        my_consumption_C = current_stock / (2 * self.n_players)
        total_consumption_if_I_defect = my_consumption_D + num_cooperators_prev * my_consumption_C + num_defectors_prev * my_consumption_D
        projected_new_stock_if_I_defect = self._calculate_next_stock(current_stock, total_consumption_if_I_defect)
        total_consumption_all_C = self.n_players * my_consumption_C
        projected_new_stock_all_C = self._calculate_next_stock(current_stock, total_consumption_all_C)
        if projected_new_stock_if_I_defect < self.critical_stock_threshold:
            if projected_new_stock_all_C > self.critical_stock_threshold:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_283(BaseStrategy):
    """
    The Strategic Opportunist strategy for the Common Pool Resource Game.
    This strategy aims to maximize personal total payoff by being aggressively exploitative
    when conditions allow (high stock, cooperative opponents), but demonstrating strategic
    restraint (cooperation) to prevent resource collapse or to encourage cooperation when
    it's beneficial for long-term exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        stock = state.current_stock
        if current_round == r - 1:
            return Action.D
        if current_round == r - 2:
            return Action.D
        if current_round == 0:
            return Action.C
        previous_round_others_actions = history.opponent_actions[-1, :]
        num_C_others_prev_round = np.sum(previous_round_others_actions)
        cooperation_ratio_others = num_C_others_prev_round / (n - 1)
        if stock < capacity / 4:
            return Action.C
        if cooperation_ratio_others >= 0.7:
            return Action.D
        elif cooperation_ratio_others <= 0.3:
            return Action.D
        elif stock >= capacity * 0.8:
            return Action.D
        elif stock <= capacity * 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_284(BaseStrategy):
    """
    The Opportunistic Predator strategy prioritizes immediate personal gain,
    defaulting to defection. It adaptively cooperates only when the common
    resource is critically low but salvageable, and only if other players
    demonstrate sufficient cooperation to make the recovery effort worthwhile.
    It aggressively defects in endgame scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.pillage_threshold = self.capacity / (2 * self.n)
        self.recovery_effort_threshold = self.capacity / self.n
        self.min_observed_cooperation_ratio = 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.D
        elif current_round_0_indexed == self.r - 1:
            return Action.D
        elif current_round_0_indexed == self.r - 2:
            return Action.D
        if current_stock <= self.pillage_threshold:
            return Action.D
        if current_stock <= self.recovery_effort_threshold:
            num_other_cooperators_last_round = np.sum(history.opponent_actions[current_round_0_indexed - 1, :])
            observed_other_cooperation_ratio = 0.0
            observed_other_cooperation_ratio = num_other_cooperators_last_round / (self.n - 1)
            if observed_other_cooperation_ratio >= self.min_observed_cooperation_ratio:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_285(BaseStrategy):
    """
    Adaptive Free-Rider: An exploitative strategy for the Common Pool Resource game.
    It defaults to defection to maximize personal gain but cooperates strategically
    to prevent resource collapse, ensuring future exploitation opportunities.
    Its decisions are driven by current stock levels and observed opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_CRITICAL_THRESHOLD = self.capacity * 0.2
        self.S_CAUTION_THRESHOLD = self.capacity * 0.5
        self.DEFECTION_HIGH_PRESSURE = 0.6
        self.DEFECTION_EXTREME_PRESSURE = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.total_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        last_round_opponent_actions = history.opponent_actions[-1, :]
        num_opponent_cooperators = np.sum(last_round_opponent_actions)
        num_other_players = self.n_players - 1
        num_other_defectors = num_other_players - num_opponent_cooperators
        defection_pressure = num_other_defectors / num_other_players
        if current_stock < self.S_CRITICAL_THRESHOLD:
            return Action.C
        elif current_stock < self.S_CAUTION_THRESHOLD:
            if defection_pressure >= self.DEFECTION_HIGH_PRESSURE:
                return Action.C
            else:
                return Action.D
        elif defection_pressure >= self.DEFECTION_EXTREME_PRESSURE:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_286(BaseStrategy):
    """
    The Calculated Predator strategy defaults to defecting to maximize immediate payoffs.
    It incorporates "emergency brakes" to temporarily cooperate and prevent resource collapse
    when stock is critically low or when widespread defection is causing rapid decline,
    thereby safeguarding future exploitation opportunities.
    """
    _COOPERATION_THRESHOLD_RATIO_DEFAULT = 0.15
    _CRITICAL_DEFECTION_RATIO_DEFAULT = 0.7

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.cooperation_threshold_ratio = self._COOPERATION_THRESHOLD_RATIO_DEFAULT
        self.critical_defection_ratio = self._CRITICAL_DEFECTION_RATIO_DEFAULT
        self._stock_history_at_start_of_round: list[float] = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_idx = state.round_number
        current_stock = state.current_stock
        if round_idx == self.n_rounds - 1:
            self._stock_history_at_start_of_round.append(current_stock)
            return Action.D
        if round_idx == 0:
            self._stock_history_at_start_of_round.append(current_stock)
            return Action.D
        else:
            stock_ratio = current_stock / self.capacity
            previous_round_opponent_actions = history.opponent_actions[round_idx - 1]
            d_count_prev = (previous_round_opponent_actions == False).sum()
            stock_at_start_of_previous_round = self._stock_history_at_start_of_round[round_idx - 1]
            if current_stock <= 0:
                self._stock_history_at_start_of_round.append(current_stock)
                return Action.D
            if stock_ratio < self.cooperation_threshold_ratio:
                self._stock_history_at_start_of_round.append(current_stock)
                return Action.C
            if round_idx > 1 and d_count_prev / self.n_players >= self.critical_defection_ratio and (current_stock < stock_at_start_of_previous_round):
                self._stock_history_at_start_of_round.append(current_stock)
                return Action.C
            else:
                self._stock_history_at_start_of_round.append(current_stock)
                return Action.D

class Strategy_EXPLOITATIVE_287(BaseStrategy):
    """
    The Adaptive Predator strategy prioritizes immediate personal gain by defecting (D),
    but critically observes the common resource stock and the collective behavior of other players.
    It will temporarily switch to cooperation (C) only as a strategic measure to prevent the
    common pool from collapsing entirely, thereby preserving future rounds for its own exploitation.
    However, if its temporary cooperation proves ineffective due to continued aggression from others,
    it will revert to defection to avoid being a "sucker."
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold_ratio = 0.25
        self.defection_alert_ratio = 0.5
        self.patience_limit = 2
        self.my_coop_streak_while_others_defect = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            self.my_coop_streak_while_others_defect = 0
            return Action.D
        if current_round_0_indexed == 0:
            self.my_coop_streak_while_others_defect = 0
            return Action.D
        n_coop_prev_total = int(history.my_actions[-1] == Action.C) + np.sum(history.opponent_actions[-1, :] == Action.C)
        n_defectors_prev_total = self.n_players - n_coop_prev_total
        stock_health_ratio = current_stock / self.capacity
        others_aggression_ratio = n_defectors_prev_total / self.n_players
        if stock_health_ratio < self.critical_stock_threshold_ratio:
            if others_aggression_ratio > self.defection_alert_ratio:
                if self.my_coop_streak_while_others_defect < self.patience_limit:
                    self.my_coop_streak_while_others_defect += 1
                    return Action.C
                else:
                    self.my_coop_streak_while_others_defect = 0
                    return Action.D
            else:
                self.my_coop_streak_while_others_defect = 0
                return Action.C
        else:
            self.my_coop_streak_while_others_defect = 0
            return Action.D

class Strategy_EXPLOITATIVE_288(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its own total payoff by primarily defecting,
    but adapts to cooperate when the common pool resource is critically low or when heavy
    defection by others threatens long-term exploitation. It prioritizes immediate gains,
    exploits cooperation, and strategically retreats to allow resource recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.S_CRITICAL_LOW_THRESHOLD = capacity / (2 * n)
        self.S_HEALTHY_THRESHOLD = capacity / 2
        self.OPPONENT_DEFECTION_LOW_RATE = 0.3
        self.OPPONENT_DEFECTION_HIGH_RATE = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        d_rate_others = 0.0
        if round_number > 0 and history is not None:
            num_d_others_prev = np.sum(~history.opponent_actions[-1, :])
            d_rate_others = num_d_others_prev / (n_players - 1)
        if round_number == total_rounds - 1:
            return Action.D
        elif current_stock < self.S_CRITICAL_LOW_THRESHOLD:
            return Action.C
        elif current_stock >= self.S_HEALTHY_THRESHOLD:
            if d_rate_others <= self.OPPONENT_DEFECTION_LOW_RATE:
                return Action.D
            else:
                return Action.D
        elif d_rate_others <= self.OPPONENT_DEFECTION_LOW_RATE:
            return Action.D
        elif d_rate_others >= self.OPPONENT_DEFECTION_HIGH_RATE:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_289(BaseStrategy):
    """
    The Adaptive Exploiter strategy for the Common Pool Resource game.
    This strategy aims to maximize its individual total payoff by defecting
    aggressively, but cooperates as a self-preservation measure when the
    resource stock is critically low, to prevent total collapse and ensure
    future (even if smaller) payoffs. It adapts its behavior based on the
    current round and the observed stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Exploiter strategy.

        Args:
            game_description: An object containing game parameters like
                              n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round.

        Args:
            state: An object containing the current round number and stock level.
            history: An object containing past actions and payoffs for all players.
                     This will be None for the very first round (round_number = 0).

        Returns:
            An Action enum member (Action.C for Cooperate or Action.D for Defect).
        """
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        else:
            previous_round_0_indexed = current_round_0_indexed - 1
            opponent_defections_last_round = (history.opponent_actions[previous_round_0_indexed, :] == False).sum()
            stock_health_status: str
            if current_stock > self.capacity / 2:
                stock_health_status = 'HEALTHY'
            elif current_stock > self.capacity / self.n_players:
                stock_health_status = 'STRAINED'
            else:
                stock_health_status = 'CRITICAL'
            if stock_health_status == 'HEALTHY':
                return Action.D
            elif stock_health_status == 'STRAINED':
                return Action.D
            elif stock_health_status == 'CRITICAL':
                return Action.C

class Strategy_EXPLOITATIVE_290(BaseStrategy):
    """
    The "Adaptive Predator" strategy for the Common Pool Resource game.

    This strategy aims to maximize its own cumulative payoff by primarily defecting,
    but also adapting to protect its future opportunities for exploitation or to
    seize opportunities when others are cooperative.

    Core Principles:
    1. Immediate Gain First: Default to Defect (D) to secure the highest immediate payoff.
    2. Exploit Cooperation: Free-ride on the cooperative efforts of other players.
    3. Self-Preservation: Temporarily cooperate only if the stock is critically low AND
       a strong signal of collective preservation effort is observed, thereby protecting
       the resource for future exploitation.
    4. End-Game Aggression: Maximize final gains when the "shadow of the future" disappears.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.STOCK_DEPLETION_RISK_THRESHOLD_PERCENT = 0.2
        self.COOPERATION_LEVEL_TO_PRESERVE = 0.75
        self.COOPERATION_LEVEL_TO_EXPLOIT = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if state.round_number == 0:
            return Action.D
        if current_round_1_indexed == total_rounds:
            return Action.D
        num_other_players = n_players - 1
        num_cooperators_prev_round = np.sum(history.opponent_actions[-1, :])
        cooperation_level = num_cooperators_prev_round / num_other_players
        stock_depletion_threshold = capacity * self.STOCK_DEPLETION_RISK_THRESHOLD_PERCENT
        if current_stock <= stock_depletion_threshold:
            if cooperation_level >= self.COOPERATION_LEVEL_TO_PRESERVE:
                return Action.C
            else:
                return Action.D
        if cooperation_level >= self.COOPERATION_LEVEL_TO_EXPLOIT:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_291(BaseStrategy):
    """
    The Adaptive Opportunistic Predator (AOP) strategy for the Common Pool Resource game.
    It is designed to be highly aggressive and exploitative, prioritizing immediate gains by defecting.
    It incorporates a dynamic, forward-looking safeguard to prevent self-sabotage due to resource collapse,
    adapting its behavior based on observed opponent actions. It ruthlessly exploits the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.MIN_VIABLE_STOCK_FLOOR = self.capacity / (4.0 * self.n_players)

    def _predict_next_stock(self, S_current: float, total_defectors_in_simulation: int) -> float:
        """
        Helper method to predict the next round's stock level.
        It takes the current stock (S_current) and the total number of players
        (including 'self') who defect in this simulated round.

        Args:
            S_current (float): The current stock level.
            total_defectors_in_simulation (int): The total count of players assumed to defect
                                                 in the current round for this prediction.

        Returns:
            float: The predicted stock level for the beginning of the next round.
        """
        total_cooperators_in_simulation = self.n_players - total_defectors_in_simulation
        consumption_by_defectors = total_defectors_in_simulation * (S_current / self.n_players)
        consumption_by_cooperators = total_cooperators_in_simulation * (S_current / (2.0 * self.n_players))
        total_consumption = consumption_by_defectors + consumption_by_cooperators
        S_remaining = S_current - total_consumption
        S_remaining = max(0.0, S_remaining)
        growth = 2.0 * S_remaining * (1.0 - S_remaining / self.capacity)
        S_next = S_remaining + growth
        S_next = min(S_next, self.capacity)
        S_next = max(0.0, S_next)
        return S_next

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed >= self.n_rounds - 1:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        num_defectors_prev_round_by_opponents = (history.opponent_actions[-1, :] == False).sum()
        total_defectors_if_I_D = num_defectors_prev_round_by_opponents + 1
        S_next_if_I_D = self._predict_next_stock(current_stock, total_defectors_if_I_D)
        total_defectors_if_I_C = num_defectors_prev_round_by_opponents
        S_next_if_I_C = self._predict_next_stock(current_stock, total_defectors_if_I_C)
        if S_next_if_I_D < self.MIN_VIABLE_STOCK_FLOOR:
            if S_next_if_I_C >= self.MIN_VIABLE_STOCK_FLOOR:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_292(BaseStrategy):
    """
    The Opportunistic Predator strategy for the Common Pool Resource Game.

    This strategy aims to maximize its own total payoff by primarily exploiting other
    players' cooperation. It largely defects, only cooperating under specific, dire
    circumstances to preserve the resource for future exploitation, rather than
    out of altruism. If the resource is on an irreversible path to collapse due
    to widespread defection, it will switch to maximizing immediate gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_danger_threshold = game_description.capacity / 4
        self.S_recovery_threshold = game_description.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round_idx = state.round_number
        current_stock_S = state.current_stock
        if current_round_idx == 0:
            return Action.D
        if current_round_idx == r - 1:
            return Action.D
        k_C = sum(history.opponent_actions[-1, :]) + int(history.my_actions[-1])
        if current_stock_S < self.S_danger_threshold:
            if k_C > n / 2:
                return Action.C
            else:
                return Action.D
        elif current_stock_S < self.S_recovery_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_293(BaseStrategy):
    """
    The Opportunistic Predator strategy for the Common Pool Resource Game.
    This strategy prioritizes personal total payoff by primarily defecting,
    while exhibiting just enough "strategic cooperation" to prevent the
    resource from collapsing entirely if such cooperation could lead to
    future exploitation opportunities. It is designed to be highly adaptive
    to opponent behavior without relying on shared norms.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOPERATION_MEMORY_ROUNDS = 3
        self.LOW_STOCK_THRESHOLD_FACTOR = 0.15
        self.OPPONENT_HIGH_COOP_RATE = 0.6
        self.OPPONENT_MODERATE_COOP_RATE = 0.3
        self.MY_DEFECTION_STREAK_LIMIT = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        if current_round_1_indexed == total_rounds:
            return Action.D
        if state.current_stock < capacity * self.LOW_STOCK_THRESHOLD_FACTOR:
            return Action.C
        avg_opponent_cooperation_rate = 0.0
        num_observation_rounds = min(state.round_number, self.COOPERATION_MEMORY_ROUNDS)
        if num_observation_rounds > 0:
            start_index = state.round_number - num_observation_rounds
            observed_opponent_actions = history.opponent_actions[start_index:state.round_number, :]
            total_other_coop_actions = np.sum(observed_opponent_actions)
            total_possible_actions = (n_players - 1) * num_observation_rounds
            avg_opponent_cooperation_rate = total_other_coop_actions / total_possible_actions
        if avg_opponent_cooperation_rate >= self.OPPONENT_HIGH_COOP_RATE:
            return Action.D
        elif avg_opponent_cooperation_rate >= self.OPPONENT_MODERATE_COOP_RATE:
            return Action.D
        else:
            my_defection_streak = 0
            if state.round_number > 0:
                for r_idx in range(state.round_number - 1, -1, -1):
                    if history.my_actions[r_idx] == False:
                        my_defection_streak += 1
                    else:
                        break
                    if my_defection_streak >= self.MY_DEFECTION_STREAK_LIMIT:
                        break
            if my_defection_streak >= self.MY_DEFECTION_STREAK_LIMIT:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_294(BaseStrategy):
    """
    Adaptive Predator strategy: Aggressively exploits resources but strategically cooperates
    when necessary to maintain the common pool for future exploitation. It avoids being a "sucker"
    by responding to low cooperation from others and defects in the first/last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.s_low_threshold = 0.1
        self.s_high_threshold = 0.7
        self.c_coop_tolerance = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.D
        if current_round_1_indexed == total_rounds:
            return Action.D
        stock_ratio = current_stock / capacity
        previous_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        num_coop_others = np.sum(previous_round_opponent_actions)
        coop_ratio_others = num_coop_others / (n_players - 1)
        if stock_ratio <= self.s_low_threshold:
            return Action.D
        elif coop_ratio_others < self.c_coop_tolerance:
            return Action.D
        elif stock_ratio >= self.s_high_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_295(BaseStrategy):
    """
    Opportunistic Harvester:

    This strategy primarily defaults to defection to maximize immediate payoff,
    switching to conditional cooperation only when the common stock is dangerously low
    and there's a collective effort to restore it. It then reverts to full exploitation
    in the final rounds.

    Strategy Parameters (Tunable):
    - K_collapse_threshold: (float, 0.0 to 1.0) Proportion of `capacity` below which the
                            common `stock` is considered "endangered."
    - K_defection_tolerance_ratio: (float, 0.0 to 1.0) When stock is endangered, this is the
                                   maximum proportion of opponents who can defect in the
                                   previous round before this strategy will also defect.
    - K_endgame_rounds: (integer) Number of final rounds during which the strategy will
                        switch to full, unconditional defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.K_collapse_threshold: float = 0.3
        self.K_defection_tolerance_ratio: float = 0.5
        self.K_endgame_rounds: int = 2
        self.K_endgame_rounds = min(self.K_endgame_rounds, self.game_description.n_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round: int = state.round_number
        total_rounds: int = self.game_description.n_rounds
        current_stock: float = state.current_stock
        capacity: int = self.game_description.capacity
        n_players: int = self.game_description.n_players
        if current_round == 0:
            return Action.D
        if current_round >= total_rounds - self.K_endgame_rounds:
            return Action.D
        total_opponents: int = n_players - 1
        p_D_prev: float = 0.0
        if total_opponents > 0:
            num_opponents_defected_prev_round: int = np.sum(history.opponent_actions[-1, :] == False)
            p_D_prev = num_opponents_defected_prev_round / total_opponents
        if current_stock < capacity * self.K_collapse_threshold:
            if p_D_prev > self.K_defection_tolerance_ratio:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_296(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its own total payoff over the rounds
    by aggressively defecting when the common pool resource is healthy. It only switches
    to cooperation when the resource becomes critically low and there's a reasonable
    chance of collective cooperation from other players. In the very last round, it always
    defects to maximize immediate gains without future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.MIN_SUSTAINABLE_STOCK_RATIO = 0.25
        self.DEFECTION_TOLERANCE_THRESHOLD = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        rounds_total = self.game_description.n_rounds
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_round_1_indexed == rounds_total:
            return Action.D
        critical_stock_threshold = capacity * self.MIN_SUSTAINABLE_STOCK_RATIO
        if state.current_stock < critical_stock_threshold:
            if current_round_1_indexed == 1:
                return Action.C
            else:
                num_opponent_defections_last_round = np.sum(history.opponent_actions[-1, :] == False)
                num_opponents = n_players - 1
                last_round_opponent_defection_rate = num_opponent_defections_last_round / num_opponents
                if last_round_opponent_defection_rate < self.DEFECTION_TOLERANCE_THRESHOLD:
                    return Action.C
                else:
                    return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_297(BaseStrategy):
    """
    The "Adaptive Exploiter" strategy aims to maximize its total payoff by aggressively exploiting
    opportunities to defect, while prudently cooperating only when necessary to prevent the collapse
    of the common resource. It balances immediate gratification with the long-term sustainability
    of the game for personal gain.
    """
    _STOCK_CRITICAL_THRESHOLD_FACTOR = 0.25
    _STOCK_RECOVERY_THRESHOLD_FACTOR = 0.5
    _OPPONENT_DEFECTION_TOLERANCE_PERCENTAGE = 0.3

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._stock_critical_threshold = self.game_description.capacity * self._STOCK_CRITICAL_THRESHOLD_FACTOR
        self._stock_recovery_threshold = self.game_description.capacity * self._STOCK_RECOVERY_THRESHOLD_FACTOR
        self._opponent_defection_tolerance_percentage = self._OPPONENT_DEFECTION_TOLERANCE_PERCENTAGE

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if round_number == total_rounds - 1:
            return Action.D
        if round_number == 0:
            return Action.C
        num_opponents_defected_prev_round = np.sum(~history.opponent_actions[-1, :])
        opponent_defection_rate = num_opponents_defected_prev_round / (n_players - 1)
        if current_stock <= self._stock_critical_threshold:
            return Action.C
        elif opponent_defection_rate > self._opponent_defection_tolerance_percentage:
            if current_stock <= self._stock_recovery_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_298(BaseStrategy):
    """
    The Opportunistic Predator strategy is designed to be highly exploitative,
    prioritizing immediate gain while employing strategic, conditional cooperation
    to protect its long-term profit source (the common pool resource) from complete collapse.
    It adapts to the current state of the resource and the observed behavior of other players.

    Core Principles:
    1.  Greedy by Default: Always chooses to Defect (D) to maximize immediate payoff,
        unless a specific condition dictates otherwise for a calculated long-term benefit.
    2.  Last-Round Maximization: Takes everything possible in the final round
        without concern for future consequences.
    3.  Self-Preservation through Strategic Cooperation: Temporarily cooperates only
        when the resource is critically low AND there's a reasonable chance it can
        recover AND other players demonstrate a willingness to contribute to recovery.
    4.  Panic Grab: If the resource is critically low but recovery is unlikely
        (either due to insufficient remaining rounds or lack of cooperation from others),
        it defects to extract whatever value remains.
    """
    _CRITICAL_STOCK_THRESHOLD_FACTOR = 0.25
    _COOPERATION_THRESHOLD = 0.6
    _RECENT_HISTORY_LOOKBACK = 3
    _RECOVERY_ROUNDS_MIN = 2

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_threshold_factor = self._CRITICAL_STOCK_THRESHOLD_FACTOR
        self.cooperation_threshold = self._COOPERATION_THRESHOLD
        self.recent_history_lookback = self._RECENT_HISTORY_LOOKBACK
        self.recovery_rounds_min = self._RECOVERY_ROUNDS_MIN

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        rounds_remaining_for_future = self.n_rounds - (current_round + 1)
        if rounds_remaining_for_future == 0:
            return Action.D
        critical_stock_threshold = self.capacity * self.critical_stock_threshold_factor
        average_other_coop_rate = 0.0
        if current_round > 0 and history is not None:
            start_round_for_history = max(0, current_round - self.recent_history_lookback)
            relevant_actions = history.opponent_actions[start_round_for_history:current_round, :]
            num_cooperators_observed = np.sum(relevant_actions)
            num_observations = relevant_actions.size
            if num_observations > 0:
                average_other_coop_rate = num_cooperators_observed / num_observations
        if current_stock < critical_stock_threshold and rounds_remaining_for_future < self.recovery_rounds_min:
            return Action.D
        if current_stock >= critical_stock_threshold or average_other_coop_rate < self.cooperation_threshold:
            return Action.D
        if current_stock < critical_stock_threshold and average_other_coop_rate >= self.cooperation_threshold and (rounds_remaining_for_future >= self.recovery_rounds_min):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_299(BaseStrategy):
    """
    Ruthless Harvester: An exploitative strategy for the Common Pool Resource Game.
    Prioritizes immediate high payoffs by defecting and only cooperates when it is
    strategically beneficial for long-term exploitation, specifically to avert
    imminent resource collapse if it's likely to be effective and worthwhile.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_PERCENTAGE = 0.2
        self.COLLAPSE_AVOIDANCE_OPPONENT_COOPERATION_THRESHOLD = 0.75
        self.MIN_ROUNDS_FOR_COOPERATION_SACRIFICE = 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        critical_stock_level = capacity * self.CRITICAL_STOCK_PERCENTAGE
        if current_round == 1:
            return Action.D
        if current_round == total_rounds:
            return Action.D
        num_other_players = n_players - 1
        num_cooperated_others = sum(history.opponent_actions[state.round_number - 1, :])
        cooperation_rate_others = 0.0
        cooperation_rate_others = num_cooperated_others / num_other_players
        rounds_remaining = total_rounds - current_round + 1
        if current_stock < critical_stock_level:
            if rounds_remaining < self.MIN_ROUNDS_FOR_COOPERATION_SACRIFICE:
                return Action.D
            elif cooperation_rate_others >= self.COLLAPSE_AVOIDANCE_OPPONENT_COOPERATION_THRESHOLD:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_300(BaseStrategy):
    """
    The Opportunistic Parasite strategy for the Common Pool Resource game.
    This strategy aims to maximize its own total payoff by continuously defecting,
    only cooperating when necessary to prevent resource collapse or to strategically
    allow for future exploitation. It is adaptive and exploitative.
    """
    CRITICAL_STOCK_THRESHOLD_RATIO = 0.1
    SIGNIFICANT_STOCK_DROP_RATIO = 0.05
    DEFECTION_MAJORITY_THRESHOLD = 0.5

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._stock_at_start_of_prev_completed_round: float = self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_idx = state.round_number
        chosen_action = Action.D
        if current_round_idx == r - 1:
            chosen_action = Action.D
        elif current_round_idx == 0:
            chosen_action = Action.D
        else:
            total_cooperators_prev_round = sum(history.opponent_actions[-1, :]) + history.my_actions[-1]
            num_defectors_prev_round = n - total_cooperators_prev_round
            stock_at_start_of_prev_round = self._stock_at_start_of_prev_completed_round
            if current_stock < self.CRITICAL_STOCK_THRESHOLD_RATIO * capacity:
                chosen_action = Action.C
            else:
                stock_change_prev_round = current_stock - stock_at_start_of_prev_round
                if stock_change_prev_round < -self.SIGNIFICANT_STOCK_DROP_RATIO * capacity and num_defectors_prev_round >= self.DEFECTION_MAJORITY_THRESHOLD * n:
                    chosen_action = Action.C
        self._stock_at_start_of_prev_completed_round = current_stock
        return chosen_action

class Strategy_EXPLOITATIVE_301(BaseStrategy):
    """
    The Adaptive Exploiter strategy is designed to maximize its own total payoff over the game.
    It defaults to defection for immediate gains, but dynamically considers stock sustainability
    when defection would push the common resource below a critical, self-interested threshold.
    It adapts to observed opponent behavior and the remaining game length, ensuring robust
    performance. In the final round, it always defects, as there are no future consequences for the stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def _calculate_next_stock(self, current_S: float, me_plays_D: bool, k_D_est: int, k_C_est: int) -> float:
        """
        Helper method to project the next stock level given the current stock,
        the player's potential action, and estimated opponent actions.
        """
        n = self.n
        capacity = self.capacity
        my_consumption: float
        if me_plays_D:
            my_consumption = current_S / n
        else:
            my_consumption = current_S / (2 * n)
        others_consumption = k_D_est * current_S / n + k_C_est * current_S / (2 * n)
        total_consumption = my_consumption + others_consumption
        S_remaining = max(0.0, current_S - total_consumption)
        growth = 2.0 * S_remaining * (1.0 - S_remaining / capacity)
        new_stock = min(S_remaining + growth, capacity)
        return new_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number + 1
        S = state.current_stock
        n = self.n
        r = self.r
        capacity = self.capacity
        n_minus_1 = n - 1
        k_D_est: int
        k_C_est: int
        if t == 1:
            k_D_est = math.floor(n_minus_1 / 2)
            k_C_est = n_minus_1 - k_D_est
        else:
            k_C_est = int(np.sum(history.opponent_actions[-1, :]))
            k_D_est = n_minus_1 - k_C_est
        next_S_if_I_D = self._calculate_next_stock(S, True, k_D_est, k_C_est)
        next_S_if_I_C = self._calculate_next_stock(S, False, k_D_est, k_C_est)
        if t >= r:
            return Action.D
        base_threshold = capacity / (2.0 * n)
        remaining_rounds_factor = r - t
        adjustment_multiplier = 1.0 + min(2.0, remaining_rounds_factor / (r / 2.0))
        stock_preservation_threshold = base_threshold * adjustment_multiplier
        if next_S_if_I_D < stock_preservation_threshold and next_S_if_I_C >= stock_preservation_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_302(BaseStrategy):
    """
    The Adaptive Harvester strategy for the Common Pool Resource Game.
    Aims to be aggressively exploitative when conditions permit, while strategically
    conserving the resource only when it's critically low and there's a reasonable
    chance of others also contributing to its recovery, to ensure future exploitation opportunities.
    It heavily leans on defection (`D`) as the default action.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_ratio = 0.25
        self.cooperation_exploit_threshold = 0.5
        self.defection_salvage_threshold = 0.8
        self.history_window = 3
        self.min_rounds_for_recovery = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number
        total_rounds_r = self.game_description.n_rounds
        current_stock_S = state.current_stock
        game_capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_round_t == 0:
            return Action.D
        if current_round_t == total_rounds_r - 1:
            return Action.D
        num_other_players = n_players - 1
        effective_history_window = min(current_round_t, self.history_window)
        avg_other_cooperation_rate_recent = 0.5
        if effective_history_window > 0:
            recent_opponent_actions = history.opponent_actions[-effective_history_window:, :]
            total_cooperated_in_window = np.sum(recent_opponent_actions)
            denominator = num_other_players * effective_history_window
            avg_other_cooperation_rate_recent = total_cooperated_in_window / denominator
        is_stock_critical = current_stock_S < game_capacity * self.critical_stock_ratio
        rounds_remaining = total_rounds_r - (current_round_t + 1)
        is_near_endgame = rounds_remaining <= self.min_rounds_for_recovery
        my_action = Action.D
        if is_stock_critical and (not is_near_endgame):
            if avg_other_cooperation_rate_recent <= 1 - self.defection_salvage_threshold:
                my_action = Action.D
            else:
                my_action = Action.C
        else:
            my_action = Action.D
        return my_action

class Strategy_EXPLOITATIVE_303(BaseStrategy):
    """
    The "Calculated Opportunist" strategy aims to maximize individual payoff
    by an aggressive default stance, free-riding on cooperation, and strategically
    adapting to preserve the common resource only when its collapse would harm
    long-term individual gains. It balances immediate exploitation with a pragmatic
    view of resource sustainability for sustained personal profit.
    """
    STOCK_RECOVERY_THRESHOLD_FACTOR: float
    ENDGAME_ROUNDS_THRESHOLD: int
    MIN_COOPERATION_RATE_THRESHOLD: float
    MAX_DEFECTION_RATE_THRESHOLD: float

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.STOCK_RECOVERY_THRESHOLD_FACTOR = 0.3
        self.ENDGAME_ROUNDS_THRESHOLD = 2
        self.MIN_COOPERATION_RATE_THRESHOLD = 0.5
        self.MAX_DEFECTION_RATE_THRESHOLD = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_number = state.round_number
        current_round_1_indexed = current_round_number + 1
        if current_round_number == 0:
            return Action.D
        if current_round_1_indexed > n_rounds - self.ENDGAME_ROUNDS_THRESHOLD:
            return Action.D
        num_other_players_D_prev = np.sum(~history.opponent_actions[-1, :])
        D_rate_others_prev = num_other_players_D_prev / (n_players - 1)
        stock_critical_level = capacity * self.STOCK_RECOVERY_THRESHOLD_FACTOR
        if current_stock < stock_critical_level:
            if D_rate_others_prev > self.MAX_DEFECTION_RATE_THRESHOLD:
                return Action.D
            else:
                return Action.C
        elif D_rate_others_prev < self.MIN_COOPERATION_RATE_THRESHOLD:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_304(BaseStrategy):
    """
    The "Greedy Opportunist" strategy for the Common Pool Resource game.
    It defaults to defection to maximize immediate gains but adaptively switches to cooperation
    in intermediate rounds if it projects that its cooperation will prevent the common pool stock
    from falling below a critical threshold, thereby safeguarding its own long-term cumulative payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_threshold = self.capacity / (2.0 * self.n)

    def _project_stock_next_round(self, my_action: Action, current_s: float, k_C_prev: int, k_D_prev: int) -> float:
        """
        Helper function to project the stock level for the next round.
        It estimates future stock based on the current stock, a hypothetical action by this player,
        and the observed behavior of opponents from the immediately preceding round.

        Args:
            my_action (Action): The hypothetical action (Action.C or Action.D) this player takes.
            current_s (float): The current stock level (S_t) at the start of the current round.
            k_C_prev (int): Number of opponents who cooperated in the previous round.
            k_D_prev (int): Number of opponents who defected in the previous round.

        Returns:
            float: The projected stock level at the start of the next round (S_{t+1}).
        """
        my_consumption = current_s / self.n if my_action == Action.D else current_s / (2.0 * self.n)
        opp_consumption_C_est = k_C_prev * (current_s / (2.0 * self.n))
        opp_consumption_D_est = k_D_prev * (current_s / self.n)
        opp_total_consumption_est = opp_consumption_C_est + opp_consumption_D_est
        total_consumption = my_consumption + opp_total_consumption_est
        S_after_consumption = max(0.0, current_s - total_consumption)
        growth = 2.0 * S_after_consumption * (1.0 - S_after_consumption / self.capacity)
        projected_S_next = min(self.capacity, S_after_consumption + growth)
        return projected_S_next

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.r:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        if current_stock <= 0:
            return Action.C
        last_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        k_C_prev = np.sum(last_round_opponent_actions).item()
        k_D_prev = self.n - 1 - k_C_prev
        projected_S_next_D = self._project_stock_next_round(Action.D, current_stock, k_C_prev, k_D_prev)
        projected_S_next_C = self._project_stock_next_round(Action.C, current_stock, k_C_prev, k_D_prev)
        if projected_S_next_D <= self.S_threshold and projected_S_next_C > self.S_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_305(BaseStrategy):
    """
    The Ruthless Opportunist strategy aims to maximize its own total payoff by defecting
    whenever it's safe and profitable, while employing specific safeguards to prevent
    resource collapse or being exploited by others. It operates based on a hierarchical
    set of rules, prioritizing critical situations (endgame, resource collapse) before
    considering opportunistic exploitation.
    """
    CRITICAL_STOCK_RATIO = 0.1
    LOW_STOCK_RECOVERY_RATIO = 0.4
    HIGH_STOCK_EXPLOITATION_RATIO = 0.75
    OPPONENT_DEFECTION_TOLERANCE_RATIO = 0.33
    MIN_ROUNDS_FOR_RECOVERY = 3

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_LEVEL = self.game_description.capacity * self.CRITICAL_STOCK_RATIO
        self.HIGH_STOCK_LEVEL = self.game_description.capacity * self.HIGH_STOCK_EXPLOITATION_RATIO
        self.LOW_STOCK_LEVEL = self.game_description.capacity * self.LOW_STOCK_RECOVERY_RATIO
        self.MAX_TOLERATED_OPPONENT_DEFECTORS = math.floor((self.game_description.n_players - 1) * self.OPPONENT_DEFECTION_TOLERANCE_RATIO)
        self.MAX_TOLERATED_OPPONENT_DEFECTORS = max(0, self.MAX_TOLERATED_OPPONENT_DEFECTORS)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if history is None:
            return Action.D
        num_opponent_defectors_last_round = np.sum(~history.opponent_actions[-1, :])
        if current_round_1_indexed == total_rounds:
            return Action.D
        if current_stock <= self.CRITICAL_STOCK_LEVEL:
            if current_stock == 0:
                return Action.D
            if total_rounds - current_round_1_indexed + 1 <= self.MIN_ROUNDS_FOR_RECOVERY:
                return Action.D
            else:
                return Action.C
        if num_opponent_defectors_last_round > self.MAX_TOLERATED_OPPONENT_DEFECTORS:
            return Action.D
        if current_stock < self.HIGH_STOCK_LEVEL:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_306(BaseStrategy):
    """
    Adaptive Exploiter with Stock Management strategy for the Common Pool Resource game.
    This strategy attempts to defect aggressively when the stock is healthy or when others
    are already causing a collapse. It strategically cooperates to prevent immediate ruin
    or facilitate stock recovery if opponents show a willingness to cooperate.
    """
    _CRITICAL_STOCK_MULTIPLIER = 0.35
    _RECOVERY_COOPERATION_DEFECTION_THRESHOLD = 0.5

    def __init__(self, game_description: CommonPoolDescription):
        self._n_players = game_description.n_players
        self._n_rounds = game_description.n_rounds
        self._capacity = game_description.capacity
        self._endgame_rounds_count = max(3, self._n_rounds // 4)
        self._immediate_collapse_stock_threshold = self._capacity * 0.05
        self._critical_stock_multiplier = self._CRITICAL_STOCK_MULTIPLIER
        self._recovery_cooperation_defection_threshold = self._RECOVERY_COOPERATION_DEFECTION_THRESHOLD

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number + 1
        current_stock = state.current_stock
        if current_round >= self._n_rounds - self._endgame_rounds_count + 1:
            return Action.D
        defection_count_prev_round = 0
        if current_round > 1:
            previous_round_actions = history.opponent_actions[state.round_number - 1]
            defection_count_prev_round = sum((1 for action_bool in previous_round_actions if not action_bool))
        opponent_defection_rate = 0.0
        if self._n_players - 1 > 0:
            opponent_defection_rate = defection_count_prev_round / (self._n_players - 1)
        critical_stock_threshold = self._capacity * self._critical_stock_multiplier
        if current_stock <= critical_stock_threshold:
            if opponent_defection_rate <= self._recovery_cooperation_defection_threshold:
                return Action.C
            else:
                return Action.D
        else:
            my_consumption_if_D = current_stock / self._n_players
            num_defecting_others = defection_count_prev_round
            num_cooperating_others = self._n_players - 1 - num_defecting_others
            others_consumption = num_defecting_others * (current_stock / self._n_players) + num_cooperating_others * (current_stock / (2 * self._n_players))
            projected_total_consumption_if_I_D = my_consumption_if_D + others_consumption
            projected_S_after_my_D = current_stock - projected_total_consumption_if_I_D
            if projected_S_after_my_D < self._immediate_collapse_stock_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_307(BaseStrategy):
    """
    The Shark strategy: An aggressive and exploitative strategy for the Common Pool Resource Game.
    It defaults to defection, prioritizing its own payoff maximization. Cooperation is considered
    only strategically to prevent a total resource collapse, and only if a sufficient number
    of other players are also contributing to that conservation. It exploits resource abundance,
    joins widespread defection, and defects in the first and final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_recovery_threshold_ratio = 0.35
        self.stock_high_threshold_ratio = 0.8
        n_opponents = self.game_description.n_players - 1
        self.cooperation_signal_threshold = math.ceil(n_opponents / 2)
        self.defection_signal_threshold = math.ceil(n_opponents * 0.75)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_round == 0:
            return Action.D
        if current_round == total_rounds - 1:
            return Action.D
        C_count_last_round = np.sum(history.opponent_actions[-1, :])
        D_count_last_round = n_players - 1 - C_count_last_round
        if current_stock < self.stock_recovery_threshold_ratio * capacity:
            if C_count_last_round > self.cooperation_signal_threshold:
                return Action.C
            else:
                return Action.D
        elif current_stock >= self.stock_high_threshold_ratio * capacity:
            return Action.D
        elif C_count_last_round == n_players - 1:
            return Action.D
        elif D_count_last_round >= self.defection_signal_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_308(BaseStrategy):
    """
    Dynamic Exploiter strategy for the Common Pool Resource game.
    This strategy aims to maximize its own total payoff by leveraging opponent cooperation when possible,
    participating in resource depletion when others are doing so, and strategically cooperating only
    to prevent total resource collapse or to enable future exploitation.
    It incorporates opportunistic defection, defensive defection, strategic cooperation,
    terminal aggression, and initial assertiveness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_CRITICAL_LOW = self.game_description.capacity / 4.0
        self.S_RECOVERY_TARGET = self.game_description.capacity / 2.0
        self.S_EXPLOIT_THRESHOLD = self.game_description.capacity * 0.75
        self.COOPERATION_TOLERANCE_OTHERS = 0.6
        self.DEFECTION_THREAT_OTHERS = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        if current_round_1_indexed == total_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        p_c_others_prev = 0.0
        p_d_others_prev = 0.0
        previous_round_actions_of_others = history.opponent_actions[-1, :]
        num_others_cooperated_prev = np.sum(previous_round_actions_of_others)
        num_other_players = n_players - 1
        p_c_others_prev = num_others_cooperated_prev / num_other_players
        p_d_others_prev = 1.0 - p_c_others_prev
        if current_stock <= self.S_CRITICAL_LOW:
            return Action.C
        elif p_d_others_prev >= self.DEFECTION_THREAT_OTHERS:
            return Action.D
        elif current_stock >= self.S_EXPLOIT_THRESHOLD and p_c_others_prev >= self.COOPERATION_TOLERANCE_OTHERS:
            return Action.D
        elif current_stock < self.S_RECOVERY_TARGET:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_309(BaseStrategy):
    """
    The "Adaptive Predator" strategy defaults to defecting to maximize immediate payoffs.
    It adaptively cooperates only when necessary to prevent resource collapse that would
    severely harm its *own* future cumulative payoffs. It prioritizes self-interest and
    reacts to the observed state of the common pool resource and past actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def _calculate_predicted_stock(self, current_S: float, num_others_D: int, my_action_choice_is_D: bool) -> float:
        """
        Helper function to project the stock level for the next round.
        Assumes current stock `current_S`.
        Assumes `num_others_D` other players will defect and the rest `(n - 1 - num_others_D)` will cooperate.
        `my_action_choice_is_D` (True for Defect, False for Cooperate) determines this player's action.
        """
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        if my_action_choice_is_D:
            my_consumption = current_S / n
        else:
            my_consumption = current_S / (2 * n)
        others_consumption_D = num_others_D * (current_S / n)
        others_consumption_C = (n - 1 - num_others_D) * (current_S / (2 * n))
        total_consumption = my_consumption + others_consumption_D + others_consumption_C
        total_consumption = min(total_consumption, current_S)
        S_after_consumption = current_S - total_consumption
        S_after_consumption = max(0.0, S_after_consumption)
        growth = 2 * S_after_consumption * (1 - S_after_consumption / capacity)
        new_S = min(S_after_consumption + growth, capacity)
        return new_S

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_S = state.current_stock
        if current_round_1_indexed == r:
            return Action.D
        num_others_defected_last_round = 0
        if state.round_number == 0:
            num_others_defected_last_round = 0
        else:
            num_others_defected_last_round = np.sum(~history.opponent_actions[-1, :])
        predicted_next_stock_if_i_D = self._calculate_predicted_stock(current_S=current_S, num_others_D=num_others_defected_last_round, my_action_choice_is_D=True)
        predicted_next_stock_if_i_C = self._calculate_predicted_stock(current_S=current_S, num_others_D=num_others_defected_last_round, my_action_choice_is_D=False)
        CRITICAL_NEXT_STOCK_LEVEL = max(n * 2.0, capacity * 0.05)
        action = Action.D
        if predicted_next_stock_if_i_D < CRITICAL_NEXT_STOCK_LEVEL:
            if predicted_next_stock_if_i_C >= CRITICAL_NEXT_STOCK_LEVEL:
                if r - current_round_1_indexed >= 1:
                    action = Action.C
        return action

class Strategy_EXPLOITATIVE_310(BaseStrategy):
    """
    The "Adaptive Predator" strategy for the Common Pool Resource Game.
    This strategy aims to maximize its own total payoff over the game's duration
    by exploiting other players' cooperation while dynamically adjusting to prevent
    premature destruction of the common resource. It adapts based on observed history
    and the current game state, balancing aggressive exploitation with resource preservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_history: list[int] = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if state.round_number > 0 and history is not None:
            num_other_cooperators_last_round = int(np.sum(history.opponent_actions[-1, :]))
            self.cooperation_history.append(num_other_cooperators_last_round)
        if current_round_1_indexed == self.game_description.n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        if state.current_stock < self.game_description.capacity / 4.0:
            return Action.C
        if not self.cooperation_history:
            return Action.C
        total_cooperators_observed = sum(self.cooperation_history)
        num_rounds_observed = len(self.cooperation_history)
        if num_rounds_observed == 0:
            return Action.C
        avg_cooperators_among_others = total_cooperators_observed / num_rounds_observed
        cooperation_threshold_for_my_C = (self.game_description.n_players - 1) / 3.0
        if avg_cooperators_among_others < cooperation_threshold_for_my_C:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_311(BaseStrategy):
    """
    The "Adaptive Exploiter" strategy maximizes its own total payoff by strategically defecting
    whenever possible, while taking calculated measures to prevent the complete collapse of
    the common resource. It adapts its behavior based on the current stock level and
    the observed cooperation of its opponents, aiming for long-term exploitation.
    """
    HIGH_STOCK_THRESHOLD_RATIO = 0.7
    CRITICAL_STOCK_THRESHOLD_RATIO = 0.1
    COOPERATION_EXPLOIT_THRESHOLD = 0.6
    PROJECTED_COLLAPSE_THRESHOLD_RATIO = 0.05

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round = state.round_number
        if current_round == 0:
            return Action.D
        if current_round == r - 1:
            return Action.D

        def calculate_projected_next_stock_if_I_D() -> float:
            previous_round_opponent_actions = history.opponent_actions[current_round - 1]
            num_opponents = n - 1
            num_cooperating_opponents = np.sum(previous_round_opponent_actions).item()
            consumption_C_per_player = current_stock / (2 * n) if n > 0 else 0.0
            consumption_D_per_player = current_stock / n if n > 0 else 0.0
            consumption_by_others = num_cooperating_opponents * consumption_C_per_player + (num_opponents - num_cooperating_opponents) * consumption_D_per_player
            my_consumption_if_I_D = consumption_D_per_player
            total_consumption_if_I_D = my_consumption_if_I_D + consumption_by_others
            projected_S_remaining_if_I_D = current_stock - total_consumption_if_I_D
            if projected_S_remaining_if_I_D < 0:
                projected_S_remaining_if_I_D = 0.0
            growth_factor_term = 1 - projected_S_remaining_if_I_D / capacity if capacity > 0 else 0.0
            projected_growth_if_I_D = 2 * projected_S_remaining_if_I_D * growth_factor_term
            projected_next_stock_if_I_D = min(projected_S_remaining_if_I_D + projected_growth_if_I_D, capacity)
            return projected_next_stock_if_I_D
        num_opponents = n - 1
        num_cooperating_opponents = np.sum(history.opponent_actions[current_round - 1]).item()
        opponent_cooperation_rate = num_cooperating_opponents / num_opponents if num_opponents > 0 else 0.0
        if current_stock >= self.HIGH_STOCK_THRESHOLD_RATIO * capacity:
            return Action.D
        if current_stock <= self.CRITICAL_STOCK_THRESHOLD_RATIO * capacity:
            projected_next_stock = calculate_projected_next_stock_if_I_D()
            if projected_next_stock <= self.PROJECTED_COLLAPSE_THRESHOLD_RATIO * capacity:
                return Action.C
            else:
                return Action.D
        if opponent_cooperation_rate >= self.COOPERATION_EXPLOIT_THRESHOLD:
            return Action.D
        else:
            projected_next_stock = calculate_projected_next_stock_if_I_D()
            if projected_next_stock <= self.PROJECTED_COLLAPSE_THRESHOLD_RATIO * capacity:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_312(BaseStrategy):
    """
    Adaptive Predator: An exploitative strategy that defaults to defection to maximize immediate payoff,
    only cooperating when its own defection would critically deplete the resource to a point where
    future exploitation potential is severely jeopardized, and its cooperation can avert this.
    It adapts to observed collective behavior and current resource health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.s_low_threshold = 0.1 * self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = float(self.game_description.capacity)
        r_current = state.round_number + 1
        S_current = state.current_stock
        if r_current == r:
            return Action.D
        if r_current == 1:
            return Action.D
        N_C_others_prev = np.sum(history.opponent_actions[-1, :])
        N_D_others_prev = n - 1 - N_C_others_prev

        def _project_next_stock(current_S: float, my_action: Action, N_C_others: int, N_D_others: int, capacity_val: float, n_players_val: int) -> float:
            """
            Calculates the projected stock level for the next round based on current state,
            hypothetical actions, and previous round's observed opponent behavior.
            """
            my_consumption = current_S / (2 * n_players_val) if my_action == Action.C else current_S / n_players_val
            others_consumption_C = N_C_others * (current_S / (2 * n_players_val))
            others_consumption_D = N_D_others * (current_S / n_players_val)
            total_consumption = my_consumption + others_consumption_C + others_consumption_D
            S_remaining = current_S - total_consumption
            S_remaining = max(0.0, S_remaining)
            growth = 2 * S_remaining * (1 - S_remaining / capacity_val)
            projected_S = min(S_remaining + growth, capacity_val)
            return max(0.0, projected_S)
        S_projected_C = _project_next_stock(S_current, Action.C, N_C_others_prev, N_D_others_prev, capacity, n)
        S_projected_D = _project_next_stock(S_current, Action.D, N_C_others_prev, N_D_others_prev, capacity, n)
        if S_projected_D < self.s_low_threshold:
            if S_projected_C >= self.s_low_threshold:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_313(BaseStrategy):
    """
    The Adaptive Predator (AP) strategy is designed to be highly exploitative, adaptive to opponent
    behavior, and robust across various game scenarios. Its core principle is to maximize its own payoff,
    leveraging immediate individual gains from defection, but with a calculated willingness to cooperate
    strategically to preserve the resource for future exploitation, especially when it senses an
    impending collapse that would harm its long-term returns. It prioritizes immediate gains, defects
    aggressively at the start and end of the game, and in periods of high stock, only cooperating
    as a last resort to prevent resource collapse when it's still possible and beneficial for future exploitation.
    """
    STOCK_CRITICAL_LOW_FACTOR = 0.2
    STOCK_CRITICAL_HIGH_FACTOR = 0.8

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_majority_defection_threshold = math.ceil((self.n - 1) / 2.0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if state.round_number == 0:
            return Action.D
        if current_round_1_indexed >= self.r - 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[state.round_number - 1]
        k_D_prev_others = np.sum(~previous_round_opponent_actions)
        if state.current_stock >= self.capacity * self.STOCK_CRITICAL_HIGH_FACTOR:
            return Action.D
        elif state.current_stock < self.capacity * self.STOCK_CRITICAL_LOW_FACTOR:
            if k_D_prev_others >= self.opponent_majority_defection_threshold:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_314(BaseStrategy):
    """
    Ruthless Opportunist: An exploitative, adaptive strategy for the Common Pool Resource game.
    It prioritizes maximizing its own cumulative payoff by defecting when the stock is healthy
    or it can free-ride. It only cooperates as a self-preservation measure when the resource
    is critically low and cooperation has a reasonable chance of preventing collapse.
    It abandons cooperation if saving the resource seems futile due to widespread defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_exploit_threshold = self.capacity * 0.6
        self.S_recovery_threshold = self.capacity * 0.3
        self.D_critical_fraction = (self.n - 1) / self.n
        self.D_tolerable_fraction = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_num_0_indexed = state.round_number
        round_num_1_indexed = round_num_0_indexed + 1
        last_round_defectors_count = 0
        if round_num_0_indexed > 0 and history is not None:
            my_prev_action_was_D = not history.my_actions[-1]
            opponent_cooperators_prev_round = history.opponent_actions[-1, :].sum()
            opponent_defectors_prev_round = self.n - 1 - opponent_cooperators_prev_round
            last_round_defectors_count = my_prev_action_was_D + opponent_defectors_prev_round
        defector_fraction_prev_round = last_round_defectors_count / self.n
        if round_num_1_indexed == self.r:
            return Action.D
        elif current_stock >= self.S_exploit_threshold:
            return Action.D
        elif current_stock < self.S_recovery_threshold:
            if defector_fraction_prev_round >= self.D_critical_fraction:
                return Action.D
            else:
                return Action.C
        elif defector_fraction_prev_round < self.D_tolerable_fraction:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_315(BaseStrategy):
    """
    Adaptive Predator strategy for the Common Pool Resource Game.
    This strategy prioritizes immediate gain by defecting (D), aiming to exploit
    the common resource and other players' cooperative tendencies. It only
    cooperates (C) as a calculated, short-term sacrifice when the resource is
    critically low AND a significant number of opponents are cooperating,
    thereby preserving the resource for its own future exploitation. It will
    always defect in the first and final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_ratio: float = 0.25
        self.defection_tolerance_ratio: float = 0.33

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock_S = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        opponent_actions_prev_round = history.opponent_actions[-1, :]
        num_opponent_D_prev_round = np.sum(~opponent_actions_prev_round)
        num_opponents = n_players - 1
        opponent_defection_rate = num_opponent_D_prev_round / num_opponents
        is_stock_critical = current_stock_S < self.critical_stock_ratio * capacity
        if not is_stock_critical:
            return Action.D
        elif opponent_defection_rate > self.defection_tolerance_ratio:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_316(BaseStrategy):
    """
    Adaptive Opportunistic Exploiter Strategy:
    Aims to maximize personal total payoff over all rounds by strategically defecting
    when advantageous, while ensuring the common pool resource does not entirely collapse.

    This strategy implements the following logic:
    1.  **Last Round Exploitation:** Always defects in the final round to maximize immediate payoff
        without future consequences.
    2.  **Initial Probing:** Cooperates for a specified number of initial rounds to assess opponent
        behavior and prevent immediate resource collapse.
    3.  **Stock Preservation:** Prioritizes cooperation if the common stock falls below a critical
        threshold, preventing total resource depletion and preserving future exploitation opportunities.
    4.  **Retaliation:** Defects if a significant proportion of other players defected in the previous
        round, avoiding being a "sucker" and claiming its share.
    5.  **Opportunistic Exploitation:** If opponents were mostly cooperative, it defects when the
        resource stock is healthy, leveraging others' cooperation.
    6.  **Sustainable Cooperation:** When opponents are cooperative but the stock is not "super healthy",
        it cooperates to allow the stock to recover for more profitable future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_preservation_threshold = self.capacity / (2.0 * self.n_players)
        self.opponent_defection_tolerance_rate = 0.25
        self.healthy_stock_for_exploitation_threshold = self.capacity * 0.75
        self.initial_cooperation_rounds = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.total_rounds:
            return Action.D
        if current_round_1_indexed <= self.initial_cooperation_rounds:
            return Action.C
        if state.current_stock < self.stock_preservation_threshold:
            return Action.C
        num_other_players_defected_prev = 0
        other_players_defection_rate = 0.0
        if state.round_number > 0:
            num_other_players_defected_prev = np.sum(~history.opponent_actions[state.round_number - 1, :])
            other_players_defection_rate = num_other_players_defected_prev / (self.n_players - 1)
        if other_players_defection_rate > self.opponent_defection_tolerance_rate:
            return Action.D
        elif state.current_stock >= self.healthy_stock_for_exploitation_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_317(BaseStrategy):
    """
    The "Calculated Predator" strategy for the Common Pool Resource game.
    It defaults to defection for immediate gain but strategically cooperates
    to preserve the resource when its own future exploitation is threatened,
    and opponents show a willingness to cooperate. It never acts as a "sucker"
    if resource collapse is inevitable due to others' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = game_description.n_players
        capacity = game_description.capacity
        self.S_low_warning_threshold: float = capacity / 2.0
        self.S_critical_collapse_threshold: float = 2.0 * n
        self.ODR_reaction_threshold: float = 0.6
        self.ODR_consideration_window: int = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n = self.game_description.n_players
        if current_round_0_indexed == 0:
            return Action.D
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        effective_window = min(self.ODR_consideration_window, current_round_0_indexed)
        relevant_opponent_actions = history.opponent_actions[-effective_window:]
        total_opponent_defections = np.sum(~relevant_opponent_actions)
        total_opponent_observations = effective_window * (n - 1)
        ODR_avg = 0.0
        if total_opponent_observations > 0:
            ODR_avg = total_opponent_defections / total_opponent_observations
        if current_stock <= self.S_critical_collapse_threshold:
            if ODR_avg > self.ODR_reaction_threshold:
                return Action.D
            else:
                return Action.C
        elif current_stock <= self.S_low_warning_threshold:
            if ODR_avg > self.ODR_reaction_threshold:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_318(BaseStrategy):
    """
    The Selfish Steward strategy prioritizes its own long-term payoff by maximizing immediate gains
    when possible, but cooperates reluctantly and conditionally when the common resource is
    critically endangered and others demonstrate a willingness to preserve it.
    This ensures there's still something left for the "Selfish Steward" to exploit in future rounds.

    Decision Rules:
    1.  Endgame (Last Round): Always Defect ('D') to maximize immediate payoff, as there are no future consequences.
    2.  Initial Round (First Round): Always Defect ('D') to grab an early high payoff and test opponent reactions.
    3.  Adaptive Play (Other Rounds):
        -   Default action is Defect ('D').
        -   Only considers Cooperating ('C') if BOTH conditions are met:
            a.  The current stock level is below a 'critical_stock_level' (capacity / 2.0).
            b.  A 'sufficient' number of other players (at least half of them) cooperated in the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        opponent_actions_last_round = history.opponent_actions[current_round_0_indexed - 1, :]
        num_other_cooperators_last_round = np.sum(opponent_actions_last_round)
        required_cooperators_for_my_cooperation = math.ceil((n_players - 1) / 2.0)
        critical_stock_level = capacity / 2.0
        action_to_take = Action.D
        if current_stock < critical_stock_level:
            if num_other_cooperators_last_round >= required_cooperators_for_my_cooperation:
                action_to_take = Action.C
        return action_to_take

class Strategy_EXPLOITATIVE_319(BaseStrategy):
    """
    The Opportunistic Predator strategy aims to maximize its own cumulative payoff
    by primarily defecting, exploiting cooperative opponents, and only resorting
    to cooperation when necessary to prevent the immediate collapse of the common
    pool resource, thereby preserving future opportunities for exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.HIGH_STOCK_THRESHOLD = self.capacity * 0.75
        self.MODERATE_STOCK_THRESHOLD = self.capacity * 0.25
        self.LOW_STOCK_THRESHOLD = self.capacity / (2 * self.n)
        self.CRITICAL_ROUND_THRESHOLD = 2
        self.LONG_TERM_ROUNDS_THRESHOLD = 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.r:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        num_opponents = self.n - 1
        if num_opponents == 0:
            opponent_defection_rate_last_round = 0.0
        else:
            num_opponent_defectors = np.sum(~history.opponent_actions[-1, :])
            opponent_defection_rate_last_round = num_opponent_defectors / num_opponents
        if current_stock >= self.HIGH_STOCK_THRESHOLD:
            return Action.D
        elif current_stock < self.LOW_STOCK_THRESHOLD:
            rounds_remaining = self.r - current_round_1_indexed
            if rounds_remaining > self.CRITICAL_ROUND_THRESHOLD:
                return Action.C
            else:
                return Action.D
        elif opponent_defection_rate_last_round <= 0.5:
            return Action.D
        else:
            rounds_remaining = self.r - current_round_1_indexed
            if rounds_remaining > self.LONG_TERM_ROUNDS_THRESHOLD:
                if current_stock < self.MODERATE_STOCK_THRESHOLD:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_320(BaseStrategy):
    """
    Greedy Stock Strategist: An exploitative strategy for the Common Pool Resource game.
    It prioritizes individual payoff maximization, strategically cooperating only when
    complete resource collapse directly threatens its own future earnings.
    Decisions are based on projections of stock health under different action choices.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def _calculate_next_stock(self, current_stock_S: float, total_consumption_val: float, capacity_val: float) -> float:
        """
        Calculates the next round's stock level based on current stock, total consumption, and capacity.
        Implements the stock dynamics specified in the game rules.
        """
        stock_after_consumption = max(0.0, current_stock_S - total_consumption_val)
        growth = 0.0
        if stock_after_consumption > 0:
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity_val)
        new_stock = min(stock_after_consumption + growth, capacity_val)
        return new_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == n_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        num_other_cooperators_prev_round = np.sum(history.opponent_actions[-1, :])
        num_other_defectors_prev_round = n_players - 1 - num_other_cooperators_prev_round
        others_consumption_base = num_other_cooperators_prev_round * (current_stock / (2 * n_players)) + num_other_defectors_prev_round * (current_stock / n_players)
        my_consumption_D = current_stock / n_players
        total_consumption_D = my_consumption_D + others_consumption_base
        projected_next_stock_D = self._calculate_next_stock(current_stock, total_consumption_D, capacity)
        my_consumption_C = current_stock / (2 * n_players)
        total_consumption_C = my_consumption_C + others_consumption_base
        projected_next_stock_C = self._calculate_next_stock(current_stock, total_consumption_C, capacity)
        critical_stock_threshold = 0.1 * capacity
        significance_factor = 1.5
        min_viable_increase = 0.05 * capacity
        if projected_next_stock_D > critical_stock_threshold:
            return Action.D
        elif projected_next_stock_C > projected_next_stock_D * significance_factor and projected_next_stock_C - projected_next_stock_D > min_viable_increase:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_321(BaseStrategy):
    """
    The "Adaptive Predator" strategy is designed to be highly exploitative, prioritizing immediate gains
    while adaptively managing the risk of resource collapse. It aims to extract as much as possible
    from the common pool, cooperating only when strictly necessary to ensure the resource remains
    viable for future exploitation, or to avoid total collapse when its own cooperation can make a difference.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_COLLAPSE_THRESHOLD = max(1.0, 0.05 * self.capacity)
        self.BELOW_OPTIMAL_GROWTH_THRESHOLD = self.capacity / 2.0
        self.HIGH_OPPONENT_DEFECTION_RATE = 0.6

    def _predict_new_stock(self, current_S: float, total_consumption: float) -> float:
        """
        Helper method to calculate the new stock level after consumption and growth,
        following the game's stock dynamics rules.
        """
        S_remaining = current_S - total_consumption
        S_remaining = max(0.0, S_remaining)
        growth = 2.0 * S_remaining * (1.0 - S_remaining / self.capacity)
        new_stock = min(S_remaining + growth, self.capacity)
        return new_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.r - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        else:
            num_opponent_cooperators_prev_round = history.opponent_actions[-1, :].sum()
            num_opponent_defectors_prev_round = self.n - 1 - num_opponent_cooperators_prev_round
            my_defection_consumption = current_stock / self.n
            opponent_defection_consumption_sum = num_opponent_defectors_prev_round * (current_stock / self.n)
            opponent_cooperation_consumption_sum = num_opponent_cooperators_prev_round * (current_stock / (2 * self.n))
            estimated_total_consumption_if_I_D = opponent_defection_consumption_sum + opponent_cooperation_consumption_sum + my_defection_consumption
            hypothetical_new_stock_if_I_D = self._predict_new_stock(current_stock, estimated_total_consumption_if_I_D)
            if hypothetical_new_stock_if_I_D <= self.CRITICAL_COLLAPSE_THRESHOLD:
                my_cooperation_consumption = current_stock / (2 * self.n)
                estimated_total_consumption_if_I_C = opponent_defection_consumption_sum + opponent_cooperation_consumption_sum + my_cooperation_consumption
                hypothetical_new_stock_if_I_C = self._predict_new_stock(current_stock, estimated_total_consumption_if_I_C)
                if hypothetical_new_stock_if_I_C <= self.CRITICAL_COLLAPSE_THRESHOLD:
                    return Action.D
                else:
                    return Action.C
            elif current_stock <= self.BELOW_OPTIMAL_GROWTH_THRESHOLD and hypothetical_new_stock_if_I_D < current_stock:
                opponent_defection_rate = num_opponent_defectors_prev_round / (self.n - 1)
                if opponent_defection_rate > self.HIGH_OPPONENT_DEFECTION_RATE:
                    return Action.D
                else:
                    my_cooperation_consumption = current_stock / (2 * self.n)
                    estimated_total_consumption_if_I_C = opponent_defection_consumption_sum + opponent_cooperation_consumption_sum + my_cooperation_consumption
                    hypothetical_new_stock_if_I_C = self._predict_new_stock(current_stock, estimated_total_consumption_if_I_C)
                    if hypothetical_new_stock_if_I_C >= current_stock:
                        return Action.C
                    else:
                        return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_322(BaseStrategy):
    """
    The "Calculated Exploiter" strategy prioritizes immediate personal gain by defecting,
    while maintaining a vigilant watch over the common resource. It only cooperates when a
    calculated self-interested assessment shows that continued defection will lead to a
    resource collapse so severe it jeopardizes its own future payoffs, and its cooperation
    can meaningfully avert or mitigate this collapse. It adapts by using past observed
    actions of other players to inform its decision-making.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.ABUNDANT_STOCK_THRESHOLD = 0.75 * self.capacity
        self.CRITICAL_COLLAPSE_THRESHOLD_D_ME = 0.05 * self.capacity
        self.RECOVERABLE_STOCK_THRESHOLD_C_ME = 0.15 * self.capacity
        self.SUBSTANTIAL_DIFFERENCE_THRESHOLD = self.capacity / (2 * self.n_players)

    def _calculate_next_stock(self, current_S: float, total_C: float) -> float:
        """
        Helper function to calculate the new stock level after consumption and growth.
        This function uses the game's stock dynamics rules.
        """
        S_remaining = current_S - total_C
        if S_remaining < 0:
            S_remaining = 0.0
        if self.capacity == 0:
            growth = 0.0
        else:
            growth = 2 * S_remaining * (1 - S_remaining / self.capacity)
        new_stock = min(S_remaining + growth, self.capacity)
        return new_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == self.total_rounds - 1:
            return Action.D
        if current_round_number == 0:
            return Action.D
        if current_stock >= self.ABUNDANT_STOCK_THRESHOLD:
            return Action.D
        previous_round_index = current_round_number - 1
        opponent_prev_actions = history.opponent_actions[previous_round_index, :]
        num_defectors_others_prev_round = np.sum(~opponent_prev_actions)
        num_cooperators_others_prev_round = np.sum(opponent_prev_actions)
        consumption_by_others = num_defectors_others_prev_round * current_stock / self.n_players + num_cooperators_others_prev_round * current_stock / (2 * self.n_players)
        my_consumption_if_D = current_stock / self.n_players
        total_consumption_if_I_D = consumption_by_others + my_consumption_if_D
        S_next_D_me = self._calculate_next_stock(current_stock, total_consumption_if_I_D)
        my_consumption_if_C = current_stock / (2 * self.n_players)
        total_consumption_if_I_C = consumption_by_others + my_consumption_if_C
        S_next_C_me = self._calculate_next_stock(current_stock, total_consumption_if_I_C)
        condition_1_D_critical = S_next_D_me < self.CRITICAL_COLLAPSE_THRESHOLD_D_ME
        condition_2_C_recoverable = S_next_C_me > self.RECOVERABLE_STOCK_THRESHOLD_C_ME
        condition_3_C_substantial_diff = S_next_C_me > S_next_D_me + self.SUBSTANTIAL_DIFFERENCE_THRESHOLD
        if condition_1_D_critical and condition_2_C_recoverable and condition_3_C_substantial_diff:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_323(BaseStrategy):
    """
    Opportunistic Predator: An exploitative, adaptive, and robust strategy for the
    Common Pool Resource game. It defaults to defection for immediate gain but
    will strategically cooperate to prevent resource collapse if it perceives
    a long-term self-serving benefit, adapting to opponent behavior and game state.
    In the endgame, all pretense of preservation is dropped for maximum extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.MIN_VIABLE_STOCK_RATIO = 0.25
        self.OPPONENT_COOPERATION_REQUIRED_RATIO = 0.5
        self.MIN_ROUNDS_FOR_RECOVERY = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        num_players = self.game_description.n_players
        capacity = float(self.game_description.capacity)
        min_viable_stock = capacity * self.MIN_VIABLE_STOCK_RATIO
        min_cooperators_for_recovery = math.ceil((num_players - 1) * self.OPPONENT_COOPERATION_REQUIRED_RATIO)
        enough_rounds_for_recovery = total_rounds - current_round_0_indexed >= self.MIN_ROUNDS_FOR_RECOVERY
        if current_round_0_indexed >= total_rounds - 2:
            return Action.D
        num_opponent_defectors_last_round = 0
        num_opponent_cooperators_last_round = 0
        if history is not None:
            opponent_actions_last_round = history.opponent_actions[current_round_0_indexed - 1, :]
            num_opponent_cooperators_last_round = np.sum(opponent_actions_last_round == True)
            num_opponent_defectors_last_round = np.sum(opponent_actions_last_round == False)
        else:
            num_opponent_defectors_last_round = 0
            num_opponent_cooperators_last_round = num_players - 1
        if current_stock < min_viable_stock:
            if num_opponent_cooperators_last_round >= min_cooperators_for_recovery and enough_rounds_for_recovery:
                return Action.C
            else:
                return Action.D
        consumption_fraction_C = 1.0 / (2.0 * num_players)
        consumption_fraction_D = 1.0 / num_players
        my_consumption_if_defect = current_stock * consumption_fraction_D
        opponent_consumption = num_opponent_defectors_last_round * (current_stock * consumption_fraction_D) + num_opponent_cooperators_last_round * (current_stock * consumption_fraction_C)
        projected_total_consumption_if_i_defect = my_consumption_if_defect + opponent_consumption
        projected_S_remaining = current_stock - projected_total_consumption_if_i_defect
        projected_S_remaining = max(0.0, projected_S_remaining)
        projected_growth = 2.0 * projected_S_remaining * (1.0 - projected_S_remaining / capacity)
        projected_new_stock_if_i_defect = min(projected_S_remaining + projected_growth, capacity)
        if projected_new_stock_if_i_defect < min_viable_stock and enough_rounds_for_recovery:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_324(BaseStrategy):
    """
    Adaptive Predator strategy: Aims to maximize extraction by defaulting to defection,
    but with sophisticated safeguards to prevent resource collapse. It adapts based
    on current stock levels and a prediction of the next round's stock given
    opponents' recent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_threshold = self.capacity / 4.0
        self.low_stock_threshold = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number + 1
        current_stock = state.current_stock
        if current_round_t == 1:
            return Action.D
        if current_round_t == self.n_rounds:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        num_other_cooperators = np.sum(previous_round_opponent_actions).item()
        num_other_defectors = self.n_players - 1 - num_other_cooperators
        my_D_consumption = current_stock / self.n_players
        others_consumption_if_repeat = num_other_cooperators * (current_stock / (2.0 * self.n_players)) + num_other_defectors * (current_stock / self.n_players)
        total_hypothetical_consumption = my_D_consumption + others_consumption_if_repeat
        hypothetical_S_remaining = max(0.0, current_stock - total_hypothetical_consumption)
        hypothetical_growth = 2.0 * hypothetical_S_remaining * (1.0 - hypothetical_S_remaining / self.capacity)
        hypothetical_next_stock = min(hypothetical_S_remaining + hypothetical_growth, self.capacity)
        if current_stock < self.critical_stock_threshold:
            return Action.C
        elif current_stock < self.low_stock_threshold:
            if hypothetical_next_stock < self.critical_stock_threshold:
                return Action.C
            else:
                return Action.D
        elif hypothetical_next_stock < self.critical_stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_325(BaseStrategy):
    """
    The Adaptive Greedy Predator strategy is designed to maximize a player's total payoff over the
    entire game by defaulting to exploitative behavior (Defect) whenever possible, but adapting
    its actions to prevent the common resource from collapsing, which would ultimately harm its
    own long-term gains. It learns from past rounds' collective consumption patterns to
    anticipate resource depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_stock_threshold = self.capacity / 4.0
        self._strategy_history = []
        self._prev_round_start_stock = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t_1_indexed = state.round_number + 1
        current_stock_S = state.current_stock
        if state.round_number > 0 and len(self._strategy_history) == state.round_number - 1:
            prev_round_idx = state.round_number - 1
            stock_at_start_of_prev_round = self._prev_round_start_stock
            total_consumption_observed_prev = 0.0
            if stock_at_start_of_prev_round > 0:
                prev_round_my_action_is_cooperate = history.my_actions[prev_round_idx]
                prev_round_opponent_actions_are_cooperate = history.opponent_actions[prev_round_idx, :]
                num_C_prev = sum(prev_round_opponent_actions_are_cooperate) + (1 if prev_round_my_action_is_cooperate else 0)
                num_D_prev = self.n - num_C_prev
                total_consumption_observed_prev = stock_at_start_of_prev_round * (self.n + num_D_prev) / (2.0 * self.n)
            self._strategy_history.append({'stock_start': stock_at_start_of_prev_round, 'total_consumption': total_consumption_observed_prev})
        self._prev_round_start_stock = current_stock_S
        if current_round_t_1_indexed == self.r:
            return Action.D
        if state.round_number == 0:
            return Action.D
        prev_round_entry = self._strategy_history[-1]
        stock_at_start_of_prev_round_for_kD = prev_round_entry['stock_start']
        total_consumption_observed_prev_for_kD = prev_round_entry['total_consumption']
        k_D_prev = 0
        if stock_at_start_of_prev_round_for_kD > 0:
            k_D_estimate = 2.0 * self.n * total_consumption_observed_prev_for_kD / stock_at_start_of_prev_round_for_kD - self.n
            k_D_prev = round(max(0, min(self.n, k_D_estimate)))
        else:
            k_D_prev = self.n
        if current_stock_S < self.critical_stock_threshold:
            return Action.C
        estimated_defecting_players_this_round = min(self.n, k_D_prev + 1)
        S_next_if_I_D_est = 0.0
        if current_stock_S > 0:
            total_consumption_if_I_D = current_stock_S * (self.n + estimated_defecting_players_this_round) / (2.0 * self.n)
            S_after_my_D_consumption = current_stock_S - total_consumption_if_I_D
            S_after_my_D_consumption = max(0.0, S_after_my_D_consumption)
            S_after_my_D_growth = 2.0 * S_after_my_D_consumption * (1.0 - S_after_my_D_consumption / self.capacity)
            S_next_if_I_D_est = min(S_after_my_D_consumption + S_after_my_D_growth, self.capacity)
        else:
            S_next_if_I_D_est = 0.0
        if S_next_if_I_D_est < self.critical_stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_326(BaseStrategy):
    """
    The "Adaptive Predator" strategy maximizes individual payoff in the Common Pool Resource
    game by aggressively pursuing immediate gains, free-riding on others' cooperation,
    and only engaging in strategic, temporary cooperation when absolutely necessary
    to prevent a total resource collapse that would eliminate future exploitation opportunities.
    It is adaptive to both the state of the common resource and the observed behavior of other players.
    """
    CRITICAL_STOCK_RATIO: float
    COOPERATION_THRESHOLD_FOR_EXPLOIT: float
    MIN_COOPERATION_TO_SAVE_RESOURCE: float

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Predator strategy with game parameters and its specific thresholds.
        """
        self.game_description = game_description
        self.CRITICAL_STOCK_RATIO = 0.25
        self.COOPERATION_THRESHOLD_FOR_EXPLOIT = 0.6
        self.MIN_COOPERATION_TO_SAVE_RESOURCE = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round
        based on the Adaptive Predator strategy logic.
        """
        current_round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_round_number == 0:
            return Action.D
        if current_round_number == total_rounds - 1:
            return Action.D
        k_prev = sum(history.opponent_actions[-1, :])
        stock_ratio = current_stock / capacity
        if stock_ratio < self.CRITICAL_STOCK_RATIO:
            if k_prev / n_players > self.MIN_COOPERATION_TO_SAVE_RESOURCE:
                return Action.C
            else:
                return Action.D
        elif k_prev / n_players >= self.COOPERATION_THRESHOLD_FOR_EXPLOIT:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_327(BaseStrategy):
    """
    The "Adaptive Predation" strategy for the Common Pool Resource game.
    It defaults to defecting (D) to maximize immediate payoff but monitors
    resource health and opponent behavior to strategically cooperate when
    resource depletion threatens future exploitation. It adapts its aggression
    based on observed opponent cooperation and the remaining rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_recovery_buffer = max(self.capacity / (4 * self.r), 2 * self.n)
        self.cooperation_memory = 5
        self.defection_streak_threshold = 3
        self.opponent_cooperation_rate_history: list[float] = []
        self.consecutive_majority_defections = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        P_coop = 0.2
        if current_round_0_indexed > 0 and history is not None:
            k_actual_coop_prev_round = sum(history.opponent_actions[current_round_0_indexed - 1, :])
            self.opponent_cooperation_rate_history.append(k_actual_coop_prev_round / (self.n - 1))
            start_idx = max(0, len(self.opponent_cooperation_rate_history) - self.cooperation_memory)
            P_coop_history_slice = self.opponent_cooperation_rate_history[start_idx:]
            if P_coop_history_slice:
                P_coop = sum(P_coop_history_slice) / len(P_coop_history_slice)
        if current_round_0_indexed == self.r - 1:
            return Action.D
        if current_stock <= self.stock_recovery_buffer:
            return Action.C
        if current_round_0_indexed > 0 and history is not None:
            k_actual_coop_prev_round = sum(history.opponent_actions[current_round_0_indexed - 1, :])
            if k_actual_coop_prev_round / (self.n - 1) < 0.5:
                self.consecutive_majority_defections += 1
            else:
                self.consecutive_majority_defections = 0
            if self.consecutive_majority_defections >= self.defection_streak_threshold and current_stock > self.capacity / 2:
                return Action.D
        k_expected_coop = (self.n - 1) * P_coop
        k_expected_defect = (self.n - 1) * (1 - P_coop)
        my_consumption_if_D = current_stock / self.n
        my_consumption_if_C = current_stock / (2 * self.n)
        consumption_by_others = k_expected_coop * current_stock / (2 * self.n) + k_expected_defect * current_stock / self.n
        ETC_if_I_D = my_consumption_if_D + consumption_by_others
        ETC_if_I_C = my_consumption_if_C + consumption_by_others
        Projected_S_rem_if_I_D = current_stock - ETC_if_I_D
        Projected_S_rem_if_I_C = current_stock - ETC_if_I_C
        if Projected_S_rem_if_I_D >= self.stock_recovery_buffer:
            return Action.D
        elif Projected_S_rem_if_I_C >= self.stock_recovery_buffer:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_328(BaseStrategy):
    """
    The "Opportunistic Predator" strategy is fundamentally greedy, aiming to extract the maximum
    possible resource in most situations. However, it incorporates a critical safeguard to prevent
    the complete collapse of the resource, ensuring there's something left to exploit in future
    rounds. It defaults to Defect (D) to maximize immediate gain, only cooperating (C) when the
    common resource is in danger of collapsing (below a critical threshold) or when it's the very
    last round and there are no future consequences to consider.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.STOCK_CRITICAL_THRESHOLD = 2.0 * self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock <= self.STOCK_CRITICAL_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_329(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize Player X's total payoff in the Common Pool Resource Game.
    It primarily focuses on exploiting opponents by defecting for immediate gain, but incorporates self-preservation
    and strategic cooperation mechanisms to prevent resource collapse or to stabilize a declining resource
    for future exploitation. It adapts based on observed opponent behavior and resource stock trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_critical_low = 2 * self.n_players
        self.observation_window_length = 3
        self.cooperation_threshold_to_exploit = 0.7
        self.defection_threshold_to_give_up = 0.8
        self.stock_decline_threshold_percent = 0.05
        self.min_rounds_for_recovery = 3
        self._past_stocks: list[float] = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_idx = state.round_number
        current_stock = state.current_stock
        self._past_stocks.append(current_stock)
        if current_round_idx == self.n_rounds - 1:
            return Action.D
        if current_stock <= self.S_critical_low:
            return Action.C
        if current_round_idx == 0:
            return Action.D
        actual_observation_rounds = min(current_round_idx, self.observation_window_length)
        num_other_player_C_actions = 0
        observation_window_start_idx_for_history = current_round_idx - actual_observation_rounds
        for r_idx in range(observation_window_start_idx_for_history, current_round_idx):
            num_other_player_C_actions += np.sum(history.opponent_actions[r_idx, :])
        total_other_player_actions = actual_observation_rounds * (self.n_players - 1)
        if total_other_player_actions == 0:
            return Action.D
        cooperation_rate_of_others = num_other_player_C_actions / total_other_player_actions
        stock_at_start_of_window = self._past_stocks[observation_window_start_idx_for_history]
        stock_decline = stock_at_start_of_window - current_stock
        is_stock_rapidly_declining = stock_decline > self.capacity * self.stock_decline_threshold_percent
        if cooperation_rate_of_others >= self.cooperation_threshold_to_exploit:
            return Action.D
        if cooperation_rate_of_others <= 1 - self.defection_threshold_to_give_up:
            return Action.D
        rounds_remaining_after_current = self.n_rounds - 1 - current_round_idx
        if is_stock_rapidly_declining and rounds_remaining_after_current >= self.min_rounds_for_recovery:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_330(BaseStrategy):
    """
    Opportunistic Predator strategy for the Common Pool Resource game.
    Maximizes individual payoff by defaulting to Defect (D) unless specific conditions
    indicate that a temporary Cooperator (C) stance is necessary to preserve the resource
    for future exploitation, or in the very last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / (2 * self.n_players)
        self.SIGNIFICANT_DIFFERENCE_THRESHOLD = self.capacity / (4 * self.n_players)
        self.MIN_ROUNDS_FOR_RECOVERY_BENEFIT = 3

    def _predict_next_stock(self, S_current: float, num_cooperators_total: int, num_defectors_total: int) -> float:
        """
        Helper function to predict the next round's stock based on current stock and assumed actions.
        """
        coop_consumption = num_cooperators_total * S_current / (2 * self.n_players)
        defect_consumption = num_defectors_total * S_current / self.n_players
        total_consumption = coop_consumption + defect_consumption
        S_after_consumption = S_current - total_consumption
        S_after_consumption = max(0.0, S_after_consumption)
        growth = 2 * S_after_consumption * (1 - S_after_consumption / self.capacity)
        S_next = min(S_after_consumption + growth, self.capacity)
        return S_next

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        elif current_round_0_indexed == 0:
            return Action.D
        else:
            actions_in_prev_round = history.opponent_actions[current_round_0_indexed - 1, :]
            num_other_cooperators_prev_round = int(np.sum(actions_in_prev_round))
            num_other_defectors_prev_round = self.n_players - 1 - num_other_cooperators_prev_round
            total_cooperators_if_I_D = num_other_cooperators_prev_round
            total_defectors_if_I_D = num_other_defectors_prev_round + 1
            predicted_S_next_if_I_D = self._predict_next_stock(current_stock, total_cooperators_if_I_D, total_defectors_if_I_D)
            total_cooperators_if_I_C = num_other_cooperators_prev_round + 1
            total_defectors_if_I_C = num_other_defectors_prev_round
            predicted_S_next_if_I_C = self._predict_next_stock(current_stock, total_cooperators_if_I_C, total_defectors_if_I_C)
            rounds_remaining_to_play = self.n_rounds - (current_round_0_indexed + 1)
            if predicted_S_next_if_I_D <= self.CRITICAL_STOCK_THRESHOLD and predicted_S_next_if_I_C > self.CRITICAL_STOCK_THRESHOLD + self.SIGNIFICANT_DIFFERENCE_THRESHOLD and (rounds_remaining_to_play >= self.MIN_ROUNDS_FOR_RECOVERY_BENEFIT) and (num_other_cooperators_prev_round > 0):
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_331(BaseStrategy):
    """
    The "Opportunistic Predator" strategy is designed to maximize its own total payoff over the course of the game,
    leveraging immediate gains whenever possible while implementing calculated cooperation only to prevent the collapse
    of the common resource or when its individual defection would put it at risk. It adapts to the current state of
    the resource and the observed behavior of other players, aiming to be exploitative and robust in a tournament setting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_critical_threshold = self.capacity / (2.0 * self.n)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.D
        if current_round_1_indexed == self.r:
            return Action.D
        if current_stock < self.S_critical_threshold:
            return Action.C
        else:
            num_my_defect_prev_round = 1 if not history.my_actions[-1] else 0
            num_opponent_defect_prev_round = np.sum(~history.opponent_actions[-1, :])
            k_prev = num_my_defect_prev_round + num_opponent_defect_prev_round
            if k_prev == 0:
                return Action.D
            elif k_prev >= self.n / 2.0:
                return Action.D
            else:
                opponents_who_defect_again = np.sum(~history.opponent_actions[-1, :])
                num_defectors_in_current_round = opponents_who_defect_again + 1
                num_cooperators_in_current_round = self.n - num_defectors_in_current_round
                consumption_by_defector_per_player = current_stock / self.n
                consumption_by_cooperator_per_player = current_stock / (2.0 * self.n)
                total_consumption_if_I_D = num_defectors_in_current_round * consumption_by_defector_per_player + num_cooperators_in_current_round * consumption_by_cooperator_per_player
                S_remaining_if_I_D = max(0.0, current_stock - total_consumption_if_I_D)
                growth_if_I_D = 2.0 * S_remaining_if_I_D * (1.0 - S_remaining_if_I_D / self.capacity)
                projected_next_stock_if_I_D = min(S_remaining_if_I_D + growth_if_I_D, self.capacity)
                if projected_next_stock_if_I_D >= self.S_critical_threshold:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_332(BaseStrategy):
    """
    The Adaptive Opportunist strategy defects aggressively to maximize immediate payoffs.
    It cooperates only if the resource is critically endangered AND there's a clear signal
    from other players that cooperation has a chance of success. Otherwise, it continues
    exploiting or matching defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        num_players = self.game_description.n_players
        CRITICAL_STOCK_THRESHOLD = capacity / 4.0
        COOPERATION_SIGNAL_THRESHOLD_DEFECTION_RATE = 0.5
        if current_round == 0:
            return Action.D
        if current_round == total_rounds - 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        previous_defection_count = num_players - np.sum(previous_round_opponent_actions)
        previous_defection_rate = previous_defection_count / num_players
        if current_stock < CRITICAL_STOCK_THRESHOLD:
            if previous_defection_rate <= COOPERATION_SIGNAL_THRESHOLD_DEFECTION_RATE:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_333(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize personal payoff by defaulting to defection,
    but adapts to prevent resource collapse in critical situations and to exploit cooperative
    opponents, while avoiding being a "sucker" against consistent defectors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_defection_streak = 0
        self.recent_opponent_cooperation_counts = []
        self.EMERGENCY_STOCK_THRESHOLD_RATIO = 0.15
        self.EMERGENCY_ROUNDS_REMAINING_MIN = 3
        self.EMERGENCY_COOPERATION_HOPE_THRESHOLD = 0.1
        self.EXPLOIT_HIGH_COOPERATION_RATE = 0.6
        self.PUNISH_DEFECTION_CONSECUTIVE_ROUNDS = 2
        self.MEMORY_ROUNDS = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number + 1
        if t == 1:
            self.opponent_defection_streak = 0
            self.recent_opponent_cooperation_counts = []
            return Action.D
        if t == self.game_description.n_rounds:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        k_prev_last_round = sum(previous_round_opponent_actions)
        if k_prev_last_round == 0:
            self.opponent_defection_streak += 1
        else:
            self.opponent_defection_streak = 0
        self.recent_opponent_cooperation_counts.append(k_prev_last_round)
        if len(self.recent_opponent_cooperation_counts) > self.MEMORY_ROUNDS:
            self.recent_opponent_cooperation_counts.pop(0)
        total_cooperation_in_recent = sum(self.recent_opponent_cooperation_counts)
        num_opponents = self.game_description.n_players - 1
        num_possible_opponent_actions = len(self.recent_opponent_cooperation_counts) * num_opponents
        avg_opponent_cooperation_rate = 0.0
        if num_possible_opponent_actions > 0:
            avg_opponent_cooperation_rate = total_cooperation_in_recent / num_possible_opponent_actions
        rounds_remaining = self.game_description.n_rounds - t
        if state.current_stock / self.game_description.capacity < self.EMERGENCY_STOCK_THRESHOLD_RATIO and rounds_remaining >= self.EMERGENCY_ROUNDS_REMAINING_MIN and (avg_opponent_cooperation_rate > self.EMERGENCY_COOPERATION_HOPE_THRESHOLD):
            return Action.C
        if avg_opponent_cooperation_rate >= self.EXPLOIT_HIGH_COOPERATION_RATE:
            return Action.D
        if self.opponent_defection_streak >= self.PUNISH_DEFECTION_CONSECUTIVE_ROUNDS:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_334(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its own total payoff by aggressively defecting
    but adapting its behavior to prevent resource collapse. It estimates the defection probability
    of other players and only cooperates when its own defection would lead to the resource
    falling below a critical preservation threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.alpha = 0.5
        self.defection_prob_others = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.r - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        num_defecting_others = (history.opponent_actions[-1, :] == False).sum()
        observed_defection_rate = num_defecting_others / (self.n - 1)
        self.defection_prob_others = (1 - self.alpha) * self.defection_prob_others + self.alpha * observed_defection_rate
        k_defectors = round((self.n - 1) * self.defection_prob_others)
        k_defectors = max(0, min(k_defectors, self.n - 1))
        k_cooperators = self.n - 1 - k_defectors
        my_consumption_if_D = current_stock / self.n
        others_consumption_if_I_D = k_defectors * current_stock / self.n + k_cooperators * current_stock / (2 * self.n)
        total_estimated_consumption_if_I_D = my_consumption_if_D + others_consumption_if_I_D
        S_remaining_if_I_defect = current_stock - total_estimated_consumption_if_I_D
        STOCK_PRESERVATION_THRESHOLD = max(0.5, self.capacity / (4 * self.n))
        if S_remaining_if_I_defect <= 0:
            action = Action.C
        elif S_remaining_if_I_defect < STOCK_PRESERVATION_THRESHOLD:
            action = Action.C
        else:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_335(BaseStrategy):
    """
    The Opportunistic Apex Predator strategy for the Common Pool Resource Game.
    This strategy embodies an aggressively self-interested approach. It defaults to
    exploiting the resource (defecting) whenever possible, only cooperating in
    extreme circumstances where its own long-term payoff is critically threatened
    AND a clear collective effort from others makes cooperation a strategic,
    self-serving move to preserve future exploitation opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.END_GAME_HORIZON = 2
        self.COOPERATION_SIGNAL_THRESHOLD = 0.75
        self.RESOURCE_CRITICAL_THRESHOLD_FRACTION = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed >= self.n_rounds - self.END_GAME_HORIZON + 1:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        num_opponents = self.n_players - 1
        opponent_defection_rate = 0.0
        if num_opponents > 0:
            num_opponents_cooperated_last_round = np.sum(history.opponent_actions[-1, :])
            num_opponents_defected_last_round = num_opponents - num_opponents_cooperated_last_round
            opponent_defection_rate = num_opponents_defected_last_round / num_opponents
        if current_stock < self.capacity * self.RESOURCE_CRITICAL_THRESHOLD_FRACTION:
            if opponent_defection_rate <= 1 - self.COOPERATION_SIGNAL_THRESHOLD:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_336(BaseStrategy):
    """
    The Opportunistic Conserver strategy is highly exploitative, prioritizing its own total payoff
    over the entire game. It dynamically adapts to opponent behavior and resource levels,
    defaulting to defecting (taking maximum immediate payoff). It incorporates robust mechanisms
    to prevent the common resource from collapsing, as a depleted resource would ultimately lead
    to zero future payoffs for itself. It aims to exploit cooperative opponents and strategically
    conserve when necessary to ensure long-term harvesting potential.
    """
    COOPERATION_THRESHOLD_RATIO = 0.5
    LOW_STOCK_THRESHOLD_RATIO = 0.3
    CRITICAL_DEPLETION_BUFFER_RATIO = 0.1
    ABUNDANT_STOCK_RATIO = 0.75

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.
        """
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round.
        """
        current_game_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_game_round_0_indexed == self.n_rounds - 1:
            return Action.D
        num_C_prev_round = 0
        num_opponents = self.n_players - 1
        if current_game_round_0_indexed == 0:
            num_C_prev_round = int(num_opponents * self.COOPERATION_THRESHOLD_RATIO)
        else:
            num_C_prev_round = np.sum(history.opponent_actions[-1, :])
        coop_ratio = num_C_prev_round / num_opponents
        my_decision = Action.D
        my_consumption_if_I_D = current_stock / self.n_players
        estimated_opp_D = num_opponents - num_C_prev_round
        estimated_opp_C = num_C_prev_round
        estimated_opp_consumption = estimated_opp_C * current_stock / (2 * self.n_players) + estimated_opp_D * current_stock / self.n_players
        estimated_total_consumption_if_I_D = my_consumption_if_I_D + estimated_opp_consumption
        projected_S_after_consumption = current_stock - estimated_total_consumption_if_I_D
        if projected_S_after_consumption <= current_stock * self.CRITICAL_DEPLETION_BUFFER_RATIO:
            my_decision = Action.C
        elif current_stock < self.ABUNDANT_STOCK_RATIO * self.capacity:
            if coop_ratio < self.COOPERATION_THRESHOLD_RATIO:
                my_decision = Action.C
            elif current_stock < self.LOW_STOCK_THRESHOLD_RATIO * self.capacity:
                my_decision = Action.C
        return my_decision

class Strategy_EXPLOITATIVE_337(BaseStrategy):
    """
    Opportunistic Stock Predator: Defaults to defection for immediate payoff,
    cooperating only to prevent critical resource depletion or ensure future
    exploitation viability. Always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.min_survival_stock_threshold = self.capacity / (2.0 * self.n * self.n)
        self.critical_growth_threshold = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.r:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        else:
            num_other_C_last_round = np.sum(history.opponent_actions[-1, :])
            num_other_D_last_round = self.n - 1 - num_other_C_last_round
            my_consumption_D = current_stock / self.n
            my_consumption_C = current_stock / (2.0 * self.n)
            others_consumption = num_other_D_last_round * current_stock / self.n + num_other_C_last_round * current_stock / (2.0 * self.n)
            total_consumption_if_I_D = my_consumption_D + others_consumption
            S_remaining_if_I_D = current_stock - total_consumption_if_I_D
            total_consumption_if_I_C = my_consumption_C + others_consumption
            S_remaining_if_I_C = current_stock - total_consumption_if_I_C
            if S_remaining_if_I_D < self.min_survival_stock_threshold:
                return Action.C
            elif S_remaining_if_I_C < self.min_survival_stock_threshold:
                return Action.C
            elif S_remaining_if_I_D < self.critical_growth_threshold and current_stock < self.critical_growth_threshold * 1.2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_338(BaseStrategy):
    """
    The "Adaptive Predator" strategy defaults to defection for immediate maximal gain,
    but reluctantly cooperates only when the resource is critically endangered by
    widespread defection, with the aim of preserving it for future exploitation.
    It leverages observed opponent behavior and the current state of the common pool.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_RATIO = 0.25
        self.HIGH_STOCK_RATIO = 0.75
        self.DEFECTION_TOLERANCE_RATIO = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == total_rounds - 1:
            return Action.D
        if current_stock >= capacity * self.HIGH_STOCK_RATIO:
            return Action.D
        if current_stock < capacity * self.CRITICAL_STOCK_RATIO:
            if history is not None:
                previous_round_opponent_actions = history.opponent_actions[current_round - 1, :]
                num_others_D = 0
                for action_bool in previous_round_opponent_actions:
                    if not action_bool:
                        num_others_D += 1
                n_minus_1 = n_players - 1
                defection_rate_others = num_others_D / n_minus_1
                if defection_rate_others >= self.DEFECTION_TOLERANCE_RATIO:
                    return Action.C
                else:
                    return Action.D
            pass
        return Action.D

class Strategy_EXPLOITATIVE_339(BaseStrategy):
    """
    The Last Drop Harvester strategy: Prioritizes maximizing its own total payoff over all rounds.
    It defaults to aggressive exploitation (Defect) and only cooperates under very specific,
    self-serving conditions where its own cooperation is crucial to prevent the resource
    from becoming completely unusable for *its own* future extraction.

    This strategy assumes standard game theory conditions: perfect information, common knowledge,
    simultaneous actions, repeated interaction, and no communication. It cannot rely on others
    sharing norms or coordinating.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number + 1
        current_stock = state.current_stock
        if current_round == 1:
            return Action.D
        if current_round == self.total_rounds:
            return Action.D
        if current_stock <= 0:
            return Action.D
        opponent_actions_prev_round = history.opponent_actions[-1, :]
        N_C_prev = np.sum(opponent_actions_prev_round)
        N_D_prev = self.n_players - 1 - N_C_prev
        my_C_consumption = current_stock / (2 * self.n_players)
        my_D_consumption = current_stock / self.n_players
        others_consumption_pred = N_C_prev * my_C_consumption + N_D_prev * my_D_consumption

        def _calculate_next_stock_level(current_S: float, total_consumption: float, capacity: float) -> float:
            S_remaining = max(0.0, current_S - total_consumption)
            growth = 2 * S_remaining * (1 - S_remaining / capacity)
            return min(S_remaining + growth, capacity)
        total_consumption_if_I_D = my_D_consumption + others_consumption_pred
        S_next_projected_if_I_D = _calculate_next_stock_level(current_stock, total_consumption_if_I_D, self.capacity)
        total_consumption_if_I_C = my_C_consumption + others_consumption_pred
        S_next_projected_if_I_C = _calculate_next_stock_level(current_stock, total_consumption_if_I_C, self.capacity)
        CRITICAL_COLLAPSE_THRESHOLD = float(self.n_players)
        MIN_FUTURE_STOCK_IMPROVEMENT = my_D_consumption
        if S_next_projected_if_I_D < CRITICAL_COLLAPSE_THRESHOLD and S_next_projected_if_I_C > S_next_projected_if_I_D + MIN_FUTURE_STOCK_IMPROVEMENT and (S_next_projected_if_I_C >= CRITICAL_COLLAPSE_THRESHOLD):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_340(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its total payoff over `r` rounds
    in a Common Pool Resource game. It adopts an exploitative approach, prioritizing
    immediate gains while dynamically adjusting to opponent behaviors and the state
    of the shared resource. This strategy is designed to prevent complete resource
    collapse, which would result in zero future payoffs, thus ensuring long-term
    self-interest. It assumes no prior coordination with other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == n_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        last_round_opponent_actions = history.opponent_actions[-1, :]
        num_opponent_D = (last_round_opponent_actions == False).sum()
        num_opponent_C = (last_round_opponent_actions == True).sum()
        opponent_count = n_players - 1
        opponent_defection_rate = num_opponent_D / opponent_count
        my_consumption_if_D = current_stock / n_players
        consumption_by_opponent_Ds = num_opponent_D * (current_stock / n_players)
        consumption_by_opponent_Cs = num_opponent_C * (current_stock / (2 * n_players))
        total_projected_consumption_if_I_D = my_consumption_if_D + consumption_by_opponent_Ds + consumption_by_opponent_Cs
        projected_S_after_consumption_if_I_D = current_stock - total_projected_consumption_if_I_D
        if projected_S_after_consumption_if_I_D <= 0:
            if num_opponent_D == opponent_count:
                return Action.D
            else:
                return Action.C
        elif opponent_defection_rate == 0:
            return Action.D
        elif current_stock >= capacity / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_341(BaseStrategy):
    """
    The "Adaptive Predator" strategy: Defaults to defection,
    adapting to stock levels and opponent behavior to maximize
    own long-term gain by preventing complete resource collapse.
    It prioritizes exploitation but incorporates safety mechanisms
    to ensure the resource remains viable for future gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_absolute_threshold_ratio = 0.05
        self.conservation_kick_in_stock_ratio = 0.25
        self.high_stock_forgiveness_ratio = 0.75
        self.opponent_cooperation_threshold_ratio = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        stock = state.current_stock
        my_action = Action.D
        if current_round_0_indexed == r - 1:
            my_action = Action.D
            return my_action
        if current_round_0_indexed == 0:
            my_action = Action.D
            return my_action
        if stock < capacity * self.critical_stock_absolute_threshold_ratio:
            my_action = Action.C
            return my_action
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1]
        num_others_defecting_prev_round = np.sum(previous_round_opponent_actions == False)
        defection_ratio_others = num_others_defecting_prev_round / (n - 1)
        if defection_ratio_others <= self.opponent_cooperation_threshold_ratio:
            my_action = Action.D
        elif stock > capacity * self.high_stock_forgiveness_ratio:
            my_action = Action.D
        elif stock <= capacity * self.conservation_kick_in_stock_ratio:
            my_action = Action.C
        else:
            my_action = Action.D
        return my_action

class Strategy_EXPLOITATIVE_342(BaseStrategy):
    """
    Adaptive Exploiter with Stock Management Strategy for the Common Pool Resource Game.

    This strategy aims to maximize total payoff by primarily defecting (exploiting)
    but incorporates strategic cooperation under specific conditions:
    1.  To prevent catastrophic resource collapse: Cooperates if the stock falls
        below a critical threshold to ensure future exploitation.
    2.  To strategically "lure" or "punish" opponents: Cooperates if many opponents
        are defecting and the stock is in a mid-range state (below optimal growth
        point), aiming to encourage stock replenishment and potential future
        cooperation from others, which it can then exploit.
    Otherwise, the strategy defaults to defecting to maximize immediate individual payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.STOCK_CRITICAL_THRESHOLD = self.capacity / 3.0
        self.STOCK_LURE_THRESHOLD = self.capacity / 2.0
        self.DEFECTION_RATE_HIGH_THRESHOLD = math.ceil(self.n_players / 2.0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number == 0:
            return Action.D
        if current_round_number == self.n_rounds - 1:
            return Action.D
        total_cooperators_prev = sum(history.opponent_actions[-1, :]) + int(history.my_actions[-1])
        k_D_prev = self.n_players - total_cooperators_prev
        if current_stock < self.STOCK_CRITICAL_THRESHOLD:
            return Action.C
        if k_D_prev >= self.DEFECTION_RATE_HIGH_THRESHOLD and current_stock < self.STOCK_LURE_THRESHOLD:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_343(BaseStrategy):
    """
    The "Resource Leech" strategy exploits the common pool resource by defaulting to defection,
    but adapts to cooperate only when the resource is at significant risk of collapsing or
    when collective defection becomes too high, ensuring its long-term availability for exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.IMMINENT_COLLAPSE_STOCK_THRESHOLD = self.capacity / (2 * self.n)
        self.HIGH_RISK_STOCK_THRESHOLD = self.capacity * 0.5
        self.CRITICAL_LOW_STOCK_THRESHOLD = self.capacity * 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_k = state.round_number + 1
        current_stock_S = state.current_stock
        num_D_players_prev_round = 0
        if current_round_k > 1:
            prev_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
            num_D_players_prev_round = np.sum(~prev_round_opponent_actions)
        if current_round_k == self.r:
            return Action.D
        if current_round_k == 1:
            return Action.D
        if current_stock_S < self.IMMINENT_COLLAPSE_STOCK_THRESHOLD:
            return Action.C
        if num_D_players_prev_round >= self.n - 1 and current_stock_S < self.HIGH_RISK_STOCK_THRESHOLD:
            return Action.C
        if num_D_players_prev_round >= self.n / 2 and current_stock_S < self.CRITICAL_LOW_STOCK_THRESHOLD:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_344(BaseStrategy):
    """
    The "Adaptive Shark" strategy is designed to be highly exploitative, prioritizing individual payoff
    maximization while incorporating necessary safeguards to prevent the total collapse of the common
    resource *only* when such collapse would significantly harm its own future earnings.
    It adapts to the game state (current stock level) and the proximity to the game's end, rather
    than attempting to predict or react to specific opponent behaviors, making it robust against
    a wide range of adversaries.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Shark strategy with game parameters.

        Args:
            game_description: A dataclass containing the game's static parameters
                              (n_players, n_rounds, capacity).
        """
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) based on the Adaptive Shark strategy.

        Args:
            state: A dataclass containing the current game state (round_number, current_stock).
            history: A dataclass containing the history of actions and payoffs for all players.
                     This strategy primarily uses `current_stock` as an aggregate reflection
                     of past actions, not specific opponent behaviors from `history`.

        Returns:
            An Action enum member (Action.C for Cooperate, Action.D for Defect).
        """
        if state.round_number >= self.n_rounds - 2:
            return Action.D
        elif state.current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_345(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its own total payoff by leveraging immediate defection
    while strategically preserving the resource when necessary for future exploitation. It exploits periods
    of high resource stock and high opponent cooperation, and defensively adapts when the resource is
    threatened or opponents are aggressive.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_STOCK_LOWER_BOUND = self.capacity / (2.0 * self.n)
        self.STOCK_RECOVERY_THRESHOLD = self.capacity / 4.0
        self.FUTILITY_DEFECTION_THRESHOLD = self.n - 1

    def _calculate_projected_stock(self, current_s: float, num_total_defectors_in_round: int) -> float:
        """
        Helper to calculate the next round's stock given current stock and total defecting players in this round.
        Assumes `num_total_defectors_in_round` includes this player's projected action.
        """
        num_total_cooperators_in_round = self.n - num_total_defectors_in_round
        consumption_per_cooperator = current_s / (2.0 * self.n)
        consumption_per_defector = current_s / float(self.n)
        total_consumption = num_total_cooperators_in_round * consumption_per_cooperator + num_total_defectors_in_round * consumption_per_defector
        stock_after_consumption = current_s - total_consumption
        stock_for_growth = max(0.0, stock_after_consumption)
        growth = 2.0 * stock_for_growth * (1.0 - stock_for_growth / self.capacity)
        new_stock = min(stock_for_growth + growth, self.capacity)
        return new_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num = state.round_number
        current_stock = state.current_stock
        if current_round_num == 0:
            return Action.C
        if current_round_num == self.r - 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        num_opponent_defectors_prev = np.sum(previous_round_opponent_actions == False)
        num_total_defectors_if_i_D = num_opponent_defectors_prev + 1
        projected_next_stock_if_i_D = self._calculate_projected_stock(current_stock, num_total_defectors_if_i_D)
        num_total_defectors_if_i_C = num_opponent_defectors_prev
        projected_next_stock_if_i_C = self._calculate_projected_stock(current_stock, num_total_defectors_if_i_C)
        if current_stock <= self.CRITICAL_STOCK_LOWER_BOUND:
            if num_opponent_defectors_prev >= self.FUTILITY_DEFECTION_THRESHOLD and current_stock < self.capacity / (4.0 * self.n):
                return Action.D
            else:
                return Action.C
        elif current_stock <= self.STOCK_RECOVERY_THRESHOLD:
            if num_opponent_defectors_prev > (self.n - 1) / 2.0:
                if projected_next_stock_if_i_C > projected_next_stock_if_i_D + self.CRITICAL_STOCK_LOWER_BOUND / 2.0:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        elif projected_next_stock_if_i_D <= self.STOCK_RECOVERY_THRESHOLD:
            if num_opponent_defectors_prev <= (self.n - 1) / 2.0:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_346(BaseStrategy):
    """
    The Opportunistic Stock Manager strategy for the Common Pool Resource Game.

    This strategy aims to maximize its own total payoff by primarily defecting,
    but includes adaptive safeguards and responses to opponent behavior to ensure
    the resource remains viable for continued exploitation. Cooperation is a
    calculated tactic, not an inherent preference.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD = self.game_description.capacity / (self.game_description.n_players * 2)
        self.END_GAME_BUFFER_ROUNDS = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number >= self.game_description.n_rounds - self.END_GAME_BUFFER_ROUNDS:
            return Action.D
        if state.current_stock <= self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        my_action_last_round = history.my_actions[state.round_number - 1]
        opponent_actions_last_round = history.opponent_actions[state.round_number - 1, :]
        num_cooperators_last_round = my_action_last_round + np.sum(opponent_actions_last_round)
        cooperation_ratio_last_round = num_cooperators_last_round / self.game_description.n_players
        if cooperation_ratio_last_round >= (self.game_description.n_players - 1) / self.game_description.n_players:
            return Action.D
        elif state.current_stock > self.game_description.capacity / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_347(BaseStrategy):
    """
    The "Ruthless Opportunist" strategy defaults to exploitation (Defect)
    to maximize immediate gain. It cooperates only when the common resource
    is critically low and there's a clear indication that cooperation from
    others makes a recovery attempt viable and beneficial for future exploitation.
    If the resource is irrevocably doomed, it defects to salvage remaining value.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.RECENT_ROUNDS_WINDOW = 3
        self.STOCK_RECOVERY_THRESHOLD = self.capacity / 3.0
        self.STOCK_COLLAPSE_THRESHOLD = self.capacity / (2.0 * self.n)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.r - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        recent_opponent_defection_rate = 0.0
        start_idx_for_window = max(0, current_round_0_indexed - self.RECENT_ROUNDS_WINDOW)
        recent_history_actions_slice = history.opponent_actions[start_idx_for_window:current_round_0_indexed, :]
        if recent_history_actions_slice.size > 0:
            recent_opponent_defection_rate = 1.0 - np.mean(recent_history_actions_slice)
        if current_stock <= self.STOCK_COLLAPSE_THRESHOLD:
            return Action.D
        elif current_stock <= self.STOCK_RECOVERY_THRESHOLD:
            if recent_opponent_defection_rate < 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_348(BaseStrategy):
    """
    The Opportunistic Predator strategy is designed to maximize cumulative payoff by aggressively exploiting
    cooperative behavior while adaptively preserving the common resource from total collapse, especially
    when the game has many rounds remaining. It balances immediate gains with strategic considerations
    for long-term viability, adjusting behavior based on observed opponent actions and game state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.S_C_Absolute = 2.0 * self.n
        self.Cooperation_Signal_Threshold_Rounds_Fraction = 1.0 / 3.0
        self.Cooperation_Signal_Threshold_Rounds = round(self.r * self.Cooperation_Signal_Threshold_Rounds_Fraction)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        current_round_1_indexed = current_round_0_indexed + 1
        if current_round_0_indexed == 0:
            return Action.D
        if current_round_0_indexed == self.r - 1:
            return Action.D
        rounds_remaining = self.r - current_round_1_indexed
        if current_stock < self.S_C_Absolute:
            return Action.C
        num_opponent_cooperators_prev_round = np.sum(history.opponent_actions[-1, :])
        num_opponent_defectors_prev_round = self.n - 1 - num_opponent_cooperators_prev_round
        if num_opponent_defectors_prev_round < (self.n - 1) / 2.0:
            return Action.D
        elif rounds_remaining > self.Cooperation_Signal_Threshold_Rounds:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_349(BaseStrategy):
    """
    Adaptive Exploiter (AE) strategy for the Common Pool Resource Game.
    This strategy defaults to defection to maximize immediate payoff but
    dynamically adjusts to prevent resource collapse and avoid being a "sucker"
    to other aggressive players. It leverages perfect information about past actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.STOCK_CRITICAL_THRESHOLD_FACTOR = 0.3
        self.DEFECTION_TOLERANCE_RATE = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        my_previous_action_was_D = not history.my_actions[-1]
        defection_count_t_minus_1 = 1 if my_previous_action_was_D else 0
        defection_count_t_minus_1 += np.sum(~history.opponent_actions[-1, :])
        critical_stock_level = self.capacity * self.STOCK_CRITICAL_THRESHOLD_FACTOR
        if current_stock <= critical_stock_level:
            if defection_count_t_minus_1 > self.n_players / 2:
                return Action.D
            else:
                return Action.C
        elif defection_count_t_minus_1 == self.n_players - 1:
            return Action.D
        elif defection_count_t_minus_1 / self.n_players > self.DEFECTION_TOLERANCE_RATE:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_350(BaseStrategy):
    """
    Greedy Adaptive Free-Rider (GAFR) strategy for the Common Pool Resource Game.
    Prioritizes immediate payoff maximization by defecting, but conditionally
    cooperates when the common stock is critically low AND a sufficient
    number of other players have demonstrated cooperation in the previous round,
    aiming for long-term self-preservation of the resource.
    """
    CRITICAL_STOCK_FACTOR: float = 0.5
    COOPERATION_THRESHOLD_PERCENTAGE: float = 0.5

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.D
        if current_round_0_indexed == n_rounds - 1:
            return Action.D
        num_other_players_cooperating_last_round = np.sum(history.opponent_actions[-1, :])
        num_other_players = n_players - 1
        required_cooperators_for_my_cooperation = math.ceil(num_other_players * self.COOPERATION_THRESHOLD_PERCENTAGE)
        if num_other_players > 0 and required_cooperators_for_my_cooperation == 0:
            required_cooperators_for_my_cooperation = 1
        if current_stock < capacity * self.CRITICAL_STOCK_FACTOR:
            if num_other_players_cooperating_last_round >= required_cooperators_for_my_cooperation:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_351(BaseStrategy):
    """
    The Strategic Extractor strategy for the Common Pool Resource Game.
    This strategy is maximally exploitative, prioritizing its own total payoff
    over the entire game. It employs a default defection stance, combined with
    adaptive responses to opponent behavior and resource state, carefully
    calibrated to serve its own exploitative interests. It aims to free-ride
    on others' cooperation while strategically managing the resource to ensure
    its continued (and profitable) availability for personal extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.my_previous_action: Action | None = None
        self.others_defection_history: list[int] = []
        self.MAX_MEMORY_ROUNDS: int = 5
        self.COOPERATION_THRESHOLD: float = 0.3
        self.HEALTHY_STOCK_FRACTION: float = 0.5
        self.CRITICAL_STOCK_LEVEL_MULTIPLIER: float = 1.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_t = state.round_number + 1
        current_stock = state.current_stock
        if current_round_t > 1:
            self.my_previous_action = Action.C if history.my_actions[-1] else Action.D
            opponent_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
            opponent_defections_last_round = n - 1 - opponent_cooperators_last_round
            self.others_defection_history.append(int(opponent_defections_last_round))
            if len(self.others_defection_history) > self.MAX_MEMORY_ROUNDS:
                self.others_defection_history.pop(0)
        if current_round_t == r:
            return Action.D
        if current_stock < n * self.CRITICAL_STOCK_LEVEL_MULTIPLIER:
            return Action.D
        if current_round_t == 1:
            return Action.D
        effective_memory_window = min(current_round_t - 1, self.MAX_MEMORY_ROUNDS)
        total_opponent_defections_in_window = sum(self.others_defection_history[-effective_memory_window:])
        possible_opponent_defections = effective_memory_window * (n - 1)
        opponent_defection_rate = total_opponent_defections_in_window / possible_opponent_defections
        if opponent_defection_rate <= self.COOPERATION_THRESHOLD:
            return Action.D
        if opponent_defection_rate > self.COOPERATION_THRESHOLD and self.my_previous_action == Action.D and (current_stock < capacity * self.HEALTHY_STOCK_FRACTION):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_352(BaseStrategy):
    """
    The Resource PREDATOR strategy is designed to be highly exploitative, maximizing its own total payoff
    over the course of the tournament. It operates on a foundation of self-interest, defaulting to defection
    to gain immediate advantage, but strategically adjusting its behavior to prevent resource collapse
    only when such a collapse would significantly harm its own long-term payoffs. It is adaptive,
    learning from opponents' past actions, and robust against various playstyles by either exploiting
    cooperation or cutting losses when facing widespread defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.avg_opponent_D_rate = 0.0
        self.alpha = 0.5
        self.S_critical_lower_val = self.capacity / (2 * self.n)
        self.S_critical_upper_val = self.capacity / self.n
        self.Exploit_D_threshold = 0.3
        self.Collapse_Risk_D_threshold = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        num_opponents = self.n - 1
        if current_round_1_indexed > 1:
            k_D_opponents_last_round = np.sum(history.opponent_actions[-1, :] == False)
            current_opponent_D_rate = k_D_opponents_last_round / num_opponents
            if current_round_1_indexed == 2:
                self.avg_opponent_D_rate = current_opponent_D_rate
            else:
                self.avg_opponent_D_rate = self.alpha * current_opponent_D_rate + (1 - self.alpha) * self.avg_opponent_D_rate
        if current_round_1_indexed == self.r:
            return Action.D
        if current_stock < self.S_critical_lower_val:
            expected_opponent_D_count = round(num_opponents * self.avg_opponent_D_rate)
            expected_opponent_D_count = max(0, min(num_opponents, expected_opponent_D_count))
            expected_opponent_C_count = num_opponents - expected_opponent_D_count
            my_consumption_if_D = current_stock / self.n
            expected_opponent_D_consumption = expected_opponent_D_count * (current_stock / self.n)
            expected_opponent_C_consumption = expected_opponent_C_count * (current_stock / (2 * self.n))
            projected_total_consumption_if_my_D = my_consumption_if_D + expected_opponent_D_consumption + expected_opponent_C_consumption
            projected_stock_after_cons = current_stock - projected_total_consumption_if_my_D
            stock_for_growth_calc = max(0.0, projected_stock_after_cons)
            projected_growth = 2 * stock_for_growth_calc * (1 - stock_for_growth_calc / self.capacity)
            projected_new_stock_after_growth = min(stock_for_growth_calc + projected_growth, self.capacity)
            if projected_stock_after_cons <= 0 or projected_new_stock_after_growth < self.S_critical_lower_val / 2:
                return Action.D
            else:
                return Action.C
        if self.avg_opponent_D_rate < self.Exploit_D_threshold:
            return Action.D
        elif self.avg_opponent_D_rate > self.Collapse_Risk_D_threshold:
            return Action.D
        else:
            expected_opponent_D_count = round(num_opponents * self.avg_opponent_D_rate)
            expected_opponent_D_count = max(0, min(num_opponents, expected_opponent_D_count))
            expected_opponent_C_count = num_opponents - expected_opponent_D_count
            my_consumption_if_D = current_stock / self.n
            expected_opponent_D_consumption = expected_opponent_D_count * (current_stock / self.n)
            expected_opponent_C_consumption = expected_opponent_C_count * (current_stock / (2 * self.n))
            projected_total_consumption_if_my_D = my_consumption_if_D + expected_opponent_D_consumption + expected_opponent_C_consumption
            projected_stock_after_cons = current_stock - projected_total_consumption_if_my_D
            stock_for_growth_calc = max(0.0, projected_stock_after_cons)
            projected_growth = 2 * stock_for_growth_calc * (1 - stock_for_growth_calc / self.capacity)
            projected_new_stock_if_my_D = min(stock_for_growth_calc + projected_growth, self.capacity)
            if projected_new_stock_if_my_D < self.S_critical_upper_val:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_353(BaseStrategy):
    """
    Adaptive Opportunist strategy for the Common Pool Resource game.

    This strategy aims to maximize its own total payoff by free-riding on cooperative
    opponents, while adapting its aggression to prevent resource collapse. It defects
    in the final round for immediate gain and cooperates in the first round to
    probe for cooperation and maintain initial resource health. In intermediate
    rounds, it projects the resource stock if it defects and decides based on
    this projection and the observed defection rate of others in the previous round.
    It defects when its action doesn't critically endanger the resource, or when
    the resource is already likely doomed by others' high defection. It cooperates
    only when its defection would be critical AND a majority of others are showing
    cooperation, to strategically preserve the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        stock = state.current_stock
        if current_round_1_indexed == self.r:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        n_defectors_others_prev = np.sum(history.opponent_actions[-1, :] == False)
        MINIMUM_VIABLE_STOCK_AFTER_MY_D = float(self.n)
        k_if_I_D = n_defectors_others_prev + 1
        total_consumption_if_I_D = stock * (self.n + k_if_I_D) / (2.0 * self.n)
        S_remaining_calc_if_I_D = max(0.0, stock - total_consumption_if_I_D)
        growth_calc_if_I_D = 2.0 * S_remaining_calc_if_I_D * (1.0 - S_remaining_calc_if_I_D / self.capacity)
        projected_stock_if_I_D = min(S_remaining_calc_if_I_D + growth_calc_if_I_D, self.capacity)
        if projected_stock_if_I_D <= MINIMUM_VIABLE_STOCK_AFTER_MY_D:
            if n_defectors_others_prev >= (self.n - 1) / 2.0:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_354(BaseStrategy):
    """
    The Calculated Predator strategy: An exploitative strategy that defaults to defection
    to maximize immediate gains. It temporarily cooperates only when the common resource
    is critically low, acting out of self-preservation to allow for resource recovery
    and future exploitation. It plays to maximize payoff in the final round without restraint.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD_VALUE = max(self.game_description.capacity * 0.1, 2 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock_level = state.current_stock
        n_rounds = self.game_description.n_rounds
        if current_round_number == n_rounds - 1:
            return Action.D
        elif current_stock_level < self.CRITICAL_STOCK_THRESHOLD_VALUE:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_355(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its total personal payoff across all rounds.
    It ruthlessly exploits cooperative opponents, aggressively claims resources when the stock is plentiful,
    and adapts to prevent premature collapse of the common pool only when absolutely necessary to secure future gains.

    Decision Logic Priority:
    1. Endgame Exploitation: Always Defect in the final round.
    2. Critical Stock Prevention: Cooperate if stock is at or below 25% of capacity to allow recovery.
    3. First Round Aggression: Always Defect in the first round to establish dominance and gather data.
    4. Adaptive Behavior for Intermediate Rounds:
       a. Exploit Cooperators: Defect if average opponent defection rate is low (<30%).
       b. Race to the Bottom: Defect if average opponent defection rate is high (>70%).
       c. Strategic Balance: If mixed defection (30-70% defection), Defect if stock is high (>60% of capacity), else Cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_defection_counts_history = []

    def _update_history(self, history: PlayerHistory, current_round_0_indexed: int):
        """
        Updates the internal history of opponent defections based on the actions
        observed in the round immediately preceding the current one.
        This method is called at the beginning of `__call__` for rounds > 0.
        """
        if current_round_0_indexed > 0 and history is not None and (len(history.opponent_actions) >= current_round_0_indexed):
            last_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
            defection_count_prev_round = (last_round_opponent_actions == False).sum()
            self.opponent_defection_counts_history.append(defection_count_prev_round)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.D
        self._update_history(history, current_round_0_indexed)
        if current_round_1_indexed == n_rounds:
            return Action.D
        if current_stock <= 0:
            return Action.C
        elif current_stock < capacity * 0.25:
            return Action.C
        num_previous_rounds_observed = len(self.opponent_defection_counts_history)
        total_opponent_defections = sum(self.opponent_defection_counts_history)
        avg_opponent_defection_rate = total_opponent_defections / (num_previous_rounds_observed * (n_players - 1))
        if avg_opponent_defection_rate < 0.3:
            return Action.D
        if avg_opponent_defection_rate > 0.7:
            return Action.D
        elif current_stock > capacity * 0.6:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_356(BaseStrategy):
    """
    The Adaptive Exploiter strategy: Defaults to defection, cooperates only to prevent
    resource collapse, free-rides on others' cooperation, and defects maximally in endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.COLLAPSE_THRESHOLD = self.capacity / (2 * self.n_players)
        self.HEALTHY_STOCK_THRESHOLD = self.capacity / 2
        self.COOP_RATIO_HIGH = 0.75
        self.COOP_RATIO_LOW = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = state.current_stock
        if current_round_number >= self.n_rounds - 2:
            return Action.D
        elif current_stock < self.COLLAPSE_THRESHOLD:
            return Action.C
        elif current_stock >= self.HEALTHY_STOCK_THRESHOLD:
            return Action.D
        else:
            num_others_cooperated_last_round = 0
            if current_round_number > 0:
                num_others_cooperated_last_round = np.sum(history.opponent_actions[-1, :])
            num_players_minus_self = self.n_players - 1
            cooperation_ratio = num_others_cooperated_last_round / num_players_minus_self
            if cooperation_ratio >= self.COOP_RATIO_HIGH:
                return Action.D
            elif cooperation_ratio < self.COOP_RATIO_LOW:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_357(BaseStrategy):
    """
    The Adaptive Opportunist strategy aims to maximize total accumulated payoff.
    It defaults to defection for immediate gain, but strategically cooperates
    when the common pool resource is critically low AND a majority of other
    players demonstrated cooperation in the previous round. This conditional
    cooperation is a self-interested investment to restore the resource for
    future exploitation, rather than letting it collapse. It defects in the
    last round to maximize final payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_ratio: float = 0.25
        self.cooperator_majority_threshold: float = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == r - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        is_stock_critically_low = current_stock < capacity * self.critical_stock_ratio
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1]
        num_other_cooperators = np.sum(previous_round_opponent_actions)
        num_other_players = n - 1
        num_other_defectors = num_other_players - num_other_cooperators
        other_defection_ratio = num_other_defectors / num_other_players
        others_are_cooperating_majority = other_defection_ratio <= self.cooperator_majority_threshold
        if is_stock_critically_low:
            if others_are_cooperating_majority:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_358(BaseStrategy):
    """
    The Opportunistic Predator strategy aims to maximize its own total payoff over the game rounds.
    Its core principle is to defect whenever possible for higher immediate payoff, but it incorporates
    adaptive rules to prevent the resource from collapsing entirely (which would harm its own future payoffs)
    and to react to collective defection from opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_critical_low_threshold = self.capacity / (4 * self.n_players)
        self.opponent_defection_threshold = 0.75
        self.stock_risky_level = self.capacity / (2 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_stock <= self.stock_critical_low_threshold:
            return Action.C
        if current_round_1_indexed == 1:
            return Action.D
        prev_round_opponent_actions = history.opponent_actions[state.round_number - 1]
        num_others_defecting_prev_round = sum((1 for action_bool in prev_round_opponent_actions if not action_bool))
        defection_rate_others = num_others_defecting_prev_round / (self.n_players - 1)
        if defection_rate_others >= self.opponent_defection_threshold and current_stock < self.stock_risky_level:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_359(BaseStrategy):
    """
    The "Adaptive Predator" strategy defaults to defection to maximize immediate payoff,
    but adapts to preserve the common pool resource and ensure long-term exploitation opportunities.
    It cooperates in critical stock situations, probes in the first round, and responds
    to observed cooperation rates of others and stock trends in intermediate rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        current_stock = state.current_stock
        self.stock_history.append(current_stock)
        if current_round_1_indexed == self.r:
            return Action.D
        min_sustainable_stock_threshold = self.capacity / self.n
        if current_stock < min_sustainable_stock_threshold:
            return Action.C
        if current_round_1_indexed == 1:
            return Action.C
        my_previous_action_was_cooperate = history.my_actions[-1]
        count_cooperated_by_all_in_prev_round = np.sum(history.opponent_actions[-1, :])
        if my_previous_action_was_cooperate:
            count_cooperated_by_all_in_prev_round += 1
        num_other_players = self.n - 1
        coop_rate_others = (count_cooperated_by_all_in_prev_round - (1 if my_previous_action_was_cooperate else 0)) / num_other_players
        if coop_rate_others > 0.5:
            return Action.D
        else:
            stock_at_start_of_prev_round = self.stock_history[current_round_0_indexed - 1]
            stock_at_start_of_current_round = self.stock_history[current_round_0_indexed]
            if stock_at_start_of_current_round < stock_at_start_of_prev_round:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_360(BaseStrategy):
    """
    The Aggressive Observer strategy for the Common Pool Resource Game.

    This strategy aims to maximize its own total payoff by exploiting cooperative behavior
    from others while strategically preserving the common resource to ensure future
    exploitation opportunities. It is adaptive to opponent behavior and robust to resource
    depletion.

    Core Principles:
    1. Exploit when possible: Take a larger share (Defect) when other players are
       collectively maintaining the resource.
    2. Preserve when necessary: Cooperate (C) to prevent resource collapse when stock
       levels are critically low or when widespread defection threatens long-term gains.
    3. Endgame greed: Always defect in the final round as there are no future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_CRITICAL_LOW = self.capacity / 4.0
        self.N_C_THRESHOLD = math.floor((self.n_players - 1) / 2.0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds_count = self.n_rounds
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == total_rounds_count - 1:
            return Action.D
        if current_stock <= self.S_CRITICAL_LOW:
            return Action.C
        else:
            num_cooperators_others = sum(history.opponent_actions[-1, :])
            if num_cooperators_others >= self.N_C_THRESHOLD:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_361(BaseStrategy):
    """
    The "Resource-Aware Predator" strategy prioritizes individual payoff maximization by defaulting to defection,
    but adapts to ensure the common resource remains viable for continued exploitation. It cooperates if the
    resource is critically low or if its defection would cause a significant and detrimental stock decline
    below optimal growth levels, especially when others are relatively cooperative.
    It matches aggression if opponents are highly exploitative and defects in the final round to maximize terminal payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / 4.0
        self.SUSTAINABILITY_STOCK_THRESHOLD = self.capacity / 2.0
        self.OPPONENT_DEFECTION_TOLERANCE_RATE = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        n = self.n_players
        r = self.n_rounds
        capacity = self.capacity
        if current_round == r - 1:
            return Action.D
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        if current_round == 0:
            return Action.D
        num_other_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
        num_other_defectors_last_round = n - 1 - num_other_cooperators_last_round
        defection_rate_others = 0.0
        if n - 1 > 0:
            defection_rate_others = num_other_defectors_last_round / (n - 1)
        if defection_rate_others > self.OPPONENT_DEFECTION_TOLERANCE_RATE:
            return Action.D
        else:
            my_consumption_if_D = current_stock / n
            others_consumption_if_I_D = num_other_cooperators_last_round * current_stock / (2 * n) + num_other_defectors_last_round * current_stock / n
            total_consumption_if_I_D_others_as_before = my_consumption_if_D + others_consumption_if_I_D
            S_remaining_after_consumption_if_I_D = current_stock - total_consumption_if_I_D_others_as_before
            S_remaining_after_consumption_if_I_D = max(0.0, S_remaining_after_consumption_if_I_D)
            stock_growth_predicted_if_I_D = 2 * S_remaining_after_consumption_if_I_D * (1 - S_remaining_after_consumption_if_I_D / capacity)
            predicted_next_stock_if_I_D = min(S_remaining_after_consumption_if_I_D + stock_growth_predicted_if_I_D, capacity)
            if predicted_next_stock_if_I_D < current_stock and predicted_next_stock_if_I_D < self.SUSTAINABILITY_STOCK_THRESHOLD:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_362(BaseStrategy):
    """
    The "Calculated Predator" strategy is designed to be highly exploitative, adaptive,
    and robust in a Common Pool Resource game. Its core principle is to aggressively
    pursue individual maximum payoff by defecting, while strategically cooperating
    only when such cooperation is necessary to prevent a resource collapse that would
    detrimentally impact its own long-term total payoff, or to cultivate the resource
    for future free-riding, but only if others are bearing the primary burden of cooperation.
    It explicitly avoids being a "sucker" by not cooperating when others are not.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_critical = self.capacity / self.n_players
        self.S_encourage = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_round_0_indexed == self.n_rounds - 2:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        num_coop_opponents_prev = np.sum(history.opponent_actions[current_round_0_indexed - 1, :])
        num_opponents = self.n_players - 1
        P_coop_opponents = num_coop_opponents_prev / num_opponents
        action_to_play = Action.D
        if current_stock <= self.S_critical:
            if P_coop_opponents > 0.5:
                action_to_play = Action.C
        elif current_stock < self.S_encourage:
            if P_coop_opponents > 0.75:
                action_to_play = Action.C
        return action_to_play

class Strategy_EXPLOITATIVE_363(BaseStrategy):
    """
    The "Pragmatic Predator" strategy prioritizes immediate personal gain by defecting.
    It strategically cooperates only out of self-preservation to prevent the common resource
    from falling into an unrecoverable state, and only if its individual cooperation can
    make a significant difference and there are sufficient future rounds to benefit.
    Otherwise, it always defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        num_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        current_round = state.round_number
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round == total_rounds - 1:
            return Action.D
        k_D_prev = 0
        k_C_prev = 0
        if current_round == 0:
            k_D_prev = math.floor((num_players - 1) / 2)
            k_C_prev = num_players - 1 - k_D_prev
        else:
            k_C_prev = np.sum(history.opponent_actions[-1, :])
            k_D_prev = num_players - 1 - k_C_prev
        my_consumption_D = current_stock / num_players
        my_consumption_C = current_stock / (2 * num_players)
        expected_opponent_consumption = k_D_prev * (current_stock / num_players) + k_C_prev * (current_stock / (2 * num_players))
        total_consumption_if_I_D = my_consumption_D + expected_opponent_consumption
        S_remaining_if_I_D = current_stock - total_consumption_if_I_D
        S_remaining_if_I_D = max(0.0, S_remaining_if_I_D)
        total_consumption_if_I_C = my_consumption_C + expected_opponent_consumption
        S_remaining_if_I_C = current_stock - total_consumption_if_I_C
        S_remaining_if_I_C = max(0.0, S_remaining_if_I_C)
        CRITICAL_STOCK_THRESHOLD = capacity / (2 * num_players)
        CRITICAL_STOCK_THRESHOLD = max(0.01, CRITICAL_STOCK_THRESHOLD)
        if S_remaining_if_I_D <= CRITICAL_STOCK_THRESHOLD:
            if S_remaining_if_I_C > CRITICAL_STOCK_THRESHOLD:
                if total_rounds - current_round > 2:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_364(BaseStrategy):
    """
    The Calculated Predator: Maximally exploitative, prioritizing personal payoff while
    adapting to resource state and other players' behavior. Designed to free-ride,
    aggressively exploit when abundant, and only engage in calculated conservation
    if it promises greater long-term individual gain, especially facing cooperation.
    Aims to win tournaments.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_doom_threshold = self.capacity / (2 * self.n * self.n)
        self.S_critical_threshold = self.capacity / (2 * self.n)
        self.D_cooperation_threshold = math.floor(self.n / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        k_D_prev = 0
        if state.round_number > 0 and history is not None:
            k_D_prev = np.sum(history.opponent_actions[-1, :] == False)
        if current_round_1_indexed == self.r:
            return Action.D
        elif current_round_1_indexed == self.r - 1 and current_stock <= self.S_critical_threshold:
            return Action.D
        elif current_stock <= self.S_doom_threshold:
            return Action.D
        elif current_stock <= self.S_critical_threshold:
            if k_D_prev >= self.D_cooperation_threshold:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_365(BaseStrategy):
    """
    The "Opportunistic Predator" strategy is designed to maximize a player's total payoff
    over the game by strategically exploiting cooperative behavior from others, while
    ensuring the common resource remains viable enough for continued exploitation. It is
    adaptive to both the current stock level and the observed behavior of other players,
    and it shifts to pure self-interest in the final stages of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.COOPERATION_STOCK_THRESHOLD = max(1.0, self.capacity / (2 * self.n_players))
        self.NUM_FINAL_AGGRESSIVE_ROUNDS = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number_0_indexed = state.round_number
        current_round_number_1_indexed = current_round_number_0_indexed + 1
        current_stock_level = state.current_stock
        if current_round_number_1_indexed == 1:
            return Action.D
        if current_round_number_0_indexed >= self.n_rounds - self.NUM_FINAL_AGGRESSIVE_ROUNDS:
            return Action.D
        if current_stock_level < self.COOPERATION_STOCK_THRESHOLD:
            return Action.C
        else:
            previous_opponent_actions = history.opponent_actions[-1, :]
            num_others_cooperated_prev_round = np.sum(previous_opponent_actions)
            num_others_defected_prev_round = self.n_players - 1 - num_others_cooperated_prev_round
            my_consumption_if_D = current_stock_level / self.n_players
            others_consumption_based_on_prev = num_others_defected_prev_round * current_stock_level / self.n_players + num_others_cooperated_prev_round * current_stock_level / (2 * self.n_players)
            hypothetical_total_consumption = my_consumption_if_D + others_consumption_based_on_prev
            hypothetical_S_after_consumption = max(0.0, current_stock_level - hypothetical_total_consumption)
            hypothetical_growth = 2 * hypothetical_S_after_consumption * (1 - hypothetical_S_after_consumption / self.capacity)
            hypothetical_next_stock = min(hypothetical_S_after_consumption + hypothetical_growth, self.capacity)
            if hypothetical_next_stock < self.COOPERATION_STOCK_THRESHOLD:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_366(BaseStrategy):
    """
    Adaptive Predator strategy for the Common Pool Resource game.

    This strategy employs internal thresholds and monitors opponent behavior
    to balance aggressive extraction with resource preservation. It prioritizes
    defection when the resource is healthy and others are cooperative, effectively
    free-riding. It switches to cooperation only when necessary to prevent resource
    collapse or to stabilize it against widespread defection, thereby preserving
    the means of future exploitation. In the final round, it reverts to pure
    self-interest.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.depletion_threshold = self.game_description.capacity / 4.0
        self.cooperation_observation_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == n_rounds - 1:
            return Action.D
        if current_stock <= self.depletion_threshold:
            return Action.C
        if current_round == 0:
            return Action.C
        cooperators_prev_round = np.sum(history.opponent_actions[current_round - 1, :])
        num_other_players = n_players - 1
        observed_cooperation_ratio = cooperators_prev_round / num_other_players
        if observed_cooperation_ratio >= self.cooperation_observation_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_367(BaseStrategy):
    """
    The "Opportunistic Predator" strategy is designed to maximize its own total payoff over the game rounds.
    It defaults to exploitative behavior (Defect) to secure immediate gains but strategically cooperates
    under specific conditions to ensure the resource's survival and thus its own long-term exploitation potential,
    but only when other players are also contributing.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.scarcity_threshold_factor = 0.5
        self.min_opponent_cooperation_rate = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_zero_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_round_zero_indexed == 0:
            return Action.D
        if current_round_zero_indexed == total_rounds - 1:
            return Action.D
        num_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
        num_other_players = n_players - 1
        cooperation_rate_others = num_cooperators_last_round / num_other_players
        is_stock_scarce = current_stock <= capacity * self.scarcity_threshold_factor
        if is_stock_scarce and cooperation_rate_others >= self.min_opponent_cooperation_rate:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_368(BaseStrategy):
    """
    The Adaptive Opportunist strategy for the Common Pool Resource game.
    It aims to maximize personal payoff by exploiting opportunities to free-ride,
    while also ensuring the long-term viability of the resource through
    self-preservation mechanisms when the stock is critically low.
    It adapts based on observed opponent actions and resource state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD = self.game_description.capacity / (2 * self.game_description.n_players)
        self.HIGH_STOCK_THRESHOLD = self.game_description.capacity * 0.75
        self.COOPERATION_OBSERVATION_THRESHOLD = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == self.game_description.n_rounds:
            return Action.D
        if state.current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        if state.current_stock > self.HIGH_STOCK_THRESHOLD:
            return Action.D
        if state.round_number == 0:
            return Action.D
        num_cooperators_last_round = sum(history.opponent_actions[-1, :])
        num_opponents = self.game_description.n_players - 1
        opponent_cooperation_ratio = num_cooperators_last_round / num_opponents
        if opponent_cooperation_ratio >= self.COOPERATION_OBSERVATION_THRESHOLD:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_369(BaseStrategy):
    """
    The "Adaptive Predator" strategy for the Common Pool Resource Game.
    It primarily aims to exploit the common resource by defecting, maximizing immediate payoffs.
    However, it adaptively cooperates to prevent total resource collapse, ensuring future exploitation
    opportunities. Decisions are based on projecting the next round's stock level, considering
    opponent behavior from the previous round and its own potential defection. In the final round,
    or the very first round where no history exists, it always defects for maximum immediate gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Predator strategy with game parameters and its own internal state.

        Args:
            game_description: An object containing game parameters such as n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.F = 0.15
        self.epsilon = 0.001 * self.game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round based on the strategy's logic.

        Args:
            state: An object containing the current round number (0-indexed) and current stock level.
            history: An object containing historical actions and payoffs for this player and opponents.
                     It is None for the very first round (round_number == 0).

        Returns:
            An Action enum value (Action.C for Cooperate or Action.D for Defect).
        """
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_t = state.round_number
        current_stock_S = state.current_stock
        if current_round_t == r - 1:
            return Action.D
        if current_round_t == 0:
            return Action.D
        else:
            previous_round_opponent_actions = history.opponent_actions[current_round_t - 1, :]
            num_defecting_opponents_prev = np.sum(~previous_round_opponent_actions)
            projected_total_defectors_if_I_D = num_defecting_opponents_prev + 1
            projected_total_consumption_if_I_D = current_stock_S * (n + projected_total_defectors_if_I_D) / (2 * n)
            stock_after_consumption_if_I_D = current_stock_S - projected_total_consumption_if_I_D
            stock_after_consumption_if_I_D = max(stock_after_consumption_if_I_D, self.epsilon)
            projected_stock_growth = 2 * stock_after_consumption_if_I_D * (1 - stock_after_consumption_if_I_D / capacity)
            projected_next_stock_if_I_D = min(stock_after_consumption_if_I_D + projected_stock_growth, capacity)
            if projected_next_stock_if_I_D < self.F * capacity:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_370(BaseStrategy):
    """
    The Opportunistic Predator strategy for the Common Pool Resource game.
    This strategy aims to maximize individual payoff by defaulting to defection (D) whenever possible,
    strategically free-riding on others' cooperation when the resource is healthy. It will only
    invest in cooperation (C) when the resource is critically endangered and a collective effort
    (including its own) is likely to restore it, thereby ensuring future rounds of exploitation.
    In the final rounds or when the resource is beyond recovery, it will aggressively defect
    to maximize its last take.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.R_MAX_EXPLOIT_1_indexed = max(2, self.r - 2)
        self.STOCK_CRITICAL_THRESHOLD = 0.3 * self.capacity
        self.STOCK_DESPERATE_THRESHOLD = 0.05 * self.capacity
        self.OTHERS_COOP_THRESHOLD = 0.65
        self.HISTORY_WINDOW_SIZE = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.C
        others_coop_rate = 0.0
        if history is not None:
            relevant_rounds_start_idx = max(0, current_round_0_indexed - self.HISTORY_WINDOW_SIZE)
            relevant_rounds_end_idx = current_round_0_indexed - 1
            opponent_actions_window = history.opponent_actions[relevant_rounds_start_idx:relevant_rounds_end_idx + 1, :]
            if opponent_actions_window.size > 0:
                total_other_C_actions_in_window = np.sum(opponent_actions_window)
                total_other_actions_in_window = opponent_actions_window.size
                others_coop_rate = total_other_C_actions_in_window / total_other_actions_in_window
        if current_round_0_indexed >= self.R_MAX_EXPLOIT_1_indexed - 1:
            return Action.D
        if current_stock <= self.STOCK_DESPERATE_THRESHOLD:
            return Action.D
        if current_stock <= self.STOCK_CRITICAL_THRESHOLD:
            if others_coop_rate >= self.OTHERS_COOP_THRESHOLD:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_371(BaseStrategy):
    """
    The Maverick Exploiter strategy aims to maximize its own total payoff by starting cooperatively, 
    then strategically exploiting sustained cooperation from others. It defends against widespread 
    defection by punishing opponents and prioritizes resource recovery when stock is critically low 
    to ensure long-term gain, ultimately defecting in the final round.
    """
    CRITICAL_STOCK_THRESHOLD_RATIO: float = 0.25
    FORGIVENESS_ROUNDS: int = 2
    DEFECTION_TRIGGER_RATIO: float = 0.5
    EXPLOIT_AFTER_COOPERATION_ROUNDS: int = 3

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.rounds_in_punishment: int = 0
        self.consecutive_other_cooperations: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed: int = state.round_number + 1
        total_rounds: int = self.game_description.n_rounds
        num_players: int = self.game_description.n_players
        capacity: float = self.game_description.capacity
        if state.round_number == 0:
            self.rounds_in_punishment = 0
            self.consecutive_other_cooperations = 0
            return Action.C
        if current_round_1_indexed == total_rounds:
            return Action.D
        if state.current_stock <= self.CRITICAL_STOCK_THRESHOLD_RATIO * capacity:
            self.rounds_in_punishment = 0
            self.consecutive_other_cooperations = 0
            return Action.C
        previous_round_opponent_actions: NDArray[np.bool_] = history.opponent_actions[state.round_number - 1, :]
        num_other_defectors: int = np.sum(previous_round_opponent_actions == False)
        num_others: int = num_players - 1
        defection_proportion_others: float = num_other_defectors / num_others
        if num_other_defectors == 0:
            self.consecutive_other_cooperations += 1
        else:
            self.consecutive_other_cooperations = 0
        if self.rounds_in_punishment > 0:
            self.rounds_in_punishment -= 1
            return Action.D
        if defection_proportion_others >= self.DEFECTION_TRIGGER_RATIO:
            self.rounds_in_punishment = self.FORGIVENESS_ROUNDS - 1
            return Action.D
        if self.consecutive_other_cooperations >= self.EXPLOIT_AFTER_COOPERATION_ROUNDS:
            self.consecutive_other_cooperations = 0
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_372(BaseStrategy):
    """
    The Adaptive Predator strategy aims for maximum immediate gain by defaulting to defection.
    It cooperates only as a tactical retreat for self-preservation when the resource is
    critically low or when other players' aggression threatens the longevity of the game,
    thereby safeguarding potential future exploitation opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / 4.0
        self.DEFECTION_TOLERANCE_THRESHOLD = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        else:
            num_others_defected_last_round = self.n_players - 1 - np.sum(history.opponent_actions[state.round_number - 1, :])
            proportion_others_defected = num_others_defected_last_round / (self.n_players - 1.0)
            if proportion_others_defected >= self.DEFECTION_TOLERANCE_THRESHOLD:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_373(BaseStrategy):
    """
    The Agile Predator strategy: Prioritizes immediate gains (Defect) unless the resource is genuinely threatened
    and there's a collective effort by opponents to recover it. It strategically cooperates to preserve the resource
    for future exploitation, but will join a race to the bottom if widespread defection dooms the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = float(self.game_description.capacity)
        self.CRITICAL_STOCK_THRESHOLD = max(n * 2.0, capacity * 0.1)
        self.RECOVERY_STOCK_THRESHOLD = capacity * 0.3
        self.OPPONENT_COOPERATION_THRESHOLD = max(1.0, math.ceil((n - 1) * 0.75))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n = self.game_description.n_players
        if current_round == total_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        opponent_cooperation_count = sum(history.opponent_actions[-1, :])
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            if opponent_cooperation_count > 0:
                return Action.C
            else:
                return Action.D
        elif current_stock < self.RECOVERY_STOCK_THRESHOLD:
            if opponent_cooperation_count >= self.OPPONENT_COOPERATION_THRESHOLD:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_374(BaseStrategy):
    """
    Adaptive Predator strategy for the Common Pool Resource game.

    Overall Philosophy:
    The Adaptive Predator aims to maximize cumulative payoff by defaulting to defection
    to exploit cooperators, while strategically cooperating only when necessary
    to prevent resource collapse (to preserve future exploitation opportunities)
    or when such cooperation might induce a more favorable environment. It adapts
    its aggression based on the observed behavior of others and the current health
    of the common pool stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.min_stock_threshold = self.capacity / 4.0
        self.num_others_defecting_before_caution = max(1, math.floor((self.n_players - 1) / 3.0))
        self.resource_preservation_min = math.ceil((self.n_players - 1) / 2.0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        n_others = self.n_players - 1
        if round_number == self.n_rounds - 1:
            return Action.D
        if current_stock < self.min_stock_threshold:
            return Action.C
        if round_number == 0:
            return Action.C
        num_defectors_prev_round = np.sum(~history.opponent_actions[-1, :])
        if num_defectors_prev_round == n_others:
            return Action.D
        if num_defectors_prev_round <= self.num_others_defecting_before_caution:
            return Action.D
        if num_defectors_prev_round >= self.resource_preservation_min:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_375(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its own total payoff in the Common Pool Resource game
    by exploiting the resource and opponents' cooperation. It is aggressive in resource-rich and end-game
    conditions, but conditionally cooperates when resource scarcity threatens long-term gains or
    when opponents demonstrate a willingness to cooperate to preserve the stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.end_game_horizon = 3
        self.critical_stock_threshold_low = self.capacity / 4.0
        self.critical_stock_threshold_very_low = self.capacity / (2.0 * self.n)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        N_C_prev = 0
        if history is not None and state.round_number > 0:
            N_C_prev = int(np.sum(history.opponent_actions[-1, :]))
        if current_round_1_indexed > self.r - self.end_game_horizon:
            return Action.D
        elif current_stock <= self.critical_stock_threshold_very_low:
            if N_C_prev >= (self.n - 1) / 2.0:
                return Action.C
            else:
                return Action.D
        elif current_stock <= self.critical_stock_threshold_low:
            if N_C_prev >= (self.n - 1) / 2.0:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_376(BaseStrategy):
    """
    Predatory Stock Harvester: An exploitative strategy for the Common Pool Resource game.
    This strategy prioritizes maximizing its own payoff, even at the expense of others or
    the long-term health of the resource. It primarily defects, but intelligently chooses
    to cooperate when the resource is critically endangered and there is a reasonable
    chance that others might also cooperate, thereby allowing for future exploitation
    opportunities for itself. It does not rely on shared norms or communication.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Predatory Stock Harvester strategy.

        Args:
            game_description: A CommonPoolDescription object containing game parameters
                              like number of players, rounds, and capacity.
        """
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD = 0.25 * self.game_description.capacity
        self.RECENT_ROUNDS_FOR_ANALYSIS = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state: A CommonPoolState object containing the current round number and stock level.
            history: A PlayerHistory object containing past actions and payoffs for the current
                     player and all opponents, or None if it's the very first round (round 0).

        Returns:
            An Action enum (Action.C for Cooperate, Action.D for Defect).
        """
        current_round = state.round_number
        current_stock = state.current_stock
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if current_round == 0:
            return Action.D
        if current_round == total_rounds - 1:
            return Action.D
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            num_other_cooperated_recently = 0
            total_opponent_actions_checked = 0
            rounds_to_check = min(current_round, self.RECENT_ROUNDS_FOR_ANALYSIS)
            for i in range(1, rounds_to_check + 1):
                round_index = current_round - i
                opponent_actions_in_round = history.opponent_actions[round_index]
                for opponent_action in opponent_actions_in_round:
                    if opponent_action:
                        num_other_cooperated_recently += 1
                    total_opponent_actions_checked += 1
            cooperation_ratio = 0.0
            if total_opponent_actions_checked > 0:
                cooperation_ratio = num_other_cooperated_recently / total_opponent_actions_checked
            if cooperation_ratio >= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_377(BaseStrategy):
    """
    Adaptive Exploiter Strategy (AES) for the Common Pool Resource game.

    This strategy operates on the principle of aggressive self-interest. It defaults to the
    individually optimal (defecting) action to maximize immediate payoff. It only switches
    to a cooperative stance (playing C) when the common resource is severely threatened
    by collective over-extraction, to the point where its own future ability to exploit
    the resource would be jeopardized. This cooperation is not altruistic but a strategic
    concession to ensure long-term self-gain. It also considers the aggressiveness of
    other players from the previous round as a warning signal.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / (2 * self.n_players)
        self.EXPLOITATION_STOCK_THRESHOLD = self.capacity / self.n_players
        self.MAX_OTHER_DEFECTORS = self.n_players - 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == 0:
            return Action.D
        elif current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        else:
            num_opponent_cooperators_last_round = np.sum(history.opponent_actions[-1, :])
            num_defections_last_round = self.MAX_OTHER_DEFECTORS - num_opponent_cooperators_last_round
            if current_stock < self.CRITICAL_STOCK_THRESHOLD:
                return Action.C
            elif current_stock < self.EXPLOITATION_STOCK_THRESHOLD and num_defections_last_round >= self.MAX_OTHER_DEFECTORS:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_378(BaseStrategy):
    """
    The Adaptive Exploiter strategy is designed to be highly self-interested and exploitative.
    It aggressively defects for immediate gains, but strategically cooperates to prevent
    resource collapse or to manipulate opponents into creating better conditions for future
    exploitation. It adapts its behavior based on the current stock level and observed
    actions of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.N = game_description.n_players
        self.R = game_description.n_rounds
        self.CAPACITY = game_description.capacity
        self.STOCK_CRITICAL_THRESHOLD_RATIO = 0.2
        self.DEFECTION_PROPORTION_THRESHOLD = 0.5
        self.PUNISHMENT_DURATION = 2
        self.COOPERATION_RESET_DURATION = 1
        self.HISTORY_WINDOW_FOR_CRITICAL_STOCK = 3
        self.other_defectors_history: list[int] = []
        self.is_punishing: bool = False
        self.is_cooperation_reset_mode: bool = False
        self.rounds_in_current_mode: int = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number > 0 and history is not None:
            prev_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
            num_other_defectors_prev_round = np.sum(~prev_round_opponent_actions).item()
            self.other_defectors_history.append(num_other_defectors_prev_round)
        if state.round_number == self.R - 1:
            return Action.D
        if state.round_number == 0:
            return Action.C
        avg_other_defectors_recent = 0.0
        if len(self.other_defectors_history) > 0:
            start_idx = max(0, len(self.other_defectors_history) - self.HISTORY_WINDOW_FOR_CRITICAL_STOCK)
            relevant_history = self.other_defectors_history[start_idx:]
            if len(relevant_history) > 0:
                avg_other_defectors_recent = sum(relevant_history) / len(relevant_history)
        if state.current_stock < self.STOCK_CRITICAL_THRESHOLD_RATIO * self.CAPACITY:
            num_other_players = self.N - 1
            if num_other_players > 0 and avg_other_defectors_recent / num_other_players > self.DEFECTION_PROPORTION_THRESHOLD:
                return Action.D
            else:
                self.is_punishing = False
                self.is_cooperation_reset_mode = False
                self.rounds_in_current_mode = 0
                return Action.C
        if self.is_punishing:
            self.rounds_in_current_mode += 1
            if self.rounds_in_current_mode <= self.PUNISHMENT_DURATION:
                return Action.D
            else:
                self.is_punishing = False
                self.is_cooperation_reset_mode = True
                self.rounds_in_current_mode = 1
                return Action.C
        if self.is_cooperation_reset_mode:
            self.rounds_in_current_mode += 1
            if self.rounds_in_current_mode <= self.COOPERATION_RESET_DURATION:
                return Action.C
            else:
                self.is_cooperation_reset_mode = False
                self.rounds_in_current_mode = 0
        if len(self.other_defectors_history) > 0:
            num_other_defectors_prev_round = self.other_defectors_history[-1]
            num_other_players = self.N - 1
            if num_other_players > 0 and num_other_defectors_prev_round / num_other_players > self.DEFECTION_PROPORTION_THRESHOLD:
                self.is_punishing = True
                self.rounds_in_current_mode = 1
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_379(BaseStrategy):
    """
    The Adaptive Opportunist strategy aims to maximize total individual payoff over the entire game.
    It defaults to defecting for immediate gain but adapts strategically:
    1. Always defects in the final round to maximize immediate payoff.
    2. Always defects in the first round to establish an aggressive stance and probe opponents.
    3. If the resource is critically low (below LOW_STOCK_THRESHOLD_RATIO), it strategically cooperates
       if others are not defecting heavily (aggressiveness_ratio <= HIGH_DEFECTION_RATIO) to prevent
       resource collapse and ensure future exploitation. Otherwise, if others are heavily defecting,
       it defects (scorched earth).
    4. Responds to opponent aggressiveness: if a large majority of others defected in the previous round
       (aggressiveness_ratio >= HIGH_DEFECTION_RATIO), it defects to avoid being a 'sucker'. If a large
       majority cooperated (aggressiveness_ratio <= LOW_DEFECTION_RATIO), it defects to exploit their cooperation.
    5. In cases of moderate opponent aggressiveness, it projects the next round's stock. If its own defection
       would cause the stock to fall below a critical recovery level (STOCK_CRITICAL_FOR_RECOVERY_RATIO)
       while its cooperation would prevent this, it cooperates.
    6. In all other scenarios, it defaults to defecting (greedy, individually optimal action).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.LOW_STOCK_THRESHOLD_RATIO = 0.15
        self.HIGH_DEFECTION_RATIO = 0.75
        self.LOW_DEFECTION_RATIO = 0.25
        self.STOCK_CRITICAL_FOR_RECOVERY_RATIO = 0.2

    def _calculate_next_stock(self, S_current: float, num_D_this_round: int, num_C_this_round: int, total_players_n: int, max_capacity: float) -> float:
        """
        Helper function to calculate the projected next stock level based on current stock,
        actions in the current round, and game parameters.
        """
        consumption_per_D = S_current / total_players_n
        consumption_per_C = S_current / (2.0 * total_players_n)
        total_consumption = num_D_this_round * consumption_per_D + num_C_this_round * consumption_per_C
        S_after_consumption = S_current - total_consumption
        if S_after_consumption < 0:
            S_after_consumption = 0.0
        growth = 2.0 * S_after_consumption * (1.0 - S_after_consumption / max_capacity)
        S_next = min(S_after_consumption + growth, max_capacity)
        return S_next

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        total_rounds = self.game_description.n_rounds
        if state.round_number == total_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.D
        num_other_players = n - 1
        if num_other_players == 0:
            return Action.D
        c_count_others_prev_round = int(np.sum(history.opponent_actions[state.round_number - 1, :]))
        d_count_others_prev_round = num_other_players - c_count_others_prev_round
        aggressiveness_ratio = float(d_count_others_prev_round) / num_other_players
        if current_stock < capacity * self.LOW_STOCK_THRESHOLD_RATIO:
            if aggressiveness_ratio > self.HIGH_DEFECTION_RATIO:
                return Action.D
            else:
                return Action.C
        if aggressiveness_ratio >= self.HIGH_DEFECTION_RATIO:
            return Action.D
        if aggressiveness_ratio <= self.LOW_DEFECTION_RATIO:
            return Action.D
        projected_stock_if_i_D = self._calculate_next_stock(current_stock, d_count_others_prev_round + 1, c_count_others_prev_round, n, capacity)
        projected_stock_if_i_C = self._calculate_next_stock(current_stock, d_count_others_prev_round, c_count_others_prev_round + 1, n, capacity)
        if projected_stock_if_i_D < capacity * self.STOCK_CRITICAL_FOR_RECOVERY_RATIO and projected_stock_if_i_C >= capacity * self.STOCK_CRITICAL_FOR_RECOVERY_RATIO:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_380(BaseStrategy):
    """
    Adaptive Stock Predator (ASP) strategy for the Common Pool Resource game.

    This strategy aims to maximize total payoff by defecting as much as possible,
    only cooperating when the resource is at risk of collapse (thereby threatening
    future exploitation opportunities), and intensifying exploitation as the game
    approaches its end.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_ratio = 0.25
        self.pre_endgame_aggression_rounds = math.ceil(self.r / 4)
        self.critical_stock_level = self.capacity * self.critical_stock_ratio

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.r:
            return Action.D
        if current_stock < self.critical_stock_level:
            return Action.C
        if current_round_1_indexed >= self.r - self.pre_endgame_aggression_rounds:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_381(BaseStrategy):
    """
    Adaptive Exploiter (Greedy but Cautious) strategy for the Common Pool Resource Game.
    Prioritizes immediate gains by free-riding and defecting, but cooperates strategically
    to prevent resource collapse for future exploitation. Adapts based on stock level,
    opponent behavior, and rounds remaining.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.low_stock_threshold_ratio: float = 0.25
        self.recovery_stock_threshold_ratio: float = 0.5
        self.defection_tolerance_ratio: float = 0.5
        self.endgame_rounds_threshold: int = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n: int = self.game_description.n_players
        r: int = self.game_description.n_rounds
        capacity: float = self.game_description.capacity
        current_round_1_indexed: int = state.round_number + 1
        stock: float = state.current_stock
        num_defectors_prev_round: int = 0
        if state.round_number > 0:
            num_cooperators_prev_round = np.sum(history.opponent_actions[state.round_number - 1, :])
            num_defectors_prev_round = n - 1 - num_cooperators_prev_round
        stock_is_critically_low: bool = stock <= capacity * self.low_stock_threshold_ratio
        if current_round_1_indexed == r:
            return Action.D
        if stock_is_critically_low:
            return Action.D
        if current_round_1_indexed == 1 or num_defectors_prev_round == 0:
            return Action.D
        rounds_remaining: int = r - current_round_1_indexed + 1
        if rounds_remaining <= self.endgame_rounds_threshold:
            return Action.D
        if num_defectors_prev_round / (n - 1) >= self.defection_tolerance_ratio:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_382(BaseStrategy):
    """
    Adaptive Opportunist strategy for the Common Pool Resource Game.
    This strategy prioritizes immediate personal payoff by defecting, but employs a calculated
    approach to prevent the collapse of the common resource. It adapts its behavior based on
    observed opponent actions and the current stock level. The strategy becomes increasingly
    aggressive towards the end of the game, abandoning all long-term considerations.
    It strategically cooperates only if its cooperation can significantly avert critical
    resource depletion and thereby preserve future exploitation opportunities.
    """
    EARLY_GAME_ROUNDS = 1
    END_GAME_HORIZON = 2
    DEFECTION_ALERT_THRESHOLD = 0.6
    STOCK_CRITICAL_THRESHOLD_RATIO = 0.2
    COOPERATION_EFFECTIVENESS_BUFFER = 1.05

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def _predict_stock(self, current_S: float, num_c_players: int, num_d_players: int) -> float:
        """
        Calculates the predicted new stock level after a round, given the current stock,
        the number of players choosing to Cooperate (C), and the number of players choosing
        to Defect (D) in that round.
        """
        n = self.n_players
        capacity = self.capacity
        per_player_consumption_C = current_S / (2 * n) if current_S > 0 else 0.0
        per_player_consumption_D = current_S / n if current_S > 0 else 0.0
        total_consumption = num_c_players * per_player_consumption_C + num_d_players * per_player_consumption_D
        S_remaining = current_S - total_consumption
        S_remaining = max(0.0, S_remaining)
        growth = 2 * S_remaining * (1 - S_remaining / capacity)
        new_stock = min(S_remaining + growth, capacity)
        return new_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        if current_round_0_indexed >= self.n_rounds - self.END_GAME_HORIZON:
            return Action.D
        if current_round_0_indexed <= self.EARLY_GAME_ROUNDS - 1:
            return Action.D
        num_rounds_observed = current_round_0_indexed
        total_opponent_defects = np.sum(history.opponent_actions[:, :] == False)
        max_possible_opponent_defects = num_rounds_observed * (self.n_players - 1)
        opponent_defection_rate = 0.0
        if max_possible_opponent_defects > 0:
            opponent_defection_rate = total_opponent_defects / max_possible_opponent_defects
        if opponent_defection_rate >= self.DEFECTION_ALERT_THRESHOLD:
            return Action.D
        else:
            num_expected_opponent_D = round(opponent_defection_rate * (self.n_players - 1))
            num_expected_opponent_C = self.n_players - 1 - num_expected_opponent_D
            num_expected_opponent_D = max(0, min(num_expected_opponent_D, self.n_players - 1))
            num_expected_opponent_C = max(0, min(num_expected_opponent_C, self.n_players - 1))
            predicted_new_stock_if_I_D = self._predict_stock(current_stock, num_expected_opponent_C, num_expected_opponent_D + 1)
            if predicted_new_stock_if_I_D <= self.STOCK_CRITICAL_THRESHOLD_RATIO * self.capacity:
                predicted_new_stock_if_I_C = self._predict_stock(current_stock, num_expected_opponent_C + 1, num_expected_opponent_D)
                critical_stock_with_buffer = self.STOCK_CRITICAL_THRESHOLD_RATIO * self.capacity * self.COOPERATION_EFFECTIVENESS_BUFFER
                if predicted_new_stock_if_I_C > critical_stock_with_buffer:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_383(BaseStrategy):
    """
    The Opportunistic Predator strategy for the Common Pool Resource game.

    This strategy aims to maximize its own total payoff over `r` rounds by prioritizing
    defection ('D') for immediate gain. However, it is intelligent enough to switch
    to cooperation ('C') under specific conditions:
    1. To prevent the total collapse of the resource (emergency cooperation).
    2. To strategically signal cooperation when the resource is declining and others
       are defecting, hoping to incentivize other players to increase their cooperation,
       thereby preserving the resource for future exploitation.

    Decisions are based on the current round, stock level, and observed opponent behavior
    from the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = self.capacity / 4.0
        self.moderate_stock_threshold = self.capacity / 2.0
        self.cooperation_rate_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock_S = state.current_stock
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed >= self.n_rounds - 1:
            return Action.D
        if current_stock_S < self.critical_stock_threshold:
            return Action.C
        if state.round_number > 0:
            previous_round_opponent_actions = history.opponent_actions[-1, :]
            num_cooperators_last_round = sum(previous_round_opponent_actions)
            cooperation_rate_last_round = num_cooperators_last_round / self.n_players
            if cooperation_rate_last_round >= self.cooperation_rate_threshold:
                return Action.D
            elif cooperation_rate_last_round < self.cooperation_rate_threshold and current_stock_S < self.moderate_stock_threshold:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_385(BaseStrategy):
    """
    The "Adaptive Predator" strategy operates on the principle of self-interest: maximize personal gain.
    It seeks to exploit cooperative behavior from opponents whenever possible, but is also pragmatic
    enough to cooperate strategically to prevent the common resource (and thus its own future income stream)
    from being entirely depleted. The strategy anticipates rational play in the endgame, leading to
    aggressive defection in final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.K_endgame = 2
        self.critical_stock_ratio = 0.25
        self.opponent_C_threshold = 0.5
        self.memory_depth = 3
        self.history_opponent_cooperation_counts = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if state.round_number > 0 and history is not None:
            previous_round_opponent_actions = history.opponent_actions[-1, :]
            num_C_others = np.sum(previous_round_opponent_actions)
            self.history_opponent_cooperation_counts.append((num_C_others, self.n - 1 - num_C_others))
            if len(self.history_opponent_cooperation_counts) > self.memory_depth:
                self.history_opponent_cooperation_counts.pop(0)
        if current_round_1_indexed == 1:
            return Action.D
        if current_round_1_indexed > self.r - self.K_endgame:
            return Action.D
        if current_stock < self.capacity * self.critical_stock_ratio:
            return Action.C
        num_memory_rounds_used = len(self.history_opponent_cooperation_counts)
        if num_memory_rounds_used == 0:
            return Action.D
        total_cooperators_in_memory = sum((item[0] for item in self.history_opponent_cooperation_counts))
        total_possible_opponent_actions = num_memory_rounds_used * (self.n - 1)
        if total_possible_opponent_actions == 0:
            return Action.D
        avg_opponent_cooperation_rate = total_cooperators_in_memory / total_possible_opponent_actions
        if avg_opponent_cooperation_rate >= self.opponent_C_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_386(BaseStrategy):
    """
    The "Adaptive Exploit-to-Sustain" strategy is designed to be highly exploitative, 
    prioritizing immediate gains while strategically cooperating only when necessary 
    to prevent resource collapse that would severely diminish future payoffs. 
    It is adaptive to opponent behaviors and the current state of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD = float(self.game_description.n_players)
        self.LOW_STOCK_THRESHOLD = self.game_description.capacity / 4.0
        self.COOPERATION_RATE_FOR_FREERIDE = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if round_num_1_indexed == total_rounds:
            return Action.D
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.D
        if round_num_1_indexed == 1:
            return Action.D
        num_other_cooperators_last_round = int(np.sum(history.opponent_actions[-1, :]))
        if current_stock > self.LOW_STOCK_THRESHOLD:
            return Action.D
        elif num_other_cooperators_last_round >= (n_players - 1) * self.COOPERATION_RATE_FOR_FREERIDE:
            return Action.D
        else:
            my_consumption_if_D = current_stock / n_players
            others_consumption_if_C = num_other_cooperators_last_round * current_stock / (2 * n_players)
            others_consumption_if_D = (n_players - 1 - num_other_cooperators_last_round) * current_stock / n_players
            total_consumption_if_I_D = my_consumption_if_D + others_consumption_if_C + others_consumption_if_D
            s_remaining_after_consumption_if_I_D = max(0.0, current_stock - total_consumption_if_I_D)
            growth_if_I_D = 2 * s_remaining_after_consumption_if_I_D * (1 - s_remaining_after_consumption_if_I_D / capacity)
            next_stock_if_I_D = min(s_remaining_after_consumption_if_I_D + growth_if_I_D, capacity)
            if next_stock_if_I_D < self.CRITICAL_STOCK_THRESHOLD and total_rounds - round_num_1_indexed > 1:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_387(BaseStrategy):
    """
    The Adaptive Stock Predator strategy aims to maximize its own total payoff by primarily defecting,
    but with a critical self-preservation mechanism. It understands that completely destroying the
    common resource (the stock) ultimately leads to zero payoffs for itself. Therefore, it will
    only cooperate under specific conditions that ensure the continued existence or recovery of the
    resource, solely for the purpose of prolonged exploitation. It does not cooperate out of
    altruism or to "teach" opponents, but purely out of long-term self-interest.
    """
    COOPERATION_THRESHOLD_STOCK_RATIO = 0.1

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Stock Predator strategy.

        Args:
            game_description (CommonPoolDescription): An object containing
                                                     n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.cooperation_threshold_stock_ratio = self.COOPERATION_THRESHOLD_STOCK_RATIO

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.

        Args:
            state (CommonPoolState): An object containing the current round_number and current_stock.
            history (None | PlayerHistory): An object containing past actions and payoffs for
                                            this player and opponents, or None for the first round.

        Returns:
            Action: The chosen action (Action.C for Cooperate, Action.D for Defect).
        """
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_t = state.round_number
        if current_round_t == r - 1:
            return Action.D
        if current_round_t == 0:
            if current_stock < self.cooperation_threshold_stock_ratio * capacity:
                return Action.C
            else:
                return Action.D
        k_opponents_defected_last_round = 0
        for opponent_action in history.opponent_actions[current_round_t - 1, :]:
            if not opponent_action:
                k_opponents_defected_last_round += 1
        projected_num_D_this_round_if_I_D = k_opponents_defected_last_round + 1
        projected_S_after_consumption_if_I_D = current_stock * (n - projected_num_D_this_round_if_I_D) / (2 * n)
        projected_num_D_this_round_if_I_C = k_opponents_defected_last_round
        projected_S_after_consumption_if_I_C = current_stock * (n - projected_num_D_this_round_if_I_C) / (2 * n)
        if projected_S_after_consumption_if_I_D <= 0:
            if projected_S_after_consumption_if_I_C > 0:
                return Action.C
            else:
                return Action.D
        elif projected_S_after_consumption_if_I_D < self.cooperation_threshold_stock_ratio * capacity:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_388(BaseStrategy):
    """
    The Opportunistic Defector strategy aims to maximize its own total payoff by defaulting to defection,
    cooperating only when the common resource is critically low AND a sufficient number of other players
    cooperated in the previous round, thereby preventing resource collapse for future exploitation.
    It defects in the first and last rounds for immediate gain.
    """
    SURVIVAL_THRESHOLD_PERCENTAGE = 0.25

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.survival_threshold = self.capacity * self.SURVIVAL_THRESHOLD_PERCENTAGE

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        num_cooperators_last_round = np.sum(previous_round_opponent_actions)
        if state.current_stock <= self.survival_threshold:
            if num_cooperators_last_round >= self.n_players / 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_389(BaseStrategy):
    """
    Adaptive Predator strategy: Highly exploitative, prioritizes individual gain,
    responds adaptively to collective behavior and resource health to ensure
    continued opportunity for exploitation. It's designed to free-ride when
    others cooperate, defect when the resource is abundant or when collapse
    is imminent due to universal defection, and strategically cooperate only
    when the resource is critically low or projected to become so due to its own defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.warning_stock_level = self.game_description.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r_total = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == r_total - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        num_cooperators_prev_round = np.sum(history.opponent_actions[-1, :])
        num_defectors_prev_round = n - 1 - num_cooperators_prev_round
        if current_stock <= self.warning_stock_level:
            return Action.C
        elif num_cooperators_prev_round == n - 1:
            return Action.D
        elif num_cooperators_prev_round == 0:
            return Action.D
        else:
            consumption_by_others_if_repeat = num_cooperators_prev_round * current_stock / (2.0 * n) + num_defectors_prev_round * current_stock / float(n)
            my_consumption_if_D = current_stock / float(n)
            total_consumption_if_I_D = consumption_by_others_if_repeat + my_consumption_if_D
            stock_after_consumption = current_stock - total_consumption_if_I_D
            if stock_after_consumption < 0:
                stock_after_consumption = 0.0
            growth = 2.0 * stock_after_consumption * (1.0 - stock_after_consumption / capacity)
            projected_next_stock = min(stock_after_consumption + growth, capacity)
            if projected_next_stock > self.warning_stock_level:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_390(BaseStrategy):
    """
    The Adaptive Predator strategy is designed to be highly exploitative, aiming to maximize its own
    total payoff by defaulting to aggressive resource extraction (defecting) while intelligently
    using cooperation as a strategic tool to prevent the common pool from collapsing, thus
    preserving future exploitation opportunities. It is robust as it adapts its behavior based
    on the current state of the resource and the observed actions of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_FRACTION = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == r - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        if current_stock < capacity * self.CRITICAL_STOCK_FRACTION:
            return Action.C
        else:
            opponent_actions_prev_round = history.opponent_actions[current_round_0_indexed - 1, :]
            num_opponent_defectors_prev_round = np.sum(~opponent_actions_prev_round)
            num_opponent_cooperators_prev_round = np.sum(opponent_actions_prev_round)
            my_consumption_if_D = current_stock / n
            opponents_consumption_if_I_D = num_opponent_defectors_prev_round * (current_stock / n) + num_opponent_cooperators_prev_round * (current_stock / (2 * n))
            total_consumption_if_I_D = my_consumption_if_D + opponents_consumption_if_I_D
            stock_after_consumption = max(0.0, current_stock - total_consumption_if_I_D)
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
            predicted_next_stock_if_I_D = min(stock_after_consumption + growth, capacity)
            if predicted_next_stock_if_I_D > capacity * self.CRITICAL_STOCK_FRACTION:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_391(BaseStrategy):
    """
    The Resilient Predator strategy: Maximize personal payoff by aggressively defecting.
    Only cooperates when the common resource is at critical risk of depletion and such cooperation
    is deemed likely to preserve the resource for future exploitation, avoiding being a "sucker".
    Always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold = self.game_description.capacity / (self.game_description.n_players * 2.0)
        self.opponent_defection_threshold_for_futile_cooperation = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == r:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        previous_round_history_index = state.round_number - 1
        opponent_actions_last_round = history.opponent_actions[previous_round_history_index, :]
        num_opponent_defectors = np.sum(~opponent_actions_last_round)
        n_minus_1 = n - 1
        if n_minus_1 > 0:
            avg_opponent_defection_rate = num_opponent_defectors / n_minus_1
        else:
            avg_opponent_defection_rate = 0.0
        if current_stock <= self.critical_stock_threshold:
            if avg_opponent_defection_rate > self.opponent_defection_threshold_for_futile_cooperation:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_392(BaseStrategy):
    """
    The Opportunistic Sentinel strategy aims to maximize personal cumulative payoff by defecting
    whenever possible, but critically intervenes with cooperation to prevent the common pool resource
    from collapsing, thereby ensuring future opportunities for exploitation. It adapts its behavior
    based on the current stock level and the observed defection rate of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_lower_bound_ratio = 1.0 / float(self.game_description.n_players)
        self.D_aggression_threshold = 0.5
        self.S_critical_threshold = self.game_description.capacity * self.S_lower_bound_ratio

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        if current_round == 0 or current_round == total_rounds - 1:
            return Action.D
        else:
            previous_round_opponent_actions = history.opponent_actions[current_round - 1, :]
            previous_round_D_count = np.sum(~previous_round_opponent_actions)
            previous_round_D_rate = float(previous_round_D_count) / float(n_players)
            if current_stock < self.S_critical_threshold:
                return Action.C
            elif previous_round_D_rate < self.D_aggression_threshold:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_393(BaseStrategy):
    """
    The Adaptive Exploiter strategy prioritizes immediate gains through defection but incorporates a strong
    self-preservation mechanism to prevent the collapse of the common resource. It adapts to opponent behavior
    by observing past rounds and adjusts its strategy in the final rounds to maximize short-term profit.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_min_for_survival = 0.001 * game_description.capacity

    def _project_next_stock(self, current_stock: float, my_intended_action: Action, k_opponents_D: int) -> float:
        """
        Helper function to project the stock level in the next round based on current state and assumed actions.
        """
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        if current_stock <= 0:
            return 0.0
        my_consumption = current_stock / n if my_intended_action == Action.D else current_stock / (2.0 * n)
        k_opponents_D = max(0, min(k_opponents_D, n - 1))
        k_opponents_C = n - 1 - k_opponents_D
        others_D_consumption = k_opponents_D * (current_stock / n)
        others_C_consumption = k_opponents_C * (current_stock / (2.0 * n))
        total_consumption = my_consumption + others_D_consumption + others_C_consumption
        S_remaining_after_consumption = max(0.0, current_stock - total_consumption)
        growth_factor = 1.0 - S_remaining_after_consumption / capacity if capacity > 0 else 0.0
        growth = 2.0 * S_remaining_after_consumption * growth_factor
        new_stock = min(S_remaining_after_consumption + growth, capacity)
        return new_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number + 1
        current_stock = state.current_stock
        if current_round >= r - 1:
            return Action.D
        k_opponents_D: int
        if current_round == 1:
            k_opponents_D = n - 1
        else:
            prev_round_opponent_actions = history.opponent_actions[-1, :]
            k_opponents_D = n - 1 - sum(prev_round_opponent_actions)
        S_next_round_if_I_D = self._project_next_stock(current_stock, Action.D, k_opponents_D)
        S_next_round_if_I_C = self._project_next_stock(current_stock, Action.C, k_opponents_D)
        if S_next_round_if_I_D > self.S_min_for_survival:
            return Action.D
        elif S_next_round_if_I_C > self.S_min_for_survival:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_394(BaseStrategy):
    """
    The Adaptive Opportunist strategy for the Common Pool Resource game.
    This strategy defaults to aggressive defection, aiming to maximize immediate payoff.
    It strategically switches to cooperation only if projecting its defection, combined
    with the observed behavior of other players, would likely drive the common resource
    stock below a critical self-preservation threshold, thus jeopardizing future
    exploitation opportunities. This makes the strategy adaptive to aggregate opponent
    behavior and robust to various play styles while prioritizing individual long-term gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COLLAPSE_THRESHOLD = self.game_description.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == r - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        else:
            previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
            num_cooperators_among_others_prev_round = np.sum(previous_round_opponent_actions)
            num_defectors_among_others_prev_round = n - 1 - num_cooperators_among_others_prev_round
            my_projected_consumption_if_D = current_stock / n
            others_projected_consumption = num_cooperators_among_others_prev_round * (current_stock / (2.0 * n)) + num_defectors_among_others_prev_round * (current_stock / n)
            total_consumption_projected = my_projected_consumption_if_D + others_projected_consumption
            stock_after_consumption_raw = current_stock - total_consumption_projected
            stock_after_consumption_projected = max(0.0, stock_after_consumption_raw)
            growth_projected = 2.0 * stock_after_consumption_projected * (1.0 - stock_after_consumption_projected / capacity)
            next_stock_projected = min(stock_after_consumption_projected + growth_projected, capacity)
            if next_stock_projected <= self.COLLAPSE_THRESHOLD:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_395(BaseStrategy):
    """
    The Opportunistic Piranha strategy aggressively extracts resources, defecting by default.
    It only cooperates as a last resort to prevent resource collapse (and preserve its own future extraction ability)
    if its individual defection would cause the collapse and its cooperation can avert it.
    It adapts by forecasting based on opponents' previous round actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.T_collapse = 0.001 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_idx = state.round_number
        current_stock = state.current_stock
        if current_round_idx == 0:
            return Action.D
        if current_round_idx == self.n_rounds - 1:
            return Action.D
        else:

            def calculate_projected_stock(s_current_val: float, my_action_is_C: bool, others_coop_count: int, others_defect_count: int, n_players_val: int, capacity_val: float) -> float:
                """
                Calculates the projected stock level for the next round given current stock,
                my hypothetical action, and opponents' assumed actions.
                """
                my_consumption = s_current_val / (2 * n_players_val) if my_action_is_C else s_current_val / n_players_val
                others_consumption = others_coop_count * s_current_val / (2 * n_players_val) + others_defect_count * s_current_val / n_players_val
                total_consumption = my_consumption + others_consumption
                stock_after_consumption = s_current_val - total_consumption
                stock_after_consumption = max(0.0, stock_after_consumption)
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity_val)
                s_projected = min(stock_after_consumption + growth, capacity_val)
                s_projected = max(0.0, s_projected)
                return s_projected
            k_others_coop_last_round = np.sum(history.opponent_actions[current_round_idx - 1, :])
            j_others_defect_last_round = self.n_players - 1 - k_others_coop_last_round
            S_projected_if_I_D = calculate_projected_stock(current_stock, False, k_others_coop_last_round, j_others_defect_last_round, self.n_players, self.capacity)
            S_projected_if_I_C = calculate_projected_stock(current_stock, True, k_others_coop_last_round, j_others_defect_last_round, self.n_players, self.capacity)
            if S_projected_if_I_D < self.T_collapse and S_projected_if_I_C >= self.T_collapse:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_396(BaseStrategy):
    """
    Implements the "Ruthless Opportunist with Self-Preservation" strategy.
    This strategy defaults to defection to maximize immediate payoff,
    only cooperating when the shared resource is critically low to ensure
    future opportunities for exploitation, and always defects in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_critical_threshold = self.game_description.capacity / (2.0 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < self.stock_critical_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_397(BaseStrategy):
    """
    The Opportunist Predator strategy aims to maximize individual payoff by exploiting the common pool
    resource. It prioritizes immediate personal gain through defection, but strategically cooperates
    under specific conditions: in the initial round(s) to establish the resource and observe,
    or when the resource is critically low to prevent its collapse and ensure future exploitation.
    In the final rounds, it abandons long-term considerations to maximize terminal payoffs through defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.final_rounds_aggressive_defection: int = 1
        self.stock_critical_low_threshold_factor: float = 0.25
        self.initial_observation_rounds: int = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round >= total_rounds - self.final_rounds_aggressive_defection:
            return Action.D
        if current_stock <= capacity * self.stock_critical_low_threshold_factor:
            return Action.C
        if current_round < self.initial_observation_rounds:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_398(BaseStrategy):
    """
    Adaptive Predator strategy for the Common Pool Resource Game.

    This strategy aims to maximize individual payoff by defecting opportunistically
    while implementing safeguards to prevent resource collapse and strategically
    induce cooperation from other players. It prioritizes immediate gains but
    considers long-term resource viability for continued exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.INITIAL_AGGRESSION_ROUNDS = max(1, min(2, self.r - 1))
        self.STOCK_DANGER_THRESHOLD = self.capacity / (2 * self.n)
        self.COOPERATION_INDUCEMENT_THRESHOLD = 0.3
        self.EXPLOITATION_THRESHOLD = 0.6
        self.consecutive_cooperation_rounds_needed = 0
        self.previous_stock = self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.r:
            self.previous_stock = current_stock
            return Action.D
        if current_stock < self.STOCK_DANGER_THRESHOLD:
            self.consecutive_cooperation_rounds_needed = 1
            self.previous_stock = current_stock
            return Action.C
        if self.consecutive_cooperation_rounds_needed > 0:
            self.consecutive_cooperation_rounds_needed -= 1
            self.previous_stock = current_stock
            return Action.C
        if current_round_1_indexed <= self.INITIAL_AGGRESSION_ROUNDS:
            self.previous_stock = current_stock
            return Action.D
        num_others_cooperated = np.sum(history.opponent_actions[-1, :])
        num_other_players = self.n - 1
        cooperation_rate_others = num_others_cooperated / num_other_players
        if cooperation_rate_others >= self.EXPLOITATION_THRESHOLD:
            self.previous_stock = current_stock
            return Action.D
        elif cooperation_rate_others <= self.COOPERATION_INDUCEMENT_THRESHOLD:
            self.previous_stock = current_stock
            return Action.C
        elif current_stock < self.previous_stock:
            self.previous_stock = current_stock
            return Action.C
        else:
            self.previous_stock = current_stock
            return Action.D

class Strategy_EXPLOITATIVE_399(BaseStrategy):
    """
    The Opportunistic Predator strategy: This strategy is designed to be highly exploitative,
    aiming to maximize its total payoff across all rounds. It defaults to defection to gain
    the highest immediate reward, but intelligently adapts to cooperate only when doing so
    directly benefits its long-term exploitation potential by preventing a stock collapse
    that would diminish its future earnings. It does not assume any specific opponent
    behavior beyond what is observed from the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.S_critical_low = capacity / 4.0
        self.S_recovery_margin = capacity / (2.0 * n * 10.0) if n > 0 else 0.001
        self.D_proportion_threshold_high = 0.75

    def _calculate_next_stock_estimate(self, current_S: float, my_action: Action, num_defectors_opponents: int, num_cooperators_opponents: int) -> float:
        """
        Estimates the stock level for the next round, assuming opponents repeat their
        actions from the previous round.
        """
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        if my_action == Action.C:
            my_consumption = current_S / (2.0 * n)
        else:
            my_consumption = current_S / n
        opponent_consumption = num_defectors_opponents * current_S / n + num_cooperators_opponents * current_S / (2.0 * n)
        total_consumption = my_consumption + opponent_consumption
        S_after_consumption = current_S - total_consumption
        S_remaining_for_growth = max(0.0, S_after_consumption)
        growth = 2 * S_remaining_for_growth * (1 - S_remaining_for_growth / capacity)
        new_stock = min(S_remaining_for_growth + growth, capacity)
        return new_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        if current_round_0_indexed == 0:
            return Action.D
        opponent_actions_prev_round = history.opponent_actions[-1, :]
        num_cooperators_prev_round = np.sum(opponent_actions_prev_round).item()
        num_defectors_prev_round = n - 1 - num_cooperators_prev_round
        prop_D_opponents_prev_round = num_defectors_prev_round / (n - 1.0) if n - 1.0 > 0 else 0.0
        if current_round_0_indexed == r - 1:
            return Action.D
        if current_round_0_indexed == r - 2:
            S_next_D = self._calculate_next_stock_estimate(current_stock, Action.D, num_defectors_prev_round, num_cooperators_prev_round)
            S_next_C = self._calculate_next_stock_estimate(current_stock, Action.C, num_defectors_prev_round, num_cooperators_prev_round)
            if current_stock < self.S_critical_low:
                return Action.C
            elif S_next_D <= self.S_recovery_margin and S_next_C > self.S_recovery_margin:
                return Action.C
            else:
                return Action.D
        if current_stock < self.S_critical_low:
            return Action.C
        elif prop_D_opponents_prev_round >= self.D_proportion_threshold_high:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_400(BaseStrategy):
    """
    Adaptive Predator strategy: An exploitative and adaptive strategy that defaults to defection
    to maximize immediate gains. It temporarily cooperates to prevent resource collapse when
    stock is critically low, ensuring a resource for future exploitation. As the game
    approaches its end, it switches to pure defection to maximize final payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        defect_endgame_threshold = max(1, math.floor(n_players / 2))
        critical_stock_threshold = capacity / n_players
        rounds_remaining = n_rounds - current_round
        if rounds_remaining <= defect_endgame_threshold:
            return Action.D
        if current_stock < critical_stock_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_401(BaseStrategy):
    """
    The "Adaptive Predator" strategy for the Common Pool Resource game.

    This strategy aims to maximize its own total payoff by adapting its
    behavior based on the current stock level and observed opponent actions.
    It defaults to aggressive exploitation (Defect) when the resource is abundant.
    However, it will switch to conservation (Cooperate) if the stock becomes
    critically low to ensure future opportunities for exploitation. In an
    intermediate stock zone, it adapts by cooperating if opponents were
    aggressive in the previous round, or defecting if opponents were cooperative.
    The strategy always defects in the final round to maximize terminal payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_healthy_threshold = self.game_description.capacity * 0.75
        self.stock_critical_threshold = self.game_description.capacity * 0.25
        self.defection_tolerance_ratio = 0.5
        self.num_opponents = self.game_description.n_players - 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round_number == total_rounds - 1:
            return Action.D
        defection_ratio_last_round = 0.0
        if current_round_number > 0 and history is not None:
            previous_round_opponent_actions = history.opponent_actions[-1, :]
            opponent_defections = np.sum(previous_round_opponent_actions == False)
            defection_ratio_last_round = opponent_defections / self.num_opponents
        if current_stock >= self.stock_healthy_threshold:
            return Action.D
        elif current_stock <= self.stock_critical_threshold:
            return Action.C
        elif defection_ratio_last_round >= self.defection_tolerance_ratio:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_402(BaseStrategy):
    """
    The Ruthless Opportunist strategy for the Common Pool Resource Game.
    It prioritizes maximizing its own total payoff by defaulting to defection,
    while adaptively responding to the state of the common resource and the
    observed behavior of other players to avoid premature collapse or to
    strategically benefit from others' cooperation. It aims to extract as much
    value as possible from the system, always defecting in the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.STOCK_CRITICAL_THRESHOLD = self.capacity / (2 * self.n)
        self.FREE_RIDE_COOPERATION_RATIO = 0.5
        self.DEFECTION_CASCADE_RATIO = 0.75
        self.MIN_ROUNDS_FOR_REBUILD = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if state.round_number == 0:
            return Action.D
        if current_round_1_indexed == self.r or current_round_1_indexed == self.r - 1:
            return Action.D
        num_C_others = np.sum(history.opponent_actions[-1, :])
        num_D_others = self.n - 1 - num_C_others
        prop_C_others = num_C_others / (self.n - 1)
        prop_D_others = num_D_others / (self.n - 1)
        if state.current_stock <= self.STOCK_CRITICAL_THRESHOLD:
            if prop_C_others >= self.FREE_RIDE_COOPERATION_RATIO:
                rounds_left_inclusive = self.r - current_round_1_indexed + 1
                if rounds_left_inclusive >= self.MIN_ROUNDS_FOR_REBUILD:
                    return Action.C
            return Action.D
        if prop_D_others >= self.DEFECTION_CASCADE_RATIO:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_403(BaseStrategy):
    """
    The Adaptive Predator strategy aims for maximum self-gain in a Common Pool Resource Game.
    It defaults to aggressive defection, exploiting the common resource and any cooperation
    from other players. Strategic cooperation is considered only under critical resource
    depletion, and only if other players demonstrate sufficient restraint to make cooperation
    effective (i.e., not a 'sucker's move'). In the final rounds, all long-term considerations
    are abandoned for immediate maximum extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold_ratio: float = 0.3
        self.rounds_to_consider_collapse: int = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if total_rounds - current_round_1_indexed < self.rounds_to_consider_collapse:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        num_other_defectors = np.sum(history.opponent_actions[-1, :] == False)
        if current_stock < capacity * self.critical_stock_threshold_ratio:
            if num_other_defectors <= (n_players - 1) / 2:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_404(BaseStrategy):
    """
    The "Adaptive Predator" strategy is designed to be highly exploitative, aiming to maximize its own total payoff.
    It defaults to defection for immediate gains, but intelligently adapts its behavior based on the current common
    resource stock, the remaining rounds, and the observed cooperation/defection patterns of other players.
    This allows it to free-ride on cooperators while attempting to preserve the resource just enough to continue
    exploitation, becoming more aggressive as the game nears its end.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.COOPERATION_BASE_THRESHOLD_FACTOR = 0.75
        self.EXPLOITATION_AGGREESIVENESS = 0.9
        self.MIN_STOCK_THRESHOLD = max(float(self.n_players), self.capacity / (2.0 * self.n_players))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        total_rounds = self.n_rounds
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.D
        if current_round_1_indexed == total_rounds:
            return Action.D
        avg_opponent_defection_rate = 0.5
        if history is not None and history.opponent_actions.shape[0] > 0:
            opponent_defections = ~history.opponent_actions
            num_opponents = self.n_players - 1
            if num_opponents > 0:
                defection_counts_per_round = np.sum(opponent_defections, axis=1)
                defection_rates = defection_counts_per_round / float(num_opponents)
                avg_opponent_defection_rate = np.mean(defection_rates)
        base_threshold = self.capacity * self.COOPERATION_BASE_THRESHOLD_FACTOR
        round_progress = (current_round_1_indexed - 1) / float(total_rounds - 1)
        aggression_adjustment = self.EXPLOITATION_AGGREESIVENESS * round_progress
        effective_threshold = base_threshold * (1.0 - aggression_adjustment)
        behavior_adjustment_multiplier = 1.0
        if avg_opponent_defection_rate > 0.6:
            behavior_adjustment_multiplier = 1.0 - 0.1 * ((avg_opponent_defection_rate - 0.6) / 0.4)
        elif avg_opponent_defection_rate < 0.4:
            behavior_adjustment_multiplier = 1.0 + 0.1 * ((0.4 - avg_opponent_defection_rate) / 0.4)
        final_threshold = effective_threshold * behavior_adjustment_multiplier
        final_threshold = max(self.MIN_STOCK_THRESHOLD, final_threshold)
        if current_stock < final_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_405(BaseStrategy):
    """
    Predatory Stock Manager (PSM) Strategy.

    This strategy combines aggressive defection when the resource is abundant or
    when others are cooperating, with strategic cooperation when the resource is
    critically low or when widespread defection threatens its collapse. This
    "selfish conservation" ensures a future stream of resources to exploit.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Predatory Stock Manager strategy with game parameters
        and calculates its internal thresholds.

        Args:
            game_description (CommonPoolDescription): An object containing
                                                      n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.S_LOW_THRESHOLD = max(2 * n, capacity / 4.0)
        self.S_HIGH_THRESHOLD = 0.9 * capacity
        self.OTHER_DEFECTION_TOLERANCE_THRESHOLD = (n - 1) // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides the action (Cooperate or Defect) for the current round based on
        the Predatory Stock Manager strategy's logic.

        Args:
            state (CommonPoolState): The current state of the game, including
                                     round_number (0-indexed) and current_stock.
            history (None | PlayerHistory): History of past rounds' actions and
                                           payoffs, or None for the first round.

        Returns:
            Action: Action.C for Cooperate, Action.D for Defect.
        """
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        if current_round_1_indexed == 1:
            return Action.D
        if current_round_1_indexed == total_rounds:
            return Action.D
        other_D_prev = (~history.opponent_actions[-1, :]).sum()
        if current_stock < self.S_LOW_THRESHOLD:
            return Action.C
        elif current_stock >= self.S_HIGH_THRESHOLD:
            return Action.D
        elif other_D_prev <= self.OTHER_DEFECTION_TOLERANCE_THRESHOLD:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_406(BaseStrategy):
    """
    Opportunistic Predator strategy: Defaults to defection, but strategically cooperates to prevent
    resource collapse or when opponents are highly aggressive. It prioritizes self-enrichment and
    maximizes immediate gain in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_defection_rate: float = 0.0
        self.my_last_action: Action | None = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if state.round_number > 0:
            prev_round_game_index = state.round_number - 1
            opponent_prev_actions = history.opponent_actions[prev_round_game_index, :]
            opponent_defected_count = np.sum(~opponent_prev_actions)
            current_observed_opponent_defection_rate = opponent_defected_count / (self.n_players - 1)
            alpha = 0.5
            self.opponent_defection_rate = (1 - alpha) * self.opponent_defection_rate + alpha * current_observed_opponent_defection_rate
        action = Action.D
        if current_round_1_indexed == self.total_rounds:
            action = Action.D
        elif current_stock < self.capacity * 0.3:
            action = Action.C
        elif self.opponent_defection_rate > 0.6:
            action = Action.C
        elif current_round_1_indexed == 1:
            action = Action.C
        self.my_last_action = action
        return action

class Strategy_EXPLOITATIVE_407(BaseStrategy):
    """
    The "Calculated Predator" strategy aims to maximize its own total payoff over the entire game
    by primarily defecting to secure a larger share, but with a crucial self-preservation
    mechanism that triggers cooperation only when its own continued defection would critically
    jeopardize future resource availability, thus diminishing its own long-term gains. It adapts
    to opponent behavior by exploiting cooperation and responding to collective defection with
    strategic short-term cooperation if necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.MIN_STOCK_THRESHOLD = self.game_description.capacity / (2 * self.game_description.n_players)

    def _calculate_next_stock(self, current_stock: float, my_action: Action, others_consumption_total: float) -> float:
        """
        Helper to simulate stock dynamics for one round based on game rules.
        """
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        my_consumption: float
        if my_action == Action.C:
            my_consumption = current_stock / (2 * n)
        else:
            my_consumption = current_stock / n
        total_consumption = my_consumption + others_consumption_total
        stock_after_consumption = max(0.0, current_stock - total_consumption)
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / capacity)
        new_stock = min(stock_after_consumption + growth, capacity)
        return new_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number + 1
        if round_t == 1:
            return Action.C
        if round_t == self.game_description.n_rounds:
            return Action.D
        if state.current_stock < self.MIN_STOCK_THRESHOLD:
            return Action.D
        prev_round_idx = state.round_number - 1
        others_actions_prev_round = history.opponent_actions[prev_round_idx, :]
        num_others_cooperated_prev = np.sum(others_actions_prev_round)
        num_others_defected_prev = self.game_description.n_players - 1 - num_others_cooperated_prev
        other_defection_rate_prev = num_others_defected_prev / (self.game_description.n_players - 1)
        if other_defection_rate_prev < 0.5:
            return Action.D
        else:
            n = self.game_description.n_players
            current_stock = state.current_stock
            consumption_by_others_if_repeat = num_others_cooperated_prev * (current_stock / (2 * n)) + num_others_defected_prev * (current_stock / n)
            next_stock_if_I_C = self._calculate_next_stock(current_stock, Action.C, consumption_by_others_if_repeat)
            next_stock_if_I_D = self._calculate_next_stock(current_stock, Action.D, consumption_by_others_if_repeat)
            if next_stock_if_I_D < self.MIN_STOCK_THRESHOLD and next_stock_if_I_C >= self.MIN_STOCK_THRESHOLD:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_408(BaseStrategy):
    """
    The Adaptive Harvester strategy aims to maximize a player's total payoff in the Common Pool Resource game.
    It prioritizes defecting for immediate gain when resources are abundant, but strategically cooperates
    to preserve the resource when it's critically low. It also adapts its behavior based on observed
    opponent defection rates to either free-ride on their cooperation or defensively mitigate a
    "race to the bottom" when others are highly exploitative.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_critical_threshold = self.capacity / 2.0
        self.S_healthy_threshold = self.capacity * 0.75
        self.opponent_defection_ratio_threshold = 0.6
        self.n_rounds_to_assess = min(self.n_rounds - 1, 3)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        COOPERATE = Action.C
        DEFECT = Action.D
        if current_round_1_indexed == self.n_rounds:
            return DEFECT
        if current_round_1_indexed <= self.n_rounds_to_assess:
            return DEFECT
        if current_stock < self.S_critical_threshold:
            return COOPERATE
        else:
            total_defections_by_others = np.sum(history.opponent_actions == False)
            total_actions_by_others = history.opponent_actions.size
            avg_defection_rate_across_opponents = 0.0
            if total_actions_by_others > 0:
                avg_defection_rate_across_opponents = total_defections_by_others / total_actions_by_others
            if current_stock > self.S_healthy_threshold:
                return DEFECT
            elif avg_defection_rate_across_opponents <= self.opponent_defection_ratio_threshold:
                return DEFECT
            else:
                return COOPERATE

class Strategy_EXPLOITATIVE_409(BaseStrategy):
    """
    The "Adaptive Shark" strategy is an aggressive, self-interested approach that defaults to defection to
    maximize immediate payoffs. It adapts its behavior based on opponent cooperation rates and the
    common resource's health, only cooperating strategically to prevent resource collapse that would
    diminish its own future payoffs, or to set up free-riding opportunities.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.ENDGAME_ROUNDS = 3
        self.CRITICAL_STOCK_RATIO = 0.33
        self.MODERATE_STOCK_RATIO = 0.5
        self.HIGH_COOP_RATE_THRESHOLD = 0.6
        self.LOW_COOP_RATE_THRESHOLD = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.D
        if current_round_0_indexed >= r - self.ENDGAME_ROUNDS:
            return Action.D
        if current_stock <= capacity * self.CRITICAL_STOCK_RATIO:
            return Action.D
        num_past_rounds_with_actions = current_round_0_indexed
        total_other_actions = (n - 1) * num_past_rounds_with_actions
        total_other_cooperations = np.sum(history.opponent_actions)
        other_coop_rate = 0.0
        if total_other_actions > 0:
            other_coop_rate = total_other_cooperations / total_other_actions
        if other_coop_rate >= self.HIGH_COOP_RATE_THRESHOLD:
            return Action.D
        if other_coop_rate < self.LOW_COOP_RATE_THRESHOLD:
            if current_stock <= capacity * self.MODERATE_STOCK_RATIO:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_410(BaseStrategy):
    """
    The Apex Predator strategy for the Common Pool Resource Game.
    Maximizes cumulative payoff by balancing aggressive defection with resource conservation.
    It defects unconditionally in endgame rounds, cooperates if the resource is critically low,
    and otherwise adapts its behavior based on opponents' previous-round defections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description: CommonPoolDescription = game_description
        self.endgame_rounds: int = 2
        self.s_critical_ratio: float = 0.3
        self.cooperation_threshold_opponent_defection_percentage: float = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players: int = self.game_description.n_players
        n_rounds: int = self.game_description.n_rounds
        capacity: float = self.game_description.capacity
        current_round_number: int = state.round_number
        current_stock: float = state.current_stock
        if current_round_number >= n_rounds - self.endgame_rounds:
            return Action.D
        s_critical_absolute: float = capacity * self.s_critical_ratio
        if current_stock < s_critical_absolute:
            return Action.C
        if current_round_number == 0:
            return Action.D
        previous_round_opponent_actions: NDArray[np.bool_] = history.opponent_actions[-1, :]
        num_opponent_D_last_round: int = np.sum(previous_round_opponent_actions == False)
        opponent_defection_threshold: float = (n_players - 1) * self.cooperation_threshold_opponent_defection_percentage
        if num_opponent_D_last_round >= opponent_defection_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_411(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize immediate gains by defaulting to defection,
    but it is adaptive, switching to cooperation when collective behavior or the resource state
    signals a potential collapse that would ultimately harm its own long-term payoffs.
    It uses history to project future resource levels and makes decisions based on these projections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round == total_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        C_others_prev = sum(history.opponent_actions[-1, :])
        projected_S_remaining_after_consumption = current_stock * C_others_prev / (2.0 * n_players)
        projected_S_remaining_after_consumption = max(0.0, projected_S_remaining_after_consumption)
        projected_growth = 2.0 * projected_S_remaining_after_consumption * (1.0 - projected_S_remaining_after_consumption / capacity)
        projected_next_stock = min(projected_S_remaining_after_consumption + projected_growth, capacity)
        if C_others_prev == 0:
            return Action.C
        if projected_next_stock < n_players * 2.0:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_412(BaseStrategy):
    """
    The "Adaptive Exploiter" strategy balances aggressive defection with critical resource
    preservation. It prioritizes maximizing immediate gains by defaulting to defection,
    while employing safeguards to prevent catastrophic resource collapse and adapting its
    aggressive stance based on observed opponent cooperation, though ultimately defaulting
    to defection in non-critical situations.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.critical_stock_threshold = self.capacity / 2
        self.optimistic_cooperation_threshold = 0.5
        self.history_window = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_t_0_indexed = state.round_number
        if round_t_0_indexed == self.n_rounds - 1:
            return Action.D
        if current_stock < self.critical_stock_threshold:
            return Action.C
        if round_t_0_indexed == 0:
            return Action.D
        start_history_round_idx = max(0, round_t_0_indexed - self.history_window)
        history_slice = history.opponent_actions[start_history_round_idx:round_t_0_indexed, :]
        total_cooperations = np.sum(history_slice)
        total_opponent_actions_in_window = history_slice.shape[0] * history_slice.shape[1]
        opponent_cooperation_rate = 0.0
        if total_opponent_actions_in_window > 0:
            opponent_cooperation_rate = total_cooperations / total_opponent_actions_in_window
        if opponent_cooperation_rate >= self.optimistic_cooperation_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_413(BaseStrategy):
    """
    Adaptive Predator strategy for the Common Pool Resource Game.

    Core Principle: Prioritize immediate exploitation by defecting, but implement
    calculated cooperation when the resource is threatened or when it offers a
    strategic advantage for future exploitation. It adapts its behavior based
    on the current stock level, the stage of the game, and the observed behavior
    of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_CRIT_THRESHOLD_MULTIPLIER = 0.25
        self.AVG_DEFECTION_LOOKBACK_ROUNDS = 3
        self.LOW_DEFECTION_BY_OTHERS_THRESHOLD = 0.3
        self.HIGH_DEFECTION_BY_OTHERS_THRESHOLD = 0.7
        self.HEALTHY_STOCK_FOR_DEFECTION_IN_MIXED_ENVIRONMENT = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        S_crit_level = self.capacity * self.S_CRIT_THRESHOLD_MULTIPLIER
        if current_round_1_indexed == self.r:
            return Action.D
        if current_stock < S_crit_level:
            return Action.C
        if state.round_number == 0:
            if current_stock == self.capacity:
                return Action.D
            else:
                return Action.D
        num_rounds_to_consider = min(state.round_number, self.AVG_DEFECTION_LOOKBACK_ROUNDS)
        if num_rounds_to_consider == 0:
            return Action.D
        num_players_excluding_self = self.n - 1
        if num_players_excluding_self == 0:
            return Action.D
        recent_opponent_actions = history.opponent_actions[-num_rounds_to_consider:]
        total_defections_by_others_in_history = np.sum(~recent_opponent_actions)
        denominator = num_rounds_to_consider * num_players_excluding_self
        if denominator == 0:
            return Action.D
        Avg_Defection_Rate_Others = total_defections_by_others_in_history / denominator
        if Avg_Defection_Rate_Others < self.LOW_DEFECTION_BY_OTHERS_THRESHOLD:
            return Action.D
        elif Avg_Defection_Rate_Others > self.HIGH_DEFECTION_BY_OTHERS_THRESHOLD:
            return Action.D
        elif current_stock < self.capacity * self.HEALTHY_STOCK_FOR_DEFECTION_IN_MIXED_ENVIRONMENT:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_414(BaseStrategy):
    """
    Opportunistic Exploiter with Collapse Aversion strategy for the Common Pool Resource Game.
    This strategy prioritizes immediate exploitation (Defect) but incorporates a crucial
    self-preservation mechanism to prevent the resource from collapsing entirely. It only
    switches to cooperation when its continued defection, combined with observed opponent
    behavior, is projected to render the resource effectively useless for future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        if self.n_players <= 0:
            self.epsilon = 0.0
        else:
            self.epsilon = self.capacity / (100.0 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_k = state.round_number + 1
        current_stock_S = state.current_stock
        if current_round_k == self.n_rounds:
            return Action.D
        if current_round_k == 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        c_others_prev_round = np.sum(previous_round_opponent_actions)
        d_others_prev_round = self.n_players - 1 - c_others_prev_round
        my_consumption_if_D = current_stock_S / self.n_players if self.n_players > 0 else 0.0
        others_consumption = 0.0
        if self.n_players > 0:
            others_consumption = d_others_prev_round * (current_stock_S / self.n_players) + c_others_prev_round * (current_stock_S / (2.0 * self.n_players))
        total_consumption_projected = my_consumption_if_D + others_consumption
        S_after_consumption_projected = max(0.0, current_stock_S - total_consumption_projected)
        growth_factor = 0.0
        if self.capacity > 0:
            growth_factor = 1.0 - S_after_consumption_projected / self.capacity
        growth_projected = 2.0 * S_after_consumption_projected * growth_factor
        next_stock_projected = min(S_after_consumption_projected + growth_projected, self.capacity)
        if next_stock_projected < self.epsilon:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_415(BaseStrategy):
    """
    The "Adaptive Predator" strategy for the Common Pool Resource game.
    This strategy aims to maximize its own total payoff by defecting whenever possible,
    and strategically cooperating only when necessary to ensure the long-term viability
    of the resource for future exploitation. It adapts its behavior based on the
    current stock level and the observed actions of other players from the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_CRITICAL_THRESHOLD = float(self.n_players)
        self.S_RECOVERY_ZONE_THRESHOLD = self.capacity / 4.0
        self.OPPONENT_DEFECTION_HIGH_THRESHOLD = 0.6
        self.OPPONENT_DEFECTION_LOW_THRESHOLD = 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0:
            return Action.D
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        defection_count_others_prev_round = 0
        for opponent_action_bool in history.opponent_actions[-1, :]:
            if not opponent_action_bool:
                defection_count_others_prev_round += 1
        defection_rate_others = float(defection_count_others_prev_round) / (self.n_players - 1)
        if current_stock < self.S_CRITICAL_THRESHOLD:
            if defection_rate_others > self.OPPONENT_DEFECTION_HIGH_THRESHOLD:
                return Action.D
            else:
                return Action.C
        elif current_stock < self.S_RECOVERY_ZONE_THRESHOLD:
            if defection_rate_others < self.OPPONENT_DEFECTION_LOW_THRESHOLD:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_416(BaseStrategy):
    """
    Adaptive Free-Rider with Collapse Aversion: Prioritizes defection for maximum immediate payoff,
    but switches to cooperation if the resource is critically low or if other players are
    over-exploiting. This is done not out of altruism, but to prevent resource collapse and
    ensure future exploitation opportunities for itself.

    Assumption Clarification:
    This strategy is designed based on the assumption that the stock level 'current_stock'
    can range from 0 up to 'capacity'. It ignores the potential typo in the problem
    statement '0 <= stock <= 2n', which contradicts the 'capacity >= 2n' parameter
    and the provided example calculations.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.collapse_threshold_ratio = 0.25
        self.defection_tolerance_ratio = 0.6
        self.monitoring_window = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        avg_other_defection_rate = 0.0
        num_available_history_rounds = current_round
        num_rounds_to_consider = min(num_available_history_rounds, self.monitoring_window)
        if num_rounds_to_consider > 0:
            recent_opponent_actions = history.opponent_actions[current_round - num_rounds_to_consider:current_round, :]
            total_defections_by_others = np.sum(~recent_opponent_actions)
            total_opportunities_for_defection = recent_opponent_actions.size
            if total_opportunities_for_defection > 0:
                avg_other_defection_rate = total_defections_by_others / total_opportunities_for_defection
        is_stock_critical = current_stock < self.capacity * self.collapse_threshold_ratio
        are_others_over_exploiting = avg_other_defection_rate > self.defection_tolerance_ratio
        if is_stock_critical or are_others_over_exploiting:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_417(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its own total payoff by aggressively exploiting
    cooperative behavior from opponents while safeguarding the resource from complete collapse
    only when absolutely necessary for its own long-term benefit.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.very_critical_stock_frac = 0.1
        self.cooperative_threshold = 0.7
        self.aggressive_defection_threshold = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == 0:
            return Action.C
        if current_round_0_indexed == r - 1:
            return Action.D
        previous_round_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        num_others_cooperated_last_round = np.sum(previous_round_actions)
        num_others = n - 1
        cooperation_rate_others = num_others_cooperated_last_round / num_others
        if current_stock < capacity * self.very_critical_stock_frac:
            return Action.C
        elif cooperation_rate_others >= self.cooperative_threshold:
            return Action.D
        elif cooperation_rate_others <= self.aggressive_defection_threshold:
            return Action.D
        else:
            num_others_defecting_last_round = num_others - num_others_cooperated_last_round
            k_total_D_if_I_defect = num_others_defecting_last_round + 1
            predicted_S_remaining_after_consumption = current_stock * (n - k_total_D_if_I_defect) / (2 * n)
            if predicted_S_remaining_after_consumption < capacity * self.very_critical_stock_frac:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_418(BaseStrategy):
    """
    Opportunistic Predator: This strategy aims to aggressively extract resources (Defect)
    when the stock is abundant or when other players are cooperative, to maximize immediate gains.
    It only cooperates strategically when the resource is critically low AND there's a strong
    signal from opponents that they are willing to cooperate, viewing this cooperation as a
    necessary investment to prolong the game and allow for future exploitation.
    In end-game scenarios, all incentives for cooperation vanish, leading to consistent defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_RATIO = 0.25
        self.COOPERATIVE_OPPONENT_THRESHOLD = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_idx = state.round_number
        current_stock = state.current_stock
        if current_round_idx == 0:
            return Action.D
        if current_round_idx == self.n_rounds - 1:
            return Action.D
        total_opponent_defections_observed = np.sum(~history.opponent_actions)
        total_possible_opponent_actions = history.opponent_actions.size
        if total_possible_opponent_actions == 0:
            avg_opponent_defection_rate = 0.0
        else:
            avg_opponent_defection_rate = total_opponent_defections_observed / total_possible_opponent_actions
        is_stock_critical = current_stock < self.CRITICAL_STOCK_RATIO * self.capacity
        action_to_play = Action.D
        if is_stock_critical:
            if avg_opponent_defection_rate < self.COOPERATIVE_OPPONENT_THRESHOLD:
                action_to_play = Action.C
        else:
            action_to_play = Action.D
        return action_to_play

class Strategy_EXPLOITATIVE_419(BaseStrategy):
    """
    Opportunistic Predator Strategy: Default to aggressive extraction (Defect).
    Only temporarily cooperate if the resource is critically endangered AND
    cooperation can demonstrably prolong its life sufficiently for future exploitation,
    given the observed behavior of other players. Always prioritize immediate gain in the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_danger_threshold = self.capacity / (2.0 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        if current_round_0_indexed == 0:
            return Action.D
        if current_round_1_indexed >= self.n_rounds - 1:
            return Action.D
        last_round_opponent_actions = history.opponent_actions[-1, :]
        last_round_D_count = np.sum(~last_round_opponent_actions)
        last_round_C_count = np.sum(last_round_opponent_actions)
        if current_stock <= self.stock_danger_threshold:
            consumption_by_others_hypothetical = last_round_D_count * current_stock / self.n_players + last_round_C_count * current_stock / (2.0 * self.n_players)
            my_C_consumption = current_stock / (2.0 * self.n_players)
            total_consumption_if_I_C = consumption_by_others_hypothetical + my_C_consumption
            s_remaining_if_I_C = max(0.0, current_stock - total_consumption_if_I_C)
            growth_if_I_C = 2.0 * s_remaining_if_I_C * (1.0 - s_remaining_if_I_C / self.capacity)
            next_stock_if_I_C = min(s_remaining_if_I_C + growth_if_I_C, self.capacity)
            my_D_consumption = current_stock / self.n_players
            total_consumption_if_I_D = consumption_by_others_hypothetical + my_D_consumption
            s_remaining_if_I_D = max(0.0, current_stock - total_consumption_if_I_D)
            growth_if_I_D = 2.0 * s_remaining_if_I_D * (1.0 - s_remaining_if_I_D / self.capacity)
            next_stock_if_I_D = min(s_remaining_if_I_D + growth_if_I_D, self.capacity)
            if next_stock_if_I_C > next_stock_if_I_D and next_stock_if_I_C > self.stock_danger_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_420(BaseStrategy):
    """
    The "Opportunistic Predator" strategy is designed to maximize its own total payoff over the game's
    duration. It balances immediate gains from defection with the need to sustain the common pool
    resource for future exploitation. It is adaptive, reactive to opponent behavior, and robust
    against various strategies, with a clear focus on self-interest.
    """
    _CRITICAL_STOCK_THRESHOLD_RATIO = 0.2
    _JOIN_DEFECTION_THRESHOLD_RATIO = 0.5
    _RECOVERY_COOPERATION_GAIN_FACTOR = 0.5
    _MIN_ROUNDS_FOR_LONG_TERM_CONSIDERATION_RATIO = 0.25
    _FUTURE_STOCK_IMPACT_DIFFERENCE_RATIO = 0.75

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initialises the strategy with game parameters and internal tunable constants.
        """
        self.game_description = game_description
        self.critical_stock_threshold_ratio = self._CRITICAL_STOCK_THRESHOLD_RATIO
        self.join_defection_threshold_ratio = self._JOIN_DEFECTION_THRESHOLD_RATIO
        self.recovery_cooperation_gain_factor = self._RECOVERY_COOPERATION_GAIN_FACTOR
        self.min_rounds_for_long_term_consideration_ratio = self._MIN_ROUNDS_FOR_LONG_TERM_CONSIDERATION_RATIO
        self.future_stock_impact_difference_ratio = self._FUTURE_STOCK_IMPACT_DIFFERENCE_RATIO

    def _calculate_next_stock(self, current_stock: float, total_consumption: float, capacity: float) -> float:
        """
        Helper function to calculate the next stock level based on the game's stock dynamics.
        """
        S_after_consumption = current_stock - total_consumption
        growth = 2.0 * S_after_consumption * (1.0 - S_after_consumption / capacity)
        new_stock_unclamped = S_after_consumption + growth
        final_stock = min(max(0.0, new_stock_unclamped), capacity)
        return final_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) for the current round.
        """
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_round_1_indexed == total_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        num_opponent_cooperators_prev = np.sum(history.opponent_actions[-1, :])
        num_opponent_defections_prev = n_players - 1 - num_opponent_cooperators_prev
        rounds_remaining = total_rounds - current_round_1_indexed
        my_potential_C_consumption = current_stock / (2.0 * n_players)
        my_potential_D_consumption = current_stock / (1.0 * n_players)
        opponent_consumption_if_repeated = num_opponent_defections_prev * my_potential_D_consumption + num_opponent_cooperators_prev * my_potential_C_consumption
        total_consumption_if_I_C = opponent_consumption_if_repeated + my_potential_C_consumption
        next_stock_if_I_C = self._calculate_next_stock(current_stock, total_consumption_if_I_C, capacity)
        total_consumption_if_I_D = opponent_consumption_if_repeated + my_potential_D_consumption
        next_stock_if_I_D = self._calculate_next_stock(current_stock, total_consumption_if_I_D, capacity)
        critical_stock_level = capacity * self.critical_stock_threshold_ratio
        if current_stock <= critical_stock_level:
            cond_a = next_stock_if_I_C - next_stock_if_I_D <= my_potential_D_consumption * self.recovery_cooperation_gain_factor
            cond_b = next_stock_if_I_C <= critical_stock_level / 2.0
            cond_c = num_opponent_defections_prev >= (n_players - 1) * self.join_defection_threshold_ratio
            if cond_a or cond_b or cond_c:
                return Action.D
            else:
                return Action.C
        if num_opponent_defections_prev >= (n_players - 1) * self.join_defection_threshold_ratio:
            return Action.D
        if rounds_remaining > total_rounds * self.min_rounds_for_long_term_consideration_ratio:
            cond_lt_1 = next_stock_if_I_D < next_stock_if_I_C * self.future_stock_impact_difference_ratio
            cond_lt_2 = next_stock_if_I_D <= critical_stock_level
            cond_lt_3 = current_stock > critical_stock_level
            if cond_lt_1 and cond_lt_2 and cond_lt_3:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_421(BaseStrategy):
    """
    The Adaptive Free-Rider strategy is designed to be highly exploitative while
    remaining adaptive and robust. It prioritizes maximizing its own payoff by
    defaulting to Defect (D) to free-ride on others' cooperation.

    Strategic Cooperation (C) is reserved for specific situations where it
    demonstrably serves the player's long-term interest by preventing resource
    collapse and enabling future exploitation, but only if a sufficient number
    of other players are also cooperating.

    When the common pool resource is severely threatened or collapsing due to
    widespread defection, the strategy defects to grab its share rather than
    being a "sucker" by cooperating alone. In the final round, pure self-interest
    dictates defection as there are no future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.STOCK_DANGER_THRESHOLD_RATIO = 0.33
        self.STOCK_COLLAPSE_THRESHOLD_RATIO = 0.1
        self.MIN_OTHERS_COOPERATION_FOR_MY_C = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.n_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        else:
            num_C_others_prev_round = np.sum(history.opponent_actions[-1, :])
            proportion_others_cooperated = 0.0
            if self.n_players - 1 > 0:
                proportion_others_cooperated = num_C_others_prev_round / (self.n_players - 1)
            stock_danger_threshold = self.capacity * self.STOCK_DANGER_THRESHOLD_RATIO
            stock_collapse_threshold = self.capacity * self.STOCK_COLLAPSE_THRESHOLD_RATIO
            if current_stock < stock_collapse_threshold:
                return Action.D
            elif current_stock < stock_danger_threshold:
                if proportion_others_cooperated >= self.MIN_OTHERS_COOPERATION_FOR_MY_C:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_422(BaseStrategy):
    """
    The Opportunistic Predator strategy aims to maximize personal payoff by primarily defecting,
    but includes adaptive safeguards to ensure the resource isn't entirely depleted if it means
    sacrificing future gains. It leverages opponent cooperation and reacts to the overall health
    of the common pool.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_RATIO = 0.5
        self.DOOMSDAY_STOCK_RATIO = 0.1
        self.COOPERATION_THRESHOLD_FOR_EXPLOIT = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_1_indexed = state.round_number + 1
        s_doomsday = capacity * self.DOOMSDAY_STOCK_RATIO
        s_critical = capacity * self.CRITICAL_STOCK_RATIO
        if current_stock <= s_doomsday:
            return Action.D
        if current_round_1_indexed == n_rounds:
            return Action.D
        if current_stock <= s_critical:
            return Action.C
        if current_round_1_indexed == 1:
            return Action.D
        num_others_cooperated_last_round = sum(history.opponent_actions[-1, :])
        n_others = n_players - 1
        cooperation_rate_of_others = num_others_cooperated_last_round / n_others
        if cooperation_rate_of_others >= self.COOPERATION_THRESHOLD_FOR_EXPLOIT:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_423(BaseStrategy):
    """
    The Adaptive Exploiter strategy aims to maximize its own total payoff over the game's rounds
    by opportunistically defecting. It preserves the common resource only when critically low
    and when there's a strong signal that enough other players are also cooperating, adapting
    to observed opponent behavior. It prioritizes immediate gains unless future gains are
    significantly jeopardized, and exploits the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOPERATION_THRESHOLD_STOCK_FACTOR = 0.25

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        stock = state.current_stock
        if current_round_0_indexed == r - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        num_opponent_cooperators_last_round = np.sum(previous_round_opponent_actions)
        num_opponent_defectors_last_round = n - 1 - num_opponent_cooperators_last_round
        critically_low_stock_level = capacity * self.COOPERATION_THRESHOLD_STOCK_FACTOR
        is_stock_critically_low = stock < critically_low_stock_level
        if is_stock_critically_low:
            if num_opponent_defectors_last_round > (n - 1) / 2.0:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_424(BaseStrategy):
    """
    Ruthless Opportunist strategy: Prioritizes immediate individual gain (Defect)
    unless the common stock is dangerously low AND other players are showing
    sufficient restraint. If others are exploiting heavily when the stock is low,
    cooperation is deemed futile, and the strategy reverts to maximizing its share.
    Aggressively defects in initial and final rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOPERATION_REGENERATION_THRESHOLD_FACTOR = 0.4
        self.OPPONENT_DEFECTION_TOLERANCE = 0.5
        self.INITIAL_AGGRESSION_ROUNDS = 2
        self.RECENCY_WINDOW = 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        if current_round_0_indexed < self.INITIAL_AGGRESSION_ROUNDS:
            return Action.D
        avg_opponent_defection_rate = 0.0
        history_start_idx = max(0, current_round_0_indexed - self.RECENCY_WINDOW)
        if history is not None and history.opponent_actions.shape[0] > 0:
            relevant_opponent_actions = history.opponent_actions[history_start_idx:current_round_0_indexed, :]
            total_opponent_actions_observed = relevant_opponent_actions.size
            if total_opponent_actions_observed > 0:
                total_opponent_defections_observed = np.sum(~relevant_opponent_actions)
                avg_opponent_defection_rate = total_opponent_defections_observed / total_opponent_actions_observed
        cooperation_regeneration_threshold = capacity * self.COOPERATION_REGENERATION_THRESHOLD_FACTOR
        if current_stock < cooperation_regeneration_threshold:
            if avg_opponent_defection_rate <= self.OPPONENT_DEFECTION_TOLERANCE:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_425(BaseStrategy):
    """
    Ruthless Exploiter strategy for the Common Pool Resource game.

    This strategy aims to maximize its own total payoff by primarily defecting
    (taking more from the resource). It only cooperates under specific
    conditions: when the resource is critically low AND there's a perceived
    chance of collective recovery due to opponents' prior cooperative tendencies.
    It defects in the first and final rounds to maximize immediate gains without
    future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.opponent_defection_tolerance_threshold = 0.7
        self.critical_stock_ratio = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_num = state.round_number + 1
        if current_round_num == 1:
            return Action.D
        if current_round_num == self.n_rounds:
            return Action.D
        total_opponent_defections = np.sum(history.opponent_actions == False)
        total_opponent_actions_observed = history.opponent_actions.size
        average_opponent_defection_rate = 0.0
        if total_opponent_actions_observed > 0:
            average_opponent_defection_rate = total_opponent_defections / total_opponent_actions_observed
        else:
            average_opponent_defection_rate = 1.0
        critical_stock_level = self.capacity * self.critical_stock_ratio
        if state.current_stock < critical_stock_level:
            if average_opponent_defection_rate < self.opponent_defection_tolerance_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_426(BaseStrategy):
    """
    The Greedy Predator strategy aims to maximize personal total payoff by prioritizing immediate gains
    while ensuring sufficient resource for future exploitation. It defaults to defecting (taking a larger share),
    but strategically cooperates when the resource is critically low (to allow recovery) or when it detects
    an opportunity to encourage others to replenish the resource while maintaining a healthy stock.
    It exploits cooperative players and avoids being a "sucker" by defecting when others are predominantly defecting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD_RATIO = 0.25
        self.HEALTHY_STOCK_RATIO = 0.75
        self.HIGH_COOPERATION_THRESHOLD_D_COUNT = self.game_description.n_players / 3.0
        self.HIGH_DEFECTION_THRESHOLD_D_COUNT = 2.0 * self.game_description.n_players / 3.0
        self.stock_at_start_of_previous_actual_round: float = float(self.game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        num_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = float(self.game_description.capacity)
        round_num = state.round_number + 1
        if round_num == total_rounds:
            self.stock_at_start_of_previous_actual_round = current_stock
            return Action.D
        if round_num == 1:
            self.stock_at_start_of_previous_actual_round = current_stock
            return Action.D
        my_prev_action = history.my_actions[state.round_number - 1]
        opponent_prev_actions = history.opponent_actions[state.round_number - 1, :]
        total_prev_C_count = np.sum(opponent_prev_actions).item()
        if my_prev_action:
            total_prev_C_count += 1
        D_count_prev = num_players - total_prev_C_count
        previous_round_start_stock = self.stock_at_start_of_previous_actual_round
        if previous_round_start_stock == 0:
            D_count_prev = num_players
        if current_stock <= capacity * self.CRITICAL_STOCK_THRESHOLD_RATIO:
            self.stock_at_start_of_previous_actual_round = current_stock
            return Action.C
        action_to_take: Action
        if D_count_prev <= self.HIGH_COOPERATION_THRESHOLD_D_COUNT:
            action_to_take = Action.D
        elif D_count_prev >= self.HIGH_DEFECTION_THRESHOLD_D_COUNT:
            action_to_take = Action.D
        elif current_stock / capacity > self.HEALTHY_STOCK_RATIO:
            action_to_take = Action.D
        else:
            action_to_take = Action.C
        self.stock_at_start_of_previous_actual_round = current_stock
        return action_to_take

class Strategy_EXPLOITATIVE_427(BaseStrategy):
    """
    The Adaptive Opportunistic Exploiter (AOE) strategy for the Common Pool Resource game.
    It prioritizes its own total payoff, adapting to current stock levels, observed
    opponent behavior, and the remaining number of rounds. The strategy aims to maximize
    immediate gain when possible, strategically cooperate only to preserve a resource
    for future exploitation, and avoid being a "sucker" who cooperates while others defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.low_stock_threshold = capacity / (n * 2)
        self.critical_stock_threshold = capacity / n
        self.stable_stock_threshold = capacity / 2
        self.defection_tolerance_rate = 0.4
        self.stock_decline_tolerance_C_D = 0.95
        self.stock_decline_tolerance_D_D = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_t = state.round_number + 1
        total_rounds_r = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if round_t == total_rounds_r:
            return Action.D
        if state.round_number == 0:
            return Action.D
        else:
            my_action_prev_bool = history.my_actions[state.round_number - 1]
            num_other_defectors_prev = np.sum(~history.opponent_actions[state.round_number - 1, :])
            others_defection_rate = num_other_defectors_prev / (n_players - 1)
            stock_at_prev_round_start = history.my_payoffs[state.round_number - 1] * (2 * n_players if my_action_prev_bool else n_players)
            if state.current_stock < self.critical_stock_threshold:
                if state.current_stock < self.low_stock_threshold:
                    return Action.D
                elif others_defection_rate > self.defection_tolerance_rate:
                    return Action.D
                else:
                    return Action.C
            elif my_action_prev_bool:
                if others_defection_rate > self.defection_tolerance_rate:
                    return Action.D
                elif state.current_stock < stock_at_prev_round_start * self.stock_decline_tolerance_C_D and state.current_stock < self.stable_stock_threshold:
                    return Action.C
                else:
                    return Action.D
            elif others_defection_rate > self.defection_tolerance_rate:
                return Action.D
            elif state.current_stock < stock_at_prev_round_start * self.stock_decline_tolerance_D_D and state.current_stock < self.stable_stock_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_428(BaseStrategy):
    """
    The Adaptive Resource Drainer strategy for the Common Pool Resource game.
    This strategy is fundamentally exploitative, prioritizing immediate gains
    by defecting (D), but adapts its behavior based on the common stock level
    and the observed cooperation of other players. This adaptation is a calculated
    move to ensure the resource's longevity for future exploitation, rather than
    for genuine cooperation. It is designed to be robust against various opponent
    strategies without relying on assumptions about their norms or coordination.
    """
    THRESHOLD_STOCK_RATIO: float = 0.5
    RECENT_HISTORY_WINDOW: int = 3
    HIGH_DEFECTION_RATE: float = 0.75

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the AdaptiveResourceDrainer strategy.

        Args:
            game_description (CommonPoolDescription): An object containing
                                                     game parameters like n_players,
                                                     n_rounds, and capacity.
        """
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action for the current round based on game state and history.

        Args:
            state (CommonPoolState): An object containing the current round number
                                     (0-indexed) and current stock level.
            history (None | PlayerHistory): An object containing past actions and payoffs
                                            for this player and opponents. None for the
                                            very first round.

        Returns:
            Action: The chosen action, either Action.C (Cooperate) or Action.D (Defect).
        """
        current_round_0_indexed = state.round_number
        total_rounds_0_indexed = self.game_description.n_rounds - 1
        if current_round_0_indexed == total_rounds_0_indexed:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        num_other_players = self.game_description.n_players - 1
        rounds_to_consider = min(current_round_0_indexed, self.RECENT_HISTORY_WINDOW)
        total_other_defectors = 0
        start_hist_idx = current_round_0_indexed - rounds_to_consider
        end_hist_idx = current_round_0_indexed
        for round_idx in range(start_hist_idx, end_hist_idx):
            total_other_defectors += np.sum(~history.opponent_actions[round_idx, :])
        avg_other_defectors = total_other_defectors / (num_other_players * rounds_to_consider)
        is_stock_low = state.current_stock / self.game_description.capacity < self.THRESHOLD_STOCK_RATIO
        is_others_highly_defection = avg_other_defectors >= self.HIGH_DEFECTION_RATE
        if not is_stock_low:
            return Action.D
        elif is_others_highly_defection:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_429(BaseStrategy):
    """
    The "Adaptive Shark" strategy aims to maximize its total payoff by aggressively exploiting 
    cooperative behavior from other players, while possessing a crucial self-preservation 
    mechanism to prevent the common pool resource from collapsing. It adapts its behavior 
    based on the current stock level and the recent actions of other players.

    Core Principles:
    1. Exploit when safe: When the resource is abundant, defect.
    2. Exploit cooperation: If others are cooperating and the resource is not threatened, free-ride.
    3. Preserve when necessary: If stock drops to critical levels, cooperate for recovery.
    4. Mitigate others' destruction: If others are heavily defecting and threatening the resource, 
       temporarily cooperate to stabilize.
    5. No future consequences in the end: Maximize final payoff in the last round without regard for stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_CRITICAL_LOW_THRESHOLD = self.capacity / (2 * self.n_players)
        self.S_HEALTHY_THRESHOLD = self.capacity / 2
        self.OPPONENT_DEFECTION_TRIGGER = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == self.n_rounds - 1:
            return Action.D
        if round_number == 0:
            return Action.D
        if current_stock < self.S_CRITICAL_LOW_THRESHOLD:
            return Action.C
        if current_stock >= self.S_HEALTHY_THRESHOLD:
            return Action.D
        previous_round_others_actions = history.opponent_actions[round_number - 1, :]
        num_defectors_others = np.sum(~previous_round_others_actions)
        defection_rate_others = 0.0
        defection_rate_others = num_defectors_others / (self.n_players - 1)
        if defection_rate_others >= self.OPPONENT_DEFECTION_TRIGGER:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_430(BaseStrategy):
    """
    The Opportunistic Stock Manager strategy aims to maximize individual payoff by exploiting
    others' cooperation when the resource is abundant, while strategically cooperating
    to prevent total resource collapse when it's under threat. This ensures there's a
    resource left to exploit in future rounds, making it both exploitative and robust.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOPERATION_THRESHOLD_STOCK = self.game_description.capacity / 2
        self.DEFECTION_TOLERANCE_RATE = 0.25
        self.DOOMED_RESOURCE_DEFECTION_RATE = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        num_opponents_defected_last_round = 0
        opponent_count = self.game_description.n_players - 1
        if state.round_number > 0 and history is not None:
            previous_round_opponent_actions = history.opponent_actions[state.round_number - 1]
            num_opponents_defected_last_round = opponent_count - sum(previous_round_opponent_actions)
        opponent_defection_rate = 0.0
        if opponent_count > 0:
            opponent_defection_rate = num_opponents_defected_last_round / opponent_count
        current_stock = state.current_stock
        if current_stock < self.COOPERATION_THRESHOLD_STOCK:
            if opponent_defection_rate >= self.DOOMED_RESOURCE_DEFECTION_RATE:
                return Action.D
            else:
                return Action.C
        elif opponent_defection_rate < self.DEFECTION_TOLERANCE_RATE:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_431(BaseStrategy):
    """
    The "Pragmatic Predator" strategy is designed to be highly exploitative by
    prioritizing immediate gains through defection, while also being adaptive and
    robust by implementing self-preservation mechanisms to ensure the long-term
    viability of the resource (and thus its own potential for future exploitation).
    It observes opponent behavior indirectly through aggregate cooperation rates
    and directly through stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.SRT = self.capacity / 2.0
        self.Forgiveness_Factor = 0.5
        self.Observation_Window = 3
        self.SRT_Buffer = self.SRT + (self.capacity - self.SRT) / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_stock <= self.SRT:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.D
        start_history_idx = max(0, current_round_0_indexed - self.Observation_Window)
        num_cooperating_opponents_in_window = np.sum(history.opponent_actions[start_history_idx:current_round_0_indexed, :])
        rounds_in_window = current_round_0_indexed - start_history_idx
        num_opponents = self.n_players - 1
        num_observed_opponent_actions = rounds_in_window * num_opponents
        avg_opponent_cooperation_rate = 0.0
        if num_observed_opponent_actions > 0:
            avg_opponent_cooperation_rate = num_cooperating_opponents_in_window / num_observed_opponent_actions
        if avg_opponent_cooperation_rate >= self.Forgiveness_Factor:
            return Action.D
        elif current_stock <= self.SRT_Buffer:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_432(BaseStrategy):
    """
    The Aggressive Opportunist strategy aims to maximize personal payoff in the Common Pool Resource Game.
    It prioritizes immediate extraction when the resource is abundant, free-rides on cooperators, and
    only strategically cooperates to preserve the resource for future exploitation if there's a good
    chance of success or to avoid "sucker play" when others are defecting. It defects in the first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_RHI_THRESHOLD = 0.2
        self.MODERATE_RHI_THRESHOLD = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock_S = state.current_stock
        RHI = current_stock_S / capacity
        if state.round_number == 0:
            return Action.D
        if state.round_number == r - 1:
            return Action.D
        num_opponents_cooperated_prev = history.opponent_actions[-1, :].sum()
        num_opponents_defected_prev = n - 1 - num_opponents_cooperated_prev
        majority_or_half_defecting_threshold = (n - 1) / 2.0
        if RHI > self.MODERATE_RHI_THRESHOLD:
            return Action.D
        elif RHI > self.CRITICAL_RHI_THRESHOLD:
            if num_opponents_defected_prev >= majority_or_half_defecting_threshold:
                return Action.D
            else:
                return Action.C
        elif num_opponents_defected_prev >= majority_or_half_defecting_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_433(BaseStrategy):
    """
    The Adaptive Exploiter strategy for the Common Pool Resource game.
    It primarily defects to maximize immediate payoff but intelligently assesses
    resource health and collective opponent behavior to decide when a temporary,
    strategic cooperation might be necessary to ensure long-term exploitability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the strategy with game parameters.
        """
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the action (Cooperate or Defect) for the current round based on
        game state, history, and the Adaptive Exploiter strategy rules.
        """
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        critical_stock_threshold = self.game_description.capacity / 2.0
        num_cooperators_last_round = sum(history.opponent_actions[state.round_number - 1, :])
        n_opponents = self.game_description.n_players - 1
        cooperation_ratio_last_round = num_cooperators_last_round / n_opponents
        current_stock = state.current_stock
        if current_stock < critical_stock_threshold:
            if cooperation_ratio_last_round >= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_434(BaseStrategy):
    """
    Adaptive Free-Rider strategy for the Common Pool Resource game.

    This strategy aims to maximize its own total payoff by defecting aggressively,
    only cooperating in specific, self-serving scenarios to prevent total resource
    collapse and preserve future exploitation opportunities.

    Decision Rules:
    1. First Round: Always Defect. Establish an aggressive stance.
    2. Last Round: Always Defect. Maximize immediate payoff, no future consequences.
    3. Intermediate Rounds:
       a. If stock is critically low (< stock_collapse_threshold):
          - If a widespread majority of others defected previously: Defect (resource is doomed).
          - Else (others trying to save it): Cooperate (strategic investment in future exploitation).
       b. If stock is not critically low:
          - If all others defected previously:
            - If more than one round remains: Cooperate (prevent immediate crash, preserve future gains).
            - Else (only penultimate round): Defect (no point in sacrifice).
          - Else (not all others defected): Defect (default free-riding behavior).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_collapse_threshold = self.capacity / (2 * self.n)
        self.widespread_defection_threshold = math.floor((self.n - 1) / 2) + 1
        self.critical_defection_threshold = self.n - 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == 1:
            return Action.D
        if current_round_1_indexed == self.r:
            return Action.D
        rounds_remaining = self.r - current_round_1_indexed
        num_D_others_prev = np.sum(~history.opponent_actions[-1, :])
        if current_stock < self.stock_collapse_threshold:
            if num_D_others_prev >= self.widespread_defection_threshold:
                return Action.D
            else:
                return Action.C
        elif num_D_others_prev == self.critical_defection_threshold:
            if rounds_remaining > 1:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_435(BaseStrategy):
    """
    The Resource-Aware Free Rider strategy aims to maximize individual payoff by defaulting to defection
    (exploitation) while dynamically adjusting to cooperation only when the collective actions,
    including its own defection, threaten the long-term sustainability of the common pool resource,
    thereby jeopardizing its own future payoffs. It prioritizes self-interest and only contributes
    to resource preservation out of pragmatic necessity for its own continued extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_index = state.round_number
        current_round_number = current_round_index + 1
        current_stock = state.current_stock
        if current_round_number == self.total_rounds:
            return Action.D
        if current_round_number == 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        num_other_cooperators = np.sum(previous_round_opponent_actions)
        num_other_defectors = self.n_players - 1 - num_other_cooperators
        S = current_stock
        consumption_me_D = S / self.n_players
        consumption_others = num_other_cooperators * (S / (2 * self.n_players)) + num_other_defectors * (S / self.n_players)
        total_consumption_projection_if_I_D = consumption_me_D + consumption_others
        S_after_consumption_if_I_D = max(0.0, S - total_consumption_projection_if_I_D)
        growth_projection_if_I_D = 2 * S_after_consumption_if_I_D * (1 - S_after_consumption_if_I_D / self.capacity)
        projected_new_stock_if_I_D = min(S_after_consumption_if_I_D + growth_projection_if_I_D, self.capacity)
        critical_S_after_consumption_threshold = self.capacity / (4 * self.n_players)
        if S_after_consumption_if_I_D < critical_S_after_consumption_threshold:
            return Action.C
        optimal_growth_point = self.capacity / 2
        if projected_new_stock_if_I_D < S and projected_new_stock_if_I_D < optimal_growth_point:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_436(BaseStrategy):
    """
    The Adaptive Predator strategy is designed to be highly exploitative. It prioritizes maximizing
    its own total payoff over the game by taking advantage of immediate gains and the cooperation
    of other players, while employing a calculated risk management approach to prevent total
    resource collapse only when it directly benefits its own long-term exploitation potential.

    The strategy is adaptive, responding to both the current resource stock level and the
    observed behavior of other players, and adjusts its aggression based on the number of
    rounds remaining.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.low_stock_threshold_ratio: float = 0.25
        self.opponent_cooperation_threshold: float = 0.5
        self.endgame_rounds_threshold_value: int = max(1, math.floor(self.game_description.n_rounds / 4))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if current_round_1_indexed > total_rounds - self.endgame_rounds_threshold_value:
            return Action.D
        else:
            avg_cooperation_rate: float = 0.0
            if current_round_0_indexed == 0:
                avg_cooperation_rate = 0.5
            else:
                opponent_actions_prev_round = history.opponent_actions[current_round_0_indexed - 1]
                num_cooperators_prev_round = np.sum(opponent_actions_prev_round)
                num_other_players = n_players - 1
                if num_other_players > 0:
                    avg_cooperation_rate = num_cooperators_prev_round / num_other_players
                else:
                    avg_cooperation_rate = 0.0
            if current_stock / capacity <= self.low_stock_threshold_ratio:
                if avg_cooperation_rate >= self.opponent_cooperation_threshold:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_437(BaseStrategy):
    """
    The Calculated Predator strategy for the Common Pool Resource game.
    This strategy prioritizes immediate exploitation (Defect) but incorporates
    self-preservation mechanisms to prevent total collapse of the common stock
    and ensures the resource remains exploitable for future gains. It adapts
    its risk assessment based on observed opponent behavior and remaining rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.MIN_SUSTAINABLE_STOCK_RATIO: float = 0.3
        self.COLLAPSE_THRESHOLD_RATIO: float = 0.1
        self.HISTORY_WINDOW: int = 3
        self.HISTORY_WINDOW = max(0, self.HISTORY_WINDOW)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_idx = state.round_number
        predicted_num_C_others = 0
        if current_round_idx == 0:
            predicted_num_C_others = round((n - 1) * 0.5)
        else:
            total_C_by_others_in_history = 0
            rounds_to_consider = min(current_round_idx, self.HISTORY_WINDOW)
            if rounds_to_consider > 0:
                start_history_idx = current_round_idx - rounds_to_consider
                total_C_by_others_in_history = np.sum(history.opponent_actions[start_history_idx:current_round_idx, :])
                OCR = total_C_by_others_in_history / (rounds_to_consider * (n - 1))
                predicted_num_C_others = round(OCR * (n - 1))
            else:
                predicted_num_C_others = round((n - 1) * 0.5)
        predicted_num_C_others = max(0, min(n - 1, predicted_num_C_others))
        predicted_num_D_others = n - 1 - predicted_num_C_others

        def calculate_next_stock(my_action_is_C: bool) -> float:
            my_consumption = current_stock / (2 * n) if my_action_is_C else current_stock / n
            total_consumption_by_others = predicted_num_D_others * current_stock / n + predicted_num_C_others * current_stock / (2 * n)
            total_consumption = my_consumption + total_consumption_by_others
            s_remaining = max(0.0, current_stock - total_consumption)
            growth = 2 * s_remaining * (1 - s_remaining / capacity)
            next_stock = min(capacity, s_remaining + growth)
            return next_stock
        predicted_next_stock_if_I_D = calculate_next_stock(my_action_is_C=False)
        predicted_next_stock_if_I_C = calculate_next_stock(my_action_is_C=True)
        if current_round_idx >= r - 2:
            return Action.D
        if predicted_next_stock_if_I_D < self.COLLAPSE_THRESHOLD_RATIO * capacity:
            if predicted_next_stock_if_I_C >= self.COLLAPSE_THRESHOLD_RATIO * capacity:
                return Action.C
            else:
                return Action.D
        if current_stock < self.MIN_SUSTAINABLE_STOCK_RATIO * capacity:
            if predicted_next_stock_if_I_D < current_stock and predicted_next_stock_if_I_C > current_stock:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_438(BaseStrategy):
    """
    The "Adaptive Predator" strategy is designed to maximize its own cumulative payoff by consistently seeking
    opportunities to defect, while only cooperating as a necessary measure for self-preservation of the common
    resource or in response to critical conditions. It is aggressive, opportunistic, and aims to free-ride on
    the cooperation of others or join the race to extract if others are defecting.

    It prioritizes individual gain, aggressively defecting to maximize immediate payoffs. It only resorts to
    cooperation when the common resource is critically endangered, as a pragmatic move to ensure future exploitation
    opportunities. It does not aim to foster cooperation, but rather to benefit from it or to ensure it doesn't fall
    behind if others are defecting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = capacity / (4.0 * n)
        self.EXPLOIT_STOCK_HIGH_THRESHOLD = capacity * 0.75
        self.DEFECTOR_TOLERANCE_THRESHOLD = math.floor((n - 1) / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        r = self.game_description.n_rounds
        if current_round == 0:
            return Action.D
        if current_round == r - 1:
            return Action.D
        if current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        if current_stock >= self.EXPLOIT_STOCK_HIGH_THRESHOLD:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_439(BaseStrategy):
    """
    The Opportunistic Shark strategy is designed to be highly exploitative,
    prioritizing its own immediate and projected long-term payoff by maximizing consumption,
    while being adaptive enough to prevent the resource from collapsing prematurely (and thus
    ending its own exploitation opportunities) unless collapse is inevitable due to other players' actions.

    It maximizes personal gain by defecting (taking more) whenever possible. Only cooperates if doing so
    is demonstrably beneficial for ensuring future exploitation, specifically when the common resource
    is critically low AND other players show a willingness to conserve. Otherwise, if the resource is
    healthy or doomed by others' actions, it takes as much as possible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.W = 4
        self.LOW_STOCK_EMERGENCY_FACTOR = 2.0
        self.CONSERVATION_HOPE_THRESHOLD = 0.5
        self.DEFECTION_PROPAGATION_THRESHOLD = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = float(self.game_description.capacity)
        current_round = state.round_number
        current_stock = state.current_stock
        LSET = capacity / (n * self.LOW_STOCK_EMERGENCY_FACTOR)
        if current_round == total_rounds - 1:
            return Action.D
        num_players_other = n - 1
        if current_stock < LSET:
            rounds_to_consider_history = min(current_round, self.W)
            if rounds_to_consider_history > 0:
                recent_opponent_actions = history.opponent_actions[current_round - rounds_to_consider_history:current_round, :]
                observed_cooperations_others = np.sum(recent_opponent_actions)
                total_possible_actions_considered = rounds_to_consider_history * num_players_other
                avg_opponent_cooperation_rate = observed_cooperations_others / total_possible_actions_considered
                if avg_opponent_cooperation_rate >= self.CONSERVATION_HOPE_THRESHOLD:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        else:
            rounds_to_consider_history = min(current_round, self.W)
            if rounds_to_consider_history > 0:
                recent_opponent_actions = history.opponent_actions[current_round - rounds_to_consider_history:current_round, :]
                observed_defects_others = np.sum(~recent_opponent_actions)
                total_possible_actions_considered = rounds_to_consider_history * num_players_other
                avg_opponent_defect_rate = observed_defects_others / total_possible_actions_considered
                if avg_opponent_defect_rate >= self.DEFECTION_PROPAGATION_THRESHOLD:
                    return Action.D
                else:
                    return Action.D
            else:
                return Action.D

class Strategy_EXPLOITATIVE_440(BaseStrategy):
    """
    The Opportunistic Predator strategy defects by default but cooperates under specific conditions
    to prevent resource collapse, ensuring long-term exploitation, and only if other players
    are also contributing to recovery. It defects in the first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_recovery_threshold = self.capacity / 4.0
        self.cooperation_threshold_for_recovery = math.floor((self.n - 1) / 2)

    def _project_next_stock(self, current_stock: float, my_action: Action, prev_D_count: int, prev_C_count: int) -> float:
        """
        Helper to project the next stock level based on current state and hypothetical actions.
        Replicates the stock dynamics of the Common Pool Resource Game.
        """
        my_consumption: float
        if my_action == Action.D:
            my_consumption = current_stock / self.n
        else:
            my_consumption = current_stock / (2.0 * self.n)
        my_consumption = max(0.0, my_consumption)
        others_projected_consumption = prev_D_count * (current_stock / self.n) + prev_C_count * (current_stock / (2.0 * self.n))
        others_projected_consumption = max(0.0, others_projected_consumption)
        total_projected_consumption = my_consumption + others_projected_consumption
        S_after_consumption = max(0.0, current_stock - total_projected_consumption)
        growth = 2.0 * S_after_consumption * (1.0 - S_after_consumption / self.capacity)
        new_stock = min(S_after_consumption + growth, self.capacity)
        return new_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock = float(state.current_stock)
        if current_round_number == 0:
            return Action.D
        if current_round_number == self.r - 1:
            return Action.D
        prev_C_count = int(np.sum(history.opponent_actions[-1, :]))
        prev_D_count = self.n - 1 - prev_C_count
        projected_next_stock_if_I_D = self._project_next_stock(current_stock, Action.D, prev_D_count, prev_C_count)
        projected_next_stock_if_I_C = self._project_next_stock(current_stock, Action.C, prev_D_count, prev_C_count)
        decision = Action.D
        if current_stock > 0 and projected_next_stock_if_I_D < self.S_recovery_threshold and (projected_next_stock_if_I_C > projected_next_stock_if_I_D) and (prev_C_count >= self.cooperation_threshold_for_recovery):
            decision = Action.C
        if current_stock <= 0:
            decision = Action.D
        elif prev_D_count == self.n - 1 and projected_next_stock_if_I_D <= 0:
            decision = Action.D
        return decision

class Strategy_EXPLOITATIVE_441(BaseStrategy):
    """
    Adaptive Predator: Prioritizes immediate gain by defecting. It only cooperates strategically
    when the common resource is critically low AND a significant portion of opponents are
    cooperating, aiming to allow the resource to "recharge" for future exploitation.
    Always defects unconditionally in the final two rounds of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.STOCK_DANGER_THRESHOLD = self.capacity / 4.0
        self.OPPONENT_COOPERATION_THRESHOLD = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_number = state.round_number
        current_stock_level_at_start_of_round = state.current_stock
        if current_round_number >= self.n_rounds - 2:
            return Action.D
        opponent_defection_rate = 1.0
        if current_round_number > 0 and history is not None:
            num_opponent_defectors = np.sum(~history.opponent_actions[-1, :])
            opponent_defection_rate = num_opponent_defectors / (self.n_players - 1)
        if current_stock_level_at_start_of_round < self.STOCK_DANGER_THRESHOLD and opponent_defection_rate < self.OPPONENT_COOPERATION_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_442(BaseStrategy):
    """
    The Opportunistic Sustainer strategy defaults to defecting to maximize immediate gain.
    However, it strategically cooperates under two conditions:
    1. To prevent the imminent collapse of the common resource, which would yield no future payoffs.
    2. To allow the resource to recover if it's struggling due to widespread defection by others,
       acting as a strategic investment for future exploitation opportunities, provided there are
       sufficient rounds remaining in the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        k_D_prev = 0
        k_C_prev = 0
        if current_round_0_indexed == 0:
            k_C_prev = self.n_players - 1
            k_D_prev = 0
        else:
            k_C_prev = np.sum(history.opponent_actions[-1, :])
            k_D_prev = self.n_players - 1 - k_C_prev
        my_C_consumption = current_stock / (2.0 * self.n_players)
        my_D_consumption = current_stock / self.n_players
        opponents_consumption_based_on_prev_round = k_D_prev * (current_stock / self.n_players) + k_C_prev * (current_stock / (2.0 * self.n_players))
        total_consumption_if_I_C = my_C_consumption + opponents_consumption_based_on_prev_round
        total_consumption_if_I_D = my_D_consumption + opponents_consumption_based_on_prev_round
        stock_after_cons_if_I_C = max(0.0, current_stock - total_consumption_if_I_C)
        stock_after_cons_if_I_D = max(0.0, current_stock - total_consumption_if_I_D)
        growth_if_I_C = 2.0 * stock_after_cons_if_I_C * (1.0 - stock_after_cons_if_I_C / self.capacity)
        growth_if_I_D = 2.0 * stock_after_cons_if_I_D * (1.0 - stock_after_cons_if_I_D / self.capacity)
        projected_next_stock_if_I_C = min(stock_after_cons_if_I_C + growth_if_I_C, self.capacity)
        projected_next_stock_if_I_D = min(stock_after_cons_if_I_D + growth_if_I_D, self.capacity)
        action_to_take = Action.D
        is_imminent_collapse_if_I_D = projected_next_stock_if_I_D <= 0.001 or projected_next_stock_if_I_D < current_stock * 0.25
        if is_imminent_collapse_if_I_D and projected_next_stock_if_I_C > projected_next_stock_if_I_D:
            action_to_take = Action.C
            return action_to_take
        is_stock_struggling = current_stock < self.capacity / 2.0
        is_widespread_defection = k_D_prev > (self.n_players - 1) / 2.0
        is_enough_game_left = self.n_rounds - current_round_0_indexed > 3
        is_cooperation_beneficial_for_stock = projected_next_stock_if_I_C > current_stock
        is_defection_detrimental_for_stock = projected_next_stock_if_I_D <= current_stock
        if is_stock_struggling and is_widespread_defection and is_enough_game_left and is_cooperation_beneficial_for_stock and is_defection_detrimental_for_stock:
            action_to_take = Action.C
        return action_to_take

class Strategy_EXPLOITATIVE_443(BaseStrategy):
    """
    The "Calculated Maverick" strategy for the Common Pool Resource game.
    It prioritizes maximizing its own total payoff by defaulting to aggressive defection,
    while incorporating critical safeguards to prevent the collapse of the common resource
    or extreme defection cascades that would harm its long-term gains. It always defects
    in the final round to exploit the lack of future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold = self.game_description.capacity / (2.0 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        current_round_1_indexed = state.round_number + 1
        if current_round_1_indexed == n_rounds:
            return Action.D
        if current_stock < self.critical_stock_threshold:
            return Action.C
        if current_round_1_indexed > 1:
            num_my_defectors_prev_round = 1 if not history.my_actions[-1] else 0
            num_opponent_defectors_prev_round = np.sum(~history.opponent_actions[-1, :])
            total_defectors_prev_round = num_my_defectors_prev_round + num_opponent_defectors_prev_round
            if total_defectors_prev_round >= n_players - 1:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_444(BaseStrategy):
    """
    Adaptive Exploiter with Calculated Conservation strategy.
    Aims to maximize individual payoff by extensively free-riding on other players'
    cooperation, while strategically conserving the common resource only when
    absolutely necessary to ensure its long-term viability for continued exploitation.
    It adapts to opponent behavior and is robust across various game conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_CRITICAL_THRESHOLD = 0.1 * self.capacity
        self.S_RECOVERY_TARGET = 0.5 * self.capacity
        self.S_HIGH_EXPLOITATION_THRESHOLD = 0.8 * self.capacity
        self.OBSERVATION_WINDOW_SIZE = max(1, min(5, self.r // 5))
        self.DEFECTION_TOLERANCE_OTHERS = 0.3
        self.MY_DEFECTION_STREAK_SOFT_LIMIT = 3
        self.my_current_defection_streak = 0
        self.is_in_recovery_mode = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_idx = state.round_number
        current_stock = state.current_stock
        action_to_take = None
        if current_round_idx == 0:
            action_to_take = Action.D
            self.is_in_recovery_mode = False
        elif current_round_idx == self.r - 1:
            action_to_take = Action.D
        else:
            if self.is_in_recovery_mode:
                if current_stock < self.S_RECOVERY_TARGET:
                    action_to_take = Action.C
                else:
                    self.is_in_recovery_mode = False
            if action_to_take is None:
                if current_stock < self.S_CRITICAL_THRESHOLD:
                    self.is_in_recovery_mode = True
                    action_to_take = Action.C
                elif current_stock > self.S_HIGH_EXPLOITATION_THRESHOLD:
                    action_to_take = Action.D
            if action_to_take is None:
                total_opponent_defections = 0
                num_opponent_observations = 0
                start_history_idx = max(0, current_round_idx - self.OBSERVATION_WINDOW_SIZE)
                relevant_opponent_actions = history.opponent_actions[start_history_idx:current_round_idx, :]
                total_opponent_defections = np.sum(~relevant_opponent_actions)
                num_opponent_observations = relevant_opponent_actions.shape[0] * relevant_opponent_actions.shape[1]
                avg_opponent_defection_rate = 0.0
                if num_opponent_observations > 0:
                    avg_opponent_defection_rate = total_opponent_defections / num_opponent_observations
                if avg_opponent_defection_rate > self.DEFECTION_TOLERANCE_OTHERS:
                    action_to_take = Action.D
                elif self.my_current_defection_streak < self.MY_DEFECTION_STREAK_SOFT_LIMIT:
                    action_to_take = Action.D
                else:
                    action_to_take = Action.C
        if action_to_take == Action.D:
            self.my_current_defection_streak += 1
        else:
            self.my_current_defection_streak = 0
        return action_to_take

class Strategy_EXPLOITATIVE_445(BaseStrategy):
    """
    Adaptive Exploiter with Conditional Signaling (AECS) strategy.
    This strategy aims to maximize total personal payoff by exploiting cooperative behavior,
    preserving the common resource when critically low, and strategically signaling cooperation
    to encourage others when their behavior becomes too destructive (but not yet critical).
    It defaults to defection to probe opponents or in mixed environments.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._signaling_active: bool = False
        self._signaling_rounds_left: int = 0
        self.CRITICAL_STOCK_RATIO = 0.25
        self.COOPERATIVE_OPPONENT_THRESHOLD = 0.75
        self.RISKY_DEFECTION_THRESHOLD = 0.4
        self.LOOKBACK_ROUNDS = 3
        self.SIGNAL_COOPERATION_DURATION = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number + 1
        total_rounds_r = self.game_description.n_rounds
        current_stock_S = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if state.round_number == 0:
            return Action.D
        if current_round_t == total_rounds_r:
            self._signaling_active = False
            self._signaling_rounds_left = 0
            return Action.D
        if current_stock_S < self.CRITICAL_STOCK_RATIO * capacity:
            self._signaling_active = False
            self._signaling_rounds_left = 0
            return Action.C
        if self._signaling_active:
            if self._signaling_rounds_left > 0:
                self._signaling_rounds_left -= 1
                return Action.C
            else:
                self._signaling_active = False
        total_opponent_actions_observed = 0
        total_opponent_cooperations = 0
        start_history_round_idx = max(0, state.round_number - self.LOOKBACK_ROUNDS)
        if start_history_round_idx < state.round_number:
            opponent_actions_slice = history.opponent_actions[start_history_round_idx:state.round_number, :]
            total_opponent_cooperations = np.sum(opponent_actions_slice)
            total_opponent_actions_observed = opponent_actions_slice.size
        if total_opponent_actions_observed == 0:
            return Action.D
        average_opponent_cooperation_rate = total_opponent_cooperations / total_opponent_actions_observed
        if average_opponent_cooperation_rate >= self.COOPERATIVE_OPPONENT_THRESHOLD:
            return Action.D
        elif average_opponent_cooperation_rate <= self.RISKY_DEFECTION_THRESHOLD:
            self._signaling_active = True
            self._signaling_rounds_left = self.SIGNAL_COOPERATION_DURATION - 1
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_446(BaseStrategy):
    """
    The Adaptive Predator strategy is designed for aggressive self-interest.
    It aims to extract as much value as possible from the common pool by defecting,
    only cooperating as a strategic, self-preserving measure when the resource's health
    becomes critically low, threatening future exploitation opportunities.
    It does not cooperate to encourage others or to be "fair," but solely to ensure
    the longevity of its own profitable actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Predator strategy with game parameters.
        Calculates the critical stock threshold for self-preservation.
        """
        self.game_description = game_description
        self.STOCK_CRITICAL_LOW = self.game_description.capacity / 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determines the player's action (Cooperate or Defect) based on the current
        game state and the Adaptive Predator strategy's rules.

        The `state.round_number` is 0-indexed, meaning round 0 is the first round,
        and `self.game_description.n_rounds - 1` is the last round.
        """
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == 0:
            return Action.D
        if state.current_stock <= self.STOCK_CRITICAL_LOW:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_447(BaseStrategy):
    """
    The "Resource Vampire" strategy is designed to be highly exploitative,
    prioritizing immediate payoffs by defecting, while maintaining robustness
    through strategic cooperation only when necessary to preserve the resource
    or to manipulate other players. It operates purely on observable game parameters,
    current state, and historical actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_abs_threshold = self.game_description.capacity * 0.2
        self.warning_stock_abs_threshold = self.game_description.capacity * 0.5
        self.cooperation_ratio_for_exploitation = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        if current_stock <= self.critical_stock_abs_threshold:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.D
        num_cooperators_last_round = sum(history.opponent_actions[-1, :])
        n_other_players = n_players - 1
        cooperation_ratio_others = num_cooperators_last_round / n_other_players
        if cooperation_ratio_others >= self.cooperation_ratio_for_exploitation:
            return Action.D
        elif current_stock <= self.warning_stock_abs_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_448(BaseStrategy):
    """
    Adaptive Predatory Harvester strategy: Prioritizes immediate individual gain by defecting,
    but implements calculated cooperation as a self-interested measure to prevent resource collapse
    if and only if such cooperation is crucial for prolonging the game and ensuring future payoffs.
    It adapts to different tournament environments by observing opponent behavior.
    """
    S_CRITICAL_THRESHOLD_FACTOR = 0.25
    RECENT_HISTORY_LENGTH = 5
    SURVIVAL_EPSILON = 0.01

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def _calculate_new_stock(self, current_stock: float, my_action_is_C: bool, num_others_defect_expected: int, num_others_cooperate_expected: int, n_players: int, game_capacity: float) -> float:
        """
        Predicts the new stock level for the next round given current state and assumed actions.
        """
        if my_action_is_C:
            my_consumption = current_stock / (2 * n_players)
        else:
            my_consumption = current_stock / n_players
        others_consumption_defect = num_others_defect_expected * (current_stock / n_players)
        others_consumption_cooperate = num_others_cooperate_expected * (current_stock / (2 * n_players))
        total_others_consumption = others_consumption_defect + others_consumption_cooperate
        total_consumption = my_consumption + total_others_consumption
        S_rem = current_stock - total_consumption
        S_rem = max(0.0, S_rem)
        growth = 2 * S_rem * (1 - S_rem / game_capacity) if game_capacity > self.SURVIVAL_EPSILON else 0.0
        S_new = min(S_rem + growth, game_capacity)
        return S_new

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        game_capacity = float(self.game_description.capacity)
        current_round_idx = state.round_number
        S_current_stock = state.current_stock
        if current_round_idx == total_rounds - 1:
            return Action.D
        if current_round_idx == 0:
            return Action.D
        num_others = n_players - 1
        others_defection_rate = 0.5
        if current_round_idx > 0:
            num_recent_rounds_to_consider = min(current_round_idx, self.RECENT_HISTORY_LENGTH)
            recent_opponent_actions = history.opponent_actions[-num_recent_rounds_to_consider:, :]
            if recent_opponent_actions.size > 0:
                num_others_defect_in_history = np.sum(~recent_opponent_actions)
                total_actions_observed_by_others = recent_opponent_actions.size
                if total_actions_observed_by_others > 0:
                    others_defection_rate = num_others_defect_in_history / total_actions_observed_by_others
        S_critical_low_absolute = game_capacity * self.S_CRITICAL_THRESHOLD_FACTOR
        num_others_defect_expected = int(round(others_defection_rate * num_others))
        num_others_defect_expected = max(0, min(num_others_defect_expected, num_others))
        num_others_cooperate_expected = num_others - num_others_defect_expected
        S_new_if_I_C = self._calculate_new_stock(S_current_stock, True, num_others_defect_expected, num_others_cooperate_expected, n_players, game_capacity)
        S_new_if_I_D = self._calculate_new_stock(S_current_stock, False, num_others_defect_expected, num_others_cooperate_expected, n_players, game_capacity)
        if S_new_if_I_C > self.SURVIVAL_EPSILON and S_new_if_I_D <= self.SURVIVAL_EPSILON:
            return Action.C
        if S_current_stock < S_critical_low_absolute:
            if S_new_if_I_C >= S_current_stock and S_new_if_I_D < S_current_stock:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_449(BaseStrategy):
    """
    The Dynamic Opportunist strategy prioritizes individual gain, defaulting to defection (D).
    It adapts by cooperating only when strategically necessary: to prevent total resource collapse
    if others are cooperating, or to allow resource recovery for future exploitation.
    It probes in the first round and defects without consequence in the last.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_collapse_threshold = self.capacity / (self.n * 2)
        self.stock_severe_depletion_threshold = self.capacity / 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        actual_current_round = state.round_number + 1
        if actual_current_round == 1:
            return Action.C
        if actual_current_round == self.r:
            return Action.D
        prev_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        num_defecting_others_prev = np.sum(~prev_round_opponent_actions)
        current_stock = state.current_stock
        if current_stock <= self.stock_collapse_threshold and num_defecting_others_prev == 0:
            return Action.C
        elif num_defecting_others_prev >= 1:
            return Action.D
        elif current_stock <= self.stock_severe_depletion_threshold and num_defecting_others_prev == 0:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_450(BaseStrategy):
    """
    The Opportunistic Realist strategy defects by default, aiming for maximum immediate payoff.
    It cooperates only when its defection is predicted to lead to resource collapse below an
    adaptive threshold, AND its cooperation can meaningfully prevent this collapse.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        max_capacity = self.game_description.capacity
        current_round_idx = state.round_number
        stock_current = state.current_stock
        coop_consumption_per_player = stock_current / (2 * n_players)
        defect_consumption_per_player = stock_current / n_players
        if current_round_idx == 0:
            return Action.D
        if current_round_idx == total_rounds - 1:
            return Action.D
        k_others_C_prev = sum(history.opponent_actions[-1, :])
        n_others = n_players - 1
        k_others_D_prev = n_others - k_others_C_prev
        adaptive_threshold_factor = 1 + (total_rounds - (current_round_idx + 1)) / total_rounds
        COLLAPSE_AVOIDANCE_THRESHOLD = max_capacity / (2 * n_players) * adaptive_threshold_factor
        others_consumption_if_repeat = k_others_C_prev * coop_consumption_per_player + k_others_D_prev * defect_consumption_per_player
        my_D_consumption = defect_consumption_per_player
        total_consumption_if_I_D = my_D_consumption + others_consumption_if_repeat
        stock_after_my_D_action = stock_current - total_consumption_if_I_D
        if stock_after_my_D_action <= COLLAPSE_AVOIDANCE_THRESHOLD:
            my_C_consumption = coop_consumption_per_player
            total_consumption_if_I_C = my_C_consumption + others_consumption_if_repeat
            stock_after_my_C_action = stock_current - total_consumption_if_I_C
            if stock_after_my_C_action > COLLAPSE_AVOIDANCE_THRESHOLD:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_451(BaseStrategy):
    """
    The Opportunistic Conservationist strategy aims to maximize total payoff by primarily exploiting
    the common resource (defecting) but incorporates a critical self-preservation mechanism.
    It adaptively responds to the current stock level to prevent total resource collapse,
    which would ultimately diminish its own long-term gains. In the final round, it always defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_THRESHOLD = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        elif current_stock < self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_452(BaseStrategy):
    """
    The Opportunistic Predator strategy aims to maximize its own total payoff.
    It adaptively responds to opponent behavior and resource state, free-riding on
    cooperation, defensively defecting against widespread defection, and exploiting
    the resource in critical or end-game phases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.FREE_RIDE_COOPERATION_THRESHOLD = 0.6
        self.PUNISHMENT_DEFECTION_THRESHOLD = 0.3
        self.STOCK_CRITICAL_LEVEL_RATIO = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_1_indexed = state.round_number + 1
        stock = state.current_stock
        if current_round_1_indexed >= r - 1:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        num_others_cooperated_last_round = np.sum(history.opponent_actions[-1, :])
        n_others = n - 1
        cooperation_rate_of_others_last_round = num_others_cooperated_last_round / n_others
        if stock <= capacity * self.STOCK_CRITICAL_LEVEL_RATIO:
            if cooperation_rate_of_others_last_round >= 0.9:
                return Action.C
            else:
                return Action.D
        elif cooperation_rate_of_others_last_round >= self.FREE_RIDE_COOPERATION_THRESHOLD:
            return Action.D
        elif cooperation_rate_of_others_last_round < self.PUNISHMENT_DEFECTION_THRESHOLD:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_453(BaseStrategy):
    """
    The "Calculated Predator" strategy aims to maximize its total payoff in the Common Pool Resource game by balancing
    aggressive exploitation of other players with a pragmatic approach to resource preservation, ensuring long-term
    opportunities for gain. It's adaptive to opponent behavior and stock levels, always defaulting to defection unless
    specific conditions make cooperation a more profitable long-term or necessary short-term move.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r_total = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.COOP_EXPLOIT_THRESHOLD = 0.6
        self.MIN_COOP_FOR_SELF_PRESERVE = 0.4
        self.CRITICAL_STOCK_LOW_THRESHOLD_FACTOR = 0.25
        self.CRITICAL_STOCK_VERY_LOW_THRESHOLD_FACTOR = 0.1
        self.ROUNDS_FOR_AVG_COOP = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        r_current = state.round_number + 1
        current_stock = state.current_stock
        if r_current == self.r_total:
            return Action.D
        if r_current == 1:
            return Action.D
        num_opponents = self.n - 1
        avg_opponent_C_ratio = 0.0
        if num_opponents > 0 and state.round_number > 0:
            rounds_to_sample = min(state.round_number, self.ROUNDS_FOR_AVG_COOP)
            if rounds_to_sample > 0:
                total_opponent_cooperations = np.sum(history.opponent_actions[-rounds_to_sample:, :])
                total_possible_opponent_actions = rounds_to_sample * num_opponents
                if total_possible_opponent_actions > 0:
                    avg_opponent_C_ratio = total_opponent_cooperations / total_possible_opponent_actions
        if current_stock <= self.CRITICAL_STOCK_VERY_LOW_THRESHOLD_FACTOR * self.capacity:
            return Action.C
        if current_stock <= self.CRITICAL_STOCK_LOW_THRESHOLD_FACTOR * self.capacity:
            if avg_opponent_C_ratio >= self.MIN_COOP_FOR_SELF_PRESERVE:
                return Action.C
            else:
                return Action.D
        if avg_opponent_C_ratio >= self.COOP_EXPLOIT_THRESHOLD:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_454(BaseStrategy):
    """
    Adaptive Predator strategy for the Common Pool Resource game.

    This strategy aims to maximize its own total payoff by aggressively defecting
    but includes mechanisms to preserve the common resource when its long-term
    viability is critical for continued exploitation. It observes opponent behavior
    and the current stock level to make informed, self-serving decisions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def _count_defectors_bool(self, actions_list: np.ndarray[np.bool_]) -> int:
        """
        Helper function to count the number of defecting players (Action.D / False)
        in a numpy boolean array of actions.
        """
        if actions_list.size == 0:
            return 0
        return np.sum(~actions_list).item()

    def _project_next_stock(self, current_S: float, my_hypothetical_action: Action, prev_opponent_actions: np.ndarray[np.bool_]) -> float:
        """
        Helper function to simulate the stock dynamics and predict the next round's
        stock level. It assumes this player takes `my_hypothetical_action` and
        all other players (`n-1` opponents) repeat their actions from the previous round.
        """
        my_consumption: float
        if my_hypothetical_action == Action.C:
            my_consumption = current_S / (2 * self.n)
        else:
            my_consumption = current_S / self.n
        consumption_from_others = 0.0
        for opp_action_bool in prev_opponent_actions:
            if not opp_action_bool:
                consumption_from_others += current_S / self.n
            else:
                consumption_from_others += current_S / (2 * self.n)
        total_consumption = my_consumption + consumption_from_others
        S_remaining = current_S - total_consumption
        S_remaining_for_growth = max(0.0, S_remaining)
        growth = 2 * S_remaining_for_growth * (1 - S_remaining_for_growth / self.capacity)
        next_S = min(S_remaining + growth, self.capacity)
        return next_S

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        stock = state.current_stock
        if current_round_1_indexed == self.r:
            return Action.D
        threshold_critical_stock = self.capacity / (4 * self.n)
        if stock <= threshold_critical_stock:
            return Action.D
        d_prev: int
        prev_opponent_actions_for_projection: np.ndarray[np.bool_]
        if state.round_number == 0:
            d_prev = 0
            prev_opponent_actions_for_projection = np.full(self.n - 1, True, dtype=np.bool_)
        else:
            prev_my_action_bool = history.my_actions[-1]
            prev_opponent_actions_bool = history.opponent_actions[-1, :]
            all_prev_actions = np.concatenate(([prev_my_action_bool], prev_opponent_actions_bool))
            d_prev = self._count_defectors_bool(all_prev_actions)
            prev_opponent_actions_for_projection = prev_opponent_actions_bool
        d_prev_threshold = math.floor(self.n / 2)
        if d_prev >= d_prev_threshold:
            return Action.D
        S_next_if_I_D = self._project_next_stock(stock, Action.D, prev_opponent_actions_for_projection)
        S_next_if_I_C = self._project_next_stock(stock, Action.C, prev_opponent_actions_for_projection)
        critically_low_stock_threshold_for_my_D = self.capacity / (self.n * 2)
        rounds_remaining = self.r - state.round_number
        min_significant_benefit_of_cooperation = self.capacity / (self.n * 4) * (rounds_remaining / self.r)
        if S_next_if_I_D < critically_low_stock_threshold_for_my_D and S_next_if_I_C > S_next_if_I_D + min_significant_benefit_of_cooperation:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_455(BaseStrategy):
    """
    The Predatory Stock Manager strategy aims to exploit the common pool resource
    by defaulting to defection (D) for immediate maximal payoff. It incorporates
    a self-preservation mechanism: it will strategically cooperate (C) only when
    the common stock is critically low AND there's sufficient evidence that
    other players are also cooperating, making its own cooperation effective in
    preventing a complete resource collapse that would harm its future
    exploitation potential.
    """
    _COOPERATION_THRESHOLD_FRACTION = 0.5

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._STOCK_CRITICAL_THRESHOLD = self.game_description.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        is_stock_critical = state.current_stock < self._STOCK_CRITICAL_THRESHOLD
        num_other_players_cooperating_last_round = 0
        if state.round_number > 0 and history is not None:
            num_other_players_cooperating_last_round = sum(history.opponent_actions[-1, :])
        min_cooperators_needed = (self.game_description.n_players - 1) * self._COOPERATION_THRESHOLD_FRACTION
        sufficient_cooperation_observed = num_other_players_cooperating_last_round >= min_cooperators_needed
        if is_stock_critical and sufficient_cooperation_observed:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_456(BaseStrategy):
    """
    The Opportunistic Shepherd operates with a self-interested long-term perspective.
    It seeks to free-ride on others' cooperation to maximize its individual gains.
    However, it recognizes that the total collapse of the common resource is
    detrimental to its own long-term payoff. Therefore, it strategically cooperates
    to induce others to sustain the resource, punishes widespread defection to
    avoid being a "sucker" and to guide behavior back to sustainability, and
    ruthlessly exploits in the end game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_critical_threshold = self.capacity / 4.0
        self.defection_tolerance_threshold = math.floor((self.n_players - 1) / 2)
        self.end_game_window = max(2, math.floor(self.n_rounds / 3))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        game_round_0_indexed = state.round_number
        strategy_round_1_indexed = game_round_0_indexed + 1
        if strategy_round_1_indexed > self.n_rounds - self.end_game_window:
            return Action.D
        if strategy_round_1_indexed == 1:
            return Action.C
        prev_round_idx = game_round_0_indexed - 1
        my_action_prev_bool = history.my_actions[prev_round_idx]
        opponent_actions_prev_round_bools = history.opponent_actions[prev_round_idx, :]
        num_opponent_cooperators_prev = np.sum(opponent_actions_prev_round_bools)
        k_D_prev = self.n_players - 1 - num_opponent_cooperators_prev
        if current_stock <= self.stock_critical_threshold:
            if k_D_prev >= self.defection_tolerance_threshold:
                return Action.D
            else:
                return Action.C
        elif k_D_prev == 0:
            return Action.D
        elif my_action_prev_bool == True:
            return Action.D
        elif k_D_prev >= self.defection_tolerance_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_457(BaseStrategy):
    """
    The Opportunistic Harvester strategy is designed to maximize its own total payoff.
    It prioritizes immediate gains through defection but is adaptive, employing tactical
    cooperation to prevent resource collapse when threatened, only to revert to
    exploitation once the resource has sufficiently recovered.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.STOCK_CRITICAL_LOW_THRESHOLD_FACTOR = 0.2
        self.STOCK_RECOVERY_TARGET_FACTOR = 0.5
        self.OPPONENT_COOPERATION_EXPLOIT_THRESHOLD = 0.75
        self.OPPONENT_DEFECTION_JOIN_THRESHOLD = 0.75
        self.conservation_mode_flag = False
        self.previous_round_initial_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        num_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        action_to_take: Action
        if current_round_1_indexed == total_rounds:
            action_to_take = Action.D
        elif current_stock <= 0:
            action_to_take = Action.C
        else:
            stock_critical_low_level = capacity * self.STOCK_CRITICAL_LOW_THRESHOLD_FACTOR
            stock_recovery_level = capacity * self.STOCK_RECOVERY_TARGET_FACTOR
            if current_stock < stock_critical_low_level and (not self.conservation_mode_flag):
                self.conservation_mode_flag = True
                action_to_take = Action.C
            elif self.conservation_mode_flag and current_stock >= stock_recovery_level:
                self.conservation_mode_flag = False
                action_to_take = Action.D
            elif self.conservation_mode_flag:
                action_to_take = Action.C
            elif current_round_1_indexed == 1:
                action_to_take = Action.D
            else:
                num_cooperated_opponents = np.sum(history.opponent_actions[-1, :])
                num_defected_opponents = num_players - 1 - num_cooperated_opponents
                denominator = num_players - 1
                proportion_coop_opponents = num_cooperated_opponents / denominator
                proportion_defect_opponents = num_defected_opponents / denominator
                if proportion_coop_opponents >= self.OPPONENT_COOPERATION_EXPLOIT_THRESHOLD:
                    action_to_take = Action.D
                elif proportion_defect_opponents >= self.OPPONENT_DEFECTION_JOIN_THRESHOLD:
                    action_to_take = Action.D
                else:
                    previous_stock = self.previous_round_initial_stock
                    if current_stock < previous_stock:
                        action_to_take = Action.C
                    else:
                        action_to_take = Action.D
        if current_round_1_indexed < total_rounds:
            self.previous_round_initial_stock = current_stock
        return action_to_take

class Strategy_EXPLOITATIVE_458(BaseStrategy):
    """
    Adaptive Predator strategy for the Common Pool Resource Game.

    This strategy aims to maximize its total payoff by defaulting to defection,
    but strategically cooperates to preserve the resource when it's critically low,
    provided other players also show some willingness to cooperate. In the final
    rounds, it defects relentlessly to maximize end-game gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.k = 2
        self.s_crit_factor = 0.3
        self.min_coop_rate_for_my_cooperation = 0.2
        self.s_crit = self.s_crit_factor * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        stock = state.current_stock
        if current_round_1_indexed >= self.n_rounds - self.k + 1:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        total_others = self.n_players - 1
        num_others_cooperated_last_round = np.sum(history.opponent_actions[-1, :])
        if total_others == 0:
            observed_cooperation_rate_others = 0.0
        else:
            observed_cooperation_rate_others = num_others_cooperated_last_round / total_others
        my_consumption_D = stock / self.n_players
        consumption_per_player_C = stock / (2.0 * self.n_players)
        consumption_per_player_D = stock / self.n_players
        others_consumption_estimate = total_others * (observed_cooperation_rate_others * consumption_per_player_C + (1.0 - observed_cooperation_rate_others) * consumption_per_player_D)
        total_consumption_estimate_if_I_D = my_consumption_D + others_consumption_estimate
        stock_after_consumption = max(0.0, stock - total_consumption_estimate_if_I_D)
        growth_estimate = 2.0 * stock_after_consumption * (1.0 - stock_after_consumption / self.capacity)
        next_round_stock_estimate_if_I_D = min(stock_after_consumption + growth_estimate, self.capacity)
        if next_round_stock_estimate_if_I_D < self.s_crit:
            if observed_cooperation_rate_others >= self.min_coop_rate_for_my_cooperation:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_459(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its total payoff over all rounds by
    generally exploiting the common resource (defaulting to Defect), but adapts its
    behavior to prevent complete resource collapse. It cooperates strategically when
    defection would lead to critically low stock levels that jeopardize future payoffs,
    and when cooperation can meaningfully improve the stock's health.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.DANGER_THRESHOLD = max(self.n_players * 1.0, self.capacity * 0.1)
        self.SUFFICIENT_IMPROVEMENT_BY_COOPERATION = self.capacity * 0.05

    def _calculate_projected_stock(self, my_action: Action, avg_defection_rate_others: float, current_stock: float) -> float:
        """
        Helper method to calculate the projected stock for the next round.
        Assumes other players behave according to the average defection rate.
        """
        n_param = self.n_players
        capacity_param = self.capacity
        num_D_expected_others = int(math.floor((n_param - 1) * avg_defection_rate_others + 0.5))
        num_C_expected_others = n_param - 1 - num_D_expected_others
        if my_action == Action.D:
            my_consumption = current_stock / n_param
        else:
            my_consumption = current_stock / (2 * n_param)
        others_consumption = num_D_expected_others * (current_stock / n_param) + num_C_expected_others * (current_stock / (2 * n_param))
        total_consumption = my_consumption + others_consumption
        stock_after_consumption = max(0.0, current_stock - total_consumption)
        growth_ratio_term = 1 - stock_after_consumption / capacity_param
        growth = 2 * stock_after_consumption * growth_ratio_term
        projected_stock = min(stock_after_consumption + growth, capacity_param)
        return projected_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        round_num = state.round_number
        current_stock = state.current_stock
        r_param = self.n_rounds
        if round_num == r_param - 1:
            return Action.D
        avg_defection_rate_others = 0.0
        if round_num > 0 and history is not None:
            total_defectors_observed = np.sum(history.opponent_actions == False)
            total_actions_observed = history.opponent_actions.size
            if total_actions_observed > 0:
                avg_defection_rate_others = total_defectors_observed / total_actions_observed
        projected_stock_if_I_defect = self._calculate_projected_stock(Action.D, avg_defection_rate_others, current_stock)
        projected_stock_if_I_cooperate = self._calculate_projected_stock(Action.C, avg_defection_rate_others, current_stock)
        if projected_stock_if_I_defect <= self.DANGER_THRESHOLD:
            if projected_stock_if_I_cooperate > projected_stock_if_I_defect + self.SUFFICIENT_IMPROVEMENT_BY_COOPERATION:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_460(BaseStrategy):
    """
    The "Adaptive Exploiter" strategy is designed to maximize a player's individual total payoff
    by primarily defecting, while strategically cooperating only when necessary to prevent
    resource collapse or to maintain the stock at a sufficiently high level for sustained
    future exploitation. It adapts to the current stock level and the observed behavior of
    other players, and is robust against a wide range of opponent strategies.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_critical_absolute_min = 0.05 * game_description.capacity
        self.S_recovery_target = 0.8 * game_description.capacity
        self.cooperation_threshold_for_exploitation = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == n_rounds - 1:
            return Action.D
        if current_stock <= self.S_critical_absolute_min:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.D
        num_C_others_last_round = np.sum(history.opponent_actions[current_round_0_indexed - 1, :])
        n_others = n_players - 1
        cooperation_rate_others = num_C_others_last_round / n_others
        if cooperation_rate_others > self.cooperation_threshold_for_exploitation:
            return Action.D
        elif current_stock < self.S_recovery_target:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_461(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize individual payoff by defaulting to defection.
    It strategically cooperates only when the common pool resource is critically low, threatening
    its own future exploitation opportunities, or when a temporary sacrifice might induce others
    to sustain the resource. It actively monitors opponent behavior to adapt its aggression level,
    free-riding on cooperators and cautiously cooperating only when strictly necessary for
    long-term selfish gain.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.num_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.history_of_round_details: list[tuple[float, bool, NDArray[np.bool_]]] = []
        self._stock_at_last_round_start: float | None = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = float(state.current_stock)
        if current_round > 0 and history is not None:
            if self._stock_at_last_round_start is not None:
                self.history_of_round_details.append((self._stock_at_last_round_start, history.my_actions[-1], history.opponent_actions[-1, :]))
        self._stock_at_last_round_start = current_stock
        if current_round == self.num_rounds - 1:
            return Action.D
        num_opponents = self.n_players - 1
        opponent_cooperation_count_prev_round = 0
        opponent_defection_count_prev_round = 0
        if current_round > 0 and history is not None:
            opponent_actions_prev_round = history.opponent_actions[-1, :]
            opponent_cooperation_count_prev_round = np.sum(opponent_actions_prev_round)
            opponent_defection_count_prev_round = num_opponents - opponent_cooperation_count_prev_round
        opponent_defection_rate_avg_prev_k_rounds = 0.5
        if current_round > 0 and len(self.history_of_round_details) > 0:
            k_history_lookback = min(len(self.history_of_round_details), 3)
            total_opponent_actions_observed = 0
            total_opponent_defections_observed = 0
            for _, _, opp_actions_arr in self.history_of_round_details[-k_history_lookback:]:
                total_opponent_actions_observed += len(opp_actions_arr)
                total_opponent_defections_observed += np.sum(~opp_actions_arr)
            if total_opponent_actions_observed > 0:
                opponent_defection_rate_avg_prev_k_rounds = total_opponent_defections_observed / total_opponent_actions_observed
        projected_num_opp_D = round(num_opponents * opponent_defection_rate_avg_prev_k_rounds)
        projected_num_opp_C = num_opponents - projected_num_opp_D
        my_consumption_if_I_D = current_stock / self.n_players
        opp_consumption_projected = projected_num_opp_D * current_stock / self.n_players + projected_num_opp_C * current_stock / (2 * self.n_players)
        total_consumption_projected_if_I_D = my_consumption_if_I_D + opp_consumption_projected
        S_rem_projected_if_I_D = current_stock - total_consumption_projected_if_I_D
        S_rem_for_growth = max(0.0, S_rem_projected_if_I_D)
        growth_factor = 1 - S_rem_for_growth / self.capacity
        growth_projected_if_I_D = 2 * S_rem_for_growth * growth_factor
        next_stock_projected_if_I_D = min(S_rem_for_growth + growth_projected_if_I_D, self.capacity)
        if S_rem_projected_if_I_D <= 0 or next_stock_projected_if_I_D <= self.capacity / (8 * self.n_players):
            return Action.C
        if current_stock >= self.capacity * 0.8:
            return Action.D
        if current_round > 0 and opponent_cooperation_count_prev_round >= num_opponents / 2:
            return Action.D
        if current_round > 0 and current_stock <= self.capacity * 0.4 and (opponent_defection_count_prev_round >= num_opponents / 2):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_462(BaseStrategy):
    """
    The Opportunistic Shark strategy for the Common Pool Resource game.

    Goal: Maximize personal total payoff by prioritizing immediate gains (defection)
    while employing strategic cooperation to prevent resource collapse (which would
    diminish future profits) and to incentivize/exploit others' cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.observation_window_k = 3
        self.cooperation_threshold_high = 0.75
        self.cooperation_threshold_low = 0.25
        self.CRITICAL_MIN_STOCK_LEVEL = self.capacity / self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.D
        if current_round == self.n_rounds - 1:
            return Action.D
        relevant_rounds_for_observation = max(1, min(current_round, self.observation_window_k))
        total_cooperators_observed = 0
        num_opponents = self.n_players - 1
        for r_idx in range(current_round - relevant_rounds_for_observation, current_round):
            total_cooperators_observed += np.sum(history.opponent_actions[r_idx, :])
        opponent_cooperation_rate = total_cooperators_observed / (relevant_rounds_for_observation * num_opponents)
        consumption_if_I_defect = current_stock / self.n_players
        consumption_by_others_if_all_cooperate = (self.n_players - 1) * current_stock / (2 * self.n_players)
        total_consumption_projected_for_resource_check = consumption_if_I_defect + consumption_by_others_if_all_cooperate
        stock_after_consumption_projected = current_stock - total_consumption_projected_for_resource_check
        stock_after_consumption_projected = max(0.0, stock_after_consumption_projected)
        growth_projected = 2 * stock_after_consumption_projected * (1 - stock_after_consumption_projected / self.capacity)
        projected_next_stock = min(stock_after_consumption_projected + growth_projected, self.capacity)
        if projected_next_stock < self.CRITICAL_MIN_STOCK_LEVEL:
            return Action.C
        elif opponent_cooperation_rate >= self.cooperation_threshold_high:
            return Action.D
        elif opponent_cooperation_rate < self.cooperation_threshold_low:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_463(BaseStrategy):
    """
    The "Adaptive Free-Rider with Collapse Aversion" strategy prioritizes defection for immediate gain,
    adapting its behavior based on the common stock level and opponents' previous round defection rate
    to prevent resource collapse and maximize long-term exploitation.

    It defects in the first and last rounds for maximum immediate payoff.
    In intermediate rounds:
    - It cooperates if the stock is critically low (<= 10% capacity) to avert total collapse.
    - It defects if the stock is abundant (>= 50% capacity) to exploit the buffer.
    - In moderate stock conditions, it cooperates if half or more opponents defected in the previous round
      to slow decline, and defects if fewer than half defected, to free-ride on their cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.s_critical_low = self.capacity * 0.1
        self.s_tolerable_defection = self.capacity * 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.n_rounds
        current_stock = state.current_stock
        n = self.n_players
        if current_round_0_indexed == 0:
            return Action.D
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        num_opponent_defectors_prev_round = np.sum(~previous_round_opponent_actions)
        if current_stock <= self.s_critical_low:
            return Action.C
        elif current_stock >= self.s_tolerable_defection:
            return Action.D
        elif num_opponent_defectors_prev_round >= (n - 1) / 2.0:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_464(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its own total payoff by primarily defecting,
    but intelligently cooperating only when necessary to preserve the common resource for future
    exploitation, or to avoid being excessively exploited by others. It adapts its behavior
    based on the current stock level, the number of remaining rounds, and the observed behavior
    of other players.

    Core Principles:
    1. Endgame Smash: Prioritize immediate maximum gain in the final rounds by defecting.
    2. Self-Preservation through Prudent Cooperation: Cooperate when the resource is critically low
       to prevent collapse, ensuring future exploitation opportunities.
    3. Opportunistic Exploitation/Free-riding: Defect to maximize immediate gain when the resource
       is not critical and opponents are not overtly aggressive.
    4. Retaliatory Defection: Respond with defection if opponents show high defection rates
       to avoid being a "sucker."
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.ENDGAME_ROUNDS = 3
        self.CRITICAL_STOCK_RATIO = 0.25
        self.OPPONENT_DEFECTION_TOLERANCE = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number >= self.game_description.n_rounds - self.ENDGAME_ROUNDS:
            return Action.D
        if state.current_stock <= self.game_description.capacity * self.CRITICAL_STOCK_RATIO:
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        num_opponent_defectors = np.sum(~previous_round_opponent_actions)
        num_other_players = self.game_description.n_players - 1
        opponent_defection_rate = num_opponent_defectors / num_other_players
        if opponent_defection_rate >= self.OPPONENT_DEFECTION_TOLERANCE:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_465(BaseStrategy):
    """
    The Calculated Predator strategy aims to maximize the player's own total payoff.
    It defects by default but strategically cooperates when the common pool resource
    is declining, to prevent its premature collapse and preserve future exploitation opportunities.
    If the resource is critically low or in the final round, it abandons preservation
    and defects to extract maximum immediate value.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.MIN_VIABLE_STOCK_RATIO = 0.15
        self.history_stock_levels: list[float] = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        current_stock = state.current_stock
        self.history_stock_levels.append(current_stock)
        if current_round_1_indexed == self.r:
            return Action.D
        if current_stock < self.MIN_VIABLE_STOCK_RATIO * self.capacity:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        else:
            prev_round_stock_start = self.history_stock_levels[current_round_0_indexed - 1]
            if current_stock >= prev_round_stock_start:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_466(BaseStrategy):
    """
    The Selfish Harvester strategy prioritizes immediate personal gain by defaulting to Defect (D).
    It tactically Cooperates (C) only when its own Defection would likely lead to a critical collapse
    of the common resource, and its Cooperation has a tangible chance of preventing this collapse,
    thereby safeguarding the resource for future exploitation. This is a calculated long-term profit
    maximization, not altruism.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.LOW_STOCK_THRESHOLD_RATIO = 0.25
        self.CRITICAL_COLLAPSE_THRESHOLD_RATIO = 0.05

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_idx = state.round_number
        if current_round_idx == 0:
            return Action.D
        if current_round_idx == total_rounds - 1:
            return Action.D
        prev_round_opponent_actions = history.opponent_actions[current_round_idx - 1, :]
        num_other_cooperators_prev_round = np.sum(prev_round_opponent_actions)
        num_other_defectors_prev_round = n_players - 1 - num_other_cooperators_prev_round
        estimated_other_consumption_this_round = num_other_defectors_prev_round * current_stock / n_players + num_other_cooperators_prev_round * current_stock / (2 * n_players)
        if current_stock > capacity * self.LOW_STOCK_THRESHOLD_RATIO:
            return Action.D
        else:
            my_D_consumption = current_stock / n_players
            predicted_S_remaining_if_my_D = current_stock - (my_D_consumption + estimated_other_consumption_this_round)
            my_C_consumption = current_stock / (2 * n_players)
            predicted_S_remaining_if_my_C = current_stock - (my_C_consumption + estimated_other_consumption_this_round)
            if predicted_S_remaining_if_my_D < capacity * self.CRITICAL_COLLAPSE_THRESHOLD_RATIO and predicted_S_remaining_if_my_C > predicted_S_remaining_if_my_D:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_467(BaseStrategy):
    """
    The "Opportunistic Harvester" strategy. This strategy is highly exploitative, prioritizing immediate payoff
    while taking a pragmatic approach to resource sustainability. It defects aggressively when the stock is healthy,
    cooperates only when the resource is at a critical level for self-preservation, and free-rides on others'
    cooperation. In the last round, it always defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_ratio = 0.1
        self.healthy_stock_ratio = 0.75
        self.defection_punishment_threshold = 0.5

    def _get_opponent_defection_rate(self, current_round_idx: int, history: PlayerHistory) -> float:
        """
        Calculates the defection rate of opponents in the previous round.
        This helper function is designed to be called only when `current_round_idx` is 1 or greater,
        ensuring `history` is available and contains data for the previous round.

        Args:
            current_round_idx (int): The current 0-indexed round number.
            history (PlayerHistory): The history of actions and payoffs from previous rounds.

        Returns:
            float: The proportion of opponents who defected in the previous round.
        """
        previous_round_opponent_actions = history.opponent_actions[current_round_idx - 1]
        num_defectors_among_opponents = np.sum(previous_round_opponent_actions == False)
        num_opponents = self.game_description.n_players - 1
        if num_opponents == 0:
            return 0.0
        else:
            return num_defectors_among_opponents / num_opponents

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_idx = state.round_number
        if current_round_idx == n_rounds - 1:
            return Action.D
        if current_round_idx == 0:
            return Action.D
        if current_stock < self.critical_stock_ratio * capacity:
            return Action.C
        if current_stock > self.healthy_stock_ratio * capacity:
            return Action.D
        opponent_defection_rate = self._get_opponent_defection_rate(current_round_idx, history)
        if opponent_defection_rate >= self.defection_punishment_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_468(BaseStrategy):
    """
    Opportunistic Stock Manager strategy for the Common Pool Resource Game.
    This strategy prioritizes self-profit by defecting whenever possible,
    while strategically employing cooperation only when necessary to preserve
    the resource for future exploitation or to coerce opponents into more
    cooperative behavior that can then be exploited.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.my_last_action: Action = Action.D
        self.cooperation_recovery_rounds_left: int = 0
        self.coercion_rounds: int = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == self.r - 1:
            self.my_last_action = Action.D
            return Action.D
        if state.current_stock < 2 * self.n:
            self.my_last_action = Action.C
            return Action.C
        if state.round_number == 0:
            self.my_last_action = Action.D
            return Action.D
        if self.cooperation_recovery_rounds_left > 0:
            self.cooperation_recovery_rounds_left -= 1
            self.my_last_action = Action.C
            return Action.C
        opponent_actions_prev_round = history.opponent_actions[-1, :]
        num_opponents_defected_prev_round = np.sum(opponent_actions_prev_round == False)
        if num_opponents_defected_prev_round == 0:
            self.my_last_action = Action.D
            return Action.D
        if num_opponents_defected_prev_round == self.n - 1:
            self.my_last_action = Action.D
            return Action.D
        if self.my_last_action == Action.D and num_opponents_defected_prev_round > (self.n - 1) / 2 and (state.current_stock < self.capacity * 0.75):
            self.cooperation_recovery_rounds_left = self.coercion_rounds
            self.my_last_action = Action.C
            return Action.C
        else:
            self.my_last_action = Action.D
            return Action.D

class Strategy_EXPLOITATIVE_469(BaseStrategy):
    """
    The Opportunistic Harvester strategy balances immediate gain (defecting) with the
    long-term need to maintain the common resource. It aims to exploit cooperative
    environments by free-riding, but switches to cooperation itself when the stock is
    declining due to mixed opponent behavior, or when in the first round to probe
    for cooperation. It defects purely in endgame scenarios or when stock is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self._stock_at_start_of_previous_round = float(game_description.capacity)
        self._stock_decrease_streak = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        opponent_defections_rate_prev = 0.0
        if current_round_0_indexed > 0:
            if current_stock < self._stock_at_start_of_previous_round:
                self._stock_decrease_streak += 1
            else:
                self._stock_decrease_streak = 0
            num_opponent_defections_prev = np.sum(history.opponent_actions[-1, :] == False)
            opponent_defections_rate_prev = num_opponent_defections_prev / (n_players - 1)
        decision = Action.D
        if total_rounds - current_round_1_indexed <= 1:
            decision = Action.D
        elif current_stock < n_players:
            decision = Action.D
        elif current_round_1_indexed == 1:
            decision = Action.C
        elif opponent_defections_rate_prev <= 0.3:
            decision = Action.D
        elif opponent_defections_rate_prev >= 0.7:
            decision = Action.D
        elif self._stock_decrease_streak >= 2:
            decision = Action.C
        else:
            decision = Action.D
        self._stock_at_start_of_previous_round = current_stock
        return decision

class Strategy_EXPLOITATIVE_470(BaseStrategy):
    """
    The "Greedy Greenkeeper" strategy prioritizes immediate self-gain through defection (D),
    as it always yields a higher payoff in the current round. However, it pragmatically
    incorporates resource preservation (C) when the common stock becomes critically low,
    understanding that a depleted resource leads to zero future payoffs. It acts entirely
    in its own self-interest, not attempting to coordinate with or reward other players,
    but rather to exploit them.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_preservation_threshold = self.capacity / 2.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_stock <= self.stock_preservation_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_471(BaseStrategy):
    """
    "Calculated Predator" Strategy: An exploitative strategy for the Common Pool Resource Game.
    It prioritizes immediate personal payoff by defaulting to defect, but strategically cooperates
    to prevent resource collapse, ensuring future exploitation opportunities. It free-rides on
    opponent cooperation and goes all-out in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        capacity = float(self.game_description.capacity)
        self.survival_threshold_S = capacity / (2.0 * n)
        self.recovery_threshold_S = capacity / 2.0
        self.exploit_threshold_D = math.floor((n - 1) / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number + 1
        current_stock_S = state.current_stock
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        if current_round_t == n_rounds:
            return Action.D
        if current_round_t == 1:
            return Action.D
        d_count_prev = (history.opponent_actions[-1, :] == False).sum()
        if current_stock_S <= self.survival_threshold_S:
            if d_count_prev == n_players - 1:
                return Action.D
            else:
                return Action.C
        elif current_stock_S >= self.recovery_threshold_S:
            return Action.D
        elif d_count_prev <= self.exploit_threshold_D:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_472(BaseStrategy):
    """
    The "Adaptive Exploit & Guard" (AEG) strategy for the Common Pool Resource Game.

    This strategy aims to maximize its own total payoff by aggressively defecting when
    advantageous, protecting against exploitation by others, and strategically
    cooperating to encourage resource sustainability and create future exploitation opportunities.
    It adapts its behavior based on opponent actions in the previous round and the current
    state of the common stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.AGGRESSIVE_DEFECTION_THRESHOLD = 0.6
        self.EXPLOITATIVE_COOPERATION_THRESHOLD = 0.8
        self.CRITICAL_STOCK_FACTOR = 0.15
        self.MIN_COOPERATORS_FOR_RECOVERY_IN_CRISIS = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        n_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        if current_round_1_indexed == n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        last_round_opponent_actions = history.opponent_actions[-1, :]
        num_others = n_players - 1
        if num_others == 0:
            return Action.D
        num_others_cooperated_last_round = np.sum(last_round_opponent_actions)
        num_others_defected_last_round = num_others - num_others_cooperated_last_round
        proportion_others_defected = num_others_defected_last_round / num_others
        proportion_others_cooperated = num_others_cooperated_last_round / num_others
        if current_stock < capacity * self.CRITICAL_STOCK_FACTOR:
            if proportion_others_cooperated >= self.MIN_COOPERATORS_FOR_RECOVERY_IN_CRISIS:
                return Action.C
            else:
                return Action.D
        if proportion_others_defected >= self.AGGRESSIVE_DEFECTION_THRESHOLD:
            return Action.D
        elif proportion_others_cooperated >= self.EXPLOITATIVE_COOPERATION_THRESHOLD:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_473(BaseStrategy):
    """
    The Opportunistic Harvester strategy is inherently selfish, defaulting to maximum exploitation.
    It will, however, strategically cooperate to preserve the common resource if it is critically low
    AND a sufficient number of other players are also cooperating, ensuring the resource's survival
    for future exploitation opportunities. In the final rounds, all sustainability concerns are
    discarded in favor of immediate maximal extraction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_RATIO = 0.25
        self.COOPERATION_THRESHOLD_FOR_MY_C = 0.5
        self.MAX_CRITICAL_ROUNDS_REMAINING = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        critical_stock_level = self.capacity * self.CRITICAL_STOCK_RATIO
        min_cooperators_to_enable_my_C = math.ceil((self.n_players - 1) * self.COOPERATION_THRESHOLD_FOR_MY_C)
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        if self.n_rounds - current_round_0_indexed - 1 <= self.MAX_CRITICAL_ROUNDS_REMAINING:
            return Action.D
        num_cooperators_prev_round = 0
        if current_round_0_indexed > 0:
            num_cooperators_prev_round = sum(history.opponent_actions[-1, :])
        if current_stock < critical_stock_level:
            if num_cooperators_prev_round >= min_cooperators_to_enable_my_C:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_474(BaseStrategy):
    """
    The "Adaptive Predator" strategy is designed to be highly exploitative, prioritizing individual gain
    while adapting to opponent behavior and resource scarcity to avoid premature game-ending collapses.
    It defaults to defection, only cooperating under specific conditions where it strategically
    benefits the player by preserving the resource for future exploitation.

    Key Principles:
    1. Greed (Default Defection): Always prefer to Defect (D) to maximize immediate individual payoff.
    2. Self-Preservation (Strategic Cooperation): Only Cooperate (C) when the resource is critically low
       AND there's overwhelming evidence that other players are also cooperating to restore it.
       This is a strategic investment to ensure future rounds have a valuable resource to exploit.
    3. Endgame Exploitation: In the final rounds, future resource levels are irrelevant, so always defect.
    4. Initial Scouting: Start by defecting to gauge opponent reactions and secure early gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_critical_level = self.capacity / 4.0
        self.cooperation_necessity_threshold = self.n_players - 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds_1_indexed = self.n_rounds
        if current_round_1_indexed == total_rounds_1_indexed:
            return Action.D
        if state.round_number == 0:
            return Action.D
        prev_round_index = state.round_number - 1
        num_cooperators_among_opponents_prev_round = sum(history.opponent_actions[prev_round_index, :])
        my_prev_action_was_C = history.my_actions[prev_round_index]
        num_cooperators_prev_round = num_cooperators_among_opponents_prev_round + (1 if my_prev_action_was_C else 0)
        if state.current_stock <= self.stock_critical_level:
            if num_cooperators_prev_round >= self.cooperation_necessity_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_475(BaseStrategy):
    """
    The Dynamic Exploiter with Self-Preservation strategy for the Common Pool Resource Game.
    This strategy aims to maximize its total accumulated payoff by opportunistically exploiting others'
    cooperation while prudently protecting the common resource from collapse to ensure future rounds.
    It adapts its behavior based on the current stock level and the observed cooperation levels of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.SAFETY_STOCK_THRESHOLD = self.game_description.capacity / 4.0
        self.COOPERATION_INCENTIVE_THRESHOLD = math.ceil(self.game_description.n_players / 2.0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_idx = state.round_number
        current_stock = state.current_stock
        n_rounds = self.game_description.n_rounds
        if current_round_idx == 0:
            return Action.C
        if current_round_idx == n_rounds - 1:
            return Action.D
        num_cooperators_prev_round = sum(history.opponent_actions[-1, :])
        if current_stock < self.SAFETY_STOCK_THRESHOLD:
            return Action.C
        if num_cooperators_prev_round >= self.COOPERATION_INCENTIVE_THRESHOLD:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_476(BaseStrategy):
    """
    Greedy Predator with Limited Patience: Prioritizes immediate self-gain by defecting,
    but cooperates under highly specific and restrictive conditions designed to allow
    future exploitation of a replenished resource, provided others bear the burden.
    Adaptive to opponent behavior and stock dynamics, robust by defaulting to immediate gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        S = state.current_stock
        n = self.n_players
        r = self.n_rounds
        capacity = self.capacity
        if current_round_1_indexed == 1:
            return Action.D
        if current_round_1_indexed == r:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        C_opponents_prev_round = np.sum(previous_round_opponent_actions)
        D_opponents_prev_round = n - 1 - C_opponents_prev_round
        consumption_if_I_D_myself = S / n
        consumption_if_I_D_opponents_D = D_opponents_prev_round * (S / n)
        consumption_if_I_D_opponents_C = C_opponents_prev_round * (S / (2 * n))
        total_consumption_if_I_D = consumption_if_I_D_myself + consumption_if_I_D_opponents_D + consumption_if_I_D_opponents_C
        S_remaining_if_I_D = max(0.0, S - total_consumption_if_I_D)
        stock_growth_if_I_D = 2 * S_remaining_if_I_D * (1 - S_remaining_if_I_D / capacity)
        S_next_if_I_D = min(S_remaining_if_I_D + stock_growth_if_I_D, capacity)
        consumption_if_I_C_myself = S / (2 * n)
        consumption_if_I_C_opponents_D = D_opponents_prev_round * (S / n)
        consumption_if_I_C_opponents_C = C_opponents_prev_round * (S / (2 * n))
        total_consumption_if_I_C = consumption_if_I_C_myself + consumption_if_I_C_opponents_D + consumption_if_I_C_opponents_C
        S_remaining_if_I_C = max(0.0, S - total_consumption_if_I_C)
        stock_growth_if_I_C = 2 * S_remaining_if_I_C * (1 - S_remaining_if_I_C / capacity)
        S_next_if_I_C = min(S_remaining_if_I_C + stock_growth_if_I_C, capacity)
        condition1_critically_low_stock = S <= capacity / (2 * n)
        condition2_perfect_opponent_cooperation = D_opponents_prev_round == 0
        condition3_projected_stock_recovery = S_next_if_I_C > S
        condition4_sufficient_future_rounds = r - current_round_1_indexed > 1
        if condition1_critically_low_stock and condition2_perfect_opponent_cooperation and condition3_projected_stock_recovery and condition4_sufficient_future_rounds:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_477(BaseStrategy):
    """
    Predator strategy: Exploitative by default, cooperates only to strategically preserve
    a critically low resource if opponents show restraint, and defects aggressively in the endgame.

    Core Principles:
    1. Exploit by Default: Always choose D unless specific conditions necessitate C.
    2. End Game Aggression: Defect unequivocally in the final rounds (last two rounds),
       as there are no future consequences for stock depletion.
    3. Strategic Preservation: Cooperate only when the stock is critically low AND there's a reasonable
       chance that our cooperation, combined with others' relatively restrained behavior, can help
       preserve or restore the stock for future exploitation. This is an investment.
    4. Avoid Sucker's Payoff: If the stock is critically low AND many opponents are already defecting,
       join the "race to the bottom" to extract what little value remains, rather than sacrificing
       individual payoff for a doomed resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        self.stock_critical_threshold = float(2 * n)
        self.d_tolerance_threshold = max(0, math.floor(n / 2) - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number + 1
        total_rounds_r = self.game_description.n_rounds
        current_stock_S = state.current_stock
        d_count_prev_round = 0
        if current_round_t > 1 and history is not None:
            d_count_prev_round = np.sum(~history.opponent_actions[-1, :])
        if state.round_number >= total_rounds_r - 2:
            return Action.D
        if current_stock_S < self.stock_critical_threshold and d_count_prev_round <= self.d_tolerance_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_478(BaseStrategy):
    """
    The Adaptive Predator strategy aims for maximum individual gain, adapting to game stage
    and resource health. It aggressively defects by default but includes a self-preservation
    mechanism to prevent resource collapse below a critical threshold.
    It does not attempt to induce cooperation from opponents or mirror their past actions,
    instead exploiting any cooperation that may occur.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == n_rounds - 1:
            return Action.D
        elif current_round_0_indexed == n_rounds - 2:
            return Action.D
        elif current_stock < capacity / 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_479(BaseStrategy):
    """
    The "Adaptive Predator" strategy prioritizes immediate individual gain by defecting,
    but implements calculated cooperation to prevent resource collapse or allow recovery,
    thereby securing future opportunities for exploitation. It adapts to opponent behavior
    and aims to maximize its own cumulative payoff over the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        n = self.n_players
        r = self.n_rounds
        capacity = self.capacity
        current_round_1_indexed = current_round_0_indexed + 1
        if current_round_1_indexed == r:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        else:
            num_opp_D_prev_round = np.sum(~history.opponent_actions[-1, :])
            S_rem_if_I_C = current_stock * ((n - num_opp_D_prev_round) / (2 * n))
            S_rem_if_I_D = current_stock * ((n - (num_opp_D_prev_round + 1)) / (2 * n))
            T_critical = capacity / (2 * n)
            if S_rem_if_I_D <= 0:
                return Action.C
            elif S_rem_if_I_D <= T_critical and S_rem_if_I_C > T_critical:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_480(BaseStrategy):
    """
    Adaptive Free-Rider (AFR) strategy for the Common Pool Resource Game.
    Prioritizes defection but cooperates when the common stock is dangerously low
    and opponents are not sufficiently cooperating, to prevent resource collapse.
    It becomes more aggressive (tolerates lower stock levels before cooperating)
    as the game nears its end. The strategy also includes an initial 'C' as a probe
    and an unconditional 'D' in the very last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.BASE_LOW_STOCK_THRESHOLD: float = 0.25
        self.RECOVERY_COOPERATION_THRESHOLD: float = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        actual_current_round = state.round_number + 1
        if actual_current_round == self.game_description.n_rounds:
            return Action.D
        if state.round_number == 0:
            return Action.C
        time_factor = (self.game_description.n_rounds - actual_current_round) / (self.game_description.n_rounds - 1)
        effective_low_stock_threshold = self.BASE_LOW_STOCK_THRESHOLD * time_factor
        prev_round_opponent_actions = history.opponent_actions[state.round_number - 1]
        num_opponent_cooperators = np.sum(prev_round_opponent_actions)
        total_opponents = self.game_description.n_players - 1
        opponent_cooperation_rate_prev = num_opponent_cooperators / total_opponents
        if state.current_stock <= effective_low_stock_threshold * self.game_description.capacity:
            if opponent_cooperation_rate_prev <= self.RECOVERY_COOPERATION_THRESHOLD:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_481(BaseStrategy):
    """
    Adaptive Predator: This strategy aims to maximize its own total payoff by defaulting to
    defection, but adapts its behavior based on the common resource's health and other players'
    recent actions. It enters a self-preservation mode if the stock is critically low and
    responds with aggressive defection if other players are widely exploitative.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.CRITICAL_STOCK_THRESHOLD = 0.25
        self.AGGRESSIVE_DEFECTION_RATE = 0.5
        self.PUNISH_DURATION = 1
        self.punishment_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            return Action.D
        if current_round == n_rounds - 1:
            return Action.D
        if current_stock <= capacity * self.CRITICAL_STOCK_THRESHOLD:
            return Action.C
        average_defection_rate_others = 0.0
        if current_round > 0:
            num_others_defected = n_players - 1 - np.sum(history.opponent_actions[-1, :])
            average_defection_rate_others = num_others_defected / (n_players - 1)
            if average_defection_rate_others >= self.AGGRESSIVE_DEFECTION_RATE:
                self.punishment_rounds_remaining = self.PUNISH_DURATION - 1
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_482(BaseStrategy):
    """
    The Opportunistic Predation strategy aims to maximize individual payoff in a Common Pool Resource game
    by defaulting to defection, while strategically cooperating only when necessary to preserve the resource
    for future exploitation or to encourage a cooperative environment that can be free-ridden upon.
    It includes an initial probe phase, an endgame exploitation phase, and a general phase balancing
    exploitation with resource preservation based on stock levels and opponent cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.exploitation_horizon_rounds: int = 2
        self.stock_critical_ratio: float = 0.5
        self.cooperation_threshold_for_preservation: float = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        num_opponents = n - 1
        if current_round_1_indexed == 1:
            return Action.C
        if current_round_0_indexed >= r - self.exploitation_horizon_rounds:
            return Action.D
        c_prev_count = np.sum(history.opponent_actions[current_round_0_indexed - 1, :])
        if current_stock < capacity * self.stock_critical_ratio:
            min_cooperators_needed = math.floor(num_opponents * self.cooperation_threshold_for_preservation)
            min_cooperators_needed = max(1, min_cooperators_needed) if num_opponents > 0 else 0
            if c_prev_count >= min_cooperators_needed:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_483(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its own total payoff over the game's rounds
    by primarily exploiting the common resource (defecting), but also incorporating a
    self-preservation mechanism. This mechanism triggers cooperation only when the strategy
    predicts that its defection would lead to a catastrophic depletion of the stock that
    its cooperation could avert, thus safeguarding its future earning potential.
    It starts aggressively and finishes greedily.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity

    def _calculate_next_stock(self, S_remaining_val: float) -> float:
        """
        Helper method to calculate the next round's stock level given the stock after consumption.
        Applies growth and caps at capacity.
        """
        S_effective_remaining = max(0.0, S_remaining_val)
        growth = 2 * S_effective_remaining * (1 - S_effective_remaining / self.capacity)
        return min(S_effective_remaining + growth, self.capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        prev_opponent_actions = history.opponent_actions[-1, :]
        num_opp_D_prev = np.sum(prev_opponent_actions == False)
        num_opp_C_prev = np.sum(prev_opponent_actions == True)
        consumption_D_per_player = current_stock / self.n_players
        consumption_C_per_player = current_stock / (2 * self.n_players)
        my_consumption_if_D = consumption_D_per_player
        total_consumption_if_I_D = my_consumption_if_D + num_opp_D_prev * consumption_D_per_player + num_opp_C_prev * consumption_C_per_player
        S_remaining_if_I_D = current_stock - total_consumption_if_I_D
        S_next_if_I_D = self._calculate_next_stock(S_remaining_if_I_D)
        my_consumption_if_C = consumption_C_per_player
        total_consumption_if_I_C = my_consumption_if_C + num_opp_D_prev * consumption_D_per_player + num_opp_C_prev * consumption_C_per_player
        S_remaining_if_I_C = current_stock - total_consumption_if_I_C
        S_next_if_I_C = self._calculate_next_stock(S_remaining_if_I_C)
        rounds_remaining_for_threshold = self.n_rounds - current_round_1_indexed + 1
        S_catastrophic_threshold = self.capacity / (2.0 * self.n_players * rounds_remaining_for_threshold)
        if S_next_if_I_D <= S_catastrophic_threshold and S_next_if_I_C > S_catastrophic_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_484(BaseStrategy):
    """
    The "Predatory Stock Manager" strategy always defects to maximize immediate gain,
    unless the resource is on the brink of collapse or it is the very last round of the game.
    It leverages the current stock level as the primary indicator of the resource's health.
    This strategy prioritizes self-interest, only cooperating to prevent total collapse
    and thereby preserving the possibility of future (exploitable) payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_hard_floor = self.capacity / (4.0 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == self.total_rounds - 1:
            return Action.D
        if current_stock < self.S_hard_floor:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_485(BaseStrategy):
    """
    Adaptive Predator strategy for the Common Pool Resource game.

    This strategy aims to aggressively exploit the resource when it is abundant,
    cooperate defensively when the resource is threatened (and others show willingness to help),
    and always maximize immediate payoff in the final round. It keeps track of
    previous stock levels to infer collective behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.stock_history = [self.capacity]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_idx = state.round_number
        current_stock = state.current_stock
        decision: Action
        if current_round_idx == self.n_rounds - 1:
            decision = Action.D
        elif current_round_idx == 0:
            decision = Action.D
        elif current_stock < self.capacity / 4:
            decision = Action.C
        elif current_stock < self.capacity / 2:
            last_S_start = self.stock_history[current_round_idx - 1]
            my_last_action_bool = history.my_actions[current_round_idx - 1]
            opponent_last_actions_bool = history.opponent_actions[current_round_idx - 1, :]
            num_cooperators_last_round = np.sum(opponent_last_actions_bool) + (1 if my_last_action_bool else 0)
            num_defectors_last_round = self.n_players - num_cooperators_last_round
            last_total_consumption = 0.0
            if last_S_start > 0:
                last_total_consumption = num_cooperators_last_round * last_S_start / (2 * self.n_players) + num_defectors_last_round * last_S_start / self.n_players
            fraction_defection_last_round = 0.0
            if last_S_start > 0:
                fraction_defection_last_round = 2 * last_total_consumption / last_S_start - 1
                fraction_defection_last_round = max(0.0, min(1.0, fraction_defection_last_round))
            else:
                fraction_defection_last_round = 1.0
            if fraction_defection_last_round > 0.5:
                decision = Action.D
            else:
                decision = Action.C
        else:
            decision = Action.D
        if len(self.stock_history) <= current_round_idx:
            self.stock_history.append(current_stock)
        return decision

class Strategy_EXPLOITATIVE_486(BaseStrategy):
    """
    The Adaptive Predator strategy aims to aggressively exploit the common resource,
    while dynamically adjusting its behavior based on the current stock level and
    the observed cooperation levels of other players. It operates on the principle
    of defaulting to defection unless specific conditions make cooperation a strategic
    necessity for future exploitation or preventing total collapse from which it cannot benefit.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.stock_danger_threshold = 2 * self.n_players
        self.stock_opportunity_threshold = self.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_stock <= 0.001:
            return Action.D
        if current_round == self.total_rounds - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        num_C_prev = sum(history.opponent_actions[current_round - 1, :])
        if current_stock < self.stock_danger_threshold:
            if num_C_prev >= self.n_players / 2:
                return Action.C
            else:
                return Action.D
        if current_stock >= self.stock_opportunity_threshold:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_487(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize individual payoff by defaulting to Defect (D)
    and only cooperating (C) as a self-preservation mechanism when the common resource is
    critically low and other players demonstrate sufficient cooperation. It exploits healthy
    resource levels and free-rides on others' cooperation, only contributing when necessary to
    prevent collapse for future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.STOCK_CRITICAL_LEVEL = self.game_description.capacity / 4.0
        self.COOPERATION_THRESHOLD_FOR_OTHERS = 0.5

    def _calculate_others_average_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculates the average cooperation rate of all other players across all past rounds recorded in history.
        'True' in history.opponent_actions signifies a Cooperate (C) action, 'False' signifies Defect (D).
        """
        total_other_cooperations_count = np.sum(history.opponent_actions)
        total_other_actions_count = history.opponent_actions.size
        if total_other_actions_count == 0:
            return 0.0
        return float(total_other_cooperations_count) / total_other_actions_count

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number
        current_stock = state.current_stock
        total_rounds = self.game_description.n_rounds
        if current_round_t == 0:
            return Action.D
        if current_round_t == total_rounds - 1:
            return Action.D
        avg_others_C_rate = self._calculate_others_average_cooperation_rate(history)
        if current_stock < self.STOCK_CRITICAL_LEVEL:
            if avg_others_C_rate > self.COOPERATION_THRESHOLD_FOR_OTHERS:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_488(BaseStrategy):
    """
    Adaptive Exploiter (AE) strategy for the Common Pool Resource Game.

    This strategy aims to maximize individual payoff by defaulting to defection,
    but adapts its behavior based on critical resource levels and opponent actions.
    It prioritizes resource preservation when stock is critically low,
    free-rides on widespread opponent cooperation, and retaliates against
    widespread opponent defection. In the final round, it always defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.num_players = game_description.n_players
        self.num_opponents = self.num_players - 1
        self.critical_stock_factor = 0.25
        self.opponent_cooperation_threshold = 0.6
        self.retaliation_threshold = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_idx = state.round_number
        current_stock = state.current_stock
        if current_round_0_idx == self.total_rounds - 1:
            return Action.D
        if current_stock < self.capacity * self.critical_stock_factor:
            return Action.C
        if current_round_0_idx == 0:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        c_prev_opponents = np.sum(previous_round_opponent_actions)
        d_prev_opponents = self.num_opponents - c_prev_opponents
        if c_prev_opponents / self.num_opponents >= self.opponent_cooperation_threshold:
            return Action.D
        if d_prev_opponents / self.num_opponents >= self.retaliation_threshold:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_489(BaseStrategy):
    """
    Adaptive Predator strategy for the Common Pool Resource game.

    This strategy aims to maximize its own total payoff over all rounds by generally defecting,
    but intelligently choosing to cooperate in critical situations to preserve the resource
    for future exploitation, or to avoid being a "sucker" when others are also defecting.

    It defaults to defection, which provides the highest immediate payoff. It only deviates
    from defection when its long-term payoff is jeopardized by resource collapse (a pragmatic
    choice) or when others are also defecting, in which case it defects to maximize its share
    of the remaining resource rather than altruistically preserving it for others. The primary
    exploitation occurs when others are cooperative.

    It adapts to the observed behavior of other players by analyzing their previous round's
    cooperation rate. It adjusts its aggressiveness (more defection) when it perceives
    cooperation and becomes defensively aggressive (matching defection) when it sees others
    exploiting.

    It is robust against resource collapse via the epsilon_stock_threshold, handles
    consistent cooperators by exploiting them, consistent defectors by matching them,
    and addresses the unique strategic considerations of the first and last rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initializes the Adaptive Predator strategy with game parameters and internal strategy tuning.

        Args:
            game_description: An object containing n_players, n_rounds, and capacity.
        """
        self.game_description = game_description
        self.epsilon_stock_threshold = 0.2
        self.cooperative_signal_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decides on an action (Cooperate or Defect) for the current round based on
        game state, history, and the Adaptive Predator strategy rules.

        Args:
            state: A CommonPoolState object containing round_number (0-indexed) and current_stock.
            history: A PlayerHistory object (or None for the first round) containing
                     actions and payoffs from previous rounds.

        Returns:
            An Action (Action.C for Cooperate, Action.D for Defect).
        """
        n_players = self.game_description.n_players
        n_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == n_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            if current_stock < self.epsilon_stock_threshold * capacity:
                return Action.C
            else:
                return Action.D
        previous_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
        num_opponent_C = sum(previous_round_opponent_actions)
        num_opponents = n_players - 1
        opponent_cooperation_rate = num_opponent_C / num_opponents
        if current_stock < self.epsilon_stock_threshold * capacity:
            return Action.C
        elif opponent_cooperation_rate >= self.cooperative_signal_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_490(BaseStrategy):
    """
    The "Opportunistic Predator" strategy is designed to maximize individual payoff by aggressively defecting
    and free-riding on the cooperation of others, while implementing a self-preservation mechanism to
    prevent total resource collapse that would ultimately lead to zero payoffs. It adapts its behavior
    to the current state of the common pool resource, prioritizing immediate gain when possible and
    strategic conservation when the resource is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_critical_threshold = self.capacity / (2 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        elif current_stock < self.S_critical_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_491(BaseStrategy):
    """
    The Opportunistic Harvester aims to maximize its own cumulative payoff by defecting whenever possible.
    It aggressively exploits periods when the resource is abundant or when other players are cooperating.
    However, it strategically switches to cooperation when the resource is critically low or when widespread
    defection by others threatens the resource's survival, understanding that a collapsed resource yields
    zero future payoffs. The strategy uses a clear hierarchy of rules, prioritizing end-game exploitation
    and resource conservation over adaptive exploitation based on history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_round_1_indexed == total_rounds:
            return Action.D
        if current_round_1_indexed == total_rounds - 1:
            return Action.D
        if current_stock < capacity / 4.0:
            return Action.C
        if current_round_1_indexed == 1:
            return Action.D
        else:
            total_cooperators_in_prev_round = sum(history.opponent_actions[-1, :])
            if total_cooperators_in_prev_round >= n_players / 2.0:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_492(BaseStrategy):
    """
    The "Strategic Predator" strategy is designed to maximize its own cumulative payoff over the course of the game, 
    adopting an aggressive and exploitative stance while maintaining enough foresight to prevent premature resource 
    collapse that would cut off its future profits. It dynamically adapts its behavior based on the current state 
    of the common stock and the observed collective actions of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.WINDOW_SIZE_FOR_AVG_DEFECTION = 3
        self.DEFECTION_TOLERANCE_PROPORTION = 0.6
        self.LOW_STOCK_RATIO = 0.6
        self.CRITICAL_STOCK_RATIO = 0.3
        self.ABSOLUTE_COLLAPSE_IMMINENT_STOCK_FLOOR = self.n * 2.5

    def _calculate_next_stock(self, initial_stock: float, my_action: Action, avg_opponent_defections_count: float) -> float:
        """
        Helper function to predict the next stock level based on current stock, my action,
        and the assumed average defection behavior of opponents.
        """
        num_opponents = self.n - 1
        estimated_other_consumption = 0.0
        if num_opponents > 0:
            estimated_other_defections = avg_opponent_defections_count
            estimated_other_cooperators = num_opponents - avg_opponent_defections_count
            estimated_other_defections = max(0.0, estimated_other_defections)
            estimated_other_cooperators = max(0.0, estimated_other_cooperators)
            estimated_other_consumption = estimated_other_defections * initial_stock / self.n + estimated_other_cooperators * initial_stock / (2 * self.n)
        my_consumption = initial_stock / self.n if my_action == Action.D else initial_stock / (2 * self.n)
        total_consumption = my_consumption + estimated_other_consumption
        stock_after_consumption = max(0.0, initial_stock - total_consumption)
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
        new_stock = min(stock_after_consumption + growth, self.capacity)
        return new_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        current_stock_S = state.current_stock
        if current_round_1_indexed == self.r:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        num_defections_in_window = 0
        rounds_considered_for_avg = 0
        start_history_idx = max(0, current_round_0_indexed - self.WINDOW_SIZE_FOR_AVG_DEFECTION)
        if history is not None and current_round_0_indexed > 0:
            for i in range(start_history_idx, current_round_0_indexed):
                opponent_actions_in_round = history.opponent_actions[i, :]
                num_defections_in_round = np.sum(~opponent_actions_in_round)
                num_defections_in_window += num_defections_in_round
                rounds_considered_for_avg += 1
        avg_opponent_defections_count = 0.0
        if rounds_considered_for_avg > 0:
            avg_opponent_defections_count = num_defections_in_window / rounds_considered_for_avg
        num_opponents = self.n - 1
        avg_opponent_defections_proportion = avg_opponent_defections_count / num_opponents if num_opponents > 0 else 0.0
        if current_stock_S <= self.ABSOLUTE_COLLAPSE_IMMINENT_STOCK_FLOOR:
            return Action.D
        if avg_opponent_defections_proportion >= self.DEFECTION_TOLERANCE_PROPORTION:
            return Action.D
        if current_stock_S > self.capacity * self.LOW_STOCK_RATIO:
            return Action.D
        next_stock_if_I_D = self._calculate_next_stock(current_stock_S, Action.D, avg_opponent_defections_count)
        next_stock_if_I_C = self._calculate_next_stock(current_stock_S, Action.C, avg_opponent_defections_count)
        remaining_rounds = self.r - current_round_1_indexed
        if (next_stock_if_I_D <= self.capacity * self.CRITICAL_STOCK_RATIO and next_stock_if_I_C > self.capacity * self.CRITICAL_STOCK_RATIO) and remaining_rounds > self.r / 4:
            return Action.C
        if next_stock_if_I_C > current_stock_S + self.capacity * 0.05 and next_stock_if_I_D < current_stock_S - self.capacity * 0.05 and (remaining_rounds > self.r / 3):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_493(BaseStrategy):
    """
    Adaptive Predator with Dynamic Survival Threshold strategy for the Common Pool Resource Game.

    This strategy aims to maximize individual payoff by defaulting to defection (D) but
    switches to cooperation (C) as a self-preservation measure when the resource's stock level
    is projected to become critically low. It adapts its behavior based on the current stock
    and the observed actions of other players in the immediate past.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.S_survival_threshold_ratio = 0.25
        self.S_survival_threshold = self.capacity * self.S_survival_threshold_ratio

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        k_C_others_prev = np.sum(previous_round_opponent_actions)
        k_D_others_prev = self.n_players - 1 - k_C_others_prev
        my_consumption_if_D = current_stock / self.n_players
        others_consumption_predicted = k_D_others_prev * current_stock / self.n_players + k_C_others_prev * current_stock / (2 * self.n_players)
        predicted_total_consumption_if_I_D = my_consumption_if_D + others_consumption_predicted
        projected_S_after_my_D_and_others_prev = current_stock - predicted_total_consumption_if_I_D
        if projected_S_after_my_D_and_others_prev < self.S_survival_threshold:
            my_consumption_if_C = current_stock / (2 * self.n_players)
            predicted_total_consumption_if_I_C = my_consumption_if_C + others_consumption_predicted
            projected_S_after_my_C_and_others_prev = current_stock - predicted_total_consumption_if_I_C
            if projected_S_after_my_C_and_others_prev >= self.S_survival_threshold:
                return Action.C
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_494(BaseStrategy):
    """
    The Selfish Steward strategy for the Common Pool Resource game.
    This strategy aims to maximize its own total payoff over all rounds by primarily defecting,
    but adaptively cooperating only when the resource is critically endangered and
    there's a sufficient collective effort from other players to make cooperation
    a worthwhile investment for future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.CRITICAL_STOCK_LEVEL = self.capacity * 0.25
        self.MIN_COOPERATORS_FOR_MY_COOPERATION = (self.n_players - 1) * 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_t = state.round_number + 1
        if current_round_t == self.n_rounds:
            return Action.D
        if current_round_t == 1:
            return Action.D
        c_count_prev_others = np.sum(history.opponent_actions[-1, :])
        if state.current_stock < self.CRITICAL_STOCK_LEVEL and c_count_prev_others >= self.MIN_COOPERATORS_FOR_MY_COOPERATION:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_495(BaseStrategy):
    """
    The Adaptive Harvester strategy for the Common Pool Resource Game.

    This strategy aims to maximize its own cumulative payoff by primarily defecting.
    It cooperates only under specific, calculated conditions:
    1. To prevent the resource from collapsing if its defection would be critical,
       and sufficient opponents are cooperating to make its cooperation meaningful.
    2. When the resource is already doomed to collapse regardless of its action, it defects to salvage what it can.
    3. To boost the resource back to a healthier state when all other players
       are highly cooperative, ensuring a larger pool for future exploitation.
    4. Always defects in the final round (no future consequences).
    5. Always defects in the first round (gather info, aggressive stance).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.CRITICAL_STOCK_THRESHOLD_DEFECT_RISK = self.capacity / 4.0
        self.HEALTHY_STOCK_LEVEL = self.capacity / 2.0
        if self.n == 0:
            self.FUTILE_COOPERATION_THRESHOLD_STOCK = 0.0
        else:
            self.FUTILE_COOPERATION_THRESHOLD_STOCK = self.capacity / (2.0 * self.n)

    def _predict_next_stock(self, current_stock: float, my_action: Action, num_opponents_cooperated: int, num_opponents_defected: int) -> float:
        """
        Helper function to predict the next round's stock level based on current stock,
        my action, and assumed opponent actions (repeating previous round's).
        """
        n_players = self.n
        capacity = self.capacity
        if my_action == Action.C:
            my_consumption = current_stock / (2.0 * n_players)
        else:
            my_consumption = current_stock / n_players
        opponents_consumption = num_opponents_cooperated * current_stock / (2.0 * n_players) + num_opponents_defected * current_stock / n_players
        total_consumption = my_consumption + opponents_consumption
        S_remaining = max(0.0, current_stock - total_consumption)
        growth_factor = 0.0
        if capacity > 0:
            growth_factor = 1.0 - S_remaining / capacity
        growth = 2.0 * S_remaining * growth_factor
        new_stock = min(S_remaining + growth, capacity)
        return new_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = float(state.current_stock)
        if current_round_0_indexed == self.r - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        num_opponents_cooperated_prev = int(np.sum(history.opponent_actions[-1, :]))
        num_opponents_defected_prev = self.n - 1 - num_opponents_cooperated_prev
        next_stock_if_I_D = self._predict_next_stock(current_stock, Action.D, num_opponents_cooperated_prev, num_opponents_defected_prev)
        next_stock_if_I_C = self._predict_next_stock(current_stock, Action.C, num_opponents_cooperated_prev, num_opponents_defected_prev)
        if next_stock_if_I_C >= self.HEALTHY_STOCK_LEVEL and next_stock_if_I_D < self.CRITICAL_STOCK_THRESHOLD_DEFECT_RISK and (num_opponents_cooperated_prev >= (self.n - 1) / 2.0):
            return Action.C
        if next_stock_if_I_C <= self.FUTILE_COOPERATION_THRESHOLD_STOCK:
            return Action.D
        if current_stock < self.HEALTHY_STOCK_LEVEL and num_opponents_cooperated_prev == self.n - 1 and (next_stock_if_I_C > next_stock_if_I_D):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_496(BaseStrategy):
    """
    Adaptive Predator Pro Max: An exploitative strategy for the Common Pool Resource game.
    It primarily defects to maximize immediate gain but strategically cooperates to prevent
    premature resource collapse, or when cooperation is likely to be reciprocated. It extracts
    value from a collapsing resource when cooperation is futile. The strategy adapts based on
    current stock, observed player behavior, and round number.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_CRITICAL_RATIO = 0.4
        self.S_DEPLETION_THRESHOLD_RATIO = 0.1
        self.P_D_THRESHOLD_COOPERATE = 0.3
        self.P_D_THRESHOLD_EXPLOIT = 0.7
        self.EXPLOIT_THRESHOLD_ROUNDS_RATIO = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        last_round_D_count = 0
        P_D_observed = 0.0
        if current_round_1_indexed > 1:
            last_round_D_count = np.sum(~history.opponent_actions[-1, :])
            P_D_observed = float(last_round_D_count) / (n - 1)
        stock_ratio = current_stock / capacity
        if current_round_1_indexed == r:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.C
        exploit_threshold_absolute_rounds = int(r * self.EXPLOIT_THRESHOLD_ROUNDS_RATIO)
        if stock_ratio <= self.S_DEPLETION_THRESHOLD_RATIO:
            return Action.D
        elif stock_ratio <= self.S_CRITICAL_RATIO:
            if P_D_observed <= self.P_D_THRESHOLD_COOPERATE:
                return Action.C
            else:
                return Action.D
        elif current_round_1_indexed > exploit_threshold_absolute_rounds or P_D_observed >= self.P_D_THRESHOLD_EXPLOIT:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_497(BaseStrategy):
    """
    The "Greedy Chameleon" strategy is designed to be highly exploitative,
    prioritizing the agent's own cumulative payoff by aggressively extracting
    from the common pool. It adapts its behavior based on the current state of
    the resource, the actions of other players, and the game's progression,
    shifting between aggressive exploitation and temporary resource preservation
    (only when necessary for future exploitation).

    This strategy acknowledges the strong immediate incentive to Defect (D) but
    avoids the self-defeating outcome of immediate resource collapse by
    introducing conditional cooperation when the resource is critically endangered
    and there are enough rounds left to matter. Otherwise, it defaults to
    defection, especially when others cooperate or when the resource is
    sufficiently healthy to withstand defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_action_was_cooperate = False
        self.rounds_in_critical_recovery_mode = 0
        self.CRITICAL_STOCK_FACTOR = 0.1
        self.EXPLORATION_ROUNDS_RATIO = 0.2
        self.OPPONENT_DEFECTION_TOLERANCE = 0.5
        self.RECOVERY_TARGET_STOCK_FACTOR = 0.7
        self.MAX_CRITICAL_RECOVERY_COOPERATION_ROUNDS = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        exploration_rounds = max(1, math.floor(total_rounds * self.EXPLORATION_ROUNDS_RATIO))
        critical_stock_threshold = self.CRITICAL_STOCK_FACTOR * capacity
        recovery_target_stock = self.RECOVERY_TARGET_STOCK_FACTOR * capacity
        remaining_rounds = total_rounds - current_round_1_indexed
        opponent_defection_rate = 0.0
        if history is not None and state.round_number >= 1:
            opponent_actions_last_round = history.opponent_actions[state.round_number - 1, :]
            num_opponent_defectors = np.sum(opponent_actions_last_round == False)
            opponent_defection_rate = num_opponent_defectors / (n_players - 1)
        action = None
        if remaining_rounds == 0:
            action = Action.D
            self.rounds_in_critical_recovery_mode = 0
        elif current_stock <= critical_stock_threshold:
            if remaining_rounds <= 2:
                action = Action.D
            elif self.rounds_in_critical_recovery_mode >= self.MAX_CRITICAL_RECOVERY_COOPERATION_ROUNDS:
                action = Action.D
            else:
                action = Action.C
                self.rounds_in_critical_recovery_mode += 1
        elif current_round_1_indexed <= exploration_rounds:
            action = Action.D
            self.rounds_in_critical_recovery_mode = 0
        else:
            if current_stock >= recovery_target_stock and self.rounds_in_critical_recovery_mode > 0:
                self.rounds_in_critical_recovery_mode = 0
            if opponent_defection_rate < self.OPPONENT_DEFECTION_TOLERANCE:
                action = Action.D
            elif current_stock < capacity * 0.5:
                if self.last_action_was_cooperate and self.rounds_in_critical_recovery_mode < self.MAX_CRITICAL_RECOVERY_COOPERATION_ROUNDS:
                    action = Action.C
                else:
                    action = Action.D
            else:
                action = Action.D
        self.last_action_was_cooperate = action == Action.C
        return action

class Strategy_EXPLOITATIVE_498(BaseStrategy):
    """
    The "Defect Until Desperate" strategy aims to be exploitative by consistently defecting
    to maximize immediate gain. However, it incorporates a self-preserving conditional
    cooperation mechanism: if the common resource (stock) falls below a critical level,
    it will cooperate, provided there are enough future rounds remaining to make a recovery
    attempt worthwhile for subsequent exploitation. If the resource is critically low and
    there are insufficient rounds for meaningful recovery, the strategy reverts to defection
    to extract what little remains, prioritizing immediate gain when long-term sustainability
    is no longer a viable self-interested option.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_ratio = 0.1
        self.min_rounds_for_recovery_attempt = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        critical_stock_level = capacity * self.critical_stock_ratio
        rounds_remaining_after_current = total_rounds - (current_round_0_indexed + 1)
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        elif current_stock > critical_stock_level:
            return Action.D
        elif rounds_remaining_after_current >= self.min_rounds_for_recovery_attempt:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_499(BaseStrategy):
    """
    The "Calculated Thief" prioritizes immediate self-gain (defection) as much as possible.
    It strategically cooperates only when continued defection is predicted to lead to a
    stock level so low that it jeopardizes future exploitation potential.
    It adapts to opponent behavior by exploiting cooperative tendencies and retaliating
    against widespread defection, though the latter still leads to defection unless
    an imminent resource collapse is predicted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        capacity = float(self.game_description.capacity)
        current_stock = state.current_stock
        if current_round_1_indexed == total_rounds:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        num_opponents = n_players - 1
        num_defectors_prev = np.sum(history.opponent_actions[-1, :] == False)
        if num_opponents > 0:
            opponent_defection_rate = num_defectors_prev / num_opponents
        else:
            opponent_defection_rate = 0.0
        my_consumption_if_I_D = current_stock / n_players
        num_cooperators_prev = num_opponents - num_defectors_prev
        others_consumption_predicted = num_defectors_prev * current_stock / n_players + num_cooperators_prev * current_stock / (2 * n_players)
        total_consumption_predicted_if_I_D = my_consumption_if_I_D + others_consumption_predicted
        S_remaining_predicted_if_I_D = max(0.0, current_stock - total_consumption_predicted_if_I_D)
        growth_predicted = 2 * S_remaining_predicted_if_I_D * (1 - S_remaining_predicted_if_I_D / capacity)
        predicted_next_stock_if_I_D = min(S_remaining_predicted_if_I_D + growth_predicted, capacity)
        CRITICAL_STOCK_THRESHOLD = capacity / (2 * n_players)
        if predicted_next_stock_if_I_D < CRITICAL_STOCK_THRESHOLD:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_500(BaseStrategy):
    """
    The "Adaptive Predator" strategy is designed to be exploitative while remaining robust
    and adaptive to varying opponent behaviors and dynamic resource levels. It prioritizes
    personal gain through defection but incorporates safeguards to prevent total resource
    collapse, which would yield zero future payoffs for all players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.STOCK_CRITICAL_THRESHOLD = 0.25 * self.capacity
        self.STOCK_HEALTHY_THRESHOLD = 0.75 * self.capacity
        self.OPPONENT_COOP_EXPLOIT_THRESHOLD_RATIO = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        num_other_players = self.n_players - 1
        if current_round_1_indexed == self.n_rounds:
            return Action.D
        elif current_round_1_indexed == 1:
            return Action.C
        else:
            num_cooperated_by_others_prev_round = sum(history.opponent_actions[-1, :])
            if current_stock <= self.STOCK_CRITICAL_THRESHOLD:
                return Action.C
            elif current_stock > self.STOCK_HEALTHY_THRESHOLD:
                return Action.D
            else:
                required_cooperators_for_exploitation = self.OPPONENT_COOP_EXPLOIT_THRESHOLD_RATIO * num_other_players
                if num_cooperated_by_others_prev_round >= required_cooperators_for_exploitation:
                    return Action.D
                else:
                    return Action.C

class Strategy_EXPLOITATIVE_501(BaseStrategy):
    """
    The Opportunistic Defector (OD) strategy is designed to be highly exploitative,
    prioritizing individual payoff maximization while being adaptive to opponent behavior
    and the state of the common resource. It defaults to defecting unless specific,
    self-serving conditions for cooperation are met. OD aims to extract as much value
    as possible from the common pool, cooperating strategically only when the resource
    is critically endangered AND there's a strong collective effort from other players
    that makes recovery plausible and beneficial for the OD's long-term total payoff.
    It does not cooperate out of altruism but purely as a calculated move to prevent
    premature resource collapse that would diminish its own future returns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.COOPERATION_THRESHOLD_FOR_OTHERS = 0.85
        self.CRITICAL_STOCK_RATIO = 0.15
        self.LAST_FEW_ROUNDS_THRESHOLD = 0.33

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        future_rounds_count = self.n_rounds - (current_round_0_indexed + 1)
        num_other_cooperators_prev_round = 0
        if current_round_0_indexed > 0:
            prev_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
            num_other_cooperators_prev_round = np.sum(prev_round_opponent_actions)
        cooperation_ratio_others = 0.0
        num_others = self.n_players - 1
        if num_others > 0:
            cooperation_ratio_others = num_other_cooperators_prev_round / num_others
        is_stock_critical = current_stock < self.capacity * self.CRITICAL_STOCK_RATIO
        if is_stock_critical and future_rounds_count > self.n_rounds * self.LAST_FEW_ROUNDS_THRESHOLD and (cooperation_ratio_others >= self.COOPERATION_THRESHOLD_FOR_OTHERS):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_502(BaseStrategy):
    """
    The Adaptive Predator strategy is designed for the Common Pool Resource Game.
    It aims to maximize individual payoff by aggressively exploiting the common resource
    when safe, while strategically cooperating to preserve the resource when it's
    critically low or to stabilize the system in hopes of enabling future exploitation.

    Core principles include:
    - Defecting in the first and last rounds.
    - Defecting when stock is healthy and others are cooperating sufficiently.
    - Cooperating when stock is low to prevent collapse.
    - Cooperating when others are defecting heavily (but stock isn't critical) to signal
      or stabilize, hoping to induce more cooperation from others.
    - Defecting to cut losses when stock is critically low and others are also defecting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.S_LOW_THRESHOLD_FACTOR = 0.3
        self.S_VERY_LOW_THRESHOLD_FACTOR = 0.1
        self.COOPERATION_TOLERANCE_PROPORTION = 0.6
        self.DEFECTION_FOR_SURVIVAL_TOLERANCE_PROPORTION = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        num_players = self.game_description.n_players
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        S_low_threshold = capacity * self.S_LOW_THRESHOLD_FACTOR
        S_very_low_threshold = capacity * self.S_VERY_LOW_THRESHOLD_FACTOR
        num_other_players = num_players - 1
        num_cooperators_others = np.sum(history.opponent_actions[-1, :])
        proportion_cooperators_others = num_cooperators_others / num_other_players
        if current_stock < S_very_low_threshold and proportion_cooperators_others < self.DEFECTION_FOR_SURVIVAL_TOLERANCE_PROPORTION:
            return Action.D
        if current_stock < S_low_threshold:
            return Action.C
        if proportion_cooperators_others >= self.COOPERATION_TOLERANCE_PROPORTION:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_503(BaseStrategy):
    """
    Greedy Predator with Survival Instinct: Aims to maximize cumulative payoff by defaulting
    to defection (greedy behavior). However, it adapts by cooperating if the common pool
    resource is critically low, a majority of opponents are defecting, and there are
    sufficient rounds remaining for the resource to recover for future exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_threshold = self.game_description.capacity / 4.0
        self.defection_rate_threshold = 0.5
        self.n_players = self.game_description.n_players
        self.n_rounds = self.game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        if current_round_0_indexed == 0 or current_round_0_indexed == self.n_rounds - 1:
            return Action.D
        n_other_players = self.n_players - 1
        num_other_defectors = np.sum(history.opponent_actions[-1, :] == False)
        P_D_others = num_other_defectors / n_other_players
        resource_critically_low = current_stock < self.critical_stock_threshold
        enough_rounds_for_recovery = self.n_rounds - current_round_0_indexed > 2
        if P_D_others > self.defection_rate_threshold and resource_critically_low and enough_rounds_for_recovery:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_504(BaseStrategy):
    """
    The "Opportunistic Predator" strategy is designed for a tournament setting where
    individual payoff maximization is the primary goal. It balances aggressive
    exploitation with a pragmatic approach to resource sustainability, aiming to
    extract maximum value from the common pool while avoiding early personal ruin
    due to collective resource collapse. It is adaptive to opponent behavior and
    the changing state of the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        self.end_game_rounds = max(1, math.floor(r / 5))
        self.stock_recovery_threshold_factor = 0.25
        self.buffer_factor = 0.1
        if n > 1:
            self.defection_tolerance_threshold_high = (n - 1) / n
            if self.defection_tolerance_threshold_high > 0.05:
                self.defection_tolerance_threshold_high -= 0.05
            else:
                self.defection_tolerance_threshold_high = 0.0
        else:
            self.defection_tolerance_threshold_high = 0.0
        self.defection_tolerance_threshold_low = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if current_round_1_indexed >= r - self.end_game_rounds + 1:
            return Action.D
        if current_stock < capacity * self.stock_recovery_threshold_factor:
            return Action.C
        if current_round_0_indexed == 0:
            return Action.D
        prev_round_opponent_actions = history.opponent_actions[-1, :]
        opponent_cooperation_count = np.sum(prev_round_opponent_actions)
        opponent_defection_count = n - 1 - opponent_cooperation_count
        opponent_defection_rate = opponent_defection_count / (n - 1)
        my_consumption_if_i_d = current_stock / n
        total_opponent_consumption_projected = opponent_defection_count * (current_stock / n) + opponent_cooperation_count * (current_stock / (2 * n))
        total_consumption_projected_if_i_d = my_consumption_if_i_d + total_opponent_consumption_projected
        stock_after_consumption_if_i_d = max(0.0, current_stock - total_consumption_projected_if_i_d)
        projected_growth_if_i_d = 2 * stock_after_consumption_if_i_d * (1 - stock_after_consumption_if_i_d / capacity)
        projected_next_stock_if_i_d = min(stock_after_consumption_if_i_d + projected_growth_if_i_d, capacity)
        if opponent_defection_rate >= self.defection_tolerance_threshold_high:
            return Action.D
        if opponent_defection_rate <= self.defection_tolerance_threshold_low:
            if projected_next_stock_if_i_d < capacity * (self.stock_recovery_threshold_factor + self.buffer_factor):
                return Action.C
            else:
                return Action.D
        elif projected_next_stock_if_i_d < capacity * (self.stock_recovery_threshold_factor + self.buffer_factor):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_505(BaseStrategy):
    """
    The "Greedy Opportunist" strategy aims to maximize its own total payoff over the course of the game
    by defaulting to defection, but strategically cooperating only when its defection would lead to a
    critical, long-term depletion of the common stock that *could otherwise be avoided by its cooperation*.
    It is robust because it adapts to the observed behavior of other players and the current stock level,
    without making overly optimistic assumptions about others' cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.critical_threshold = self.capacity / (2 * self.n)

    def _calculate_next_stock(self, current_stock: float, total_consumption: float) -> float:
        """
        Calculates the next round's stock level based on current stock and total consumption.
        """
        stock_after_consumption = current_stock - total_consumption
        stock_for_growth_calc = max(0.0, stock_after_consumption)
        growth = 2 * stock_for_growth_calc * (1 - stock_for_growth_calc / self.capacity)
        new_stock = min(stock_after_consumption + growth, self.capacity)
        return new_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_round_1_indexed = current_round_0_indexed + 1
        current_stock = state.current_stock
        if current_round_1_indexed == 1 or current_round_1_indexed == self.r:
            return Action.D
        num_opponents_C_prev = np.sum(history.opponent_actions[-1, :])
        num_opponents_D_prev = self.n - 1 - num_opponents_C_prev
        consumption_per_player_C = current_stock / (2 * self.n)
        consumption_per_player_D = current_stock / self.n
        opponents_consumption_total = num_opponents_D_prev * consumption_per_player_D + num_opponents_C_prev * consumption_per_player_C
        my_consumption_if_I_D = consumption_per_player_D
        total_consumption_if_I_D = my_consumption_if_I_D + opponents_consumption_total
        projected_next_stock_if_I_D = self._calculate_next_stock(current_stock, total_consumption_if_I_D)
        my_consumption_if_I_C = consumption_per_player_C
        total_consumption_if_I_C = my_consumption_if_I_C + opponents_consumption_total
        projected_next_stock_if_I_C = self._calculate_next_stock(current_stock, total_consumption_if_I_C)
        if projected_next_stock_if_I_D <= self.critical_threshold:
            if projected_next_stock_if_I_C > self.critical_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_506(BaseStrategy):
    """
    Adaptive Exploiter strategy for the Common Pool Resource game.
    This strategy aims to maximize personal total payoff by defaulting to defection,
    but strategically cooperating to ensure the common resource remains viable
    for future exploitation. It adapts based on current stock levels and
    the observed behavior of other players in the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.safe_stock_threshold = self.capacity / 2.0
        self.desperation_stock_threshold = self.capacity / (4.0 * self.n)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        current_stock = state.current_stock
        current_stock = float(current_stock)
        if current_round_0_indexed == self.r - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.D
        else:
            if current_stock <= 0:
                return Action.D
            prev_round_opponent_actions = history.opponent_actions[current_round_0_indexed - 1, :]
            c_opponents_count = np.sum(prev_round_opponent_actions)
            d_opponents_count = self.n - 1 - c_opponents_count
            cons_me_D = current_stock / self.n
            cons_others_D = c_opponents_count * (current_stock / (2.0 * self.n)) + d_opponents_count * (current_stock / self.n)
            total_cons_D = cons_me_D + cons_others_D
            S_remaining_D = max(0.0, current_stock - total_cons_D)
            growth_D = 2.0 * S_remaining_D * (1.0 - S_remaining_D / self.capacity)
            S_forecast_D = min(S_remaining_D + growth_D, self.capacity)
            cons_me_C = current_stock / (2.0 * self.n)
            cons_others_C = c_opponents_count * (current_stock / (2.0 * self.n)) + d_opponents_count * (current_stock / self.n)
            total_cons_C = cons_me_C + cons_others_C
            S_remaining_C = max(0.0, current_stock - total_cons_C)
            growth_C = 2.0 * S_remaining_C * (1.0 - S_remaining_C / self.capacity)
            S_forecast_C = min(S_remaining_C + growth_C, self.capacity)
            if S_forecast_D >= self.safe_stock_threshold:
                return Action.D
            elif S_forecast_D < self.safe_stock_threshold and S_forecast_C >= self.safe_stock_threshold:
                return Action.C
            elif S_forecast_D < self.desperation_stock_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_507(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its own total payoff over 'r' rounds.
    It prioritizes immediate gains (defection) but adaptively cooperates only when defection
    would lead to a likely collapse of the resource that negatively impacts its own future
    payoffs, and when its cooperation can realistically avert this. The strategy assumes
    opponents will broadly continue their observed past behavior.

    Key principles:
    1. End-Game Exploitation: Always defect in the final two rounds for maximum immediate gain.
    2. Initial Round Strategy: Default to defection, but cooperate if the stock is critically low.
    3. Adaptive Intermediate Rounds:
       - Predicts others' actions based on the previous round.
       - Simulates the next round's stock level for both 'Cooperate' and 'Defect' actions.
       - If current stock is critically low, cooperates to aid recovery.
       - If defection keeps the stock above critical, defects.
       - If defection pushes the stock below critical, but cooperation keeps it above, cooperates.
       - If stock is predicted to fall below critical regardless of this player's action, defects.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_low = 2 * self.n_players

    def _predict_next_stock(self, current_S: float, my_action_is_C_bool: bool, num_opp_cooperators: int, num_opp_defectors: int) -> float:
        """
        Calculates the predicted stock level for the next round based on current stock,
        this player's hypothetical action, and the predicted actions of opponents.
        """
        my_consumption: float
        if my_action_is_C_bool:
            my_consumption = current_S / (2 * self.n_players)
        else:
            my_consumption = current_S / self.n_players
        opponents_consumption = num_opp_cooperators * current_S / (2 * self.n_players) + num_opp_defectors * current_S / self.n_players
        total_consumption = my_consumption + opponents_consumption
        stock_after_consumption = current_S - total_consumption
        stock_after_consumption = max(0.0, stock_after_consumption)
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
        new_stock = min(stock_after_consumption + growth, self.capacity)
        return new_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        strategy_round_num = state.round_number + 1
        if strategy_round_num == self.n_rounds or strategy_round_num == self.n_rounds - 1:
            return Action.D
        if strategy_round_num == 1:
            if current_stock < self.S_low:
                return Action.C
            else:
                return Action.D
        previous_round_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        num_opp_cooperators = int(np.sum(previous_round_opponent_actions))
        num_opp_defectors = self.n_players - 1 - num_opp_cooperators
        S_next_pred_C = self._predict_next_stock(current_stock, True, num_opp_cooperators, num_opp_defectors)
        S_next_pred_D = self._predict_next_stock(current_stock, False, num_opp_cooperators, num_opp_defectors)
        if current_stock < self.S_low:
            return Action.C
        elif S_next_pred_D >= self.S_low:
            return Action.D
        elif S_next_pred_D < self.S_low and S_next_pred_C >= self.S_low:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_508(BaseStrategy):
    """
    The Resource Vulture strategy is an exploitative, adaptive, and robust approach
    for the Common Pool Resource game. It prioritizes maximizing its own total
    payoff by defecting (consuming more) whenever possible. It only cooperates
    under specific self-preservation conditions: either to prevent immediate
    catastrophic stock collapse or to avoid pushing the stock into a critical
    danger zone, thereby ensuring future opportunities for exploitation.
    It estimates other players' behavior based on the previous round or
    a pessimistic assumption in the first round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.epsilon = 0.001

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        stock = state.current_stock
        if current_round_1_indexed == self.r:
            return Action.D
        num_other_defectors_last_round = 0
        if state.round_number > 0:
            num_other_defectors_last_round = np.sum(~history.opponent_actions[-1, :])
        else:
            num_other_defectors_last_round = self.n - 1
        num_other_cooperators_last_round = self.n - 1 - num_other_defectors_last_round
        consumption_per_defect = stock / self.n
        consumption_per_cooperate = stock / (2 * self.n)
        estimated_consumption_by_others = num_other_defectors_last_round * consumption_per_defect + num_other_cooperators_last_round * consumption_per_cooperate
        stock_after_others_consumption = stock - estimated_consumption_by_others
        projected_stock_if_I_defect = stock_after_others_consumption - consumption_per_defect
        projected_stock_if_I_cooperate = stock_after_others_consumption - consumption_per_cooperate
        if projected_stock_if_I_defect < self.epsilon:
            return Action.C
        stock_danger_threshold = self.capacity / (2.0 * self.n)
        if projected_stock_if_I_defect < stock_danger_threshold and projected_stock_if_I_cooperate >= stock_danger_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_509(BaseStrategy):
    """
    The "Adaptive Predator" strategy for the Common Pool Resource game.

    This strategy aims to maximize its total payoff by balancing short-term gain
    (defecting) with long-term sustainability (cooperating). It continuously assesses
    the health of the common stock and the cooperativeness of other players to
    make its decision. It exploits cooperation, encourages sustainability
    opportunistically, and minimizes losses when the resource is diminishing.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity
        self.W = 3
        self.S_critical_low = self.capacity / self.n
        self.S_deteriorating_threshold = self.capacity / 2
        self.S_healthy_threshold = self.capacity * 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_0_indexed = state.round_number
        total_rounds = self.r
        current_stock = state.current_stock
        if current_round_0_indexed == total_rounds - 1:
            return Action.D
        if current_round_0_indexed == 0:
            return Action.C
        num_other_players = self.n - 1
        start_history_index = max(0, current_round_0_indexed - self.W)
        end_history_index = current_round_0_indexed
        num_rounds_in_window = end_history_index - start_history_index
        total_C_by_others = 0
        total_actions_by_others = 0
        if num_rounds_in_window > 0 and history is not None:
            total_C_by_others = np.sum(history.opponent_actions[start_history_index:end_history_index, :])
            total_actions_by_others = num_rounds_in_window * num_other_players
        coop_ratio_others = 0.5
        if total_actions_by_others > 0:
            coop_ratio_others = total_C_by_others / total_actions_by_others
        if current_stock <= self.S_critical_low:
            return Action.D
        if current_stock < self.S_deteriorating_threshold or coop_ratio_others < 0.25:
            return Action.D
        if current_stock >= self.S_healthy_threshold and coop_ratio_others >= 0.75:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_510(BaseStrategy):
    """
    Greedy Harvester with Self-Preservation strategy.
    Prioritizes immediate personal gain (Defect) unless the projected health of the common
    resource falls below a critical threshold, at which point it cooperates (Cooperate)
    to ensure future opportunities for exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.S_min_viable = self.capacity / 4.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        current_stock = state.current_stock
        if current_round_1_indexed == self.r:
            return Action.D
        if current_round_1_indexed == 1:
            return Action.D
        else:
            opponent_actions_prev_round = history.opponent_actions[state.round_number - 1, :]
            num_C_others = np.sum(opponent_actions_prev_round)
            num_D_others = self.n - 1 - num_C_others
            my_D_consumption = current_stock / self.n
            others_consumption = num_D_others * current_stock / self.n + num_C_others * current_stock / (2 * self.n)
            total_consumption_if_I_D = my_D_consumption + others_consumption
            S_remaining_if_I_D = max(0.0, current_stock - total_consumption_if_I_D)
            growth_if_I_D = 2 * S_remaining_if_I_D * (1 - S_remaining_if_I_D / self.capacity)
            S_projected = min(S_remaining_if_I_D + growth_if_I_D, self.capacity)
            if S_projected <= self.S_min_viable:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_511(BaseStrategy):
    """
    The "Opportunistic Steward" is a strategic and adaptive approach designed to maximize
    individual payoff in the Common Pool Resource game. It operates under the principle
    of "enlightened self-interest," recognizing that a healthy common pool is essential
    for sustained exploitation. The strategy leverages opportunistic defection when
    conditions are favorable, punishes widespread defection to restore exploitable
    conditions, and acts as a steward of the resource when its viability is threatened.
    It's built to be robust across a spectrum of opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.end_game_rounds = 2
        self.stock_critical_threshold_factor = 0.3
        self.stock_healthy_threshold_factor = 0.8
        num_opponents = self.n_players - 1
        self.opponent_defection_for_punishment_count_threshold = math.ceil(num_opponents * 0.5)
        self.opponent_cooperation_for_freeride_count_threshold = math.ceil(num_opponents * 0.75)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        if state.round_number == 0:
            return Action.C
        if current_round_1_indexed > self.n_rounds - self.end_game_rounds:
            return Action.D
        if state.current_stock < self.capacity * self.stock_critical_threshold_factor:
            return Action.C
        previous_opponent_actions = history.opponent_actions[state.round_number - 1, :]
        num_opponent_cooperators_prev_round = np.sum(previous_opponent_actions)
        num_opponent_defectors_prev_round = self.n_players - 1 - num_opponent_cooperators_prev_round
        if num_opponent_defectors_prev_round >= self.opponent_defection_for_punishment_count_threshold:
            return Action.D
        if state.current_stock > self.capacity * self.stock_healthy_threshold_factor and num_opponent_cooperators_prev_round >= self.opponent_cooperation_for_freeride_count_threshold:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_512(BaseStrategy):
    """
    Ruthless Opportunist strategy for the Common Pool Resource Game.

    This strategy aims to maximize its own total payoff by aggressively free-riding on others' cooperation,
    resorting to defection when the resource is threatened by widespread defection, and only cooperating
    strategically when it serves a clear long-term benefit for its own exploitation. It adapts to observed
    opponent behavior and the current state of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.ALPHA_CRITICAL_STOCK = 0.25
        self.BETA_OTHERS_COOPERATE_TO_SAVE = 0.75
        self.GAMMA_OTHERS_COOPERATE_TO_FREERIDE = 0.75
        self.DELTA_OTHERS_DEFECT_TO_JOIN = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        total_rounds = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        elif current_round == total_rounds - 1:
            return Action.D
        else:
            stock_ratio = current_stock / capacity
            previous_round_actions_others = history.opponent_actions[current_round - 1, :]
            num_others_cooperated_last_round = np.sum(previous_round_actions_others)
            num_others_defected_last_round = n_players - 1 - num_others_cooperated_last_round
            if stock_ratio < self.ALPHA_CRITICAL_STOCK:
                if num_others_cooperated_last_round >= (n_players - 1) * self.BETA_OTHERS_COOPERATE_TO_SAVE:
                    return Action.C
                else:
                    return Action.D
            elif num_others_cooperated_last_round >= (n_players - 1) * self.GAMMA_OTHERS_COOPERATE_TO_FREERIDE:
                return Action.D
            elif num_others_defected_last_round >= (n_players - 1) * self.DELTA_OTHERS_DEFECT_TO_JOIN:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_300(BaseStrategy):
    """
    Adaptive Collective Steward Strategy for the Common Pool Resource game.
    This strategy aims to foster cooperation, protect the common resource,
    and retaliate defensively against exploitation, with a built-in mechanism
    to try and re-establish cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self.K_D_TOLERANCE = math.floor(self.n / 2)
        self.S_CRITICAL = self.capacity / 4.0
        self.S_RECOVERY = self.capacity / 2.0
        self.PERSISTENT_DEFECTION_THRESHOLD = 3
        self.SUSTAINED_RETALIATION_TIMEOUT = 5
        self.my_defection_streak = 0
        self.is_in_sustained_retaliation_mode = False
        self.rounds_in_sustained_retaliation = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        num_defectors_last_round = 0
        if state.round_number > 0:
            prev_round_idx = state.round_number - 1
            num_defectors_last_round = np.sum(~history.opponent_actions[prev_round_idx, :])
        if current_round_1_indexed == self.r:
            self.my_defection_streak = 0
            self.is_in_sustained_retaliation_mode = False
            self.rounds_in_sustained_retaliation = 0
            return Action.D
        if self.is_in_sustained_retaliation_mode:
            self.rounds_in_sustained_retaliation += 1
            if state.current_stock >= self.S_RECOVERY * 1.25 or self.rounds_in_sustained_retaliation > self.SUSTAINED_RETALIATION_TIMEOUT:
                self.is_in_sustained_retaliation_mode = False
                self.rounds_in_sustained_retaliation = 0
                self.my_defection_streak = 0
                return Action.C
            else:
                return Action.D
        if state.round_number == 0:
            self.my_defection_streak = 0
            return Action.C
        if state.current_stock < self.S_CRITICAL:
            if num_defectors_last_round > self.K_D_TOLERANCE:
                self.my_defection_streak += 1
                if self.my_defection_streak >= self.PERSISTENT_DEFECTION_THRESHOLD:
                    self.is_in_sustained_retaliation_mode = True
                return Action.D
            else:
                self.my_defection_streak = 0
                return Action.C
        if num_defectors_last_round == 0:
            self.my_defection_streak = 0
            return Action.C
        elif num_defectors_last_round <= self.K_D_TOLERANCE:
            if state.current_stock >= self.S_RECOVERY:
                self.my_defection_streak = 0
                return Action.C
            else:
                self.my_defection_streak += 1
                if self.my_defection_streak >= self.PERSISTENT_DEFECTION_THRESHOLD:
                    self.is_in_sustained_retaliation_mode = True
                return Action.D
        else:
            self.my_defection_streak += 1
            if self.my_defection_streak >= self.PERSISTENT_DEFECTION_THRESHOLD:
                self.is_in_sustained_retaliation_mode = True
            return Action.D

class Strategy_COLLECTIVE_496(BaseStrategy):
    """
    The Adaptive Reciprocal Stock Manager (ARSM) strategy for the Common Pool Resource Game.

    ARSM prioritizes long-term resource sustainability through generalized reciprocity.
    It cooperates by default, but defects when the collective observed outcome of the
    previous round indicates unsustainable over-consumption (stock level significantly
    lower than if all had cooperated). It is forgiving, returning to cooperation
    when collective behavior improves, but firm in punishing persistent over-consumption.
    It adapts its responsiveness based on the current stock level, becoming more cautious
    when the resource is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = float(game_description.capacity)
        self._history_S_start_of_round: list[float] = []
        self._history_my_action: list[Action] = []
        self.epsilon_stock_deviation = 0.01 * self.capacity
        self.low_stock_danger_threshold = 0.2 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round_1_indexed = state.round_number + 1
        n = self.n_players
        r = self.n_rounds
        capacity = self.capacity
        current_stock = state.current_stock
        self._history_S_start_of_round.append(current_stock)
        if current_round_1_indexed == r:
            my_action = Action.D
            self._history_my_action.append(my_action)
            return my_action
        if current_round_1_indexed == 1:
            my_action = Action.C
            self._history_my_action.append(my_action)
            return my_action
        S_prev = self._history_S_start_of_round[state.round_number - 1]
        S_prev_after_C_consumption = S_prev / 2.0
        growth_if_all_C = 2.0 * S_prev_after_C_consumption * (1.0 - S_prev_after_C_consumption / capacity)
        expected_S_current_if_all_C = min(S_prev_after_C_consumption + growth_if_all_C, capacity)
        collective_over_consumed_prev_round = current_stock < expected_S_current_if_all_C - self.epsilon_stock_deviation
        my_action = Action.C
        if current_stock < self.low_stock_danger_threshold:
            if collective_over_consumed_prev_round:
                my_action = Action.D
        elif collective_over_consumed_prev_round:
            my_action = Action.D
        self._history_my_action.append(my_action)
        return my_action

class Strategy_COLLECTIVE_511(BaseStrategy):
    """
    The Adaptive Resource Manager (ARM) strategy prioritizes long-term resource sustainability through
    cooperation but reacts defensively and signals distress when the resource is threatened.
    It adapts decisions based on the current health and trend of the common stock.

    Core principles:
    1. Initial Cooperation: Start with a cooperative stance.
    2. Resource-Dependent Adaptation: Base decisions on current stock health and trend.
    3. Reward Collective Sustainability: Cooperate when the resource is healthy or recovering.
    4. Deter Collective Overconsumption: Defect when the resource is declining or critically low.
    5. Endgame Rationality: Act in immediate self-interest in the final round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.COOPERATION_THRESHOLD_HIGH = 0.95
        self.CRITICAL_STOCK_THRESHOLD = 0.5
        self.last_round_start_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        total_rounds = self.game_description.n_rounds
        current_stock_this_round = state.current_stock
        capacity = self.game_description.capacity
        action = Action.C
        if current_round == 0:
            action = Action.C
        elif current_round == total_rounds - 1:
            action = Action.D
        elif current_stock_this_round >= self.COOPERATION_THRESHOLD_HIGH * capacity:
            action = Action.C
        elif current_stock_this_round < self.CRITICAL_STOCK_THRESHOLD * capacity:
            action = Action.D
        elif self.last_round_start_stock is not None and current_stock_this_round > self.last_round_start_stock:
            action = Action.C
        else:
            action = Action.D
        self.last_round_start_stock = current_stock_this_round
        return action

class Strategy_EXPLOITATIVE_384(BaseStrategy):
    """
    The Adaptive Exploiter strategy maximizes its own total payoff by primarily defecting,
    while adaptively responding to the common resource state and other players' actions
    to prevent complete resource collapse that would harm long-term profit.
    It defects in the first and last rounds, and defaults to defection in intermediate
    rounds unless the stock is critically low (then it cooperates) or if other
    players are defecting heavily (then it also defects to avoid being a "sucker").
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.critical_stock_ratio: float = 0.1
        self.defection_tolerance_threshold: float = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == r - 1:
            return Action.D
        if current_round == 0:
            return Action.D
        previous_round_opponent_actions = history.opponent_actions[-1]
        num_other_players = n - 1
        num_other_cooperators_prev = np.sum(previous_round_opponent_actions)
        num_other_defectors_prev = num_other_players - num_other_cooperators_prev
        defection_rate_others = num_other_defectors_prev / num_other_players
        if current_stock < capacity * self.critical_stock_ratio:
            return Action.C
        elif defection_rate_others > self.defection_tolerance_threshold:
            return Action.D
        else:
            return Action.D
