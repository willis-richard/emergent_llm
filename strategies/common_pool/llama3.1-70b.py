"""
Generated LLM strategies for social dilemma games.

This file contains strategy classes generated by LLMs for game theory experiments.
Each strategy is a callable class that implements a specific approach to the game.

Generated with:
- Provider: Client
- Model: llama3.1:70b
- Game: common_pool
"""

from dataclasses import dataclass
from enum import Enum
import math
import numpy as np
from numpy.typing import NDArray
import random

from emergent_llm.players import BaseStrategy
from emergent_llm.games import PublicGoodsDescription, CollectiveRiskDescription, CommonPoolDescription, CommonPoolState
from emergent_llm.common import Action, C, D, PlayerHistory, GameState




class Strategy_COLLECTIVE_1(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Threshold (ACST) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.5
        self.target_payoff = 20
        self.delta_threshold = 0.01
        self.epsilon = 0.05

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock_fraction = state.current_stock / self.game_description.capacity
        if history is not None and len(history.my_payoffs) > 1:
            average_payoff = np.mean(history.my_payoffs[-2:])
            if average_payoff > self.target_payoff:
                self.threshold += self.delta_threshold
            elif average_payoff < self.target_payoff and self.threshold - self.delta_threshold >= 0:
                self.threshold -= self.delta_threshold
        if state.current_stock < self.epsilon * self.game_description.capacity:
            return Action.D
        if current_stock_fraction >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_2(BaseStrategy):
    """
    A hybrid approach combining elements of tit-for-tat (TFT), grim trigger, and a capacity-aware consumption adjustment mechanism.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.my_actions) == 0):
            return Action.C
        prev_coop_count = sum((1 for action in history.opponent_actions[-1, :] if action))
        coop_threshold = 0.75 * self.game_description.n_players
        stock_ratio = state.current_stock / self.game_description.capacity
        last_round = state.round_number == self.game_description.n_rounds - 1
        if prev_coop_count >= coop_threshold or last_round:
            return Action.C
        elif stock_ratio < 0.5:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_3(BaseStrategy):
    """
    Collective strategy that balances individual payoffs with long-term sustainability of the common pool resource.
    Adapts to changing stock levels and opponent behaviors while maintaining a robust, cooperative approach.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        CT = self.game_description.capacity / (2 * self.game_description.n_players) * (state.current_stock / self.game_description.capacity)
        if state.current_stock > CT:
            cooperation_choice = Action.C
        else:
            cooperation_choice = Action.D
        opponent_cooperation_rate = sum(history.opponent_actions[-1, :]) / self.game_description.n_players
        if opponent_cooperation_rate >= 0.5:
            return cooperation_choice
        elif opponent_cooperation_rate < 0.5 and cooperation_choice == Action.C:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return cooperation_choice

class Strategy_COLLECTIVE_4(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Conservation (ASC)

    The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    It prioritizes cooperation when the stock is healthy and gradually shifts towards defection as the stock depletes.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_high = 0.75 * game_description.capacity
        self.threshold_low = 0.25 * game_description.capacity
        self.k = min(game_description.n_rounds // 4, 5)
        self.history_consumption = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if len(self.history_consumption) >= self.k:
            avg_consumption = sum(self.history_consumption[-self.k:]) / self.k
            if avg_consumption > 0.5 * self.game_description.capacity:
                self.threshold_high *= 1.1
            elif avg_consumption < 0.25 * self.game_description.capacity:
                self.threshold_low *= 0.9
        if state.current_stock >= self.threshold_high:
            return Action.C
        elif state.current_stock < self.threshold_low:
            return Action.D
        else:
            p = (state.current_stock - self.threshold_low) / (self.threshold_high - self.threshold_low)
            return Action.C if random.random() < p else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if history is not None:
            total_consumption = np.sum(history.opponent_actions[-1, :] * (state.current_stock / self.game_description.n_players)) + state.current_stock / self.game_description.n_players
            self.history_consumption.append(total_consumption)
        return Action.C

class Strategy_COLLECTIVE_5(BaseStrategy):
    """
    Adaptive Cooperation Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_scores = np.zeros(game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        tau = (state.current_stock / self.game_description.capacity) ** 2
        for i, action in enumerate(history.opponent_actions[-1]):
            if action:
                self.cooperation_scores[i] += 1
            else:
                self.cooperation_scores[i] -= 1
        avg_cooperation_score = np.mean(self.cooperation_scores)
        your_last_action = history.my_actions[-1]
        if state.current_stock < 0.2 * self.game_description.capacity:
            return Action.D
        if state.current_stock > tau * self.game_description.capacity and self.cooperation_scores[0] >= avg_cooperation_score:
            return Action.C
        if state.current_stock <= tau * self.game_description.capacity or self.cooperation_scores[0] < avg_cooperation_score or (not your_last_action and self.cooperation_scores[0] < 0):
            return Action.D
        if state.round_number == self.game_description.n_rounds:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_6(BaseStrategy):
    """
    Adaptive Cooperation with Stock-based Trigger (ACST) strategy.
    
    This strategy prioritizes cooperation when the stock level is high, 
    encouraging others to do the same and promoting sustainability. As 
    the game progresses, it adapts to changing opponent behaviors by 
    monitoring average payoffs and switching between cooperation and 
    defection accordingly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.avg_payoff_history = []

    def calculate_avg_payoff(self, history: PlayerHistory) -> float:
        if not history.my_payoffs.size:
            return 0.0
        avg_payoff = np.mean(history.my_payoffs[-3:]) if len(history.my_payoffs) >= 3 else np.mean(history.my_payoffs)
        self.avg_payoff_history.append(avg_payoff)
        return avg_payoff

    def avg_payoff_decreasing(self, current_avg_payoff: float) -> bool:
        if len(self.avg_payoff_history) < 2:
            return False
        return current_avg_payoff < self.avg_payoff_history[-2]

    def switch_behavior(self) -> Action:
        return Action.C if len([avg for avg in self.avg_payoff_history if avg != 0]) % 2 == 1 else Action.D

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        elif state.current_stock <= 0.25 * self.game_description.capacity:
            return Action.D
        avg_payoff = self.calculate_avg_payoff(history)
        if self.avg_payoff_decreasing(avg_payoff):
            return self.switch_behavior()
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_7(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy for Common Pool Resource Game.
    
    Balances individual payoffs with collective conservation of the common pool resource.
    Cooperates when average payoff is high and switches to defection when it drops.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.π_avg_prev = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock >= self.game_description.capacity / 2 else Action.D
        payoffs = np.mean(history.my_payoffs[-1:] + history.opponent_payoffs[-1, :])
        self.π_avg_prev = (self.π_avg_prev + payoffs) / 2 if state.round_number == 1 else (self.π_avg_prev * (state.round_number - 1) + payoffs) / state.round_number
        return Action.C if self.π_avg_prev >= state.current_stock / (2 * self.game_description.n_players) else Action.D

class Strategy_COLLECTIVE_8(BaseStrategy):
    """
    A strategy that adapts to the group's performance and balances individual self-interest with collective well-being.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        t = state.round_number
        stock = state.current_stock
        if state.round_number == 0:
            return random.choices([Action.C, Action.D], weights=[0.8, 0.2])[0]
        prev_avg_payoff = np.mean(history.my_payoffs[-1])
        avg_payoff_threshold = stock / (2 * n)
        if prev_avg_payoff >= avg_payoff_threshold:
            return random.choices([Action.C, Action.D], weights=[0.9, 0.1])[0]
        else:
            return random.choices([Action.C, Action.D], weights=[0.4, 0.6])[0]
        if stock < capacity / 4:
            return Action.D
        if t == self.game_description.n_rounds - 1 or stock < capacity / 10:
            return Action.D

class Strategy_COLLECTIVE_9(BaseStrategy):
    """
    A strategy that adapts to the game's state and history by balancing cooperation with self-interest.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_level = game_description.capacity
        self.average_cooperator_payoff = 0.0
        self.p = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.stock_level > 0.75 * self.game_description.capacity:
            return Action.C
        elif 0.5 * self.game_description.capacity <= self.stock_level <= 0.75 * self.game_description.capacity:
            if history is not None and len(history.opponent_payoffs) > 0:
                opponent_cooperators = np.where(history.opponent_actions[-1, :] == True)[0]
                if len(opponent_cooperators) > 0:
                    self.average_cooperator_payoff = np.mean(history.opponent_payoffs[-1, opponent_cooperators])
                else:
                    self.average_cooperator_payoff = 0.0
            overall_average_payoff = np.mean(np.append(history.my_payoffs, history.opponent_payoffs))
            if self.average_cooperator_payoff > overall_average_payoff and self.p < 1:
                self.p += 0.05
            elif self.p > 0:
                self.p -= 0.05
            return Action.C if random.random() < self.p else Action.D
        elif state.round_number == self.game_description.n_rounds - 1 or self.stock_level < 0.5 * self.game_description.capacity:
            return Action.D

class Strategy_COLLECTIVE_10(BaseStrategy):
    """
    Adaptive Cooperation with Stock Threshold (ACST) strategy for the Common Pool Resource Game.
    
    This strategy initially cooperates, then adapts to opponents' behaviors and stock levels,
    prioritizing cooperation when the stock level is sufficient to sustain it.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / (2 * game_description.n_players)
        self.cooperation_rate = [0.5] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.current_stock <= 0 or state.round_number + 1 >= self.game_description.n_rounds:
            return Action.C
        opponent_cooperation_rates = np.array([min(1, max(0, rate)) for rate in self.cooperation_rate])
        if history is not None and len(history.my_actions) > 0:
            last_round_opponent_actions = history.opponent_actions[-1]
            for opponent, action in enumerate(last_round_opponent_actions):
                if action == True:
                    self.cooperation_rate[opponent] += 0.1
                else:
                    self.cooperation_rate[opponent] -= 0.1
            opponent_cooperation_rates = np.array([min(1, max(0, rate)) for rate in self.cooperation_rate])
        if state.current_stock > self.threshold and all(opponent_cooperation_rates >= 0.5):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_11(BaseStrategy):
    """
    Adaptive Stock Conservation strategy for Common Pool Resource Game.
    Balances individual payoffs with long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        stock_level = state.current_stock / capacity
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions_last_round = history.opponent_actions[-1]
        most_recent_cooperators = sum(opponent_actions_last_round)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif stock_level > 0.75 or stock_level < 0.25:
            return Action.C
        elif most_recent_cooperators >= self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_12(BaseStrategy):
    """
    Adaptive Cooperation with Sustainability Threshold strategy.
    
    This hybrid approach balances individual self-interest with collective sustainability,
    aiming to optimize payoffs while maintaining a healthy stock level in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        T = self.game_description.capacity / 2
        if state.current_stock < T:
            return Action.D
        opponent_actions_last_round = history.opponent_actions[-1]
        coop_count = sum((1 for action in opponent_actions_last_round if action))
        if coop_count >= self.game_description.n_players / 2:
            return Action.C
        else:
            return Action.D
        total_consumption = sum((action * self.game_description.capacity / self.game_description.n_players for action in opponent_actions_last_round))
        if total_consumption > 0.75 * self.game_description.capacity:
            stock_growth = 2 * state.current_stock * (1 - state.current_stock / self.game_description.capacity)
            if stock_growth < 0.25 * self.game_description.capacity:
                return Action.C if random.random() < 0.7 else Action.D
        return Action.D

class Strategy_COLLECTIVE_13(BaseStrategy):
    """
    Adaptive Sustainable Harvesting strategy.
    Balances individual payoffs with collective sustainability in the Common Pool Resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        prev_round_history = history.opponent_actions[-1, :]
        prev_cooperators = sum(prev_round_history)
        if state.current_stock > 0.5 * self.game_description.capacity:
            if prev_cooperators >= self.game_description.n_players / 2:
                return Action.C
            else:
                return Action.D
        elif state.current_stock < 0.5 * self.game_description.capacity:
            prev_defectors = sum((not x for x in prev_round_history))
            if prev_defectors > self.game_description.n_players / 2:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_COLLECTIVE_14(BaseStrategy):
    """
    Adaptive Cooperation (AC) strategy for Common Pool Resource Game.
    
    This strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        prev_opponent_actions = history.opponent_actions[-1]
        prev_total_consumption = self.get_prev_total_consumption(history)
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio > 0.75:
            return Action.C
        elif stock_ratio < 0.25:
            return Action.D
        elif prev_total_consumption <= 0.5 * self.game_description.capacity:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

    def get_prev_total_consumption(self, history: PlayerHistory):
        prev_my_payoff = history.my_payoffs[-1]
        prev_opponent_actions = history.opponent_actions[-1]
        prev_opponent_payoffs = history.opponent_payoffs[-1]
        if self.get_action_from_bool(prev_my_payoff > 0.5 * self.game_description.capacity):
            my_consumption = self.game_description.capacity / (2 * self.game_description.n_players)
        else:
            my_consumption = self.game_description.capacity / self.game_description.n_players
        opponent_consumptions = []
        for i, opponent_action in enumerate(prev_opponent_actions):
            if opponent_action:
                consumption = self.game_description.capacity / (2 * self.game_description.n_players)
            else:
                consumption = self.game_description.capacity / self.game_description.n_players
            opponent_consumptions.append(consumption)
        total_consumption = my_consumption + sum(opponent_consumptions)
        return total_consumption

    def get_action_from_bool(self, is_coop):
        if is_coop:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_15(BaseStrategy):
    """
    A collective strategy that adapts to the stock level and opponents' actions,
    balancing individual self-interest with collective well-being.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        if stock_level >= 0.5:
            return Action.C
        p_defect = 1
        if stock_level >= 0.25:
            p_defect = 0.5
        if stock_level >= 0.75:
            p_defect = 0
        return Action.D if random.random() < p_defect else Action.C

class Strategy_COLLECTIVE_16(BaseStrategy):
    """
    Adaptive Stock Conservation strategy. This strategy aims to balance individual payoffs 
    with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if state.current_stock >= self.game_description.capacity * 0.75:
                return Action.C
            else:
                return Action.D
        last_round_consumption = sum((state.current_stock / (2 * self.game_description.n_players) if action else state.current_stock / self.game_description.n_players for action in [True] + history.opponent_actions[-1, :]))
        if last_round_consumption <= state.current_stock / 2:
            return Action.C
        elif state.current_stock < self.game_description.capacity / 4:
            return Action.C
        else:
            p = (self.game_description.capacity - state.current_stock) / self.game_description.capacity
            return Action.D if random.random() < p else Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock >= self.game_description.capacity / 2:
                return Action.C
            else:
                return Action.D
        elif state.current_stock < self.game_description.capacity / 4 and self.game_description.n_rounds - state.round_number <= 2:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_17(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Aware Threshold (ACSAT) strategy.
    
    This strategy adapts to the current stock level and cooperates when the stock ratio is above a certain threshold, 
    which decreases as the number of rounds increases. It defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        threshold = 0.5 + (1 - stock_ratio) / (2 * self.game_description.n_players)
        if state.round_number < self.game_description.n_rounds - 1:
            if stock_ratio >= threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_18(BaseStrategy):
    """
    Adaptive Stock Conservation strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.stock_threshold_high = 0.75 * self.capacity
        self.stock_threshold_low = 0.5 * self.capacity
        self.consumption_threshold = 0.5 * self.capacity
        self.cooperation_likelihood = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < 0.25 * self.capacity:
            return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        cooperators = sum(opponent_actions)
        num_opponents = len(opponent_actions)
        opponent_cooperation_rate = cooperators / num_opponents
        if opponent_cooperation_rate > 0.5:
            self.cooperation_likelihood += 0.1
            self.cooperation_likelihood = min(self.cooperation_likelihood, 1)
        elif opponent_cooperation_rate < 0.5:
            self.cooperation_likelihood -= 0.1
            self.cooperation_likelihood = max(self.cooperation_likelihood, 0)
        if state.current_stock > self.stock_threshold_high:
            return Action.D
        prev_consumption = sum((history.my_payoffs[-1] if history.my_actions[-1] else 2 * (self.capacity / (2 * self.game_description.n_players)) for _ in range(self.game_description.n_players)))
        if prev_consumption < self.consumption_threshold and state.current_stock >= self.stock_threshold_low:
            return Action.C
        return Action.C if random.random() < self.cooperation_likelihood else Action.D

class Strategy_COLLECTIVE_19(BaseStrategy):
    """
    Adaptive Collective Sustainability strategy for the Common Pool Resource Game.
    
    This hybrid approach combines elements of Tit-for-Tat with dynamic adjustments 
    based on the game's state and history to promote collective sustainability while 
    balancing individual self-interest.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = np.any(history.opponent_actions[-1, :]) if len(np.shape(history.opponent_actions)) > 1 else history.opponent_actions[-1]
        tft_response = Action.D if not opponent_actions else Action.C
        growth_rate = 2 * (state.current_stock / self.game_description.capacity) * (1 - state.current_stock / self.game_description.capacity)
        if state.current_stock < 0.5 * self.game_description.capacity or growth_rate < 0:
            return Action.D
        elif state.current_stock > 0.8 * self.game_description.capacity and growth_rate > 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return tft_response

class Strategy_COLLECTIVE_20(BaseStrategy):
    """
    A dynamic, collective strategy that balances individual self-interest with long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        conservation_threshold = 0.7 * self.game_description.capacity
        alarm_threshold = 0.3 * self.game_description.capacity
        if state.current_stock > conservation_threshold:
            return Action.C
        elif state.current_stock < alarm_threshold:
            return Action.D
        else:
            p_C = (state.current_stock - alarm_threshold) / (conservation_threshold - alarm_threshold)
            if random.random() < p_C:
                return Action.C
            else:
                return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        num_defectors = sum((1 for action in opponent_actions if not action))
        if num_defectors > self.game_description.n_players / 2:
            if state.current_stock > conservation_threshold:
                return Action.C
            else:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if len(history.my_actions) > 0 and history.current_stock == state.current_stock:
            if history.my_actions[-1]:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_21(BaseStrategy):
    """
    The Adaptive Stock Preservation (ASP) strategy balances individual self-interest 
    with collective responsibility, promoting cooperation when the common pool resource 
    is abundant and adapting to changing game conditions to ensure long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.5 * game_description.capacity
        self.payoff_threshold = 0.75 * (game_description.capacity / (2 * game_description.n_players))
        self.trend_window_size = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock >= 0.75 * self.game_description.capacity else Action.D
        avg_payoff_prev_round = np.mean(history.my_payoffs[-1:])
        trend = self.calculate_trend(avg_payoff_prev_round, history)
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C if state.current_stock >= 0.25 * self.game_description.capacity else Action.D
        if state.current_stock >= self.stock_threshold and avg_payoff_prev_round >= self.payoff_threshold:
            return Action.C
        elif state.current_stock < 0.25 * self.game_description.capacity or avg_payoff_prev_round < 0.5 * (self.game_description.capacity / (2 * self.game_description.n_players)):
            return Action.D
        if trend == 'increasing' and state.current_stock >= self.stock_threshold:
            return Action.C
        elif trend in ['decreasing', 'stable'] and state.current_stock < self.stock_threshold:
            return Action.D
        return Action.D

    def calculate_trend(self, avg_payoff_prev_round: float, history: PlayerHistory) -> str:
        """
        Calculate the trend of average payoffs over the last few rounds.
        
        Args:
        - avg_payoff_prev_round (float): The average payoff in the previous round.
        - history (PlayerHistory): The game history.

        Returns:
        - 'increasing' if the trend is increasing, 'decreasing' if decreasing, and 'stable' otherwise.
        """
        window_size = min(self.trend_window_size, len(history.my_payoffs))
        avg_payoffs_window = np.mean(history.my_payoffs[-window_size:])
        return 'increasing' if avg_payoff_prev_round > avg_payoffs_window else 'decreasing' if avg_payoff_prev_round < avg_payoffs_window else 'stable'

class Strategy_COLLECTIVE_22(BaseStrategy):
    """
    The Adaptive Stock Conservation (ASC) strategy balances individual payoff maximization with stock conservation.
    It adapts to changes in the game state and opponent behaviors, promoting cooperation while ensuring long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_opponent_cooperation_rate = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_level = state.current_stock
        capacity = self.game_description.capacity
        tau = 0.5 * (stock_level / capacity) + 0.25 * self.average_opponent_cooperation_rate
        if history is not None:
            opponent_actions = history.opponent_actions[-1, :]
            cooperators = sum(opponent_actions)
            self.average_opponent_cooperation_rate = (self.average_opponent_cooperation_rate * state.round_number + cooperators) / (state.round_number + 1)
        action = Action.C if tau > random.random() else Action.D
        if stock_level < 0.2 * capacity:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return action

class Strategy_COLLECTIVE_23(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy for the Common Pool Resource Game.
    
    This strategy balances individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_streak = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        opponents_defected = sum(previous_round_opponent_actions)
        if opponents_defected > self.game_description.n_players // 2:
            self.defection_streak += 1
        else:
            self.defection_streak = 0
        if stock_ratio > 0.75:
            return Action.C
        elif 0.25 <= stock_ratio <= 0.75:
            defection_probability = self.defection_streak / state.round_number * 0.5
            return Action.D if random.random() < defection_probability else Action.C
        else:
            return Action.C
        if self.defection_streak > 2:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if stock_ratio > 0.5 and self.defection_streak > 0:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_24(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Consideration (ATSC) strategy.

    This strategy adapts to the game state and opponents' behavior, balancing individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        coop_rates = np.mean(history.opponent_actions, axis=1)
        stock_level = state.current_stock / self.game_description.capacity
        if stock_level > 0.75:
            return Action.C
        elif 0.5 <= stock_level <= 0.75:
            most_coop_rate = np.max(coop_rates)
            if most_coop_rate >= 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

        def detect_deviation(opponent_actions):
            if len([action for action in opponent_actions[-2:] if not action]) == 2:
                return True
            return False

class Strategy_COLLECTIVE_25(BaseStrategy):
    """
    Adaptive and robust collective strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = math.floor(game_description.n_players / 2)
        self.stock_alarm_threshold = game_description.capacity / 4
        self.low_stock_threshold = game_description.capacity / 8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.low_stock_threshold:
            return Action.C
        if state.current_stock < self.stock_alarm_threshold:
            return Action.C
        defectors = sum((not x for x in history.opponent_actions[-1, :]))
        defect_prob = defectors / self.game_description.n_players * (state.current_stock / self.game_description.capacity)
        if random.random() < defect_prob:
            action = Action.D
        else:
            action = Action.C
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators >= self.cooperation_threshold:
            action = Action.C
        elif action == Action.D and state.current_stock > self.game_description.capacity / 2:
            self.cooperation_threshold -= 1
        elif action == Action.C and state.current_stock < self.game_description.capacity / 4:
            self.cooperation_threshold += 1
        return action

class Strategy_COLLECTIVE_26(BaseStrategy):
    """
    Adaptive Cooperative Harvesting (ACH) strategy.
    This strategy prioritizes sustainability and cooperation while adapting to changing circumstances.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.num_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_level = state.current_stock
        num_rounds = self.game_description.n_rounds
        round_num = state.round_number + 1
        if len(history.my_actions) > 0:
            opponent_cooperations = np.sum(history.opponent_actions, axis=0)
            opponent_defections = self.num_players - 1 - opponent_cooperations
            most_recent_opponent_actions = history.opponent_actions[-1]
            cooperators_in_last_round = np.sum(most_recent_opponent_actions)
        if len(history.my_payoffs) > 0 and state.current_stock > history.my_payoffs[-1] * 1.2:
            reassess_decision = True
        else:
            reassess_decision = False
        stock_ratio = stock_level / self.capacity
        if round_num == num_rounds:
            return Action.D
        elif stock_ratio >= 0.75 or (reassess_decision and cooperators_in_last_round > self.num_players // 2):
            return Action.C
        elif stock_ratio < 0.5 or cooperators_in_last_round <= self.num_players // 4:
            return Action.D
        else:
            p = stock_ratio ** 2
            if np.random.rand() < p:
                return Action.C
            return Action.D

class Strategy_COLLECTIVE_27(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy.
    
    This strategy balances individual payoffs with long-term sustainability of the common pool resource.
    It adapts to the actions and payoffs of other players, adjusting its thresholds accordingly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.high_threshold = 0.8 * game_description.capacity
        self.low_threshold = 0.5 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_coop_count = sum(history.opponent_actions[-1, :])
        S = state.current_stock
        if S >= self.high_threshold:
            action = Action.C
        elif S < self.low_threshold:
            action = Action.D
        elif prev_coop_count > self.game_description.n_players / 2:
            action = Action.C
        else:
            action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if prev_coop_count < self.game_description.n_players / 2:
            self.high_threshold -= 0.1 * self.game_description.capacity
        elif prev_coop_count > self.game_description.n_players / 2:
            self.low_threshold += 0.1 * self.game_description.capacity
        return action

class Strategy_COLLECTIVE_28(BaseStrategy):
    """
    A strategy that prioritizes cooperation while adapting to the actions of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.my_actions) == 0):
            return Action.C
        total_consumption = sum((self.game_description.n_players if action else self.game_description.n_players // 2 for action in history.opponent_actions[-1, :]))
        S = state.current_stock
        n = self.game_description.n_players
        if self.game_description.capacity < 2 * n:
            return Action.C
        consecutive_defections = all((action == Action.D for action in history.opponent_actions[-1, :]))
        if consecutive_defections and S < self.game_description.capacity / 4:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if S >= self.game_description.capacity / 4:
                return Action.D
            else:
                return Action.C
        if S >= self.game_description.capacity / 2:
            return Action.C
        elif S < self.game_description.capacity / 2 and total_consumption <= S / n:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_29(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Threshold (ACST) strategy.
    
    This strategy prioritizes collective well-being by encouraging cooperation when the stock is high,
    responding adaptively to defections, and fostering a cooperative environment through initial and final-round cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_probability = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        S = state.current_stock
        r_remaining = self.game_description.n_rounds - state.round_number
        n = self.game_description.n_players
        if S >= 0.5 * self.game_description.capacity:
            return Action.C
        D_prev = sum((1 for action in history.opponent_actions[-1, :] if not action))
        if D_prev > 0.25 * n and S < 0.5 * self.game_description.capacity:
            return Action.D
        if history.my_actions[-1] == False and S >= 0.5 * self.game_description.capacity:
            self.defection_probability = min(1.0, self.defection_probability + 0.1)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if S < 0.25 * self.game_description.capacity:
            return Action.D
        if D_prev == n:
            return Action.C
        return Action.C if random.random() > self.defection_probability else Action.D

class Strategy_COLLECTIVE_30(BaseStrategy):
    """
    Adaptive Collective Conservation strategy for Common Pool Resource Game.
    
    This strategy adapts to various opponent behaviors and game states, balancing individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C if state.current_stock >= self.game_description.capacity / 2 else Action.D
        prev_outcome = history.my_actions[-1]
        opponent_actions = history.opponent_actions[-1, :]
        most_cooperated = sum((1 for action in opponent_actions if action)) > self.game_description.n_players / 2
        if state.current_stock < self.game_description.capacity / 2:
            if not most_cooperated:
                return Action.D
            else:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock < self.game_description.capacity / 4:
                return Action.D
            else:
                return Action.C
        if not most_cooperated and state.current_stock >= self.game_description.capacity / 2:
            return Action.C if state.round_number % 2 == 0 else Action.D
        return Action.C if most_cooperated and (state.current_stock >= self.game_description.capacity / 2 or math.isclose(state.current_stock, history.current_stock[-1])) else Action.D

class Strategy_COLLECTIVE_31(BaseStrategy):
    """
    A strategy that prioritizes stock conservation while adapting to opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / 2
        self.min_threshold = game_description.capacity / 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_actions = history.opponent_actions[-1, :]
        num_cooperators = sum(opponents_actions)
        if num_cooperators > self.game_description.n_players / 2:
            self.threshold += 0.1 * self.game_description.capacity
        elif num_cooperators < self.game_description.n_players / 2:
            self.threshold -= 0.1 * self.game_description.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.min_threshold and state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        all_defectors = all((not opponent for opponent in history.opponent_actions.flatten()))
        if all_defectors and state.current_stock > self.threshold:
            return Action.C
        if state.current_stock > self.threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_32(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_number = 0
        self.stock_threshold_high = 0.75 * game_description.capacity
        self.stock_threshold_low = 0.25 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.round_number = state.round_number
        avg_payoff = np.mean(history.my_payoffs)
        if avg_payoff < 0.5 * self.game_description.capacity / self.game_description.n_players or self.round_number > 2 * self.game_description.n_players:
            self.stock_threshold_high = self.stock_threshold_low
        current_stock = state.current_stock
        if current_stock > self.stock_threshold_high:
            return Action.D
        elif current_stock >= self.stock_threshold_low and current_stock <= self.stock_threshold_high:
            return Action.C
        if self.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_33(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Threshold (ACST) strategy.

    This strategy promotes cooperation while adapting to opponents' behaviors.
    It uses a dynamic threshold based on the current stock level and capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        tau = state.current_stock / self.game_description.capacity
        D_prev = sum((1 for action in history.opponent_actions[-1, :] if not action))
        if D_prev <= self.game_description.n_players * tau:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_35(BaseStrategy):
    """
    The Adaptive Cooperativeness strategy is designed to balance individual self-interest with collective sustainability in the Common Pool Resource game.
    It adapts to the game's state and history, aiming to maintain a healthy stock level while being robust against various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_deviation = (self.game_description.capacity - state.current_stock) / self.game_description.capacity
        opponent_majority_defected = sum(history.opponent_actions[-1, :]) < self.game_description.n_players // 2
        if history.my_payoffs.shape[0] >= 3:
            avg_payoff_opponent_i = np.mean(history.opponent_payoffs[-3:, :], axis=0)
            max_avg_payoff_opponent = np.max(avg_payoff_opponent_i)
            my_last_round_payoff = history.my_payoffs[-1]
            punishment_trigger = max_avg_payoff_opponent > 1.5 * my_last_round_payoff
        else:
            punishment_trigger = False
        last_round = state.round_number == self.game_description.n_rounds - 1
        if stock_deviation < 0.25 or opponent_majority_defected or last_round or (not punishment_trigger):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_36(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Dependent Threshold strategy for Common Pool Resource games.
    
    This strategy promotes collective cooperation while adapting to the current state of the game.
    It calculates a dynamic threshold based on the current stock level and adjusts its behavior accordingly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        theta = 0.5 * (1 - state.current_stock / self.game_description.capacity)
        num_cooperative_opponents = sum(history.opponent_actions[-1, :] == True)
        if num_cooperative_opponents >= theta * self.game_description.n_players or state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_37(BaseStrategy):
    """
    A strategy that balances individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and game history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.cooperation_threshold is None:
            self.cooperation_threshold = state.current_stock / (2 * self.game_description.n_players * (self.game_description.n_rounds - state.round_number))
        if state.current_stock >= self.cooperation_threshold:
            action = Action.C
        else:
            action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.game_description.capacity / (2 * self.game_description.n_players):
            return Action.D
        if history is not None and history.my_payoffs.size > 0:
            old_stock = history.my_payoffs[-1] * (2 * self.game_description.n_players)
            new_stock = state.current_stock
            all_cooperated = np.all(history.opponent_actions[-1, :] == True)
            any_defected = np.any(history.opponent_actions[-1, :] == False)
            if all_cooperated and new_stock >= old_stock:
                self.cooperation_threshold *= 0.9
            elif any_defected and new_stock < old_stock:
                self.cooperation_threshold *= 1.2
        return action

class Strategy_COLLECTIVE_38(BaseStrategy):
    """
    The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the dynamic state and history of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_consumption_previous_round = 0.0
        if history is not None and len(history.my_actions) > 0:
            opponent_defectors = sum((not action for action in history.opponent_actions[-1, :]))
            opponent_cooperators = self.game_description.n_players - 1 - opponent_defectors
            my_consumption = state.current_stock / (2 * self.game_description.n_players) if history.my_actions[-1] else state.current_stock / self.game_description.n_players
            opponent_consumption = opponent_cooperators * state.current_stock / (2 * self.game_description.n_players) + opponent_defectors * state.current_stock / self.game_description.n_players
            total_consumption_previous_round = my_consumption + opponent_consumption
        current_stock_level = state.current_stock
        if current_stock_level >= self.capacity / 2:
            return Action.C
        elif current_stock_level < self.capacity / 2 and total_consumption_previous_round <= self.capacity / 4:
            return random.choice([Action.D, Action.C])
        elif current_stock_level < self.capacity / 2 and total_consumption_previous_round > self.capacity / 4:
            return Action.D
        elif current_stock_level < 0.1 * self.capacity:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_39(BaseStrategy):
    """
    This strategy adapts to the game's state and history, balancing individual payoffs 
    with collective sustainability while being robust against various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_bonus = 0.2
        self.stock_penalty = -0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        threshold = state.current_stock / self.game_description.capacity
        previous_cooperation_rate = np.sum(history.opponent_actions[-1, :]) / self.game_description.n_players
        if previous_cooperation_rate > 0.5:
            base_decision = Action.C
        else:
            base_decision = Action.D
        if state.current_stock > 0.7 * self.game_description.capacity:
            decision = base_decision if random.random() < (1 + self.stock_bonus) / 2 else Action.D
        elif state.current_stock < 0.3 * self.game_description.capacity:
            decision = base_decision if random.random() < (1 + self.stock_penalty) / 2 else Action.C
        else:
            decision = base_decision
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        return decision

class Strategy_COLLECTIVE_40(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with collective sustainability 
    by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock >= self.game_description.capacity / 2 else Action.D
        avg_stock = (state.current_stock + self.prev_stock) / 2 if self.prev_stock is not None else state.current_stock
        cooperator_count = sum(history.opponent_actions[-1, :])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif avg_stock < self.game_description.capacity / 4 or state.current_stock < self.game_description.capacity / 4:
            return Action.D
        elif cooperator_count > 0:
            return Action.C
        else:
            return Action.D
        self.prev_stock = state.current_stock

class Strategy_COLLECTIVE_41(BaseStrategy):
    """
    The Adaptive Sustainability strategy prioritizes cooperation when the sustainability 
    threshold is met, while adapting to opponent behavior. By favoring cooperation when 
    others cooperate, AS promotes a culture of mutual support and collective responsibility 
    for resource management.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        ST = self.game_description.capacity / (2 * self.game_description.n_players * (self.game_description.n_rounds - state.round_number))
        if state.current_stock >= ST:
            OCR = sum(history.opponent_actions[-1, :]) / self.game_description.n_players
            if OCR > 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_42(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation (AC)
    
    This strategy prioritizes cooperation when the stock is sustainable and opponents are cooperative.
    It adapts to opponents' behaviors by punishing defection and reinforcing mutual cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        previous_actions = history.opponent_actions[-1, :]
        if current_stock >= 0.75 * self.capacity:
            return Action.C
        elif np.any(previous_actions == False):
            return Action.D
        elif np.all(previous_actions == True):
            return Action.C
        elif current_stock < 0.25 * self.capacity:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_43(BaseStrategy):
    """
    A collective strategy that balances individual payoff maximization with 
    collective sustainability of the common pool resource. It adapts to various 
    opponent behaviors and promotes cooperation when the stock level is high.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_actions = history.opponent_actions[-1, :]
        stock_level = state.current_stock / self.capacity
        if stock_level >= 0.75:
            most_opponents_cooperated = sum(opponents_actions) / len(opponents_actions) > 0.5
            return Action.C if most_opponents_cooperated else Action.D
        elif stock_level < 0.75 and stock_level >= 0.5:
            half_or_more_opponents_cooperated = sum(opponents_actions) / len(opponents_actions) >= 0.5
            return Action.C if half_or_more_opponents_cooperated else Action.D
        elif stock_level < 0.5:
            for opponent in opponents_actions:
                if not opponent and stock_level < 0.5:
                    return Action.D
        if stock_level < 0.25:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C if stock_level > 0.75 else Action.D
        return Action.D

class Strategy_COLLECTIVE_44(BaseStrategy):
    """
    Adaptive Collective Conservation strategy for the Common Pool Resource Game.
    
    This strategy prioritizes collective conservation and adaptability by cooperating when the stock is high, 
    using a Mirror-Majority rule when it's moderate, and defecting when the stock is low. It also cooperates in 
    the last round to prevent unnecessary harm to the collective.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def mirror_majority(self, history: PlayerHistory) -> Action:
        majority_cooperation = True
        for action in history.opponent_actions[-1, :]:
            if not action:
                majority_cooperation = False
                break
        return Action.C if majority_cooperation else Action.D

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < 0.25 * self.capacity:
            return Action.C
        if state.current_stock > 0.75 * self.capacity:
            return Action.C
        elif 0.5 * self.capacity <= state.current_stock <= 0.75 * self.capacity:
            return self.mirror_majority(history)
        else:
            return Action.D

class Strategy_COLLECTIVE_45(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock-Sensitive Threshold (ACST)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        opponent_defections = sum(~history.opponent_actions[-1, :])
        theta = current_stock / self.capacity * (1 - opponent_defections / self.n_players)
        if theta > 0.5 or current_stock < 2 * self.n_players:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_46(BaseStrategy):
    """
    A collective strategy that prioritizes cooperation while adapting to changing circumstances.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if random.random() < 0.8 else Action.D
        if history is not None and len(history.my_actions) > 0:
            prev_round_opponent_actions = history.opponent_actions[-1, :]
            prev_round_cooperators = sum(prev_round_opponent_actions)
            prev_stock_level = state.current_stock
            capacity = self.game_description.capacity
            if prev_stock_level >= 0.75 * capacity:
                return Action.C
            elif prev_stock_level >= 0.5 * capacity and prev_stock_level < 0.75 * capacity:
                coop_prob = prev_round_cooperators / self.game_description.n_players
                return Action.C if random.random() < coop_prob else Action.D
            else:
                return Action.D
            if prev_stock_level > 0.75 * capacity and any((not action for action in prev_round_opponent_actions)):
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C if state.current_stock >= 0.25 * self.game_description.capacity else Action.D
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.C
        if history is not None and len(history.opponent_actions) > 0 and (sum((1 for action in history.opponent_actions[-1, :] if not action)) >= self.game_description.n_players // 2):
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_47(BaseStrategy):
    """
    Adaptive Cooperation with Stock Conservation (ACSC) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        opponent_defections = sum((not action for action in history.opponent_actions[-1, :]))
        if opponent_defections > 0 and state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        avg_coop_rate = np.mean(history.opponent_actions[-self.game_description.n_rounds // 2:, :].mean(axis=1))
        if avg_coop_rate > 0.5:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C

class Strategy_COLLECTIVE_48(BaseStrategy):
    """
    A dynamic and responsive strategy that balances cooperation with caution.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number < 5:
            prev_round_behavior = history.opponent_actions[-1]
            most_defected = sum(prev_round_behavior) < len(prev_round_behavior) / 2
            return Action.D if most_defected else Action.C
        avg_consumption = self.calculate_avg_consumption(history, state)
        if avg_consumption > 0.75 * self.capacity:
            return Action.D
        current_stock_ratio = state.current_stock / self.capacity
        if current_stock_ratio < 0.25:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_round_behavior = history.opponent_actions[-1]
        most_defected = sum(prev_round_behavior) < len(prev_round_behavior) / 2
        return Action.C if not most_defected and current_stock_ratio > 0.5 else Action.D

    def calculate_avg_consumption(self, history: PlayerHistory, state: CommonPoolState):
        total_consumption = self.get_total_consumption(history, state)
        avg_consumption = total_consumption / (3 * self.n_players)
        return avg_consumption

    def get_total_consumption(self, history: PlayerHistory, state: CommonPoolState):
        last_3_rounds_actions = history.opponent_actions[-3:]
        total_consumption = 0
        for i in range(3):
            round_actions = last_3_rounds_actions[i]
            cooperators = sum(round_actions)
            defectors = len(round_actions) - cooperators
            consumption = cooperators * state.current_stock / (2 * self.n_players) + defectors * state.current_stock / self.n_players
            total_consumption += consumption
        return total_consumption

class Strategy_COLLECTIVE_49(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Threshold (ACST) strategy.

    This strategy promotes a collective mindset by adapting cooperation levels based on the current stock level and history of play.
    It aims to balance individual payoffs with collective sustainability, encouraging cooperation when the stock is healthy and defecting
    when necessary to prevent further depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_stock = 0.6 * game_description.capacity
        self.adjustment_threshold = 0.8 * game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.my_payoffs) > 3:
            avg_payoff = np.mean(history.my_payoffs[-3:])
        else:
            avg_payoff = float('inf')
        action = Action.C if state.current_stock > self.threshold_stock else Action.D
        if avg_payoff < self.adjustment_threshold:
            self.threshold_stock -= 0.05 * self.game_description.capacity
        if state.current_stock < 0.2 * self.game_description.capacity or (history is not None and np.mean(history.my_payoffs[-3:]) < 0):
            action = Action.D
        return action

class Strategy_COLLECTIVE_50(BaseStrategy):
    """
    The Adaptive Stock Conservation (ASC) strategy aims to balance individual payoffs with collective sustainability by adapting to the game's dynamic state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k = 5
        self.delta = 0.05

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio >= 0.75:
            return Action.C
        elif stock_ratio <= 0.25:
            return Action.D
        average_payoff = np.mean(history.my_payoffs[-self.k:])
        threshold = 0.5 * (state.current_stock / self.game_description.n_players)
        p = stock_ratio ** 2
        if average_payoff < threshold and p > 0:
            p = min(1, p + self.delta)
        elif average_payoff >= threshold and p < 1:
            p = max(0, p - self.delta)
        mixed_strategy = random.random()
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C if mixed_strategy < p else Action.D

class Strategy_COLLECTIVE_51(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation (AC)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        avg_coop_payoff_prev_round = np.mean(np.where(history.opponent_actions[-1, :] == True, history.opponent_payoffs[-1, :], 0))
        avg_defect_payoff_prev_round = np.mean(np.where(history.opponent_actions[-1, :] == False, history.opponent_payoffs[-1, :], 0))
        if state.current_stock >= 0.75 * self.capacity:
            return Action.C
        elif 0.5 * self.capacity <= state.current_stock < 0.75 * self.capacity:
            coop_prob = avg_coop_payoff_prev_round / (avg_coop_payoff_prev_round + avg_defect_payoff_prev_round)
            return random.choices([Action.C, Action.D], weights=[coop_prob, 1 - coop_prob])[0]
        else:
            return Action.D

class Strategy_COLLECTIVE_52(BaseStrategy):
    """
    This strategy combines cooperation, defection and exploration to conserve common resources.
    
    It starts with initial round cooperation, adapts stock-based cooperation and defection based on the stock level,
    and incorporates opponent behavior adaptation and exploration for learning.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_defection_probabilities = [0.5] * (game_description.n_players - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        elif state.current_stock <= 0.25 * self.game_description.capacity:
            return Action.D
        for i, opponent_action in enumerate(history.opponent_actions[-1, :]):
            if opponent_action == True:
                self.opponent_defection_probabilities[i] = max(0.01, self.opponent_defection_probabilities[i] - 0.05)
            else:
                self.opponent_defection_probabilities[i] = min(0.99, self.opponent_defection_probabilities[i] + 0.1)
        exploration_randomness = random.random()
        if exploration_randomness < 0.05:
            return Action.C if random.random() > 0.5 else Action.D
        if state.current_stock <= 0.1 * self.game_description.capacity:
            return Action.D
        opponent_defection_probability = np.mean(self.opponent_defection_probabilities)
        return Action.C if random.random() > opponent_defection_probability else Action.D

class Strategy_COLLECTIVE_53(BaseStrategy):
    """
    Implement an adaptive cooperation strategy based on stock-dependent tit-for-tat logic.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = history.opponent_actions.flatten()
        ocr = sum(opponent_actions) / len(opponent_actions)
        capacity_threshold_high = self.game_description.capacity * 0.75
        capacity_threshold_low = self.game_description.capacity * 0.25
        if state.current_stock > capacity_threshold_high:
            return Action.C if ocr >= 0.5 else Action.D
        elif state.current_stock < capacity_threshold_low:
            return Action.D
        else:
            return Action.C if ocr >= 0.5 else random.choice([Action.C, Action.D])

class Strategy_COLLECTIVE_54(BaseStrategy):
    """
    Adaptive Stock Conservation strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.tau = game_description.capacity / (2 * game_description.n_players)
        self.last_majority_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number <= 1:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.tau:
            return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        majority_action = np.mean(opponent_actions) >= 0.5
        if majority_action is None or math.isnan(majority_action):
            majority_action = self.last_majority_action if self.last_majority_action else True
        self.last_majority_action = majority_action
        return Action.C if majority_action else Action.D

class Strategy_COLLECTIVE_55(BaseStrategy):
    """
    Adaptive Cooperation with Stock Awareness (ACSA) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_defect_rates = [0.0] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = history.opponent_actions[:-1].sum(axis=0)
        self.opponent_defect_rates = opponent_actions / (state.round_number - 1)
        stock_level = state.current_stock
        capacity = self.game_description.capacity
        if stock_level >= 0.75 * capacity:
            return Action.C
        elif 0.5 * capacity <= stock_level < 0.75 * capacity:
            defect_prob = 0.5 + (self.opponent_defect_rates.max() - 0.5) / 2
            if random.random() < defect_prob:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_56(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy for Common Pool Resource games.
    
    This strategy balances individual self-interest with collective stock conservation,
    adapting to opponents' behaviors and game state dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_defected = sum((not action for action in history.opponent_actions[-1, :]))
        estimated_proportion_defectors = opponents_defected / (self.game_description.n_players - 1)
        SBT = 0.75 * (state.current_stock / self.game_description.capacity)
        if estimated_proportion_defectors < 0.3 and state.current_stock > SBT:
            return Action.C
        elif estimated_proportion_defectors >= 0.5 or state.current_stock <= SBT:
            return Action.D
        elif opponents_defected > 0 and state.current_stock > SBT:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_57(BaseStrategy):
    """
    Adaptive Cooperative Harvesting (ACH) strategy prioritizes cooperation while adapting to the dynamic state of the game and the behaviors of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.high_threshold = 0.8 * game_description.capacity
        self.low_threshold = 0.2 * game_description.capacity
        self.p_coop = 0.5
        self.prev_avg_payoff = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock > self.high_threshold:
            return Action.C
        elif state.current_stock < self.low_threshold:
            return Action.D
        avg_payoff = np.mean(history.my_payoffs)
        smoothed_avg_payoff = (avg_payoff + self.prev_avg_payoff) / 2
        if smoothed_avg_payoff > self.prev_avg_payoff:
            self.p_coop += 0.1
        else:
            self.p_coop -= 0.1
        self.prev_avg_payoff = smoothed_avg_payoff
        recent_defections = np.count_nonzero(~history.my_actions[-5:])
        if recent_defections > 0:
            p_defect = 0.2
        else:
            p_defect = 0
        opponent_cooperation_rates = np.mean(history.opponent_actions, axis=0)
        cooperation_bias = np.mean(opponent_cooperation_rates)
        if random.random() < self.p_coop + cooperation_bias:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_58(BaseStrategy):
    """
    Adaptive Stock Conservation Strategy.

    Balances individual payoffs with collective stock conservation,
    adapting to the game's dynamic state and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        low_threshold = capacity / 4
        high_threshold = 3 * capacity / 4
        defectors_last_round = sum(1 - history.opponent_actions[-1, :])
        if defectors_last_round > n_players // 2:
            p_coop_adjustment = -0.2
        else:
            p_coop_adjustment = 0
        if current_stock > high_threshold:
            return Action.C
        elif low_threshold <= current_stock <= high_threshold:
            p_coop = (current_stock - low_threshold) / (high_threshold - low_threshold)
            p_coop += p_coop_adjustment
            if random.random() < p_coop:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_59(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Conservation (ASC)
    
    This strategy balances individual payoffs with collective stock conservation.
    It adapts to opponents' behaviors and adjusts its actions based on the current state of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_total_consumption = sum((history.my_payoffs[-1] if action else history.my_payoffs[-1] * 2 for action in [True] + history.opponent_actions[-1, :].tolist()))
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        if last_total_consumption >= 0.75 * self.game_description.capacity:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_60(BaseStrategy):
    """
    The Adaptive Stock Sustainer strategy balances individual payoffs with long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def calculate_odr(self, opponent_history) -> float:
        """Calculate the average opponent defection rate (ODR)."""
        if opponent_history is None or len(opponent_history.opponent_actions) == 0:
            return 0.5
        total_defections = np.sum(~opponent_history.opponent_actions)
        odr = total_defections / (len(opponent_history.opponent_actions) * self.game_description.n_players - 1)
        return odr

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_history = history or PlayerHistory([], [], np.zeros((state.round_number, self.game_description.n_players - 1), dtype=bool), np.zeros((state.round_number, self.game_description.n_players - 1)))
        odr = self.calculate_odr(opponent_history)
        if state.current_stock < self.game_description.capacity / 2:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1 and state.current_stock >= state.current_stock / (self.game_description.n_players * 2):
            return Action.D
        p_defect = (odr - 0.5) / 0.5 if odr > 0.5 else 0
        if random.random() < p_defect:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_61(BaseStrategy):
    """
    Adaptive Stock Sensitive Tit-for-Tat with Threshold Strategy.
    
    This strategy balances individual payoff maximization with collective sustainability 
    by adapting to the game's dynamic state and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_number = 0
        self.current_stock = game_description.capacity
        self.cooperators = 0
        self.defectors = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.round_number += 1
        self.current_stock = state.current_stock
        sst = 0.5 * (self.game_description.capacity - self.current_stock)
        if self.current_stock < sst:
            return Action.D
        if history is not None:
            self.cooperators, self.defectors = (np.sum(history.opponent_actions[-1] == True), np.sum(history.opponent_actions[-1] == False))
        if self.defectors > self.game_description.n_players / 2:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_62(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock-based Threshold (ACST)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.threshold = 0.7 * self.capacity
        self.last_stock_growth_positive = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if self.last_stock_growth_positive is not None:
            if self.last_stock_growth_positive:
                self.threshold += 0.05 * self.capacity
            else:
                self.threshold -= 0.05 * self.capacity
        if current_stock >= self.threshold or current_stock < 0.2 * self.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_63(BaseStrategy):
    """
    The Adaptive Sustainability (AS) strategy aims to balance immediate gains with long-term sustainability by adapting to both 
    the current state of the stock and the observed behavior of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        else:
            stock_ratio = state.current_stock / self.game_description.capacity
            opponent_actions = history.opponent_actions[-1, :]
            num_cooperators = sum(opponent_actions)
            if stock_ratio >= 0.75:
                return Action.C if num_cooperators > self.game_description.n_players // 2 else Action.D
            elif 0.5 <= stock_ratio < 0.75:
                if num_cooperators == self.game_description.n_players - 1 - num_cooperators:
                    return Action.C if history.my_actions[-1] else Action.D
                elif num_cooperators > (self.game_description.n_players - 1) // 2:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
            if state.round_number >= self.game_description.n_rounds - 1:
                if state.current_stock > 0.25 * self.game_description.capacity and state.round_number == self.game_description.n_rounds - 2:
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_64(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Trigger strategy for the Common Pool Resource Game.
    
    This strategy aims to balance individual payoff maximization with collective sustainability by 
    adaptively adjusting cooperation levels based on the current stock level and past opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.75 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 1:
            return Action.D
        opponent_actions = history.opponent_actions[:-1, :] if history else np.empty((0, self.game_description.n_players - 1))
        avg_opponent_coop = np.mean(opponent_actions) if opponent_actions.size > 0 else 0.5
        if avg_opponent_coop > 0.5:
            self.stock_threshold *= 1 + avg_opponent_coop
        else:
            self.stock_threshold *= 1 - avg_opponent_coop
        if state.current_stock >= self.stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_66(BaseStrategy):
    """
    A strategy that balances individual self-interest with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        round_number = state.round_number
        if current_stock >= 0.75 * capacity:
            return Action.C
        elif current_stock >= 0.5 * capacity and current_stock < 0.75 * capacity:
            p = (current_stock / capacity) ** 0.5
            if random.random() < p:
                return Action.C
            else:
                return Action.D
        elif current_stock < 0.25 * capacity or (current_stock < 0.5 * capacity and round_number != total_rounds - 1):
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_67(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy.
    
    This strategy balances individual payoff maximization with collective sustainability,
    adapting to the dynamic state and history of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        if history is not None and len(history.opponent_actions) > 0:
            previous_cooperators = sum((1 for action in history.opponent_actions[-1, :] if action))
            if previous_cooperators >= self.game_description.n_players // 2:
                return Action.C
            if not all(history.opponent_actions[-1, :]):
                return Action.D
        if state.current_stock > 0.5 * self.game_description.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_68(BaseStrategy):
    """
    Adaptive Collective Conservation strategy for the Common Pool Resource Game.
    This strategy adapts to various opponent behaviors and aligns with a collective mindset.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.stock_threshold = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock > self.stock_threshold * self.capacity:
            return Action.C
        if history is not None and len(history.my_actions) > 0:
            total_consumption_prev = sum(history.opponent_payoffs[-1, :]) + history.my_payoffs[-1]
            if total_consumption_prev > 0.5 * self.capacity:
                return Action.D
        if history is not None and len(history.my_actions) >= 3:
            cooperation_rate = sum(history.opponent_actions[-3:, :].mean(axis=1)) / self.game_description.n_players
            if cooperation_rate >= 2 / 3:
                return Action.C
        if state.round_number % 5 == 0 and history is not None and (len(history.my_payoffs) > 4):
            avg_stock_level = np.mean(state.current_stock - history.my_payoffs[-5:])
            if avg_stock_level < 0.5 * self.capacity:
                self.stock_threshold = 0.5
            else:
                self.stock_threshold = 0.75
        if state.current_stock < 0.25 * self.capacity:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_69(BaseStrategy):
    """
    The Adaptive Stock Conservation (ASC) strategy aims to balance individual payoffs with collective sustainability by adaptively responding to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.my_payoff_history = []
        self.median_historical_payoff = 0

    def calculate_average_payoff(self, history: PlayerHistory) -> float:
        return np.mean(history.my_payoffs)

    def calculate_median_payoff(self, history: PlayerHistory) -> float:
        if len(self.my_payoff_history) == 0:
            return self.median_historical_payoff
        else:
            return np.median(np.append(self.my_payoff_history, history.my_payoffs[-1]))

    def count_cooperators(self, history: PlayerHistory) -> int:
        opponent_actions = history.opponent_actions[-1, :]
        cooperators = sum(opponent_actions)
        return cooperators

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if state.current_stock >= 0.75 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        avg_payoff_prev = self.calculate_average_payoff(history)
        median_historical_payoff = self.calculate_median_payoff(history)
        if state.current_stock > 0.5 * self.game_description.capacity:
            if avg_payoff_prev < median_historical_payoff:
                return Action.C
            else:
                return Action.D
        elif 0.25 * self.game_description.capacity <= state.current_stock <= 0.5 * self.game_description.capacity:
            cooperators_prev = self.count_cooperators(history)
            if cooperators_prev >= self.game_description.n_players / 2:
                return Action.C
            else:
                return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock <= 0:
            return Action.D
        else:
            return Action.D

    def update_payoff_history(self, history: PlayerHistory):
        self.my_payoff_history = np.append(self.my_payoff_history, history.my_payoffs)

class Strategy_COLLECTIVE_70(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and promotes sustainability of the common pool.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_thresholds = [0.25, 0.75]
        self.cooperation_rate = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock >= capacity * self.stock_thresholds[1]:
            action = Action.C
        elif current_stock >= capacity * self.stock_thresholds[0]:
            probability_defect = (1 - current_stock / capacity) ** 2
            action = Action.D if random.random() < probability_defect else Action.C
        else:
            action = Action.D
        if history is not None and len(history.my_actions) > 0:
            opponent_actions = history.opponent_actions[-3:, :]
            for i in range(self.game_description.n_players - 1):
                cooperation_rate_opponent = np.mean(opponent_actions[:, i])
                if cooperation_rate_opponent > 0.75:
                    self.cooperation_rate += 0.1
                elif cooperation_rate_opponent < 0.25:
                    self.cooperation_rate -= 0.1
        total_payoff_last_3_rounds = np.sum(history.my_payoffs[-3:])
        average_player_payoff = np.mean(np.sum(history.opponent_payoffs[-3:, :], axis=0))
        if total_payoff_last_3_rounds < average_player_payoff:
            self.reconsider_strategy(current_stock)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if current_stock < capacity * self.stock_thresholds[0] and np.all(history.opponent_actions[-3:, :] == False):
            return Action.C
        return action

    def reconsider_strategy(self, current_stock):
        capacity = self.game_description.capacity
        if current_stock >= capacity * self.stock_thresholds[1]:
            self.cooperation_rate += 0.1
        elif current_stock >= capacity * self.stock_thresholds[0]:
            self.cooperation_rate -= 0.05
        else:
            self.cooperation_rate -= 0.1
        self.cooperation_rate = max(0, min(self.cooperation_rate, 1))

class Strategy_COLLECTIVE_71(BaseStrategy):
    """
    An adaptive strategy that balances individual self-interest with collective responsibility.
    Cooperates when the stock level is high, and uses Tit-for-Tat with Stock Threshold to adapt to opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def calculate_avg_opponent_consumption(self, current_stock, n_players):
        if not hasattr(self, 'history') or not self.history.my_payoffs.size:
            return 0
        own_consumption = self.history.my_payoffs[-1] * (2 * n_players) / current_stock
        opponent_consumptions = np.sum(self.history.opponent_payoffs[-1]) * (2 * n_players) / current_stock
        avg_opponent_consumption = (opponent_consumptions - own_consumption) / (n_players - 1)
        return avg_opponent_consumption

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.history = history
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if current_stock >= 0.75 * capacity:
            return Action.C
        if current_stock <= 0.25 * capacity:
            return Action.D
        avg_opponent_consumption = self.calculate_avg_opponent_consumption(current_stock, n_players)
        cooperative_threshold = current_stock / (2 * n_players)
        if avg_opponent_consumption < cooperative_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_72(BaseStrategy):
    """
    Adaptive Cooperation and Punishment (ACP) strategy balances cooperation with punishment mechanisms to ensure sustainable resource usage.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < 2:
            return Action.C
        opponent_actions = history.opponent_actions[-5:, :] if len(history.opponent_actions) >= 5 else history.opponent_actions
        recent_coop_rate = np.mean(opponent_actions)
        if recent_coop_rate >= 0.7:
            return Action.C
        if recent_coop_rate < 0.7 and state.current_stock > self.game_description.capacity / 2:
            p = 1 - recent_coop_rate
            return Action.D if random.random() < p else Action.C
        if state.current_stock < self.game_description.capacity / 4:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1 and state.current_stock > self.game_description.capacity / 2:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_73(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperate-to-Threshold (ACT)
    
    Balances individual gain with collective sustainability by adapting cooperation levels based on the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.cooperation_threshold = self.update_ct(self.cooperation_threshold, state.current_stock, history)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        if state.current_stock >= self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

    def update_ct(self, ct: float, new_stock: float, history: PlayerHistory) -> float:
        if new_stock > history.my_payoffs[-1]:
            ct += 0.05 * self.game_description.capacity
        else:
            ct -= 0.05 * self.game_description.capacity
        opponents_defected = sum((1 for action in history.opponent_actions[-1, :] if not action))
        if opponents_defected >= len(history.opponent_actions[0]) / 2:
            ct -= 0.1 * self.game_description.capacity
        return max(0, min(ct, self.game_description.capacity))

class Strategy_COLLECTIVE_74(BaseStrategy):
    """
    Adaptive Stock-Sensitive Tit-for-Tat strategy.
    
    This strategy aims to balance individual payoffs with collective sustainability by adapting 
    to the game state and opponents' behaviors. It prioritizes cooperation when the stock is abundant 
    and adapts to changes in the game state, such as declining stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        if state.round_number == 0 or history is None:
            return Action.C
        stock_fraction = state.current_stock / capacity
        if stock_fraction >= 0.75:
            return Action.C
        elif stock_fraction >= 0.5:
            opponent_actions = history.opponent_actions[-1, :]
            cooperators = sum(opponent_actions)
            if cooperators > len(opponent_actions) / 2 or (cooperators == len(opponent_actions) / 2 and random.choice([True, False])):
                return Action.C
            else:
                return Action.D
        elif stock_fraction < 0.5 and state.round_number != self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_75(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock-Aware Tit-for-Tat.
    
    This strategy balances individual payoff maximization with collective sustainability 
    of the common pool resource by adapting to various opponent behaviors while prioritizing 
    collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        elif state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        elif state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        else:
            p_coop = np.mean(history.opponent_actions[-1, :])
            if p_coop >= 0.5 or (state.current_stock < 0.25 * self.game_description.capacity and history.my_actions[-1] == Action.D):
                return Action.C
            else:
                return Action.D
        if state.round_number + 1 == self.game_description.n_rounds:
            return Action.D

class Strategy_COLLECTIVE_76(BaseStrategy):
    """
    The Adaptive Stock Conservation Strategy prioritizes collective resource conservation 
    by adapting to changing stock levels and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        stock_ratio = state.current_stock / self.game_description.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            if stock_ratio > 0.5:
                return Action.C
            else:
                return Action.D
        elif stock_ratio > 0.75:
            return Action.C
        elif stock_ratio >= 0.5:
            p_c = stock_ratio ** 2
            return random.choices([Action.C, Action.D], weights=[p_c, 1 - p_c])[0]
        else:
            return Action.D

class Strategy_COLLECTIVE_77(BaseStrategy):
    """
    Adaptive Stock Sustainer (ASS) strategy for the Common Pool Resource Game.
    
    This strategy balances individual payoff maximization with long-term sustainability 
    of the common pool resource by adapting to changing conditions and being mindful 
    of opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        theta = 0.75 * self.game_description.capacity / self.game_description.n_players
        gamma = 0.8
        prev_round_history = history.my_payoffs.shape[0] - 1
        s_prev = state.current_stock + sum(history.opponent_actions[-1, :] * (state.current_stock / self.game_description.n_players)) + history.my_payoffs[-1]
        pi_avg_prev = np.mean(np.concatenate((history.my_payoffs[:prev_round_history], history.opponent_payoffs[prev_round_history, :])))
        phi = 0.25 * self.game_description.capacity / self.game_description.n_players
        if s_prev < phi:
            return Action.C
        elif self.game_description.n_rounds - state.round_number <= self.game_description.n_players:
            return Action.C
        elif s_prev > theta and pi_avg_prev >= gamma * (s_prev / (2 * self.game_description.n_players)):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_78(BaseStrategy):
    """
    A strategy that balances individual payoffs with collective sustainability 
    by adapting to the dynamic state and history of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.threshold = 0.1 * (self.capacity / (2 * self.n_players))
        self.adaptive_component_window = 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_level = state.current_stock / self.capacity
        if state.round_number == 1:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock_level >= 0.75:
            action = Action.C
        elif stock_level >= 0.5 and stock_level < 0.75:
            prob_coop = 0.6
            action = Action.C if random.random() < prob_coop else Action.D
        else:
            action = Action.D
        avg_payoff = np.mean(history.my_payoffs[-self.adaptive_component_window:])
        if avg_payoff < self.threshold and action == Action.C:
            action = Action.D
        elif avg_payoff >= self.threshold and action == Action.D:
            action = Action.C
        if state.current_stock > 0.75 * self.capacity and (not history.my_actions[-1]):
            action = Action.C
        opponent_history = history.opponent_actions[:, 0] if history.opponent_actions.shape[1] == 1 else np.all(history.opponent_actions, axis=1)
        consistent_defection = sum(opponent_history[-3:]) == len(opponent_history[-3:])
        if consistent_defection:
            action = Action.D
        return action

class Strategy_COLLECTIVE_79(BaseStrategy):
    """
    Adaptive Stock Conservation Strategy.

    This strategy prioritizes stock conservation while adapting to the group's behaviour and the current state.
    It initially cooperates, then assesses the average payoff per player in the previous round and adapts accordingly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_payoff_prev_round = np.mean(history.my_payoffs[-1])
        max_possible_payoff = self.game_description.capacity / (2 * self.game_description.n_players)
        if avg_payoff_prev_round > self.cooperation_threshold * max_possible_payoff:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        delta_S = np.mean(np.diff(history.my_payoffs[-3:])) if len(history.my_payoffs) >= 3 else 0
        if delta_S < 0:
            self.cooperation_threshold += 0.1
        opponent_actions_prev_round = history.opponent_actions[-1, :]
        pC = np.mean(opponent_actions_prev_round)
        if pC > 0.5:
            self.cooperation_threshold -= 0.1
        elif 1 - pC > 0.5:
            self.cooperation_threshold += 0.1
        return Action.C

class Strategy_COLLECTIVE_80(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy for the Common Pool Resource Game.
    
    ASC balances individual payoffs with collective sustainability by adapting to 
    the game's dynamic state and opponent behaviors while prioritizing stock conservation 
    when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock > 0.75 * capacity:
            return Action.C
        if history.opponent_actions[-1].all():
            return Action.C
        num_defectors = sum((not action for action in history.opponent_actions[-1]))
        defect_prob = num_defectors / self.game_description.n_players * (1 - current_stock / capacity)
        if random.random() < defect_prob:
            return Action.D
        if current_stock < 0.25 * capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1 and current_stock > 0.5 * capacity:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_81(BaseStrategy):
    """
    Adaptive Tit-for-Two-Tats with Stock-Dependent Cooperation (ATTC) strategy.
    Balances individual payoff maximization with collective sustainability by adapting to the game state and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        cooperation_threshold = 0.75 * self.game_description.capacity
        defection_threshold = 0.25 * self.game_description.capacity
        if state.current_stock > cooperation_threshold:
            return Action.C
        elif state.current_stock <= defection_threshold:
            return Action.D
        opponents_defected = sum((1 for opponent_action in history.opponent_actions[-1, :] if not opponent_action))
        if opponents_defected >= 2:
            return Action.D
        individual_cooperation_payoff = state.current_stock / (2 * self.game_description.n_players)
        individual_defection_payoff = state.current_stock / self.game_description.n_players
        if individual_cooperation_payoff >= individual_defection_payoff:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_82(BaseStrategy):
    """
    A collective strategy for managing common pool resources, 
    balancing individual payoffs with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.25 * (game_description.capacity / (2 * game_description.n_players))
        self.adaptation_window = 3
        self.cooperation_probability = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        if stock_level > 0.75:
            return Action.C
        elif 0.5 <= stock_level < 0.75:
            self.cooperation_probability = stock_level - 0.5
            return Action.C if random.random() < self.cooperation_probability else Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_83(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Threshold (ACST) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock_threshold = self.capacity / (2 * self.n_players + 1)
        min_stock = self.capacity / (4 * self.n_players)
        if state.round_number == 0:
            return Action.C
        if state.current_stock > stock_threshold:
            return Action.C
        elif state.current_stock < min_stock:
            return Action.C
        else:
            defect_prob = (self.capacity - state.current_stock) / self.capacity
            if random.random() < defect_prob:
                return Action.D
            else:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > stock_threshold:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_84(BaseStrategy):
    """
    Adaptive Stock-Sensitive Cooperation strategy.
    
    This strategy aims to balance individual payoff maximization with cooperation 
    to maintain a healthy common pool stock. It adapts its cooperation probability 
    based on the current stock level and historical average stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        S_t = state.current_stock
        if history is not None:
            S_avg = np.mean([state.current_stock] + history.my_payoffs)
        else:
            S_avg = S_t
        if S_t >= 0.75 * self.capacity and S_avg >= 0.5 * self.capacity:
            P_C = (S_t / self.capacity) ** 2
        elif S_t < 0.25 * self.capacity or S_avg < 0.25 * self.capacity:
            return Action.D
        else:
            P_C = 0.5
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif random.random() < P_C:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_86(BaseStrategy):
    """
    Adaptive Stock Sensitive Tit-for-Tat with Exploration strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_high = 0.75 * (game_description.capacity / (2 * game_description.n_players))
        self.threshold_low = 0.5 * (game_description.capacity / (2 * game_description.n_players))
        self.exploration_probability = 0.05

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_previous_payoff = np.mean(history.my_payoffs[-1])
        opponent_actions = history.opponent_actions
        n_opponents = self.game_description.n_players - 1
        if avg_previous_payoff > self.threshold_high and state.current_stock < self.game_description.capacity * 0.75:
            return Action.C
        elif avg_previous_payoff < self.threshold_low:
            self.exploration_probability *= 2
        stock_level_ratio = state.current_stock / self.game_description.capacity
        if stock_level_ratio < 0.25 or state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif stock_level_ratio > 0.75:
            return Action.C
        random_action = random.random() < self.exploration_probability
        if random_action:
            return Action.C if random.choice([True, False]) else Action.D
        opponents_defected = np.sum(opponent_actions[-1, :])
        if opponents_defected >= n_opponents // 2 or state.current_stock < self.game_description.capacity * 0.25:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_87(BaseStrategy):
    """
    Adaptive Stock Conservation Strategy.
    
    The ASC strategy aims to balance individual payoffs with collective sustainability 
    by adapting to the game's dynamic state and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.theta = 0.75 * (game_description.capacity / game_description.n_players)
        self.p_defect = 0

    def calculate_avg_payoff(self, history: PlayerHistory) -> float:
        """
        Calculate the average payoff per player in the previous round.
        
        Args:
            history (PlayerHistory): The current player's history.

        Returns:
            float: Average payoff per player in the previous round.
        """
        if len(history.my_payoffs) > 1:
            return np.mean([history.my_payoffs[-2]] + list(history.opponent_payoffs[-2, :]))
        else:
            return self.game_description.capacity / (self.game_description.n_players * 2)

    def get_opponent_actions(self, history: PlayerHistory) -> NDArray[np.bool_]:
        """
        Get opponent actions in the previous round.
        
        Args:
            history (PlayerHistory): The current player's history.

        Returns:
            NDArray[np.bool_]: Opponent actions in the previous round.
        """
        return history.opponent_actions[-1, :]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock >= self.game_description.capacity / 2 else Action.D
        avg_payoff_prev_round = self.calculate_avg_payoff(history)
        if avg_payoff_prev_round > self.theta:
            action = Action.C
        else:
            self.p_defect = max(0, 1 - (state.current_stock / self.game_description.capacity) ** 2)
            opponent_actions_prev_round = self.get_opponent_actions(history)
            for opponent in opponent_actions_prev_round:
                if not opponent:
                    self.p_defect += 0.1
                else:
                    self.p_defect -= 0.05
            action = Action.D if random.random() < self.p_defect else Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C if state.current_stock >= self.game_description.capacity / 4 else Action.D
        return action

class Strategy_COLLECTIVE_88(BaseStrategy):
    """
    An adaptive cooperation strategy that prioritizes collective well-being and adaptability over individual short-term gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_stock_level = None
        self.previous_outcomes = {'stock': None, 'actions': None}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.previous_stock_level = history.my_payoffs[-2] if len(history.my_payoffs) > 1 else None
        prev_actions = np.sum(history.opponent_actions[-1, :]) / self.game_description.n_players
        current_stock_level = state.current_stock
        capacity = self.game_description.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            if current_stock_level > 0.75 * capacity:
                return Action.C
            else:
                return Action.D
        if current_stock_level > 0.75 * capacity:
            return Action.C
        elif current_stock_level < 0.5 * capacity:
            return Action.D
        else:
            cooperate_prob = 0.6
            if self.previous_stock_level is not None and self.previous_stock_level < current_stock_level:
                cooperate_prob += 0.1
            if prev_actions > 0.7:
                cooperate_prob += 0.1
            return Action.C if random.random() < cooperate_prob else Action.D
        self.previous_outcomes['stock'] = current_stock_level
        self.previous_outcomes['actions'] = prev_actions

class Strategy_COLLECTIVE_89(BaseStrategy):
    """
    The ASP strategy aims to balance individual payoffs with collective sustainability, 
    ensuring a stable stock level throughout the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number < 6:
            if state.current_stock > 0.75 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D if random.random() < 0.5 else Action.C
        elif state.round_number <= self.game_description.n_rounds // 2:
            avg_payoff = np.mean(history.my_payoffs) if len(history.my_payoffs) > 1 else 0
            max_payoff = self.game_description.capacity / (2 * self.game_description.n_players)
            if avg_payoff < 0.5 * max_payoff or state.current_stock <= 0:
                return Action.C
            else:
                opponents_cooperated = sum(history.opponent_actions[-1, :])
                return Action.C if opponents_cooperated > self.game_description.n_players / 2 else Action.D
        elif state.round_number > self.game_description.n_rounds // 2:
            if state.current_stock > 0.5 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D if random.random() < 0.75 else Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number >= self.game_description.n_rounds - 2 and state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        elif history is not None and len(history.opponent_actions) > 0 and np.all(~history.opponent_actions[-1, :]):
            return Action.D

class Strategy_COLLECTIVE_91(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy for the Common Pool Resource Game.
    
    This strategy prioritizes cooperation when the stock level is healthy, promoting collective sustainability. 
    By adapting to recent history and stock levels, ASC balances individual interests with collective well-being.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_level_threshold = 0.75 * self.game_description.capacity
        if state.current_stock >= stock_level_threshold:
            return Action.C
        low_stock_warning_threshold = 0.25 * self.game_description.capacity
        if state.current_stock < low_stock_warning_threshold:
            return Action.D
        opponent_actions_in_last_round = history.opponent_actions[-1, :]
        most_players_cooperated = np.sum(opponent_actions_in_last_round) >= self.game_description.n_players / 2
        if most_players_cooperated:
            return Action.C
        else:
            return Action.D
        last_round_threshold = self.game_description.n_rounds - 1
        if state.round_number == last_round_threshold:
            return Action.D
        if state.current_stock <= 0 or state.round_number >= self.game_description.n_rounds:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_92(BaseStrategy):
    """
    Adaptive Cooperative Harvesting strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        S = state.current_stock
        opponent_behaviors = history.opponent_actions
        if S >= 0.8 * self.capacity:
            return Action.C
        elif 0.5 * self.capacity <= S < 0.8 * self.capacity:
            defect_probability = np.mean(~opponent_behaviors[-1, :]) if history.my_actions.size > 0 else 0.5
            return Action.C if random.random() >= defect_probability else Action.D
        else:
            return Action.D
        cooperators = np.sum(opponent_behaviors[-1, :])
        if cooperators > self.game_description.n_players // 2:
            return Action.C
        elif np.mean(history.my_payoffs[history.my_actions]) > np.mean(history.opponent_payoffs[:, ~opponent_behaviors[-1, :]]):
            return Action.C
        else:
            return Action.D
        opponents = range(self.n_players)
        for opponent in opponents:
            if history.opponent_actions[-2:, opponent].all() and np.mean(history.my_payoffs[history.my_actions]) < history.opponent_payoffs[-1, opponent]:
                return Action.D

class Strategy_COLLECTIVE_93(BaseStrategy):
    """
    Adaptive Cooperative Sustainability (ACS) strategy.
    
    This collective strategy balances individual payoffs with long-term sustainability 
    of the common pool resource, adapting to changing game conditions and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponents_defected = np.count_nonzero(~history.opponent_actions[-1, :])
        if state.current_stock < 0.5 * self.game_description.capacity or opponents_defected > self.game_description.n_players / 2:
            return Action.D
        elif state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        else:
            p_defect = opponents_defected / self.game_description.n_players * (1 - state.current_stock / self.game_description.capacity)
            if random.random() < p_defect:
                return Action.D
            else:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C

class Strategy_COLLECTIVE_94(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy.
    
    This strategy prioritizes cooperation when the stock level is healthy, 
    but adaptively adjusts to defecting behavior as the stock level declines or opponents exhibit exploitative behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = None

    def opponent_defect_count(self) -> float:
        if self.opponent_history is None:
            return 0.0
        count = np.sum(~self.opponent_history.opponent_actions[-3:, :], axis=0)
        return np.mean(count, axis=0)

    def adjust_strategy(self, current_stock: float, opponent_defect_prob: float) -> Action:
        if current_stock < 0.25 * self.game_description.capacity:
            return Action.D if random.random() < 0.9 else Action.C
        elif self.opponent_history is not None and self.opponent_history.my_actions.shape[0] == self.game_description.n_rounds - 1:
            return Action.C
        elif current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        elif 0.5 <= current_stock / self.game_description.capacity < 0.75:
            defect_prob = 0.3 + opponent_defect_prob
            return Action.D if random.random() < defect_prob else Action.C
        else:
            defect_prob = 0.7 + opponent_defect_prob
            return Action.D if random.random() < defect_prob else Action.C

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if random.random() < 0.5 else Action.D
        self.opponent_history = history
        opponent_defect_prob = np.mean(self.opponent_defect_count())
        return self.adjust_strategy(state.current_stock, opponent_defect_prob)

class Strategy_COLLECTIVE_95(BaseStrategy):
    """
    A strategy that adapts to the current stock level and opponent behavior 
    to balance individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock <= 0:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio >= 0.75:
            return Action.C
        elif stock_ratio < 0.5:
            return Action.D
        p = stock_ratio
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        opponent_defectors = self.game_description.n_players - 1 - opponent_cooperators
        if opponent_cooperators > (self.game_description.n_players - 1) / 2:
            p += 0.1
        elif opponent_defectors > (self.game_description.n_players - 1) / 2:
            p -= 0.1
        p = max(0, min(p, 1))
        return Action.C if random.random() < p else Action.D

class Strategy_COLLECTIVE_96(BaseStrategy):
    """
    This strategy adapts to various opponent behaviors and promotes cooperation 
    while ensuring robustness against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.p_defect_threshold = 0.3
        self.stock_level_threshold = game_description.capacity / 2
        self.payoff_decrease_threshold = 0.2
        self.recent_payoffs_window_size = 5
        self.forgiveness_rounds = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        p_defect = np.sum(history.opponent_actions[-1, :]) / self.game_description.n_players
        recent_payoffs = history.my_payoffs[-self.recent_payoffs_window_size:]
        avg_recent_payoff = np.mean(recent_payoffs)
        initial_stock_level = self.game_description.capacity
        stock_depletion_threshold = initial_stock_level / 4
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < stock_depletion_threshold:
            return Action.D
        opponent_defected_last_round = np.sum(history.opponent_actions[-1, :]) > 0
        if opponent_defected_last_round and state.current_stock > self.stock_level_threshold:
            return Action.D
        opponent_cooperated_again = np.all(np.equal(history.opponent_actions[-self.forgiveness_rounds:, :], True))
        if opponent_cooperated_again:
            return Action.C
        if p_defect > self.p_defect_threshold or state.current_stock < self.stock_level_threshold or avg_recent_payoff * (1 + self.payoff_decrease_threshold) < np.mean(history.my_payoffs[:-self.recent_payoffs_window_size]):
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_97(BaseStrategy):
    """
    A strategy that adapts to the stock level and opponent's previous actions.
    Cooperates when the stock level is high, plays tit-for-tat when it's moderate,
    and defects when it's low. Adjusts its decision based on opponents' defections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold_high = 0.75 * game_description.capacity
        self.cooperation_threshold_low = 0.5 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        previous_opponent_action = np.any(opponent_actions)
        if state.current_stock >= self.cooperation_threshold_high:
            return Action.C
        elif self.cooperation_threshold_low <= state.current_stock < self.cooperation_threshold_high:
            if previous_opponent_action:
                return Action.C
            else:
                return Action.D
        else:
            num_opponents = self.game_description.n_players - 1
            opponent_defectors = np.sum(~opponent_actions)
            probability_of_defection = opponent_defectors / num_opponents if num_opponents > 0 else 0.5
            if random.random() < probability_of_defection:
                return Action.D
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C

class Strategy_COLLECTIVE_98(BaseStrategy):
    """
    The Adaptive Stock Conservation (ASC) strategy balances individual payoff maximization with collective stock conservation,
    adapting to changing game conditions and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        high_stock = self.game_description.capacity * 0.75
        low_stock = self.game_description.capacity * 0.25
        opponents_defected_prev_ratio = sum(1 - history.opponent_actions[-1, :]) / self.game_description.n_players
        defect_prob = min(1, opponents_defected_prev_ratio)
        stock_growth_prev = (state.current_stock - history.my_payoffs[-1] * self.game_description.n_players) / state.round_number
        if state.current_stock > high_stock:
            return Action.C
        if state.current_stock < low_stock or state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if random.random() < (1 - defect_prob) * 0.5 and stock_growth_prev > 0:
            return Action.C
        return Action.D if random.random() < defect_prob else Action.C

class Strategy_COLLECTIVE_99(BaseStrategy):
    """
    Balances individual payoffs with collective stock conservation by adapting to the current state of the game and the behavior of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = [game_description.capacity]
        self.payoff_history = []
        self.action_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = self.stock_history[-1]
        previous_payoffs = self.payoff_history[-1] if self.payoff_history else [0] * self.game_description.n_players
        if current_stock >= 0.5 * self.game_description.capacity:
            action = Action.C
        elif history.my_payoffs[-1] < np.mean(previous_payoffs):
            action = Action.D
        elif (current_stock - self.stock_history[-2]) / self.game_description.capacity < -0.2:
            action = Action.D
        elif current_stock < 0.3 * self.game_description.capacity:
            action = Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        elif all((self.action_history[-i] == True for i in range(1, min(len(self.action_history), 4)))):
            if current_stock < 1.1 * self.stock_history[-4]:
                action = Action.D
        else:
            opponent_actions = history.opponent_actions[-1]
            if all(opponent_actions):
                action = Action.C
            elif not any(opponent_actions):
                action = Action.D
        payoffs = self.calculate_payoffs(current_stock, [action] + list(history.opponent_actions[-1]))
        self.payoff_history.append(payoffs)
        self.action_history.append(action)
        new_stock = min(current_stock - sum([payoff for payoff in payoffs if payoff < 0]) / self.game_description.n_players + 2 * (current_stock - sum([payoff for payoff in payoffs if payoff < 0])) * (1 - (current_stock - sum([payoff for payoff in payoffs if payoff < 0])) / self.game_description.capacity), self.game_description.capacity)
        self.stock_history.append(new_stock)
        return action

    def calculate_payoffs(self, current_stock: float, actions: list[bool]) -> list[float]:
        """
        Calculate payoffs based on the given stock level and actions.
        """
        n = len(actions)
        payoffs = []
        for i in range(n):
            if actions[i]:
                payoff = -current_stock / (2 * n)
            else:
                payoff = -current_stock / n
            payoffs.append(payoff)
        return payoffs

class Strategy_COLLECTIVE_100(BaseStrategy):
    """
    Collective strategy that adapts to the game's state and history.
    
    Aims to balance individual payoffs with collective sustainability by 
    cooperating when the stock level is sufficient and adapting to opponents' 
    behavior when it's not. By balancing individual payoffs with collective 
    conservation, ASC promotes a stable and resilient game state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponents_defected = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.opponents_defected = sum((not action for action in history.opponent_actions[-1, :]))
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        elif state.current_stock >= 0.5 * self.game_description.capacity:
            defect_prob = self.opponents_defected / self.game_description.n_players
            if random.random() < defect_prob:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_101(BaseStrategy):
    """
    The ASP strategy aims to balance individual payoffs with collective sustainability 
    by adaptively adjusting cooperation levels based on the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock >= self.game_description.capacity / 2 else Action.D
        avg_depletion = (self.game_description.capacity - state.current_stock) / state.round_number
        depletion_threshold = self.game_description.capacity / (4 * self.game_description.n_players)
        stock_threshold = self.game_description.capacity / 4
        if avg_depletion < depletion_threshold:
            return Action.C
        elif state.current_stock < stock_threshold:
            return Action.D
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1 or len(history.opponent_actions) == 0:
            return Action.D

class Strategy_COLLECTIVE_102(BaseStrategy):
    """
    Collective strategy that adapts to the game's state and history by balancing individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_fraction = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        threshold = self.threshold_fraction * self.game_description.capacity
        if state.round_number == 0 or history is None:
            return Action.C
        defectors_count = sum((not action for action in history.opponent_actions[-1, :]))
        if state.current_stock < threshold:
            return Action.D
        elif defectors_count > self.game_description.n_players / 2:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_103(BaseStrategy):
    """
    Collective Strategy: Adaptive Tit-for-Two-Tats with Stock Conservation.
    
    This strategy prioritizes cooperation when the stock level is sustainable and opponents have demonstrated cooperative behavior. 
    By adapting to the environment and opponents' actions, this strategy aims to maintain a balance between individual payoff maximization and collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock_level >= 0.75:
            return Action.C
        elif stock_level >= 0.5:
            cooperators = sum((1 for opponent in history.opponent_actions[-1, :] if opponent))
            if cooperators > self.game_description.n_players / 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D
        for opponent_actions in history.opponent_actions[-2:, :]:
            if not np.any(opponent_actions):
                return Action.D

class Strategy_COLLECTIVE_104(BaseStrategy):
    """
    Collective strategy that balances individual payoffs with collective stock conservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if self.game_description.n_players % 2 == 0 else Action.D
        opponent_payoffs = history.opponent_payoffs[-1, :]
        total_consumption = sum(opponent_payoffs) + history.my_payoffs[-1]
        avg_opponent_payoff = np.mean(opponent_payoffs)
        stock_threshold_high = 0.75 * self.game_description.capacity
        stock_threshold_low = 0.5 * self.game_description.capacity
        stock_growth_threshold = 0.1 * self.game_description.capacity
        if state.current_stock > stock_threshold_high:
            return Action.C if avg_opponent_payoff < 0.5 * state.current_stock / (2 * self.game_description.n_players) else Action.D
        elif state.current_stock >= stock_threshold_low:
            return Action.C if total_consumption > 0.5 * self.game_description.capacity else Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < stock_growth_threshold:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_105(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy aims to balance individual payoffs with collective sustainability.
    It adapts to the game's state and history, encouraging opponents to cooperate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_level_thresholds = [0.25 * game_description.capacity, 0.75 * game_description.capacity]
        self.low_stock_warning = 0.1 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        opponent_actions = history.opponent_actions[-1]
        num_cooperators = sum(opponent_actions)
        defect_probability = max(0, min(stock_level - 0.5 + (num_cooperators > len(opponent_actions) // 2) * -0.1 + (num_cooperators < len(opponent_actions) // 2) * 0.2, 1))
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if stock_level < self.low_stock_warning / self.game_description.capacity and (history.my_actions[-1] or random.random() > defect_probability):
            return Action.C
        if stock_level >= self.stock_level_thresholds[1]:
            return Action.C
        elif stock_level <= self.stock_level_thresholds[0]:
            return Action.D
        else:
            return Action.C if random.random() < 1 - defect_probability else Action.D

class Strategy_COLLECTIVE_106(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Dependent Tit-for-Tat (ASDT) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_threshold_low = 0.1 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.capacity_threshold_low:
            opponent_cooperated = np.any(history.opponent_actions[-1, :] == True)
            return Action.C if opponent_cooperated else Action.D
        sufficient_stock = state.current_stock > 0.7 * self.game_description.capacity
        low_stock = state.current_stock < 0.3 * self.game_description.capacity
        if sufficient_stock:
            opponent_defected_last_round = np.any(history.opponent_actions[-1, :] == False)
            return Action.D if opponent_defected_last_round else Action.C
        elif low_stock:
            return Action.D
        else:
            opponent_cooperated_last_round = np.any(history.opponent_actions[-1, :] == True)
            if opponent_cooperated_last_round:
                return Action.C
            elif random.random() < state.current_stock / self.game_description.capacity:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_107(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Dependent Trigger (ACSDT) strategy.
    
    This strategy balances individual self-interest with collective well-being by cooperating when the stock level is high and adapting to defect more frequently when the stock level drops, considering opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_behaviors = [None] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and history.opponent_actions is not None:
            for i, action in enumerate(history.opponent_actions[-1, :]):
                if action:
                    self.opponent_behaviors[i] = 'C'
                else:
                    self.opponent_behaviors[i] = 'D'

        def calculate_probability(behaviors):
            p = 0.5
            for behavior in behaviors:
                if behavior == 'D':
                    p += 0.1
                elif behavior == 'C':
                    p -= 0.1
                    p = max(p, 0)
            return p
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio >= 0.75:
            return Action.C
        elif stock_ratio >= 0.5:
            p = calculate_probability(self.opponent_behaviors)
            if random.random() < p:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_108(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that balances individual payoffs with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_payoff = 0.0
        self.max_payoff = 100 / (2 * self.game_description.n_players)
        self.reduced_consumption_countdown = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperation_threshold = state.current_stock / (2 * self.game_description.n_players * (self.game_description.n_rounds - state.round_number))
        if history is not None:
            self.average_payoff += (history.my_payoffs[-1] - self.average_payoff) / len(history.my_payoffs)
            if self.reduced_consumption_countdown > 0:
                self.reduced_consumption_countdown -= 1
            elif self.average_payoff > 0.75 * self.max_payoff and self.reduced_consumption_countdown == 0:
                self.reduced_consumption_countdown = 2
        if self.reduced_consumption_countdown > 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > 0.5 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        if state.current_stock < 0.2 * self.game_description.capacity:
            return Action.C
        if state.current_stock > cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_109(BaseStrategy):
    """
    A strategy that balances individual payoffs with collective sustainability,
    adapting to opponents' behaviors while conserving the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_defectors = sum((1 for action in history.opponent_actions[-1, :] if not action))
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        elif opponent_defectors > 0:
            return Action.D
        elif state.current_stock <= 0.25 * self.game_description.capacity:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif opponent_defectors > 1:
            player_index = history.my_actions.size % self.game_description.n_players
            if player_index % 2 == 1:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_COLLECTIVE_110(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        sdr = (self.game_description.capacity - state.current_stock) / self.game_description.capacity
        if sdr < 0.25:
            return Action.C
        elif sdr >= 0.5 or (history and len(history.my_actions) > 0 and all((not action for action in history.opponent_actions[-1, :])) and (state.current_stock < self.game_description.capacity / 2)):
            return Action.D
        else:
            p_defect = (sdr - 0.25) / 0.25
            if history and len(history.my_actions) > 0:
                opponent_cooperations = sum(history.opponent_actions[-1, :])
                p_defect *= opponent_cooperations / self.game_description.n_players
            return Action.D if random.random() < p_defect else Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C if state.current_stock > self.game_description.capacity / 2 else Action.D

class Strategy_COLLECTIVE_111(BaseStrategy):
    """
    Adaptive Common Pool Resource Management Strategy.
    
    Balances individual payoffs with long-term sustainability of the common pool resource.
    Prioritizes cooperation when the resource is abundant, adapting to changing conditions by monitoring average payoffs and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_thresholds = {'low': game_description.capacity * 0.25, 'high': game_description.capacity * 0.9, 'critical': game_description.capacity * 0.1, 'initial_cooperate': game_description.capacity * 0.75, 'last_round_cooperate': game_description.capacity * 0.5}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if state.current_stock >= self.capacity_thresholds['initial_cooperate']:
                return Action.C
            else:
                return Action.D
        avg_payoff = np.mean(history.my_payoffs[-1])
        if history.my_payoffs.size > 0 and avg_payoff >= state.current_stock / (2 * self.game_description.n_players):
            return Action.C
        if state.current_stock < self.capacity_thresholds['low']:
            return Action.C
        elif state.current_stock > self.capacity_thresholds['high']:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock >= self.capacity_thresholds['last_round_cooperate']:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_COLLECTIVE_112(BaseStrategy):
    """
    Adaptive Stock-Conscious Tit-for-Tat Strategy.

    This strategy adapts to the dynamic state of the common pool by balancing individual interests with collective sustainability.
    It cooperates when the stock is relatively high, defects with increasing probability as the stock depletes, and adjusts its strategy based on opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        S = state.current_stock
        APP_prev = np.mean(history.my_payoffs[-1:]) if len(history.my_payoffs) > 0 else 0
        if S > 0.75 * self.capacity:
            action = Action.C
        else:
            P_defect = (1 - S / self.capacity) ** 2
            action = Action.D if random.random() < P_defect else Action.C
        opponent_actions_prev = history.opponent_actions[-1, :] if len(history.opponent_actions) > 0 else np.zeros(self.n_players - 1)
        num_defectors_prev = sum(opponent_actions_prev == False)
        if num_defectors_prev > self.n_players / 2:
            action = Action.D
        if state.round_number >= self.game_description.n_rounds - 1:
            return Action.D
        if S < self.n_players and action == Action.D:
            return Action.C
        return action

class Strategy_COLLECTIVE_113(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Trigger (ACST) strategy.
    This strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_level = 1.0
        self.opponent_actions_last_round = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        sr = state.current_stock / self.game_description.capacity
        action = Action.D
        if sr > 0.7:
            action = Action.C
        if history is not None and history.opponent_actions.shape[0] > 0:
            opponent_actions_last_round = history.opponent_actions[-1, :]
            for opponent_action in opponent_actions_last_round:
                if opponent_action == True:
                    self.cooperation_level += 0.05
                else:
                    self.cooperation_level -= 0.1
        if sr < 0.3:
            action = Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if random.random() > self.cooperation_level:
            action = Action.D
        return action

class Strategy_COLLECTIVE_114(BaseStrategy):
    """
    Adaptive Collective Harvesting strategy that balances cooperation and defection to optimize long-term payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defect_rate = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if self.game_description.n_players > 4:
                return Action.C
            else:
                return Action.D
        if state.current_stock >= self.game_description.capacity / 2:
            cooperate = True
        else:
            self.defect_rate = (self.game_description.capacity - state.current_stock) / self.game_description.capacity
            cooperate = random.random() > self.defect_rate
        if history is not None:
            opponent_defection_rate = np.mean(1 - history.opponent_actions[-1, :])
            if opponent_defection_rate > 0.5:
                self.defect_rate += 0.2
        if state.current_stock < 0.1 * self.game_description.capacity:
            cooperate = False
        if history is not None and np.mean(1 - history.opponent_actions[-1, :]) > 0.75:
            cooperate = True
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > 2 * self.game_description.n_players:
                return Action.C
            else:
                return Action.D
        return Action.C if cooperate else Action.D

class Strategy_COLLECTIVE_115(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Threshold (ACST) strategy.
    
    This strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and game history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.gamma = 0.5
        self.memory_size = 5
        self.stock_memory = []

    def update_stock_memory(self, stock_level):
        if len(self.stock_memory) < self.memory_size:
            self.stock_memory.append(stock_level)
        else:
            self.stock_memory.pop(0)
            self.stock_memory.append(stock_level)

    def calculate_cooperation_threshold(self, stock_level):
        return self.capacity / (2 * self.n_players) * (stock_level / self.capacity) ** self.gamma

    def adjust_gamma(self):
        if len(self.stock_memory) < 3:
            return
        avg_stock = np.mean(self.stock_memory)
        avg_cooperation_payoff = 0
        avg_defection_payoff = 0
        for i, stock in enumerate(self.stock_memory[:-1]):
            if self.calculate_cooperation_threshold(stock) > stock:
                avg_cooperation_payoff += stock / (2 * self.n_players)
            else:
                avg_defection_payoff += stock / self.n_players
        if avg_cooperation_payoff > avg_defection_payoff:
            self.gamma *= 1.05
        elif avg_cooperation_payoff < avg_defection_payoff:
            self.gamma *= 0.95

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.current_stock < self.capacity / (2 * self.n_players):
            action = Action.C
        elif state.current_stock > 3 / 4 * self.capacity:
            probability = (state.current_stock - 3 / 4 * self.capacity) / (1 / 4 * self.capacity)
            if random.random() < probability:
                action = Action.D
            else:
                action = Action.C
        else:
            cooperation_threshold = self.calculate_cooperation_threshold(state.current_stock)
            if state.current_stock > cooperation_threshold:
                action = Action.C
            else:
                action = Action.D
        self.update_stock_memory(state.current_stock)
        self.adjust_gamma()
        return action

class Strategy_COLLECTIVE_116(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Sensitive Threshold (ACST) strategy.
    
    This collective strategy prioritizes cooperation when the collective benefit is high,
    while adapting to changes in player behavior to maintain a stable and efficient exploitation of the common resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initialize the ACST strategy with the given game description.

        :param game_description: The CommonPoolDescription instance containing game parameters.
        """
        self.game_description = game_description
        self.stock_threshold = game_description.capacity * (1 - (game_description.n_players - 1) / game_description.n_players)
        self.critical_stock = game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determine the action to take in the given state and history.

        :param state: The current CommonPoolState instance.
        :param history: The PlayerHistory instance or None for the initial round.
        :return: The chosen Action (C or D).
        """
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.my_actions) > 0:
            previous_round_cooperators = sum(history.opponent_actions[-1, :])
            if previous_round_cooperators >= self.game_description.n_players // 2:
                self.stock_threshold *= 1.05
            elif previous_round_cooperators < self.game_description.n_players // 2:
                self.stock_threshold *= 0.95
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < self.critical_stock:
            return Action.C
        if state.current_stock > self.stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_117(BaseStrategy):
    """
    Adaptive Cooperation (AC) is a collective strategy designed for the Common Pool Resource Game.
    AC balances individual interests with collective sustainability by adaptively responding to the game state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_payoff_prev = np.mean(history.my_payoffs)
        max_possible_payoff = self.capacity / (2 * self.game_description.n_players)
        defect_rate_prev = sum((1 - action for action in history.my_actions[-2:])) / 2
        if state.current_stock > 0.75 * self.capacity:
            return Action.D if random.random() < 0.5 else Action.C
        elif avg_payoff_prev < 0.5 * max_possible_payoff:
            return Action.D
        elif defect_rate_prev > 0.25:
            return Action.C if random.random() < 0.7 else Action.D
        return Action.C

class Strategy_COLLECTIVE_118(BaseStrategy):
    """
    Adaptive Collective Conservation strategy for the Common Pool Resource Game.
    Balances individual self-interest with collective conservation by adapting to 
    the current stock level and opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        theta = 0.5 * self.game_description.capacity
        defectors = sum((1 for action in history.opponent_actions[-1, :] if not action))
        p_defect = defectors / self.game_description.n_players
        if state.current_stock > theta:
            if p_defect > 0.5:
                return Action.D
            else:
                return Action.C
        elif random.random() < 0.5:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_119(BaseStrategy):
    """
    Adaptive Stock Conservation strategy for the Common Pool Resource Game.
    
    This strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    It ensures robustness against various opponent behaviors while promoting cooperation when beneficial.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if current_stock >= 0.75 * self.capacity:
            return Action.C
        elif 0.5 * self.capacity <= current_stock < 0.75 * self.capacity:
            p = (current_stock / self.capacity) ** 2
            return Action.C if random.random() < p else Action.D
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_120(BaseStrategy):
    """
    Adaptive Cooperation with Stock Conservation strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        capacity = self.game_description.capacity
        if state.current_stock > 0.75 * capacity:
            return Action.C
        elif 0.25 * capacity <= state.current_stock <= 0.75 * capacity:
            p = (state.current_stock / capacity) ** 2
            return Action.C if random.random() < p else Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_121(BaseStrategy):
    """
    Collective strategy that balances individual self-interest with the need to maintain a sustainable common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        if state.round_number == 0 or history is None:
            return Action.C
        avg_consumption = np.mean(history.my_payoffs[-3:]) if len(history.my_payoffs) >= 3 else state.current_stock / n_players
        defectors = sum((1 for a in history.opponent_actions[-1, :] if not a))
        if avg_consumption < state.current_stock / (2 * n_players):
            return Action.C
        elif defectors > n_players / 2:
            return Action.D
        elif state.current_stock > capacity * 0.75:
            return Action.C
        elif state.current_stock < capacity * 0.25:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_122(BaseStrategy):
    """
    A hybrid strategy combining Tit-for-Tat (TFT), Grim Trigger (GT) with a novel stock-based adaptation mechanism.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        stock = state.current_stock
        majority_threshold = self.get_majority_threshold(stock)
        switch_to_defection = stock < 0.5 * self.capacity
        if switch_to_defection:
            return Action.D
        opponent_cooperators = sum(opponent_actions)
        if opponent_cooperators / len(opponent_actions) >= majority_threshold:
            return Action.C
        return Action.D

    def get_majority_threshold(self, stock: float):
        """
        Dynamically adjust the majority threshold based on the current stock level.
        """
        if stock < 0.5 * self.capacity:
            return 0.6
        elif stock < 0.75 * self.capacity:
            return 0.5
        return 0.4

    def get_last_round_action(self, rounds: int, round_number: int):
        """
        Last round logic: always defect to maximize individual payoff.
        """
        if round_number == rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_123(BaseStrategy):
    """
    The Adaptive Cooperative Balance strategy aims to balance individual self-interest 
    with collective sustainability in a dynamic Common Pool Resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            stock_utilization_rate = state.current_stock / self.game_description.capacity
            return Action.C if stock_utilization_rate > 0.75 else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        stock_utilization_rate = state.current_stock / self.game_description.capacity
        opponents_cooperated = sum(history.opponent_actions[-1, :])
        if opponents_cooperated > self.game_description.n_players / 2:
            return Action.C
        elif stock_utilization_rate > 0.5 and any((not history.opponent_actions[-1, i] for i in range(self.game_description.n_players - 1))):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_124(BaseStrategy):
    """
    Adaptive Stock Preservation (ASP) strategy.

    This collective strategy balances individual payoffs with the need for sustainable resource management.
    It cooperates when the stock level is high and defects when it's low, adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.low_stock_threshold = 0.5 * game_description.capacity
        self.high_stock_threshold = 0.8 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_payoff_prev_round = np.mean(history.my_payoffs[-1:])
        avg_coop_payoff = state.current_stock / (2 * self.game_description.n_players)
        if state.current_stock > self.high_stock_threshold:
            return Action.C
        elif state.current_stock < self.low_stock_threshold or state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if avg_payoff_prev_round >= avg_coop_payoff:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_125(BaseStrategy):
    """
    Adaptive Sustainability strategy balances individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            if state.current_stock > 0.75 * self.capacity:
                return Action.C
            else:
                return Action.D
        avg_payoff_prev_round = np.mean(history.my_payoffs[-1])
        max_possible_payoff = state.current_stock / self.game_description.n_players
        if avg_payoff_prev_round < 0.25 * max_possible_payoff:
            return Action.D
        elif state.current_stock > 0.5 * self.capacity:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C

class Strategy_COLLECTIVE_126(BaseStrategy):
    """
    A collective strategy that balances individual self-interest with the long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and history.my_payoffs.size < state.round_number):
            return Action.C
        previous_round_history = history.opponent_actions[-1]
        previous_cooperators = np.sum(previous_round_history)
        cooperation_threshold = 0.7 * (self.game_description.capacity - state.current_stock) / self.game_description.capacity
        adaptive_defection = False
        if history is not None:
            my_payoff = history.my_payoffs[-1]
            opponent_payoffs = history.opponent_payoffs[-1, :]
            average_opponent_payoff = np.mean(opponent_payoffs)
            adaptive_defection = my_payoff < 0.5 * average_opponent_payoff and state.current_stock > 0.8 * self.game_description.capacity
        if state.current_stock < 0.2 * self.game_description.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if previous_cooperators > cooperation_threshold and (not adaptive_defection):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_127(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that adapts to various opponent behaviors and game states.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_threshold = 3
        self.stock_high_threshold = 0.75 * game_description.capacity
        self.stock_low_threshold = 0.5 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number <= self.round_threshold:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock <= 1:
            return Action.C
        if state.current_stock > self.stock_high_threshold:
            return Action.C
        elif state.current_stock < self.stock_low_threshold:
            return Action.D
        probability_defect = (self.game_description.capacity - state.current_stock) / (0.5 * self.game_description.capacity)
        return Action.D if random.random() < probability_defect else Action.C
        opponent_actions = history.opponent_actions if history is not None else np.array([])
        average_opponent_cooperation_rate = np.mean(opponent_actions[-min(5, state.round_number):, :])
        if average_opponent_cooperation_rate > 0.7:
            cooperation_probability = 0.8 + (average_opponent_cooperation_rate - 0.7) * 0.2
            return Action.C if random.random() < cooperation_probability else Action.D
        elif average_opponent_cooperation_rate < 0.3:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_128(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history_p = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if history is not None:
            for opponent_action in history.opponent_actions[-1, :]:
                if opponent_action == 0:
                    self.history_p -= 0.01
                elif opponent_action == 1:
                    self.history_p += 0.01
        if current_stock >= 0.75 * capacity:
            return Action.C
        elif 0.5 * capacity <= current_stock < 0.75 * capacity:
            p = (current_stock / capacity) ** 2 + self.history_p
            p = max(0, min(p, 1))
            if random.random() < p:
                return Action.C
            else:
                return Action.D
        elif current_stock < 25 * capacity / 100:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_129(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Dynamic Threshold (ACDT)

    ACDT balances individual interests with collective sustainability, adapting to changing game conditions and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_consumption_rate = np.mean(np.sum(history.opponent_actions, axis=1) / self.game_description.n_players)
        if state.current_stock < self.game_description.capacity * self.threshold:
            self.threshold *= 0.9
        elif avg_consumption_rate > state.current_stock / (2 * self.game_description.n_players):
            self.threshold *= 1.1
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.2 * self.game_description.capacity:
            return Action.D
        if state.current_stock > self.game_description.capacity * self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_130(BaseStrategy):
    """
    A dynamic, adaptive strategy that balances individual self-interest with collective well-being.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        if state.round_number == 0 or history is None:
            return Action.C
        stock_ratio = current_stock / capacity
        prev_total_consumption = sum([current_stock / n_players if act else current_stock / (2 * n_players) for act in history.opponent_actions[-1, :]] + [current_stock / n_players if history.my_actions[-1] == Action.D else current_stock / (2 * n_players)])
        if stock_ratio > 0.75:
            return Action.C
        elif stock_ratio >= 0.5:
            if prev_total_consumption > 0.5 * capacity:
                return Action.D
            else:
                return Action.C
        else:
            prev_defection = history.my_actions[-1] == Action.D
            prev_low_consumption = prev_total_consumption < 0.25 * capacity
            if prev_defection or prev_low_consumption:
                return Action.D
            else:
                return Action.C
        if state.round_number + 1 == self.game_description.n_rounds:
            return Action.D
        if stock_ratio < 0.25 and all((act == Action.D for act in history.opponent_actions[-1, :])):
            return Action.C

class Strategy_COLLECTIVE_131(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that balances individual interests with the need to conserve the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stress_threshold = 0.3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_stress = (self.game_description.capacity - state.current_stock) / self.game_description.capacity
        if stock_stress < self.stress_threshold:
            action = Action.C
        else:
            action = Action.D
        if history:
            opponent_actions = np.where(history.opponent_actions[-1, :] == True, Action.C, Action.D)
            majority_defected = sum(opponent_actions) < len(opponent_actions) / 2
            majority_cooperated = sum(opponent_actions) > len(opponent_actions) / 2
            if majority_defected:
                self.stress_threshold -= 0.05
            elif majority_cooperated:
                self.stress_threshold += 0.05
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return action

class Strategy_COLLECTIVE_132(BaseStrategy):
    """
    Adaptive Stock Preservation strategy for Common Pool Resource Game.
    
    This strategy adapts to the stock level and opponents' actions, prioritizing 
    collective well-being by cooperating when the stock is high and defecting 
    with a probability proportional to the number of defectors in previous rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C
        if state.current_stock < 0.5 * self.game_description.capacity and state.round_number == 1:
            return Action.D
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        elif state.current_stock >= 0.5 * self.game_description.capacity:
            num_defectors = sum((not action for action in history.opponent_actions[-1, :]))
            defect_prob = num_defectors / (self.game_description.n_players - 1) if self.game_description.n_players > 1 else 1
            return Action.D if random.random() < defect_prob else Action.C
        elif state.current_stock < 0.5 * self.game_description.capacity:
            if all((not action for action in history.opponent_actions[-1, :])):
                return Action.C
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_133(BaseStrategy):
    """
    Adaptive Collective Conservation (ACC) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        prev_defections = sum((1 for opponent_action in history.opponent_actions[-1, :] if not opponent_action))
        if stock_level > 0.75:
            return Action.C
        elif prev_defections > self.game_description.n_players / 2:
            return Action.D
        elif stock_level < 0.25:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_134(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy to balance individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperate_prob = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.my_actions) > 0:
            previous_consumption = sum((self.game_description.n_players * self.consume(state.current_stock / self.game_description.n_players) for _ in range(self.game_description.n_players)))
            if previous_consumption > 0.5 * state.current_stock:
                self.cooperate_prob += 0.1
            elif previous_consumption <= 0.5 * state.current_stock:
                self.cooperate_prob -= 0.1
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio >= 0.75 or state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif stock_ratio < 0.25:
            return Action.D
        else:
            p_defect = 1 - stock_ratio
            return Action.D if random.random() < p_defect else Action.C

    def consume(self, stock: float) -> float:
        """
        Calculate consumption based on action.
        """
        return stock / self.game_description.n_players if True else stock / (2 * self.game_description.n_players)

class Strategy_COLLECTIVE_135(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Preservation.
    
    This strategy prioritizes preserving the common pool resource while adapting to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif np.all(history.opponent_actions[-1, :] == False):
            return Action.D
        elif state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        stock_threshold = 0.75 * self.game_description.capacity
        mid_threshold = 0.25 * self.game_description.capacity
        if state.current_stock >= stock_threshold:
            return Action.C
        elif state.current_stock < mid_threshold:
            return Action.D
        fc, fd = (np.sum(history.opponent_actions[-2:, :] == True), np.sum(history.opponent_actions[-2:, :] == False))
        trend = np.mean(np.diff([state.current_stock] + history.my_payoffs[-2:])) / self.game_description.n_players
        if fc >= fd + 1 or trend > 0:
            return Action.C
        else:
            return random.choice([Action.C, Action.D])

class Strategy_COLLECTIVE_136(BaseStrategy):
    """
    Adaptive Cooperation with Stock-based Threshold (ACS-ST) Strategy.

    This strategy balances individual payoffs with collective sustainability by cooperating when most opponents cooperate,
    and becoming more cautious when the stock-to-capacity ratio drops.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_actions = [None] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        s_ratio = state.current_stock / self.game_description.capacity
        ct = 0.6 if s_ratio > 0.75 else 0.4
        ocr = sum(history.opponent_actions[-1, :]) / self.game_description.n_players
        return Action.C if ocr >= ct else Action.D

class Strategy_COLLECTIVE_137(BaseStrategy):
    """
    A strategy that balances individual payoffs with collective sustainability of the common pool resource.
    It combines elements of tit-for-tat and adaptive strategies to respond to various opponent behaviors while conserving the stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if history is not None:
            opponent_actions = history.opponent_actions[-1, :]
            most_cooperated = sum(opponent_actions)
        else:
            most_cooperated = self.game_description.n_players // 2
        if history is not None and state.round_number > 0:
            opponent_actions_last_round = history.opponent_actions[-1, :]
            cooperators_last_round = sum(opponent_actions_last_round)
            cooperation_rate = cooperators_last_round / self.game_description.n_players
            if cooperation_rate > 0.75:
                self.threshold += 0.1
            elif cooperation_rate < 0.25:
                self.threshold -= 0.1
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C if most_cooperated > self.game_description.n_players / 2 else Action.D
        elif state.current_stock >= 0.5 * self.game_description.capacity and state.current_stock < 0.75 * self.game_description.capacity:
            return Action.C if any((not action for action in opponent_actions)) else Action.D
        else:
            return Action.D
        return Action.C if most_cooperated > self.threshold * self.game_description.n_players else Action.D

class Strategy_COLLECTIVE_138(BaseStrategy):
    """
    A collective strategy that adapts cooperation levels based on the current stock level and historical behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if state.round_number == 0:
            return Action.C if state.current_stock > 0.75 * capacity else Action.D
        avg_stock_rounds = min(5, state.round_number - 1)
        avg_stock = np.mean([state.current_stock] + history.my_payoffs[-avg_stock_rounds:])
        if avg_stock >= 0.67 * capacity:
            p_C = 0.8
        elif avg_stock >= 0.33 * capacity and avg_stock < 0.67 * capacity:
            p_C = 0.5
        else:
            return Action.D
        if state.current_stock == 0 or (history.my_actions.size > 2 and (not history.my_actions[-3:].any())):
            return Action.D
        if state.round_number + 1 == self.game_description.n_rounds:
            return Action.D
        if history.my_actions.size > 2 and (not history.my_actions[-3:].any()):
            p_C = 0.8
            random_coop = random.random()
            return Action.C if random_coop < p_C else Action.D
        return Action.C if random.random() < p_C else Action.D

class Strategy_COLLECTIVE_140(BaseStrategy):
    """
    The Adaptive Stock Conservation (ASC) strategy aims to balance individual payoffs with collective sustainability.
    It adapts to the game's state and history, promoting cooperation when beneficial for the group while avoiding over-exploitation of the common resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        n_cooperators = sum(opponent_actions)
        defect_threshold = self.game_description.capacity / 4 + (self.game_description.n_players - 1) * 0.01
        if state.current_stock >= self.game_description.capacity / 2:
            return Action.C
        elif state.current_stock < defect_threshold:
            return Action.D
        else:
            most_cooperated = n_cooperators > self.game_description.n_players / 2
            if most_cooperated:
                return Action.C
            else:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock >= self.game_description.capacity / 2:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_141(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Tit-for-Tat strategy.
    
    This strategy balances individual self-interest with collective sustainability by adapting to the game's state and history.
    It cooperates in initial rounds, defects when stock is low, and plays tit-for-tat based on previous round's actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        if current_stock > 0.75 * capacity:
            return Action.C
        elif 0.5 * capacity <= current_stock <= 0.75 * capacity:
            prev_round_coops = sum((1 for action in history.my_actions[-1:] + history.opponent_actions[-1, :].tolist() if action))
            if prev_round_coops >= n_players / 2:
                return Action.C
            else:
                return Action.D
        elif 0.25 * capacity < current_stock <= 0.5 * capacity:
            return Action.D
        else:
            return Action.C
        if round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_142(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Sensitive Trigger (ACST) strategy.
    
    This strategy adapts to the opponents' behaviors by adjusting its threshold based on the current stock level and opponents' actions.
    It prioritizes cooperation when the common pool resource is abundant, while ensuring a robust response to defectors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = None
        self.round_count = 0
        self.avg_payoff = 0.0

    def get_threshold(self, stock: float) -> float:
        """
        Calculate the stock-dependent threshold.
        
        If current stock is above capacity / 2, set T = capacity / (4n).
        Otherwise, set T = S / (2n).
        """
        if stock > self.game_description.capacity / 2:
            return self.game_description.capacity / (4 * self.game_description.n_players)
        else:
            return stock / (2 * self.game_description.n_players)

    def update_threshold(self) -> None:
        """
        Update the threshold every 5 rounds to reflect changes in opponents' behaviors.
        
        If average payoff over the last 5 rounds is above the initial capacity, increase T by 10%.
        Otherwise, decrease T by 10%.
        """
        if self.round_count % 5 == 0 and self.round_count > 0:
            if self.avg_payoff > self.game_description.capacity / self.game_description.n_players:
                self.threshold *= 1.1
            else:
                self.threshold /= 1.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock <= 0:
            return Action.D
        total_consumption_prev = np.sum(state.current_stock / (2 * self.game_description.n_players) * history.my_actions[-1] + state.current_stock / self.game_description.n_players * (not history.my_actions[-1]))
        self.update_threshold()
        if self.threshold is None or total_consumption_prev > 0:
            self.threshold = self.get_threshold(state.current_stock)
        if total_consumption_prev < self.threshold:
            return Action.C
        else:
            return Action.D
        self.avg_payoff += state.current_stock / (2 * self.game_description.n_players) * history.my_actions[-1]
        self.round_count += 1

class Strategy_COLLECTIVE_143(BaseStrategy):
    """
    Collective strategy that prioritizes cooperation when the stock level is high and adapts to opponents' behaviors when the stock level is moderate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        low_stock_threshold = 0.5 * self.game_description.capacity
        high_stock_threshold = 0.8 * self.game_description.capacity
        if state.current_stock > high_stock_threshold:
            return Action.C
        elif state.current_stock < low_stock_threshold:
            return Action.D
        else:
            opponent_actions = history.opponent_actions[-1, :]
            majority_behavior = np.mean(opponent_actions) >= 0.5
            return Action.C if majority_behavior else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_144(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Threshold (ACS) strategy.
    
    This dynamic, history-dependent strategy balances individual payoff maximization 
    with collective sustainability. It adapts to the current stock level, opponent behavior, 
    and game progress.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_threshold = self.capacity * (self.n_players - 1) / (2 * self.n_players)
        cooperation_tendency = state.current_stock > stock_threshold
        if history is not None:
            defections = np.sum(history.opponent_actions[:, :] == Action.D)
            if defections > self.game_description.n_players / 2:
                cooperation_tendency = False
        if state.round_number + 1 == self.game_description.n_rounds and state.current_stock > stock_threshold:
            return Action.C
        if cooperation_tendency:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_145(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Dependent Tit-for-Tat (ASDT) strategy for the Common Pool Resource Game.
    Balances cooperation and defection based on current stock level, previous rounds' outcomes, and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / 2
        self.opponent_actions_history = []
        self.previous_stock_level = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.previous_stock_level = state.current_stock
        if state.current_stock >= self.stock_threshold:
            return Action.C
        for i, opponent_action in enumerate(history.opponent_actions[-1, :]):
            if not opponent_action:
                return Action.D
        if state.current_stock < self.stock_threshold and any((not action for action in history.opponent_actions[-1, :])):
            return Action.D
        if self.previous_stock_level is not None and state.current_stock > self.previous_stock_level:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_146(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock Threshold (ACST)
    
    The ACST strategy aims to balance individual payoff maximization with collective sustainability 
    by adapting cooperation levels based on the current stock level and game history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.stock_threshold = self.capacity * (1 - 1 / self.n_players)
        self.cooperation_probability = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < 0.1 * self.capacity:
            return Action.D
        if history is not None and len(history.my_actions) > 0:
            previous_opponent_actions = history.opponent_actions[-1, :]
            all_cooperated = np.all(previous_opponent_actions)
            if all_cooperated:
                self.cooperation_probability = min(1, self.cooperation_probability + 0.1)
            else:
                self.cooperation_probability = max(0, self.cooperation_probability - 0.1)
        random_value = random.random()
        if state.current_stock > self.stock_threshold and random_value < self.cooperation_probability:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_147(BaseStrategy):
    """
    A collective strategy called "Adaptive Collective Harvesting" (ACH) 
    for the Common Pool Resource Game, designed to balance individual payoffs 
    with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold_high = 0.75 * game_description.capacity
        self.stock_threshold_low = 0.25 * game_description.capacity
        self.opponent_payoff_average = 0
        self.total_consumption_history = []
        self.stock_growth_history = []
        self.cooperation_frequency = 1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.current_stock >= self.stock_threshold_high:
            return Action.C
        elif state.current_stock <= self.stock_threshold_low:
            return Action.D
        elif history is not None and len(history.my_payoffs) > 0:
            opponent_payoff_average = np.mean(history.opponent_payoffs[-1, :])
            my_payoff = history.my_payoffs[-1]
            if opponent_payoff_average > my_payoff:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_148(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Conservation (ASC)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        threshold_high = 0.75 * self.game_description.capacity
        threshold_low = 0.25 * self.game_description.capacity
        if current_stock > threshold_high:
            return Action.C
        elif current_stock < threshold_low:
            return Action.D
        else:
            OCR_window = max(state.round_number // 2, 1)
            opponent_actions_window = history.opponent_actions[-OCR_window:]
            average_OCR = np.mean(opponent_actions_window)
            if average_OCR < 0.5:
                return Action.D
            else:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_149(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation (AC)

    This strategy balances individual self-interest with collective well-being,
    adapting to the dynamics of the game. By responding to the actions of others
    and the state of the stock, AC promotes a stable and cooperative outcome whenever possible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return random.choice([Action.C, Action.D])
        previous_round_actions = history.opponent_actions[-1, :]
        cooperation_threshold_50 = len(previous_round_actions[previous_round_actions == True]) / self.game_description.n_players
        cooperation_threshold_75 = len(previous_round_actions[previous_round_actions == True]) / (2 / 3 * self.game_description.n_players)
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C if sum(history.opponent_actions[-1, :]) >= self.game_description.n_players // 2 else Action.D
        elif state.current_stock > 0.5 * self.game_description.capacity:
            return Action.C if cooperation_threshold_50 >= 2 / 3 else Action.D
        else:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_150(BaseStrategy):
    """
    Adaptive Cooperation strategy for the Common Pool Resource Game.
    This strategy adapts to various opponent behaviors and prioritizes collective well-being when possible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_growth_rate = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        previous_round_stock = history.my_payoffs[-1] * self.game_description.n_players + current_stock
        if self.stock_growth_rate is None:
            self.stock_growth_rate = (current_stock - previous_round_stock) / previous_round_stock
        else:
            self.stock_growth_rate = 0.5 * self.stock_growth_rate + 0.5 * ((current_stock - previous_round_stock) / previous_round_stock)
        capacity = self.game_description.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif current_stock >= 0.75 * capacity:
            return Action.C
        elif 0.25 * capacity <= current_stock < 0.75 * capacity:
            p = (current_stock / capacity) ** 2
            if self.stock_growth_rate is not None and self.stock_growth_rate < 0:
                p *= 0.5
            return Action.C if random.random() < p else Action.D
        else:
            return Action.D
        if history.opponent_actions[-1, :].sum() >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_151(BaseStrategy):
    """
    Adaptive Cooperativity with Stock-Sensitive Defection (ACSSD) strategy.
    
    This strategy balances cooperation and defection based on the game's state and history to achieve a collective optimum.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if state.round_number == 0 or history is None:
            return Action.C
        my_actions = np.where(history.my_actions, 'C', 'D')
        recent_defections = sum((1 for action in my_actions[-3:] if action == 'D'))
        recent_cooperations = 3 - recent_defections
        weighted_payoffs = [payoff * (1 / (i + 1)) for i, payoff in enumerate(history.my_payoffs)]
        avg_payoff = sum(weighted_payoffs) / len(weighted_payoffs)
        threshold = capacity * 0.75
        if state.current_stock >= threshold:
            return Action.C
        if recent_defections > recent_cooperations:
            return Action.D
        if avg_payoff > capacity / (2 * n_players):
            return Action.C
        low_stock_threshold = capacity * 0.25
        if state.current_stock < low_stock_threshold:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_152(BaseStrategy):
    """
    The Adaptive Stock Conservation (ASC) strategy prioritizes collective stock conservation 
    while being adaptive to opponent behaviors and robust to a wide range of scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperate_threshold = 0.6
        self.critical_stock_threshold = 0.3 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions
        avg_opponent_cooperation_rate = np.mean(opponent_actions[-5:, :]) if state.round_number >= 5 else np.mean(opponent_actions[:, :])
        stock_change = state.current_stock - history.my_payoffs[state.round_number - 1] * self.game_description.n_players
        if stock_change > 0 or stock_change == 0:
            return Action.C
        elif stock_change < -0.2 * self.game_description.capacity:
            return Action.D
        if avg_opponent_cooperation_rate > self.cooperate_threshold:
            return Action.C
        else:
            return Action.D
        if state.current_stock < self.critical_stock_threshold:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.C

class Strategy_COLLECTIVE_154(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Dependent Threshold (ACSDT) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.payoff_history = []
        self.D_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        T = self.game_description.capacity * (1 - 0.5 * (self.game_description.n_players / (2 * self.game_description.n_players)))
        action = Action.D if state.current_stock <= T else Action.C
        payoff_threshold = self.game_description.capacity / (2 * self.game_description.n_players * self.game_description.n_rounds)
        if sum(self.payoff_history) < payoff_threshold:
            action = Action.D
        if history is not None and len(history.opponent_actions) > 0:
            recent_opponents = history.opponent_actions[-1, :]
            self.D_count = sum((1 for opponent in recent_opponents if not opponent))
            if self.D_count > self.game_description.n_players / 2:
                T *= 1.1
                action = Action.D if state.current_stock <= T else Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        if state.current_stock < self.game_description.capacity / 4:
            action = Action.C
        return action

    def update_payoff_history(self, payoffs, action, stock):
        payoff = stock / (2 * self.game_description.n_players) if action == Action.C else stock / self.game_description.n_players
        payoffs.append(payoff)
        return payoffs

class Strategy_COLLECTIVE_155(BaseStrategy):
    """
    This strategy adapts the cooperation threshold based on opponents' behavior,
    encouraging a mix of cooperation and defection that maintains a healthy stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.tau = 0.5
        self.opponent_cooperation_rate = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_cooperations = np.sum(history.opponent_actions, axis=1)
        self.opponent_cooperation_rate = np.mean(opponent_cooperations[-10:]) if state.round_number >= 10 else np.mean(opponent_cooperations)
        if self.opponent_cooperation_rate > 0.7:
            self.tau = min(0.9, self.tau + 0.1)
        elif self.opponent_cooperation_rate < 0.3:
            self.tau = max(0.1, self.tau - 0.1)
        if state.current_stock < self.game_description.capacity * self.tau:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > self.game_description.capacity * self.tau:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_156(BaseStrategy):
    """
    Adaptive Cooperative Harvesting (ACH) strategy.
    
    This strategy balances individual payoffs with collective sustainability in a dynamic common pool resource game.
    It adapts to changing stock levels, opponent behaviors, and game history while promoting cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        if state.round_number == 0:
            return Action.C
        low_stock_threshold = 0.25 * self.capacity
        high_stock_threshold = 0.75 * self.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        avg_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
        if current_stock > high_stock_threshold:
            return Action.D
        elif current_stock < low_stock_threshold:
            return Action.C
        elif avg_opponent_payoff > 0.5 * (current_stock / self.n_players):
            return Action.D
        else:
            return random.choice([Action.C, Action.D])

class Strategy_COLLECTIVE_157(BaseStrategy):
    """
    Adaptive Sustainability (AS) strategy, balancing individual self-interest with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        last_round = state.round_number >= self.game_description.n_rounds - 1
        critically_low_stock = state.current_stock < 0.25 * self.game_description.capacity
        if last_round or critically_low_stock:
            return Action.D
        if stock_level >= 0.75:
            return Action.C
        elif stock_level >= 0.5:
            p = stock_level ** 2
            return Action.C if random.random() < p else Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_159(BaseStrategy):
    """
    Collective strategy that balances individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < self.game_description.capacity / 2:
            return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        defectors = sum(1 - opponent_actions)
        if defectors > self.game_description.n_players / 2:
            return Action.D
        recent_payoffs = history.my_payoffs[-3:]
        if len(recent_payoffs) < 3:
            recent_payoffs = np.pad(recent_payoffs, (3 - len(recent_payoffs), 0))
        if all((recent_payoffs[i] >= recent_payoffs[i - 1] for i in range(1, len(recent_payoffs)))):
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 1e-06:
            return Action.C

class Strategy_COLLECTIVE_160(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock-Dependent Trigger (ACSDT)

    The ACSDT strategy aims to balance individual payoff maximization with collective sustainability of the common pool resource.
    It adapts to the game state and history, using a trigger mechanism to switch between cooperation and defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_depletion_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        T = 0.7 * self.game_description.capacity
        if state.current_stock >= T:
            action = Action.C
            self.consecutive_depletion_rounds = 0
        else:
            self.consecutive_depletion_rounds += 1
            if self.consecutive_depletion_rounds > 3:
                action = Action.C
            else:
                action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return action

class Strategy_COLLECTIVE_161(BaseStrategy):
    """
    Adaptive Stock Preservation (ASP) Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_level = state.current_stock / self.capacity
        if stock_level > 0.75:
            return Action.C
        elif stock_level < 0.5:
            return Action.D
        else:
            p = (stock_level - 0.5) / 0.25
            return Action.C if random.random() < p else Action.D
        opponent_actions = history.opponent_actions[-1, :]
        cooperators = sum(opponent_actions)
        if cooperators > self.game_description.n_players // 2:
            return Action.C
        elif cooperators == self.game_description.n_players // 2:
            return random.choice([Action.C, Action.D])
        else:
            p = cooperators / self.game_description.n_players
            return Action.C if random.random() < p else Action.D
        stock_trend = [state.current_stock - history.my_payoffs[i] for i in range(-3, 0)]
        if all((trend > 0 for trend in stock_trend)):
            pass
        elif any((trend < 0 for trend in stock_trend)):
            p = (stock_level - 0.5) / 0.25 * 0.95
            return Action.C if random.random() < p else Action.D
        if state.round_number == self.game_description.n_rounds:
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_162(BaseStrategy):
    """
    A collective strategy that balances individual payoff maximization with long-term stock conservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_threshold = game_description.capacity / 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        total_consumption = sum([history.my_payoffs[-1] / (self.game_description.capacity / self.game_description.n_players)] + [payoffs[-1] / (self.game_description.capacity / self.game_description.n_players) for payoffs in history.opponent_payoffs.T])
        n_defectors = sum((1 - actions[-1] for actions in [history.my_actions] + history.opponent_actions.T))
        if state.current_stock <= self.game_description.capacity / 2 or total_consumption > 3 * self.game_description.n_players / 4 or n_defectors > self.game_description.n_players / 2:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1 and state.current_stock < self.capacity_threshold:
            return Action.D
        if state.current_stock < 0.2 * self.game_description.capacity:
            return Action.C
        if all((actions[-1] == 0 for actions in [history.my_actions] + history.opponent_actions.T)):
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_163(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Trigger strategy for the Common Pool Resource Game.
    This strategy aims to balance individual and collective interests by cooperating when the stock level is above a certain threshold,
    adjusting the threshold in response to defections, and switching to defecting after consecutive rounds of defections from one or more players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.delta_T = 0.05 * self.capacity / self.n_players
        self.stock_threshold = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.stock_threshold is None:
            self.stock_threshold = 0.5 * self.capacity / self.n_players
        if state.current_stock > self.stock_threshold:
            action = Action.C
        else:
            action = Action.D
        if history and any((action == Action.D for action in history.opponent_actions[-1, :])):
            self.stock_threshold -= self.delta_T
            self.stock_threshold = max(self.stock_threshold, 0)
        consecutive_defections = sum((1 for round_actions in history.opponent_actions[-2:, :] if any((action == Action.D for action in round_actions))))
        if consecutive_defections >= 2:
            action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.C
        return action

class Strategy_COLLECTIVE_164(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Conservation (ASC)

    This strategy balances individual payoff maximization with collective stock conservation.
    It cooperates when the majority of opponents do so, adapts to changes in opponent behavior,
    and prioritizes individual payoff maximization in edge cases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_threshold = game_description.capacity / 2
        self.low_stock_level = game_description.capacity / 4

    def calculate_cooperators(self, history: PlayerHistory) -> int:
        return sum(~history.opponent_actions[-1, :])

    def calculate_growth_rate(self, history: PlayerHistory) -> float:
        current_stock = history.my_payoffs[-1] * self.game_description.n_players
        previous_stock = history.my_payoffs[-2] * self.game_description.n_players if len(history.my_payoffs) > 1 else self.game_description.capacity
        return (current_stock - previous_stock) / previous_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock <= self.low_stock_level:
            return Action.D
        if state.current_stock <= self.capacity_threshold:
            return Action.D
        cooperators = self.calculate_cooperators(history)
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        growth_rate = self.calculate_growth_rate(history) if len(history.my_payoffs) > 1 else float('inf')
        if growth_rate < 0:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_165(BaseStrategy):
    """
    Collective strategy that prioritizes cooperation when necessary to maintain the stock's sustainability,
    while adapting to opponent behavior and exploiting opportunities for short-term gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        exploiter_opponents = []
        for opponent_actions in history.opponent_actions.T:
            if np.sum(opponent_actions) / (state.round_number + 1) < 0.25:
                exploiter_opponents.append(True)
            else:
                exploiter_opponents.append(False)
        if state.round_number < self.game_description.n_rounds // 2:
            if state.current_stock > 0.75 * self.game_description.capacity:
                return Action.D
            elif any(exploiter_opponents):
                return Action.D
            else:
                return Action.C
        elif self.game_description.n_rounds // 2 <= state.round_number < self.game_description.n_rounds * 3 // 4:
            defector_count = np.sum(~history.opponent_actions[-1, :])
            if defector_count >= self.game_description.n_players // 2 or state.current_stock < 0.5 * self.game_description.capacity:
                return Action.C
            elif any(exploiter_opponents):
                return Action.D
            else:
                return Action.D
        elif state.current_stock > 0.25 * self.game_description.capacity and (not any(exploiter_opponents)):
            return Action.D
        else:
            return Action.C
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.C

class Strategy_COLLECTIVE_166(BaseStrategy):
    """
    Adaptive Common Pool Resource Management Strategy.

    This strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        low_threshold = 0.3 * self.game_description.capacity
        high_threshold = 0.7 * self.game_description.capacity
        if state.current_stock > high_threshold:
            return Action.C
        elif state.current_stock < low_threshold:
            return Action.D
        my_actions = history.my_actions[:state.round_number]
        hci = np.mean(my_actions) if len(my_actions) else 0.5
        opponent_history = history.opponent_actions[:state.round_number, :]
        opponent_defection_rates = np.mean(opponent_history == False, axis=0)
        for opponent_defect_rate in opponent_defection_rates:
            if opponent_defect_rate > 2 / 3:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if hci > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_167(BaseStrategy):
    """
    The ACD strategy aims to balance individual payoff maximization with collective stock sustainability.
    It adapts to the game state and history, while being robust to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.7
        self.recent_defection_response_window = 2
        self.defection_signal_threshold = 0.5
        self.stock_depletion_protection_threshold = game_description.capacity / 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        theta = state.current_stock / self.game_description.capacity
        if theta > self.cooperation_threshold:
            return Action.C
        recent_defections = sum((1 for action in history.my_actions[-self.recent_defection_response_window:] if not action))
        if recent_defections / self.recent_defection_response_window > self.defection_signal_threshold:
            return Action.D
        if state.current_stock < self.stock_depletion_protection_threshold:
            return Action.C
        opponent_payoffs = history.opponent_payoffs[-1, :]
        best_opponent_payoff = np.max(opponent_payoffs)
        own_payoff = history.my_payoffs[-1]
        if best_opponent_payoff > own_payoff * 1.2:
            imitated_opponent_actions = history.opponent_actions[-self.recent_defection_response_window:, np.argmax(opponent_payoffs)]
            return Action.C if sum(imitated_opponent_actions) / len(imitated_opponent_actions) > 0.5 else Action.D
        return Action.D if state.round_number < self.game_description.n_rounds - 1 else Action.C

class Strategy_COLLECTIVE_168(BaseStrategy):
    """
    The ACST strategy aims to balance individual payoffs with collective sustainability 
    by adapting cooperation levels based on the current stock level and history of opponent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_defection_rates = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        sdr = state.current_stock / self.game_description.capacity
        if sdr >= 0.5:
            action = Action.C
        else:
            action = Action.D
        opponent_actions_last_round = history.opponent_actions[-1, :]
        opponent_defection_rate = np.mean(opponent_actions_last_round == False)
        if len(self.opponent_defection_rates) >= 10:
            self.opponent_defection_rates.pop(0)
        self.opponent_defection_rates.append(opponent_defection_rate)
        avg_opponent_defection_rate = np.mean(self.opponent_defection_rates)
        if avg_opponent_defection_rate > 0.5:
            action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.C
        return action

class Strategy_COLLECTIVE_169(BaseStrategy):
    """
    A strategy that adapts to changing conditions in the common pool resource game.
    Cooperates when the stock level is high and adapts to opponent behavior by defecting with a probability proportional to the number of opponents who defected in the previous round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        high_threshold = 0.75 * self.game_description.capacity
        low_threshold = 0.5 * self.game_description.capacity
        current_stock = state.current_stock
        num_defectors_prev_round = sum(1 - history.opponent_actions[-1, :])
        if current_stock > high_threshold:
            return Action.C
        elif current_stock >= low_threshold:
            defect_prob = (num_defectors_prev_round / self.game_description.n_players) ** 2
            return Action.D if random.random() < defect_prob else Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_170(BaseStrategy):
    """
    A collective strategy that balances individual payoff maximization with cooperative behavior to maintain a sustainable common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.p_defect = 0.5
        self.opponent_cooperation_rate = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.capacity
        if stock_ratio > 0.75:
            return Action.C
        elif stock_ratio >= 0.5 and stock_ratio <= 0.75:
            defect_prob = (1 - stock_ratio) ** 2
            return Action.D if random.random() < defect_prob else Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if stock_ratio > 0.75:
                return Action.C
            else:
                return Action.D
        if history is not None and len(history.opponent_actions) > 0:
            recent_opponent_cooperations = np.sum(history.opponent_actions[-1, :])
            self.opponent_cooperation_rate = recent_opponent_cooperations / (self.n_players - 1)
            if self.opponent_cooperation_rate > 0.5:
                self.p_defect -= 0.1
            elif self.opponent_cooperation_rate < 0.5:
                self.p_defect += 0.1
                self.p_defect = min(self.p_defect, 0.5)

class Strategy_COLLECTIVE_171(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACS)
    
    This strategy adapts to changing game conditions and opponent behaviors while promoting cooperation.
    It balances individual payoffs with long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        C_prev = sum((1 for action in history.opponent_actions[-1, :] if not action))
        if state.current_stock < 0.5 * self.capacity or C_prev > 0.75 * self.n_players:
            return Action.D
        S = state.current_stock
        p_t = max(0.5, min(1, (S / self.capacity) ** 2))
        for action in history.opponent_actions[-1, :]:
            if not action:
                p_t -= 0.1
            else:
                p_t += 0.1
        return Action.C if random.random() < p_t else Action.D

class Strategy_COLLECTIVE_172(BaseStrategy):
    """
    A strategy that balances individual payoffs with long-term sustainability of the common pool resource.
    It adapts its behavior based on the current stock level, number of players, and game history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        if state.current_stock >= 0.75 * capacity:
            return Action.C
        elif state.current_stock < 0.5 * capacity:
            return Action.D
        probability = (capacity - state.current_stock) / (0.25 * capacity)
        if random.random() < probability:
            return Action.D
        else:
            return Action.C
        cooperation_ratio = np.sum(history.opponent_actions[-1, :]) / n_players
        if cooperation_ratio > 0.5:
            self.probability_to_cooperate += 0.1
        elif cooperation_ratio < 0.3:
            self.probability_to_cooperate -= 0.1
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_173(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Preservation (ASP)
    
    This strategy aims to balance individual payoffs with collective sustainability 
    by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1 or state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        if any(history.opponent_actions[-1, :]):
            return Action.D
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        elif 0.5 * self.game_description.capacity <= state.current_stock < 0.75 * self.game_description.capacity:
            p = (state.current_stock / self.game_description.capacity) ** 2
            return Action.C if random.random() < p else Action.D
        elif state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_174(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) Strategy for Common Pool Resource Game.
    
    This strategy balances individual payoff maximization with collective stock conservation, 
    adapting to various opponent behaviors and game states.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.triggered = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        stock_percentage = state.current_stock / self.game_description.capacity
        if stock_percentage >= 0.75:
            self.triggered = False
            return Action.C
        if 0.5 <= stock_percentage < 0.75:
            p = stock_percentage ** 2
            if random.random() < p:
                self.triggered = False
                return Action.C
            else:
                return Action.D
        if stock_percentage < 0.5:
            return Action.D
        if history is not None:
            opponent_defected = np.any(~history.opponent_actions[-1, :])
            if opponent_defected and state.current_stock < 0.75 * self.game_description.capacity:
                self.triggered = True
            elif np.all(history.my_actions[-2:]) and np.all(history.my_actions[-2:] == history.opponent_actions[-2:, 0]):
                self.triggered = False
        if self.triggered:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_175(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with collective sustainability 
    by dynamically adjusting cooperation levels based on game state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_health = state.current_stock / self.game_description.capacity
        defect_threshold = 0.5 - 1 / (2 * self.game_description.n_players) + 1 / (2 * (self.game_description.n_rounds - state.round_number))
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock_health < 0.2:
            return Action.D
        if stock_health > defect_threshold:
            return Action.C
        else:
            defection_probability = 1 - stock_health
            return Action.D if random.random() < defection_probability else Action.C

class Strategy_COLLECTIVE_176(BaseStrategy):
    """
    Adaptive Cooperation with Stock Threshold (ACST) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.7 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock >= self.threshold:
            action = Action.C
        else:
            action = Action.D
        all_cooperated = np.all(history.opponent_actions[-1, :] == 1)
        stock_growth = state.current_stock - history.my_payoffs[-1] * self.game_description.n_players / (self.game_description.capacity * 2)
        if all_cooperated and stock_growth > 0:
            self.threshold *= 1.05
        elif not all_cooperated and stock_growth < 0:
            self.threshold *= 0.9
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return action

class Strategy_COLLECTIVE_177(BaseStrategy):
    """
    Adaptive Cooperative Escalation (ACE) strategy prioritizes collective well-being by adapting to the group's behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        coop_prob = 0.5
        for opponent_action in history.opponent_actions[-1]:
            if opponent_action and history.my_payoffs.size != history.opponent_payoffs.shape[1]:
                coop_prob += 0.1
        if state.current_stock > self.game_description.capacity / 2:
            coop_prob *= 1.1
        elif state.current_stock < self.game_description.capacity / 4:
            coop_prob *= 0.8
        if any((not opponent_action for opponent_action in history.opponent_actions[-1])) and sum((1 for opponent_action in history.opponent_actions[-1] if opponent_action)) >= self.game_description.n_players * 0.75:
            coop_prob = 0.5
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < self.game_description.capacity / 10:
            return Action.D
        return Action.C if random.random() < coop_prob else Action.D

class Strategy_COLLECTIVE_178(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Sensitivity (ATTS) strategy.
    
    This collective strategy balances individual self-interest with collective well-being by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_C = np.mean(history.my_payoffs[history.my_actions])
        avg_D = np.mean(history.my_payoffs[~history.my_actions])
        opponents_previous_round_payoff = history.opponent_payoffs[-1]
        opponents_previous_round_action = history.opponent_actions[-1]
        defector_index = np.where((opponents_previous_round_action == 0) & (opponents_previous_round_payoff > avg_C))
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        elif state.round_number + 1 >= self.game_description.n_rounds:
            return Action.D
        elif avg_C >= 0.8 * self.game_description.capacity / self.game_description.n_players:
            return Action.C
        elif len(defector_index[0]) > 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_179(BaseStrategy):
    """
    The Adaptive Stock Preservation (ASP) strategy prioritizes long-term sustainability over short-term gains.
    It adapts to opponents' behaviors and conserves the stock when necessary, promoting a collective mindset 
    that balances individual payoffs with the need to maintain a healthy common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < self.game_description.n_players:
            return Action.C
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :] if history else []
        defect_prob = sum((1 for action in opponent_actions if not action)) / self.game_description.n_players
        stock_level = state.current_stock / self.game_description.capacity
        if stock_level >= 0.75:
            return Action.C
        elif 0.5 <= stock_level < 0.75:
            return Action.D if random.random() < defect_prob else Action.C
        elif stock_level < 0.5:
            return Action.C
        if self.game_description.n_rounds - self.game_description.n_players <= state.round_number <= self.game_description.n_rounds:
            defect_prob = (state.round_number - (self.game_description.n_rounds - self.game_description.n_players)) / self.game_description.n_players
            return Action.D if random.random() < defect_prob else Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_180(BaseStrategy):
    """
    Collective strategy: Adaptive Stock Conservation (ASC)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.upper_threshold = 0.75 * self.capacity
        self.lower_threshold = 0.25 * self.capacity
        self.cooperation_probability = 1.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and state.round_number < self.game_description.n_players):
            return Action.C
        if history is not None:
            previous_stock = history.my_payoffs[-1] * 2 * self.game_description.n_players
            stock_decreased_significantly = (previous_stock - state.current_stock) / previous_stock > 0.1
            if state.current_stock >= self.upper_threshold or state.current_stock <= self.lower_threshold:
                self.cooperation_probability = max(0, self.cooperation_probability - 0.2)
            elif not stock_decreased_significantly:
                self.cooperation_probability = min(1, self.cooperation_probability + 0.1)
        if random.random() < self.cooperation_probability:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1 or state.current_stock < self.lower_threshold:
            return Action.D

class Strategy_COLLECTIVE_181(BaseStrategy):
    """
    Collective strategy to balance individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        threshold = capacity / (2 * n_players)
        if current_stock > threshold:
            return Action.C
        defection_rate = (threshold - current_stock) / (capacity - threshold)
        defect_prob = min(defection_rate, 1)
        if history is not None:
            prev_opponent_actions = history.opponent_actions[-1]
            most_opponents_cooperated = sum(prev_opponent_actions) > len(prev_opponent_actions) / 2
            if most_opponents_cooperated:
                return Action.C
            elif sum(prev_opponent_actions) < len(prev_opponent_actions) / 2:
                defection_rate *= 1.5
        n_rounds = self.game_description.n_rounds
        if round_number > n_rounds - 5:
            if current_stock > capacity * 0.8:
                return Action.C
            else:
                return Action.D
        return Action.D if random.random() < defection_rate else Action.C

class Strategy_COLLECTIVE_182(BaseStrategy):
    """
    Adaptive Sustainable Harvesting strategy for the Common Pool Resource game.
    This strategy prioritizes sustainable harvesting while being responsive to opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if random.random() < 0.7 else Action.D
        stock_level = state.current_stock
        capacity = self.game_description.capacity
        num_opponents = self.game_description.n_players - 1
        opponent_actions = history.opponent_actions[-1, :] if history is not None else []
        if stock_level > 0.75 * capacity:
            return Action.C
        elif 0.5 <= stock_level / capacity < 0.75:
            defect_prob = sum(opponent_actions) / num_opponents if opponent_actions.size > 0 else 0
            return Action.D if random.random() < defect_prob else Action.C
        else:
            return Action.C
        frequent_defectors = sum((1 for action in opponent_actions if action == Action.D)) / num_opponents if num_opponents > 0 else 0
        frequent_cooperators = sum((1 for action in opponent_actions if action == Action.C)) / num_opponents if num_opponents > 0 else 0
        if frequent_defectors >= 0.6:
            return Action.D
        elif frequent_cooperators >= 0.6:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C if random.random() < 0.5 else Action.D

class Strategy_COLLECTIVE_183(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Preservation (ASP)

    This strategy aims to balance individual payoffs with collective stock preservation,
    ensuring a sustainable game environment. It adapts to changing opponent behaviors and
    adjusts cooperation levels accordingly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_probability = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < 3:
            return Action.C
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        CT = current_stock / (2 * n_players * (1 - (current_stock / capacity) ** 2))
        if history is not None:
            opponent_actions = history.opponent_actions[-n_players:]
            opponent_cooperation = np.mean(opponent_actions)
            if opponent_cooperation > 0.5:
                self.cooperation_probability += 0.1
            else:
                self.cooperation_probability -= 0.2
        if current_stock < capacity / 2:
            self.cooperation_probability += 0.1
        elif current_stock > capacity / 2:
            self.cooperation_probability -= 0.1
        if random.random() < self.cooperation_probability or CT > 0.5:
            return Action.C
        else:
            return Action.D

    def last_round(self, state: CommonPoolState) -> Action:
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_stock < capacity / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_184(BaseStrategy):
    """
    The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consumption_history = []
        self.stock_thresholds = {'conservation': 0.75 * game_description.capacity, 'alarm': 0.25 * game_description.capacity}
        self.opponent_actions = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.consumption_history.append(state.current_stock)
            for i in range(self.game_description.n_players - 1):
                if history.opponent_actions.shape[0] > state.round_number:
                    self.opponent_actions.append(history.opponent_actions[state.round_number - 1, i])
        if len(self.consumption_history) == 0:
            return Action.C
        current_stock = self.consumption_history[-1]
        if current_stock >= self.stock_thresholds['conservation']:
            return Action.C
        elif current_stock <= self.stock_thresholds['alarm']:
            return Action.C
        else:
            free_riders = sum([opponent < 0.5 for opponent in np.mean(self.opponent_actions, axis=0)]) if len(self.opponent_actions) > 0 else 0
            defect_prob = 0.75 if free_riders > 0 else (self.game_description.n_rounds - state.round_number + 1) / self.game_description.n_rounds
            recent_stock_trend = np.mean(np.array(self.consumption_history[-3:]) if len(self.consumption_history) >= 3 else [current_stock] * 3)
            if current_stock < recent_stock_trend:
                return Action.C
            if random.random() < defect_prob:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_185(BaseStrategy):
    """
    Collective strategy: Adaptive Stock Conservation (ASC).
    Balances individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock_per_player = state.current_stock / self.game_description.n_players
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock <= 0.25 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C
        if current_stock_per_player >= 0.75 * self.game_description.capacity / self.game_description.n_players:
            return Action.C
        elif current_stock_per_player <= 0.25 * self.game_description.capacity / self.game_description.n_players:
            return Action.D
        else:
            p = (state.current_stock - 0.5 * self.game_description.capacity) / (self.game_description.capacity - 0.5 * self.game_description.capacity)
            if random.random() < p:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_186(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Dependent Threshold strategy.
    
    This strategy adapts to changes in the game's state and opponent behavior by adjusting 
    a cooperation threshold based on stock trends and opponent actions. It aims to balance 
    individual self-interest with collective well-being while being robust to various 
    opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_threshold = 0.5
        self.stock_threshold = self.initial_threshold * game_description.capacity
        self.decrease_threshold_fraction = 0.05

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.calculate_new_threshold(state.current_stock, history)
        if state.current_stock > self.stock_threshold:
            return Action.C
        else:
            return Action.D

    def calculate_new_threshold(self, new_stock: float, history: PlayerHistory):
        previous_stock = history.my_payoffs.shape[0] > 1 and history.opponent_payoffs[-2, :].sum() or self.game_description.capacity
        if new_stock >= previous_stock:
            self.stock_threshold -= self.decrease_threshold_fraction * self.game_description.capacity
        else:
            self.stock_threshold += self.decrease_threshold_fraction * self.game_description.capacity
        self.stock_threshold = max(0, min(self.stock_threshold, self.game_description.capacity))
        if history.opponent_actions[-1].sum() >= self.game_description.n_players // 2:
            self.stock_threshold -= self.decrease_threshold_fraction * self.game_description.capacity
        else:
            self.stock_threshold += self.decrease_threshold_fraction * self.game_description.capacity
        self.stock_threshold = max(0, min(self.stock_threshold, self.game_description.capacity))

class Strategy_COLLECTIVE_187(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock-Dependent Cooperation (ATSC) Strategy.
    
    This strategy promotes cooperation while adapting to changing circumstances and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determine the next action based on the current state and history.
        
        :param state: The current state of the game (round number and stock level).
        :param history: The player's history in the game (actions, payoffs, opponent actions, and opponent payoffs).
        :return: The chosen action (either Cooperate or Defect).
        """
        if state.round_number == 0:
            return Action.C
        else:
            cooperators = sum(history.opponent_actions[-1, :])
            cr = cooperators / self.game_description.n_players
            ct = state.current_stock / self.game_description.capacity * 0.5
            if state.round_number == self.game_description.n_rounds - 1:
                return Action.D
            elif state.current_stock < 0.25 * self.game_description.capacity:
                return Action.C
            if cr >= ct:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_188(BaseStrategy):
    """
    Adaptive Collective Conservation (ACC) Strategy for Common Pool Resource Game.

    This strategy promotes collective conservation by cooperating initially, 
    adapting to changing game conditions, and shifting to defection when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        previous_stock = history.my_payoffs[-1] * self.game_description.n_players
        current_stock = state.current_stock
        if all(history.my_actions) and all((np.all(opponent_actions == True, axis=0) for opponent_actions in history.opponent_actions)):
            return Action.C
        if (previous_stock - current_stock) / self.game_description.capacity > 0.2 or not all(history.my_actions):
            return Action.D
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        rounds_remaining = self.game_description.n_rounds - state.round_number
        if rounds_remaining <= 0.1 * self.game_description.n_rounds:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_189(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Aware Tit-for-Tat (ACST) strategy.

    This strategy prioritizes collective well-being by balancing short-term gains with long-term sustainability.
    It adapts to the current stock level and opponents' actions, aiming to maintain a healthy stock level for future rounds,
    encourage cooperation when possible, and punish defectors to maintain fairness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round_actions = history.opponent_actions[-1, :]
        majority_cooperated = np.sum(previous_round_actions) >= self.game_description.n_players / 2
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        elif 0.25 * self.game_description.capacity <= state.current_stock <= 0.75 * self.game_description.capacity:
            if majority_cooperated or np.sum(previous_round_actions) == self.game_description.n_players / 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_190(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that adapts to changing stock levels and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_recovery_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        T = self.game_description.capacity * (1 - 1 / (self.game_description.n_players + 1))
        if state.current_stock >= T and self.stock_recovery_rounds_remaining <= 0:
            if state.round_number >= self.game_description.n_rounds * 0.9:
                if state.current_stock > T:
                    return Action.C
                else:
                    return random.choice([Action.C, Action.D])
            elif history.opponent_actions[-1].sum() == 0:
                return random.choice([Action.C, Action.D])
            else:
                defectors_last_round = self.game_description.n_players - history.opponent_actions[-1].sum()
                P_defect = defectors_last_round / self.game_description.n_players
                if random.random() < P_defect:
                    return Action.D
                return Action.C
        if state.current_stock < self.game_description.capacity / 2 and self.stock_recovery_rounds_remaining <= 0:
            self.stock_recovery_rounds_remaining = 2
            return Action.C
        if self.stock_recovery_rounds_remaining > 0:
            self.stock_recovery_rounds_remaining -= 1
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_191(BaseStrategy):
    """
    Adaptive Stock Conservation strategy.

    This strategy aims to balance individual payoff maximization with collective sustainability of the common pool resource.
    It adapts to changing game conditions and opponent behaviors while promoting cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        half_capacity = self.game_description.capacity / 2
        cooperated_last_round = sum(history.opponent_actions[-1, :]) >= len(history.opponent_actions[-1, :]) // 2
        defected_last_round = any((not action for action in history.opponent_actions[-1, :]))
        if state.current_stock > half_capacity:
            if cooperated_last_round:
                return Action.C
            else:
                return Action.D
        elif state.current_stock < half_capacity:
            if defected_last_round:
                return Action.D
            else:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if sum(history.opponent_actions[-1, :]) == len(history.opponent_actions[-1, :]) // 2:
            if state.current_stock > self.game_description.capacity * 0.75:
                return Action.C
            else:
                return Action.D
        if any((not action for action in history.opponent_actions[-1, :])):
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_192(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy balances individual self-interest with collective responsibility.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.theta = game_description.capacity / (game_description.n_players + 1)
        self.phi = game_description.capacity / (4 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        S = state.current_stock
        opponents_cooperated = sum(history.opponent_actions[-1, :])
        if S > self.theta and (not state.round_number + 1 == self.game_description.n_rounds):
            action = Action.C
        elif opponents_cooperated > self.game_description.n_players / 2:
            action = Action.C
        else:
            action = Action.D
        if S < self.phi:
            action = Action.C
        return action

class Strategy_COLLECTIVE_193(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with long-term stock sustainability.
    Combines elements of cooperation, reciprocity, and adaptive learning to handle various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_index = np.zeros(game_description.n_players - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            for i, action in enumerate(history.opponent_actions[-1, :]):
                self.cooperation_index[i] = (self.cooperation_index[i] * state.round_number + action) / (state.round_number + 1)
        current_stock_ratio = state.current_stock / self.game_description.capacity
        if current_stock_ratio > 0.5:
            p = math.sqrt(current_stock_ratio)
            q = 1 - p
        else:
            q = (1 - current_stock_ratio) ** 2
            p = 1 - q
        avg_ci = np.mean(self.cooperation_index)
        if avg_ci > 0.6:
            p += 0.05
            q -= 0.05
        elif avg_ci < 0.4:
            p -= 0.05
            q += 0.05
        if random.random() < p:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D

class Strategy_COLLECTIVE_194(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACSDT)
    
    Balances individual payoffs with collective sustainability by adapting cooperation levels 
    based on the current stock level and history of play.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_prob = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        θ = self.game_description.capacity / (2 * self.game_description.n_players)
        Δp = 0.1 if state.current_stock >= history.my_payoffs[-1] else -0.2
        self.cooperation_prob = max(0.1, min(0.9, self.cooperation_prob + Δp))
        if history.opponent_actions[-1].any():
            self.cooperation_prob -= 0.3
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < self.game_description.capacity / (4 * self.game_description.n_players):
            return Action.D
        return Action.C if random.random() < self.cooperation_prob else Action.D

class Strategy_COLLECTIVE_195(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with stock conservation.
    Adapts to the game's state and history by defining cooperation and defection zones.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        low_threshold = 0.5 * self.game_description.capacity
        high_threshold = 0.8 * self.game_description.capacity
        if state.current_stock > high_threshold:
            return Action.C
        elif state.current_stock < low_threshold:
            return Action.D
        else:
            if history is None or len(history.my_actions) == 0:
                return Action.C
            opponent_cooperation_count = np.sum(np.logical_not(history.opponent_actions), axis=1)
            avg_opponent_coop_rate = np.mean(opponent_cooperation_count[-1])
            if avg_opponent_coop_rate > 0.5:
                return Action.C
            else:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_196(BaseStrategy):
    """
    Adaptive Collective Conservation (ACC) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_count = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.cooperation_count is None:
            self.cooperation_count = [False] * self.game_description.n_players
        for i, action in enumerate(history.opponent_actions[-1, :]):
            self.cooperation_count[i] = bool(action)
        if state.round_number <= 5:
            if sum(self.cooperation_count) >= self.game_description.n_players / 2 and state.current_stock >= 0.75 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        elif sum(self.cooperation_count) >= self.game_description.n_players / 2 and state.current_stock >= 0.5 * self.game_description.capacity:
            return Action.C
        elif sum([not x for x in self.cooperation_count]) > self.game_description.n_players / 2 or state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1 and state.current_stock >= 0.5 * self.game_description.capacity:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity and history.my_payoffs[-1] > 0:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_197(BaseStrategy):
    """
    Adaptive Cooperation with Stock Feedback (ACSF) strategy for the Common Pool Resource Game.
    
    This collective strategy balances individual self-interest with collective sustainability by adapting cooperation levels based on the current stock level and history of play.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_count = 0
        self.history_payoffs = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.round_count += 1
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio >= 0.75:
            p_C = 1.0
        elif stock_ratio >= 0.5:
            p_C = stock_ratio - 0.5 + 0.25
        else:
            p_C = 0.0
        if history is not None and len(self.history_payoffs) > 1:
            avg_payoff_last_2_rounds = np.mean(np.array(self.history_payoffs)[-2:])
            expected_coop_payoff = state.current_stock / (2 * self.game_description.n_players)
            if avg_payoff_last_2_rounds > expected_coop_payoff:
                p_C += 0.1
                p_C = min(p_C, 1)
            else:
                p_C -= 0.1
                p_C = max(p_C, 0)
        if random.random() < p_C:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_198(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock-Awareness (ACS)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        SAT = self.capacity / (2 * self.n_players)
        if state.round_number == 0:
            return Action.C
        if current_stock > SAT:
            cooperation_level = 1.0
        else:
            cooperation_level = max(0.0, 1 - (SAT - current_stock) / SAT)
        if history is not None and len(history.opponent_actions):
            opponent_cooperations = np.sum(history.opponent_actions[-1, :])
            if opponent_cooperations >= self.n_players // 2:
                cooperation_level *= 1.1
            else:
                cooperation_level *= 0.9
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if random.random() < cooperation_level:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_199(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Dependent Threshold (ACSDT) strategy.
    
    Balances individual payoff maximization with collective sustainability by adapting cooperation levels based on the current stock level and game history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        capacity = self.game_description.capacity
        stock = state.current_stock
        theta = stock / capacity
        if theta >= 0.5:
            return Action.C
        elif state.round_number + 1 == self.game_description.n_rounds:
            return Action.C
        elif stock <= self.game_description.n_players:
            return Action.D
        else:
            p = theta
            return Action.D if random.random() < p else Action.C

class Strategy_COLLECTIVE_201(BaseStrategy):
    """
    Adaptive Cooperation with Stock Threshold (ACST) strategy.

    This strategy prioritizes cooperation when the stock is relatively high, 
    ensuring that players contribute to its sustainability. When the stock is low, 
    it adapts by defecting or cooperating based on previous consumption patterns and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        prev_round = history.my_actions.shape[0] - 1
        my_prev_action = history.my_actions[prev_round]
        opp_prev_actions = history.opponent_actions[prev_round, :]
        prev_consumption = self.prev_round_total_consumption(state.current_stock + self.stock_depletion(prev_round, history), my_prev_action, opp_prev_actions)
        if state.current_stock >= self.game_description.capacity / 2:
            return Action.C
        elif prev_consumption <= self.game_description.capacity / 4:
            return Action.D
        elif any(history.opponent_actions[prev_round, :]):
            return Action.C
        else:
            return Action.D

    def prev_round_total_consumption(self, stock, my_action, opp_actions):
        consumption = self.game_description.n_players / (2 * self.game_description.n_players) * stock
        if not my_action:
            consumption += stock / self.game_description.n_players
        for action in opp_actions:
            if action:
                consumption += stock / (2 * self.game_description.n_players)
            else:
                consumption += stock / self.game_description.n_players
        return consumption

    def stock_depletion(self, round_number, history):
        depletion = 0.0
        for i in range(round_number + 1):
            my_action = history.my_actions[i]
            opp_actions = history.opponent_actions[i, :]
            if my_action:
                depletion += self.game_description.capacity / (2 * self.game_description.n_players)
            else:
                depletion += self.game_description.capacity / self.game_description.n_players
            for action in opp_actions:
                if action:
                    depletion += self.game_description.capacity / (2 * self.game_description.n_players)
                else:
                    depletion += self.game_description.capacity / self.game_description.n_players
        return depletion

class Strategy_COLLECTIVE_202(BaseStrategy):
    """
    Adaptive Collective Harvesting strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_probability = 1.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        previous_round_defections = sum((1 for opponent_action in history.opponent_actions[-1, :] if not opponent_action))
        if previous_round_defections > self.game_description.n_players / 2:
            self.cooperation_probability *= 0.8
            return Action.D
        elif previous_round_defections > 0:
            if random.random() < self.cooperation_probability:
                return Action.C
            else:
                return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            while state.current_stock < 0.5 * self.game_description.capacity:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1 and state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        if self.game_description.n_players <= 2:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_203(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACSDT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_payoff_avg = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_payoffs = np.mean(history.opponent_payoffs[-1, :] + history.my_payoffs[-1])
        self.prev_payoff_avg = avg_payoffs if self.prev_payoff_avg is None else self.prev_payoff_avg * 0.9 + avg_payoffs * 0.1
        stock_fraction = state.current_stock / self.game_description.capacity
        threshold = 0.5 + (1 - self.prev_payoff_avg / (self.game_description.capacity / self.game_description.n_players)) * 0.25
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        if stock_fraction > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_204(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Threshold Strategy.

    Cooperates initially to establish a baseline for collective behavior and encourage cooperation.
    In subsequent rounds, adjusts behavior based on the previous round's outcomes. If many players defected,
    lowers the cooperation threshold to avoid over-exploitation of the common pool. Conversely, if most players
    cooperated, raises the threshold to maintain a healthy stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        total_defections_last_round = sum((not action for action in history.opponent_actions[-1, :]))
        SBT = capacity / (2 * n_players * (1 + total_defections_last_round / n_players))
        if state.current_stock > SBT:
            return Action.C
        else:
            if state.round_number == self.game_description.n_rounds - 1:
                return Action.C
            low_stock_threshold = capacity * 0.2
            if state.current_stock < low_stock_threshold:
                return Action.D
            return Action.D

class Strategy_COLLECTIVE_205(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with long-term sustainability of the common pool resource.
    It combines elements of cooperation, defection, and adaptiveness to achieve this goal.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.early_rounds_threshold = math.ceil(game_description.n_rounds / 2)
        self.p_cooperate = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_defected_last_round = np.any(history.opponent_actions[-1, :])
        opponents_cooperated_unconditionally = np.all([opp for opp in history.opponent_actions[:-1]])
        if state.current_stock == 0:
            return Action.C
        if opponents_cooperated_unconditionally:
            return Action.C
        if state.current_stock >= self.game_description.capacity / 2 and state.round_number < self.early_rounds_threshold:
            if random.random() < self.p_cooperate:
                return Action.C
            elif opponents_defected_last_round:
                return Action.D
            else:
                return Action.C
        if state.current_stock < self.game_description.capacity / 2 and state.round_number >= self.early_rounds_threshold:
            if state.current_stock < self.game_description.capacity / 4:
                return Action.C
            opponents_defected_last_round = np.any(history.opponent_actions[-1, :])
            two_or_more_cooperated_last_round = np.sum([opp for opp in history.opponent_actions[-1, :]]) >= 2
            if opponents_defected_last_round or two_or_more_cooperated_last_round:
                return Action.D
            else:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1 or state.round_number == self.game_description.n_rounds:
            if state.current_stock < self.game_description.capacity / 4:
                return Action.C
            opponents_defected_last_round = np.any(history.opponent_actions[-1, :])
            if opponents_defected_last_round:
                return Action.D
            else:
                if state.round_number == self.game_description.n_rounds:
                    return Action.D
                return Action.C
        return Action.C

class Strategy_COLLECTIVE_206(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Conservation (ASC)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock = game_description.capacity
        self.avg_payoff_prev_round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_defected = np.any(history.opponent_actions[-1, :] == False)
        payoff_i_prev_round = self.calculate_payoff(state.current_stock, Action.C)
        avg_payoffs_prev_round = np.mean(history.my_payoffs)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock >= 0.75 * self.game_description.capacity and avg_payoffs_prev_round >= 0.5 * (self.game_description.capacity / (2 * self.game_description.n_players)):
            action = Action.C
        elif state.current_stock < 0.25 * self.game_description.capacity or (payoff_i_prev_round > avg_payoffs_prev_round and opponent_defected):
            action = Action.D
        else:
            action = Action.C
        if action == Action.C:
            consumption = state.current_stock / (2 * self.game_description.n_players) * 0.9
        else:
            consumption = state.current_stock / self.game_description.n_players
        total_consumption = consumption * self.game_description.n_players
        new_stock = max(0, state.current_stock - total_consumption)
        growth = 2 * new_stock * (1 - new_stock / self.game_description.capacity)
        self.stock = min(new_stock + growth, self.game_description.capacity)
        payoff_i = consumption if action == Action.C else state.current_stock / self.game_description.n_players
        self.avg_payoff_prev_round = (self.avg_payoff_prev_round * (self.game_description.n_players - 1) + payoff_i) / self.game_description.n_players
        return action

    def calculate_payoff(self, stock: float, action: Action):
        if action == Action.C:
            return stock / (2 * self.game_description.n_players)
        else:
            return stock / self.game_description.n_players

class Strategy_COLLECTIVE_207(BaseStrategy):
    """
    Adaptive Sustainability (AS) strategy balances individual self-interest with cooperative behavior to ensure long-term sustainability of the common resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        threshold = 0.3 * self.game_description.capacity
        opponent_cooperation_rate = self.calculate_opponent_cooperation(history)
        if state.current_stock < threshold:
            return Action.C
        elif opponent_cooperation_rate > 0.5:
            return Action.D
        else:
            return Action.C

    def calculate_opponent_cooperation(self, history: PlayerHistory) -> float:
        cooperation_count = sum([1 if np.sum(history.opponent_actions[round, :]) > self.game_description.n_players / 2 else 0 for round in range(len(history.my_actions))])
        return cooperation_count / len(history.my_actions)

class Strategy_COLLECTIVE_208(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with the need to sustain the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        current_stock, capacity = (state.current_stock, self.game_description.capacity)
        if current_stock > 0.75 * capacity:
            return Action.C
        elif 0.5 * capacity <= current_stock < 0.75 * capacity:
            p = (current_stock / capacity) ** 2
            return Action.C if random.random() < p else Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_209(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) Strategy.
    
    This strategy balances individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        stock_threshold_coop = 0.75 * capacity
        low_stock_coop = 0.25 * capacity
        max_payoff_per_round = capacity / (2 * n_players)
        if np.any(~history.opponent_actions[-1, :]):
            return Action.D
        if state.current_stock >= stock_threshold_coop:
            return Action.C
        if state.current_stock <= low_stock_coop:
            return Action.C
        avg_payoff = np.mean(history.my_payoffs[-3:]) / n_players
        if avg_payoff >= max_payoff_per_round:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_210(BaseStrategy):
    """
    Adaptive Stock Conservation Strategy.
    
    This strategy aims to balance individual payoffs with collective sustainability 
    by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        total_consumption = sum([self.game_description.capacity / self.game_description.n_players * (1 - action) for action in history.opponent_actions[-1, :]]) + state.current_stock / (2 * self.game_description.n_players)
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        elif state.current_stock <= 0.25 * self.game_description.capacity:
            return Action.D
        elif total_consumption > 0.5 * self.game_description.capacity:
            return Action.D
        if self.previous_stock is not None and (state.current_stock - self.previous_stock) / self.previous_stock >= 0.1:
            return Action.C
        return Action.D

    def update_state(self, state: CommonPoolState):
        self.previous_stock = state.current_stock

class Strategy_COLLECTIVE_211(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Dynamic Stock Threshold (ACDST)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and history.opponent_actions.shape[0] > 1:
            opponents_defected = sum((1 - action for action in history.opponent_actions[-2, :]))
            opponents_cooperated = self.game_description.n_players - 1 - opponents_defected
            if opponents_defected > self.game_description.n_players // 2:
                self.threshold *= 1.1
            elif opponents_cooperated > self.game_description.n_players // 2:
                self.threshold *= 0.9
        remaining_rounds = self.game_description.n_rounds - state.round_number
        if remaining_rounds == 0:
            return Action.D
        elif state.current_stock < 0.2 * self.game_description.capacity:
            return Action.C
        else:
            self.threshold = self.game_description.capacity / (self.game_description.n_players + 1) * remaining_rounds
            if state.current_stock < self.threshold or state.current_stock < 0.5 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_212(BaseStrategy):
    """
    Adaptive Collective Sustainability strategy.

    This strategy adapts to various opponent behaviors and aligns with the collective mindset.
    It balances individual payoff maximization with collective sustainability by cooperating when the stock level is high,
    defecting when it's low, and playing a mixed strategy in intermediate cases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.p = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.adapt_to_opponent_behavior(history)
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock >= 0.75 * capacity:
            return Action.C
        elif 0.5 <= current_stock / capacity < 0.75:
            return Action.C if random.random() < self.p else Action.D
        else:
            if state.round_number == self.game_description.n_rounds - 1 and current_stock > 0.25 * capacity:
                return Action.C
            return Action.D

    def adapt_to_opponent_behavior(self, history: PlayerHistory):
        if history:
            opponent_cooperators = sum(history.opponent_actions[-1, :])
            total_players = self.game_description.n_players - 1
            cooperation_rate = opponent_cooperators / total_players
            if cooperation_rate > 0.7:
                self.p = max(0.8, min(self.p + 0.05, 1))
            elif cooperation_rate < 0.3:
                self.p = max(0, min(self.p - 0.05, 1))
        if self.game_description.n_players > 10:
            self.p = max(0.9, min(self.p + 0.05, 1))
        if self.game_description.n_rounds == 2:
            return Action.C

class Strategy_COLLECTIVE_213(BaseStrategy):
    """
    Collective Strategy: Adaptive Tit-for-Tat with Stock Threshold (ATTT-ST)
    
    This strategy starts by cooperating, then adapts to the previous round's payoffs.
    It also introduces a stock threshold condition to prioritize resource conservation when the current stock level falls below 50% of capacity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_coop_payoffs = history.opponent_payoffs[-1, history.opponent_actions[-1] == True]
        opponent_defect_payoffs = history.opponent_payoffs[-1, history.opponent_actions[-1] == False]
        avg_coop_payoff_prev_round = np.mean(opponent_coop_payoffs) if len(opponent_coop_payoffs) > 0 else 0
        avg_defect_payoff_prev_round = np.mean(opponent_defect_payoffs) if len(opponent_defect_payoffs) > 0 else 0
        action = Action.C if avg_coop_payoff_prev_round >= avg_defect_payoff_prev_round else Action.D
        if state.current_stock < 0.5 * self.game_description.capacity:
            action = Action.C
        return action

class Strategy_COLLECTIVE_214(BaseStrategy):
    """
    Adaptive Cooperation with Stock-based Trigger strategy.
    
    Encourages cooperation when the stock is plentiful, gradually introduces 
    defection as the stock level decreases, taking into account the actions of others.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        if history is not None and len(history.opponent_actions) > 0:
            num_defectors_prev_round = sum((1 - action for action in history.opponent_actions[-1, :]))
        else:
            num_defectors_prev_round = 0
        if stock_ratio > 0.75:
            return Action.C
        elif 0.5 <= stock_ratio < 0.75:
            defect_prob = num_defectors_prev_round / self.game_description.n_players
            return Action.D if random.random() < defect_prob else Action.C
        elif state.current_stock == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_215(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with the sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.sustainability_threshold = 0.2 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        cooperators = sum(opponent_actions)
        acr = cooperators / self.n_players
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif state.current_stock < self.sustainability_threshold:
            return Action.C
        elif acr >= 0.5 or (acr == 0.5 and random.random() > 0.5):
            action = Action.C
        else:
            action = Action.D
        for opponent_action in opponent_actions:
            if opponent_action and state.current_stock / self.n_players < np.mean(history.my_payoffs):
                action = Action.C
            elif not opponent_action and state.current_stock / self.n_players > np.mean(history.my_payoffs):
                action = Action.D
        return action

class Strategy_COLLECTIVE_216(BaseStrategy):
    """
    The ASC strategy aims to balance individual payoffs with collective sustainability 
    by adaptively adjusting cooperation levels based on game state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        previous_stock = history.my_payoffs[-1] * self.game_description.n_players * 2
        current_stock = state.current_stock
        sdr = (previous_stock - current_stock) / previous_stock if previous_stock > 0 else float('inf')
        if sdr > 0.5:
            return Action.D
        if current_stock >= self.game_description.capacity / 2:
            if len(history.my_payoffs) > 1 and history.my_payoffs[-1] - history.my_payoffs[-2] < self.game_description.capacity * 0.1:
                return Action.D
            return Action.C
        p = (self.game_description.capacity - current_stock) / self.game_description.capacity
        return Action.D if random.random() < p else Action.C

    def __name__(self):
        return 'ASCStrategy'

class Strategy_COLLECTIVE_217(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock-Awareness (ACSA)
    
    This strategy adapts cooperation based on the current stock level and previous round's average payoff.
    It prioritizes cooperation when the stock level is high or moderate, and defects when the stock level is low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_payoff_prev_round = np.mean(history.my_payoffs[-1] + history.opponent_payoffs[-1, :])
        if state.current_stock > 0.75 * self.capacity:
            return Action.C
        elif 0.25 * self.capacity <= state.current_stock <= 0.75 * self.capacity:
            n = self.game_description.n_players
            p = avg_payoff_prev_round / (avg_payoff_prev_round + 1 / n)
            return Action.C if random.random() < p else Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_218(BaseStrategy):
    """
    Adaptive Harvesting with Memory strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.memory = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_actions = history.opponent_actions[-1, :]
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        if any((not action for action in opponents_actions)) and state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        opponent_cooperated = [action for action in opponents_actions]
        if any(opponent_cooperated) and all((action for action in opponent_cooperated[:-1])):
            return Action.C
        elif not any(opponent_cooperated):
            return Action.D
        coop_harvest = state.current_stock / (2 * self.game_description.n_players * (1 + self.memory))
        if coop_harvest > state.current_stock / (2 * self.game_description.n_players):
            self.memory += 1
            return Action.C
        else:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > 0.5 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D

class Strategy_COLLECTIVE_219(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Dependent Trigger strategy.
    
    This strategy adapts to opponent behavior and adjusts its cooperation trigger based on the current stock level,
    balancing individual payoff maximization with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_num = 0
        self.stock_history = []
        self.avg_opponent_coop = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.round_num = state.round_number
        self.stock_history.append(state.current_stock)
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        if n <= 3:
            trigger_stock = capacity * (1 - 1 / (n + 2))
        else:
            trigger_stock = capacity * (1 - 1 / (n + 1))
        if history:
            recent_rounds = min(5, self.round_num)
            opponent_coop_rates = np.mean(history.opponent_actions[-recent_rounds:], axis=0)
            avg_opponent_coop_recent = np.mean(opponent_coop_rates)
            self.avg_opponent_coop = self.avg_opponent_coop * 0.9 + avg_opponent_coop_recent * 0.1
        if self.avg_opponent_coop > 0.5:
            trigger_stock *= 1.1
        else:
            trigger_stock *= 0.9
        if self.round_num == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.1 * capacity:
            return Action.D
        if state.current_stock > trigger_stock:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_220(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Conservation (ASC)

    ASC balances individual payoff maximization with collective stock conservation.
    It adapts to the current state of the game and responds to opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.recent_payoffs = []
        self.opponent_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.recent_payoffs.append(history.my_payoffs[-1])
            if len(self.recent_payoffs) > 3:
                self.recent_payoffs.pop(0)
        if history is not None:
            opponent_actions = history.opponent_actions[-1, :]
            self.opponent_history.append(opponent_actions)
            if len(self.opponent_history) > 5:
                self.opponent_history.pop(0)
        stock_threshold_high = 0.75 * self.game_description.capacity
        stock_threshold_low = 0.25 * self.game_description.capacity
        recent_payoff_average = np.mean(self.recent_payoffs) if self.recent_payoffs else 0
        recent_payoff_threshold = 0.75 * (state.current_stock / (2 * self.game_description.n_players))
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif state.current_stock >= stock_threshold_high or recent_payoff_average > recent_payoff_threshold:
            return Action.C
        elif stock_threshold_low <= state.current_stock < stock_threshold_high and random.random() < 0.5:
            return Action.D
        elif len(self.opponent_history) >= 3:
            opponent_defection_rate = np.mean([np.sum(actions == 0) for actions in self.opponent_history[-3:]])
            if opponent_defection_rate > 0.5:
                return Action.D
        return Action.D

class Strategy_COLLECTIVE_221(BaseStrategy):
    """
    The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consumption_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_opponents = history.opponent_actions[-1, :]
        prev_consumption = sum(prev_round_opponents) * state.current_stock / (2 * self.game_description.n_players) + sum(~prev_round_opponents) * state.current_stock / self.game_description.n_players
        conservation_threshold = 0.7 * self.game_description.capacity
        if history is None:
            return Action.C
        else:
            prev_my_action = history.my_actions[-1]
            if prev_my_action == 1:
                consumption = state.current_stock / (2 * self.game_description.n_players)
            else:
                consumption = state.current_stock / self.game_description.n_players
            self.consumption_history.append(consumption)
        if state.current_stock > conservation_threshold and prev_consumption <= self.game_description.n_players / 2 * state.current_stock / (2 * self.game_description.n_players):
            return Action.C
        elif state.current_stock <= conservation_threshold and sum(history.opponent_actions[-1, :]) >= self.game_description.n_players / 2:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_222(BaseStrategy):
    """
    A collective strategy that adapts to changing game conditions and opponent behaviors,
    promoting cooperation while being mindful of individual self-interest.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_phase = False
        self.punishment_rounds_left = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if self.punishment_phase:
            self.punishment_rounds_left -= 1
            if self.punishment_rounds_left <= 0:
                self.punishment_phase = False
            return Action.C
        if state.round_number % 10 == 0:
            return random.choice([Action.C, Action.D])
        S = state.current_stock
        n_C = sum(history.opponent_actions[-1, :])
        T = S / self.game_description.capacity * (self.game_description.n_players - 1)
        if S < 0.1 * self.game_description.capacity:
            return Action.C
        n_D = sum((1 for opponent_action in history.opponent_actions[-1, :] if not opponent_action))
        if n_D > self.game_description.n_players // 2:
            self.punishment_phase = True
            self.punishment_rounds_left = 2
            return Action.C
        if S > self.game_description.capacity / 2 and S >= T and (n_C > 0):
            return Action.C
        else:
            my_payoff = history.my_payoffs[-1]
            average_cooperative_payoff = np.mean(history.opponent_payoffs[-1, :])
            if my_payoff > 2 * average_cooperative_payoff and (not self.punishment_phase):
                self.punishment_phase = True
                self.punishment_rounds_left = 2
                return Action.C
            else:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if S > self.game_description.capacity / 2:
                return Action.C
            return Action.D

class Strategy_COLLECTIVE_223(BaseStrategy):
    """
    Adaptive Cooperation strategy in the Common Pool Resource Game.
    
    This strategy balances individual payoffs with collective sustainability, 
    adapting to various opponent behaviors while promoting cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        previous_actions = history.opponent_actions[-1, :]
        previous_stock = self.game_description.capacity - state.current_stock / self.game_description.capacity * self.game_description.capacity
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        if any((not action for action in previous_actions)) and state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        if all((action for action in previous_actions)):
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1 or state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_224(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock-Dependent Tit-for-Tat (ACSDT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_punishment = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        majority_action = self.most_common(history.opponent_actions[-1, :])
        if state.current_stock >= 0.75 * self.game_description.capacity:
            if majority_action == True:
                return Action.C
            else:
                return Action.D
        elif 0.25 * self.game_description.capacity <= state.current_stock < 0.75 * self.game_description.capacity:
            if majority_action == True or (majority_action is None and random.random() < 0.5):
                return Action.C
            else:
                return Action.D
        else:
            return Action.D
        if history.my_actions[-1] and self.most_defected(history.opponent_actions[-1, :]):
            self.prev_punishment = True
            return Action.D
        elif self.prev_punishment:
            self.prev_punishment = False
            return self.to_stock_dependent_tit_for_tat(state.current_stock, history.opponent_actions[-1, :])

    def most_common(self, actions):
        cooperators = sum(actions)
        if cooperators > len(actions) / 2:
            return True
        elif cooperators < len(actions) / 2:
            return False
        else:
            return None

    def to_stock_dependent_tit_for_tat(self, stock_level, actions):
        majority_action = self.most_common(actions)
        if stock_level >= 0.75 * self.game_description.capacity:
            if majority_action == True:
                return Action.C
            else:
                return Action.D
        elif 0.25 * self.game_description.capacity <= stock_level < 0.75 * self.game_description.capacity:
            if majority_action == True or (majority_action is None and random.random() < 0.5):
                return Action.C
            else:
                return Action.D

    def most_defected(self, actions):
        defectors = len(actions) - sum(actions)
        return defectors > len(actions) / 2

class Strategy_COLLECTIVE_225(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Trigger (ACST) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperate_prob = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        stock = state.current_stock
        if history is not None:
            avg_payoff_prev_round = np.mean(history.opponent_payoffs[-1, :])
            max_payoff = stock / (2 * n)
        else:
            avg_payoff_prev_round = 0
            max_payoff = 0
        if stock < 0.5 * capacity or avg_payoff_prev_round < 0.25 * max_payoff:
            return Action.D
        if stock > 0.75 * capacity:
            return Action.D
        if history is not None:
            opponent_actions = history.opponent_actions[-1, :]
            for opponent_action in opponent_actions:
                if opponent_action:
                    self.cooperate_prob += 0.05
                else:
                    self.cooperate_prob -= 0.1
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if stock < 0.25 * capacity:
            return Action.D
        if random.random() < self.cooperate_prob:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_226(BaseStrategy):
    """
    Adaptive Collective Conservation (ACC) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.coop_scores = [0] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_opponent_actions = history.opponent_actions[-1, :]
        self.coop_scores = [score + (1 if action else -1) for score, action in zip(self.coop_scores, prev_opponent_actions)]
        num_cooperators = sum((1 for score in self.coop_scores if score > 0))
        num_defectors = self.n_players - num_cooperators
        if state.current_stock < 0.25 * self.capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        theta = 0.5 * self.capacity
        if num_cooperators >= self.n_players / 2:
            action = Action.C
        elif state.current_stock < theta or num_defectors > self.n_players / 2:
            action = Action.D
        else:
            action = Action.C
        return action

class Strategy_COLLECTIVE_227(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy for Common Pool Resource Game.

    This dynamic, adaptive strategy balances individual payoffs with collective sustainability.
    It responds to the game's state and history, ensuring robustness against diverse opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_depletion = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == 0:
            if state.current_stock >= 3 / 4 * capacity:
                return Action.C
            else:
                return Action.D
        if history is not None:
            previous_round = history.my_actions.shape[0] - 1
            my_previous_action = history.my_actions[previous_round]
            opponent_previous_actions = history.opponent_actions[previous_round, :]
            consumption_per_cooperator = state.current_stock / (2 * n)
            consumption_per_defector = state.current_stock / n
            cooperators = sum(opponent_previous_actions) + int(my_previous_action)
            defectors = n - cooperators
            total_consumption = cooperators * consumption_per_cooperator + defectors * consumption_per_defector
            self.total_depletion += total_consumption
        if state.round_number > 0:
            depletion_rate = self.total_depletion / state.round_number
            if state.current_stock >= 3 / 4 * capacity and depletion_rate <= capacity / (2 * n * r):
                return Action.C
            elif state.current_stock < 1 / 4 * capacity:
                return Action.C
            else:
                return Action.D
        if state.round_number == r - 1:
            return Action.D

class Strategy_COLLECTIVE_228(BaseStrategy):
    """
    Adaptive Cooperative Harvesting strategy balances individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.coop_prob = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if random.random() < self.coop_prob else Action.D
        if state.current_stock >= self.game_description.capacity / 2:
            return Action.C
        else:
            avg_opponent_payoff = np.mean(history.opponent_payoffs[-3:, :]) if history.opponent_payoffs.shape[0] > 2 else np.mean(history.opponent_payoffs)
            avg_your_payoff = np.mean(history.my_payoffs) if history.my_payoffs.size > 1 else history.my_payoffs[0]
            if avg_opponent_payoff > avg_your_payoff:
                return Action.D
            opponent_actions_last_round = history.opponent_actions[-1, :]
            defectors_last_round = np.sum(opponent_actions_last_round == 0)
            cooperators_last_round = self.game_description.n_players - 1 - defectors_last_round
            if defectors_last_round > cooperators_last_round:
                return Action.D
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1 or state.current_stock < self.game_description.capacity / 4:
            return Action.D

class Strategy_COLLECTIVE_229(BaseStrategy):
    """
    A strategy that adapts to various opponent behaviors and balances individual payoff maximization with long-term sustainability of the common pool.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.previous_opponent_cooperation = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock_level = state.current_stock
        opponent_actions = history.opponent_actions[-1, :]
        opponent_cooperation_rate = np.mean(opponent_actions)
        self.update_threshold(opponent_cooperation_rate)
        if current_stock_level >= 0.75 * self.game_description.capacity:
            action = Action.C if opponent_cooperation_rate >= self.cooperation_threshold else Action.D
        elif current_stock_level < 0.25 * self.game_description.capacity:
            action = Action.C
        else:
            opponent_defection_rate = 1 - opponent_cooperation_rate
            action = Action.C if opponent_defection_rate > 1 - self.cooperation_threshold else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        return action

    def update_threshold(self, opponent_cooperation_rate):
        if opponent_cooperation_rate > 0.75:
            self.cooperation_threshold = min(1, self.cooperation_threshold + 0.05)
        elif opponent_cooperation_rate < 0.25:
            self.cooperation_threshold = max(0, self.cooperation_threshold - 0.05)

class Strategy_COLLECTIVE_230(BaseStrategy):
    """
    Collective Strategy: "Adaptive Stock Conservation" (ASC)
    
    The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    This approach prioritizes cooperation when the stock is healthy and gradually shifts towards defection as the stock depletes.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.avg_payoff_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        previous_round_history = history.opponent_actions[-1, :]
        n_defectors = sum((not action for action in previous_round_history))
        tau = 0.5 * (1 - current_stock / capacity)
        if tau < 0.33:
            return Action.C
        if n_defectors >= n_players / 2:
            return Action.D
        avg_payoff_threshold = 0.75 * capacity / n_players
        if history.my_payoffs.size > self.game_description.n_rounds // 2:
            avg_payoff = np.mean(history.my_payoffs[-self.game_description.n_rounds // 2:])
            if avg_payoff < avg_payoff_threshold:
                tau += 0.1
            elif avg_payoff > avg_payoff_threshold:
                tau -= 0.1
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_231(BaseStrategy):
    """
    A strategy that aims to balance individual payoffs with collective sustainability of the common pool resource.
    It adapts to the game state and history, responding to opponents' actions while prioritizing long-term cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_actions_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(self.opponent_actions_history) < state.round_number:
            self.opponent_actions_history.append(history.opponent_actions[-1, :])
        stock = state.current_stock
        capacity = self.game_description.capacity
        if stock > 0.75 * capacity:
            return Action.C
        elif stock >= 0.5 * capacity and stock < 0.75 * capacity:
            p = (capacity - stock) / (0.25 * capacity)
            return Action.D if random.random() < p else Action.C
        elif stock < 0.5 * capacity and state.round_number != self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        AOA = np.mean(self.opponent_actions_history[-min(5, len(self.opponent_actions_history)):])
        if AOA >= 0.6:
            return Action.C
        else:
            p = (capacity - stock) / (0.25 * capacity)
            p += (1 - AOA) * 0.1
            return Action.D if random.random() < p else Action.C
        if stock < 0.25 * capacity and state.round_number != self.game_description.n_rounds - 1:
            return Action.C

class Strategy_COLLECTIVE_232(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and maximizes long-term payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        stock_ratio = state.current_stock / capacity
        if state.current_stock == 0:
            return Action.D
        elif state.current_stock == capacity:
            return Action.C
        if history is not None and len(history.opponent_actions) > 0:
            opponents_cooperated = np.sum(history.opponent_actions[-1, :]) >= self.game_description.n_players / 2
            if opponents_cooperated:
                return Action.C
        if history is not None and len(history.opponent_actions) > 0:
            opponents_defected = np.sum(1 - history.opponent_actions[-1, :]) >= self.game_description.n_players / 2
            if opponents_defected:
                return Action.D
        if stock_ratio >= 0.75:
            return Action.C
        elif stock_ratio >= 0.5:
            p = (capacity - state.current_stock) / (0.25 * capacity)
            return Action.D if random.random() < p else Action.C
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_233(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game, balancing cooperation with self-interest adjustments.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.recent_history_majority_cooperated = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.cooperation_threshold = state.current_stock / self.game_description.capacity * (self.game_description.n_players - 1)
        if history is not None:
            recent_history_majority_cooperated = sum(history.opponent_actions[-1, :]) > self.game_description.n_players / 2
            if recent_history_majority_cooperated:
                self.cooperation_threshold += 0.1
            else:
                self.cooperation_threshold -= 0.1
        if state.current_stock < self.game_description.capacity / (2 * self.game_description.n_players):
            return Action.C
        elif state.current_stock > 3 * self.game_description.capacity / 4:
            return Action.D
        personal_payoffs = []
        if history is not None and len(history.my_payoffs) >= 3:
            personal_payoffs = list(history.my_payoffs[-3:])
            average_payoff_of_all_players = np.mean([history.opponent_payoffs[-i] for i in range(1, min(4, len(history.opponent_payoffs)) + 1)])
            if sum(personal_payoffs) < average_payoff_of_all_players * 3:
                return Action.D
        if self.cooperation_threshold > 0.5:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.game_description.capacity / (4 * self.game_description.n_players):
            return Action.C
        opponent_consistent_defection = False
        opponent_consistent_cooperation = False
        for player_history in history.opponent_actions.T:
            if all(player_history):
                opponent_consistent_cooperation = True
            elif not any(player_history):
                opponent_consistent_defection = True
        if opponent_consistent_defection or opponent_consistent_cooperation:
            return Action.D if opponent_consistent_defection else Action.C
        if self.cooperation_threshold > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_234(BaseStrategy):
    """
    Adaptive Cooperative Threshold (ACT) strategy for Common Pool Resource Game.
    
    This strategy adapts cooperation based on current stock levels and opponents' actions,
    aiming to balance individual self-interest with collective well-being.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.epsilon = 0.01

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        threshold = self.game_description.capacity / (2 * self.game_description.n_players)
        opponent_actions = history.opponent_actions[-1, :]
        defect_count = sum(~opponent_actions)
        if defect_count > self.game_description.n_players / 2:
            threshold -= self.epsilon
        elif defect_count < self.game_description.n_players / 2:
            threshold += self.epsilon
        if state.current_stock > threshold:
            action = Action.C
        else:
            action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return action

class Strategy_COLLECTIVE_235(BaseStrategy):
    """
    This strategy aims to balance individual self-interest with collective conservation,
    adapting to various opponent behaviors and game states.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        prev_round_opponent_actions = history.opponent_actions[-1]
        prev_round_my_action = history.my_actions[-1]
        total_consumption_previous_round = sum(prev_round_opponent_actions) * self.game_description.capacity / (2 * self.game_description.n_players) + prev_round_my_action * self.game_description.capacity / (2 * self.game_description.n_players)
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        elif total_consumption_previous_round > 0.5 * self.game_description.capacity:
            return Action.D
        else:
            cooperators = sum(prev_round_opponent_actions)
            if cooperators >= self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D

class Strategy_COLLECTIVE_236(BaseStrategy):
    """
    The Adaptive Stock Conservation (ASC) strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 and history is None:
            return Action.C if state.current_stock == self.game_description.capacity else Action.D
        total_stock_depleted = self.game_description.capacity - state.current_stock
        avg_consumption = total_stock_depleted / (self.game_description.n_players * state.round_number)
        if state.round_number < self.game_description.n_rounds - 1:
            return Action.C if state.current_stock > self.game_description.capacity / 2 and avg_consumption > state.current_stock / (2 * self.game_description.n_players) else Action.D
        return Action.D

class Strategy_COLLECTIVE_237(BaseStrategy):
    """
    The Adaptive Stock Conservation (ASC) strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        cooperate_prob = 0.5
        if stock_ratio > 0.75:
            defect_prob = 0.2 + 0.1 * sum((1 for round in history.my_payoffs if round < 0.25))
            cooperate_prob = 1 - defect_prob
        elif stock_ratio < 0.25:
            return Action.C
        opponent_defections = np.sum(history.opponent_actions, axis=1)
        majority_defection_rounds = sum((1 for round in opponent_defections if round > self.game_description.n_players / 2))
        if majority_defection_rounds > state.round_number / 2:
            defect_prob = 0.3 + 0.1 * majority_defection_rounds
            cooperate_prob = 1 - defect_prob
        recent_payoff = history.my_payoffs[-1]
        median_payoff = np.median(history.my_payoffs)
        if recent_payoff < median_payoff:
            low_payoff_rounds = sum((1 for round in history.my_payoffs if round < median_payoff))
            defect_prob = 0.2 + 0.1 * low_payoff_rounds
            cooperate_prob = 1 - defect_prob
        if state.round_number == self.game_description.n_rounds:
            return Action.D
        return Action.C if random.random() < cooperate_prob else Action.D

class Strategy_COLLECTIVE_238(BaseStrategy):
    """
    A dynamic, adaptive strategy that balances individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_probability = 0.5
        self.stock_thresholds = [0.75 * game_description.capacity, 0.5 * game_description.capacity]
        self.opponent_behavior_weights = [0.1, -0.2]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        if current_stock >= self.stock_thresholds[0]:
            action = Action.C
        elif current_stock < self.stock_thresholds[1]:
            action = Action.D
        else:
            action_probability = 0.7 * self.cooperation_probability
            action = Action.C if random.random() < action_probability else Action.D
        opponent_cooperations = sum(history.opponent_actions[-1, :])
        opponent_proportion = opponent_cooperations / self.game_description.n_players
        if opponent_proportion >= 0.75:
            self.cooperation_probability += 0.1
        elif opponent_proportion < 0.25:
            self.cooperation_probability -= 0.2
        my_payoff = history.my_payoffs[-1]
        average_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
        if my_payoff < average_opponent_payoff:
            self.cooperation_probability -= 0.15
        elif my_payoff > average_opponent_payoff:
            self.cooperation_probability += 0.1
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        elif current_stock < 0.25 * self.game_description.capacity:
            action = Action.D
        return action

class Strategy_COLLECTIVE_239(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Preservation (ASP)

    This strategy prioritizes maintaining a sustainable stock level while adapting to opponents' behavior and the current state of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_stock = None
        self.opponents_previous_actions = []
        self.last_round_flag = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.last_round_flag = state.round_number == self.game_description.n_rounds - 1
        avg_consumption_rate = np.mean(history.opponent_actions[-1, :]) if history else 0.5
        if state.current_stock > 0.5 * self.game_description.capacity or self.previous_stock is None:
            action = Action.C
        elif avg_consumption_rate > 0.5 and state.current_stock < 0.5 * self.game_description.capacity:
            action = Action.D
        elif sum((1 for opponent_action in history.opponent_actions[-1, :] if not opponent_action)) >= self.game_description.n_players // 2:
            action = Action.C
        elif sum((1 for opponent_action in history.opponent_actions[-1, :] if opponent_action)) > self.game_description.n_players // 2:
            action = Action.D
        elif state.current_stock < 0.2 * self.game_description.capacity and (self.previous_stock is None or self.previous_stock > state.current_stock):
            action = Action.C
        else:
            action = Action.C
        self.previous_stock = state.current_stock
        self.opponents_previous_actions.append(history.opponent_actions[-1, :])
        return action if not self.last_round_flag else Action.D

class Strategy_COLLECTIVE_240(BaseStrategy):
    """
    This strategy adapts to various opponent behaviors while prioritizing sustainability and fairness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperation_rate = np.mean(history.opponent_actions)
        if state.round_number <= self.game_description.n_players:
            action = Action.C
        elif self.current_stock >= 0.75 * self.game_description.capacity:
            action = Action.C
        elif self.current_stock < 0.25 * self.game_description.capacity:
            action = Action.D
        else:
            coop_prob = (self.current_stock - 0.25 * self.game_description.capacity) / (0.75 * self.game_description.capacity - 0.25 * self.game_description.capacity)
            action = Action.C if random.random() < coop_prob else Action.D
        if state.round_number >= self.game_description.n_rounds - 2:
            if self.current_stock > 0.5 * self.game_description.capacity:
                action = Action.C
            else:
                action = Action.D
        consumption_per_player = self.current_stock / (2 * self.game_description.n_players) if action == Action.C else self.current_stock / self.game_description.n_players
        total_consumption = consumption_per_player + np.sum(history.opponent_actions[-1, :] / (2 * self.game_description.n_players))
        remaining_stock = max(0, self.current_stock - total_consumption)
        stock_growth = 2 * remaining_stock * (1 - remaining_stock / self.game_description.capacity)
        self.current_stock = min(self.game_description.capacity, remaining_stock + stock_growth)
        return action

class Strategy_COLLECTIVE_241(BaseStrategy):
    """
    A collective strategy that balances cooperation and defection based on 
    current stock level and game history, aiming to maximize individual payoffs 
    while maintaining a sustainable common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        num_cooperators = sum(history.opponent_actions[-1, :])
        num_defectors = self.n_players - 1 - num_cooperators
        threshold = state.current_stock / (2 * self.n_players)
        if num_cooperators >= self.n_players // 2 and state.current_stock > threshold:
            return Action.C
        elif num_defectors >= self.n_players // 2 and state.current_stock < self.capacity / 2:
            return Action.D
        stock_depletion = state.current_stock - history.my_payoffs[-1]
        if len(history.my_actions) > 0 and abs(stock_depletion) / self.capacity > 0.5:
            return Action.C
        if len(history.my_actions) >= self.game_description.n_rounds - 2 and state.current_stock < self.capacity / 4:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_242(BaseStrategy):
    """
    A collective strategy that adapts to various opponent behaviors while prioritizing sustainability and individual payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / 2
        self.p_defect = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock >= self.game_description.capacity / 2:
            self.stock_threshold = min(self.stock_threshold * 1.1, self.game_description.capacity)
        elif state.current_stock < self.game_description.capacity / 4:
            self.stock_threshold = max(self.stock_threshold * 0.8, 0)
        if history is not None and history.opponent_actions.shape[0] > 0:
            total_consumption = sum(((self.game_description.capacity - state.current_stock) / self.game_description.capacity if action else state.current_stock / (2 * self.game_description.n_players) for action in history.opponent_actions[-1, :]))
            if total_consumption > 0.75 * state.current_stock:
                self.stock_threshold *= 0.7
        if state.current_stock >= self.stock_threshold or state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        else:
            self.p_defect = (self.game_description.capacity - state.current_stock) / self.game_description.capacity
            if random.random() < self.p_defect:
                return Action.D
        if history is not None and history.opponent_actions.shape[0] > 0:
            coop_players = sum((1 for action in history.opponent_actions[-1, :] if not action))
            defect_players = self.game_description.n_players - coop_players
            if coop_players > defect_players:
                self.p_defect *= 1.1
            else:
                self.p_defect *= 0.8
        return Action.D

class Strategy_COLLECTIVE_243(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with long-term stock sustainability,
    while being robust to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        previous_stock = self.capacity if state.round_number == 1 else history.my_payoffs[-2] * (self.n_players * 2)
        if state.current_stock > 0.75 * self.capacity:
            return Action.C
        opponent_defections = sum((1 for action in opponent_actions if not action))
        if opponent_defections > self.n_players / 2:
            return Action.D
        previous_cooperations = sum((1 for action in opponent_actions if action))
        if previous_cooperations > self.n_players / 2:
            return Action.C
        if state.current_stock < 0.25 * self.capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > 0.5 * self.capacity:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_244(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Dependent Tit-for-Tat (ACSDT) strategy.
    
    This strategy balances individual interests with collective well-being, adapting to the game state and opponents' behavior.
    By cooperating when the stock level is high and defecting when it's low, ACSDT promotes a sustainable environment while maximizing individual payoffs in depleted situations.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_thresholds = {'high': 0.75, 'medium': 0.5}

    def mirror(self, opponent_actions: NDArray[np.bool_]) -> Action:
        if all(opponent_actions) or np.all(~opponent_actions):
            return Action.C if all(opponent_actions) else Action.D
        else:
            return Action.C if opponent_actions[-1] else Action.D

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        opponent_actions = history.opponent_actions[:, 0]
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif stock_level > self.stock_thresholds['high']:
            return Action.C
        elif stock_level >= self.stock_thresholds['medium']:
            return self.mirror(opponent_actions)
        else:
            return Action.D

class Strategy_COLLECTIVE_245(BaseStrategy):
    """
    The Adaptive Stock Conservator strategy balances individual payoffs with long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        capacity = self.game_description.capacity
        stock = state.current_stock
        p_C = 0
        if stock >= 0.75 * capacity:
            p_C = 1
        elif stock < 0.5 * capacity:
            p_C = 0
        else:
            p_C = (stock - 0.5 * capacity) / (0.25 * capacity)
        opponent_actions = history.opponent_actions[-1, :]
        most_common_action = Action.C if np.sum(opponent_actions) >= self.game_description.n_players // 2 else Action.D
        if most_common_action == Action.D:
            p_C -= 0.1
        elif most_common_action == Action.C:
            p_C += 0.1
        p_C = max(0, min(p_C, 1))
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C if random.random() < p_C else Action.D

class Strategy_COLLECTIVE_246(BaseStrategy):
    """
    This strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    It prioritizes cooperation when possible, while also being mindful of potential defections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.threshold = 0.5 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if current_stock > self.threshold:
            action = Action.C
        else:
            action = Action.D
        previous_stock = history.my_payoffs[-1] * (self.game_description.n_players * 2)
        stock_diff = current_stock - previous_stock
        if stock_diff >= 0 or stock_diff < -0.1 * self.capacity:
            self.threshold -= 0.05 * self.capacity
        elif stock_diff < -0.2 * self.capacity:
            self.threshold += 0.05 * self.capacity
        opponent_actions = history.opponent_actions[-1, :]
        num_defectors = sum((1 for action in opponent_actions if not action))
        if num_defectors > len(opponent_actions) / 2:
            return Action.D
        elif sum((1 for action in opponent_actions if action)) > len(opponent_actions) / 2:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if current_stock < 0.2 * self.capacity:
            return Action.C
        return action

class Strategy_COLLECTIVE_247(BaseStrategy):
    """
    Adaptive Stock Sustainer (ASS) strategy aims to balance individual payoffs with collective sustainability,
    adapting to various opponent behaviors and game states.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def calculate_average_payoff(self, history: PlayerHistory) -> float:
        """Calculate average payoff per player in the previous round"""
        return np.mean(history.my_payoffs[-1])

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if self.game_description.n_players % 2 == 0:
                return Action.C
            else:
                return Action.D
        π_avg = self.calculate_average_payoff(history)
        stock_threshold_low = 0.25 * self.game_description.capacity
        stock_threshold_high = 0.75 * self.game_description.capacity
        if state.current_stock < stock_threshold_low:
            return Action.C
        if π_avg >= state.current_stock / (2 * self.game_description.n_players):
            return Action.C
        elif state.current_stock > stock_threshold_high:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if history.my_actions.size == 1:
            return Action.C

class Strategy_COLLECTIVE_248(BaseStrategy):
    """
    Adaptive Cooperation with Stock Awareness (ACSA) Strategy.
    This strategy balances individual self-interest with collective well-being,
    adapting to the dynamic state of the game and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        cooperation_threshold = self.game_description.capacity / (2 * self.game_description.n_players)
        if state.current_stock > cooperation_threshold:
            action = Action.C
        else:
            action = Action.D
        opponents_defected = sum((1 - h for h in history.opponent_actions[-1, :])) / self.game_description.n_players
        if opponents_defected > 0.5:
            action = Action.D
        elif opponents_defected < 0.5:
            action = Action.C
        if state.current_stock < self.game_description.capacity / 4:
            action = Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        return action

class Strategy_COLLECTIVE_249(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Trigger (ACST) strategy.

    This dynamic strategy balances individual payoffs with collective sustainability.
    It responds to both current stock levels and historical actions of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        if history is not None and np.any(~history.opponent_actions[-1, :]):
            return Action.D
        if history is not None and state.current_stock > history.my_payoffs[-1] + self.game_description.capacity / (2 * self.game_description.n_players):
            return Action.C
        prob_cooperate = 0.75
        return Action.C if random.random() < prob_cooperate else Action.D

class Strategy_COLLECTIVE_250(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy for the Common Pool Resource Game.
    
    This strategy promotes cooperation while adapting to the game's state and history, 
    balancing individual payoffs with collective sustainability. It adjusts based on the 
    previous round's outcome, incorporates a mixed strategy when the stock level decreases 
    slightly, and defects in critical situations or the last round if necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_stock = history.my_payoffs[-1] * self.game_description.n_players * 2
        stock_change = state.current_stock - previous_stock
        if state.current_stock < 0.2 * self.capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if stock_change >= 0:
            return Action.C
        elif abs(stock_change) > 0.1 * self.capacity:
            return Action.D
        else:
            p = state.current_stock / self.capacity
            if random.random() < p:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_251(BaseStrategy):
    """
    A strategy that adapts to the game's state and history, balancing individual payoffs with long-term stock sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def calculate_probability(self, avg_consumption: float, capacity: int) -> float:
        if avg_consumption < 0.125 * capacity:
            return 1 - avg_consumption / (0.5 * capacity)
        elif avg_consumption < 0.25 * capacity:
            return 0.5
        else:
            return (capacity - self.current_stock) / capacity

    def get_total_consumption(self, n: int, actions: NDArray[np.bool_], current_stock: float) -> float:
        total = 0
        for action in actions:
            if action:
                total += current_stock / (2 * n)
            else:
                total += current_stock / n
        return total

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.current_stock = state.current_stock
            if state.current_stock > 0.75 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        total_consumption = self.get_total_consumption(self.game_description.n_players - 1, opponent_actions, self.current_stock)
        avg_consumption = (total_consumption + state.current_stock / (2 * self.game_description.n_players)) / self.game_description.n_players
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.5 * self.game_description.capacity or avg_consumption > 0.25 * self.game_description.capacity:
            return Action.D
        elif state.current_stock < 0.1 * self.game_description.capacity:
            return Action.C
        p = self.calculate_probability(avg_consumption, self.game_description.capacity)
        if random.random() < p:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_253(BaseStrategy):
    """
    A collective strategy that balances individual payoff maximization with long-term stock conservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        cooperators = sum(history.opponent_actions[-1, :])
        cooperation_ratio = cooperators / self.game_description.n_players
        expected_growth = self.calculate_expected_growth(state.current_stock)
        if state.current_stock < self.stock_threshold:
            return Action.D
        elif cooperation_ratio > 0.5 or (expected_growth > 0 and (not self.is_tie(expected_growth, cooperation_ratio))):
            return Action.C
        else:
            return Action.D

    def calculate_expected_growth(self, current_stock: float) -> float:
        remaining_stock = max(0, current_stock - self.game_description.n_players * (current_stock / (2 * self.game_description.n_players)))
        growth = 2 * remaining_stock * (1 - remaining_stock / self.stock_threshold)
        return min(growth, self.game_description.capacity)

    def is_tie(self, expected_growth: float, cooperation_ratio: float) -> bool:
        return abs(expected_growth) < 1e-09 or abs(cooperation_ratio - 0.5) < 1e-09

class Strategy_COLLECTIVE_254(BaseStrategy):
    """
    Adaptive Cooperation with Stock Conservation (ACSC) strategy.
    This strategy prioritizes cooperation to maintain a stable and growing common pool resource,
    while adapting to changing stock levels and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock / self.game_description.capacity < 0.1:
            return Action.C
        if state.current_stock / self.game_description.capacity > 0.9:
            p_D = 0.3 + state.current_stock / self.game_description.capacity / 20
            return Action.D if random.random() < p_D else Action.C
        if state.current_stock / self.game_description.capacity > 0.5:
            p_C = 0.7 + state.current_stock / self.game_description.capacity / 10
            return Action.C if random.random() < p_C else Action.D
        else:
            p_D = 1 - state.current_stock / self.game_description.capacity / 5
            return Action.D if random.random() < p_D else Action.C

class Strategy_COLLECTIVE_255(BaseStrategy):
    """
    Collective Strategy: "Adaptive Harvesting with Stock-Sensitive Cooperation" (AHSSC)

    This strategy prioritizes cooperation when the stock level is sufficient, promoting a collective mindset that balances individual payoffs with long-term sustainability.
    By adapting to opponents' behaviors, AHSSC encourages cooperation while protecting against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / (2 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        previous_opponent_actions = history.opponent_actions[-1]
        majority_cooperated = sum(previous_opponent_actions) > self.game_description.n_players / 2
        if majority_cooperated:
            self.stock_threshold *= 0.9
        else:
            self.stock_threshold *= 1.1
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.game_description.capacity / (4 * self.game_description.n_players):
            return Action.C
        if state.current_stock > self.stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_256(BaseStrategy):
    """
    Collective Strategy: Adaptive Tit-for-Tat with Stock Sensitivity (ATTS)
    
    This strategy balances individual interests with collective sustainability in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        if state.round_number == 0 or history is None:
            return Action.C
        stock_level = state.current_stock / capacity
        prev_round_coops = sum(history.opponent_actions[-1, :])
        if stock_level >= 0.75:
            return Action.C
        elif 0.5 <= stock_level < 0.75:
            if prev_round_coops > self.game_description.n_players / 2:
                return Action.C
            else:
                return Action.D
        elif 0.25 <= stock_level < 0.5:
            return Action.D
        elif stock_level < 0.25:
            return Action.D
        elif stock_level > 0.9:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_257(BaseStrategy):
    """
    A collective strategy that balances individual payoff maximization with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperate_threshold = 0.7
        self.prev_stock_level = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock_level = state.current_stock
        if current_stock_level >= self.cooperate_threshold * self.game_description.capacity:
            action = Action.C
        else:
            action = Action.D
        all_players_cooperated = history.my_actions[-1] and np.all(history.opponent_actions[-1, :])
        some_players_defected = not all_players_cooperated and (not np.all(~history.opponent_actions[-1, :]))
        if all_players_cooperated and (self.prev_stock_level <= current_stock_level or self.prev_stock_level == current_stock_level):
            pass
        elif some_players_defected and current_stock_level < 0.5 * self.game_description.capacity:
            self.cooperate_threshold *= 0.9
        elif (~all_players_cooperated and ~some_players_defected) and current_stock_level < 0.2 * self.game_description.capacity:
            self.cooperate_threshold *= 1.2
        self.prev_stock_level = current_stock_level
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return action

class Strategy_COLLECTIVE_258(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock-Dependent Threshold (ATTT-SdT) strategy.

    This strategy encourages cooperation by responding to cooperation with cooperation,
    using a stock-dependent threshold, and adjusting it based on the current stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        prev_coops = sum(history.opponent_actions[-1, :])
        T = state.current_stock / self.game_description.capacity * self.game_description.n_players
        if prev_coops >= T:
            action = Action.C
        else:
            action = Action.D
        if state.current_stock < self.game_description.capacity / 2:
            T += 1
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < self.game_description.capacity / 4:
            return Action.C
        return action

class Strategy_COLLECTIVE_259(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Awareness strategy for the Common Pool Resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defect_probability = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        majority_cooperated = sum(history.opponent_actions[-1, :]) / (self.game_description.n_players - 1) > 0.5
        stock_threshold_reached = state.current_stock < self.game_description.capacity / 2
        if majority_cooperated or stock_threshold_reached:
            return Action.C
        avg_payoff_last_3_rounds = np.mean(history.my_payoffs[-3:]) if len(history.my_payoffs) >= 3 else 0
        max_possible_payoff = self.game_description.capacity / (2 * self.game_description.n_players)
        if avg_payoff_last_3_rounds < 0.75 * max_possible_payoff:
            self.defect_probability += 0.2
        return Action.D if random.random() < self.defect_probability else Action.C

class Strategy_COLLECTIVE_260(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACS)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.threshold = 0.0
        self.opponent_behavior = [None] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.current_stock < 2 * self.n_players:
            return Action.C
        elif state.round_number == self.n_rounds - 1:
            return Action.D
        else:
            self.threshold = state.current_stock / (2 * self.n_players * (1 + state.round_number / 10))
            if state.current_stock > self.threshold:
                return Action.C
            else:
                probability = 1 - state.current_stock / self.capacity
                if history is not None and len(history.opponent_actions) > 0:
                    for i in range(self.n_players):
                        opponent_cooperations = sum((1 for action in history.opponent_actions[:, i] if action))
                        opponent_defections = len(history.opponent_actions[:, i]) - opponent_cooperations
                        self.opponent_behavior[i] = 'cooperate' if opponent_cooperations > opponent_defections else 'defect'
                if random.random() < probability:
                    return Action.D
                elif history is not None and len(history.opponent_actions) > 0:
                    for i in range(self.n_players):
                        if self.opponent_behavior[i] == 'cooperate':
                            self.threshold -= 0.1 * self.threshold
                        else:
                            self.threshold += 0.1 * self.threshold
                return Action.C

class Strategy_COLLECTIVE_261(BaseStrategy):
    """
    A strategy that balances individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_payoff = np.mean(history.my_payoffs)
        opponent_actions = history.opponent_actions[-1]
        defection_rate = np.sum(opponent_actions == False) / self.game_description.n_players
        current_stock_proportion = state.current_stock / self.capacity
        if current_stock_proportion >= 0.75:
            return Action.C
        elif 0.5 <= current_stock_proportion < 0.75:
            if random.random() < defection_rate:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C

class Strategy_COLLECTIVE_262(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock > self.cooperation_threshold * self.game_description.capacity:
            return Action.C
        previous_round_defections = sum((1 for action in history.opponent_actions[-1, :] if not action))
        if previous_round_defections > 0 and state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        average_payoff = np.mean(history.my_payoffs[-3:])
        group_average_payoff = np.mean(np.mean(history.opponent_payoffs[-3:, :], axis=1))
        if average_payoff > 1.2 * group_average_payoff:
            return Action.D
        opponent_cooperation_rate = np.mean(history.opponent_actions[-1, :])
        if opponent_cooperation_rate > 0.6:
            self.cooperation_threshold += 0.1
        elif opponent_cooperation_rate < 0.4:
            self.cooperation_threshold -= 0.1
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        return Action.C if state.current_stock > self.cooperation_threshold * self.game_description.capacity else Action.D

class Strategy_COLLECTIVE_263(BaseStrategy):
    """
    Adaptive Stock Conservation strategy for Common Pool Resource Game.
    
    This strategy balances individual payoffs with long-term stock sustainability, 
    adapting to the actions of other players and the game's state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        defectors = sum((1 for opponent_action in history.opponent_actions[-1, :] if not opponent_action))
        if defectors > 0:
            return Action.D
        avg_payoffs = []
        for i in range(1, min(state.round_number + 1, 3)):
            avg_payoff = np.mean([history.my_payoffs[-i]] + history.opponent_payoffs[-i, :].tolist())
            avg_payoffs.append(avg_payoff)
        avg_payoff = np.mean(avg_payoffs)
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        max_payoff = state.current_stock / (2 * self.game_description.n_players)
        if avg_payoff < 0.5 * max_payoff:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1 and state.current_stock > 0.25 * self.game_description.capacity:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_264(BaseStrategy):
    """
    The Adaptive Stock Conservation (ASC) strategy aims to balance individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.75 * game_description.capacity
        self.history_window = min(3, game_description.n_rounds)
        self.adaptation_margin = 0.05
        self.round_actions = []
        self.round_payoffs_diff = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_payoff_diff = np.mean(self.round_payoffs_diff[-self.history_window:])
        prev_opponent_actions = history.opponent_actions[-1, :]
        more_than_half_defected = sum(prev_opponent_actions) < len(prev_opponent_actions) // 2
        if avg_payoff_diff < 0:
            self.stock_threshold -= self.adaptation_margin
        elif avg_payoff_diff > 0:
            self.stock_threshold += self.adaptation_margin
            self.stock_threshold = min(self.stock_threshold, 0.75 * self.game_description.capacity)
        if state.current_stock > self.stock_threshold and (not more_than_half_defected):
            return Action.C
        elif avg_payoff_diff < 0 or more_than_half_defected:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_265(BaseStrategy):
    """
    Adaptive Stock Conservation strategy for Common Pool Resource Game.
    
    Balances individual short-term gains with collective long-term sustainability.
    Adapts to average stock level and adjusts cooperation probability accordingly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def calculate_avg_stock(self, history: PlayerHistory, n_rounds: int) -> float:
        if history is None or len(history.my_payoffs) < n_rounds:
            return 0
        end_index = len(history.my_payoffs)
        start_index = max(0, end_index - n_rounds)
        avg_stock = np.mean([self.game_description.capacity] + list(history.my_payoffs[start_index:end_index]))
        return avg_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock >= self.game_description.capacity * 0.75 else Action.D
        avg_stock = self.calculate_avg_stock(history, min(5, state.round_number - 1))
        if avg_stock < self.game_description.capacity * 0.5 or state.current_stock < self.game_description.capacity * 0.25:
            return Action.D
        else:
            p_c = max(0.4, min(0.8, avg_stock / self.game_description.capacity))
            return Action.C if random.random() <= p_c else Action.D

class Strategy_COLLECTIVE_266(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperative Balance (ACB)

    This strategy prioritizes cooperation when the stock level is sufficient, 
    while adapting to opponents' behaviors by introducing a probabilistic defection mechanism.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        majority_defection_count = sum(np.sum(history.opponent_actions, axis=1) > self.game_description.n_players / 2)
        defect_probability = majority_defection_count / state.round_number
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        elif 0.25 * self.game_description.capacity <= state.current_stock < 0.75 * self.game_description.capacity:
            if random.random() < defect_probability:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_267(BaseStrategy):
    """
    This strategy implements the Adaptive Cooperation with Stock-Based Threshold (ACST) 
    approach to the Common Pool Resource Game. It adapts to changing stock levels and 
    opponent behaviors, balancing individual self-interest with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        S_threshold = self.game_description.capacity / 2
        if state.current_stock > S_threshold:
            return Action.C
        if history is not None:
            avg_coop_rate = np.mean(history.opponent_actions)
            if avg_coop_rate > 0.5:
                return Action.C
        S_critical = self.game_description.capacity / 4
        if state.current_stock < S_critical and history is not None and (not history.my_actions[-1]):
            punish_defector = True
            if len(history.my_actions) > 1 and (not history.my_actions[-2]) and history.my_actions[-1]:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_268(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock-Based Trigger (ACST)
    Balances individual self-interest with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        T = self.game_description.capacity * (self.game_description.n_players / (2 * self.game_description.n_players + 1))
        if state.current_stock >= T:
            action = Action.C
        else:
            action = Action.D
        avg_payoff = np.mean(history.my_payoffs)
        if avg_payoff < state.current_stock / (2 * self.game_description.n_players):
            T *= 1.05
        opponent_defections = sum(1 - history.opponent_actions[-1, :])
        if opponent_defections > self.game_description.n_players / 2:
            T *= 1.1
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < state.current_stock / (2 * self.game_description.n_players):
            return Action.C
        if sum(1 - history.opponent_actions[-1, :]) > 0.75 * self.game_description.n_players:
            return Action.C
        return action

class Strategy_COLLECTIVE_269(BaseStrategy):
    """
    Balances individual interests with collective responsibility,
    adapting to the game's state and history while being robust
    to diverse opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (state.round_number == 1 and self.game_description.n_players == 2):
            return Action.C
        stock_threshold = 0.7 * self.game_description.capacity
        total_consumption_prev_round = sum([self._get_payoff(history, i) for i in range(self.game_description.n_players)])
        if state.current_stock > stock_threshold:
            return Action.C
        my_payoff_prev_round = self._get_my_payoff(history)
        average_payoff_prev_round = total_consumption_prev_round / self.game_description.n_players
        if total_consumption_prev_round > 0.5 * self.game_description.capacity and my_payoff_prev_round < average_payoff_prev_round:
            return Action.D
        if history.opponent_payoffs is not None and self._punishment_triggered(history):
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1 and state.current_stock > 0.2 * self.game_description.capacity:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 2 and state.current_stock < 0.2 * self.game_description.capacity:
            return Action.D
        return Action.C

    def _get_payoff(self, history: PlayerHistory, player_id: int) -> float:
        if history.my_actions is not None and history.my_payoffs is not None:
            payoff = history.my_payoffs[-1] if player_id == 0 else history.opponent_payoffs[-1, player_id - 1]
        elif history.opponent_actions is not None:
            action = history.my_actions[-1] if player_id == 0 else history.opponent_actions[-1, player_id - 1]
            payoff = self.game_description.capacity / (2 * self.game_description.n_players) if action else self.game_description.capacity / self.game_description.n_players
        return payoff

    def _get_my_payoff(self, history: PlayerHistory) -> float:
        return self._get_payoff(history, player_id=0)

    def _punishment_triggered(self, history: PlayerHistory) -> bool:
        total_consumption_prev_round = sum([self._get_payoff(history, i) for i in range(self.game_description.n_players)])
        if total_consumption_prev_round > 0.5 * self.game_description.capacity and history.my_payoffs is not None:
            my_payoff = history.my_payoffs[-1]
            average_payoff = np.mean([self._get_payoff(history, i) for i in range(self.game_description.n_players)])
            if my_payoff > average_payoff:
                return True
        return False

class Strategy_COLLECTIVE_270(BaseStrategy):
    """
    The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.expected_payoff = game_description.capacity / (2 * game_description.n_players) * 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_defections = sum([1 for action in history.opponent_actions[-1, :] if not action])
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        if previous_defections > self.game_description.n_players / 2 or state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        total_payoff = sum(history.my_payoffs[-3:]) if len(history.my_payoffs) >= 3 else sum(history.my_payoffs)
        if total_payoff < 0.75 * self.expected_payoff:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_271(BaseStrategy):
    """
    A collective strategy that adapts cooperation based on the current stock level and game history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock > 0.75 * self.game_description.capacity else Action.D
        avg_stock_last_3 = np.mean(history.my_payoffs[-min(3, len(history.my_payoffs)):]) * (self.game_description.n_players / 2)
        TH = self.game_description.capacity * (0.5 + 0.5 * avg_stock_last_3 / self.game_description.capacity)
        if state.current_stock > TH:
            return Action.C
        else:
            P_DEFECT = max(0, min(1, 1 - state.current_stock / TH))
            if np.any(~history.opponent_actions[-1, :]):
                P_DEFECT += 0.2
            return Action.D if random.random() < P_DEFECT else Action.C

class Strategy_COLLECTIVE_272(BaseStrategy):
    """
    Adaptive Cooperative Harvesting (ACH) strategy balances individual payoffs with long-term sustainability of the common pool resource.
    It adapts to the game state and history, promoting cooperation among players while protecting individual interests when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defect_probability = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        cooperate_ratio = sum(opponent_actions) / len(opponent_actions)
        if cooperate_ratio >= 0.75:
            return Action.C
        elif cooperate_ratio >= 0.25:
            return random.choice([Action.C, Action.D])
        else:
            return Action.D
        if hasattr(history, 'my_payoffs') and history.my_payoffs.size > 0:
            average_payoff = np.mean(history.opponent_payoffs[-1, :])
            if history.my_payoffs[-1] < average_payoff:
                self.defect_probability = min(1.0, self.defect_probability + 0.1)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        return random.choice([Action.C, Action.D], p=[1 - self.defect_probability, self.defect_probability])

class Strategy_COLLECTIVE_273(BaseStrategy):
    """
    Adaptive Cooperation strategy for Common Pool Resource game.
    
    This strategy combines reactive and proactive elements to maintain a balance between cooperation and self-interest.
    It observes the actions of other players, adjusts its strategy based on the stock level trend, and prioritizes long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def calculate_cooperation_index(self, opponent_actions: NDArray[np.bool_]) -> float:
        """Calculate the proportion of players who cooperated in a round."""
        return np.mean(opponent_actions)

    def is_stock_decreasing_rapidly(self, current_stock: float, previous_stock: float) -> bool:
        """Check if the stock level has decreased by more than 20% in a single round."""
        return (previous_stock - current_stock) / previous_stock > 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        opponent_actions = history.opponent_actions[-1, :]
        cooperation_index = self.calculate_cooperation_index(opponent_actions)
        if cooperation_index >= 0.5 or state.current_stock < self.game_description.capacity * 0.2:
            return Action.C
        previous_stock = history.my_payoffs.shape[0] > 1 and self.game_description.capacity - sum(history.opponent_payoffs[-2, :]) or self.game_description.capacity
        if self.is_stock_decreasing_rapidly(state.current_stock, previous_stock):
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > self.game_description.capacity * 0.5:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_274(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Preservation (ASP)

    Decision Rules:
    - Initial Round: Cooperate to set a positive tone and establish a baseline stock level.
    - Stock Threshold: If the current stock level is below 50% of the capacity, Defect to maximize individual payoff.
    - Opponent Behavior Analysis: Monitor the actions of all players in previous rounds and calculate the average cooperation rate (ACR).
    - Cooperation Threshold: If ACR is above 0.5, Cooperate to reinforce collective cooperation and maintain a healthy stock level. Otherwise, Defect to protect individual interests.

    Edge Cases:
    - Last Round: In the final round, Defect to maximize individual payoff.
    - Ties in ACR: If the average cooperation rate is exactly 0.5, Cooperate to maintain a positive collective outcome.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        opponent_actions = history.opponent_actions[:-1]
        avg_cooperation_rate = np.mean(opponent_actions)
        if avg_cooperation_rate > 0.5:
            return Action.C
        elif avg_cooperation_rate == 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_275(BaseStrategy):
    """
    Adaptive Stock-Conscious Tit-for-Tat strategy for the Common Pool Resource Game.
    
    Initially cooperates to establish a cooperative tone. Then, observes previous round's actions and payoffs.
    Cooperates if stock level is above 50% of capacity; defects otherwise. 
    Punishes non-cooperative opponents by defecting in response to their defection.
    Adjusts cooperation threshold based on the stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_stock_level = state.current_stock - sum(self.game_description.n_players * [state.current_stock / self.game_description.n_players])
        if previous_stock_level > 0.5 * self.game_description.capacity:
            cooperation_threshold = 0.5
        elif previous_stock_level < 0.25 * self.game_description.capacity:
            cooperation_threshold = 0.7
        else:
            cooperation_threshold = 0.6
        opponent_defected_cooperated = False
        if history is not None and history.my_payoffs[-1] > 0 and any((not action for action in history.opponent_actions[-1])):
            opponent_defected_cooperated = True
        if state.current_stock > 0.75 * self.game_description.capacity:
            cooperation_threshold -= 0.1
        elif state.current_stock < 0.25 * self.game_description.capacity:
            cooperation_threshold += 0.1
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock <= 0:
            return Action.D
        self.cooperation_threshold = cooperation_threshold
        if random.random() < self.cooperation_threshold or opponent_defected_cooperated:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_276(BaseStrategy):
    """
    A collective strategy that adapts to the stock level and previous players' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        stock_ratio = current_stock / capacity
        if stock_ratio > 0.75:
            opponent_cooperators = sum(history.opponent_actions[-1, :])
            if opponent_cooperators >= self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D
        elif stock_ratio < 0.25:
            return Action.D
        else:
            probability_cooperate = stock_ratio
            if random.random() < probability_cooperate:
                return Action.C
            else:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if current_stock > capacity / 2:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_277(BaseStrategy):
    """
    Collective strategy that balances individual payoffs with collective stock conservation.
    Adapts to changing game conditions and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperation_rate = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        elif 0.25 * self.game_description.capacity <= state.current_stock < 0.75 * self.game_description.capacity:
            opponent_actions = history.opponent_actions[-1, :]
            cooperators = sum(opponent_actions)
            if cooperators / len(opponent_actions) >= 0.5:
                return Action.C if random.random() < 0.7 else Action.D
            else:
                return Action.D if random.random() < 0.3 else Action.C
        else:
            if state.round_number == self.game_description.n_rounds - 1:
                return Action.D
            return Action.D

class Strategy_COLLECTIVE_278(BaseStrategy):
    """
    The ASP strategy prioritizes cooperation while adapting to changing game conditions.
    By monitoring other players' actions, it can detect defections and respond accordingly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.7 * game_description.capacity
        self.stock_recovery_threshold = 0.3 * game_description.capacity
        self.endgame_threshold = 0.5 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < 2:
            return Action.C
        if state.round_number == 0 and history is None:
            return Action.C
        if state.current_stock > self.stock_threshold:
            return Action.C
        for player in history.opponent_actions[-1, :]:
            if not player:
                return Action.D
        if state.current_stock < self.stock_recovery_threshold:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1 and state.current_stock > self.endgame_threshold and all(history.opponent_actions[-1, :]):
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_279(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy.
    
    This strategy balances individual payoffs with collective sustainability, adapting to changing game conditions and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_payoff = np.mean(history.my_payoffs)
        max_payoff = self.game_description.capacity / (2 * self.game_description.n_players)
        if avg_payoff > 0.75 * max_payoff:
            if state.current_stock < 0.5 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        elif history.opponent_actions[-1, :].sum() / self.game_description.n_players > 0.25 and state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock < 0.25 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_280(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that balances individual interests with sustainable resource management.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_threshold = 0.75 * self.game_description.capacity
        if state.current_stock > stock_threshold:
            return Action.C
        prev_round_consumption = np.sum(history.opponent_actions[-1, :] * state.current_stock / self.game_description.n_players + history.my_actions[-1] * state.current_stock / (2 * self.game_description.n_players))
        aic = prev_round_consumption / self.game_description.n_players
        sustainable_level = state.current_stock / (2 * self.game_description.n_players)
        if aic > sustainable_level:
            return Action.D
        prev_player_action = history.my_actions[-1]
        new_stock_level = state.current_stock - np.sum(history.opponent_actions[-1, :] * state.current_stock / self.game_description.n_players + history.my_actions[-1] * state.current_stock / (2 * self.game_description.n_players)) + 2 * max(0, state.current_stock) * (1 - state.current_stock / self.game_description.capacity)
        if prev_player_action and new_stock_level >= stock_threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_281(BaseStrategy):
    """
    Adaptive Common Pool Resource Management strategy.

    This strategy prioritizes collective well-being by adapting to the current state and history of the game.
    It encourages cooperation when the stock level is sustainable and opponents are cooperative,
    promotes cooperation to replenish the stock when consumption levels are high, and
    prioritizes stock replenishment over individual gain when the stock level is critically low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        prev_round_consumption = sum(state.current_stock / self.game_description.n_players * (history.opponent_actions[-1, :] == Action.D) + state.current_stock / (2 * self.game_description.n_players) * (history.opponent_actions[-1, :] == Action.C))
        if prev_round_consumption <= self.game_description.capacity / 2:
            prev_round_cooperators = sum(history.opponent_actions[-1, :] == Action.C)
            if prev_round_cooperators >= self.game_description.n_players / 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C
        if state.current_stock < 0.2 * self.game_description.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_282(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_cooperated = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        previous_stock = self.game_description.capacity if state.round_number == 1 else history.my_payoffs[-2] * 2 * self.game_description.n_players
        total_consumption = sum(history.opponent_payoffs[-1, :] + [history.my_payoffs[-1]])
        defectors = sum((1 for action in history.opponent_actions[-1, :] if not action)) + (not self.last_round_cooperated)
        τ = self.game_description.capacity / (2 * self.game_description.n_players)
        if state.current_stock > τ:
            return Action.C
        if total_consumption > 0.75 * previous_stock or defectors > self.game_description.n_players / 2:
            return Action.D
        if self.last_round_cooperated and state.current_stock >= previous_stock + 2 * previous_stock * (1 - previous_stock / self.game_description.capacity):
            return Action.C
        if not self.last_round_cooperated:
            self.last_round_cooperated = True
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            self.last_round_cooperated = True
            return Action.C

    def set_last_action(self, action):
        self.last_round_cooperated = action == Action.C

class Strategy_COLLECTIVE_283(BaseStrategy):
    """
    A strategy that balances individual payoffs with collective sustainability,
    adapting to the game's dynamic state and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.tft_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        sdr = np.mean(np.diff(history.my_payoffs)) * self.game_description.n_players
        if sdr > 0.2 * self.game_description.capacity / self.game_description.n_rounds:
            self.tft_threshold += 0.1
        opponents_cooperated = np.sum(history.opponent_actions[-1, :])
        if opponents_cooperated > self.game_description.n_players // 2:
            self.tft_threshold -= 0.05
        elif opponents_cooperated < self.game_description.n_players // 4:
            self.tft_threshold += 0.05
        if stock_ratio >= 0.75:
            return Action.C
        elif 0.5 <= stock_ratio < 0.75 and opponents_cooperated > self.game_description.n_players // 2:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_284(BaseStrategy):
    """
    Adaptive Stock-Conscious Cooperation strategy.

    This strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        previous_defections = sum(~history.opponent_actions[-1, :]) if history else 0
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        cooperation_probability = 0.5
        if stock_ratio > 0.75:
            cooperation_probability += 0.1
        elif stock_ratio < 0.5:
            cooperation_probability -= 0.1
        defect_probability = previous_defections / self.game_description.n_players
        if stock_ratio >= 0.5 and stock_ratio <= 0.75:
            return Action.D if random.random() < defect_probability else Action.C
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.C
        if previous_defections > 0.75 * self.game_description.n_players:
            return Action.D
        return Action.C if random.random() < cooperation_probability else Action.D

class Strategy_COLLECTIVE_285(BaseStrategy):
    """
    Adaptive Cooperative Harvesting Strategy.
    
    This strategy prioritizes cooperation to maintain a sustainable stock level 
    while adapting to the actions of other players. It initially randomizes 
    cooperation, incorporates punishment and reward mechanisms, and encourages 
    collective behavior to prevent over-exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        stock_threshold = self.game_description.capacity / (2 * self.game_description.n_players) * (1 - 1 / self.game_description.n_rounds)
        punishment_threshold = self.game_description.capacity / (2 * self.game_description.n_players) * 0.25
        reward_threshold = 0.1
        if state.current_stock > stock_threshold:
            return Action.C
        elif state.current_stock < punishment_threshold:
            return Action.D
        else:
            prev_round_stock = history.my_payoffs[state.round_number - 1] * (2 * self.game_description.n_players)
            if prev_round_stock > reward_threshold and random.random() < 0.7:
                return Action.C
            elif random.random() < 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_286(BaseStrategy):
    """
    An adaptive collective strategy that balances individual interests with resource conservation goals.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.threshold = self.capacity / 2
        self.defector_trigger = self.n_players // 4
        self.stock_recovery_threshold = self.capacity / 10
        self.threshold_adjustment = self.capacity / 100

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number < self.n_players // 2:
            return Action.C
        previous_stock_level = state.current_stock
        if history is not None and history.my_actions.size > 0:
            previous_stock_level = history.opponent_payoffs[-1, 0] * (self.game_description.n_players - 1) + history.my_payoffs[-1]
        num_defectors_prev_round = self._count_defectors(history)
        stock_level_change = state.current_stock - previous_stock_level
        if state.current_stock > self.threshold and num_defectors_prev_round < self.defector_trigger:
            action = Action.C
        elif state.current_stock <= self.threshold or num_defectors_prev_round >= self.defector_trigger:
            action = Action.D
        if stock_level_change > self.stock_recovery_threshold:
            action = Action.C
        self._adjust_threshold(history)
        return action

    def _count_defectors(self, history: PlayerHistory) -> int:
        if history is None or history.opponent_actions.size == 0:
            return 0
        num_defectors_prev_round = np.sum(1 - history.opponent_actions[-1])
        return num_defectors_prev_round

    def _adjust_threshold(self, history: PlayerHistory):
        if history is not None and history.my_payoffs.size > 0:
            stock_level_change = history.my_payoffs[-1] * (self.game_description.n_players - 1) + history.opponent_payoffs[-1, 0]
            if np.sum(history.opponent_actions[-1]) >= self.game_description.n_players // 2 and stock_level_change > 0:
                self.threshold -= self.threshold_adjustment
            elif np.sum(1 - history.opponent_actions[-1]) >= self.game_description.n_players // 2 and stock_level_change < 0:
                self.threshold += self.threshold_adjustment
        self.threshold = max(self.capacity / 10, min(self.capacity * 0.9, self.threshold))

class Strategy_COLLECTIVE_287(BaseStrategy):
    """
    Collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.low_threshold = 0.5 * game_description.capacity
        self.high_threshold = 0.8 * game_description.capacity
        self.cooperation_likelihood = 1.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_consumption_prev = np.mean(history.my_payoffs[-1] / self.game_description.n_players + np.sum(history.opponent_payoffs[-1, :] / self.game_description.n_players))
        if state.current_stock > self.high_threshold:
            if avg_consumption_prev >= 0.75 * state.current_stock / self.game_description.n_players:
                action = Action.C
            else:
                action = Action.D
        elif self.low_threshold <= state.current_stock <= self.high_threshold:
            action = Action.C
        else:
            action = Action.D
        if avg_consumption_prev >= 0.75 * state.current_stock / self.game_description.n_players:
            self.cooperation_likelihood += 0.2
        else:
            self.cooperation_likelihood -= 0.1
        self.cooperation_likelihood = max(0, min(self.cooperation_likelihood, 1))
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        if random.random() < self.cooperation_likelihood and action != Action.C:
            return Action.C
        else:
            return action

class Strategy_COLLECTIVE_288(BaseStrategy):
    """
    This strategy balances individual interests with collective sustainability,
    adapting to the game's state and history. It promotes a cooperative atmosphere
    while considering opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        round_number = state.round_number
        current_stock = state.current_stock
        total_rounds = self.game_description.n_rounds
        if round_number == 0:
            return Action.C
        theta = capacity / (2 * n_players) * (1 + (total_rounds - round_number) / total_rounds)
        if history is not None:
            opponent_actions = history.opponent_actions[-1, :]
            cooperators = sum(opponent_actions)
            if cooperators > n_players // 2:
                return Action.C
        if history is not None and round_number >= n_players // 3:
            defector_count = np.sum(np.logical_not(history.opponent_actions[:round_number, :]), axis=0)
            defectors = np.where(defector_count > n_players // 3)[0]
            if len(defectors) > 0:
                return Action.C if current_stock > theta * 1.2 else Action.D
        if round_number == total_rounds - 1:
            return Action.C
        if current_stock < capacity / (4 * n_players):
            return Action.C
        elif current_stock > 3 / 4 * capacity:
            return Action.D
        return Action.C if current_stock > theta else Action.D

class Strategy_COLLECTIVE_289(BaseStrategy):
    """
    Collective Strategy: Adaptive Tit-for-Tat with Stock-Sensitive Cooperation (ATSC)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.my_actions) == 0):
            return Action.C
        previous_round_defections = self.count_defectors(history, state.round_number - 1)
        stock_decreased = self.stock_decreased(history, state.current_stock)
        cooperate = True
        if previous_round_defections > self.n_players / 2 and stock_decreased:
            cooperate = False
        elif previous_round_defections <= self.n_players / 2 and (not stock_decreased):
            cooperate = True
        if state.current_stock < self.capacity / 2:
            cooperate = True
        elif state.current_stock >= self.capacity / 2 and previous_round_defections > self.n_players / 2:
            cooperate = False
        own_payoff_avg = np.mean(history.my_payoffs) if len(history.my_payoffs) > 0 else float('inf')
        opponent_payoff_avg = np.mean(history.opponent_payoffs, axis=1) if len(history.opponent_payoffs) > 0 else []
        avg_opponent_payoff = np.mean(opponent_payoff_avg) if len(opponent_payoff_avg) > 0 else own_payoff_avg
        detected_defector = self.detected_defector(history)
        if own_payoff_avg < avg_opponent_payoff or detected_defector:
            cooperate = False
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock >= self.capacity / 2:
                return Action.C
            else:
                return Action.D
        return Action.C if cooperate else Action.D

    def count_defectors(self, history: PlayerHistory, round_number: int):
        opponent_actions = history.opponent_actions[round_number]
        return sum((1 for action in opponent_actions if not action))

    def stock_decreased(self, history: PlayerHistory, current_stock: float):
        if len(history.my_payoffs) == 0:
            return False
        previous_round_stock = self.calculate_stock(history, len(history.my_payoffs) - 1)
        return current_stock < previous_round_stock

    def detected_defector(self, history: PlayerHistory):
        opponent_actions = history.opponent_actions
        if len(opponent_actions) == 0:
            return False
        opponent_defection_rates = np.mean(~opponent_actions, axis=0)
        return any((defection_rate > 0.8 for defection_rate in opponent_defection_rates))

    def calculate_stock(self, history: PlayerHistory, round_number: int):
        my_payoffs = history.my_payoffs[:round_number + 1]
        opponent_payoffs = history.opponent_payoffs[:round_number + 1, :]
        total_consumption = np.sum(my_payoffs) + np.sum(opponent_payoffs)
        growth_rate = 2 * (self.capacity - total_consumption / self.n_players) * (1 - total_consumption / (self.capacity * self.n_players))
        return min(self.capacity, max(0, self.game_description.capacity - total_consumption + growth_rate))

class Strategy_COLLECTIVE_290(BaseStrategy):
    """
    A strategy that adapts to various opponent behaviors and focuses on long-term sustainability of the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock > self.threshold * self.game_description.capacity:
            return Action.C
        defected_players = sum((1 for action in history.opponent_actions[-1, :] if not action))
        if defected_players > 0 and state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        if defected_players > 0.5 * self.game_description.n_players:
            self.threshold = max(0, self.threshold - 0.1)
        else:
            self.threshold = min(1, self.threshold + 0.05)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_292(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and game states.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        prev_stock = self.capacity if state.round_number == 1 else history.my_payoffs[-2] * 2 * self.n_players
        if state.current_stock >= 0.75 * self.capacity:
            return Action.C
        elif 0.5 <= state.current_stock / self.capacity < 0.75:
            p = (state.current_stock / self.capacity) ** 2
            return Action.C if random.random() < p else Action.D
        else:
            if history.opponent_actions is not None and np.all(history.opponent_actions[:, 0] == False):
                return Action.D
            return Action.D
        if state.round_number + 1 == self.game_description.n_rounds:
            return Action.D

class Strategy_COLLECTIVE_293(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Threshold (ACS) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.opponent_behavior = {}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        T = self.capacity / 2
        for i in range(self.game_description.n_players - 1):
            action = 'C' if history.opponent_actions[-1, i] else 'D'
            if action == 'D':
                self.opponent_behavior[i] = self.opponent_behavior.get(i, 0) + 0.1
            elif action == 'C':
                self.opponent_behavior[i] = max(0, self.opponent_behavior.get(i, 0) - 0.1)
        if state.current_stock > T:
            return Action.C
        p = self.calculate_defection_probability(state.current_stock, self.capacity, self.game_description.n_rounds - state.round_number)
        for opponent in self.opponent_behavior.values():
            p += opponent / (self.game_description.n_players - 1)
        if random.random() < p:
            return Action.D
        else:
            return Action.C

    def calculate_defection_probability(self, stock: float, capacity: int, rounds_remaining: int) -> float:
        """
        Calculate the base probability of defection.
        """
        if rounds_remaining > 2:
            return 0.5 * (1 - stock / capacity)
        elif rounds_remaining == 2:
            return 0.8 * (1 - stock / capacity)
        else:
            return 1

class Strategy_COLLECTIVE_294(BaseStrategy):
    """
    A strategy that balances individual payoffs with collective sustainability by adapting to varying opponent behaviors and the current state of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        total_rounds = self.game_description.n_rounds
        n_players = self.game_description.n_players
        if state.round_number == 0:
            return Action.C if state.current_stock >= 0.9 * capacity else Action.D
        elif 1 <= state.round_number < total_rounds - 1:
            p_defect = self.estimate_proportion_defected(history.opponent_actions)
            stock = state.current_stock
            if stock >= 0.75 * capacity:
                return Action.C
            elif stock <= 0.25 * capacity:
                return Action.D
            else:
                cooperate_prob = 1 - p_defect
                return Action.C if random.random() < cooperate_prob else Action.D
        else:
            return Action.D if state.current_stock <= 0.25 * capacity else Action.C

    def estimate_proportion_defected(self, opponent_actions: NDArray[np.bool_]) -> float:
        """
        Estimate the proportion of opponents who defected in the last round.
        
        :param opponent_actions: Opponents' actions, indexed [round, player]
        :return: Proportion of opponents who defected
        """
        if len(opponent_actions.shape) < 2 or opponent_actions.shape[0] == 0:
            return 0.5
        last_round_actions = opponent_actions[-1, :]
        proportion_defecting_opponents = np.mean(np.logical_not(last_round_actions))
        proportion_defecting_opponents = max(0.0, min(proportion_defecting_opponents, 1.0))
        return proportion_defecting_opponents

class Strategy_COLLECTIVE_295(BaseStrategy):
    """
    Adaptive Cooperation with Dynamic Threshold strategy.

    This strategy balances individual payoffs with collective sustainability by 
    dynamically adjusting the cooperation threshold based on game state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        total_consumption = np.sum(history.my_payoffs + np.sum(history.opponent_payoffs, axis=1))
        s_remaining = state.current_stock
        dT = (1 - total_consumption / (2 * self.game_description.n_players * self.game_description.capacity)) * 0.5 + s_remaining / self.game_description.capacity * 0.5
        if s_remaining < 0.1 * self.game_description.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if s_remaining / self.game_description.capacity > dT:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_296(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Tit-for-Tat strategy.
    
    This strategy starts by cooperating to establish a baseline. 
    It then adapts its decision based on the current stock level, 
    balancing individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        last_round = self.game_description.n_rounds - 1
        if stock_level > 0.75 or (state.round_number == last_round and history.my_payoffs.mean() > 0):
            return Action.C
        elif stock_level >= 0.5 and stock_level <= 0.75:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators >= self.game_description.n_players / 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_297(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Aware Tit-for-Tat strategy.
    
    This strategy prioritizes cooperation when the stock is abundant, 
    introduces Tit-for-Tat as the stock declines to promote reciprocity, 
    and defects to minimize losses when the stock is severely depleted.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (state.current_stock == 0 and state.round_number > 0):
            return Action.C
        if state.round_number + 1 == self.game_description.n_rounds:
            return Action.D
        stock_level = state.current_stock / self.game_description.capacity
        if stock_level >= 0.75:
            return Action.C
        elif stock_level >= 0.5 and stock_level < 0.75:
            previous_cooperation_rate = sum(history.opponent_actions[-1, :]) / (self.game_description.n_players - 1)
            if previous_cooperation_rate > 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_298(BaseStrategy):
    """
    Adaptive Stock Sensitive Tit-for-Tat strategy balances individual payoff maximization with collective stock sustainability.
    It adapts to the game's dynamic state and opponent behaviors, promoting cooperation while responding to defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        low_stock_threshold = self.capacity / 4
        high_stock_threshold = self.capacity * 3 / 4
        if current_stock >= high_stock_threshold:
            opponents_cooperated = sum(history.opponent_actions[-1, :]) > self.n_players / 2
            return Action.C if opponents_cooperated else Action.D
        elif current_stock <= low_stock_threshold:
            return Action.D
        else:
            opponents_cooperated = sum(history.opponent_actions[-1, :]) > self.n_players / 2
            total_consumption = np.sum(np.where(history.opponent_actions[-1, :], self.capacity / self.n_players, self.capacity / (2 * self.n_players)))
            return Action.C if opponents_cooperated and total_consumption < self.capacity / 2 else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif not history.opponent_actions[-1, :].all():
            return Action.D

class Strategy_COLLECTIVE_299(BaseStrategy):
    """
    Adaptive Stock Conservation strategy for the Common Pool Resource Game.
    Balances individual payoffs with collective sustainability by adapting to opponents' behaviors and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.my_index = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.my_index is None:
            self.my_index = np.argmax(np.sum(history.opponent_actions, axis=0) < np.sum(history.my_actions))
        avg_opponent_payoff = self.calculate_average_opponent_payoff(history)
        my_previous_payoff = self.my_previous_payoff(history)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        stock_level = state.current_stock / self.game_description.capacity
        if stock_level > 0.75:
            return Action.C
        elif 0.25 <= stock_level < 0.75:
            if avg_opponent_payoff > my_previous_payoff:
                return Action.D
            else:
                return Action.C
        else:
            if state.current_stock / self.game_description.capacity < 0.1:
                return Action.D
            return Action.D

    def calculate_average_opponent_payoff(self, history):
        opponent_payoffs = np.delete(history.opponent_payoffs[-1], self.my_index)
        return np.mean(opponent_payoffs)

    def my_previous_payoff(self, history):
        return history.my_payoffs[-1]

class Strategy_COLLECTIVE_300(BaseStrategy):
    """
    A collective strategy balancing individual self-interest with long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.round_number = 0
        self.stock_last_3_rounds = []
        self.my_payoffs_last_3_rounds = []
        self.opponents_actions_last_round = None
        self.cooperation_likelihood = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.round_number = state.round_number
        self.stock_last_3_rounds.append(state.current_stock)
        self.stock_last_3_rounds = self.stock_last_3_rounds[-3:]
        if history is not None:
            self.my_payoffs_last_3_rounds.append(history.my_payoffs[-1])
            self.my_payoffs_last_3_rounds = self.my_payoffs_last_3_rounds[-3:]
            self.opponents_actions_last_round = history.opponent_actions[-1, :]
        if state.round_number <= 3:
            return Action.C
        avg_stock_last_3_rounds = np.mean(self.stock_last_3_rounds) if self.stock_last_3_rounds else 0
        ACT = 0.7 * self.capacity
        if avg_stock_last_3_rounds >= ACT:
            return Action.C
        if state.current_stock < 0.4 * self.capacity:
            return Action.C
        opponents_cooperated = np.mean(self.opponents_actions_last_round) if self.opponents_actions_last_round is not None else 0
        if opponents_cooperated > 0.5:
            self.cooperation_likelihood += 0.1
            self.cooperation_likelihood = min(1, self.cooperation_likelihood)
        elif opponents_cooperated < 0.5:
            self.cooperation_likelihood -= 0.1
            self.cooperation_likelihood = max(0, self.cooperation_likelihood)
        total_payoff_last_3_rounds = sum(self.my_payoffs_last_3_rounds) if self.my_payoffs_last_3_rounds else 0
        average_payoff_per_round = np.mean(history.my_payoffs) if history is not None and len(history.my_payoffs) > 0 else 0
        if total_payoff_last_3_rounds < 0.5 * average_payoff_per_round:
            return Action.D
        if random.random() < self.cooperation_likelihood:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_301(BaseStrategy):
    """
    A strategy that adapts to the opponent's behavior while balancing individual payoffs with long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number <= 2:
            return Action.C if state.current_stock >= 0.75 * self.game_description.capacity else Action.D
        opponent_actions = history.opponent_actions[-2:, :]
        aocr = np.mean(opponent_actions)
        if state.current_stock >= 0.5 * self.game_description.capacity and aocr >= 0.5:
            return Action.C
        elif state.current_stock < 0.25 * self.game_description.capacity or aocr < 0.3:
            return Action.D
        elif random.random() < 0.7:
            opponent_action = np.any(history.opponent_actions[-1, :])
            return Action.C if opponent_action else Action.D
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C if state.current_stock >= 0.75 * self.game_description.capacity else Action.D

class Strategy_COLLECTIVE_302(BaseStrategy):
    """
    Adaptive Stock Preservation Strategy: 
    Balance individual self-interest with collective well-being by adapting to opponent behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < 0.75 * self.game_description.capacity:
            return Action.D
        opponent_actions = history.opponent_actions
        FC = np.sum(opponent_actions[:, :]) / (state.round_number * self.game_description.n_players)
        FD = 1 - FC
        if FC > FD:
            return Action.C
        elif FC < FD:
            return Action.D
        recent_stock_trend = np.diff(history.my_payoffs[-3:])
        if np.all(recent_stock_trend < 0) and np.abs(np.mean(recent_stock_trend)) > 25:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_303(BaseStrategy):
    """
    A strategy that adapts to changing stock levels and opponent behaviors while promoting cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.boost_cooperation_probability = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions_last_round = history.opponent_actions[-1]
        avg_cooperation_rate = np.mean(opponent_actions_last_round)
        if state.current_stock > 0.75 * self.capacity:
            p = 0.8 + 0.2 * avg_cooperation_rate
            return Action.C if random.random() < p else Action.D
        elif state.current_stock >= 0.5 * self.capacity and state.current_stock <= 0.75 * self.capacity:
            p = 0.5 - 0.1 * avg_cooperation_rate
            if random.random() < p:
                return Action.D
            else:
                return Action.C
        elif state.current_stock < 0.2 * self.capacity or state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.D
        for action in opponent_actions_last_round:
            if not action and random.random() < 0.7 + 0.3 * avg_cooperation_rate:
                return Action.D
            elif action and random.random() < 0.9 - 0.1 * np.mean(~opponent_actions_last_round):
                return Action.C
        if state.round_number % 5 == 0:
            avg_stock_level_last_5_rounds = np.mean([state.current_stock] + [history.my_payoffs[i] for i in range(max(0, state.round_number - 4), state.round_number)])
            if avg_stock_level_last_5_rounds > 0.6 * self.capacity and (not self.boost_cooperation_probability):
                self.boost_cooperation_probability = True
        elif self.boost_cooperation_probability and state.round_number % 10 == 4:
            self.boost_cooperation_probability = False
        if self.boost_cooperation_probability:
            return Action.C

class Strategy_COLLECTIVE_304(BaseStrategy):
    """
    Adaptive Collective Harvesting strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.current_stock < self.game_description.capacity / 4:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio > 0.75:
            return Action.C
        elif stock_ratio < 0.5:
            return Action.D
        if history is None or len(history.opponent_actions) == 0:
            return Action.C
        opponent_defection_rate = np.mean(~history.opponent_actions[-1, :])
        if opponent_defection_rate > 0.5:
            return Action.D
        else:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_305(BaseStrategy):
    """
    Adaptive Cooperation with Stock Sensitivity strategy for the Common Pool Resource Game.
    This strategy balances individual self-interest with collective sustainability by adapting to stock levels and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        high_stock_threshold = 0.75 * self.game_description.capacity
        low_stock_threshold = 0.25 * self.game_description.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock > high_stock_threshold:
            return Action.C
        elif state.current_stock < low_stock_threshold:
            return Action.D
        prev_consumption = np.sum(state.current_stock - history.my_payoffs[-1]) / self.game_description.n_players
        if prev_consumption > 0.5 * self.game_description.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_306(BaseStrategy):
    """
    Adaptive Cooperative Harvesting (ACH) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_stock = self.game_description.capacity if state.round_number == 1 else history.my_payoffs[-2] * 2 * self.game_description.n_players
        total_consumption = np.sum(history.opponent_actions[-1, :] * (previous_stock / self.game_description.n_players)) + history.my_actions[-1] * previous_stock / (2 * self.game_description.n_players)
        if state.current_stock < 0.5 * self.game_description.capacity or any((not action for action in history.opponent_actions[-1, :])) or total_consumption > 0.75 * previous_stock:
            return Action.D
        elif state.current_stock >= 0.5 * self.game_description.capacity and all((action for action in history.opponent_actions[-1, :])) and (total_consumption <= 0.75 * previous_stock):
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > 0.25 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        if opponent_cooperators >= self.game_description.n_players // 2:
            self.cooperation_threshold += 0.05
        elif opponent_cooperators < self.game_description.n_players // 2:
            self.cooperation_threshold -= 0.05
        return Action.C if state.current_stock > self.cooperation_threshold * self.game_description.capacity else Action.D

class Strategy_COLLECTIVE_307(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors 
    and focuses on maintaining a sustainable stock level while maximizing payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return random.choice([Action.C, Action.D])
        avg_payoff = np.mean(history.my_payoffs)
        C_count = sum(np.all(history.opponent_actions, axis=1))
        D_count = self.n_players - 1 - C_count
        if state.current_stock > 0.5 * self.capacity:
            if avg_payoff >= state.current_stock / (2 * self.n_players) or C_count >= self.n_players // 2:
                return Action.C
            else:
                return Action.D
        elif state.current_stock <= 0.5 * self.capacity:
            if C_count >= self.n_players // 4 and avg_payoff >= state.current_stock / self.n_players:
                return Action.C
            else:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.capacity // 10:
            return Action.C

class Strategy_COLLECTIVE_308(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) Strategy.

    This strategy aims to balance individual payoffs with long-term sustainability by adapting its behavior based on total consumption and current stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock >= 0.75 * self.capacity else Action.D
        previous_total_consumption = sum(history.opponent_actions[-1, :]) / self.game_description.n_players + history.my_actions[-1] / self.game_description.n_players
        if previous_total_consumption <= 0.5 and state.current_stock >= 0.75 * self.capacity:
            return Action.C
        if history.my_actions[-1] == True or state.current_stock < 0.25 * self.capacity:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_309(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACSDT).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        T = max(state.current_stock - self.capacity / (2 * self.n_players), 0)
        if history is not None and len(history.opponent_actions) > 0:
            opponent_cooperators_last_round = sum(history.opponent_actions[-1, :])
            if state.current_stock > T and opponent_cooperators_last_round >= 1:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < self.capacity / (2 * self.n_players):
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_310(BaseStrategy):
    """
    A collective strategy that adapts to various opponent behaviors and aligns with a collective mindset.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number < self.game_description.n_rounds // 4:
            opponent_actions = np.array(history.opponent_actions[:-1], dtype=bool)
            avg_coop_rate = np.mean(opponent_actions) if len(opponent_actions) > 0 else 0.5
            return Action.C if avg_coop_rate > self.threshold else Action.D
        current_stock = state.current_stock
        if current_stock > self.game_description.capacity / 2:
            P_C = (current_stock / self.game_description.capacity) ** 2
            return Action.C if random.random() < P_C else Action.D
        else:
            P_D = 1 - ((self.game_description.capacity - current_stock) / self.game_description.capacity) ** 2
            return Action.D if random.random() < P_D else Action.C
        if state.round_number >= 3 * self.game_description.n_rounds // 4:
            if current_stock > self.game_description.capacity / 2:
                return Action.C
            elif current_stock < self.game_description.capacity / 2 and state.round_number % 2 == 1:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_312(BaseStrategy):
    """
    A collective strategy that balances individual self-interest with collective sustainability.
    It adapts to the game's state and history, promoting cooperation while being robust against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_defection_counts = [0] * (game_description.n_players - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.update_defection_counts(history)
        stock_ratio = state.current_stock / self.game_description.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock_ratio > 0.75:
            return Action.C
        elif stock_ratio >= 0.25 and stock_ratio <= 0.75:
            p_coop = stock_ratio * (1 - self.get_total_consumption_previous_round(history) / self.game_description.capacity)
            return Action.C if random.random() < p_coop else Action.D
        else:
            return Action.D

    def update_defection_counts(self, history: PlayerHistory):
        opponent_actions = history.opponent_actions[-1]
        for i in range(len(opponent_actions)):
            if not opponent_actions[i]:
                self.opponent_defection_counts[i] += 1

    def get_total_consumption_previous_round(self, history: PlayerHistory) -> float:
        previous_stock = history.my_payoffs[-1] * 2 * self.game_description.n_players
        return previous_stock - (history.my_payoffs[-1] + np.sum(history.opponent_payoffs[-1]))

class Strategy_COLLECTIVE_313(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors 
    and aligns with a collective mindset.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_stock = history.my_payoffs[-1] * (2 * self.game_description.n_players)
        opponent_defection_rates = np.mean(history.opponent_actions, axis=0)
        mirroring_defection = any((defect_rate > 0.75 for defect_rate in opponent_defection_rates))
        if prev_round_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        elif prev_round_stock >= 0.5 * self.game_description.capacity:
            p = (prev_round_stock / self.game_description.capacity) ** 2
            if mirroring_defection or random.random() < p:
                return Action.D
            else:
                return Action.C
        elif mirroring_defection:
            return Action.D
        elif state.current_stock >= 0.25 * self.game_description.capacity and state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        else:
            return Action.D
        if history is not None and len(history.my_payoffs) > 2:
            stock_increase_over_time = history.my_payoffs[-1] / history.my_payoffs[-3] * 100
            if stock_increase_over_time > 20:
                return Action.C

class Strategy_COLLECTIVE_314(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choices([Action.C, Action.D], weights=[0.7, 0.3])[0]
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        stock_level = current_stock / capacity
        if stock_level >= 0.75:
            return Action.C
        elif stock_level >= 0.25 and stock_level < 0.75:
            p = (current_stock / capacity) ** 2
            return random.choices([Action.C, Action.D], weights=[p, 1 - p])[0]
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if stock_level >= 0.5:
                return Action.C
            else:
                return Action.D
        if current_stock < 1:
            return Action.C

class Strategy_COLLECTIVE_315(BaseStrategy):
    """
    A collective strategy that balances individual payoff maximization with 
    collective sustainability of the common pool resource. It adapts to the 
    previous round's payoffs and stock level, and explores alternative strategies.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_payoff = 0.75 * (game_description.capacity / (2 * game_description.n_players))
        self.threshold_stock = 0.25 * game_description.capacity
        self.exploration_prob = 0.05

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_payoff_prev_round = np.mean(history.my_payoffs[-1] + history.opponent_payoffs[-1, :])
        stock_level_prev_round = state.current_stock - state.current_stock / (2 * self.game_description.n_players)
        if random.random() < self.exploration_prob:
            return Action.C if random.choice([True, False]) else Action.D
        if avg_payoff_prev_round >= self.threshold_payoff or stock_level_prev_round < self.threshold_stock:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_316(BaseStrategy):
    """
    A collective strategy that balances individual payoff maximization with stock conservation to ensure long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.my_actions) < self.game_description.n_players):
            if state.current_stock > 0.75 * self.capacity:
                return Action.C
            else:
                return Action.D
        elif self.game_description.n_players < state.round_number < self.game_description.n_rounds - self.game_description.n_players:
            opponents_defected = sum((not action for action in history.opponent_actions[-1, :]))
            if state.current_stock < 0.5 * self.capacity or opponents_defected >= self.game_description.n_players / 2:
                return Action.D
            else:
                return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif state.current_stock > 0.25 * self.capacity and sum((not action for action in history.opponent_actions[-1, :])) < self.game_description.n_players / 2:
            return Action.C
        else:
            return Action.D
        if state.current_stock < 0.25 * self.capacity:
            return Action.D

class Strategy_COLLECTIVE_317(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Threshold (ACS-T) strategy.
    
    A dynamic, adaptive strategy that balances individual payoffs with collective sustainability.
    It uses a stock-based threshold to determine cooperation levels, ensuring the common pool resource remains viable throughout the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.C_prob = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        T = self.game_description.capacity / (2 * self.game_description.n_players)
        if state.current_stock > T:
            action = Action.C
        else:
            action = Action.D
        if history is not None:
            prev_round_outcomes = history.opponent_actions[-1, :]
            all_cooperated = np.all(prev_round_outcomes)
            any_defected = np.any(~prev_round_outcomes)
            if all_cooperated:
                self.C_prob += 0.1
                self.C_prob = min(self.C_prob, 1)
            elif any_defected:
                self.C_prob -= 0.2
                self.C_prob = max(self.C_prob, 0)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return random.choices([Action.C, Action.D], weights=[self.C_prob, 1 - self.C_prob])[0]

class Strategy_COLLECTIVE_318(BaseStrategy):
    """
    Adaptive Collective Conservation (ACC) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.75 * game_description.capacity
        self.opponent_payoff_window = min(5, game_description.n_rounds)
        self.my_average_payoffs = []
        self.opponent_avg_payoffs = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.my_average_payoffs.append(history.my_payoffs[-1])
        opponent_avg_payoff = np.mean(history.opponent_payoffs[-1, :])
        self.opponent_avg_payoffs.append(opponent_avg_payoff)
        if len(self.my_average_payoffs) > 3:
            my_last_3_payoffs = np.mean(self.my_average_payoffs[-3:])
            opponent_last_3_payoffs = np.mean(self.opponent_avg_payoffs[-3:])
            if opponent_last_3_payoffs > my_last_3_payoffs:
                return Action.D
        if state.current_stock > self.stock_threshold:
            return Action.C
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_319(BaseStrategy):
    """
    The Adaptive Stock Saver (ASS) strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        if state.round_number == 0 or history is None:
            return Action.C
        stock = state.current_stock
        avg_payoff_prev = np.mean(history.my_payoffs) if len(history.my_payoffs) > 1 else 0
        coop_count = sum((1 for action in history.opponent_actions[-1, :] if action))
        tau = 0.5 if stock >= capacity / 2 else 0.25 if capacity / 4 <= stock < capacity / 2 else 0
        if avg_payoff_prev > stock / (2 * n_players):
            tau -= 0.1
        if coop_count >= n_players / 2:
            tau += 0.1
        action = Action.D if random.random() < 1 - tau else Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        elif stock < capacity / 10:
            action = Action.C
        elif coop_count == 0:
            action = Action.C
        return action

class Strategy_COLLECTIVE_320(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Sensitive Defection (ACSSD) strategy.
    
    This strategy adapts to changes in stock levels and opponent behavior, 
    ensuring that cooperation is maintained when feasible and exploited players are deterred.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_percentage = state.current_stock / self.game_description.capacity
        if stock_percentage >= self.cooperation_threshold:
            return Action.C
        any_player_defected = np.any(~history.opponent_actions[-1, :])
        if stock_percentage < self.cooperation_threshold and any_player_defected:
            p = (1 - stock_percentage) / 0.3
            return Action.D if random.random() < p else Action.C
        multiple_players_defected = np.sum(~history.opponent_actions[-1, :]) >= 2
        if stock_percentage < 0.4 and multiple_players_defected:
            p = (1 - stock_percentage) / 0.2
            return Action.D if random.random() < p else Action.C
        another_player_defected = np.any(~history.opponent_actions[-1, :])
        self_cooperated = history.my_actions[-1]
        if another_player_defected and self_cooperated:
            self.cooperation_threshold = 0.5
        return Action.C

class Strategy_COLLECTIVE_321(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Trigger (ACST) strategy.
    Balances individual interests with collective well-being by adapting cooperation levels based on the current stock level and historical player actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.r = game_description.n_rounds
        self.avg_opponent_coop = None

    def calculate_avg_opponent_coop(self, history: PlayerHistory) -> float:
        recent_actions = history.opponent_actions[-2:, :]
        return np.mean(recent_actions)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        S = state.current_stock
        if t == 0:
            return Action.C
        elif t == self.r - 1:
            return Action.D
        S_th = self.capacity * (0.5 + (self.r - t) / (2 * self.r))
        if history is not None and len(history.my_actions) >= 2:
            self.avg_opponent_coop = self.calculate_avg_opponent_coop(history)
            if self.avg_opponent_coop > 0.5:
                S_th *= 1.1
            elif self.avg_opponent_coop < 0.3:
                S_th *= 0.9
        if S < self.capacity / (2 * self.n_players):
            return Action.D
        elif S > 0.9 * self.capacity:
            return Action.C
        if S > S_th:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_322(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Sensitive Defection (ACSSD) strategy.

    This strategy aims to balance cooperation and defection while adapting to the game's dynamic state and history.
    It prioritizes collective well-being while being robust to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / (2 * game_description.n_players + 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < 2:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.stock_threshold and history is None:
            return Action.D
        if state.current_stock < self.stock_threshold:
            return Action.D
        opponent_defected_last_round = False
        if history is not None:
            for opponent_action in history.opponent_actions[-1, :]:
                if opponent_action == 0:
                    opponent_defected_last_round = True
                    break
        if opponent_defected_last_round and state.current_stock >= self.stock_threshold:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_323(BaseStrategy):
    """
    Adaptive Collective Conservation (ACC) strategy for Common Pool Resource game.
    
    This strategy promotes cooperation and resource conservation by adapting to the current stock level, 
    previous round's actions, and the number of rounds remaining in the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round_actions = history.opponent_actions[-1, :] if history else None
        previous_cooperators = sum(previous_round_actions) if previous_round_actions is not None else 0
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        elif any((not action for action in previous_round_actions)):
            return Action.D
        elif state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        elif state.round_number >= self.game_description.n_rounds - 2:
            return Action.C
        elif all((action for action in previous_round_actions)) and state.current_stock > 0.5 * self.game_description.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_324(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy for the Common Pool Resource Game.
    
    ASC aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    It promotes cooperation when the stock is plentiful and defects when the stock is depleted, while also considering the actions of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        stock_percentage = state.current_stock / capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock_percentage > 0.75:
            return Action.C
        elif stock_percentage >= 0.5:
            prev_round_actions = history.opponent_actions[-1, :]
            cooperators = sum(prev_round_actions)
            if cooperators >= n_players / 2:
                return Action.C
            else:
                return Action.D
        elif stock_percentage < 0.25 or state.current_stock <= 0:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_325(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACST)

    Balances individual payoff maximization with collective sustainability by adapting to the current stock level and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperation_probabilities = [0.5] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.current_stock < 0.2 * self.game_description.capacity:
            return Action.C if state.round_number == self.game_description.n_rounds - 1 else Action.D
        tau = state.current_stock / self.game_description.capacity
        if tau >= 0.5:
            return Action.C
        p = (1 - tau) / (1 - 0.5)
        if random.random() < p:
            return Action.D
        if history is not None:
            for i, action in enumerate(history.opponent_actions[-1]):
                if action == 1:
                    self.opponent_cooperation_probabilities[i] += 0.1
                else:
                    self.opponent_cooperation_probabilities[i] -= 0.1
        if max(self.opponent_cooperation_probabilities) > 0.8 or state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_326(BaseStrategy):
    """
    A strategy that balances individual payoffs with long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        total_rounds = self.game_description.n_rounds
        if current_stock > 0.75 * self.capacity:
            return Action.C
        elif current_stock >= 0.5 * self.capacity:
            p = (current_stock / self.capacity) ** 2
            return Action.C if random.random() < p else Action.D
        else:
            return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        opponent_cooperation_rate = sum(opponent_actions) / len(opponent_actions)
        if opponent_cooperation_rate > 0.5:
            return Action.C
        else:
            return Action.D
        if state.round_number == total_rounds - 1:
            return Action.D
        if current_stock < 0.25 * self.capacity:
            return Action.C
        elif current_stock > 0.9 * self.capacity:
            return Action.D

class Strategy_COLLECTIVE_327(BaseStrategy):
    """
    Collective strategy "Adaptive Sustainability" to balance individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_depletion_penalty = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        ST = current_stock / capacity * (n_players - 1)
        if ST < 0.5:
            return Action.C
        p = (ST - 0.5) / (1 - 0.5)
        if random.random() < p:
            action = Action.D
        else:
            action = Action.C
        if history:
            my_actions = np.where(history.my_actions, True, False)
            opponent_defections = ~history.opponent_actions[-1]
            stock_depletion_warning = current_stock < capacity * 0.1
            if np.all(opponent_defections) and self.stock_depletion_penalty is False:
                self.stock_depletion_penalty = True
                return Action.C
            elif stock_depletion_warning and (not my_actions[-1]):
                return Action.C
            if current_stock > capacity * 0.2:
                self.stock_depletion_penalty = False
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return action

class Strategy_COLLECTIVE_328(BaseStrategy):
    """
    A collective strategy that balances individual payoff maximization with long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_defect_round = -1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_payoff = np.mean(history.my_payoffs[-3:]) if len(history.my_payoffs) >= 3 else np.mean(history.my_payoffs)
        max_possible_payoff = self.game_description.capacity / (2 * self.game_description.n_players)
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        if avg_payoff < 0.5 * max_possible_payoff and self.last_defect_round != state.round_number - 1:
            self.last_defect_round = state.round_number
            return Action.D
        if state.current_stock >= 0.75 * self.game_description.capacity and self.last_defect_round + 1 < state.round_number:
            return Action.C
        if state.round_number > self.game_description.n_rounds * 0.9:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_329(BaseStrategy):
    """
    Adaptive Cooperation with Stock Conservation (ACSC) strategy.
    
    This strategy balances individual payoffs with collective stock conservation, 
    adapting to changing game conditions and opponent behaviors. It prioritizes 
    cooperation when the stock is high and opponents are cooperative but defects 
    when opponents are uncooperative or the stock is low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.num_players = game_description.n_players
        self.capacity = game_description.capacity
        self.num_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        early_rounds = state.round_number < self.num_rounds / 2
        middle_rounds = self.num_rounds / 2 <= state.round_number < 3 * self.num_rounds / 4
        late_rounds = state.round_number >= 3 * self.num_rounds / 4
        if early_rounds:
            if state.current_stock > 0.75 * self.capacity:
                return Action.C
            else:
                defect_prob = 1 - state.current_stock / self.capacity
                return Action.D if random.random() < defect_prob else Action.C
        elif middle_rounds:
            opponent_defections = sum((not action for action in history.opponent_actions[-1, :]))
            if opponent_defections >= self.num_players / 2:
                return Action.D
            else:
                cooperate_prob = 1 - sum((not action for action in history.opponent_actions[-1, :])) / self.num_players
                return Action.C if random.random() < cooperate_prob else Action.D
        elif late_rounds:
            if state.current_stock < 0.25 * self.capacity:
                return Action.C
            else:
                defect_prob = sum((not action for action in history.opponent_actions[-1, :])) / self.num_players
                return Action.D if random.random() < defect_prob else Action.C
        if state.round_number == self.num_rounds - 1:
            return Action.D
        elif state.current_stock < 0.1 * self.capacity:
            return Action.C
        opponent_cooperation = sum((action for action in history.opponent_actions[-1, :])) / self.num_players
        if opponent_cooperation > 0.75:
            cooperate_prob = opponent_cooperation
            return Action.C if random.random() < cooperate_prob else Action.D
        return Action.D

class Strategy_COLLECTIVE_330(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation (AC)
    
    Aims to balance individual payoffs with collective sustainability by adapting 
    to the game's state and history. Promotes cooperation while being robust against 
    various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.tau_adjustment_delta = 0.05
        self.stock_based_gamma = 0.2

    def adaptive_cooperation(self, stock, capacity, num_opponents, history):
        tau = 0.5 * (stock / capacity)
        if history is not None:
            for opponent in range(num_opponents):
                if not history.opponent_actions[-1, opponent]:
                    tau -= self.tau_adjustment_delta
            if stock < capacity / 2:
                tau -= self.stock_based_gamma
            elif stock > capacity * 3 / 4:
                tau += self.stock_based_gamma
        return random.random() < tau

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        num_opponents = self.game_description.n_players - 1
        if state.round_number == 0 or (history is not None and len(history.my_actions) == 0):
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            cooperate = self.adaptive_cooperation(state.current_stock, self.game_description.capacity, num_opponents, history)
            return Action.C if cooperate else Action.D

class Strategy_COLLECTIVE_331(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that balances individual self-interest with long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = None
        self.defection_rate = 0
        self.opponent_actions_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number <= 1:
            return Action.C
        S = state.current_stock
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        if history is not None:
            self.opponent_actions_history.append(history.opponent_actions[-1, :])
        if len(self.opponent_actions_history) > 0:
            opponent_defections = np.sum(self.opponent_actions_history)
            self.defection_rate = opponent_defections / (len(self.opponent_actions_history) * n)
        stock_threshold = capacity / (n * 2) + (S - capacity / n)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if S < capacity / n:
            return Action.C
        if S > stock_threshold and self.defection_rate <= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_332(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Threshold Strategy.

    A collective strategy that balances individual gain and collective sustainability in a Common Pool Resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k = 3
        self.theta = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        if state.round_number == 0 or history is None:
            return Action.C
        T = capacity * (n_players - 1) / (2 * n_players)
        if state.current_stock > T:
            return Action.C
        opponent_actions = history.opponent_actions[-self.k:, :]
        DR = np.mean(opponent_actions == False)
        if DR > self.theta:
            return Action.D
        if state.current_stock < T:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1 and state.current_stock > T * 0.75:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_333(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Dependent Tit-for-Tat (ASDT) strategy.

    This strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and opponents' past behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity * 0.5
        self.critical_stock_level = game_description.capacity / 4
        self.defect_rate = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_defected = sum((not opponent_action for opponent_action in history.opponent_actions[-1, :]))
        self.defect_rate = opponents_defected / self.game_description.n_players
        if state.current_stock > self.stock_threshold and (any(history.opponent_actions[-1, :]) or state.current_stock > self.critical_stock_level):
            action = Action.C
        else:
            action = Action.D
        if state.current_stock < self.critical_stock_level and any((not opponent_action for opponent_action in history.opponent_actions[-1, :])):
            self.stock_threshold *= 0.9
        return action

class Strategy_COLLECTIVE_334(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Preservation.
    
    Prioritizes preserving the common pool resource while adapting to the actions of other players.
    Balances individual payoffs with collective sustainability by cooperating when stock is abundant and defecting when scarce.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        low_threshold = self.capacity / 4
        high_threshold = self.capacity / 2
        if state.current_stock > high_threshold:
            return Action.C
        elif state.current_stock < low_threshold:
            return Action.D
        else:
            previous_cooperators = sum(history.opponent_actions[-1, :])
            if previous_cooperators >= self.game_description.n_players / 2 or (previous_cooperators == self.game_description.n_players / 2 and random.random() < 0.5):
                return Action.C
            else:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_335(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACST)

    This strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and game history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_score = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        threshold = self.game_description.capacity / (2 * self.game_description.n_players) * (1 - state.current_stock / self.game_description.capacity)
        expected_payoff_C = state.current_stock / (2 * self.game_description.n_players)
        if expected_payoff_C >= threshold:
            return Action.C
        else:
            return Action.D
        if history is not None:
            cooperators = sum(history.opponent_actions[-1, :])
            self.cooperation_score = cooperators / self.game_description.n_players
        if self.cooperation_score > 0.5 and state.round_number < self.game_description.n_rounds - 1:
            return Action.C
        elif self.cooperation_score < 0.5 and state.round_number < self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C

class Strategy_COLLECTIVE_336(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game.
    
    This strategy initially cooperates to establish a baseline for cooperation and observe other players' actions.
    It then adapts its behavior based on the current stock level, previous round's consumption, and history of opponent actions.
    The goal is to balance individual interests with collective well-being while being robust to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.theta = 0.5
        self.delta_theta = 0.05
        self.phi = 0.8
        self.stock_history = []
        self.consumption_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.stock_history.append(state.current_stock)
        if len(self.stock_history) > self.n_players + 1:
            self.stock_history.pop(0)
        avg_stock_level = np.mean(np.array(self.stock_history))
        if len(self.consumption_history) > 0 and avg_stock_level < np.mean(np.array(self.consumption_history)):
            self.theta += self.delta_theta
        elif len(self.consumption_history) > 0 and avg_stock_level > np.mean(np.array(self.consumption_history)):
            self.theta -= self.delta_theta
        self.theta = max(0, min(1, self.theta))
        if state.current_stock > self.theta * self.capacity:
            return Action.C
        if history is not None and len(history.my_actions) > 0:
            prev_round_consumption = sum([1 if action == Action.D else 0.5 for action in history.opponent_actions[-1, :]]) + (1 if history.my_actions[-1] == Action.D else 0.5)
            if prev_round_consumption > self.phi * self.capacity:
                return Action.D
        return Action.D

    def post_game(self, state: CommonPoolState, history: PlayerHistory):
        for round_num in range(len(history.my_actions)):
            total_consumption = sum([1 if action == Action.D else 0.5 for action in history.opponent_actions[round_num, :]]) + (1 if history.my_actions[round_num] == Action.D else 0.5)
            self.consumption_history.append(total_consumption)

class Strategy_COLLECTIVE_337(BaseStrategy):
    """
    Adaptive Stock Conservation strategy for the Common Pool Resource Game.
    
    This strategy balances individual payoffs with collective sustainability by adapting to the dynamic state and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        conservation_threshold = 0.75 * capacity
        alarm_threshold = 0.25 * capacity
        avg_payoff_history = np.mean(history.my_payoffs[max(0, state.round_number - 3):]) if state.round_number >= 3 else history.my_payoffs[0]
        opponents_cooperated = sum(history.opponent_actions[-1, :])
        cooperation_incentive = (conservation_threshold - state.current_stock) / capacity * (1 + avg_payoff_history)
        if state.round_number == self.game_description.n_rounds - 1 or state.current_stock <= 0:
            return Action.D
        if state.current_stock >= conservation_threshold:
            return Action.C
        elif state.current_stock < alarm_threshold:
            return Action.D
        if cooperation_incentive > 0 and opponents_cooperated >= n_players // 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_338(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy for the Common Pool Resource Game.
    This strategy aims to balance individual payoffs with collective sustainability by adapting to the dynamic state and history of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_coop_rate = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        opponent_history = history if history is not None else PlayerHistory(my_actions=np.array([]), my_payoffs=np.array([]), opponent_actions=np.array([[]]), opponent_payoffs=np.array([[]]))
        if self.opponent_coop_rate is None:
            self.opponent_coop_rate = np.mean(opponent_history.opponent_actions, axis=0)
        if stock_ratio > 0.75:
            return Action.C
        elif 0.5 <= stock_ratio < 0.75:
            p = stock_ratio ** 2
            return Action.C if random.random() < p else Action.D
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > 0.25 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        elif state.current_stock > 0.9 * self.game_description.capacity:
            return Action.C
        for i, rate in enumerate(self.opponent_coop_rate):
            if rate > 0.7:
                pass
            elif rate < 0.3:
                pass

class Strategy_COLLECTIVE_339(BaseStrategy):
    """
    Adaptive Stock Conservation strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        S_low = 0.5 * capacity
        S_high = 0.8 * capacity
        if state.round_number == 0:
            return Action.C
        stock = state.current_stock
        if stock > S_high:
            return Action.C
        elif S_low <= stock <= S_high:
            p = (stock - S_low) / (S_high - S_low)
            if random.random() < p:
                return Action.C
            else:
                return Action.D
        elif stock < S_low:
            return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        majority_cooperated = np.mean(opponent_actions) > 0.5
        if majority_cooperated:
            p += 0.1
        else:
            p -= 0.1
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock == S_low or stock == S_high:
            return Action.C

class Strategy_COLLECTIVE_340(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with the long-term sustainability of the common pool resource.
    It adapts to the game state and history, making it robust against various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def calculate_avg_depletion_rate(self, history: PlayerHistory) -> float:
        total_consumption = np.sum(history.my_payoffs[:history.my_actions.size]) + np.sum(np.sum(history.opponent_payoffs[:, :], axis=1))
        avg_depletion_rate = total_consumption / (self.n_players * self.capacity)
        return avg_depletion_rate

    def calculate_cooperation_score(self, history: PlayerHistory) -> float:
        previous_round_payoff = history.my_payoffs[-1] if history.my_actions.size > 0 else 0
        opponent_payoffs_sum = np.sum(history.opponent_payoffs[-1, :]) if history.opponent_payoffs.shape[0] > 0 else 0
        cooperation_score = (previous_round_payoff + opponent_payoffs_sum) / (self.n_players * self.capacity / 2)
        return cooperation_score

    def calculate_defection_probability(self, stock: float, capacity: int) -> float:
        if stock <= 0.25 * capacity:
            p = 1
        elif stock <= 0.5 * capacity:
            p = 0.75
        elif stock <= 0.75 * capacity:
            p = 0.5
        else:
            p = 0.25
        return p

    def punish_over_exploitation(self, history: PlayerHistory) -> bool:
        if history.my_actions.size < 3:
            return False
        previous_three_rounds_my_payoff = np.sum(history.my_payoffs[-3:])
        opponent_previous_three_rounds_avg_payoff = np.mean(np.sum(history.opponent_payoffs[-3:, :], axis=0))
        return previous_three_rounds_my_payoff > 2 * opponent_previous_three_rounds_avg_payoff

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_depletion_rate = self.calculate_avg_depletion_rate(history)
        cooperation_score = self.calculate_cooperation_score(history)
        if state.round_number <= 5:
            if avg_depletion_rate < 0.5 * self.capacity:
                return Action.C
            else:
                return Action.D
        else:
            punish = self.punish_over_exploitation(history)
            if cooperation_score >= 0.5 or state.round_number == self.game_description.n_rounds - 1 or state.current_stock <= 0.1 * self.capacity:
                return Action.C
            elif state.current_stock > 0 and (not punish):
                p = self.calculate_defection_probability(state.current_stock, self.capacity)
                return Action.D if random.random() < p else Action.C
            return Action.D

class Strategy_COLLECTIVE_341(BaseStrategy):
    """
    Adaptive Stock Preservation (ASP) strategy for Common Pool Resource Game.
    Balances individual self-interest with collective preservation of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C
        stock_level = state.current_stock / capacity
        if stock_level > 0.75:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        defectors = sum((1 for action in opponent_actions if not action))
        if defectors > n / 2:
            return Action.D
        consecutive_defections = 0
        for i in range(1, len(history.my_actions)):
            if not history.my_actions[i] and (not history.my_actions[i - 1]):
                consecutive_defections += 1
        if consecutive_defections >= 2:
            return Action.D
        if state.round_number > 0.8 * r:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_342(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Dependent Threshold strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / (2 * game_description.n_players)
        self.cooperate_prob = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_prev_actions = history.opponent_actions[-1, :]
        stock_level = state.current_stock
        if stock_level < self.threshold:
            return Action.D
        elif all(opponents_prev_actions):
            self.cooperate_prob = 1
            return Action.C
        elif any((not action for action in opponents_prev_actions)):
            self.cooperate_prob = 0.5
            return Action.C if random.random() < self.cooperate_prob else Action.D
        else:
            self.cooperate_prob = stock_level / self.game_description.capacity
            return Action.C if random.random() < self.cooperate_prob else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_343(BaseStrategy):
    """
    Adaptive Collective Conservation (ACC) strategy balances individual payoff with collective conservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_defected_prev_round = sum((not action for action in history.opponent_actions[-1, :]))
        avg_payoff_prev_round = np.mean(history.my_payoffs)
        stock_level_ratio = state.current_stock / self.game_description.capacity
        if stock_level_ratio > 0.75:
            return Action.C
        elif 0.5 <= stock_level_ratio <= 0.75:
            return Action.D if opponents_defected_prev_round > self.game_description.n_players // 2 else Action.C
        else:
            return Action.C if avg_payoff_prev_round > state.current_stock / (2 * self.game_description.n_players) else Action.D

class Strategy_COLLECTIVE_344(BaseStrategy):
    """
    A dynamic strategy that balances individual payoffs with collective stock conservation.
    It responds to opponent behaviors and adjusts its actions based on the game's history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_conservation_threshold = 0.7 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_defections = sum((1 for opponent_action in history.opponent_actions[-1, :] if not opponent_action))
        stock_growth_rate = history.my_payoffs[-1] / self.game_description.n_players * (1 - state.current_stock / self.game_description.capacity)
        if state.current_stock < self.stock_conservation_threshold or stock_growth_rate < 0.5:
            action = Action.C
        elif opponent_defections >= self.game_description.n_players // 2:
            action = Action.D
        else:
            action = Action.C if state.current_stock > self.stock_conservation_threshold else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        return action

class Strategy_COLLECTIVE_345(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Dependent Threshold (ACSDT)
    
    This strategy aims to balance individual payoffs with collective sustainability 
    by adapting cooperation levels based on the current stock level and game history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.stock_history) == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        self.stock_history.append(state.current_stock)
        threshold = self.game_description.capacity / 2 + (self.game_description.capacity - self.stock_history[-2]) / 4
        critical_threshold = self.game_description.capacity / 4
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock > threshold and state.current_stock >= critical_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_346(BaseStrategy):
    """
    Adaptive Cooperation strategy for Common Pool Resource game.
    
    This strategy balances individual payoff maximization with collective sustainability 
    by dynamically adjusting cooperation levels based on game history, state, and parameters.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_probability = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        observed_defection_in_previous_round = history is not None and np.any(history.opponent_actions[-1, :] == 0)
        if observed_defection_in_previous_round:
            return Action.D if random.random() < self.punishment_probability else Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if current_stock < 0.1 * capacity:
            return Action.C
        cooperation_probability = 0.7 + 0.3 * (current_stock / capacity)
        if current_stock > 0.75 * capacity:
            return Action.C if random.random() < cooperation_probability else Action.D
        elif current_stock >= 0.25 * capacity and current_stock <= 0.75 * capacity:
            defect_probability = 0.5 - 0.2 * (current_stock / capacity)
            return Action.D if random.random() < defect_probability else Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_347(BaseStrategy):
    """
    A collective strategy that adapts to various opponent behaviors in the Common Pool Resource Game.
    It prioritizes cooperation when possible, conserving the resource while adapting to changes in opponent behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_probabilities = {}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_opponent_actions = history.opponent_actions[-1, :]
        p_c = sum(prev_opponent_actions) / len(prev_opponent_actions)
        p_d = 1 - p_c
        if p_c >= 0.5:
            return Action.C
        elif p_c < 0.5 and state.current_stock > 0.75 * self.game_description.capacity:
            return Action.D if random.random() < 0.2 else Action.C
        elif p_c < 0.5 and state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        for i, opponent_action in enumerate(prev_opponent_actions):
            if not opponent_action and state.current_stock > 0.75 * self.game_description.capacity:
                self.punishment_probabilities.setdefault(i, 0)
                self.punishment_probabilities[i] += 0.1
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock < 0.5 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C
        if len(prev_opponent_actions) == 1:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_348(BaseStrategy):
    """
    A collective strategy that adapts to various opponent behaviors while prioritizing sustainability and fairness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.3
        self.sustainability_threshold = 0.5 * game_description.capacity
        self.critical_stock_level = 0.1 * game_description.capacity
        self.monitoring_window = 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < min(3, self.game_description.n_rounds):
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        opponent_cooperation_rates = np.mean(history.opponent_actions[max(0, history.my_actions.size - self.monitoring_window):], axis=0)
        num_cooperating_opponents = np.sum(opponent_cooperation_rates >= self.cooperation_threshold)
        if state.current_stock < self.sustainability_threshold:
            return Action.D
        all_opponents_are_defectors = np.all(opponent_cooperation_rates < self.cooperation_threshold)
        if num_cooperating_opponents > 0 and state.current_stock >= 0.5 * self.game_description.capacity:
            return Action.C
        elif all_opponents_are_defectors or state.current_stock < self.critical_stock_level:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_349(BaseStrategy):
    """
    Adaptive Cooperate-Defect (ACD) strategy for the Common Pool Resource Game.
    Aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock < 0.1 * capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if current_stock >= 0.75 * capacity:
            return Action.C
        elif current_stock >= 0.25 * capacity and current_stock < 0.75 * capacity:
            p = (current_stock / capacity) ** 2
            return Action.C if random.random() < p else Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_350(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that is adaptive and robust to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_threshold_cooperate = game_description.capacity * 0.7
        self.capacity_threshold_defect = game_description.capacity * 0.3
        self.critical_stock_level = game_description.capacity * 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        recent_defections = np.sum(history.opponent_actions[-int(self.game_description.n_rounds / 8):, :])
        if self.game_description.n_players - recent_defections > self.game_description.n_players / 2:
            return Action.D
        if state.round_number < self.game_description.n_rounds // 4:
            return Action.C
        if state.current_stock > self.capacity_threshold_cooperate:
            return Action.C
        if state.current_stock < self.capacity_threshold_defect or recent_defections >= self.game_description.n_players / 2:
            return Action.D
        if state.current_stock < self.critical_stock_level:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_351(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Conservation (ASC)
    
    Prioritizes collective conservation while allowing for adaptive responses to opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponents_defected_last_round = 0
        self.avg_payoff_prev_round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.opponents_defected_last_round = sum((1 for action in history.opponent_actions[-1, :] if not action))
        self.avg_payoff_prev_round = np.mean(history.my_payoffs[-1:] + history.opponent_payoffs[-1, :].flatten())
        stock_threshold = 0.75 * self.game_description.capacity
        if state.current_stock < stock_threshold:
            return Action.D
        opponents_defected_majority = self.opponents_defected_last_round > self.game_description.n_players / 2
        if opponents_defected_majority:
            return Action.D
        my_payoff_prev_round = history.my_payoffs[-1]
        if my_payoff_prev_round < 0.75 * self.avg_payoff_prev_round:
            return Action.D
        final_round_threshold = 0.5 * self.game_description.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > final_round_threshold:
                return Action.C
            else:
                return Action.D
        critical_stock_level = 0.25 * self.game_description.capacity
        if state.current_stock < critical_stock_level and self.opponents_defected_last_round == self.game_description.n_players - 1:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_352(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Conservation (ASC)
    
    The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[-1]
        opponent_defected = any((action == False for action in previous_round_opponent_actions))
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        elif state.current_stock < 0.5 * self.game_description.capacity or opponent_defected:
            return Action.D
        elif random.random() < 0.5 and opponent_defected and (state.current_stock >= 0.5 * self.game_description.capacity):
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_353(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock-Based Threshold (ATTS) strategy.
    
    This strategy aims to balance cooperation and self-interest by adapting to the game's state and history while maintaining a collective mindset.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.5 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < self.threshold:
            action = Action.D
        else:
            action = Action.C
        if history is not None and state.round_number < self.game_description.n_rounds - 1:
            new_stock = max(current_stock + 2 * current_stock * (1 - current_stock / self.game_description.capacity), 0)
            stock_growth = new_stock - current_stock
            if stock_growth > 0:
                self.threshold *= 0.9
            else:
                self.threshold *= 1.1
        return action

class Strategy_COLLECTIVE_354(BaseStrategy):
    """
    The Adaptive Stock Conservation (ASC) strategy balances individual payoffs with collective sustainability by adapting to the current game state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5
        self.opponent_cooperation_rate = None
        self.stock_trend = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.opponent_cooperation_rate = np.mean(history.opponent_actions[-1, :])
        self.stock_trend = self.determine_stock_trend(state.current_stock, history.my_payoffs)
        if self.opponent_cooperation_rate > 0.5:
            self.cooperation_threshold += 0.1
        else:
            self.cooperation_threshold -= 0.1
        if self.stock_trend == 'decreasing':
            self.cooperation_threshold -= 0.1
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        elif state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        elif state.current_stock < self.cooperation_threshold * self.game_description.capacity:
            return Action.D
        else:
            return Action.C

    def determine_stock_trend(self, current_stock: float, my_payoffs: NDArray[np.float64]) -> str:
        window_size = min(5, len(my_payoffs))
        stock_levels = [payoff * 2 * self.game_description.n_players for payoff in my_payoffs[-window_size:]]
        stock_trend = 'increasing' if all((stock_levels[i] <= stock_levels[i + 1] for i in range(len(stock_levels) - 1))) else 'decreasing' if all((stock_levels[i] >= stock_levels[i + 1] for i in range(len(stock_levels) - 1))) else 'stable'
        return stock_trend

class Strategy_COLLECTIVE_355(BaseStrategy):
    """
    Adaptive Stock Conservation strategy for Common Pool Resource Game.
    This strategy balances individual payoffs with collective sustainability,
    adapting to the game's dynamic state and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_defection_rate_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_defection_rate = self.calculate_opponent_defection_rate(history)
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio > 0.75:
            p_cooperate = 1.0 - opponent_defection_rate * 0.2
        elif stock_ratio >= 0.5 and stock_ratio <= 0.75:
            p_cooperate = 0.7 - opponent_defection_rate * 0.2
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif random.random() < p_cooperate:
            return Action.C
        else:
            return Action.D

    def calculate_opponent_defection_rate(self, history: PlayerHistory):
        opponent_defections = np.sum(1 - history.opponent_actions)
        total_opponent_actions = history.opponent_actions.shape[0] * (self.game_description.n_players - 1)
        if total_opponent_actions == 0:
            return 0.0
        opponent_defection_rate = opponent_defections / total_opponent_actions
        self.opponent_defection_rate_history.append(opponent_defection_rate)
        avg_opponent_defection_rate = np.mean(self.opponent_defection_rate_history)
        if avg_opponent_defection_rate > 0.5:
            return max(avg_opponent_defection_rate, 0.5)
        else:
            return avg_opponent_defection_rate

class Strategy_COLLECTIVE_356(BaseStrategy):
    """
    Adaptive Cooperation with Stock Thresholds (ACST) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        low_threshold = self.capacity / 4
        high_threshold = 3 * self.capacity / 4
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock > high_threshold:
            return Action.C
        elif state.current_stock < low_threshold:
            return Action.D
        else:
            opponent_actions = history.opponent_actions[-1, :]
            cooperators = sum(opponent_actions)
            if cooperators >= len(opponent_actions) / 2:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_357(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy balances individual payoff maximization 
    with collective sustainability, ensuring robust performance across various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == 1:
            return Action.C
        if state.round_number < 4:
            if np.all(history.opponent_actions[-1, :] == True):
                return Action.C
            else:
                return Action.D if random.random() < 0.5 else Action.C
        depletion_rate = (self.capacity - state.current_stock) / self.capacity
        if depletion_rate > 0.5 or state.current_stock < 0.25 * self.capacity:
            return Action.C
        else:
            p_C = 1 - depletion_rate
            return Action.C if random.random() < p_C else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C

class Strategy_COLLECTIVE_358(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Conservation (ASC)

    This strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_depletion_threshold = 0.5 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock < self.stock_depletion_threshold:
            return Action.D
        opponent_actions = history.opponent_actions[:-1]
        p_C = np.mean(opponent_actions)
        if p_C > 0.5:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_359(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Threshold (ACS) strategy.
    
    This strategy balances cooperation and defection based on the current stock level, round number, and game parameters.
    By adjusting its behavior in response to changing conditions, ACS aims to achieve a high total payoff while maintaining sustainable exploitation of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        remaining_rounds = self.game_description.n_rounds - state.round_number
        stock_threshold = self.game_description.capacity / (2 * self.game_description.n_players) + remaining_rounds * (self.game_description.capacity / (self.game_description.n_players * self.game_description.n_rounds))
        if state.current_stock > stock_threshold:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        elif state.current_stock > 0.9 * self.game_description.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_360(BaseStrategy):
    """
    This strategy prioritizes collective well-being by encouraging cooperation when the common resource is plentiful,
    adapting to changing stock levels and consumption patterns, and avoiding over-exploitation of the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_consumption = self._calculate_total_consumption(state, history)
        if state.round_number == 1 or self.cooperation_threshold is None:
            self.cooperation_threshold = state.current_stock / (2 * self.game_description.n_players)
        if total_consumption < self.cooperation_threshold:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > 0.25 * self.game_description.capacity:
                return Action.C
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D

    def _calculate_total_consumption(self, state: CommonPoolState, history: PlayerHistory):
        previous_round_payoffs = history.my_payoffs[-1] if len(history.my_payoffs) > 0 else 0
        opponent_payoffs_sum = np.sum(history.opponent_payoffs[-1, :]) if len(history.opponent_payoffs) > 0 else 0
        return previous_round_payoffs + opponent_payoffs_sum

class Strategy_COLLECTIVE_361(BaseStrategy):
    """
    Adaptive Cooperation with Stock Conservation (ACSC) strategy.
    
    This strategy prioritizes cooperation while adapting to the game's dynamic state and opponent behavior.
    By conserving stock levels and responding to opponents' actions, this strategy promotes a collective mindset 
    that balances individual payoffs with the sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.theta = 0.5
        self.avg_opponent_payoff = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.theta = state.current_stock / (self.game_description.n_players * self.game_description.capacity)
        if history is not None:
            prev_round_opponent_payoffs = history.opponent_payoffs[-1, :]
            avg_prev_round_opponent_payoff = np.mean(prev_round_opponent_payoffs)
            self.avg_opponent_payoff = (self.avg_opponent_payoff * state.round_number + avg_prev_round_opponent_payoff) / (state.round_number + 1)
        if self.avg_opponent_payoff >= state.current_stock / (2 * self.game_description.n_players):
            self.theta -= 0.1
        else:
            self.theta += 0.1
        if self.theta >= 0.5:
            action = Action.C
        else:
            action = Action.D
        if state.current_stock < self.game_description.capacity / 2:
            action = Action.D
        if state.round_number == self.game_description.n_rounds - 1 and state.current_stock > self.game_description.capacity / 2:
            return Action.C
        return action

class Strategy_COLLECTIVE_362(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = np.where(history.opponent_actions == True, 1, 0)
        average_opponent_action = np.mean(opponent_actions)
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        elif state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        elif average_opponent_action >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_364(BaseStrategy):
    """
    Adaptive Stock Conservation strategy, balancing individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.sustain_threshold = 0.5 * game_description.capacity
        self.conservation_threshold = 0.25 * game_description.capacity
        self.avg_opponent_payoff = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        avg_opponent_payoffs = np.mean(history.opponent_payoffs[-1, :])
        if current_stock > self.sustain_threshold:
            cooperate_probability = 1
        elif current_stock >= self.conservation_threshold:
            avg_opponent_payoff_scaled = (avg_opponent_payoffs - 0.5) / (self.game_description.capacity / self.game_description.n_players)
            cooperate_probability = 0.5 + avg_opponent_payoff_scaled
            cooperate_probability = max(0, min(cooperate_probability, 1))
        else:
            cooperate_probability = 1
        if random.random() < cooperate_probability or state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_365(BaseStrategy):
    """
    Adaptive Stock-Based Cooperation Strategy.
    
    This strategy adapts cooperation levels based on the current stock level and history of opponent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.adaptation_parameter = 0.5
        self.responsiveness_parameter = 0.2
        self.homogeneity_parameter = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        remaining_capacity = self.capacity - current_stock
        if remaining_capacity <= self.capacity / 4:
            return Action.D
        threshold = self.capacity / (2 * self.n_players) * (1 + self.adaptation_parameter * (current_stock / self.capacity))
        opponent_cooperators = np.sum(history.opponent_actions[-1, :])
        if history is not None and len(history.my_actions) > 0:
            last_round_opponents = history.opponent_actions[-1]
            cooperators_in_last_round = sum(last_round_opponents)
            threshold *= 1 + self.responsiveness_parameter * (cooperators_in_last_round / self.n_players)
        if all(history.opponent_actions[-1, :]) or not any(history.opponent_actions[-1, :]):
            threshold *= 1 + self.homogeneity_parameter * (self.n_players - 1) / self.n_players
        if current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_366(BaseStrategy):
    """
    Collective Strategy: Adaptive Common Pool Resource Management (ACPRM)

    Aims to balance individual payoffs with collective sustainability, adapting to various opponent behaviors and game states.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_prob = 1.0
        self.defect_threshold = 0.4 * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        prev_round_defectors = sum((not action for action in history.opponent_actions[-1, :]))
        if state.current_stock >= 0.8 * self.game_description.capacity:
            return Action.C
        elif prev_round_defectors >= self.defect_threshold:
            return Action.D
        elif state.round_number >= 0.8 * self.game_description.n_rounds:
            return Action.C
        else:
            delta_pi_avg = self.calculate_average_payoff_difference(history)
            if delta_pi_avg > 0.1 * self.game_description.capacity:
                self.cooperation_prob += 0.2
            elif delta_pi_avg < -0.1 * self.game_description.capacity:
                self.cooperation_prob -= 0.2
                self.cooperation_prob = max(self.cooperation_prob, 0)
            return Action.C if random.random() < self.cooperation_prob else Action.D

    def calculate_average_payoff_difference(self, history: PlayerHistory):
        avg_cooperator_payoff = np.mean([payoff for t, (action, payoff) in enumerate(zip(history.my_actions, history.my_payoffs)) if action and t >= 0.8 * len(history.my_actions)])
        avg_defector_payoff = np.mean([payoff for t, (action, payoff) in enumerate(zip(history.my_actions, history.my_payoffs)) if not action and t >= 0.8 * len(history.my_actions)])
        return avg_cooperator_payoff - avg_defector_payoff

class Strategy_COLLECTIVE_367(BaseStrategy):
    """
    A collective strategy that combines elements of tit-for-tat with adaptive adjustments based on the current stock level and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions_last_round = history.opponent_actions[-1]
        my_payoff_last_round = history.my_payoffs[-1]
        cooperators_last_round = sum(opponent_actions_last_round)
        defectors_last_round = self.game_description.n_players - 1 - cooperators_last_round
        avg_coop_payoff = np.mean(history.opponent_payoffs[-1, opponent_actions_last_round])
        avg_defect_payoff = np.mean(history.opponent_payoffs[-1, ~opponent_actions_last_round])
        if state.current_stock < 0.5 * self.capacity:
            return Action.C
        elif state.current_stock > 0.8 * self.capacity:
            return Action.D
        elif avg_coop_payoff >= avg_defect_payoff or math.isnan(avg_defect_payoff):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_368(BaseStrategy):
    """
    Collective strategy that balances individual payoffs with collective sustainability by adapting to the game's dynamic state and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock >= 0.75 * self.capacity:
            return Action.C if self.most_opponents_cooperated(history.opponent_actions[-1, :]) else Action.D
        elif 0.5 * self.capacity <= state.current_stock < 0.75 * self.capacity:
            return Action.C if self.at_least_one_defected(history.opponent_actions[-1, :]) else Action.D
        else:
            return Action.C

    def most_opponents_cooperated(self, opponent_actions_in_last_round):
        cooperators = sum(opponent_actions_in_last_round)
        return cooperators >= self.game_description.n_players / 2

    def at_least_one_defected(self, opponent_actions_in_last_round):
        for action in opponent_actions_in_last_round:
            if not action:
                return True
        return False

class Strategy_COLLECTIVE_369(BaseStrategy):
    """
    Adaptive Tit-for-Two-Tat with Stock Conservation (ATTSC) strategy.
    
    This strategy balances individual payoffs with long-term sustainability of the common pool resource.
    It initiates cooperation, adapts to opponents' behaviors, and conserves stock when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round_opponent_actions = history.opponent_actions[-1, :]
        majority_cooperated = sum(last_round_opponent_actions) > self.game_description.n_players / 2
        if majority_cooperated:
            return Action.C
        else:
            any_defected = np.any(~last_round_opponent_actions)
            if any_defected:
                return Action.D
            else:
                return Action.C
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_370(BaseStrategy):
    """
    Adaptive Cooperation with Stock Threshold (ACST) strategy.
    
    This strategy balances individual payoff maximization with collective sustainability 
    by adapting cooperation levels based on the current stock level and game history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.5 * game_description.capacity
        self.recent_defection_window_size = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_actions = history.opponent_actions
        current_stock = state.current_stock
        if current_stock > self.stock_threshold:
            action = Action.C
        elif self.count_defections(previous_actions, self.recent_defection_window_size) > self.game_description.n_players / 2:
            action = Action.D
        elif self.get_stock_growth(history.my_payoffs, history.my_actions) <= 0:
            action = Action.C
        else:
            action = Action.D
        return action

    def count_defections(self, previous_actions: NDArray[np.bool_], window_size: int):
        recent_rounds = previous_actions[-window_size:, :]
        return np.sum(~recent_rounds)

    def get_stock_growth(self, my_payoffs: NDArray[np.float64], my_actions: NDArray[np.bool_]):
        if len(my_payoffs) < 2:
            return 0
        last_round_payoff = my_payoffs[-1]
        second_last_round_payoff = my_payoffs[-2]
        if second_last_round_payoff == 0:
            return last_round_payoff
        stock_growth_rate = (last_round_payoff - second_last_round_payoff) / second_last_round_payoff
        return stock_growth_rate * self.game_description.capacity

class Strategy_COLLECTIVE_371(BaseStrategy):
    """
    A collective strategy aiming to balance individual payoffs with collective sustainability.
    It prioritizes cooperation while being robust to various opponent behaviors and environmental conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        t = state.round_number
        stock = state.current_stock
        if t == 0 or (history is not None and len(history.my_actions) == 0):
            return Action.C
        elif stock >= 0.75 * capacity:
            return Action.C
        elif 0.5 * capacity <= stock < 0.75 * capacity:
            p = (capacity - stock) / (0.25 * capacity)
            if random.random() < p:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D
        if t == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_372(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Conservation (ASC)
    
    The ASC strategy aims to balance individual payoffs with collective stock conservation, 
    adapting to the game's dynamic state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_levels_last_3_rounds = np.array([state.current_stock])
        if history is not None and len(history.my_actions) > 2:
            for i in range(1, min(3, len(history.my_actions))):
                stock_levels_last_3_rounds = np.append(stock_levels_last_3_rounds, self._get_previous_stock_level(state.round_number - i, history))
        average_stock_level = np.mean(stock_levels_last_3_rounds)
        AT = average_stock_level / self.game_description.capacity
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        opponents_defected = sum(1 - history.opponent_actions[-1, :])
        if opponents_defected > 0.5 * (self.game_description.n_players - 1):
            return Action.D
        if state.round_number >= 0.9 * self.game_description.n_rounds:
            return Action.C
        if AT < 0.5:
            return Action.C
        else:
            return Action.D

    def _get_previous_stock_level(self, round_number: int, history: PlayerHistory) -> float:
        previous_round_payoffs = history.my_payoffs[round_number - 1] + np.sum(history.opponent_payoffs[round_number - 1, :])
        return self.game_description.capacity - self.game_description.capacity * (previous_round_payoffs / self.game_description.capacity)

class Strategy_COLLECTIVE_373(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Dependent Threshold (ACSDT) Strategy.

    This strategy adapts cooperation based on stock level deviation and round number.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        stock_deviation = (capacity - state.current_stock) / n_players
        theta = 0.5 + 0.2 * round_number / total_rounds
        if stock_deviation <= theta:
            return Action.C
        elif state.current_stock <= 0 or round_number == total_rounds - 1:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_374(BaseStrategy):
    """
    This strategy implements the Collective Strategy: Adaptive Cooperation with Stock-Based Trigger (ACST).
    
    ACST is a dynamic, collective strategy that balances cooperation and defection based on the current stock level and the history of opponent actions.
    The goal is to maintain a sustainable stock level while adapting to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        threshold = self.game_description.capacity / 2
        if state.current_stock > threshold:
            action = Action.C
        else:
            action = Action.D
        if history.opponent_actions[-1, 0]:
            if state.current_stock > threshold:
                action = Action.C
            elif state.current_stock <= threshold:
                action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return action

class Strategy_COLLECTIVE_375(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Sensitive Threshold (ACST) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.cooperation_scores = [0] * self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number < min(self.game_description.n_rounds // 2, 5):
            return Action.C
        stock = state.current_stock
        if stock > 0.7 * self.capacity:
            action = Action.C
        elif 0.3 * self.capacity <= stock <= 0.7 * self.capacity:
            p = (stock / self.capacity) ** 2
            action = Action.C if random.random() < p else Action.D
        else:
            action = Action.D
        if history is not None and state.round_number > 0:
            for i, opponent_action in enumerate(history.opponent_actions[-1, :]):
                if opponent_action:
                    self.cooperation_scores[i] += 1
                else:
                    self.cooperation_scores[i] -= 2
        most_cooperative = sum((1 for score in self.cooperation_scores if score > 0)) >= self.n_players // 2
        threshold = 0.6 * self.capacity if most_cooperative else 0.8 * self.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        return action

class Strategy_COLLECTIVE_376(BaseStrategy):
    """
    Adaptive Cooperation with Stock-based Trigger (ACST) Strategy:
    
    A collective strategy that balances individual self-interest with long-term sustainability of the common pool resource.
    It adapts to changing stock levels and opponent behaviors while promoting cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        stock_threshold = capacity / 2
        stock_alarm = capacity / 4
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        if current_stock > stock_threshold:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        num_opponents = len(opponent_actions)
        defected_opponents = sum((not action for action in opponent_actions))
        if defected_opponents > 0:
            return Action.D
        if current_stock < stock_alarm:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_377(BaseStrategy):
    """
    This strategy implements the Adaptive Stock Sensitive Tit-for-Tat with Exploration (ASSTTE) algorithm.
    It aims to balance cooperation and defection while adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.epsilon = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        average_payoff_per_player = np.mean(history.my_payoffs[-1])
        if current_stock > self.capacity / 2:
            if average_payoff_per_player >= current_stock / (2 * self.n_players):
                return Action.C
            else:
                return Action.D
        else:
            p = (current_stock / self.capacity) ** 2
            if random.random() < self.epsilon:
                return random.choice([Action.C, Action.D])
            elif average_payoff_per_player < current_stock / (2 * self.n_players):
                if random.random() < p:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        if current_stock < self.capacity / 4:
            if random.random() < 0.9:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_378(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_defections = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.my_actions) < 2):
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        last_round_opponent_actions = history.opponent_actions[-1, :]
        if self.consecutive_defections >= 2:
            self.consecutive_defections = 0
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock_level > 0.75:
            return Action.C
        elif 0.5 <= stock_level < 0.75:
            last_round_cooperators = sum(last_round_opponent_actions)
            if last_round_cooperators >= 2:
                return Action.C
            else:
                return random.choice([Action.C, Action.D])
        else:
            last_round_defectors = self.game_description.n_players - sum(last_round_opponent_actions) - 1
            if last_round_defectors > 0:
                self.consecutive_defections += 1
                return Action.D
            elif state.current_stock == 0:
                self.consecutive_defections = 0
                return Action.C
            else:
                return random.choice([Action.C, Action.D])

class Strategy_COLLECTIVE_379(BaseStrategy):
    """
    Adaptive Sustainability Strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.rounds_for_avg_payoff = math.ceil(0.1 * game_description.n_rounds)
        self.threshold = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock >= 0.75 * self.game_description.capacity and state.round_number < self.game_description.n_rounds / 2:
            return Action.C
        avg_payoff = self.calculate_average_payoff(history)
        if avg_payoff > self.threshold:
            return Action.C
        if state.current_stock < 0.5 * self.game_description.capacity or state.round_number > self.game_description.n_rounds / 2:
            own_avg_payoff = self.calculate_own_average_payoff(history)
            if own_avg_payoff < self.threshold:
                return Action.D
        growth_rate = 2 * state.current_stock * (1 - state.current_stock / self.game_description.capacity)
        if state.current_stock < 0.25 * self.game_description.capacity or growth_rate < 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

    def calculate_average_payoff(self, history: PlayerHistory) -> float:
        rounds_for_avg = min(history.my_payoffs.size, self.rounds_for_avg_payoff)
        avg_payoff = np.mean(history.my_payoffs[-rounds_for_avg:])
        return avg_payoff

    def calculate_own_average_payoff(self, history: PlayerHistory) -> float:
        rounds_for_avg = min(history.my_payoffs.size, self.rounds_for_avg_payoff)
        own_avg_payoff = np.mean(history.my_payoffs[-rounds_for_avg:])
        return own_avg_payoff

class Strategy_COLLECTIVE_380(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy for Common Pool Resource Game.
    Prioritizes collective sustainability over individual short-term gains by adapting to the current stock level and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.average_cooperation_rate = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        self.average_cooperation_rate = np.mean(np.concatenate([opponent_actions, [True]]))
        p = (state.current_stock / self.game_description.capacity) ** (1 / self.game_description.n_players)
        if self.average_cooperation_rate > 0.75:
            p += 0.1
        elif self.average_cooperation_rate < 0.25:
            p -= 0.1
        if state.current_stock >= 0.75 * self.game_description.capacity or state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif state.current_stock >= 0.5 * self.game_description.capacity:
            return Action.C if random.random() < p else Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_381(BaseStrategy):
    """
    An adaptive collective strategy that balances cooperation and self-interest.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_likelihood = 0.5
        self.avg_depletion_rate_threshold = 0.2 * game_description.capacity

    def calculate_avg_depletion_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the average stock depletion rate over the last few rounds.
        """
        total_consumption = np.sum(history.opponent_actions.astype(int), axis=1) / self.game_description.n_players + 1
        avg_depletion_rate = np.mean(total_consumption[-min(len(total_consumption), 5):])
        return avg_depletion_rate

    def calculate_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Calculate the opponent cooperation rate.
        """
        opponent_cooperators = np.sum(history.opponent_actions[-1, :].astype(int))
        return opponent_cooperators / self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_depletion_rate = self.calculate_avg_depletion_rate(history)
        stock_level_ratio = state.current_stock / self.game_description.capacity
        if avg_depletion_rate > self.avg_depletion_rate_threshold:
            return Action.D
        if stock_level_ratio < 0.25:
            return Action.D
        elif stock_level_ratio >= 0.25 and stock_level_ratio <= 0.5:
            cooperate_prob = math.pow(stock_level_ratio, 2)
            return Action.C if random.random() < cooperate_prob else Action.D
        opponent_cooperation_rate = self.calculate_opponent_cooperation_rate(history)
        if opponent_cooperation_rate > 0.5:
            self.cooperation_likelihood *= 1.1
        else:
            self.cooperation_likelihood *= 0.8
        if state.round_number == self.game_description.n_rounds - 1 or stock_level_ratio < 0.1 or stock_level_ratio > 0.9:
            return Action.D
        return Action.C if random.random() < self.cooperation_likelihood else Action.D

class Strategy_COLLECTIVE_382(BaseStrategy):
    """
    The Adaptive Sustainability strategy aims to balance individual payoffs with collective sustainability,
    ensuring a robust and adaptive approach that responds to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_threshold = math.ceil(game_description.n_rounds / 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        θ = state.current_stock / self.game_description.capacity
        if θ >= 0.5:
            return Action.C
        majority_defected = sum((1 - action for action in history.opponent_actions[-1, :])) >= len(history.opponent_actions) // 2
        if majority_defected:
            return Action.D
        past_payoffs = history.my_payoffs[max(-self.round_threshold, -len(history.my_payoffs)):]
        avg_past_payoff = np.mean(past_payoffs)
        max_possible_payoff = self.game_description.capacity / (2 * self.game_description.n_players)
        if len(past_payoffs) >= self.round_threshold and avg_past_payoff < 0.25 * max_possible_payoff:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_383(BaseStrategy):
    """
    Adaptive Stock Conservation strategy.

    This strategy balances individual payoffs with collective sustainability by adapting to the game's state and history.
    It cooperates when beneficial for both individual and collective outcomes, and defects when necessary to prevent over-exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if state.current_stock > 0.75 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        avg_payoff_prev_round = np.mean(history.my_payoffs[-1] if history.my_payoffs.size > 0 else np.array([0]))
        if avg_payoff_prev_round < 0.5 * (state.current_stock / self.game_description.n_players):
            return Action.D
        elif state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        else:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C

class Strategy_COLLECTIVE_384(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with long-term sustainability.
    It adapts to potential exploitation by others and prioritizes cooperation when it benefits the collective good.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < 5:
            return Action.C
        if history is None or history.my_actions.size == 0:
            return Action.C
        avg_payoff = np.mean(history.my_payoffs)
        max_possible_payoff = self.capacity / (2 * self.n_players)
        if avg_payoff < 0.75 * max_possible_payoff:
            return Action.D
        if state.current_stock < 0.25 * self.capacity:
            return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        cooperators = np.sum(opponent_actions)
        if state.current_stock > 0.75 * self.capacity and cooperators >= self.n_players / 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_385(BaseStrategy):
    """
    A strategy that adapts to various opponent behaviors while prioritizing sustainability and fairness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock = state.current_stock
        any_defector = np.any(history.opponent_actions[-1, :])
        n_defectors = np.sum(~history.opponent_actions[-1, :])
        p_cooperate = (self.n_players - n_defectors) / self.n_players
        if stock >= 0.75 * self.capacity:
            return Action.C
        if any_defector and stock < 0.5 * self.capacity:
            return Action.D
        if random.random() < p_cooperate:
            return Action.C
        else:
            return Action.D
        if stock < 0.25 * self.capacity:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_386(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource game.
    
    This strategy balances individual payoffs with long-term sustainability, 
    adapting to changing game conditions and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperate_prob = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        opponent_defections = np.sum(history.opponent_actions[-3:, :], axis=0)
        for defections in opponent_defections:
            if defections >= 2:
                return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        cooperation_rate = np.mean(history.opponent_actions)
        if cooperation_rate > 0.5:
            self.cooperate_prob += 0.1
        elif cooperation_rate < 0.5:
            self.cooperate_prob -= 0.1
        self.cooperate_prob = max(0, min(self.cooperate_prob, 1))
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        if cooperation_rate > 0.75:
            self.cooperate_prob = max(self.cooperate_prob, 0.5)
        if random.random() < self.cooperate_prob:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_387(BaseStrategy):
    """
    Adaptive Stock Preservation (ASP) Strategy.
    
    This strategy balances individual and collective interests by adapting cooperation levels 
    based on the current stock level, opponents' past behavior, and the game's progression. 
    By prioritizing robustness and preserving the stock level, ASP aims to perform reasonably well 
    against a wide range of opponent behaviors in the tournament.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        prev_consumption = sum(self.get_player_consumptions(state.current_stock, history.opponent_actions[-1]))
        prev_cooperation = sum(history.opponent_actions[-1])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock >= 0.75 * self.game_description.capacity:
            cooperate = prev_consumption < 0.5 * self.game_description.capacity
        elif 0.5 * self.game_description.capacity <= state.current_stock < 0.75 * self.game_description.capacity:
            cooperate = prev_cooperation >= self.game_description.n_players / 2
        else:
            cooperate = False
        return Action.C if cooperate else Action.D

    @staticmethod
    def get_player_consumptions(stock: float, actions: NDArray[np.bool_]) -> list[float]:
        n_players = len(actions)
        consumption_per_cooperator = stock / (2 * n_players)
        consumption_per_defector = stock / n_players
        consumptions = []
        for action in actions:
            if action:
                consumptions.append(consumption_per_cooperator)
            else:
                consumptions.append(consumption_per_defector)
        return consumptions

class Strategy_COLLECTIVE_388(BaseStrategy):
    """
    Collective Strategy: Adaptive Tit-for-Tat with Stock Sensitivity (ATTS).
    
    This strategy balances individual payoff maximization with collective stock conservation.
    It adapts to changing opponent behaviors and prioritizes cooperation when the stock level is high,
    mirroring others' actions when it's moderate, and conserving when the stock level is low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_actions = history.opponent_actions[-1, :] if history else []
        my_prev_action = history.my_actions[-1] if history else True
        prev_actions = np.append(prev_actions, my_prev_action)

        def most_players_cooperated(actions):
            cooperate_count = sum((1 for action in actions if action))
            return cooperate_count >= len(actions) / 2

        def get_majority_action(actions):
            counts = {True: 0, False: 0}
            for action in actions:
                counts[action] += 1
            majority_action = max(counts, key=counts.get)
            return Action.C if majority_action else Action.D
        stock_level = state.current_stock / self.game_description.capacity
        if stock_level >= 0.75:
            return Action.C if most_players_cooperated(prev_actions) else Action.D
        elif 0.5 <= stock_level < 0.75:
            return get_majority_action(prev_actions)
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D if state.current_stock > 0.25 * self.game_description.capacity else Action.C

class Strategy_COLLECTIVE_389(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Conservation (ASC)

    This strategy aims to balance individual payoffs with collective stock conservation,
    adapting to changing game conditions and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / (2 * game_description.n_players)
        self.probability = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.game_description.n_players == 2 and self.game_description.capacity < 100:
            if state.round_number != self.game_description.n_rounds - 1:
                return Action.C
            else:
                return Action.D
        if state.current_stock > self.threshold:
            action = Action.C
        else:
            action = Action.D if random.random() < self.probability else Action.C
            prev_round_history = history.my_actions[state.round_number - 1]
            prev_round_opponent_actions = history.opponent_actions[state.round_number - 1]
            num_cooperators = sum([prev_round_history] + list(prev_round_opponent_actions))
            total_consumption = (state.current_stock - self.threshold) * num_cooperators
            stock_growth = 2 * state.current_stock * (1 - state.current_stock / self.game_description.capacity)
            if stock_growth > 0:
                self.probability *= 0.9
            elif stock_growth <= 0:
                self.probability *= 1.2
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return action

class Strategy_COLLECTIVE_390(BaseStrategy):
    """
    Collective Strategy: Adaptive Tit-for-Tat with Stock-Dependent Cooperation.

    This strategy balances individual payoffs with collective well-being by adapting to the game state and previous actions.
    It promotes cooperation when possible while protecting against exploitation by defectors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        if history is not None:
            prev_actions = history.opponent_actions[-1, :]
            coop_count = sum(prev_actions)
            if state.round_number == self.game_description.n_rounds - 1:
                return Action.D
            if stock_level > 0.5:
                if coop_count > len(prev_actions) / 2:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_COLLECTIVE_391(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Threshold (ACS) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.threshold = self.capacity / (2 * self.n_players)
        self.previous_acr = 1.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        opponent_actions = history.opponent_actions[-1, :]
        self.previous_acr = np.mean(opponent_actions)
        if self.previous_acr > 0.5:
            self.threshold *= 1.1
        else:
            self.threshold *= 0.9
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if current_stock >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_392(BaseStrategy):
    """
    A collective strategy that adapts to changing stock levels and opponents' actions.
    Prioritizes cooperation when stock is low, defects when high, and mirrors opponents' average action otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_opponent_consumption = np.mean(history.opponent_actions[-1, :])
        if state.current_stock < self.game_description.capacity / 2:
            return Action.C
        elif state.current_stock > self.game_description.capacity * 0.8:
            return Action.D
        if avg_opponent_consumption > state.current_stock / (2 * self.game_description.n_players):
            return Action.C
        elif avg_opponent_consumption >= state.current_stock / self.game_description.n_players:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_393(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy: 
    Balance collective sustainability with individual gains in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if random.random() < 0.5 else Action.D
        if history is not None and history.my_actions.size > 0 and (sum(history.opponent_actions[0, :]) == 0):
            cautious_mode = True
        else:
            cautious_mode = False
        if state.round_number == 1:
            previous_stock = self.game_description.capacity
        else:
            previous_stock = history.my_payoffs[-2] * 2 * self.game_description.n_players + history.opponent_payoffs[-2, :].sum() * self.game_description.n_players
        stock_diff = state.current_stock - previous_stock
        if stock_diff >= 0 and state.current_stock > self.game_description.capacity / 2:
            prob_cooperate = 0.7 if not cautious_mode else 0.4
            return Action.C if random.random() < prob_cooperate else Action.D
        elif state.current_stock < self.game_description.capacity / 3:
            prob_defect = 0.8
            return Action.D if random.random() < prob_defect else Action.C
        else:
            return Action.C if random.random() < 0.5 else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_394(BaseStrategy):
    """
    The Adaptive Cooperation (AC) strategy balances individual payoffs with collective sustainability.
    It adapts to the game's dynamic state and history, making decisions based on current stock level,
    player actions, and past outcomes.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.punishment_rounds_remaining = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if self.punishment_rounds_remaining > 0:
            self.punishment_rounds_remaining -= 1
            return Action.C
        if state.round_number == 0:
            return Action.C
        current_stock_level = state.current_stock / self.game_description.capacity
        if current_stock_level >= 0.75:
            return Action.C
        elif 0.5 <= current_stock_level < 0.75:
            return random.choice([Action.C, Action.D])
        else:
            return Action.D
        most_recent_opponent_actions = history.opponent_actions[-1]
        opponent_cooperators = sum(most_recent_opponent_actions)
        if opponent_cooperators > self.game_description.n_players // 2:
            return Action.C
        elif opponent_cooperators < self.game_description.n_players // 2:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_395(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy for the Common Pool Resource Game.
    
    This strategy prioritizes cooperation when the common pool is abundant and 
    shifts towards defection as the stock depletes. It also monitors opponents' 
    actions and adjusts its own behavior to prevent over-exploitation and promote 
    stock recovery.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_defection_rate = np.mean(1 - history.opponent_actions[-1, :])
        if current_stock >= 0.75 * self.capacity:
            cooperate = True
        elif 0.5 * self.capacity <= current_stock < 0.75 * self.capacity:
            defect_prob = (1 - current_stock / self.capacity) / 2
            cooperate = random.random() > defect_prob
            if opponent_defection_rate > 0.5:
                defect_prob += 0.1
                cooperate = random.random() > defect_prob
        else:
            cooperate = False
        stock_growth = 2 * current_stock * (1 - current_stock / self.capacity)
        if stock_growth > 0.25 * self.capacity:
            cooperate = True
        return Action.C if cooperate else Action.D

class Strategy_COLLECTIVE_396(BaseStrategy):
    """
    A collective strategy called "Adaptive Stock Conservation" (ASC) that aims to balance individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        low_threshold = capacity / 4
        high_threshold = capacity / 2
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_opponent_actions = history.opponent_actions[-1, :]
        majority_cooperated = sum(previous_opponent_actions) / len(previous_opponent_actions) > 0.5
        if state.current_stock > high_threshold:
            return Action.C
        elif state.current_stock < low_threshold:
            return Action.D
        elif majority_cooperated:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_397(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock-Based Threshold (ACST)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.theta = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[-1]
        all_cooperated = np.all(previous_round_opponent_actions)
        stock_increased = history.my_payoffs[-1] > 0
        if all_cooperated and stock_increased:
            self.theta *= 0.9
        elif not all_cooperated or not stock_increased:
            self.theta *= min(1.2, 10 / self.game_description.capacity)
        current_stock_threshold = self.theta * self.game_description.capacity
        if state.current_stock >= current_stock_threshold and state.round_number != self.game_description.n_rounds - 1:
            return Action.C
        elif state.current_stock == 0:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_398(BaseStrategy):
    """
    The ASC strategy aims to balance individual payoffs with collective sustainability 
    by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if current_stock < 0.25 * capacity:
            return Action.D
        previous_opponent_actions = history.opponent_actions[-1, :]
        any_defected = np.any(previous_opponent_actions == False)
        if current_stock > 0.75 * capacity:
            return Action.C
        elif any_defected and current_stock < 0.5 * capacity:
            return Action.D
        elif np.all(previous_opponent_actions == True) and current_stock > 0.25 * capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_399(BaseStrategy):
    """
    The Adaptive Stock Conservator (ASC) strategy aims to balance individual payoffs with collective sustainability by adapting to the game's dynamic state and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.current_stock <= 2 * self.game_description.n_players:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        scr = state.current_stock / self.game_description.capacity
        return Action.C if scr >= 0.75 else Action.D

class Strategy_COLLECTIVE_400(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) Strategy.

    This strategy aims to balance individual payoff maximization with collective stock conservation,
    adapting to the game's dynamic state and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        sdr = (self.game_description.capacity - state.current_stock) / self.game_description.capacity
        ocl = np.sum(history.opponent_actions[-1, :]) / self.game_description.n_players
        if sdr < 0.3:
            if ocl > 0.6:
                return Action.C
            elif 0.4 <= ocl <= 0.6:
                return random.choice([Action.C, Action.D])
            else:
                return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.2 * self.game_description.capacity:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_401(BaseStrategy):
    """
    A strategy that balances individual payoff maximization with sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.stock_threshold = self.capacity / 2
        self.app_threshold = self.capacity / (2 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.1 * self.capacity:
            return Action.C
        if state.current_stock > self.stock_threshold:
            return Action.C
        opponent_payoffs = history.opponent_payoffs[-1, :]
        avg_opponent_payoff = np.mean(opponent_payoffs)
        if avg_opponent_payoff > self.app_threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_402(BaseStrategy):
    """
    A collective strategy designed to balance individual payoffs with sustainable stock management,
    ensuring long-term benefits for all players. This approach adapts to various opponent behaviors 
    and game states.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock >= 0.75 * self.game_description.capacity else Action.D
        threshold = min(0.5 + state.current_stock / self.game_description.capacity, 0.75)
        cooperations_last_round = sum(history.opponent_actions[-1, :] == True)
        half_players_cooperated = cooperations_last_round >= self.game_description.n_players / 2
        if state.current_stock >= threshold and half_players_cooperated:
            return Action.C
        else:
            if state.round_number == self.game_description.n_rounds - 1:
                return Action.D
            return Action.D

class Strategy_COLLECTIVE_403(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Aware Tit-for-Tat (ACSAT) strategy.
    
    This strategy balances individual payoff maximization with collective sustainability 
    by adapting to the current stock level and opponent behaviors, promoting cooperation 
    when possible while protecting against exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_level = state.current_stock
        previous_round_cooperations = sum(history.opponent_actions[-1, :])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock_level < 0.25 * self.capacity:
            return Action.D
        if stock_level > 0.9 * self.capacity:
            return Action.C
        if stock_level > 0.75 * self.capacity:
            return Action.C
        elif stock_level >= 0.5 * self.capacity:
            if previous_round_cooperations > len(history.opponent_actions[-1, :]) / 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_404(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Threshold (ACS-T) strategy.
    
    This collective strategy balances individual payoff maximization with long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        T = self.game_description.capacity * (1 - state.round_number / self.game_description.n_rounds)
        if state.current_stock >= T and any((history.opponent_actions[-1, i] == 1 for i in range(self.game_description.n_players - 1))):
            return Action.C
        if state.round_number + 1 == self.game_description.n_rounds:
            return Action.D
        if state.current_stock < self.game_description.capacity / self.game_description.n_players:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_405(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock-Sensitive Tit-for-Tat.
    
    Balances individual payoffs with collective sustainability in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (state.round_number > 0 and history is None):
            return Action.C
        previous_actions = history.opponent_actions[-1]
        stock_level = state.current_stock / self.game_description.capacity
        if any((action == False for action in history.my_actions)) and stock_level > 0.75:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if stock_level > 0.75:
            return Action.C
        elif 0.5 <= stock_level <= 0.75:
            most_common_action = np.bincount(previous_actions.astype(int)).argmax() != 0
            return Action.C if most_common_action else Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_406(BaseStrategy):
    """
    Collective strategy aiming to balance individual payoffs with collective stock preservation.
    Adapts to dynamic state and opponent behaviors, prioritizing cooperation when the stock level is above a threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.T = game_description.capacity / 2
        self.θ = 0.5
        self.ε = 10
        self.prev_stock = None
        self.prev_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.prev_action = Action.C
            return Action.C
        if history is not None:
            opponent_CRs = np.mean(history.opponent_actions, axis=0)
            prev_stock = self.prev_stock or state.current_stock
            stock_diff = state.current_stock - prev_stock
            if state.round_number == self.game_description.n_rounds - 1:
                return Action.D
            elif state.current_stock < self.ε:
                return Action.D
            elif opponent_CRs[0] >= self.θ:
                action = Action.D if self.prev_action == Action.C else Action.C
                self.prev_action = action
                return action
            elif state.current_stock > self.T:
                return Action.C
            elif stock_diff > 0:
                return self.prev_action
            else:
                action = Action.D if self.prev_action == Action.C else Action.C
                self.prev_action = action
                return action
        self.prev_stock = state.current_stock
        return Action.C

class Strategy_COLLECTIVE_407(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def all_players_cooperated(self, history) -> bool:
        """
        Check if all players cooperated in the previous round.
        
        Parameters:
            history (PlayerHistory): Player's history.
            
        Returns:
            bool: True if all players cooperated, False otherwise.
        """
        return np.all(history.opponent_actions[-1, :] == 1)

    def stock_increased(self, history) -> bool:
        """
        Check if the stock increased or remained stable in the previous round.
        
        Parameters:
            history (PlayerHistory): Player's history.
            
        Returns:
            bool: True if the stock increased or remained stable, False otherwise.
        """
        return np.mean(history.my_payoffs[-1]) >= 0

    def significant_stock_decrease(self, history) -> bool:
        """
        Check if the stock decreased significantly (> 20%) in the previous round.
        
        Parameters:
            history (PlayerHistory): Player's history.
            
        Returns:
            bool: True if the stock decreased significantly, False otherwise.
        """
        return np.mean(history.my_payoffs[-1]) < -0.2

    def average_payoff_per_player(self, history) -> float:
        """
        Calculate the average payoff per player in the previous round.
        
        Parameters:
            history (PlayerHistory): Player's history.
            
        Returns:
            float: Average payoff per player.
        """
        return np.mean(history.my_payoffs[-1])

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock > 0.75 * self.capacity:
            return Action.C
        elif state.current_stock < 0.5 * self.capacity:
            return Action.D
        else:
            prev_outcome = history.opponent_actions[-1, :]
            if self.all_players_cooperated(history) and self.stock_increased(history):
                return Action.C
            elif not self.all_players_cooperated(history) or self.significant_stock_decrease(history):
                return Action.D
            else:
                pi_avg = self.average_payoff_per_player(history)
                if pi_avg > state.current_stock / (2 * self.n_players):
                    return Action.C
                else:
                    return Action.D

class Strategy_COLLECTIVE_408(BaseStrategy):
    """
    A strategy that balances individual payoffs with collective stock conservation by adapting to opponent behavior and monitoring the current stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            initial_stock_level = state.current_stock / self.capacity
            if initial_stock_level < 0.5:
                return Action.D
            else:
                cooperate_prob = 0.7
                return Action.C if random.random() < cooperate_prob else Action.D
        avg_opponent_coop_rate = np.mean(history.opponent_actions[-1, :])
        stock_level = state.current_stock / self.capacity
        if stock_level > 0.75:
            return Action.C if avg_opponent_coop_rate > 0.5 else Action.D
        elif stock_level >= 0.5 and stock_level <= 0.75:
            opponent_cooperators = np.sum(history.opponent_actions[-1, :])
            return Action.C if opponent_cooperators >= self.game_description.n_players / 2 else Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_409(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock-Sensitive Tit-for-Tat (ACS-TFT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.75 * game_description.capacity
        self.defect_count = 0
        self.avg_stock_level = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_defections = np.sum(~history.opponent_actions[-1])
        self.defect_count += opponent_defections
        self.avg_stock_level.append(state.current_stock)
        if len(self.avg_stock_level) > 5:
            self.avg_stock_level.pop(0)
        avg_recent_stock = sum(self.avg_stock_level[-3:]) / min(len(self.avg_stock_level), 3)
        if avg_recent_stock >= state.current_stock:
            self.threshold *= 1.1
        else:
            self.threshold *= 0.95
        probability_defect = self.defect_count / state.round_number
        return Action.D if random.random() < probability_defect and state.current_stock < self.threshold else Action.C

class Strategy_COLLECTIVE_410(BaseStrategy):
    """
    A hybrid strategy that balances individual payoff maximization with adaptive cooperation and robustness against various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.cooperation_rates = [0.5] * game_description.n_players

    def calculate_avg_opponent_cooperation(self, history: PlayerHistory) -> float:
        opponent_actions = history.opponent_actions
        window_size = 5
        recent_rounds = max(1, min(window_size, opponent_actions.shape[0]))
        coop_count = np.sum(opponent_actions[-recent_rounds:, :])
        return coop_count / (recent_rounds * self.game_description.n_players - 1)

    def adjust_cooperation_rate(self, history: PlayerHistory) -> None:
        opponent_actions = history.opponent_actions
        if opponent_actions.shape[0] > 0:
            recent_opponent_actions = opponent_actions[-1, :]
            for i in range(recent_opponent_actions.shape[0]):
                if recent_opponent_actions[i]:
                    self.cooperation_rates[i] = min(1.0, self.cooperation_rates[i] + 0.05)
                else:
                    self.cooperation_rates[i] = max(0.0, self.cooperation_rates[i] - 0.1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_coop_rate = self.calculate_avg_opponent_cooperation(history)
        self.adjust_cooperation_rate(history)
        if state.current_stock > 0.75 * self.capacity or (state.round_number < 5 and history.my_actions.shape[0] < 4):
            return Action.C
        elif state.round_number >= 20 and (state.current_stock < 0.25 * self.capacity or np.sum(history.opponent_actions[-1, :]) < 2):
            return Action.D
        elif avg_coop_rate > 0.6:
            return Action.C
        elif state.current_stock > 0.9 * self.capacity:
            return Action.D
        else:
            return Action.C if random.random() < avg_coop_rate else Action.D

class Strategy_COLLECTIVE_411(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with long-term sustainability of the common pool resource.
    It adapts to the game state and history, making it robust against various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.conservaton_threshold = 0.25 * game_description.capacity
        self.historical_context_threshold = 10

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock < self.conservaton_threshold * 0.1:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 1:
            return Action.C
        avg_payoff_prev = np.mean(history.opponent_payoffs[-1, :])
        if avg_payoff_prev > self.historical_context_threshold:
            return Action.C
        neighbor_actions = history.opponent_actions[-1, :]
        if sum(neighbor_actions) >= len(neighbor_actions) // 2:
            return Action.C
        if state.current_stock < self.conservaton_threshold:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_412(BaseStrategy):
    """
    Adaptive Cooperative Harvesting Strategy.

    This strategy prioritizes cooperation when possible, while adapting to opponents' behaviors and the game's state.
    By cooperating when the stock level is high or when others have cooperated, ACH aims to maintain a healthy stock level
    and encourage collective cooperation. When the stock level is low or opponents are defecting, ACH switches to defection
    to avoid exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initialize the strategy with the game description.

        :param game_description: The game description containing n_players and capacity.
        """
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        high_threshold = 0.75 * self.game_description.capacity
        medium_threshold = 0.5 * self.game_description.capacity
        opponents_cooperated = np.sum(history.opponent_actions[-1, :])
        if state.current_stock > high_threshold:
            return Action.C if opponents_cooperated >= self.game_description.n_players / 2 else Action.D
        elif medium_threshold <= state.current_stock <= high_threshold:
            return Action.C if opponents_cooperated > 0 else Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_413(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy for the Common Pool Resource Game.
    
    ASC balances individual self-interest with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.tau = 0.5 * self.capacity
        self.avg_consumption = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        previous_stock = history.my_payoffs[-1] * self.game_description.n_players * 2
        previous_growth = max(0, state.current_stock - previous_stock)
        total_consumption = np.sum(history.opponent_actions[-1, :] + [history.my_actions[-1]]) / self.game_description.n_players
        if len(self.avg_consumption) >= 3:
            self.avg_consumption.pop(0)
        self.avg_consumption.append(total_consumption)
        if state.current_stock < self.tau or previous_growth < 0:
            return Action.D
        elif np.mean(self.avg_consumption) <= self.capacity / (2 * self.game_description.n_players):
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1 or state.current_stock <= 0:
            return Action.D

class Strategy_COLLECTIVE_414(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Threshold (ACST) strategy.
    
    This strategy aims to balance individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and history of play.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.max_payoff = game_description.capacity / (2 * game_description.n_players)
        self.stock_threshold = None

    def calculate_threshold(self, S):
        T = self.game_description.capacity / (self.game_description.n_players + 1) * (S / self.game_description.capacity)
        return T

    def adjust_threshold(self, avg_payoff):
        if avg_payoff < 0.75 * self.max_payoff:
            self.stock_threshold *= 0.9

    def calculate_average_payoff(self, history: PlayerHistory):
        if len(history.my_payoffs) > 0:
            return np.mean(history.my_payoffs)
        else:
            return self.max_payoff

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        self.stock_threshold = self.calculate_threshold(state.current_stock)
        avg_payoff = self.calculate_average_payoff(history)
        self.adjust_threshold(avg_payoff)
        if state.current_stock > self.stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_415(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Threshold strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        T = max(0, state.current_stock / (2 * self.capacity))
        previous_total_consumption = sum((1 / self.n_players if action else 1 / (2 * self.n_players) for action in history.my_actions[-1:] + history.opponent_actions[-1, :])) * state.current_stock
        num_cooperators_last_round = int(history.my_actions[-1]) + sum((int(action) for action in history.opponent_actions[-1, :]))
        if state.round_number < self.game_description.n_rounds - 1 and previous_total_consumption < 0.5 * self.capacity and (num_cooperators_last_round >= self.n_players / 2) and (state.current_stock >= T * self.capacity):
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_416(BaseStrategy):
    """
    A dynamic, adaptive strategy that balances individual payoff maximization with collective stock sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.theta = 0.5
        self.delta_pi_history = []
        self.d_count = 0
        self.k = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        theta = state.current_stock / self.game_description.capacity
        if len(self.delta_pi_history) > self.k:
            delta_pi_avg = sum(self.delta_pi_history[-self.k:]) / self.k
            if delta_pi_avg > 0:
                self.theta += 0.01
            elif delta_pi_avg < 0:
                self.theta -= 0.01
        if history.opponent_actions[-1, :].sum() >= self.game_description.n_players / 2:
            self.d_count += 1
        else:
            self.d_count = max(0, self.d_count - 1)
        if self.d_count >= self.game_description.n_players // 2:
            return Action.D
        if theta < self.theta:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_417(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock-Awareness (ACS)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.cooperation_prob = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.capacity
        if stock_ratio >= 0.75:
            return Action.C
        elif 0.5 <= stock_ratio < 0.75:
            p = stock_ratio ** 2
            return Action.C if random.random() < p else Action.D
        else:
            return Action.D
        prev_total_consumption = sum((1 for action in history.opponent_actions[-1, :] if not action)) * state.current_stock / self.game_description.n_players + (not history.my_actions[-1]) * state.current_stock / (2 * self.game_description.n_players)
        prev_stock = state.current_stock + prev_total_consumption
        if prev_total_consumption / prev_stock > 0.75:
            p = (1 - prev_total_consumption / prev_stock) ** 2
            return Action.C if random.random() < p else Action.D
        opponent_cooperation_rate = sum(history.opponent_actions[-1, :]) / self.game_description.n_players
        if opponent_cooperation_rate > 0.5:
            self.cooperation_prob += 0.1
        elif opponent_cooperation_rate < 0.5 and self.cooperation_prob > 0:
            self.cooperation_prob -= 0.1
        return Action.C if random.random() < self.cooperation_prob else Action.D

class Strategy_COLLECTIVE_418(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Conservation (ASC)

    Balances individual payoff maximization with collective stock conservation,
    ensuring a sustainable common pool resource across multiple rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.5 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < self.stock_threshold:
            return Action.C
        if history is not None and len(history.opponent_actions) > 1:
            p_coop = np.mean(history.opponent_actions[-2, :])
            if p_coop >= 0.5:
                return Action.C
            else:
                return Action.D
        if state.current_stock > self.stock_threshold and (history is None or len(history.my_actions) == 1 or state.current_stock >= history.current_stock[-2]):
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_419(BaseStrategy):
    """
    A strategy that balances individual self-interest with collective cooperation.
    It adapts to the situation by starting with cooperation and responding to opponent behavior and environmental conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.defectors_prev_round = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.stock_history.append(state.current_stock)
        self.defectors_prev_round = np.sum(~history.opponent_actions[-1, :])
        T = 0.7 * self.game_description.capacity
        recent_growth = self.update_recent_stock_growth()
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.2 * self.game_description.capacity:
            return Action.D
        elif state.current_stock >= T:
            return Action.C
        elif self.defectors_prev_round >= self.game_description.n_players / 2:
            return Action.D
        elif recent_growth < 0:
            return Action.D
        else:
            return Action.C

    def update_recent_stock_growth(self):
        window_size = min(len(self.stock_history), 5)
        recent_growth = np.mean(np.diff(self.stock_history[-window_size:]))
        return recent_growth

class Strategy_COLLECTIVE_420(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that adapts to changing stock levels and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        high_threshold = 0.75 * self.game_description.capacity
        low_threshold = 0.25 * self.game_description.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        defectors = sum((not action for action in history.opponent_actions[-1, :]))
        if state.current_stock > high_threshold:
            return Action.C
        elif low_threshold <= state.current_stock <= high_threshold:
            p_defect = defectors / self.game_description.n_players
            return Action.D if random.random() < p_defect else Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_421(BaseStrategy):
    """
    An adaptive strategy for common pool resource management, 
    balancing individual interests with collective well-being.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_depletion_rates = []
        self.opponent_cooperation_frequencies = []

    def calculate_stock_depletion_rate(self, previous_round_actions):
        consumption = np.sum(previous_round_actions)
        total_consumption = consumption / (2 * self.game_description.n_players) if consumption else 0
        return total_consumption

    def calculate_defect_probability(self, stock_depletion_rate, previous_round_actions):
        cooperators = np.sum(previous_round_actions)
        opponents_defection_frequency = (self.game_description.n_players - cooperators) / self.game_description.n_players
        return max(0.5 * opponents_defection_frequency, 0)

    def track_opponent_cooperation_frequency(self, previous_round_actions):
        if not self.opponent_cooperation_frequencies:
            self.opponent_cooperation_frequencies = [np.mean(previous_round_actions)]
        else:
            self.opponent_cooperation_frequencies.append(np.mean(previous_round_actions))
            self.opponent_cooperation_frequencies = self.opponent_cooperation_frequencies[-5:]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        previous_round_actions = history.opponent_actions[-1]
        stock_depletion_rate = self.calculate_stock_depletion_rate(previous_round_actions)
        self.track_opponent_cooperation_frequency(previous_round_actions)
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        elif state.current_stock >= 0.5 * self.game_description.capacity and state.current_stock <= 0.75 * self.game_description.capacity:
            defect_probability = self.calculate_defect_probability(stock_depletion_rate, previous_round_actions)
            if random.random() < defect_probability:
                return Action.D
        elif stock_depletion_rate > 0.2:
            return Action.C
        opponent_cooperation_frequency = np.mean(self.opponent_cooperation_frequencies)
        if opponent_cooperation_frequency > 0.6:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_422(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy balances individual self-interest with collective conservation of the common pool resource.
    It adapts to changing stock levels and opponent behaviors, promoting cooperation when beneficial for all players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            capacity = self.game_description.capacity
            stock = state.current_stock
            if stock >= capacity / 2:
                return Action.C
            else:
                p = (capacity - stock) / capacity
                return Action.D if random.random() < p else Action.C

class Strategy_COLLECTIVE_423(BaseStrategy):
    """
    Adaptive Cooperation with Stock Feedback (ACSF) strategy for Common Pool Resource Game.
    
    This strategy balances individual self-interest with collective sustainability by adapting to the current stock level and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_previous_payoff = np.mean(history.my_payoffs[-1:])
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        if avg_previous_payoff < 0.5 * (state.current_stock / (2 * self.game_description.n_players)):
            return Action.D
        recent_stock_trend = history.my_payoffs[-3:]
        if len(recent_stock_trend) == 3:
            if np.mean(recent_stock_trend) > state.current_stock:
                return Action.C
            else:
                return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity or state.round_number >= self.game_description.n_rounds - 1:
            return Action.C if state.current_stock < 0.25 * self.game_description.capacity else Action.D
        return Action.D

class Strategy_COLLECTIVE_424(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with long-term sustainability of the common pool resource.
    It adapts to the game's state and history while promoting cooperation among players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock / self.capacity < 0.1:
            return Action.D
        elif state.current_stock / self.capacity > 0.9:
            return Action.C
        if state.round_number <= self.n_players:
            prev_actions = history.opponent_actions[-1, :] if history else []
            most_freq_action = np.mean(prev_actions) >= 0.5 if prev_actions.size else False
            return Action.C if most_freq_action else Action.D
        elif state.current_stock / self.capacity > 0.75:
            p = (state.current_stock / self.capacity) ** 0.5
            return Action.C if random.random() < p else Action.D
        elif state.current_stock / self.capacity < 0.25:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock / self.capacity > 0.5:
                return Action.C
            else:
                return Action.D
        else:
            p = 0.5
            return Action.C if random.random() < p else Action.D

class Strategy_COLLECTIVE_425(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Conservation (ASC)

    This strategy prioritizes the conservation of the common pool stock while adapting to opponents' behaviors.
    It combines elements of Tit-for-Tat and a novel stock-based threshold, with edge case handling for last round,
    low stock levels, and high opponent defection rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.5 * game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        majority_opponent_action = self.get_majority_opponent_action(history)
        opponents_defection_rate = np.mean(~history.opponent_actions[-1, :])
        if state.current_stock > self.stock_threshold:
            action = Action.C
        else:
            action = Action.D
        if majority_opponent_action == False and opponents_defection_rate < 0.75:
            action = Action.D
        elif majority_opponent_action == True:
            action = Action.C
        if state.round_number == self.game_description.n_rounds - 1 or state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        elif opponents_defection_rate > 0.75:
            return random.choices([Action.C, Action.D], weights=[0.25, 0.75])[0]
        return action

    def get_majority_opponent_action(self, history: PlayerHistory) -> bool:
        opponent_actions = history.opponent_actions[-1, :]
        majority_action = np.mean(opponent_actions)
        return majority_action >= 0.5

class Strategy_COLLECTIVE_426(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy.
    
    This strategy aims to balance individual payoffs with collective sustainability, 
    adapting to the game's dynamic state and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.num_defectors_in_prev_round = 0
        self.stock_trend = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.num_defectors_in_prev_round = sum((not action for action in history.opponent_actions[-1, :]))
            self.stock_trend.append(state.current_stock)
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        elif 0.5 * self.game_description.capacity <= state.current_stock < 0.75 * self.game_description.capacity:
            defect_prob = self.num_defectors_in_prev_round / self.game_description.n_players
            if random.random() < defect_prob:
                return Action.D
            else:
                return Action.C
        elif state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_427(BaseStrategy):
    """
    The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    This approach prioritizes cooperation when the stock is healthy and gradually shifts towards defection as the stock declines.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.high_threshold = 0.75 * game_description.capacity
        self.low_threshold = 0.25 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number + 1 == self.game_description.n_rounds:
            return Action.D
        if state.current_stock >= self.high_threshold:
            return Action.C
        elif state.current_stock <= self.low_threshold:
            return Action.D
        else:
            if history is None or len(history.my_payoffs) < 1 or len(history.opponent_actions) < 1:
                return Action.C
            avg_payoff_prev = history.my_payoffs[-1]
            total_consumption_prev = self.game_description.n_players * (state.current_stock / (2 * self.game_description.n_players))
            for opponent_action in history.opponent_actions[-1]:
                if opponent_action:
                    total_consumption_prev += state.current_stock / (2 * self.game_description.n_players)
                else:
                    total_consumption_prev += state.current_stock / self.game_description.n_players
            if avg_payoff_prev / total_consumption_prev >= 0.5 or math.isclose(avg_payoff_prev, 0.5 * total_consumption_prev):
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_428(BaseStrategy):
    """
    Adaptive Cooperation with Stock-based Trigger (ACST) strategy.

    This strategy balances individual payoff and collective sustainability by cooperating when the stock level is above a threshold,
    defecting otherwise. It also punishes opponents for exploiting cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.alpha = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        threshold = self.alpha * self.game_description.capacity
        if any((history.opponent_actions[-1, i] == False and history.my_payoffs[-1] > 0 for i in range(self.game_description.n_players - 1))):
            return Action.D
        if state.current_stock > threshold:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_429(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Dependent Threshold (ACSDT) strategy.
    
    This strategy aims to balance individual self-interest with collective sustainability 
    by cooperating when the stock level is high and defecting when it's low, adapting 
    to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_threshold = self.game_description.capacity * (1 - 1 / (self.game_description.n_players + 1))
        if state.current_stock < self.game_description.capacity / 2:
            stock_threshold *= 0.9
        elif state.current_stock > self.game_description.capacity * (1 - 1 / self.game_description.n_players):
            stock_threshold *= 1.05
        if state.current_stock >= stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_430(BaseStrategy):
    """
    A strategy for the Common Pool Resource Game that adapts to various opponent behaviors.
    It balances cooperation and resource conservation while incentivizing collective conservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.safe_threshold = game_description.capacity / (2 * game_description.n_players)
        self.stock_trend = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock > self.safe_threshold else Action.D
        avg_coop_rate = np.mean(history.my_actions[:state.round_number])
        if avg_coop_rate > 0.5 or (history and history.opponent_actions[-1, :].sum() >= self.game_description.n_players // 2):
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_stock = state.current_stock + np.sum(history.my_payoffs[-1] * (history.my_actions[-1] == 0)) + np.sum(history.opponent_payoffs[-1] * (history.opponent_actions[-1, :] == 0))
        if self.stock_trend is None or prev_stock < history.current_stock:
            self.stock_trend = 'decreasing'
        elif prev_stock > history.current_stock:
            self.stock_trend = 'increasing'
        if self.stock_trend == 'increasing' or (self.stock_trend is not None and state.current_stock >= self.safe_threshold):
            return Action.C
        else:
            self.safe_threshold *= 1.1 if self.stock_trend == 'decreasing' else 0.9
            return Action.D if state.current_stock <= self.safe_threshold else Action.C

class Strategy_COLLECTIVE_431(BaseStrategy):
    """
    Adaptive Stock Conservation strategy for the Common Pool Resource game.
    Balances individual payoffs with long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.75

    def calculate_avg_opponent_defection_rate(self, history: PlayerHistory) -> float:
        opponent_actions = history.opponent_actions
        avg_defections = np.mean(1 - opponent_actions, axis=1)
        return np.mean(avg_defections)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_defection_rate_last_round = self.calculate_avg_opponent_defection_rate(history)
        if state.current_stock < self.cooperation_threshold * self.game_description.capacity:
            return Action.C
        ADT = opponent_defection_rate_last_round * (state.current_stock / self.game_description.capacity)
        if ADT > 0.5:
            return Action.D
        else:
            return Action.C
        if history.my_payoffs[-1] < np.mean(history.my_payoffs[-3:]):
            self.cooperation_threshold += 0.1
        if state.round_number == self.game_description.n_rounds - 1 and state.current_stock > 0.5 * self.game_description.capacity:
            return Action.C
        elif state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        elif opponent_defection_rate_last_round > 0.75:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_432(BaseStrategy):
    """
    The ACC strategy balances individual self-interest with collective sustainability 
    by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k = 3

    def calculate_ocr(self, history: PlayerHistory) -> float:
        """
        Calculate the opponent cooperation rate (OCR).
        
        :param history: The player's history.
        :return: The OCR value between 0 and 1.
        """
        recent_cooperative_actions = sum((1 for action in history.opponent_actions[-self.k:, :].flatten() if action))
        total_recent_actions = self.game_description.n_players * min(self.k, len(history.my_actions))
        return recent_cooperative_actions / total_recent_actions if total_recent_actions > 0 else 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decide on the next action based on the current game state and player history.
        
        :param state: The current game state.
        :param history: The player's history (None for initial round).
        :return: The chosen action as an enum value (Action.C or Action.D).
        """
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        elif state.current_stock <= 0.5 * self.game_description.capacity:
            return Action.D
        ocr = self.calculate_ocr(history)
        if ocr > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_433(BaseStrategy):
    """
    Collective Strategy: Adaptive Tit-for-Tat with Stock-Awareness (ATSA)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.2 * self.game_description.capacity:
            return Action.C
        else:
            opponent_actions = history.opponent_actions[-1, :]
            cooperators = sum(opponent_actions)
            if state.current_stock >= 0.5 * self.game_description.capacity:
                return Action.C if cooperators > len(opponent_actions) / 2 else Action.D
            elif state.current_stock < 0.5 * self.game_description.capacity:
                current_consumption = sum((state.current_stock / (self.game_description.n_players * 2) if action else state.current_stock / self.game_description.n_players for action in opponent_actions + [True]))
                remaining_stock = max(0, state.current_stock - current_consumption)
                stock_growth = min(self.game_description.capacity, 2 * remaining_stock * (1 - remaining_stock / self.game_description.capacity))
                positive_growth = stock_growth > 0
                return Action.C if cooperators >= len(opponent_actions) / 2 and positive_growth else Action.D

class Strategy_COLLECTIVE_434(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) Strategy.

    This strategy balances individual self-interest with collective responsibility,
    adapting to the dynamic state and history of the game. It prioritizes cooperation
    when the collective behavior indicates a willingness to conserve the stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        S = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if history is not None:
            OCR = np.mean(history.opponent_actions)
            delta_S = state.current_stock - history.my_payoffs[-1] * n_players
            if OCR == 0 and S < capacity / 4:
                return Action.C
            if S < capacity / 2:
                return Action.D
            elif OCR > 0.5 or delta_S > 0:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_435(BaseStrategy):
    """
    A dynamic, state-dependent strategy that balances individual payoffs with collective sustainability.
    It adapts to various opponent behaviors while promoting cooperation and preserving the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponents_actions_history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.opponents_actions_history is None:
            self.opponents_actions_history = [history.opponent_actions[-1]]
        else:
            self.opponents_actions_history.append(history.opponent_actions[-1])
        stock_level = state.current_stock / self.game_description.capacity
        opponents_cooperators = sum(self.opponents_actions_history[-1]) / len(self.opponents_actions_history[-1])
        if 0.75 <= stock_level:
            return Action.C
        elif 0.5 <= stock_level < 0.75:
            p = (stock_level * 0.5 + 0.25) * opponents_cooperators
            return Action.C if random.random() < p else Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_436(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Preservation (ASP)

    This strategy balances individual payoffs with collective sustainability, adapting to various opponent behaviors while preserving the common pool stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        opponents_cooperated = sum(history.opponent_actions[-1, :]) >= n_players / 2
        if current_stock >= 0.75 * self.capacity:
            return Action.C
        if current_stock <= 0.25 * self.capacity:
            return Action.D
        if opponents_cooperated:
            return Action.C
        previous_stock = history.my_payoffs[-1] * n_players * 2
        stock_decrease = (current_stock - previous_stock) / previous_stock if previous_stock != 0 else 0
        if stock_decrease > 0.2 or not opponents_cooperated:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1 and current_stock >= 0.5 * self.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_437(BaseStrategy):
    """
    Adaptive Collective Conservation (ACC) Strategy.

    This strategy adapts to various opponent behaviors while prioritizing sustainability and cooperation.
    It cooperates when opponents are cooperative enough and defects otherwise, with an adjustable cooperation threshold based on stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :] if history else []
        defect_rate = sum((1 - action for action in opponent_actions)) / len(opponent_actions)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            self.cooperation_threshold -= 0.05
        elif state.current_stock > 0.75 * self.game_description.capacity:
            self.cooperation_threshold += 0.05
        if defect_rate < self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_438(BaseStrategy):
    """
    The ASC strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state, history, and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold_fraction = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        recent_history = self._get_recent_history(history)
        my_payoff_last_round = history.my_payoffs[-1]
        average_payoff = np.mean(np.concatenate((history.my_payoffs, history.opponent_payoffs[:, -1])))
        if state.current_stock > self.stock_threshold_fraction * self.game_description.capacity:
            return Action.C
        elif self._has_exploitation(recent_history) or self._is_self_interest(my_payoff_last_round, average_payoff):
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > self.stock_threshold_fraction * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        elif state.current_stock < 0.2 * self.game_description.capacity:
            return Action.C

    def _get_recent_history(self, history: PlayerHistory) -> tuple[NDArray[np.bool_], float]:
        recent_rounds = min(2, len(history.my_actions))
        actions = history.opponent_actions[-recent_rounds:, :]
        payoffs = history.opponent_payoffs[-recent_rounds:, :]
        stock_decrease = (history.my_payoffs[-1] - history.my_payoffs[-2]) / self.game_description.capacity if recent_rounds == 2 else 0
        return (actions, stock_decrease)

    def _has_exploitation(self, recent_history: tuple[NDArray[np.bool_], float]) -> bool:
        actions, stock_decrease = recent_history
        return np.sum(actions, axis=1).mean() < 0.5 and len(actions) == 2 and (stock_decrease > 0.1)

    def _is_self_interest(self, my_payoff_last_round: float, average_payoff: float) -> bool:
        return my_payoff_last_round < 0.5 * average_payoff

class Strategy_COLLECTIVE_439(BaseStrategy):
    """
    Adaptive Cooperation with Stock Feedback (ACSF) strategy for the Common Pool Resource Game.
    This strategy aims to balance individual self-interest with collective sustainability by cooperating when the stock is plentiful and adapting to others' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        round_number = state.round_number
        if history is None or round_number == 0:
            return Action.C
        current_stock = state.current_stock
        previous_round_actions = history.opponent_actions[-1]
        if current_stock > 0.75 * capacity:
            return Action.C
        elif current_stock < 0.25 * capacity:
            return Action.D
        else:
            if len(history.my_payoffs) > 1 and current_stock > history.my_payoffs[-2]:
                return Action.C
            defect_count = sum((1 for action in previous_round_actions if not action))
            if defect_count > len(previous_round_actions) / 2:
                return Action.D
            else:
                return Action.C
        if round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_440(BaseStrategy):
    """
    Adaptive Stock Conservation strategy for the Common Pool Resource Game.
    
    This strategy balances individual payoff maximization with collective stock conservation,
    ensuring a sustainable game environment. It adapts to changing opponent behaviors and state dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock >= 0.5 * self.game_description.capacity:
            return Action.C
        opponent_defectors = sum((1 for action in history.opponent_actions[-1, :] if not action))
        defect_probability = min(1, opponent_defectors / (self.game_description.n_players - 1))
        if state.current_stock < 0.25 * self.game_description.capacity:
            if any((not action for action in history.opponent_actions[-1, :])):
                return Action.D
            else:
                return Action.C
        return Action.D if random.random() < defect_probability else Action.C

class Strategy_COLLECTIVE_441(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Awareness (ACSA)
    
    This collective strategy adapts to the game's state and history, balancing individual payoffs 
    with collective sustainability. It promotes cooperation while being robust to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.defecting_rounds_left = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and state.round_number == len(history.my_actions)):
            return Action.C
        current_stock = state.current_stock
        previous_opponent_actions = history.opponent_actions[-1] if history else []
        if current_stock > 0.5 * self.capacity:
            return Action.C
        defected_in_previous_round = any((not action for action in previous_opponent_actions))
        multiple_defected = sum((1 for action in previous_opponent_actions if not action)) > len(previous_opponent_actions) / 2
        if defected_in_previous_round:
            return Action.D
        elif multiple_defected and current_stock >= 0.25 * self.capacity:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif current_stock < 0.25 * self.capacity:
            return Action.D
        elif self.defecting_rounds_left > 0:
            self.defecting_rounds_left -= 1
            return Action.D
        elif multiple_defected and state.round_number != self.game_description.n_rounds - 1:
            self.defecting_rounds_left = 2
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_442(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Dependent Trigger (ACSDT) strategy.

    This strategy is designed to be adaptive, robust, and aligned with a collective mindset.
    It establishes a baseline of cooperation in the first round, adapts to changing environmental conditions,
    responds to potential over-exploitation by other players, promotes sustainability, and takes advantage
    of the final opportunity for individual gain in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round_opponent_defections = sum((1 - action for action in history.opponent_actions[-1, :]))
        current_stock_fraction = state.current_stock / self.game_description.capacity
        if previous_round_opponent_defections > 0 and current_stock_fraction < 0.75:
            return Action.D
        elif 0.5 <= current_stock_fraction < 0.75:
            cooperation_probability = (current_stock_fraction - 0.5) / 0.25
            return Action.C if random.random() < cooperation_probability else Action.D
        elif current_stock_fraction < 0.5:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_443(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy for the Common Pool Resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        num_players = self.game_description.n_players
        low_stock_threshold = 0.5 * capacity
        high_stock_threshold = 0.8 * capacity
        if state.round_number == 0:
            return Action.C
        elif current_stock <= low_stock_threshold:
            return Action.D
        elif current_stock >= high_stock_threshold:
            return Action.C
        else:
            mixed_strategy_prob = 0.6
            if history:
                num_defectors = sum((1 for action in history.opponent_actions[-1, :] if not action))
                if num_defectors > num_players / 2:
                    mixed_strategy_prob = 0.4
                else:
                    mixed_strategy_prob = 0.8
            return Action.C if random.random() < mixed_strategy_prob else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_444(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Dependent Threshold (ACS-DT) Strategy.

    This strategy balances individual payoffs with collective sustainability by adjusting cooperation based on the current stock level, history of play, and game parameters.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        scr = state.current_stock / self.game_description.capacity
        if scr >= 0.5:
            return Action.C
        opponent_defections = np.sum(~history.opponent_actions[:, :])
        total_rounds = state.round_number - 1
        opponent_defection_rate = opponent_defections / total_rounds if total_rounds > 0 else 0
        defect_probability = opponent_defection_rate / (total_rounds + 1)
        if random.random() < defect_probability:
            return Action.D
        elif scr < 0.2:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_445(BaseStrategy):
    """
    An adaptive strategy that prioritizes cooperation and collective payoff maximization.
    It monitors stock levels and consumption trends to respond to suspected defections.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.avg_consumption = 0
        self.suspicion_threshold = 0.75
        self.cooperation_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        self.stock_history.append(current_stock)
        avg_consumption = self.calculate_average_consumption(self.stock_history, self.suspicion_threshold)
        if avg_consumption > self.suspicion_threshold:
            return Action.D
        elif current_stock < self.cooperation_threshold * self.game_description.capacity:
            return Action.C
        elif current_stock > self.cooperation_threshold * self.game_description.capacity and avg_consumption < self.cooperation_threshold * self.game_description.capacity:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        else:
            return Action.C

    def calculate_average_consumption(self, stock_history: list[float], suspicion_threshold: float) -> float:
        if len(stock_history) <= 3:
            return np.mean(stock_history)
        recent_stock_levels = stock_history[-3:]
        consumption_rates = [recent_stock_levels[i] - recent_stock_levels[i + 1] for i in range(len(recent_stock_levels) - 1)]
        avg_consumption_rate = np.mean(consumption_rates)
        return avg_consumption_rate / self.game_description.capacity

class Strategy_COLLECTIVE_446(BaseStrategy):
    """
    The Adaptive Stock Guardian strategy prioritizes long-term sustainability of the common pool resource while adapting to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        stock_level = state.current_stock
        opponent_defections = sum(1 - history.opponent_actions[-1, :])
        avg_growth_rate = np.mean(np.diff(history.my_payoffs) if len(history.my_payoffs) > 1 else [0])
        if stock_level > 0.75 * capacity:
            return Action.C
        elif stock_level >= 0.5 * capacity and stock_level < 0.75 * capacity:
            p = (stock_level / capacity - 0.5) ** 2
            if opponent_defections > n_players / 2:
                p += 0.2
            if avg_growth_rate < -0.05:
                p -= 0.3
            return Action.D if random.random() < p else Action.C
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_447(BaseStrategy):
    """
    This strategy balances individual payoff maximization with collective responsibility 
    to conserve the common pool resource. It adapts to various opponent behaviors while 
    ensuring the stock's sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        prev_total_consumption = sum(np.where(history.opponent_actions[-1, :], self.game_description.capacity / (2 * self.game_description.n_players), self.game_description.capacity / self.game_description.n_players))
        if history.my_actions.size > 0:
            prev_total_consumption += np.where(history.my_actions[-1], self.game_description.capacity / (2 * self.game_description.n_players), self.game_description.capacity / self.game_description.n_players)
        current_stock = state.current_stock
        if prev_total_consumption > 0.5 * self.game_description.capacity or current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if current_stock < 0.1 * self.game_description.capacity:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_448(BaseStrategy):
    """
    This strategy adapts to the stock level and opponent actions to balance individual payoffs with collective well-being.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_depletion = self.calculate_avg_depletion(history)
        if avg_depletion < 0.5 * self.game_description.capacity and state.round_number < self.game_description.n_rounds / 2:
            return Action.C
        if state.current_stock > 0.75 * self.game_description.capacity and sum(history.opponent_actions[-1, :]) >= self.game_description.n_players / 2:
            return Action.C
        elif state.current_stock < 0.25 * self.game_description.capacity or sum(history.opponent_actions[-1, :]) < self.game_description.n_players / 2:
            return Action.D
        else:
            p = self.calculate_probability(history)
            random_num = random.random()
            if random_num < p:
                return Action.C
            else:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number >= self.game_description.n_rounds - 2 and state.current_stock < 0.1 * self.game_description.capacity:
            return Action.C

    def calculate_avg_depletion(self, history: PlayerHistory):
        total_depletion = sum(history.my_payoffs[:history.my_actions.size])
        return total_depletion / history.my_actions.size

    def calculate_probability(self, history: PlayerHistory):
        opponents_cooperated = np.sum(history.opponent_actions, axis=1)
        p = np.mean(opponents_cooperated) / self.game_description.n_players
        return p

class Strategy_COLLECTIVE_449(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Threshold (ACS-ST) Strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.threshold = 0.75 * self.capacity
        self.defection_probability = 0
        self.exploration_rate = 0.05

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        self.defection_probability = max(0, min(1, (self.threshold - current_stock) / self.threshold))
        if history.my_payoffs[-1] < current_stock / (2 * self.n_players):
            self.defection_probability = min(1, self.defection_probability + 0.1)
        if random.random() < self.exploration_rate:
            return Action.C if random.random() < 0.5 else Action.D
        if current_stock > self.threshold:
            return Action.C
        elif random.random() < self.defection_probability:
            return Action.D
        elif current_stock < 0.2 * self.capacity:
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_450(BaseStrategy):
    """
    A strategy that adapts to various opponent behaviors in the Common Pool Resource Game.
    It prioritizes cooperation when possible, while adapting to opponents' behavior and the state of the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperate = True
        self.punishment_phase = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if all((history.opponent_actions[-1, i] for i in range(self.game_description.n_players - 1))):
            self.cooperate = True
        stock_decrease = (state.current_stock - history.my_payoffs[-1]) / self.game_description.capacity
        if stock_decrease > 0.2:
            self.punishment_phase = True
            self.cooperate = False
        if self.punishment_phase and state.current_stock < 0.3 * self.game_description.capacity:
            self.cooperate = True
        if len(history.my_actions) >= 2 and all((history.my_actions[-i] for i in range(1, 3))) and self.punishment_phase:
            self.punishment_phase = False
            self.cooperate = True
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > 0.5 * self.game_description.capacity:
                self.cooperate = False
        if state.current_stock < 0.2 * self.game_description.capacity:
            self.cooperate = True
        if random.random() < 0.05:
            self.cooperate = not self.cooperate
        return Action.C if self.cooperate else Action.D

class Strategy_COLLECTIVE_451(BaseStrategy):
    """
    Adaptive Stock-Conscious Cooperation (ASCC) strategy.

    This strategy balances individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and history of player actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_ratio_threshold = 0.5
        self.cooperation_level = 1.0
        self.payoff_threshold = 0.75 * (game_description.capacity / (2 * game_description.n_players))
        self.history_window = min(3, game_description.n_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        avg_payoff = np.mean(history.my_payoffs[-self.history_window:]) if len(history.my_payoffs) >= self.history_window else 0
        if avg_payoff > self.payoff_threshold:
            self.cooperation_level += 0.1
        elif avg_payoff < self.payoff_threshold:
            self.cooperation_level -= 0.1
        self.cooperation_level = max(0, min(self.cooperation_level, 1))
        if stock_ratio > self.stock_ratio_threshold:
            action = Action.C
        else:
            action = Action.D
        if history.my_actions[-1] == False and len(history.opponent_payoffs) > 0:
            opponent_avg_payoff = np.mean(np.concatenate([x for x in history.opponent_payoffs]))
            if avg_payoff > opponent_avg_payoff:
                self.stock_ratio_threshold -= 0.05
                self.stock_ratio_threshold = max(0, min(self.stock_ratio_threshold, 1))
        return action if random.random() < self.cooperation_level else Action.D

class Strategy_COLLECTIVE_452(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Awareness (ACSA) strategy.
    
    This strategy balances individual and collective interests by adapting to the game state 
    and opponents' behaviors while prioritizing sustainability and robustness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        opponent_defection_rates = np.mean(history.opponent_actions, axis=0)
        if current_stock >= 0.75 * capacity:
            return Action.C
        elif 0.25 * capacity <= current_stock < 0.75 * capacity:
            p = (current_stock / capacity) ** 2
            for i, rate in enumerate(opponent_defection_rates):
                if rate > 0.5 and random.random() < 0.8:
                    p *= 0.8
                elif rate < 0.2 and random.random() < 0.1:
                    p *= 1.1
            return Action.C if random.random() < p else Action.D
        elif current_stock < 0.25 * capacity:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_453(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and game history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.tau = 0
        self.penalized_opponents = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        S = state.current_stock
        opponents_actions = history.opponent_actions
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        tau = S / capacity * (n - 1)
        num_cooperators = sum(opponents_actions[-1, :])
        for opponent_idx, opponent_action in enumerate(opponents_actions[-1, :]):
            if opponent_idx not in self.penalized_opponents and opponent_action == 0:
                p_opponent = 1 - sum(opponents_actions[:, opponent_idx]) / state.round_number
                if p_opponent < 0.5:
                    self.penalized_opponents.append(opponent_idx)
        if S < 0.5 * capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1 and (S < 0.25 * capacity or any((opponent_idx in self.penalized_opponents for opponent_idx in range(n)))):
            return Action.D
        if S <= 0:
            return Action.C
        if num_cooperators >= tau:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_454(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Conservation (ASC)

    The ASC strategy aims to balance individual payoffs with collective sustainability by adaptively responding to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (self.game_description.n_rounds == 2 and state.round_number == 1):
            return Action.C
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        p_defect = math.sqrt(current_stock / capacity)
        if current_stock > 0.75 * capacity:
            return Action.D if random.random() < p_defect else Action.C
        elif 0.5 <= current_stock / capacity <= 0.75:
            return Action.C
        else:
            p_cooperate = math.sqrt(capacity / current_stock)
            return Action.C if random.random() < p_cooperate else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_455(BaseStrategy):
    """
    A collective adaptive strategy for managing common pool resources.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.75 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_defections = np.sum(~history.opponent_actions[-3:, :], axis=0)
        if state.current_stock > self.stock_threshold:
            return Action.C
        if np.any(opponent_defections > 2):
            return Action.D
        reciprocal_cooperation = random.random() < 0.8 and history.opponent_actions[-1, 0]
        if reciprocal_cooperation:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.C
        if state.current_stock < self.stock_threshold / 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_456(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy for the Common Pool Resource Game.
    
    ASC balances individual interests with collective well-being by cooperating when the stock is healthy and adapting to changes in the game state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity * 0.75
        self.payoff_threshold = game_description.capacity / (2 * game_description.n_players) * 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        previous_total_consumption = sum(np.where(history.opponent_actions[-1, :] == True, self.stock_threshold / (2 * self.game_description.n_players), self.stock_threshold / self.game_description.n_players))
        if previous_total_consumption > self.game_description.capacity * 0.5:
            return Action.D
        elif state.current_stock > self.stock_threshold:
            return Action.C
        else:
            return Action.D
        average_payoff = np.mean(history.my_payoffs[-1])
        if average_payoff >= self.payoff_threshold:
            self.stock_threshold *= 1.05
        else:
            self.stock_threshold *= 0.95
        if state.current_stock < self.game_description.capacity * 0.25:
            return Action.D

class Strategy_COLLECTIVE_457(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock-Based Threshold (ATTS) strategy.
    
    This collective strategy balances individual self-interest with cooperation to maintain a healthy common pool resource.
    It adapts to changing stock levels and opponent behaviors, ensuring robustness in various scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock < self.game_description.capacity / 6 and self.__class__.low_stock_warning_count < 2:
            self.__class__.low_stock_warning_count += 1
            return Action.C
        else:
            self.__class__.low_stock_warning_count = 0
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        prev_payoff = history.my_payoffs[-1]
        expected_payoff = state.current_stock / (2 * self.game_description.n_players)
        if state.current_stock < self.stock_threshold:
            return Action.D
        if prev_payoff < expected_payoff:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_458(BaseStrategy):
    """
    Adaptive Stock Conservation strategy prioritizes collective sustainability 
    while adapting to opponents' behaviors in a common pool resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_opponents_actions = history.opponent_actions[-1]
        defected_opponents = sum(previous_opponents_actions)
        punished_opponents = sum(previous_opponents_actions & (history.my_payoffs[-1] >= 0.5 * self.game_description.capacity / self.game_description.n_players))
        if state.current_stock >= 0.5 * self.game_description.capacity:
            return Action.C
        elif defected_opponents > 0:
            return Action.D
        elif punished_opponents > 0:
            return Action.C
        elif state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1 or state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_459(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Sensitive Tit-for-Tat (ASST) strategy.
    Balances individual self-interest with collective well-being by adapting to 
    the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def calculate_average_payoff(self, history: PlayerHistory) -> float:
        """
        Calculate average payoff per player in the previous round.
        
        Args:
            history (PlayerHistory): History of actions and payoffs.

        Returns:
            float: Average payoff per player in the previous round.
        """
        total_payoff = np.sum(history.my_payoffs[-1]) / self.game_description.n_players
        return total_payoff

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_payoff_prev = self.calculate_average_payoff(history)
        max_payoff = state.current_stock / (2 * self.game_description.n_players)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            defect_prob = (self.game_description.capacity - state.current_stock) / self.game_description.capacity
            if random.random() < defect_prob:
                return Action.D
            else:
                return Action.C
        if avg_payoff_prev > 0.75 * max_payoff:
            return Action.C
        else:
            defect_prob = (self.game_description.capacity - state.current_stock) / self.game_description.capacity
            if random.random() < defect_prob:
                return Action.D
            else:
                return Action.C

class Strategy_COLLECTIVE_460(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy for the Common Pool Resource Game.
    
    This strategy aims to balance individual payoffs with collective sustainability, 
    adapting to various opponent behaviors and game states.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        p = math.pow(state.current_stock / self.capacity, 2 / self.n_players)
        if state.round_number == self.game_description.n_rounds - 1:
            p *= 0.6
        return Action.C if random.random() < p else Action.D

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        if current_stock >= 0.75 * self.capacity:
            return Action.C
        elif 0.5 * self.capacity <= current_stock < 0.75 * self.capacity:
            p = math.pow(current_stock / self.capacity, 2 / self.n_players)
            if state.round_number == self.game_description.n_rounds - 1:
                p *= 0.6
            return Action.C if random.random() < p else Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_461(BaseStrategy):
    """
    Collective Strategy: "Sustainable Cooperation"

    This strategy prioritizes collective sustainability while allowing for individual flexibility.
    By cooperating in the initial round and maintaining sustainability when possible,
    players contribute to a stable common pool resource. Defecting with probability `p` in middle rounds
    introduces an adaptive element, enabling players to balance short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.theta = 0.5

    def calculate_growth_rate(self, stock_level_history: NDArray[np.float64]) -> float:
        if len(stock_level_history) < 2:
            return 0.0
        total_consumption = np.sum(stock_level_history[:-1] - stock_level_history[1:])
        average_stock_level = np.mean(stock_level_history)
        growth_rate = (stock_level_history[-1] - stock_level_history[0]) / (len(stock_level_history) * average_stock_level)
        return max(growth_rate, 0.0)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        growth_rate = self.calculate_growth_rate(history.my_payoffs)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        stock_level = state.current_stock
        if growth_rate > self.theta and stock_level < self.capacity:
            return Action.C
        p = 1.0 - stock_level / self.capacity
        return Action.D if random.random() < p else Action.C

class Strategy_COLLECTIVE_462(BaseStrategy):
    """
    Adaptive Sustainability strategy prioritizes cooperation when the stock is plentiful and there's a history of cooperation.
    It adapts to changing circumstances, balancing individual payoffs with sustainability concerns.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.T = None

    def calculate_average_historical_payoff(self, history: PlayerHistory) -> float:
        return np.mean(history.my_payoffs)

    def count_cooperators(self, actions: NDArray[np.bool_]) -> int:
        return sum(actions)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            if state.current_stock >= 0.75 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        AHP = self.calculate_average_historical_payoff(history)
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        elif state.current_stock < 0.5 * self.game_description.capacity:
            if self.T is None:
                self.T = state.current_stock / (2 * self.game_description.n_players)
            if AHP > self.T:
                return Action.C
            else:
                return Action.D
        else:
            prev_coop_count = self.count_cooperators(history.opponent_actions[-1, :])
            if prev_coop_count >= self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if (state.round_number + 1) % 5 == 0:
            if AHP > self.T:
                self.T *= 0.9
            else:
                self.T *= 1.1
        return Action.C

class Strategy_COLLECTIVE_463(BaseStrategy):
    """
    Collective Strategy: Adaptive Tit-for-Two-Tats with Stock Consideration.
    
    This strategy aims to balance individual payoff maximization with collective sustainability of the common pool resource.
    It adapts to opponents' actions, considers the state of the common pool resource, and promotes cooperation when possible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_defection_majorities = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        num_cooperators = sum((1 for action in history.opponent_actions[-1] if action))
        num_defectors = self.game_description.n_players - 1 - num_cooperators
        if num_cooperators > self.game_description.n_players / 2:
            return Action.C
        elif num_defectors > self.game_description.n_players / 2:
            self.consecutive_defection_majorities += 1
            return Action.D
        elif self.consecutive_defection_majorities >= 2:
            self.consecutive_defection_majorities = 0
            return Action.D
        else:
            self.consecutive_defection_majorities = 0
            return Action.C
        if state.current_stock < self.game_description.capacity / 2:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_464(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Sensitive Tit-for-Tat (ACSST) strategy.

    This strategy adapts cooperation levels based on the current stock level and opponent behavior.
    It promotes a culture of cooperation while minimizing the risk of exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.switch_to_defection = False
        self.increase_cooperation = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock_percentage = state.current_stock / self.game_description.capacity
        opponents_cooperated = np.sum(history.opponent_actions[-1, :])
        for opponent in history.opponent_actions[:, :-1].T:
            if all(opponent) and len(opponent[opponent == True]) >= 2:
                self.increase_cooperation = True
                break
            elif not any(opponent) and len(opponent[opponent == False]) >= 2:
                self.switch_to_defection = True
                break
        if current_stock_percentage >= 0.75 or self.increase_cooperation:
            return Action.C
        elif current_stock_percentage < 0.5:
            return Action.D
        elif opponents_cooperated > self.game_description.n_players / 2:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C if opponents_cooperated > self.game_description.n_players / 2 else Action.D
        if current_stock_percentage < 0.25:
            return Action.D

class Strategy_COLLECTIVE_465(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that adapts to 
    opponents' behaviors while prioritizing cooperation and stock conservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        stock = state.current_stock
        early_round_threshold = 0.75 * capacity
        middle_round_threshold = n_players // 2
        p_defect = (stock / capacity) ** 2
        if round_number < self.game_description.n_rounds // 2:
            return Action.D if random.random() < p_defect else Action.C
        elif round_number < 3 * self.game_description.n_rounds // 4:
            opponent_actions = history.opponent_actions[-1, :]
            cooperators = sum(opponent_actions)
            if cooperators > middle_round_threshold:
                return Action.C
            elif cooperators < middle_round_threshold:
                return Action.D
            else:
                return Action.D if random.random() < p_defect else Action.C
        elif stock < 0.25 * capacity:
            return Action.C
        else:
            return Action.D if random.random() < p_defect else Action.C
        return Action.D

class Strategy_COLLECTIVE_466(BaseStrategy):
    """
    Adaptive Stock Conservation strategy for Common Pool Resource Game.
    
    This strategy prioritizes cooperation when possible while adapting to changes 
    in the stock level and opponent behaviors. By cooperating initially and 
    reciprocating cooperation, ASC encourages other players to cooperate. When 
    facing minority defection or low stock levels, ASC defects to protect individual 
    interests. This collective strategy balances cooperation and self-interest, 
    making it robust against a wide range of opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_coops = sum((1 for action in history.opponent_actions[-1, :] if action))
        prev_round_defects = self.game_description.n_players - prev_round_coops
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        elif prev_round_coops >= self.game_description.n_players - 1 and state.current_stock > 0.5 * self.game_description.capacity:
            return Action.C
        elif prev_round_defects < self.game_description.n_players / 2 and state.current_stock < 0.75 * self.game_description.capacity:
            return Action.D
        elif any((not action for action in history.opponent_actions[-1, :])):
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_467(BaseStrategy):
    """
    The Adaptive Sustainability strategy prioritizes long-term sustainability of the common pool while adapting to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == 1:
            return Action.C
        elif state.round_number == 2:
            prev_defectors = sum((1 for action in history.opponent_actions[-1, :] if not action))
            if prev_defectors > 0:
                return Action.D
            else:
                return Action.C
        else:
            defector_count = sum((1 for action in history.opponent_actions[-1, :] if not action))
            if defector_count > self.game_description.n_players / 2:
                return Action.D
            elif state.current_stock < self.game_description.capacity / 2:
                return Action.C
            else:
                avg_payoff_prev_round = np.mean(history.opponent_payoffs[-1, :])
                threshold = self.game_description.capacity / (2 * self.game_description.n_players) * self.game_description.n_players * 0.75
                if avg_payoff_prev_round >= threshold:
                    return Action.C
                else:
                    return Action.D
            if state.round_number == self.game_description.n_rounds - 1 and state.current_stock < self.game_description.capacity / 4:
                return Action.D

class Strategy_COLLECTIVE_468(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock-Dependent Threshold (ACSDT)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def calculate_threshold(self, stock: float) -> float:
        if stock > self.game_description.capacity / 2:
            return self.game_description.capacity / (2 * self.game_description.n_players)
        else:
            return stock / (4 * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.game_description.capacity / 4:
            return Action.C
        T = self.calculate_threshold(state.current_stock)
        num_coop_prev = sum(history.opponent_actions[-1, :])
        if num_coop_prev >= self.game_description.n_players / 2 and state.current_stock >= T:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_469(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_threshold_75 = 0.75 * self.game_description.capacity
        stock_threshold_50 = 0.5 * self.game_description.capacity
        recent_cooperators = np.sum(history.opponent_actions[-3:, :])
        opponent_count = self.game_description.n_players - 1
        if recent_cooperators >= 2 / 3 * (opponent_count + 1):
            return Action.C
        p = (self.game_description.capacity - state.current_stock) / self.game_description.capacity
        opponent_actions = history.opponent_actions[-3:, :]
        for i in range(opponent_count):
            defector_count = np.sum(1 - opponent_actions[:, i])
            cooperator_count = 3 - defector_count
            if defector_count > 0.5 * 3:
                p += 0.1 * (defector_count - 0.5 * 3)
            elif cooperator_count > 0.5 * 3:
                p -= 0.1 * (cooperator_count - 0.5 * 3)
        if state.current_stock > stock_threshold_75:
            return Action.C
        elif state.current_stock >= stock_threshold_50:
            return Action.D if random.random() < p else Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_470(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Awareness (ATSA) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock = state.current_stock / self.capacity
        threshold = 0.5
        if stock < 0.25:
            threshold = 0.33
        elif stock > 0.75:
            threshold = 0.67
        opponent_actions = history.opponent_actions[-1, :]
        cooperators = sum(opponent_actions)
        if cooperators >= threshold * self.n_players:
            return Action.C
        else:
            return Action.D
        if stock < 0.25 and (not all(opponent_actions)):
            return Action.D
        elif len([action for action in history.my_actions[-5:] if action]) >= 3:
            return Action.C
        if stock < 0.1:
            return Action.C
        elif stock > 0.9:
            threshold = 0.75
        if state.round_number == self.game_description.n_rounds - 1:
            if stock >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_COLLECTIVE_471(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and aligns with the collective mindset.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_consumption = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.total_consumption += np.sum(history.my_payoffs[-1] + np.mean(history.opponent_payoffs[-1, :], axis=0))
        if self.total_consumption > 0.75 * self.game_description.capacity:
            return Action.D
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        elif state.current_stock >= 0.5 * self.game_description.capacity:
            p = (self.game_description.capacity - state.current_stock) / self.game_description.capacity
            return Action.D if random.random() < p else Action.C
        elif state.current_stock < 0.5 * self.game_description.capacity and state.round_number != self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.25 * self.game_description.capacity or state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_472(BaseStrategy):
    """
    Adaptive Collective Conservation (ACC) strategy for Common Pool Resource Game.
    
    This strategy adapts to various opponent behaviors and game conditions, prioritizing cooperation when the resource is abundant,
    while balancing short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        previous_stock = self.capacity if history is None else state.current_stock
        current_stock = state.current_stock
        if current_stock > 0.75 * self.capacity:
            cooperation_prob = sum(history.opponent_actions[-1, :]) / (self.n_players - 1)
        elif current_stock < 0.25 * self.capacity:
            multiple_defectors = sum(~history.opponent_actions[-1, :]) >= 2
            cooperation_prob = 0.5 if multiple_defectors else 0.0
        else:
            most_cooperated = sum(history.opponent_actions[-1, :]) >= self.n_players // 2
            cooperation_prob = 1.0 if most_cooperated else 0.0
        if current_stock < 0.1 * self.capacity:
            cooperation_prob = 0.75
        if state.round_number == self.game_description.n_rounds - 1:
            cooperation_prob = 1.0 if current_stock > 0.5 * self.capacity else 0.0
        return Action.C if random.random() < cooperation_prob else Action.D

class Strategy_COLLECTIVE_473(BaseStrategy):
    """
    Adaptive Stock Conservation strategy for the Common Pool Resource Game.

    This strategy aims to balance collective sustainability with individual payoff maximization.
    It adapts to opponent actions and stock levels, playing Cooperate (C) when possible and Defect (D) otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        previous_actions = history.opponent_actions[-1, :] if history else []
        if current_stock > 0.75 * capacity:
            return Action.C
        elif 0.5 * capacity <= current_stock <= 0.75 * capacity:
            if any((not action for action in previous_actions)):
                return Action.D
            else:
                return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_474(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy for the Common Pool Resource Game.
    
    This strategy aims to balance individual payoff maximization with collective sustainability 
    of the common pool resource. It adapts to the game state and history, responding to opponent 
    behaviors while promoting cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        CT = 0.5 * self.game_description.capacity
        AT = 0.25 * self.game_description.capacity
        if state.current_stock > CT:
            return Action.C
        elif state.current_stock < AT:
            return Action.D
        opponent_CRs = []
        for opponent_actions in history.opponent_actions.T:
            CR = np.mean(opponent_actions)
            opponent_CRs.append(CR)
        avg_CR = np.mean(opponent_CRs)
        if avg_CR > 0.5:
            return Action.C
        elif avg_CR < 0.3:
            return Action.D
        else:
            cooperation_prob = avg_CR
            if state.current_stock > CT:
                cooperation_prob += 0.1
            elif state.current_stock < AT:
                cooperation_prob -= 0.2
            if state.round_number == self.game_description.n_rounds - 1:
                return Action.D
            return Action.C if random.random() < cooperation_prob else Action.D

class Strategy_COLLECTIVE_475(BaseStrategy):
    """
    A hybrid strategy that balances individual self-interest with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.adaptive_threshold = 0.7
        self.opponent_actions = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number < 5:
            self.opponent_actions.append(history.opponent_actions[-1, :])
            average_cooperation_rate = np.mean(self.opponent_actions)
            if average_cooperation_rate >= 0.6:
                self.adaptive_threshold = 0.7
            elif 0.4 <= average_cooperation_rate < 0.6:
                self.adaptive_threshold = 0.5
            else:
                self.adaptive_threshold = 0.3
        if state.current_stock > self.game_description.capacity * self.adaptive_threshold:
            action = Action.C
        else:
            action = Action.D
        if sum((1 - x for x in history.opponent_actions[-1, :])) > self.game_description.n_players / 2:
            action = Action.D
        if state.current_stock < 0.1 * self.game_description.capacity:
            action = Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > 0.5 * self.game_description.capacity:
                action = Action.C
        return action

class Strategy_COLLECTIVE_476(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Consideration strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        prev_coop_count = sum(history.opponent_actions[-1, :])
        prev_defect_count = self.n_players - prev_coop_count
        stock_level = state.current_stock / self.capacity
        if stock_level < 0.25:
            return Action.C
        elif stock_level > 0.75:
            if prev_coop_count >= self.n_players // 2:
                return Action.C
            elif prev_defect_count > self.n_players // 2:
                return Action.D
        if history and any((not action for action in history.opponent_actions[-1, :])) and (stock_level > 0.5):
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_477(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Preservation (ASP)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.CSL = 0.5 * self.capacity
        self.WSL = 0.8 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        cooperators = np.sum(opponent_actions)
        defectors = self.n_players - 1 - cooperators
        if state.current_stock >= self.WSL:
            return Action.C
        elif self.CSL <= state.current_stock < self.WSL:
            p = (state.current_stock - self.CSL) / (self.WSL - self.CSL)
            return Action.D if random.random() < p else Action.C
        else:
            return Action.D
        if cooperators > defectors:
            return Action.C
        elif defectors > cooperators:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_478(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy.
    
    This strategy aims to balance individual payoffs with collective sustainability, 
    ensuring a stable and resilient common pool resource over multiple rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.5
        self.total_consumption = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        cooperators = sum(opponent_actions)
        defectors = len(opponent_actions) - cooperators
        coop_consumption = state.current_stock / (2 * self.game_description.n_players) * cooperators
        defect_consumption = state.current_stock / self.game_description.n_players * defectors
        self.total_consumption = coop_consumption + defect_consumption
        S_remaining = state.current_stock - self.total_consumption
        CR_opponents = np.mean(history.opponent_actions, axis=1)[-1]
        if S_remaining < 0.5 * self.game_description.capacity:
            return Action.D
        if CR_opponents > self.threshold:
            action = Action.C
        else:
            action = Action.D
        if S_remaining > 3 / 4 * self.game_description.capacity and CR_opponents > 0.5:
            self.threshold += 0.1
            self.threshold = min(self.threshold, 1)
        elif S_remaining < 1 / 4 * self.game_description.capacity or CR_opponents < 0.5:
            self.threshold -= 0.1
            self.threshold = max(self.threshold, 0)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if S_remaining < 1 / 10 * self.game_description.capacity:
            return Action.D
        return action

class Strategy_COLLECTIVE_479(BaseStrategy):
    """
    Collective strategy that prioritizes cooperation when possible, 
    while adapting to changing circumstances and penalizing selfish behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.history_payoff_diffs = []

    def calculate_avg_payoff_diff(self, history: PlayerHistory) -> float:
        last_round = len(history.my_payoffs) - 1
        avg_coop_payoff = np.mean(history.opponent_payoffs[last_round, history.opponent_actions[last_round] == True])
        avg_defect_payoff = np.mean(history.opponent_payoffs[last_round, history.opponent_actions[last_round] == False])
        return avg_defect_payoff - avg_coop_payoff

    def detect_defector(self, history: PlayerHistory) -> bool:
        last_round = len(history.my_payoffs) - 1
        opponent_actions = history.opponent_actions[last_round]
        return any(opponent_actions == False)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock > 0.75 * self.capacity:
            return Action.C
        avg_payoff_diff = self.calculate_avg_payoff_diff(history)
        self.history_payoff_diffs.append(avg_payoff_diff)
        if len(self.history_payoff_diffs) > 5:
            self.history_payoff_diffs.pop(0)
        if np.mean(self.history_payoff_diffs[-3:]) > 10:
            return Action.D
        elif self.detect_defector(history):
            return Action.C
        if state.current_stock < 0.25 * self.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 10 or sum(history.opponent_actions[-1, :]) > self.n_players // 2:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_480(BaseStrategy):
    """
    Collective Strategy: Adaptive Tit-for-Tat with Stock Preservation (ATTP)

    A strategy that balances cooperation and individual payoff by adapting to the current stock level.
    It prioritizes cooperation while preserving the common pool resource for future rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_cooperations = sum(history.opponent_actions[-1, :])
        coop_rate = opponent_cooperations / self.game_description.n_players
        if state.current_stock > 0.5 * self.game_description.capacity:
            return Action.C if coop_rate >= 0.5 else Action.D
        elif 0.25 * self.game_description.capacity <= state.current_stock <= 0.5 * self.game_description.capacity:
            return Action.C if coop_rate >= 0.5 else Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_481(BaseStrategy):
    """
    Adaptive Cooperation strategy for the Common Pool Resource Game.
    This strategy balances individual payoffs with collective sustainability by dynamically adjusting cooperation levels based on game state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.round_number = 0
        self.stock_fraction = None
        self.cooperation_probability = None
        self.history = []
        self.tau = 5
        self.delta_p = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.stock_fraction = state.current_stock / self.capacity
        self.cooperation_probability = (self.stock_fraction - 0.5) / 0.5 if state.current_stock >= self.capacity / 2 else (0.5 - self.stock_fraction) / 0.5
        if len(self.history) > 1:
            average_payoff = np.mean(self.history[-self.tau:])
            threshold = self.capacity / (4 * self.n_players)
            if average_payoff < threshold:
                self.cooperation_probability += self.delta_p
            elif average_payoff > threshold:
                self.cooperation_probability -= self.delta_p
            self.cooperation_probability = max(0, min(self.cooperation_probability, 1))
        action = Action.C if random.random() < self.cooperation_probability else Action.D
        self.history.append(state.current_stock / (2 * self.n_players) if action == Action.C else state.current_stock / self.n_players)
        self.round_number += 1
        if state.round_number >= self.game_description.n_rounds - 1:
            return Action.C
        return action

class Strategy_COLLECTIVE_482(BaseStrategy):
    """
    Collective Strategy: Adaptive Tit-for-Two-Tats with Stock Conservation.
    
    Balances individual payoffs with collective sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round_actions = history.opponent_actions[-1]
        num_defectors = sum([not action for action in previous_round_actions])
        stock_level = state.current_stock
        if num_defectors >= 2 or stock_level < self.capacity / 2:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_483(BaseStrategy):
    """
    Adaptive Stock Conservation Strategy for Common Pool Resource Game.
    
    This strategy prioritizes collective sustainability by cooperating when the stock is healthy and defecting as it depletes.
    It adapts to changing circumstances, balancing short-term gains with long-term resource conservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if self.threshold is None:
            self.threshold = self.game_description.capacity / (self.game_description.n_players + 1)
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        probability_defect = 1 - current_stock / self.game_description.capacity
        if random.random() < probability_defect:
            action = Action.D
        else:
            action = Action.C
        if history.my_actions[-1] == 0:
            self.threshold *= 0.9
        elif any(history.opponent_actions[-1, :] == 0):
            self.threshold *= 1.1
        if state.round_number + 1 == self.game_description.n_rounds:
            return Action.D
        if probability_defect == 0.5:
            return Action.C
        return action

class Strategy_COLLECTIVE_484(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with long-term conservation goals.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        stock = state.current_stock
        if state.round_number == 0 or history is None:
            return Action.C
        num_defectors_prev_round = sum((not action for action in history.opponent_actions[-1, :]))
        if stock < 0.1 * self.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock > 0.75 * self.capacity:
            return Action.C
        elif stock >= 0.25 * self.capacity and stock <= 0.75 * self.capacity:
            defect_prob = num_defectors_prev_round / n_players
            return Action.D if random.random() < defect_prob else Action.C
        elif stock < 0.25 * self.capacity:
            return Action.C

class Strategy_COLLECTIVE_485(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock-Aware Tit-for-Tat.
    
    This strategy balances individual payoff maximization with collective sustainability 
    by adapting to the current stock level and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_previous_action = np.any(history.opponent_actions[-1, :])
        stock_level_ratio = state.current_stock / self.game_description.capacity
        if stock_level_ratio >= 0.75 or state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif 0.25 <= stock_level_ratio < 0.75:
            if opponent_previous_action:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_486(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy balances individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        prev_round = history.my_payoffs.shape[0] - 1
        total_consumption = self.n_players * state.current_stock / self.n_players
        stock_growth = 2 * (state.current_stock - total_consumption) * (1 - (state.current_stock - total_consumption) / self.capacity)
        new_stock_level = min(state.current_stock - total_consumption + stock_growth, self.capacity)
        sci = (new_stock_level - total_consumption) / self.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif new_stock_level <= self.n_players:
            return Action.C
        elif new_stock_level >= 1.5 * self.capacity:
            return Action.D
        elif sci >= 0.5 and state.current_stock > self.n_players:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_487(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Sensitive Threshold (ACST) strategy.
    
    Balances individual payoffs with collective sustainability, adapting to 
    changing stock levels and opponent behaviors while promoting cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.rounds = game_description.n_rounds
        self.threshold = 0.7 * self.capacity
        self.min_threshold = 0.1 * self.capacity
        self.defection_prob = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.defection_prob is None or state.round_number > self.rounds // 2:
            avg_payoff_diff = self.calculate_average_payoff_difference(history)
            if avg_payoff_diff > 0:
                self.defection_prob = max(0, self.defection_prob - 0.1) if self.defection_prob else 0
            elif avg_payoff_diff < 0:
                self.defection_prob = min(1, self.defection_prob + 0.1) if self.defection_prob else 0
        if self.defection_prob is None:
            self.defection_prob = 0.5 / self.n_players
        if state.current_stock >= self.threshold or state.current_stock < self.min_threshold:
            return Action.C
        else:
            return Action.D if random.random() < self.defection_prob else Action.C

    def calculate_average_payoff_difference(self, history: PlayerHistory) -> float:
        my_coop_payoffs = history.my_payoffs[history.my_actions]
        my_defect_payoffs = history.my_payoffs[~history.my_actions]
        avg_coop_payoff = np.mean(my_coop_payoffs) if len(my_coop_payoffs) > 0 else 0
        avg_defect_payoff = np.mean(my_defect_payoffs) if len(my_defect_payoffs) > 0 else 0
        return avg_coop_payoff - avg_defect_payoff

class Strategy_COLLECTIVE_488(BaseStrategy):
    """
    Adaptive Stock Conservation Strategy.
    
    This strategy aims to balance individual payoffs with collective sustainability of the common pool resource.
    It adapts to changing game conditions and opponent behaviors while promoting cooperation when beneficial.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5 * game_description.capacity
        self.prev_stock_level = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock_level = state.current_stock
        opponent_actions = history.opponent_actions[-1, :]
        if history.my_payoffs.shape[0] == 1:
            opponent_cooperators = 0
        else:
            opponent_cooperators = np.sum(opponent_actions)
        if opponent_cooperators >= self.game_description.n_players // 2:
            self.cooperation_threshold -= 0.05 * self.game_description.capacity
        elif history.my_payoffs.shape[0] > 1 and opponent_cooperators < self.game_description.n_players // 2:
            self.cooperation_threshold += 0.1 * self.game_description.capacity
        if current_stock_level > self.cooperation_threshold:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif current_stock_level < self.game_description.capacity / 10 and self.game_description.n_rounds - state.round_number <= 3:
            return Action.D
        self.prev_stock_level = current_stock_level

class Strategy_COLLECTIVE_489(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy for the Common Pool Resource Game.
    
    This strategy balances individual payoffs with long-term stock conservation by 
    adapting to the game's state and history. It prioritizes cooperation when the 
    stock level is high, adjusts its strategy based on observed depletion rates, and 
    defects in emergency situations to maximize individual payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_depletion_rate = 0
        self.mid_game_adjustment = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        if not self.mid_game_adjustment and state.round_number >= self.game_description.n_rounds // 2:
            self.stock_depletion_rate = (self.game_description.capacity - state.current_stock) / (state.round_number + 1)
            if self.stock_depletion_rate > 0.25 * self.game_description.capacity:
                self.mid_game_adjustment = True
                return Action.D
        if state.round_number >= 3 * self.game_description.n_rounds // 4 and state.current_stock > 0.5 * self.game_description.capacity:
            return Action.C
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_490(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if state.round_number == 0:
            return Action.C if current_stock >= 0.75 * capacity else Action.D
        avg_opponent_coop_rate = self.calculate_avg_opponent_coop_rate(history)
        if avg_opponent_coop_rate > 0.5:
            return Action.C if current_stock >= 0.67 * capacity else Action.D
        else:
            return Action.D
        return Action.D

    def calculate_avg_opponent_coop_rate(self, history: PlayerHistory) -> float:
        opponent_actions = history.opponent_actions[-1, :]
        cooperators = sum(opponent_actions)
        return cooperators / (self.game_description.n_players - 1)

class Strategy_COLLECTIVE_491(BaseStrategy):
    """
    A strategy that balances individual payoffs with collective sustainability by adapting to the current stock level and opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_health_threshold = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_health = state.current_stock / self.game_description.capacity
        if history is not None and len(history.opponent_actions) > 0:
            opponent_cooperations = sum((1 for action in history.opponent_actions[-1, :] if action))
            if opponent_cooperations >= self.game_description.n_players * 0.6:
                self.stock_health_threshold *= 1.1
            elif opponent_cooperations <= self.game_description.n_players * 0.4:
                self.stock_health_threshold *= 0.9
        if state.current_stock < self.game_description.capacity * 0.2:
            return Action.D if random.random() > 0.8 else Action.C
        if stock_health >= self.stock_health_threshold:
            return Action.D
        elif stock_health < 0.4:
            defect_prob = 1 - stock_health / 0.4
            return Action.D if random.random() < defect_prob else Action.C
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C

class Strategy_COLLECTIVE_492(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with the sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        safety_threshold = 0.5 * self.capacity / self.n_players
        opponent_cooperation_rate = np.mean(history.opponent_actions[-1, :])
        if opponent_cooperation_rate > 0.5:
            safety_threshold -= 0.05 * self.capacity / self.n_players
        else:
            safety_threshold += 0.1 * self.capacity / self.n_players
        if state.current_stock < 0.1 * self.capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock >= safety_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_493(BaseStrategy):
    """
    A collective strategy that aims to balance individual payoffs with collective sustainability 
    by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock >= self.game_description.capacity / 2 else Action.D
        avg_prev_payoff = np.mean(history.my_payoffs)
        avg_c_payoff = state.current_stock / (2 * self.game_description.n_players)
        if state.round_number == self.game_description.n_rounds - 1:
            return self.last_round_behavior(state, history)
        if avg_prev_payoff >= avg_c_payoff or state.current_stock <= self.game_description.capacity / 4:
            return Action.C
        return Action.D

    def last_round_behavior(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        opponent_defections = np.sum(~history.opponent_actions)
        return Action.D if state.current_stock >= self.game_description.capacity / 2 and opponent_defections == self.game_description.n_players - 1 else Action.C

class Strategy_COLLECTIVE_494(BaseStrategy):
    """
    A strategy that balances individual gain with collective conservation.
    It adapts to the game state and opponents' behavior using an adaptive window approach.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if state.round_number >= self.game_description.n_rounds - 1:
            return Action.D
        if current_stock <= 0:
            return Action.C
        if current_stock > 0.5 * capacity:
            return Action.C
        elif current_stock <= 0.2 * capacity:
            return Action.D
        elif history is not None and len(history.my_payoffs) >= state.round_number - 1:
            avg_payoff = np.mean([payoff for payoff in history.my_payoffs[:state.round_number]])
            if avg_payoff > current_stock / (2 * n_players):
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_495(BaseStrategy):
    """
    Adaptive Cooperative Conservation strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        cooperation_threshold = self.calculate_cooperation_threshold(current_stock)
        if history is not None:
            opponent_cooperators = sum(history.opponent_actions[-1, :])
            my_last_action = history.my_actions[-1]
        else:
            opponent_cooperators = 0
            my_last_action = False
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if current_stock < 0.1 * self.capacity and state.round_number != self.game_description.n_rounds - 1:
            return Action.C
        if current_stock < 0.25 * self.capacity:
            return Action.D
        if current_stock >= self.capacity:
            return Action.C if random.random() < 0.8 else Action.D
        probability_defect = 1 - current_stock / self.capacity
        if opponent_cooperators >= cooperation_threshold:
            return Action.C
        elif random.random() < probability_defect:
            return Action.D
        else:
            return Action.C

    def calculate_cooperation_threshold(self, current_stock):
        """
        Calculate the cooperation threshold based on the current stock level.
        """
        if current_stock > 0.5 * self.capacity:
            return 0.5 * self.n_players
        else:
            return self.n_players - current_stock / (2 * self.capacity)

class Strategy_COLLECTIVE_496(BaseStrategy):
    """
    The Adaptive Cooperation strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        dr = (self.game_description.capacity - state.current_stock) / self.game_description.capacity
        theta = self.get_threshold(state.round_number)
        if dr < theta:
            return Action.C
        elif self.is_opponent_likely_to_defect(history):
            return Action.D
        else:
            coop_rate = self.get_cooperation_rate(history)
            return Action.C if random.random() < coop_rate else Action.D

    def get_threshold(self, round_number: int) -> float:
        """
        Returns the threshold value for the given round number.
        """
        if round_number <= 5:
            return 0.4
        elif round_number <= 10:
            return 0.35
        else:
            return 0.3

    def is_opponent_likely_to_defect(self, history: PlayerHistory) -> bool:
        """
        Returns True if the opponent is likely to defect based on their past behavior.
        """
        last_5_rounds = history.opponent_actions[-5:, :]
        defect_rate = np.mean(last_5_rounds)
        return defect_rate > 0.5

    def get_cooperation_rate(self, history: PlayerHistory) -> float:
        """
        Returns the cooperation rate based on the opponent's past behavior.
        """
        last_5_rounds = history.opponent_actions[-5:, :]
        coop_rate = 0.5
        if np.mean(last_5_rounds) > 0.8:
            coop_rate += 0.1
        elif np.mean(last_5_rounds) < 0.2:
            coop_rate -= 0.1
        return coop_rate

    def last_round(self, state: CommonPoolState) -> bool:
        """
        Returns True if it's the last round.
        """
        return state.round_number == self.game_description.n_rounds - 1

    def low_stock_levels(self, state: CommonPoolState) -> bool:
        """
        Returns True if the stock levels are low.
        """
        return state.current_stock < self.game_description.capacity / 4

class Strategy_COLLECTIVE_497(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors.
    It balances individual payoffs with collective conservation of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        threshold = self.game_description.capacity / (2 * self.game_description.n_players)
        if state.current_stock >= threshold:
            return Action.C
        prev_defectors = sum((1 for action in history.opponent_actions[-1, :] if not action))
        defect_prob = prev_defectors / self.game_description.n_players
        return Action.D if random.random() < defect_prob else Action.C

class Strategy_COLLECTIVE_498(BaseStrategy):
    """
    The ACH strategy aims to balance individual payoffs with collective sustainability by adapting to the game's dynamic state and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        opponent_defections = np.sum(history.opponent_actions[-1, :] == False)
        if opponent_defections > 0 and random.random() < 0.5:
            return Action.D
        if state.round_number >= math.ceil(0.75 * self.game_description.n_rounds):
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_499(BaseStrategy):
    """
    Adaptive Harvesting strategy for the Common Pool Resource Game.
    
    This strategy aims to balance individual payoffs with collective sustainability by cooperating initially, 
    responding to opponent actions, and adapting to changes in the stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.1 * self.capacity:
            return Action.D
        if state.current_stock > 0.8 * self.capacity:
            return Action.C
        elif state.current_stock < 0.2 * self.capacity:
            return Action.D
        total_consumption = np.sum(history.opponent_actions[-1, :] == False) / self.n_players * (state.current_stock / self.n_players)
        avg_consumption = total_consumption + state.current_stock / (2 * self.n_players)
        if avg_consumption > state.current_stock / (2 * self.n_players):
            return Action.D
        else:
            return Action.C
        majority_defected = np.sum(history.opponent_actions[-1, :] == False) > 0.5 * self.n_players
        if majority_defected:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_500(BaseStrategy):
    """
    A strategy that balances individual payoffs with collective sustainability by adapting to changing game conditions and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio > 0.75:
            return Action.C
        elif stock_ratio >= 0.5:
            num_defectors_prev_round = sum((1 for action in history.opponent_actions[-1, :] if not action))
            prob_defect = num_defectors_prev_round / self.game_description.n_players
            return Action.D if random.random() < prob_defect else Action.C
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_501(BaseStrategy):
    """
    Adaptive Stock Preservation strategy for the Common Pool Resource Game.
    
    This strategy prioritizes cooperation when the stock level is high and adjusts its behavior based on the previous round's outcome.
    By doing so, it aims to maintain a sustainable stock level, benefiting all players in the long run.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.75 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock <= 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock >= self.cooperation_threshold:
            return Action.C
        elif state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        else:
            p = (state.current_stock / self.game_description.capacity) ** 2
            return Action.C if random.random() < p else Action.D
        prev_consumption = sum(history.opponent_actions[-1, :]) + history.my_actions[-1]
        if prev_consumption > self.game_description.capacity / 2:
            self.cooperation_threshold -= 0.1 * self.game_description.capacity
        elif prev_consumption < self.game_description.capacity / 4:
            self.cooperation_threshold += 0.1 * self.game_description.capacity

class Strategy_COLLECTIVE_502(BaseStrategy):
    """
    Adaptive Cooperative Management strategy for the Common Pool Resource Game.
    This strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.p = 0.5

    def calculate_p(self, avg_coop_payoff, avg_game_payoff):
        if avg_coop_payoff > avg_game_payoff:
            return min(self.p + 0.1, 1)
        else:
            return max(self.p - 0.1, 0)

    def calculate_avg_cooperator_payoff(self, history):
        cooperators = np.where(history.my_actions)[0]
        if len(cooperators) == 0:
            return 0
        return np.mean(history.my_payoffs[cooperators])

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.p = 0.5
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        avg_coop_payoff = self.calculate_avg_cooperator_payoff(history)
        avg_game_payoff = np.mean(np.concatenate([history.my_payoffs, history.opponent_payoffs.flatten()]))
        self.p = self.calculate_p(avg_coop_payoff, avg_game_payoff)
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        elif 0.5 * self.game_description.capacity <= state.current_stock < 0.75 * self.game_description.capacity:
            return Action.C if random.random() < self.p else Action.D
        elif state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_503(BaseStrategy):
    """
    Adaptive Cooperation with Dynamic Threshold (ACDT) strategy.
    
    This collective strategy balances individual payoffs with long-term sustainability 
    of the common resource, adapting to game state and history using a dynamic threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.capacity = game_description.capacity
        self.k = 3
        self.theta = 0.7
        self.delta = 0.05

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_payoffs = history.my_payoffs
        opponent_actions = history.opponent_actions
        avg_payoff = np.mean(my_payoffs[-self.k:])
        if state.current_stock < self.capacity * 0.5:
            self.theta += self.delta
        elif state.current_stock > self.capacity * 0.75:
            self.theta -= self.delta
        if avg_payoff >= self.theta or (state.round_number == 1 and history.my_actions[-1]):
            action = Action.C
        else:
            action = Action.D
        if np.all(opponent_actions[-self.k:, :]) and my_payoffs[-1] < avg_payoff:
            action = Action.D
        if not history.my_actions[-1] and (avg_payoff >= self.theta or state.current_stock < self.capacity * 0.25):
            action = Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        return action

class Strategy_COLLECTIVE_504(BaseStrategy):
    """
    Adaptive Tit-for-Two-Tats with Stock Conservation (ATTC) strategy.

    This strategy prioritizes cooperation when the stock is healthy, while adapting to the opponents' behavior when the stock is being depleted.
    By mirroring the opponents' actions with a tit-for-tat approach, we encourage cooperation while maintaining a balance between individual payoffs and collective conservation of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        if stock_level > 0.75:
            most_cooperated = sum(history.opponent_actions[-1, :]) > self.game_description.n_players // 2
            return Action.C if most_cooperated else Action.D
        elif 0.25 <= stock_level <= 0.75:
            opponent_action = history.opponent_actions[-1, :]
            if sum(opponent_action) == self.game_description.n_players // 2:
                payoffs = history.opponent_payoffs[-1, :]
                max_payoff_idx = np.argmax(payoffs)
                return Action.C if opponent_action[max_payoff_idx] else Action.D
            return Action.C if sum(opponent_action) > self.game_description.n_players // 2 else Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_505(BaseStrategy):
    """
    Collective strategy that balances individual payoffs with collective sustainability.
    Adapts to the game's state and history, prioritizing cooperation when stock is high and defecting when it's low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_ratio = state.current_stock / self.capacity
        if stock_ratio >= 0.9:
            return Action.C
        elif stock_ratio <= 0.1:
            return Action.D
        elif stock_ratio >= 0.75:
            return Action.C
        elif stock_ratio <= 0.5:
            return Action.D
        elif random.random() < 0.5:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_506(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Conservation (ASC)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_conservation_threshold = 0.5 * game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        opponent_actions = history.opponent_actions[-1, :] if isinstance(history, PlayerHistory) else [False] * self.game_description.n_players
        if current_stock > self.stock_conservation_threshold:
            action = Action.C
        elif current_stock <= self.stock_conservation_threshold:
            opponents_cooperated = sum(opponent_actions)
            if opponents_cooperated > 0.5 * self.game_description.n_players:
                action = Action.C
            else:
                action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        elif current_stock < 0.25 * self.game_description.capacity / self.game_description.n_players:
            action = Action.D
        return action

class Strategy_COLLECTIVE_507(BaseStrategy):
    """
    A strategy that balances individual self-interest with collective responsibility to conserve the common pool resource.
    It adapts to changing game conditions and opponent behaviors while promoting cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        if history is not None and any((not action for action in history.opponent_actions[-1, :])):
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_508(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Conservation (ASC)
    
    The ASC strategy aims to balance individual payoffs with collective sustainability, 
    ensuring a stable and resilient common pool resource over multiple rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if state.round_number == 0 or state.round_number < self.game_description.n_rounds - 2:
            if state.current_stock < 0.5 * capacity:
                return Action.D
            elif history is not None and sum(history.opponent_actions[-1, :]) >= 0.5 * n_players and (state.current_stock > 0.25 * capacity):
                return Action.C
            else:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 2 or state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_509(BaseStrategy):
    """
    Adaptive Stock Sensitive Tit-for-Tat (ASST) strategy for the Common Pool Resource Game.
    This strategy balances individual self-interest with collective sustainability by adapting behavior based on stock levels and opponent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.alpha = game_description.capacity / 2
        self.beta = 3 / 4 * game_description.capacity
        self.theta = game_description.capacity / (4 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_payoff = np.mean(history.my_payoffs[-1])
        if avg_payoff > self.theta:
            return Action.C
        if state.current_stock < self.alpha:
            return Action.D
        elif self.alpha <= state.current_stock <= self.beta:
            p = (state.current_stock - self.alpha) / (self.beta - self.alpha)
            return Action.C if random.random() < p else Action.D
        else:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        cooperators = sum(opponent_actions == 1)
        if cooperators >= len(opponent_actions) / 2:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_510(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy balances individual payoffs with collective sustainability by adaptively responding to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.low_threshold = game_description.capacity / 4
        self.high_threshold = game_description.capacity * 3 / 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock == 0:
            return Action.D
        if state.current_stock > self.high_threshold:
            return Action.C
        elif state.current_stock < self.low_threshold:
            return Action.D
        else:
            trend = self.analyze_trend(history.my_payoffs[-3:])
            if trend == 'Increasing' or trend == 'Stable':
                return Action.C
            else:
                return Action.D

    def analyze_trend(self, payoffs):
        if len(payoffs) < 3:
            return 'Unknown'
        trend = []
        for i in range(1, len(payoffs)):
            if payoffs[i] > payoffs[i - 1]:
                trend.append('Increasing')
            elif payoffs[i] == payoffs[i - 1]:
                trend.append('Stable')
            else:
                trend.append('Decreasing')
        if 'Increasing' in trend and 'Decreasing' not in trend:
            return 'Increasing'
        elif 'Decreasing' in trend and 'Increasing' not in trend:
            return 'Decreasing'
        else:
            return 'Stable'

class Strategy_COLLECTIVE_511(BaseStrategy):
    """
    An adaptive strategy that prioritizes cooperation while responding to changes in opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.ACR_history = []
        self.CT_history = []
        self.defection_response = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.stock_history.append(state.current_stock)
        if state.round_number < self.game_description.n_rounds // 2:
            opponent_actions = np.any(history.opponent_actions, axis=0) == False
            ACR = np.mean(opponent_actions[-1])
            CT = 0.5 + (self.game_description.capacity - state.current_stock) / (2 * self.game_description.capacity)
            self.ACR_history.append(ACR)
            self.CT_history.append(CT)
            if ACR >= CT:
                return Action.C
            else:
                return Action.D
        elif state.round_number < self.game_description.n_rounds * 3 // 4:
            if not self.defection_response:
                opponent_actions = np.any(history.opponent_actions, axis=0) == False
                ACR = np.mean(opponent_actions[-1])
                CT = 0.5 + (self.game_description.capacity - state.current_stock) / (2 * self.game_description.capacity)
                if ACR < CT:
                    self.defection_response = True
                    return Action.D
            else:
                opponent_actions = np.any(history.opponent_actions, axis=0) == False
                ACR = np.mean(opponent_actions[-1])
                if ACR >= 0.5:
                    self.defection_response = False
            return Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_512(BaseStrategy):
    """
    Collective Strategy: Adaptive Common Pool Management (ACPM)
    Balances individual self-interest with the need to maintain a sustainable common pool resource.
    Adapts to game state, history, and opponent behavior while prioritizing cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.my_actions) > 1:
            opponent_cooperation_rate = np.mean(np.sum(history.opponent_actions, axis=1) / self.game_description.n_players)
        else:
            opponent_cooperation_rate = 0.5
        stock_threshold_high = 0.75 * self.game_description.capacity
        stock_threshold_low = 0.25 * self.game_description.capacity
        if state.current_stock >= stock_threshold_high:
            return Action.C
        elif state.current_stock < stock_threshold_low:
            return Action.D
        elif opponent_cooperation_rate > 0.5:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_1(BaseStrategy):
    """
    A hybrid strategy that combines elements of Tit-for-Tat with a novel, 
    adaptive component. This strategy will be called "Adaptive TFT with Stock-Dependent Forgiveness" (ATTF).
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.game_description.capacity / (4 * self.game_description.n_players):
            return Action.D
        opponent_previous_actions = history.opponent_actions[-1, :]
        p_mirror = 0.7
        if random.random() < p_mirror:
            return Action.C if np.any(opponent_previous_actions) else Action.D
        else:
            stock_threshold = self.game_description.capacity / (2 * self.game_description.n_players)
            return Action.C if state.current_stock > stock_threshold else Action.D

class Strategy_EXPLOITATIVE_2(BaseStrategy):
    """
    Exploitative strategy adapting to opponents' behavior while maximizing personal payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_percentage = state.current_stock / self.game_description.capacity * 100
        if stock_percentage > 75:
            threshold = 0.5
        elif 50 <= stock_percentage <= 75:
            threshold = 0.3
        else:
            threshold = 0.1
        avg_coop_rate = np.mean(history.opponent_actions[-min(5, self.game_description.n_rounds):, :])
        if avg_coop_rate < threshold and stock_percentage > 25 or history.opponent_actions[-1, 0] == False:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock_percentage < 25:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_3(BaseStrategy):
    """
    An exploitative strategy that adapts to the game's state and history,
    aiming to maximize payoffs while being robust against various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.r = game_description.n_rounds
        self.k = self.r // 10
        self.avg_payoff_C = 0.0
        self.avg_payoff_D = 0.0
        self.last_k_payoffs = {'C': [], 'D': []}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        action = None
        if state.round_number < self.r - 1:
            if current_stock >= 0.5 * self.capacity:
                action = Action.C
            else:
                action = Action.D
        else:
            action = Action.D
        if history is not None:
            last_round_payoff = history.my_payoffs[-1]
            if history.my_actions[-1]:
                self.last_k_payoffs['C'].append(last_round_payoff)
            else:
                self.last_k_payoffs['D'].append(last_round_payoff)
            if len(self.last_k_payoffs['C']) > self.k:
                self.last_k_payoffs['C'] = self.last_k_payoffs['C'][1:]
            if len(self.last_k_payoffs['D']) > self.k:
                self.last_k_payoffs['D'] = self.last_k_payoffs['D'][1:]
            self.avg_payoff_C = np.mean(self.last_k_payoffs['C'])
            self.avg_payoff_D = np.mean(self.last_k_payoffs['D'])
            if state.round_number >= self.k and self.avg_payoff_D > self.avg_payoff_C:
                action = Action.D
            elif state.round_number >= self.k and self.avg_payoff_C > self.avg_payoff_D:
                action = Action.C
        return action

class Strategy_EXPLOITATIVE_4(BaseStrategy):
    """
    Adaptive Stock Hawk strategy.

    This strategy aims to maximize individual payoffs by adapting to changing stock levels and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        cooperation_rate = np.mean(opponent_actions)
        stock_level_ratio = state.current_stock / self.game_description.capacity
        if stock_level_ratio > 0.75:
            cooperate_prob = cooperation_rate
            return Action.C if random.random() < cooperate_prob else Action.D
        elif 0.25 <= stock_level_ratio <= 0.75:
            if cooperation_rate > 0.5:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_5(BaseStrategy):
    """
    A robust and exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if self.game_description.n_players <= 5 else Action.D
        prev_consumption = sum(history.opponent_payoffs[-1, :]) + history.my_payoffs[-1]
        avg_payoff_prev = prev_consumption / self.game_description.n_players
        max_payoff = state.current_stock / (2 * self.game_description.n_players)
        if avg_payoff_prev > 0.75 * max_payoff:
            return Action.D
        elif avg_payoff_prev < 0.25 * max_payoff and state.current_stock > 0.5 * self.game_description.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.1 * self.game_description.capacity:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_6(BaseStrategy):
    """
    Adaptive Exploiter Strategy: 
    Cooperate in initial round, then adaptively exploit based on current stock level.
    Prioritize exploiting frequent defectors or those with higher past payoffs.
    Defect in last round to maximize final payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.past_stock_levels = []
        self.opponent_cooperation_rates = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.past_stock_levels.append(state.current_stock)
        if history is not None:
            self.opponent_cooperation_rates = [sum(opponent_actions) / len(opponent_actions) for opponent_actions in history.opponent_actions.T]
        stock_percentage = state.current_stock / self.game_description.capacity
        if stock_percentage > 0.75:
            return Action.D
        elif 0.25 <= stock_percentage <= 0.75:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_7(BaseStrategy):
    """
    Exploitative strategy "Adaptive Stock Hawk" that aims to maximize individual payoffs by adaptively responding to the game state and history of opponent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_cooperations = 0
        self.opponents_defected = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock >= 0.75 * capacity:
            return Action.D
        elif current_stock <= 0.25 * capacity:
            return Action.C
        else:
            p = (current_stock / capacity) ** 2
            if history.opponent_actions[-1, :].sum() > 0 and (not self.opponents_defected):
                self.opponents_defected = True
                p *= 0.5
            if history.my_payoffs.size >= 2 and history.my_payoffs[-1] > history.my_payoffs[-2]:
                self.consecutive_cooperations += 1
                p += 0.1
            else:
                self.consecutive_cooperations = 0
            return Action.C if random.random() < p else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_8(BaseStrategy):
    """
    The Adaptive Stock Raider (ASR) strategy is designed to maximize individual payoffs by adapting to the game's state and history, while exploiting opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        S = state.current_stock
        capacity = self.game_description.capacity
        if S / capacity >= 0.5:
            return Action.D
        else:
            return Action.C
        if history is not None and len(history.my_actions) > 1:
            prev_round_opponent_actions = history.opponent_actions[-2, :]
            defectors = sum((1 for action in prev_round_opponent_actions if action == False))
            if defectors >= self.game_description.n_players / 2:
                return Action.D
            else:
                return Action.C
        if S / capacity < 0.25 and len(history.my_actions) > 1:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if S < self.game_description.n_players and len(history.my_actions) > 1:
            return Action.C

class Strategy_EXPLOITATIVE_9(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behaviors and the current stock level.
    Cooperates initially, then defects or cooperates based on the stock level and opponent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        high_stock_threshold = 0.75 * self.game_description.capacity
        mid_stock_threshold_high = 0.75 * self.game_description.capacity
        mid_stock_threshold_low = 0.25 * self.game_description.capacity
        low_stock_threshold = 0.1 * self.game_description.capacity
        if state.round_number < self.game_description.n_rounds // 2:
            if state.current_stock > high_stock_threshold:
                return Action.D
            elif state.current_stock >= mid_stock_threshold_low and state.current_stock <= mid_stock_threshold_high:
                return Action.C
            else:
                return Action.D
        elif state.round_number >= self.game_description.n_rounds // 2 and state.round_number <= 3 * self.game_description.n_rounds // 4:
            if history is not None:
                opponent_cooperators = sum(history.opponent_actions[-1, :])
                if opponent_cooperators >= self.game_description.n_players // 2:
                    return Action.D
                else:
                    return Action.C
        elif state.round_number > 3 * self.game_description.n_rounds // 4:
            if state.current_stock > mid_stock_threshold_high / 2:
                return Action.D
            else:
                return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < low_stock_threshold:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_10(BaseStrategy):
    """
    Exploitative strategy that adaptively responds to the current stock level and observed opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.D
        current_stock = state.current_stock
        stock_threshold = self.capacity / 2 + self.n_players * current_stock / (2 * self.n_players)
        if current_stock > stock_threshold:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        total_consumption_threshold = self.capacity / 2
        for opponent_action in opponent_actions:
            if not opponent_action or np.sum(~opponent_actions) * current_stock / self.n_players > total_consumption_threshold:
                return Action.D
        previous_growth = current_stock - history.my_payoffs[-1] * self.n_players
        growth_threshold = 0.5 * self.capacity
        if previous_growth > growth_threshold:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_11(BaseStrategy):
    """
    An exploitative strategy that adapts to the game's state and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.D
        current_stock = state.current_stock
        high_stock_threshold = 0.75 * self.capacity
        medium_stock_threshold = 0.25 * self.capacity
        if current_stock > high_stock_threshold:
            action = Action.C
        elif current_stock >= medium_stock_threshold:
            action = Action.D
        else:
            action = Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        opponent_cooperation_rate = np.mean(history.opponent_actions[-1, :])
        if opponent_cooperation_rate > 0.5:
            action = Action.D if random.random() < opponent_cooperation_rate - 0.5 else action
        elif opponent_cooperation_rate < 0.5:
            action = Action.C if random.random() < 0.5 - opponent_cooperation_rate else action
        return action

class Strategy_EXPLOITATIVE_12(BaseStrategy):
    """
    Exploitative strategy that adapts to the game's dynamic state and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock >= 0.75 * self.game_description.capacity else Action.D
        previous_stock = history.my_payoffs[-1] * 2 * self.game_description.n_players
        sdr = (previous_stock - state.current_stock) / previous_stock if previous_stock != 0 else 0
        opponent_cooperated_last_round = np.any(history.opponent_actions[-1, :])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        return Action.C if sdr < 0.25 and opponent_cooperated_last_round else Action.D

class Strategy_EXPLOITATIVE_13(BaseStrategy):
    """
    The Adaptive Stock Predator strategy is designed to be exploitative, 
    adapting to the current state of the stock and the actions taken by other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_actions = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.opponent_actions is None or len(self.opponent_actions) < state.round_number - 1:
            self.opponent_actions = history.opponent_actions[:-1]
        else:
            self.opponent_actions = np.vstack((self.opponent_actions, history.opponent_actions[-2]))
        AO_rate = np.mean(self.opponent_actions) if state.round_number > 1 else 0
        capacity = self.game_description.capacity
        if state.current_stock >= 0.75 * capacity:
            return Action.D
        elif state.current_stock >= 0.5 * capacity and state.current_stock < 0.75 * capacity:
            if AO_rate > 0.5:
                return Action.C
            else:
                return Action.D
        elif state.current_stock < 0.5 * capacity:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_14(BaseStrategy):
    """
    Adaptive Stock Exploiter strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_threshold = 0.5
        self.prev_round_defectors = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_defected = sum((1 - action for action in history.opponent_actions[-1, :]))
        n_opponents = self.game_description.n_players - 1
        if history is not None:
            prev_payoff = history.my_payoffs[-1]
            max_payoff = state.current_stock / (2 * self.game_description.n_players)
            if prev_payoff < 0.75 * max_payoff:
                self.defection_threshold -= 0.05
            elif prev_payoff > 0.75 * max_payoff:
                self.defection_threshold += 0.05
        if state.round_number == self.game_description.n_rounds - 1 or state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        if opponents_defected < self.defection_threshold * n_opponents:
            action = Action.C
        else:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_15(BaseStrategy):
    """
    An exploitative strategy that adapts to opponents' behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.defection_likelihood = 0.5
        self.cooperation_likelihood = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperation_rate = self.calculate_opponent_cooperation_rate(history)
        sma_window = 3
        sma = self.calculate_sma(state.current_stock, history.my_payoffs, sma_window)
        sma_trend = self.sma_trend_is_increasing(sma, state.round_number)
        if state.current_stock > 0.9 * self.capacity:
            return Action.D
        elif state.current_stock < 0.1 * self.capacity:
            return Action.C
        if state.current_stock > 0.75 * self.capacity:
            self.defection_likelihood = min(1, self.defection_likelihood + 0.05)
            self.cooperation_likelihood = max(0, self.cooperation_likelihood - 0.05)
            return random.choices([Action.D, Action.C], weights=[self.defection_likelihood, self.cooperation_likelihood])[0]
        elif state.current_stock >= 0.5 * self.capacity and state.current_stock <= 0.75 * self.capacity:
            if sma_trend or opponent_cooperation_rate > 0.5:
                self.cooperation_likelihood = min(1, self.cooperation_likelihood + 0.05)
                self.defection_likelihood = max(0, self.defection_likelihood - 0.05)
            return random.choices([Action.D, Action.C], weights=[self.defection_likelihood, self.cooperation_likelihood])[0]
        else:
            if sma_trend or opponent_cooperation_rate > 0.5:
                self.cooperation_likelihood = min(1, self.cooperation_likelihood + 0.05)
                self.defection_likelihood = max(0, self.defection_likelihood - 0.05)
            return random.choices([Action.D, Action.C], weights=[self.defection_likelihood, self.cooperation_likelihood])[0]
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

    def calculate_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        opponent_actions = history.opponent_actions
        total_cooperations = np.sum(opponent_actions)
        return total_cooperations / (opponent_actions.shape[0] * opponent_actions.shape[1])

    def calculate_sma(self, stock_level: float, my_payoffs: NDArray[np.float64], window_size: int) -> float:
        if len(my_payoffs) < window_size:
            return np.mean(my_payoffs)
        else:
            return np.mean(my_payoffs[-window_size:])

    def sma_trend_is_increasing(self, sma: float, round_number: int) -> bool:
        return sma > self.calculate_sma(sma, [0], 1)

class Strategy_EXPLOITATIVE_16(BaseStrategy):
    """
    An exploitative strategy that adapts to the current stock level and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D]) if random.random() < 0.5 else Action.C
        stock_level = state.current_stock / self.capacity
        opponents_defected_prev_round = sum(1 - history.opponent_actions[-1, :])
        if stock_level > 0.75:
            return Action.D
        elif 0.5 <= stock_level <= 0.75:
            prob_coop = 1 - opponents_defected_prev_round / self.n_players
            return random.choice([Action.C, Action.D]) if random.random() < prob_coop else Action.C
        else:
            return Action.C
        if opponents_defected_prev_round > self.n_players / 2:
            pass
        stock_growth = state.current_stock - history.my_payoffs[-1] * self.game_description.n_players
        if stock_growth > 0.1 * self.capacity:
            return random.choice([Action.C, Action.D]) if random.random() < 0.7 else Action.C
        if state.round_number >= self.game_description.n_rounds - 2 and stock_level > 0.25:
            return Action.D

class Strategy_EXPLOITATIVE_17(BaseStrategy):
    """
    A dynamic decision-making approach that balances short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def calculate_cq(self, history: PlayerHistory) -> float:
        """
        Calculate the "Cooperation Quotient" (CQ): average cooperation rate of all opponents except yourself.
        """
        opponent_actions = history.opponent_actions[-3:, :]
        return np.mean(opponent_actions)

    def most_players_defected(self, history: PlayerHistory) -> bool:
        """
        Check if most players (>50%) defected in the previous round.
        """
        prev_round_opponents = history.opponent_actions[-1, :]
        return sum(1 - prev_round_opponents) > self.game_description.n_players // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number <= 5:
            if self.most_players_defected(history):
                return Action.D
            else:
                return Action.C
        else:
            cooperation_quotient = self.calculate_cq(history)
            capacity_half = self.game_description.capacity / 2
            current_stock = state.current_stock
            if cooperation_quotient > 0.6:
                return Action.C
            elif cooperation_quotient < 0.4:
                return Action.D
            elif random.random() < 0.7 and current_stock >= capacity_half:
                return Action.C
            else:
                return Action.D
        if state.round_number > self.game_description.n_rounds - 3:
            if current_stock < capacity_half:
                return Action.D
            else:
                return Action.C
        elif state.round_number == self.game_description.n_rounds:
            return Action.D
        elif current_stock < self.game_description.capacity / 4:
            return Action.C

class Strategy_EXPLOITATIVE_18(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game.

    This strategy initially cooperates to observe opponents' behavior and then adapts by defecting against weak or cooperative players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_consumption_history = []
        self.opponent_payoff_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.opponent_payoff_history.append(history.opponent_payoffs)
            total_consumption = np.sum(self.game_description.n_players / (2 * self.game_description.n_players)) if history.my_actions[-1] else np.sum(self.game_description.n_players / self.game_description.n_players)
            for opponent_action in history.opponent_actions[-1, :]:
                total_consumption += self.game_description.n_players / self.game_description.n_players if not opponent_action else self.game_description.n_players / (2 * self.game_description.n_players)
            self.total_consumption_history.append(total_consumption)
        if len(self.total_consumption_history) > 0:
            total_consumption_prev = self.total_consumption_history[-1]
            if total_consumption_prev <= self.game_description.capacity / 2 or state.current_stock < 0.25 * self.game_description.capacity:
                return Action.C
        if len(self.opponent_payoff_history) > 3:
            recent_opponent_payoffs = np.mean(self.opponent_payoff_history[-3:], axis=0)
            average_payoff = np.mean(recent_opponent_payoffs)
            weak_opponents = np.where(recent_opponent_payoffs < average_payoff)[0]
            if len(weak_opponents) > 0:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1 or (len(self.total_consumption_history) > 0 and self.total_consumption_history[-1] > self.game_description.capacity / 2):
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_19(BaseStrategy):
    """
    An adaptive exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number < 6:
            if state.current_stock > 0.75 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C
        else:
            opponents_coop_count = np.sum(history.opponent_actions[-3:, :], axis=0)
            avg_coop_rate = np.mean(opponents_coop_count / 3)
            if avg_coop_rate < 0.5:
                return Action.D
            else:
                return Action.C
        if state.round_number >= self.game_description.n_rounds - 2 and state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C

class Strategy_EXPLOITATIVE_20(BaseStrategy):
    """
    Adaptive Exploiter (AE) strategy for the Common Pool Resource Game.
    
    This strategy balances exploitation with adaptability, responding to changes in the game state and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_behaviors = []
        self.cooperator_threshold = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        opponents_cooperation_rate = np.mean(history.opponent_actions[-1, :])
        for opponent in self.opponent_behaviors:
            if opponent['cooperation_rate'] > self.cooperator_threshold:
                return Action.D
        if state.round_number < self.game_description.n_rounds - 1:
            if stock_level > 0.75:
                action = Action.D
            elif 0.5 <= stock_level <= 0.75:
                action = random.choice([Action.C, Action.D])
            else:
                action = Action.D
            if np.mean(history.opponent_actions[-1, :]) > self.cooperator_threshold and history.my_payoffs.shape[0] >= 5:
                if np.mean(history.opponent_payoffs[-5:, :].sum(axis=1)) / (self.game_description.n_players - 1) > state.current_stock * 0.75 / self.game_description.capacity:
                    action = Action.C
        else:
            action = Action.D
        opponents_cooperation_rate_history = np.mean(history.opponent_actions, axis=0)
        for i, cooperation_rate in enumerate(opponents_cooperation_rate_history):
            self.opponent_behaviors.append({'cooperation_rate': cooperation_rate})
        return action

class Strategy_EXPLOITATIVE_21(BaseStrategy):
    """
    Exploitative strategy that adapts to game state and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.75 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_defections = sum((1 - action for action in history.opponent_actions[-1, :]))
        recent_payoffs = history.my_payoffs[-3:]
        if state.current_stock > self.stock_threshold:
            return Action.D
        elif state.current_stock <= self.stock_threshold:
            return Action.C
        if opponent_defections > self.game_description.n_players / 2:
            return Action.D
        else:
            return Action.C
        if len(recent_payoffs) >= 3 and recent_payoffs[-1] < recent_payoffs[-2]:
            last_action = history.my_actions[-1]
            return Action.D if last_action else Action.C
        return Action.C

    def opposite_action(self, action: Action):
        return Action.D if action == Action.C else Action.C

class Strategy_EXPLOITATIVE_22(BaseStrategy):
    """
    Adaptive Exploitation with Stock Awareness strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defect_rate = None
        self.self_payoffs = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.defect_rate = np.sum(history.opponent_actions, axis=0) / state.round_number
        habitual_defectors = np.where(self.defect_rate > 0.5)[0]
        average_opponent_payoffs = np.mean(np.sum(history.opponent_payoffs, axis=0))
        if len(self.self_payoffs) >= 3 and all((p < average_opponent_payoffs for p in self.self_payoffs[-3:])):
            return Action.D
        if state.current_stock > self.game_description.capacity / 2:
            if len(habitual_defectors) == 0:
                action = Action.D
            else:
                action = Action.C
        elif state.current_stock <= self.game_description.capacity / 2:
            if len(habitual_defectors) > 0:
                action = Action.C
            else:
                action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if history is not None and len(history.my_payoffs) > 0:
            self.self_payoffs.append(history.my_payoffs[-1])
        return action

class Strategy_EXPLOITATIVE_23(BaseStrategy):
    """
    Adaptive Stock-Dependent Defection strategy for the Common Pool Resource Game.
    
    This strategy adapts to the game's state and opponents' behaviors, balancing short-term gains with potential long-term benefits from cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        prev_cooperators = sum(history.opponent_actions[-1, :])
        if state.round_number == 1:
            return Action.C
        if state.current_stock < self.game_description.capacity / 2:
            return Action.D
        elif prev_cooperators < self.game_description.n_players // 2:
            return Action.D
        elif prev_cooperators >= self.game_description.n_players // 2:
            p = (state.current_stock - self.game_description.capacity / 2) / (self.game_description.capacity / 2)
            if random.random() < p and state.round_number != self.game_description.n_rounds - 1:
                return Action.C
            else:
                return Action.D
        elif prev_cooperators == self.game_description.n_players // 2:
            if random.random() < 0.5:
                return Action.C
            else:
                return Action.D
        elif state.round_number + 1 == self.game_description.n_rounds:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_24(BaseStrategy):
    """
    Exploitative strategy: Adaptive Stock Depletion (ASD).
    
    This strategy aims to maximize individual payoff by adaptively responding 
    to the game state and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        total_coop_count = np.sum(opponent_actions[:-1])
        avg_opponent_ocr = total_coop_count / (n_players * state.round_number)
        if state.current_stock <= capacity / 2:
            return Action.C
        consecutive_defect_count = np.sum(1 - opponent_actions[-3:, :])
        if consecutive_defect_count >= 3:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if avg_opponent_ocr > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_25(BaseStrategy):
    """
    The Adaptive Predator strategy combines elements of exploitation, adaptation, and robustness to handle a wide range of opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.alpha = 0.5
        self.opponents_cooperated = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        opponents_actions = history.opponent_actions[-1, :]
        self.opponents_cooperated = sum(opponents_actions) / len(opponents_actions) > 0.5
        previous_stock = state.current_stock if state.round_number == 1 else history.my_payoffs[-2]
        stock_growth = 2 * (state.current_stock - previous_stock)
        if self.opponents_cooperated:
            action = Action.D
        else:
            action = Action.C
        if state.current_stock < self.game_description.capacity / 2:
            action = Action.C
        elif state.current_stock > 3 / 4 * self.game_description.capacity:
            action = Action.D
        if self.alpha > 0.7:
            action = Action.C
        elif self.alpha < 0.3:
            action = Action.D
        if self.opponents_cooperated and stock_growth > 0:
            self.alpha += 0.1
        elif not self.opponents_cooperated and stock_growth < 0:
            self.alpha -= 0.1
        self.alpha = max(0, min(self.alpha, 1))
        return action

class Strategy_EXPLOITATIVE_26(BaseStrategy):
    """
    An exploitative strategy designed to maximize payoffs by adapting to the common pool resource game's mechanics and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio > 0.75:
            return Action.D
        elif stock_ratio >= 0.25 and stock_ratio <= 0.75:
            p = stock_ratio ** 2
            return Action.C if random.random() < p else Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_27(BaseStrategy):
    """
    An adaptive exploiter strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.75 * game_description.capacity
        self.history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            total_consumption = sum(np.where(history.opponent_actions[-1, :], self.game_description.capacity / (2 * self.game_description.n_players), self.game_description.capacity / self.game_description.n_players))
            self.history.append(total_consumption)
        if len(self.history) > 0:
            total_consumption = sum(self.history)
            if total_consumption < 0.5 * self.game_description.capacity * state.round_number:
                return Action.D
        if state.current_stock <= self.threshold:
            if history is not None and (np.any(np.logical_not(history.opponent_actions[-1, :])) or total_consumption > 0.5 * self.game_description.capacity):
                return Action.D
            else:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_28(BaseStrategy):
    """
    Exploitative strategy that adapts to the game's state and history,
    aiming to maximize individual payoffs by responding to potential weaknesses in opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_stock = game_description.capacity
        self.growth_threshold = game_description.capacity / (4 * game_description.n_players)
        self.low_stock_threshold = game_description.capacity / (2 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            max_coop_consumption = self.initial_stock / (2 * self.game_description.n_players)
            return Action.C if max_coop_consumption >= self.growth_threshold else Action.D
        avg_growth = (state.current_stock - self.initial_stock) / state.round_number
        if avg_growth > self.growth_threshold and state.current_stock > self.low_stock_threshold:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_29(BaseStrategy):
    """
    The Adaptive Stock Hawk strategy aims to balance short-term gains with long-term sustainability 
    by adapting to the current state of the stock and the observed behavior of opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.stock_history.append(state.current_stock)
        opponents_defected_prev = sum((not action for action in history.opponent_actions[-1, :]))
        if 2 <= state.round_number < self.game_description.n_rounds / 2:
            if state.current_stock > 0.75 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C
        elif self.game_description.n_rounds / 2 <= state.round_number < self.game_description.n_rounds:
            if opponents_defected_prev >= self.game_description.n_players / 2:
                return Action.D
            else:
                return Action.C
        elif state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.D
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_30(BaseStrategy):
    """
    The Adaptive Stock Hawk strategy aims to exploit opponents' behavior while adapting to the dynamic state of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_payoff_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
        self.opponent_payoff_history.append(avg_opponent_payoff)
        own_payoff = history.my_payoffs[-1]
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_stock < 0.5 * capacity:
            return Action.D
        elif avg_opponent_payoff > own_payoff and (not state.round_number == self.game_description.n_rounds - 1):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_31(BaseStrategy):
    """
    Exploitative strategy that balances short-term gains with long-term sustainability of the common pool resource.
    Adapts to opponents' behaviors and the game's state, exploiting opponents' cooperation while ensuring a stable stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def calculate_opponent_average_payoff(self, history: PlayerHistory) -> float:
        opponent_payoffs = history.opponent_payoffs[:, 0] if self.n_players == 2 else np.mean(history.opponent_payoffs, axis=1)
        return np.mean(opponent_payoffs)

    def calculate_player_average_payoff(self, history: PlayerHistory) -> float:
        return np.mean(history.my_payoffs)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        t = state.round_number + 1
        OPP_avg = self.calculate_opponent_average_payoff(history)
        P_avg = self.calculate_player_average_payoff(history)
        cooperation_probability = 0.5
        if OPP_avg > P_avg:
            cooperation_probability += 0.1
        elif OPP_avg < P_avg:
            cooperation_probability -= 0.1
        if current_stock / self.capacity >= 0.75:
            return Action.D
        elif 0.25 <= current_stock / self.capacity < 0.75:
            return Action.C if random.random() < cooperation_probability else Action.D
        else:
            return Action.D
        if t == self.game_description.n_rounds:
            return Action.D
        elif current_stock / self.capacity < 0.1:
            return Action.C

class Strategy_EXPLOITATIVE_32(BaseStrategy):
    """
    Adaptive Stock-Dependent Exploitation strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_actions = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if history is not None:
            opponent_cooperators = np.sum(history.opponent_actions, axis=0) / (state.round_number + 1)
            self.opponent_actions = [opponent_cooperator >= 0.5 for opponent_cooperator in opponent_cooperators]
        SUR = state.current_stock / self.game_description.capacity
        if SUR < 0.5:
            return Action.D
        elif history is not None and np.any(history.opponent_actions[-1, :]):
            return Action.D
        elif self.opponent_actions is not None and any(self.opponent_actions):
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_33(BaseStrategy):
    """
    The Adaptive Stock Raider strategy balances exploitation and cooperation.
    
    Initially probes opponents with random cooperation, then adapts actions based on 
    stock level and opponents' payoffs. In final round, prioritizes exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C if random.random() < 0.5 else Action.D
        current_stock = state.current_stock
        avg_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
        avg_cooperation_payoff = current_stock / (2 * self.n_players)
        if current_stock >= 0.75 * self.capacity:
            return Action.D
        elif 0.25 * self.capacity <= current_stock < 0.75 * self.capacity:
            if avg_opponent_payoff < avg_cooperation_payoff:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if current_stock >= self.capacity:
            return Action.C

class Strategy_EXPLOITATIVE_34(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperation_rate = np.mean(history.opponent_actions[:-1])
        if state.round_number < self.game_description.n_rounds // 2:
            if opponent_cooperation_rate < 0.5 or state.current_stock > 0.75 * self.capacity:
                return Action.D
            else:
                return Action.C
        elif state.round_number < 3 * self.game_description.n_rounds // 4:
            exploitation_threshold = state.current_stock / self.capacity * (opponent_cooperation_rate + 0.25)
            if exploitation_threshold < 0.5:
                return Action.D
            else:
                return Action.C
        elif state.current_stock > 0.5 * self.capacity and np.any(~history.opponent_actions[-1, :]):
            return Action.D
        elif opponent_cooperation_rate > 0.5:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * self.capacity:
            return Action.C

class Strategy_EXPLOITATIVE_36(BaseStrategy):
    """
    An exploitative strategy that adapts to the current state and history of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperation_counts = [0] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        num_players = self.game_description.n_players
        current_stock = state.current_stock
        if history is not None and len(history.opponent_actions) > 1:
            for i, action in enumerate(history.opponent_actions[-1]):
                if action:
                    self.opponent_cooperation_counts[i] += 1
        if history is not None and len(history.my_payoffs) > 3:
            recent_growth = sum([history.my_payoffs[-i] for i in range(1, min(len(history.my_payoffs), 4))])
            if recent_growth > 0:
                cooperation_likelihood = 0.6
            else:
                cooperation_likelihood = 0.4
        if state.round_number == 1:
            return Action.C
        defected_last_round = sum([not action for action in history.opponent_actions[-1]]) > num_players // 2
        total_consumption_last_round = current_stock - (state.current_stock + capacity) / 2
        if current_stock > 0.75 * capacity:
            return Action.D if defected_last_round else Action.C
        elif current_stock >= 0.25 * capacity and current_stock <= 0.75 * capacity:
            return Action.C if total_consumption_last_round < 0.5 * capacity else Action.D
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_37(BaseStrategy):
    """
    Exploitative strategy designed to adapt to changing opponent behaviors while maximizing payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock > 0.75 * self.game_description.capacity else Action.D
        total_consumption = sum(history.opponent_payoffs[-1, :]) + state.current_stock / (2 * self.game_description.n_players) * history.my_actions[-1]
        avg_opponent_consumption = (total_consumption - state.current_stock / (2 * self.game_description.n_players) * history.my_actions[-1]) / (self.game_description.n_players - 1)
        if avg_opponent_consumption > 0.5 * self.game_description.capacity:
            action = Action.D
        elif state.current_stock > 0.5 * self.game_description.capacity:
            action = Action.C
        else:
            action = Action.D
        if history.my_actions.size >= self.k:
            previous_avg_opponent_consumption = np.mean([sum(history.opponent_payoffs[-i - 1, :]) / (self.game_description.n_players - 1) for i in range(self.k)])
            if abs(avg_opponent_consumption - previous_avg_opponent_consumption) > 0.2 * self.game_description.capacity:
                if avg_opponent_consumption > previous_avg_opponent_consumption:
                    action = Action.D
                else:
                    action = Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            action = Action.C
        if state.current_stock > 0.9 * self.game_description.capacity:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_39(BaseStrategy):
    """
    Exploitative Strategy: "Adaptive Stock Raider"
    
    The Adaptive Stock Raider (ASR) is a decision-making strategy designed to exploit opponents' behaviors 
    in the Common Pool Resource Game while adapting to changing game conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if self.game_description.n_players <= 4:
                return Action.C
            else:
                return Action.D
        total_consumption = np.sum(np.where(history.opponent_actions, 1 / self.game_description.n_players, 1))
        sp = total_consumption / self.game_description.capacity
        if sp >= 0.5:
            return Action.D
        c_count = np.sum(history.opponent_actions[-1])
        d_count = self.game_description.n_players - 1 - c_count
        if c_count > d_count:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.2 * self.game_description.capacity:
            return Action.D

class Strategy_EXPLOITATIVE_40(BaseStrategy):
    """
    An exploitative strategy designed to maximize individual payoffs while adapting to the dynamic state of the common pool resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperation_count = 0
        self.recent_payoff_average = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock / self.game_description.capacity
        if history is not None and len(history.my_actions) > 1:
            opponent_cooperations_last_round = sum((1 for action in history.opponent_actions[-1, :] if action))
            self.opponent_cooperation_count += opponent_cooperations_last_round / self.game_description.n_players
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif current_stock > 0.75:
            return Action.D
        elif current_stock >= 0.5:
            return Action.C
        else:
            return Action.D
        if self.opponent_cooperation_count > 0.5:
            return Action.D
        elif self.recent_payoff_average is not None and self.recent_payoff_average < 0.5 * np.mean(history.my_payoffs):
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_41(BaseStrategy):
    """
    An adaptive exploitative strategy for Common Pool Resource Game.
    
    Decision Rules:
    - Initial Round: Defect to maximize initial payoff and gather information on opponents' behavior.
    - Middle Rounds: Adapt cooperation rate based on current stock level and opponent behavior.
    - Last Round: Defect to maximize final payoff, as there are no future rounds to consider.

    Adaptive Component:
    - Monitor opponents' behavior and adjust strategy based on their cooperation rates.
    - Use a simple moving average of opponents' past actions to estimate their cooperation rates.

    Robustness Mechanisms:
    - Opponent Cooperation Detection: Estimate opponent cooperation rates using a simple moving average.
    - Stock Level Smoothing: Apply a smoothing factor to the current stock level to reduce the impact of sudden changes.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_rate = 0.5
        self.smoothing_factor = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        current_stock = state.current_stock
        opponent_cooperation_rate = self.estimate_opponent_cooperation(history)
        if current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        elif current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        else:
            if opponent_cooperation_rate > 0.5:
                self.cooperation_rate += 0.1
            else:
                self.cooperation_rate -= 0.1
            self.cooperation_rate = max(0, min(1, self.cooperation_rate))
            if random.random() < self.cooperation_rate:
                return Action.C
            else:
                return Action.D
        smoothed_stock = (1 - self.smoothing_factor) * current_stock + self.smoothing_factor * history.my_payoffs[-1]

    def estimate_opponent_cooperation(self, history: PlayerHistory):
        """
        Estimate opponent cooperation rate using a simple moving average of their past actions.
        
        :param history: The game's player history
        :return: Estimated opponent cooperation rate (float)
        """
        opponent_actions = history.opponent_actions[-1]
        return sum(opponent_actions) / len(opponent_actions)

class Strategy_EXPLOITATIVE_42(BaseStrategy):
    """
    The Adaptive Stock Hawk (ASH) strategy is designed to exploit opponents' behaviors while adapting to the dynamic state of the game.
    It balances short-term gains with long-term sustainability, aiming to maximize total payoff over multiple rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock <= 0.01 * self.game_description.capacity:
            return Action.C
        p_defect = (self.game_description.capacity - state.current_stock) / self.game_description.capacity
        if random.random() < p_defect:
            return Action.D
        prev_majority = np.mean(history.opponent_actions[-1, :]) > 0.5
        if prev_majority:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_43(BaseStrategy):
    """
    Exploitative strategy "Adaptive Stock Raider" that adapts to opponents' behaviors and stock trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.opponent_actions = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.stock_history.append(state.current_stock)
        if history is not None:
            self.opponent_actions.append(history.opponent_actions[-1, :])
        if state.current_stock > 0.75 * self.game_description.capacity:
            action = Action.D
        elif 0.25 * self.game_description.capacity < state.current_stock <= 0.75 * self.game_description.capacity:
            action = Action.C
        else:
            action = Action.D
        if history is not None and len(self.opponent_actions) > 1:
            opponents_consistency = np.std(self.opponent_actions, axis=0)
            for i in range(len(opponents_consistency)):
                if opponents_consistency[i] < 0.5:
                    action = Action.D
                    break
        if len(self.stock_history) > 2:
            stock_trend = np.polyfit(range(len(self.stock_history)), self.stock_history, 1)
            if stock_trend[0] < -self.game_description.capacity / (4 * self.game_description.n_rounds):
                action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return action

class Strategy_EXPLOITATIVE_44(BaseStrategy):
    """
    An adaptive strategy that balances cooperation and exploitation in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            if current_stock > 0.9 * capacity:
                return Action.C
            else:
                return Action.D
        elif round_number < self.game_description.n_rounds // 3:
            opponent_actions = history.opponent_actions[-1, :]
            avg_CR = np.mean(opponent_actions)
            if avg_CR > 0.5:
                return Action.C
            else:
                return Action.D
        elif round_number < self.game_description.n_rounds * 2 // 3:
            opponent_prev_action = history.opponent_actions[-1, :]
            CR = np.mean(opponent_prev_action)
            if np.any(opponent_prev_action) or CR > 0.5:
                return Action.C
            elif round_number > self.game_description.n_rounds // 3 + 2:
                return Action.D
            else:
                return Action.C
        elif current_stock > 0.7 * capacity:
            return random.choice([Action.C, Action.D])
        else:
            return Action.D
        if round_number == self.game_description.n_rounds - 1 or current_stock < 0.3 * capacity:
            opponent_prev_action = history.opponent_actions[-1, :]
            CR = np.mean(opponent_prev_action)
            if CR > 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_46(BaseStrategy):
    """
    This is an adaptive strategy designed for a Common Pool Resource game.
    It tries to identify cooperators and defectors, then adjusts its decision-making accordingly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if random.random() < 0.5 else Action.D
        prev_round_coops = sum(history.opponent_actions[-1, :])
        stock_percentage = state.current_stock / self.capacity * 100
        if state.round_number < self.game_description.n_rounds - 1:
            if stock_percentage > 75:
                return Action.C if prev_round_coops >= self.game_description.n_players // 2 else Action.D
            elif 25 <= stock_percentage < 75:
                return Action.C if prev_round_coops > self.game_description.n_players // 2 else Action.D
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_47(BaseStrategy):
    """
    The Adaptive Exploiter strategy is designed to exploit opponents' behaviors while adapting to the dynamic state of the game.
    It balances cooperation and defection based on the current stock level, number of players, and historical actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_actions = history.opponent_actions[-1, :]
        prev_round_cooperators = sum(prev_round_actions)
        if state.round_number < self.game_description.n_rounds // 2:
            if state.current_stock > 0.75 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C
        elif state.round_number >= self.game_description.n_rounds // 2 and state.round_number < self.game_description.n_rounds - 1:
            if prev_round_cooperators > self.game_description.n_players // 2:
                return Action.C
            elif prev_round_cooperators <= self.game_description.n_players // 2:
                return Action.D
            if state.current_stock < 0.5 * self.game_description.capacity:
                return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > 0.75 * self.game_description.capacity and prev_round_cooperators <= self.game_description.n_players // 2:
                return Action.D
            else:
                return Action.C
        elif state.round_number == self.game_description.n_rounds:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C

class Strategy_EXPLOITATIVE_48(BaseStrategy):
    """
    Adaptive Stock-Based Exploitation (ASBE) strategy.
    Cooperates initially to gather information about opponents' behavior and initial stock level,
    then adapts based on current stock level, opponent actions, and game state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 1:
            return Action.D
        stock_threshold = 0.5 * self.capacity
        if state.current_stock < stock_threshold:
            return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        defect_count = np.sum(~opponent_actions)
        cooperate_count = len(opponent_actions) - defect_count
        if defect_count > cooperate_count:
            return Action.D
        elif cooperate_count > defect_count:
            return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_50(BaseStrategy):
    """
    An adaptive strategy that exploits opponent weaknesses while considering the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_cooperation_rate = np.mean(history.my_actions)
        opponent_actions = history.opponent_actions[-1, :]
        stock = state.current_stock
        if stock >= 0.75 * self.capacity:
            if avg_cooperation_rate > 0.5:
                return Action.C
            else:
                return Action.D
        elif 0.25 * self.capacity <= stock < 0.75 * self.capacity:
            majority_cooperates = np.sum(opponent_actions) > len(opponent_actions) / 2
            if majority_cooperates:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock < 0.1 * self.capacity:
            return Action.D

class Strategy_EXPLOITATIVE_51(BaseStrategy):
    """
    Exploitative strategy "Adaptive Stock Guardian" for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_opponent_consumption = np.mean(history.opponent_actions[-1, :] * (state.current_stock / self.n_players) + ~history.opponent_actions[-1, :] * (state.current_stock / (2 * self.n_players)))
        stock_threshold = 0.75 * self.capacity
        cooperation_threshold = state.current_stock / (2 * self.n_players)
        if state.current_stock > stock_threshold:
            return Action.D
        elif state.current_stock >= 0.5 * self.capacity and avg_opponent_consumption < cooperation_threshold:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_52(BaseStrategy):
    """
    Adaptive Exploitation strategy for the Common Pool Resource Game.
    
    This strategy balances adaptation to opponents' behaviors with maximizing short-term gains.
    It initially cooperates, gathers information about opponents, and potentially creates a cooperative foundation.
    The cooperation threshold is adjusted based on the current stock level, responding to changes in the environment and adapting to shifting opponent behaviors.
    In times of low stock levels, it prioritizes self-interest and defects to maximize its own payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock > 0.75 * self.game_description.capacity:
            T = self.game_description.n_players / 2
        else:
            T = self.game_description.n_players / 4
        num_cooperators = sum(history.opponent_actions[-1, :])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        if num_cooperators >= T:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_53(BaseStrategy):
    """
    Exploitative strategy that adapts to the game state and history of opponent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.stock_threshold = 0.6 * self.capacity
        self.odr_window_size = 5

    def calculate_odr(self, history: PlayerHistory) -> float:
        opponent_actions = history.opponent_actions[-self.odr_window_size:]
        return (opponent_actions == False).mean()

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock > self.stock_threshold:
            return Action.D
        odr = self.calculate_odr(history)
        if odr > 0.7:
            return Action.D
        current_payoff = history.my_payoffs[-1]
        previous_payoff = history.my_payoffs[-2] if len(history.my_payoffs) > 1 else math.inf
        previous_action = history.my_actions[-2] if len(history.my_actions) > 1 else True
        if current_payoff < previous_payoff and previous_action:
            return Action.D
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_54(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behavior and current stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        opponent_payoffs = history.opponent_payoffs
        if state.round_number < self.game_description.n_rounds // 2:
            if current_stock > 0.75 * self.capacity:
                return Action.D
            elif current_stock < 0.25 * self.capacity:
                return Action.C
            else:
                return random.choice([Action.C, Action.D])
        if state.round_number >= self.game_description.n_rounds // 2 and state.round_number < self.game_description.n_rounds - 2:
            avg_opponent_payoff = np.mean(opponent_payoffs[-1, :])
            cooperator_payoff = current_stock / (2 * self.n_players)
            defector_payoff = current_stock / self.n_players
            if avg_opponent_payoff > cooperator_payoff:
                return Action.D
            elif avg_opponent_payoff < defector_payoff:
                return Action.C
            else:
                return random.choice([Action.C, Action.D])
        if current_stock > 0.5 * self.capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_55(BaseStrategy):
    """
    Exploitative strategy that adapts to the game state and history while exploiting potential cooperation from opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
        my_payoff = history.my_payoffs[-1]
        stock_trend = self.analyze_stock_trend(state.current_stock, history)
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        elif state.current_stock >= 0.5 * self.game_description.capacity and avg_opponent_payoff > my_payoff:
            return Action.D
        elif state.current_stock < 0.5 * self.game_description.capacity or stock_trend == 'decreasing':
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

    @staticmethod
    def analyze_stock_trend(current_stock, history):
        if len(history.my_payoffs) < 3:
            return 'neutral'
        stock_decrease = current_stock - np.mean([history.my_payoffs[-i] for i in range(1, min(4, len(history.my_payoffs)))])
        if stock_decrease > 0:
            return 'increasing'
        elif stock_decrease < 0:
            return 'decreasing'
        else:
            return 'neutral'

class Strategy_EXPLOITATIVE_56(BaseStrategy):
    """
    The Adaptive Stock Hawk strategy adapts to various opponent behaviors and game states,
    prioritizing short-term gains when the stock level allows it.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        num_defectors_prev = sum((1 for action in opponent_actions if not action))
        growth_rate = self.calculate_growth_rate(state.current_stock, history.my_payoffs)
        stock_level = state.current_stock / self.game_description.capacity
        if stock_level > 0.75 or (num_defectors_prev >= 2 and stock_level > 0.5) or state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif stock_level < 0.5 or growth_rate < 0.5:
            return Action.C
        else:
            return Action.C

    def calculate_growth_rate(self, current_stock: float, payoffs: NDArray[np.float64]) -> float:
        """
        Calculate the average growth rate of the stock over the last few rounds.
        
        This is a simple implementation that calculates the growth rate as the
        difference between the current stock and the previous round's stock,
        divided by the previous round's stock.
        
        :param current_stock: The current stock level.
        :param payoffs: An array of this player's payoffs, indexed [round].
        :return: The average growth rate over the last few rounds.
        """
        if len(payoffs) < 2:
            return 1.0
        previous_stock = current_stock - payoffs[-1] * self.game_description.n_players
        growth_rate = (current_stock - previous_stock) / previous_stock
        return growth_rate

class Strategy_EXPLOITATIVE_57(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to 
    both the game's state and the observed behaviors of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.recent_coop_payoffs = []
        self.recent_defect_payoffs = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if len(self.recent_coop_payoffs) > 0 and len(self.recent_defect_payoffs) > 0:
            avg_coop_payoff = np.mean(np.array(self.recent_coop_payoffs))
            avg_defect_payoff = np.mean(np.array(self.recent_defect_payoffs))
        else:
            avg_coop_payoff = history.my_payoffs[-1]
            avg_defect_payoff = 0
        exploitation_factor = (avg_defect_payoff - avg_coop_payoff) / avg_coop_payoff if avg_coop_payoff != 0 else float('inf')
        if exploitation_factor > 0.5 and state.current_stock > self.game_description.capacity / 2:
            action = Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        else:
            opponent_actions = history.opponent_actions[-1, :]
            n_cooperators = sum(opponent_actions)
            if len(self.recent_coop_payoffs) > 0 and len(self.recent_defect_payoffs) > 0:
                avg_coop_payoff_recent = np.mean(np.array(self.recent_coop_payoffs))
                avg_defect_payoff_recent = np.mean(np.array(self.recent_defect_payoffs))
            else:
                avg_coop_payoff_recent = history.my_payoffs[-1]
                avg_defect_payoff_recent = 0
            if avg_defect_payoff_recent > avg_coop_payoff_recent and n_cooperators >= self.game_description.n_players // 2:
                action = Action.D
            else:
                action = Action.C
        if history.my_actions[-1]:
            self.recent_coop_payoffs.append(history.my_payoffs[-1])
        else:
            self.recent_defect_payoffs.append(history.my_payoffs[-1])
        return action

class Strategy_EXPLOITATIVE_58(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behaviors and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_level = game_description.capacity
        self.rounds_played = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.stock_level = state.current_stock
        self.rounds_played = state.round_number
        if self.rounds_played < self.game_description.n_players:
            return Action.C
        defect_threshold = 0.5 * (self.game_description.n_rounds - self.rounds_played) / self.game_description.n_rounds
        if self.stock_level < defect_threshold:
            return Action.D
        if history is not None and len(history.opponent_actions) > 0:
            opponent_cooperation_rate = np.mean(history.opponent_actions[-1, :])
            if opponent_cooperation_rate > 0.5:
                return Action.C
            else:
                return Action.D
        return Action.D

    def update_stock_level(self, action: Action):
        consumption = self.stock_level / (2 * self.game_description.n_players) if action == Action.C else self.stock_level / self.game_description.n_players
        total_consumption = consumption * self.game_description.n_players
        remaining_stock = self.stock_level - total_consumption
        growth = 2 * remaining_stock * (1 - remaining_stock / self.game_description.capacity)
        self.stock_level = min(remaining_stock + growth, self.game_description.capacity)

class Strategy_EXPLOITATIVE_59(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behaviors while balancing cooperation and defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.acr = 0.5
        self.stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number <= 5:
            opponent_actions = history.opponent_actions[-1, :]
            self.acr = np.mean(opponent_actions) + 0.01 * random.random()
            return Action.C
        if self.acr >= 0.5:
            return Action.D
        else:
            p = state.current_stock / self.game_description.capacity
            return Action.C if random.random() < p else Action.D
        if state.round_number > 0.8 * self.game_description.n_rounds:
            return Action.D

class Strategy_EXPLOITATIVE_60(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.ocr_estimate = 0.5
        self.defect_thresholds = [0.25 * game_description.capacity]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        for action in history.opponent_actions[-1]:
            self.ocr_estimate += (action * 2 - 1) / len(history.opponent_actions[-1])
        if self.ocr_estimate > 0.5:
            self.defect_thresholds[0] = 0.9 * self.game_description.capacity
        elif self.ocr_estimate < 0.3:
            self.defect_thresholds[0] = 0.1 * self.game_description.capacity
        else:
            self.defect_thresholds[0] = 0.25 * self.game_description.capacity
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.D
        elif state.current_stock >= self.defect_thresholds[0]:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D

class Strategy_EXPLOITATIVE_61(BaseStrategy):
    """
    An exploitative strategy that adapts to the game state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.average_depletion_rate = 0.0
        self.opponent_cooperates = False
        self.opponent_defects = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_level = state.current_stock
        average_depletion_rate = self.calculate_average_depletion_rate(history)
        opponent_cooperates = self.is_opponent_cooperative(history)
        opponent_defects = self.is_opponent_defective(history)
        if average_depletion_rate > 0.5 or opponent_cooperates:
            return Action.C
        elif opponent_defects and stock_level < 0.25 * self.capacity:
            return Action.C
        if stock_level >= 0.75 * self.capacity:
            return Action.D
        elif stock_level >= 0.5 * self.capacity:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

    def calculate_average_depletion_rate(self, history: PlayerHistory) -> float:
        total_consumption = np.sum(np.logical_not(history.opponent_actions), axis=1)
        depletion_rates = np.divide(total_consumption, self.capacity)
        average_depletion_rate = np.mean(depletion_rates[-3:])
        return average_depletion_rate

    def is_opponent_cooperative(self, history: PlayerHistory) -> bool:
        opponent_actions = history.opponent_actions
        opponent_cooperation = np.sum(opponent_actions[:, 0]) / len(opponent_actions)
        if opponent_cooperation > 0.75:
            return True
        return False

    def is_opponent_defective(self, history: PlayerHistory) -> bool:
        opponent_actions = history.opponent_actions
        opponent_defection = np.sum(np.logical_not(opponent_actions[:, 0])) / len(opponent_actions)
        if opponent_defection > 0.75:
            return True
        return False

class Strategy_EXPLOITATIVE_62(BaseStrategy):
    """
    Adaptive Stock-Based Exploitation strategy for the Common Pool Resource Game.
    
    This strategy prioritizes personal gain while taking into account the stock level and opponents' behavior.
    It adapts to different scenarios, aiming to maximize its payoff by exploiting cooperative opponents,
    balancing short-term gains with long-term sustainability, and prioritizing self-interest in critical situations.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_cooperated = sum(history.opponent_actions[-1, :]) > self.game_description.n_players / 2
        stock_decline_rate = (state.current_stock - history.my_payoffs[-1]) / self.game_description.capacity
        if state.current_stock >= self.game_description.capacity / 2 and opponents_cooperated:
            return Action.D
        elif self.game_description.capacity / 4 <= state.current_stock < self.game_description.capacity / 2 and stock_decline_rate < -0.05:
            return Action.D
        elif state.current_stock < self.game_description.capacity / 4:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C

class Strategy_EXPLOITATIVE_63(BaseStrategy):
    """
    An adaptive and exploitative strategy for the Common Pool Resource Game.
    
    This strategy balances short-term gains with long-term sustainability, 
    adapting to opponents' behaviors and the game's state while ensuring 
    robustness against various strategies.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        T = 0.5 * capacity + 0.25 * current_stock
        opponents_actions = history.opponent_actions[:-1, :]
        opponent_FC = np.mean(opponents_actions, axis=0)
        W = min(5, state.round_number)
        if len(history.my_payoffs) >= W:
            avg_stock_last_W_rounds = np.mean(current_stock - history.my_payoffs[-W:])
        else:
            avg_stock_last_W_rounds = current_stock
        if current_stock > T or any(opponent_FC < 0.3):
            return Action.D
        if current_stock < avg_stock_last_W_rounds:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif current_stock < 0.2 * capacity:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_64(BaseStrategy):
    """
    Exploitative strategy that adapts to the dynamic state of the game and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.low_stock_threshold = 0.25 * game_description.capacity
        self.high_stock_threshold = 0.75 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_defected = np.sum(~history.opponent_actions[-1, :])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock > self.high_stock_threshold:
            return Action.C
        elif self.low_stock_threshold <= state.current_stock <= self.high_stock_threshold:
            if opponents_defected > 0.5 * (self.game_description.n_players - 1):
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_65(BaseStrategy):
    """
    Exploitative strategy that adapts to the game's state and history.
    Balances short-term gain with long-term sustainability to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_actions = []
        self.predicted_growth = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif 2 <= state.round_number < self.game_description.n_rounds:
            if state.current_stock > 0.75 * self.game_description.capacity:
                action = Action.D
            elif 0.25 * self.game_description.capacity <= state.current_stock <= 0.75 * self.game_description.capacity:
                action = Action.C
            else:
                action = Action.D
            if history is not None:
                opponent_actions_t = history.opponent_actions[-1, :]
                if np.mean(opponent_actions_t) > 0.5:
                    action = Action.D if random.random() < 0.6 else Action.C
                elif np.mean(opponent_actions_t) < 0.5:
                    action = Action.C if random.random() < 0.4 else Action.D
            current_consumption = self.predict_consumption(history)
            self.predicted_growth = self.estimate_stock_growth(current_consumption, state.current_stock)
            if self.predicted_growth > 0:
                action = Action.C
        else:
            action = Action.D
        return action

    def predict_consumption(self, history: PlayerHistory) -> float:
        """Predict current consumption based on opponent actions."""
        if history is None:
            return self.game_description.capacity / (2 * self.game_description.n_players)
        opponent_actions_t = history.opponent_actions[-1, :]
        n_cooperators = np.sum(opponent_actions_t)
        n_defectors = self.game_description.n_players - n_cooperators
        consumption = n_cooperators * self.game_description.capacity / (2 * self.game_description.n_players ** 2) + n_defectors * self.game_description.capacity / self.game_description.n_players ** 2
        return consumption

    def estimate_stock_growth(self, current_consumption: float, stock_level: float) -> float:
        """Estimate future stock growth based on current consumption and stock level."""
        if stock_level <= 0:
            return 0
        growth = 2 * stock_level * (1 - stock_level / self.game_description.capacity)
        return growth

    def update_stock_level(self, action: Action, current_consumption: float) -> float:
        """Update stock level based on the chosen action and current consumption."""
        if action == Action.C:
            consumption = current_consumption
        else:
            consumption = 2 * current_consumption
        new_stock = max(0, self.game_description.capacity - consumption)
        growth = 2 * new_stock * (1 - new_stock / self.game_description.capacity)
        return min(new_stock + growth, self.game_description.capacity)

class Strategy_EXPLOITATIVE_66(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behavior while maximizing personal payoffs.
    Balances cooperation and defection based on the current stock level, number of rounds remaining,
    and observed opponent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperate_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock >= 0.75 * self.game_description.capacity else Action.D
        avg_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
        if state.current_stock < 0.25 * self.game_description.capacity:
            if self.cooperate_counter < 2:
                self.cooperate_counter += 1
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock >= 0.5 * self.game_description.capacity and avg_opponent_payoff <= 0.25 * state.current_stock / (2 * self.game_description.n_players):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_67(BaseStrategy):
    """
    A dynamic and adaptive exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_consumptions = np.sum(history.opponent_actions[-1, :] * self.game_description.n_players / self.game_description.n_players)
        avg_opponent_consumption = opponent_consumptions / (self.game_description.n_players - 1)
        if state.round_number < self.game_description.n_rounds // 2:
            return Action.C
        elif state.round_number <= self.game_description.n_rounds * 3 // 4:
            if state.current_stock > 0.75 * self.game_description.capacity:
                p = avg_opponent_consumption / self.game_description.n_players / (state.current_stock / (2 * self.game_description.n_players))
                return Action.D if random.random() < p else Action.C
            else:
                return Action.C
        elif state.round_number > self.game_description.n_rounds * 3 // 4:
            if state.current_stock < 0.25 * self.game_description.capacity:
                return Action.C
            else:
                p = avg_opponent_consumption / self.game_description.n_players / (state.current_stock / (2 * self.game_description.n_players))
                return Action.D if random.random() < p else Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_68(BaseStrategy):
    """
    Exploitative strategy: "Adaptive Stock Raider"
    
    This strategy balances short-term gains with long-term sustainability by adapting to 
    the current stock level, opponent behavior, and game history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_monitoring = [0.5] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock_ratio = state.current_stock / self.game_description.capacity
        opponents_cooperated_majority = np.sum(history.opponent_actions[-1, :]) >= (self.game_description.n_players - 1) // 2
        if history is not None:
            for i, opponent_action in enumerate(history.opponent_actions[-1, :]):
                if opponent_action:
                    self.opponent_monitoring[i] = min(0.9, self.opponent_monitoring[i] + 0.1)
                else:
                    self.opponent_monitoring[i] = max(0.1, self.opponent_monitoring[i] - 0.1)
        if current_stock_ratio > 0.75:
            return Action.D
        elif current_stock_ratio < 0.25:
            return Action.C
        elif opponents_cooperated_majority and np.mean(self.opponent_monitoring) >= 0.5:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_69(BaseStrategy):
    """
    Adaptive Stock-Dependent Defection (ASDD) strategy for the Common Pool Resource Game.

    This strategy adapts to the changing stock levels and opponents' behavior, balancing cooperation and defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.7 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock > self.stock_threshold:
            action = Action.D
        else:
            action = Action.C
        if history is not None and len(history.opponent_actions) > 0:
            opponents_defected = np.mean(~history.opponent_actions[-1, :])
            if opponents_defected > 0.5:
                action = Action.C
            elif opponents_defected < 0.5:
                action = Action.D
        return action

class Strategy_EXPLOITATIVE_70(BaseStrategy):
    """
    An adaptive strategy that responds to the game's state and history, 
    exploiting potential weaknesses in opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def calculate_stock_growth(self, state: CommonPoolState) -> float:
        """
        Calculate stock growth based on the current state.
        
        :param state: The current state of the game
        :return: Stock growth value
        """
        s_remaining = state.current_stock - self.game_description.n_players * (state.current_stock / (2 * self.game_description.n_players))
        growth = 2 * s_remaining * (1 - s_remaining / self.game_description.capacity)
        return growth

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C if state.current_stock >= self.game_description.capacity / 2 else Action.D
        avg_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
        own_payoff = history.my_payoffs[-1]
        if avg_opponent_payoff > own_payoff:
            return Action.D if state.current_stock >= self.game_description.capacity / 3 else Action.C
        else:
            return Action.C if state.current_stock >= self.game_description.capacity / 2 else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D if state.current_stock >= self.game_description.capacity / 4 else Action.C
        growth = self.calculate_stock_growth(state)
        if growth > self.game_description.capacity / 10:
            cooperate_prob = 0.7
            return Action.C if random.random() < cooperate_prob else Action.D
        opponent_defections = np.sum(history.opponent_actions == False, axis=1)
        if np.any(opponent_defections >= 2):
            return Action.D

class Strategy_EXPLOITATIVE_72(BaseStrategy):
    """
    A dynamic, adaptive strategy that balances exploitation and sustainability in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.opponent_actions_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.opponent_actions_history.append(history.opponent_actions[-1])
        current_stock = state.current_stock
        threshold_high = 0.75 * self.capacity
        threshold_low = 0.25 * self.capacity
        if current_stock > threshold_high:
            return Action.D
        elif current_stock >= threshold_low and current_stock <= threshold_high:
            p = (current_stock / self.capacity) ** 2
            p = self.adjust_p(p)
            return Action.C if random.random() < p else Action.D
        else:
            return Action.C

    def adjust_p(self, p: float):
        most_recent_opponent_actions = self.opponent_actions_history[-1]
        cooperators = sum(most_recent_opponent_actions)
        if cooperators > len(most_recent_opponent_actions) // 2:
            return min(1, p + 0.1)
        elif cooperators < len(most_recent_opponent_actions) // 2:
            return max(0, p - 0.1)
        return p

    def stock_trend_analysis(self, stock_history: list[float]):
        recent_stock_levels = stock_history[-5:]
        if all((recent_stock_levels[i] < recent_stock_levels[i - 1] for i in range(1, len(recent_stock_levels)))):
            return True
        return False

    def most_opponents_cooperated(self, opponent_actions: NDArray[np.bool_]):
        return sum(opponent_actions) > len(opponent_actions) // 2

    def most_opponents_defected(self, opponent_actions: NDArray[np.bool_]):
        return sum(opponent_actions) < len(opponent_actions) // 2

class Strategy_EXPLOITATIVE_73(BaseStrategy):
    """
    Adaptive Exploiter strategy for the Common Pool Resource Game.
    
    This strategy starts by cooperating in the first round to observe opponents' behavior. 
    It then alternates between cooperation and defection for a few rounds to gather more information. 
    Based on this observation, it either defects frequently if most opponents cooperate or adopts a tit-for-tat approach with bias towards cooperation when the stock is high. 
    In late game rounds, it always defects.
    
    The strategy also handles edge cases such as low stock levels and adjusts its behavior accordingly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.observe_rounds = game_description.n_rounds // 4
        self.exploit_rounds = game_description.n_rounds - self.observe_rounds * 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number <= self.observe_rounds:
            if state.round_number % 2 == 0:
                return Action.C
            else:
                return Action.D
        if state.round_number >= self.game_description.n_rounds - self.observe_rounds:
            return Action.D
        opponent_actions = history.opponent_actions[:self.observe_rounds, :]
        cooperation_rate = np.mean(np.any(opponent_actions, axis=0))
        if state.round_number < self.observe_rounds + self.exploit_rounds:
            if cooperation_rate > 0.5:
                if random.random() < 1 - cooperation_rate:
                    return Action.D
                else:
                    return Action.C
            else:
                previous_stock_level = history.my_payoffs[-2] * self.game_description.n_players * 2
                any_cooperated_last_round = np.any(history.opponent_actions[-1, :])
                if previous_stock_level > self.game_description.capacity * 0.75 and any_cooperated_last_round:
                    return Action.C
                else:
                    return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_74(BaseStrategy):
    """
    Exploitative strategy designed to maximize payoffs in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        num_opponents = self.game_description.n_players - 1
        any_defect = np.any(opponent_actions == False)
        stock_ratio = state.current_stock / self.game_description.capacity
        if state.round_number + 1 == self.game_description.n_rounds:
            return Action.D
        opponent_cooperation_rate = sum((1 for action in opponent_actions if action)) / num_opponents
        if opponent_cooperation_rate > 0.5:
            exploitation_threshold = 0.5
        else:
            exploitation_threshold = 0.75
        if stock_ratio >= exploitation_threshold and any_defect:
            return Action.D
        if stock_ratio < 0.25:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_75(BaseStrategy):
    """
    Robust and exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio > 0.75:
            return Action.D
        elif stock_ratio >= 0.5 and stock_ratio <= 0.75:
            cooperation_prob = (state.current_stock / self.game_description.capacity) ** 2
            if random.random() < cooperation_prob:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_76(BaseStrategy):
    """
    Adaptive Exploiter (AE) strategy for Common Pool Resource Game.
    
    This strategy balances short-term exploitation with long-term sustainability by 
    adapting to changing circumstances and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_stock = 0.7 * game_description.capacity
        self.apr_threshold = 0.5 * game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        opponent_payoffs = history.opponent_payoffs[-1, :]
        if state.current_stock > self.threshold_stock:
            return Action.D
        opponent_c = np.argmax(np.mean(history.opponent_actions, axis=0))
        opponent_d = np.argmin(np.mean(history.opponent_actions, axis=0))
        if np.mean(history.opponent_actions[:, opponent_c]) >= 2 / 3:
            return Action.D
        elif np.mean(1 - history.opponent_actions[:, opponent_d]) >= 2 / 3:
            return Action.C
        apr = np.mean(history.my_payoffs)
        if apr < self.apr_threshold:
            if history.my_actions[-1]:
                return Action.D
            else:
                return Action.C
        if state.round_number >= self.game_description.n_rounds - 2 and state.current_stock > self.threshold_stock:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_77(BaseStrategy):
    """
    This strategy exploits common behaviors while being adaptive and robust.
    It initially gathers information by cooperating, then shifts towards exploiting 
    when opportunities arise or when stock levels are low. The strategy also prioritizes 
    maximizing payoffs in endgame scenarios while maintaining a degree of cooperation 
    to avoid total depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_half = game_description.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number <= 2:
            return Action.C
        elif self.game_description.n_rounds - state.round_number > 2:
            if state.current_stock > self.capacity_half:
                defector_count = sum(~history.opponent_actions[-1, :])
                if defector_count >= 1:
                    return Action.D
                else:
                    return Action.C
            elif state.current_stock <= self.capacity_half:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_78(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behaviors and game state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
        ne_payoff = self.capacity / (2 * self.n_players)
        if state.round_number < 5:
            stock_level_ratio = state.current_stock / self.capacity
            if stock_level_ratio > 0.75:
                return Action.C
            elif stock_level_ratio < 0.25:
                return Action.D
            elif avg_opponent_payoff > ne_payoff:
                return Action.C if random.random() < 0.6 else Action.D
            else:
                return Action.D if random.random() < 0.6 else Action.C
        else:
            for opponent_actions in history.opponent_actions[-1, :]:
                if not opponent_actions:
                    return Action.D if random.random() < 0.8 else Action.C
                else:
                    return Action.C if random.random() < 0.8 else Action.D
            stock_level_ratio = state.current_stock / self.capacity
            if stock_level_ratio > 0.5:
                return Action.C
            elif stock_level_ratio < 0.25:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.1 * self.capacity:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_79(BaseStrategy):
    """
    Exploitative strategy that adapts to the game state, opponents' behaviors, and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def calculate_avg_opponent_payoff(self, history: PlayerHistory) -> float:
        opponent_payoffs = np.mean(history.opponent_payoffs[:-1], axis=0)
        return np.mean(opponent_payoffs)

    def count_cooperators(self, round_history: NDArray[np.bool_]) -> int:
        return sum(round_history)

    def renewal_possible(self, stock: float, capacity: float) -> bool:
        return stock > 0.25 * capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_opponent_payoff = self.calculate_avg_opponent_payoff(history)
        cooperator_payoff = state.current_stock / (2 * self.n_players)
        if state.current_stock > 0.5 * self.capacity:
            if avg_opponent_payoff >= cooperator_payoff:
                return Action.C
            else:
                return Action.D
        elif state.current_stock <= 0.5 * self.capacity:
            num_cooperators_prev_round = self.count_cooperators(history.opponent_actions[-1, :])
            if num_cooperators_prev_round < self.n_players / 2:
                return Action.D
            else:
                return Action.C
        elif state.round_number == self.game_description.n_rounds - 1 or state.current_stock < 0.25 * self.capacity:
            return Action.D
        elif state.round_number == self.game_description.n_rounds:
            if self.renewal_possible(state.current_stock, self.capacity):
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_80(BaseStrategy):
    """
    An adaptive exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_payoffs = history.opponent_payoffs[-1, :]
        avg_opponent_payoff = np.mean(opponent_payoffs)
        max_possible_payoff = state.current_stock / (2 * self.n_players)
        if avg_opponent_payoff >= 0.75 * max_possible_payoff:
            return Action.D
        elif state.current_stock < 0.25 * self.capacity:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_81(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game.
    Cooperates when opponents are willing to conserve, and defects otherwise.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_threshold = 0.2 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.D
        ocr = np.mean(history.opponent_actions[-1, :])
        if state.current_stock < self.capacity_threshold:
            return Action.C
        if state.round_number < self.game_description.n_rounds - 1:
            if ocr >= 0.5:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_83(BaseStrategy):
    """
    Exploitative Strategy: "Adaptive Stock Predator" (ASP)
    Balances short-term gains with long-term sustainability, adapting to opponents' behavior while prioritizing individual interests.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_rate = 0.5
        self.payoff_diff_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        opponents_defected_last_round = sum((not action for action in history.opponent_actions[-1, :]))
        if current_stock > 0.7 * capacity:
            return Action.D
        elif 0.4 * capacity < current_stock <= 0.7 * capacity:
            if opponents_defected_last_round > self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D
        avg_payoff_diff = np.mean(self.payoff_diff_history) if self.payoff_diff_history else 0
        if abs(avg_payoff_diff) > 0.1:
            if avg_payoff_diff > 0:
                self.cooperation_rate += 0.2
            else:
                self.cooperation_rate -= 0.2
        return Action.C if random.random() < self.cooperation_rate else Action.D

class Strategy_EXPLOITATIVE_84(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Stock Depletion (ASD)

    ASD balances short-term gains with long-term sustainability by cooperating in early rounds, 
    gathering information about opponents' behavior, and adjusting the strategy based on average payoff per round and stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_threshold = self.game_description.capacity * 0.75
        avg_payoff_threshold = self.game_description.capacity / (2 * self.game_description.n_players) * 0.75
        if state.round_number < self.game_description.n_rounds // 2:
            if state.current_stock >= stock_threshold:
                return Action.C
            elif state.current_stock >= self.game_description.capacity * 0.5 and state.current_stock < stock_threshold:
                return random.choice([Action.C, Action.D])
            else:
                return Action.D
        avg_payoff = np.mean(history.my_payoffs) if history is not None else 0.0
        if avg_payoff >= avg_payoff_threshold:
            return Action.C
        else:
            opponent_defection_rate = np.mean(np.logical_not(history.opponent_actions)) if history is not None else 0.5
            defect_prob = max(0.25, min(0.75, 0.5 + opponent_defection_rate * 0.25))
            return random.choices([Action.C, Action.D], weights=[1 - defect_prob, defect_prob])[0]
        if state.current_stock < self.game_description.capacity * 0.25:
            return Action.C

class Strategy_EXPLOITATIVE_85(BaseStrategy):
    """
    The Adaptive Stock Protector (ASP) strategy is designed to exploit opponents' behaviors while protecting the common pool stock from over-depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        num_previous_cooperators = sum(previous_round_opponent_actions)
        if state.current_stock < 0.75 * self.game_description.capacity:
            return Action.C
        if num_previous_cooperators < self.game_description.n_players // 2:
            return Action.D
        if state.round_number >= 1 and history.opponent_actions[-1, :].sum() == 0 and (history.opponent_actions[-2, :].sum() == 0):
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_86(BaseStrategy):
    """
    Exploitative strategy for the Common Pool Resource Game.
    
    This strategy prioritizes exploiting opponents' generosity when possible, 
    while adapting to maintain a stable stock level and maximize our payoff. 
    By observing opponent behavior and adjusting our decision rule accordingly, 
    we aim to outperform other strategies in the tournament.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_stock = state.current_stock
        opponent_actions = history.opponent_actions[-1]
        if prev_stock > self.threshold * self.game_description.capacity:
            return Action.D
        elif sum(opponent_actions) / len(opponent_actions) > 0.5:
            return Action.C
        else:
            my_payoff = history.my_payoffs[-1]
            avg_payoff = np.mean(history.opponent_payoffs[-1])
            if my_payoff < avg_payoff:
                return Action.D
            else:
                return Action.C
        if state.current_stock < 0.3 * self.game_description.capacity:
            self.threshold = 0.4
        elif sum(opponent_actions) / len(opponent_actions) > 0.7:
            self.threshold = 0.6
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.round_number >= 3 and all((np.all(opponent_actions[i] == opponent_actions[0]) for i in range(len(opponent_actions)))):
            if sum(opponent_actions) / len(opponent_actions) > 0.5:
                self.threshold = 0.4
            else:
                self.threshold = 0.6
        return Action.C

class Strategy_EXPLOITATIVE_87(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold_low = game_description.capacity / 4
        self.stock_threshold_high = game_description.capacity * 3 / 4
        self.rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if state.round_number == self.rounds - 1:
            return Action.D
        if current_stock > self.stock_threshold_high:
            return Action.D
        elif current_stock < self.stock_threshold_low:
            return Action.C
        else:
            opponent_defections_last_round = sum((1 for action in history.opponent_actions[-1, :] if not action))
            n_players = self.game_description.n_players
            if opponent_defections_last_round > n_players / 2:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_88(BaseStrategy):
    """
    Adaptive Exploitation strategy for the Common Pool Resource Game.
    
    This strategy aims to balance short-term gains with long-term sustainability by dynamically adjusting its behavior based on game state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.n_rounds = game_description.n_rounds
        self.capacity = game_description.capacity
        self.threshold = self.capacity * (1 - (self.n_players - 1) / self.n_players)
        self.d_count_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if len(self.d_count_history) < state.round_number:
            self.d_count_history.append(sum(~history.opponent_actions[state.round_number - 1, :]))
        d_count = sum(history.opponent_actions[-1, :] == False)
        moving_average_d_count = np.mean(self.d_count_history[-self.n_rounds // 4:])
        if state.current_stock > self.threshold:
            if d_count > moving_average_d_count:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C
        if state.round_number >= self.n_rounds - self.n_rounds // 4 and state.current_stock < self.capacity / (2 * self.n_players):
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_89(BaseStrategy):
    """
    Exploitative strategy that adapts to the dynamic state of the game and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_rates = [0.5] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        opponent_defection_rates = [rate for i, rate in enumerate(self.defection_rates) if i != self.game_description.n_players - 1]
        avg_defection_rate = sum(opponent_defection_rates) / len(opponent_defection_rates)
        current_stock_level = state.current_stock / self.game_description.capacity
        for i, action in enumerate(history.opponent_actions[-1]):
            if not action:
                self.defection_rates[i] += 0.1
        if current_stock_level > 0.75:
            return Action.C
        elif current_stock_level < 0.25:
            return Action.D
        elif avg_defection_rate > 0.5:
            p_defect = max(0.7, avg_defection_rate)
            return Action.D if random.random() < p_defect else Action.C
        elif avg_defection_rate < 0.3:
            p_cooperate = min(0.7, 1 - avg_defection_rate)
            return Action.C if random.random() < p_cooperate else Action.D
        else:
            return random.choice([Action.C, Action.D])
        if state.round_number == self.game_description.n_rounds - 1 and current_stock_level > 0.5:
            return Action.C
        if current_stock_level < 0.1:
            return Action.D

class Strategy_EXPLOITATIVE_90(BaseStrategy):
    """
    Exploitative Strategy: "Adaptive Stock Raider"
    
    This strategy aims to balance short-term gains with long-term sustainability 
    by adapting to the game's state and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.opponent_cooperation_rates = [0.5] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        stock_level = current_stock / self.capacity
        for i, action in enumerate(history.opponent_actions[-1, :]):
            if action:
                self.opponent_cooperation_rates[i] += 0.1
            else:
                self.opponent_cooperation_rates[i] -= 0.1
            self.opponent_cooperation_rates[i] = max(0, min(self.opponent_cooperation_rates[i], 1))
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif stock_level > 0.75:
            return Action.D
        elif 0.5 <= stock_level <= 0.75:
            p = (current_stock / self.capacity) ** 2
            average_cooperation_rate = np.mean(self.opponent_cooperation_rates)
            if average_cooperation_rate > 0.6:
                p += 0.1
            elif average_cooperation_rate < 0.4:
                p -= 0.1
            p = max(0, min(p, 1))
            return Action.C if random.random() < p else Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_91(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to opponents' behaviors and the state of the resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_consumption = np.sum(history.my_payoffs[-1] + history.opponent_payoffs[-1, :])
        stock_threshold_high = 0.75 * self.game_description.capacity
        stock_threshold_low = 0.25 * self.game_description.capacity
        if state.current_stock >= stock_threshold_high:
            return Action.D
        elif prev_consumption <= self.game_description.capacity / 2:
            return Action.C
        elif state.current_stock < stock_threshold_low:
            return Action.C
        else:
            opponent_cooperations = np.sum(history.opponent_actions[-1, :])
            if opponent_cooperations >= self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_92(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behaviors and the game's dynamic state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defect_threshold = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        opponent_cooperation_rate = np.mean(history.opponent_actions[-5:])
        if opponent_cooperation_rate > 0.5:
            self.defect_threshold = 0.9
        else:
            self.defect_threshold = 0.1
        recent_history_factor = Action.C if history.my_payoffs[-1] > state.current_stock / (2 * self.game_description.n_players) else Action.D
        if stock_level > self.defect_threshold or stock_level < 0.25:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return recent_history_factor

class Strategy_EXPLOITATIVE_93(BaseStrategy):
    """
    The Adaptive Stock Depletion (ASD) strategy aims to maximize its payoff by adapting to the current state of the game and the history of opponents' actions.
    It balances exploitation with a degree of caution to avoid depleting the stock too quickly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.num_defectors_prev = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_fraction = state.current_stock / self.game_description.capacity
        self.num_defectors_prev = sum(1 - history.opponent_actions[-1, :])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        threshold = 0.5 if stock_fraction > 0.5 else 0.3 if stock_fraction <= 0.5 and self.num_defectors_prev >= self.game_description.n_players / 2 else 0.7
        if stock_fraction < 0.1:
            return Action.C
        return Action.C if stock_fraction > threshold else Action.D

class Strategy_EXPLOITATIVE_94(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behavior and maximizes payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = []

    def update_opponent_history(self, opponent_actions):
        for action in opponent_actions:
            if action == Action.D:
                self.opponent_history.append({'defected': True})
            else:
                self.opponent_history.append({'defected': False})

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.opponent_actions) > state.round_number - 1:
            opponent_actions = [Action(int(action)) for action in history.opponent_actions[state.round_number - 1, :]]
            self.update_opponent_history(opponent_actions)
        if state.round_number < self.game_description.n_rounds / 2:
            if state.current_stock > 0.75 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C
        elif self.game_description.n_rounds / 2 <= state.round_number < 3 * self.game_description.n_rounds / 4:
            defect_count = sum((1 for opponent in self.opponent_history if opponent.get('defected', False)))
            if defect_count > len(self.opponent_history) / 2:
                return Action.D
            else:
                return Action.C
        elif state.round_number >= 3 * self.game_description.n_rounds / 4:
            if state.current_stock < 0.25 * self.game_description.capacity or state.round_number == self.game_description.n_rounds - 1:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_95(BaseStrategy):
    """
    Exploitative strategy that adapts to the dynamic state and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.my_payoffs = []
        self.opponent_avg_payoff = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        if state.current_stock < 0.25 * self.game_description.capacity or state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        stock_threshold = 0.75 * self.game_description.capacity
        cooperation_rate = (state.current_stock / self.game_description.capacity) ** 2
        if state.current_stock > stock_threshold:
            return Action.D
        elif state.current_stock >= 0.5 * self.game_description.capacity and state.current_stock <= stock_threshold:
            if history is not None:
                opponent_payoffs = np.mean(history.opponent_payoffs, axis=1)
                self.opponent_avg_payoff = np.mean(opponent_payoffs)
                my_avg_payoff = np.mean(self.my_payoffs) if len(self.my_payoffs) > 0 else 0.0
                if self.opponent_avg_payoff > my_avg_payoff:
                    cooperation_rate -= 0.1
                elif self.opponent_avg_payoff < my_avg_payoff:
                    cooperation_rate += 0.1
            return Action.C if random.random() < cooperation_rate else Action.D
        else:
            return Action.D

    def update_my_payoffs(self, payoff: float):
        self.my_payoffs.append(payoff)

class Strategy_EXPLOITATIVE_96(BaseStrategy):
    """
    Adaptive Exploiter strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.6 * game_description.capacity
        self.cooperation_probability = 0
        self.stock_history = []
        self.opponent_actions = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        self.stock_history.append(state.current_stock)
        if len(self.opponent_actions) > 0:
            recent_opponents = sum(history.opponent_actions[-1, :])
            if state.current_stock < self.stock_threshold:
                self.cooperation_probability = 0.5 - state.current_stock / self.stock_threshold / 2
            elif recent_opponents > 0 and state.current_stock > self.stock_threshold:
                self.cooperation_probability = 0.3 + recent_opponents / self.game_description.n_players / 3
        if state.round_number == self.game_description.n_rounds - 1 and state.current_stock < self.stock_threshold:
            self.cooperation_probability = 0
        return Action.C if random.random() < self.cooperation_probability else Action.D

class Strategy_EXPLOITATIVE_97(BaseStrategy):
    """
    Adaptive Exploiter strategy for the Common Pool Resource Game.
    
    This strategy balances short-term gains with long-term sustainability, 
    while adapting to the behaviors of other players in the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_rate = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperations = np.sum(history.opponent_actions, axis=1)
        ac = np.mean(opponent_cooperations / self.game_description.n_players)
        if ac < 0.3:
            self.cooperation_rate -= 0.1
        elif ac > 0.7:
            self.cooperation_rate += 0.1
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock > 0.9 * self.game_description.capacity:
            return Action.C
        if state.current_stock > self.game_description.capacity / 2:
            return Action.D
        elif state.current_stock < self.game_description.capacity / 4:
            return Action.C
        elif ac < 0.5 or random.random() > self.cooperation_rate:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_98(BaseStrategy):
    """
    The Adaptive Stock Predator strategy aims to maximize its payoff by exploiting the common pool resource 
    while adapting to the actions of other players and the dynamic state of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.r_rounds = game_description.n_rounds
        self.theta = self.capacity / (4 * self.n_players)
        self.avg_consumption_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number <= self.r_rounds // 2:
            if state.current_stock >= self.capacity / 2:
                return Action.C
            else:
                return Action.D
        total_consumption = sum(history.opponent_payoffs[-1, :]) + history.my_payoffs[-1]
        avg_consumption = total_consumption / self.n_players
        self.avg_consumption_history.append(avg_consumption)
        if state.round_number % 5 == 0 and state.round_number > self.r_rounds // 2:
            last_5_avg_consumptions = self.avg_consumption_history[-5:]
            new_theta = sum(last_5_avg_consumptions) / len(last_5_avg_consumptions)
            self.theta = new_theta
        if avg_consumption < self.theta and state.current_stock >= self.capacity / 4:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.r_rounds - 1:
            if state.current_stock >= self.capacity / 2:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_99(BaseStrategy):
    """
    Adaptive Stock Raider (ASR) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.low_stock_threshold = 0.25 * game_description.capacity
        self.high_stock_threshold = 0.75 * game_description.capacity
        self.cooperation_threshold = 0.6
        self.window_size = min(3, game_description.n_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.D
        if state.current_stock > self.high_stock_threshold:
            return Action.C
        elif state.current_stock < self.low_stock_threshold:
            return Action.D
        opponent_cooperation_rate = np.mean(history.opponent_actions[max(0, history.my_actions.size - self.window_size):, :])
        if opponent_cooperation_rate > self.cooperation_threshold:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_100(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def calculate_defection_rate(self, history: PlayerHistory) -> float:
        opponent_actions = history.opponent_actions[-1, :]
        return sum((not action for action in opponent_actions)) / self.n_players

    def calculate_punishment_probability(self, opponent_defection_rate: float, num_opponents: int) -> float:
        return opponent_defection_rate * (num_opponents - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.D
        current_stock = state.current_stock
        opponent_defection_rate = self.calculate_defection_rate(history)
        if current_stock >= 0.75 * self.capacity:
            return Action.C
        if opponent_defection_rate > 0.5 or current_stock < 0.25 * self.capacity:
            return Action.D
        punishment_probability = self.calculate_punishment_probability(opponent_defection_rate, self.n_players)
        if random.random() < punishment_probability:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_101(BaseStrategy):
    """
    The Adaptive Exploiter (AE) strategy balances cooperation and defection based on the game's state, history, and parameters.
    AE aims to exploit opponents' behaviors while maintaining a robust performance across various scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def calculate_csr(self, history: PlayerHistory) -> float:
        """
        Calculate average stock consumption rate over last 3 rounds.

        Args:
            history (PlayerHistory): The player's history in the game.

        Returns:
            float: Average stock consumption rate.
        """
        if len(history.my_actions) < 4:
            return 0
        round_consumptions = []
        for i in range(3, 0, -1):
            round_stock_decrease = history.opponent_payoffs[-i - 1].sum() + self.game_description.capacity / (2 * self.game_description.n_players)
            round_consumption = round_stock_decrease / self.game_description.capacity
            round_consumptions.append(round_consumption)
        csr = np.mean(round_consumptions)
        return csr

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_stock_level = history.opponent_payoffs[-1].sum() / self.game_description.capacity
        if prev_stock_level > 0.75:
            return Action.D
        elif prev_stock_level < 0.25:
            return Action.C
        csr = self.calculate_csr(history)
        if csr > 0.5:
            return Action.D
        elif csr < -0.5:
            return Action.C
        probability = random.random()
        if probability < 0.6:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_102(BaseStrategy):
    """
    The Adaptive Stock Guardian strategy aims to balance short-term gains with long-term sustainability,
    while adapting to opponents' behaviors and exploiting their weaknesses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C if state.current_stock >= self.game_description.capacity * 0.8 else Action.D
        avg_payoffs = np.mean(history.my_payoffs) if len(history.my_payoffs) > 1 else 0
        opponent_avg_payoffs = np.mean(history.opponent_payoffs, axis=0)
        min_opponent_consumption_rate = np.inf
        most_cooperative_opponents = []
        for i in range(self.game_description.n_players - 1):
            consumption_rate = history.opponent_actions[:-1, i].mean() if len(history.opponent_actions) > 1 else 0
            if consumption_rate < min_opponent_consumption_rate:
                min_opponent_consumption_rate = consumption_rate
                most_cooperative_opponents = [i]
            elif consumption_rate == min_opponent_consumption_rate:
                most_cooperative_opponents.append(i)
        most_cooperative_opponent = random.choice(most_cooperative_opponents)
        last_opponent_action = history.opponent_actions[-1, most_cooperative_opponent]
        if avg_payoffs >= min(opponent_avg_payoffs) or (len(history.my_payoffs) == 1 and len(history.opponent_actions) > 1):
            return Action.D
        elif last_opponent_action and state.current_stock > self.game_description.capacity * 0.5:
            return Action.C
        if state.round_number + 1 >= self.game_description.n_rounds:
            return Action.D if state.current_stock < self.game_description.capacity * 0.2 else Action.C
        return Action.C

class Strategy_EXPLOITATIVE_104(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.75 * (game_description.capacity / (2 * game_description.n_players))
        self.avg_payoff_window_size = 3
        self.stock_critical_threshold = 0.2 * game_description.capacity
        self.stock_exploitation_threshold = 0.8 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_payoff = np.mean(history.my_payoffs[-self.avg_payoff_window_size:])
        self.threshold = self.adjust_threshold(avg_payoff, self.threshold)
        if state.round_number < self.game_description.n_rounds - 1:
            if avg_payoff > self.threshold and state.current_stock > self.stock_critical_threshold:
                return Action.D
            else:
                return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D

    def adjust_threshold(self, avg_payoff: float, threshold: float) -> float:
        """
        Adjust the exploitation threshold based on the trend of average payoff.
        """
        if avg_payoff > threshold * 1.15:
            return threshold * 0.9
        elif avg_payoff < threshold * 0.9:
            return threshold * 1.1
        else:
            return threshold

class Strategy_EXPLOITATIVE_105(BaseStrategy):
    """
    The Adaptive Stock Raider strategy prioritizes short-term gains by exploiting 
    the common pool resource when the stock level is high or declining rapidly. 
    By adapting to the current state of the game, we aim to maximize payoffs 
    while minimizing the risk of over-exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.my_actions) == 0):
            cooperate_prob = 0.5
        elif state.current_stock >= 0.75 * self.game_description.capacity:
            cooperate_prob = 0.7
        elif 0.5 * self.game_description.capacity <= state.current_stock < 0.75 * self.game_description.capacity:
            cooperate_prob = 0.4
        elif state.current_stock < 0.5 * self.game_description.capacity and state.round_number <= self.game_description.n_rounds // 2:
            cooperate_prob = 0.2
        elif state.current_stock >= 0.25 * self.game_description.capacity and state.round_number > self.game_description.n_rounds * 3 // 4:
            cooperate_prob = 0.9
        else:
            cooperate_prob = 0.05
        if state.round_number == self.game_description.n_rounds - 1:
            cooperate_prob = 0.05
        return Action.C if random.random() < cooperate_prob else Action.D

class Strategy_EXPLOITATIVE_106(BaseStrategy):
    """
    Adaptive Exploiter strategy for Common Pool Resource Game.
    
    This strategy aims to maximize its total payoff by adapting to the behavior of other players and exploiting their actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number <= 5:
            alternate_action = [Action.D, Action.C][state.round_number % 2]
            return alternate_action
        previous_actions = history.opponent_actions[-1, :]
        most_cooperated_last_round = sum((1 for action in previous_actions if action)) >= self.game_description.n_players / 2
        at_least_one_defected_last_round = any((not action for action in previous_actions))
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C if most_cooperated_last_round else Action.D
        elif state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        else:
            return Action.C if at_least_one_defected_last_round else Action.D
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D

class Strategy_EXPLOITATIVE_107(BaseStrategy):
    """
    Exploitative strategy for Common Pool Resource Game.
    Adapts to opponents' behavior and game state while maximizing payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        majority_defected = sum((1 for action in history.opponent_actions[-1] if not action)) > self.game_description.n_players / 2
        if state.current_stock > 0.5 * self.game_description.capacity and (not majority_defected):
            return Action.C
        elif state.current_stock < 0.5 * self.game_description.capacity or state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif sum((1 for action in history.opponent_actions[-1] if action)) > self.game_description.n_players / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_108(BaseStrategy):
    """
    A robust and exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0 or history is None:
            return Action.C
        opponent_actions_last_round = history.opponent_actions[-1]
        all_cooperated_last_round = np.all(opponent_actions_last_round)
        any_defected_last_round = not all_cooperated_last_round
        if round_number < self.rounds // 2:
            return Action.C if current_stock > 0.75 * self.capacity else Action.D if any_defected_last_round else Action.C
        elif round_number >= self.rounds // 2 and round_number < 3 * self.rounds // 4:
            return Action.D if current_stock <= 0.5 * self.capacity else Action.C if all_cooperated_last_round else Action.D
        else:
            return Action.C if current_stock > 0.25 * self.capacity else Action.D

class Strategy_EXPLOITATIVE_110(BaseStrategy):
    """
    An exploitative strategy that adapts to the current state and history of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.num_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        num_cooperators_prev_round = sum(history.opponent_actions[-1, :])
        num_defectors_prev_round = self.num_players - num_cooperators_prev_round - 1
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        stock_level_ratio = current_stock / capacity
        if stock_level_ratio >= 0.75:
            return Action.D
        opponent_behavior = num_cooperators_prev_round - num_defectors_prev_round
        if opponent_behavior > 0:
            return Action.C
        elif opponent_behavior < 0:
            return Action.D
        expected_payoff_C = current_stock / (2 * self.num_players) * (1 - stock_level_ratio)
        expected_payoff_D = current_stock / self.num_players * (1 - stock_level_ratio)
        if math.isnan(expected_payoff_C) or math.isnan(expected_payoff_D):
            return Action.C
        if expected_payoff_C > expected_payoff_D:
            return Action.C
        elif expected_payoff_C < expected_payoff_D:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_111(BaseStrategy):
    """
    An exploitative strategy that adapts to the game state and opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.my_previous_payoff = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock / self.capacity
        current_round = state.round_number
        if current_round == 0 or history is None:
            return random.choice([Action.C, Action.D])
        if current_stock > 0.75:
            return Action.D
        elif 0.25 <= current_stock <= 0.75:
            opponent_payoffs = np.mean(history.opponent_payoffs[-1, :])
            if self.my_previous_payoff is not None and opponent_payoffs > self.my_previous_payoff:
                return Action.C
            else:
                return Action.D
        elif current_stock < 0.25:
            return Action.C
        if current_round == self.game_description.n_rounds - 1:
            return Action.D
        if current_stock < 0.1:
            return random.choice([Action.C, Action.D], p=[0.8, 0.2])
        self.my_previous_payoff = history.my_payoffs[-1]
        return Action.C

class Strategy_EXPLOITATIVE_112(BaseStrategy):
    """
    Exploitative strategy that balances short-term gains with long-term sustainability,
    adapting to the game state and opponent behavior while prioritizing exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.t_threshold_1 = math.ceil(0.25 * game_description.n_rounds)
        self.t_threshold_2 = math.ceil(0.75 * game_description.n_rounds)
        self.stock_high_threshold = 0.75 * self.capacity
        self.stock_low_threshold = 0.25 * self.capacity
        self.opponent_payoff_threshold = 0.5 * self.capacity / self.n_players
        self.defection_likelihood = 0.2
        self.cooperation_likelihood = 0.8

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        opponent_payoffs = history.opponent_payoffs[-1, :]
        if state.round_number < self.t_threshold_1:
            if state.current_stock > self.stock_high_threshold:
                return Action.D
            else:
                return Action.C
        avg_opponent_payoff = np.mean(opponent_payoffs)
        if avg_opponent_payoff > self.opponent_payoff_threshold:
            self.defection_likelihood += 0.2
            self.cooperation_likelihood -= 0.1
            return Action.D
        else:
            return Action.C
        if state.round_number >= self.t_threshold_2:
            if state.current_stock < self.stock_low_threshold:
                return Action.D
            else:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        opponent_cooperation_rate = np.mean(opponent_actions)
        if opponent_cooperation_rate > 0.8:
            self.cooperation_likelihood += 0.15
        if state.current_stock < 0.5 * self.capacity:
            self.cooperation_likelihood -= 0.1
        return Action.C if random.random() < self.cooperation_likelihood else Action.D

class Strategy_EXPLOITATIVE_113(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behavior and the stock trend.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def analyze_opponent_history(self, history: PlayerHistory) -> float:
        opponent_actions = history.opponent_actions
        recent_rounds = min(5, len(opponent_actions))
        cooperations = np.sum(opponent_actions[-recent_rounds:, :], axis=0)
        return np.mean(cooperations)

    def analyze_stock_trend(self, current_round: int, current_stock: float) -> str:
        if current_round < 3:
            return 'stable'
        stock_trend = [current_stock]
        for i in range(1, 4):
            stock_trend.append(stock_trend[-i] - history.opponent_payoffs[-i])
        trend_change = np.diff(stock_trend)
        if all((change > 0 for change in trend_change)) or (all((change == 0 for change in trend_change)) and current_stock < self.capacity * 0.75):
            return 'increasing'
        elif any((change < 0 for change in trend_change)):
            return 'decreasing'
        else:
            return 'stable'

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_round = state.round_number
        current_stock = state.current_stock
        if current_round == 0:
            return Action.C
        if current_stock < 0.25 * self.capacity:
            return Action.D
        opponent_cooperation_rate = self.analyze_opponent_history(history)
        if opponent_cooperation_rate > 0.8:
            return Action.D
        elif opponent_cooperation_rate < 0.5:
            cooperate_probability = 0.6
            return Action.C if random.random() < cooperate_probability else Action.D
        stock_trend = self.analyze_stock_trend(current_round, current_stock)
        if stock_trend == 'increasing' or stock_trend == 'stable':
            cooperate_probability = 0.7
            return Action.C if random.random() < cooperate_probability else Action.D
        else:
            defect_probability = 0.8
            return Action.D if random.random() < defect_probability else Action.C
        expected_cooperation_payoff = current_stock / (2 * self.n_players)
        if expected_cooperation_payoff < 0.75 * self.capacity / (2 * self.n_players):
            return Action.D
        if current_round == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_114(BaseStrategy):
    """
    An exploitative strategy that adapts to the game's dynamics and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        cooperation_threshold = self.capacity / (2 * self.n_players + 1)
        if state.current_stock > cooperation_threshold:
            return Action.C
        if history.opponent_actions[-1, :].sum() / self.game_description.n_players > 0.5:
            return Action.D
        else:
            return Action.C
        total_consumption = state.current_stock / (2 * self.n_players)
        expected_growth = 2 * (state.current_stock - total_consumption) * (1 - state.current_stock / self.capacity)
        if expected_growth > 0:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.1 * self.capacity:
            return Action.C

class Strategy_EXPLOITATIVE_115(BaseStrategy):
    """
    The Adaptive Stock Raider strategy, an exploitative approach to maximize payoffs in a Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponents_behaviors = []
        self.my_payoffs = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        t = state.round_number
        if t == 0 or t <= n:
            return random.choice([Action.C, Action.D])
        stock = state.current_stock
        prev_round_payoffs = history.my_payoffs if len(history.my_payoffs) > 0 else [0]
        if len(self.opponents_behaviors) == 0:
            self.opponents_behaviors.append([bool(action) for action in history.opponent_actions[-1]])
        opponents_behaviors = np.array(self.opponents_behaviors)
        prev_round_opponent_actions = history.opponent_actions[-1] if len(history.opponent_actions) > 0 else [False]
        self.my_payoffs.append(prev_round_payoffs[-1])
        if stock > capacity / 2:
            for i, opponent_action in enumerate(prev_round_opponent_actions):
                if not opponent_action and prev_round_payoffs[i] > prev_round_payoffs[-1]:
                    return Action.D
            if len(self.opponents_behaviors) > 0:
                last_opponent_behavior = np.array([behavior[-1] for behavior in self.opponents_behaviors])
                if sum(last_opponent_behavior == False) >= n // 2 or any((np.all(opp_behavior[:-1]) and (not opp_behavior[-1]) for opp_behavior in opponents_behaviors)):
                    return Action.D
            return Action.C
        else:
            return Action.C
        if t >= self.game_description.n_rounds - n:
            return Action.D

class Strategy_EXPLOITATIVE_116(BaseStrategy):
    """
    Exploitative strategy "Adaptive Stock Harvester" that adapts to the current stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock > 0.75 * capacity:
            return Action.D
        elif 0.25 * capacity <= current_stock <= 0.75 * capacity:
            p = (current_stock / capacity) ** 2
            if random.random() < p:
                return Action.C
            else:
                return Action.D
        elif current_stock < 0.25 * capacity:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_117(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances individual payoff maximization with resource sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C if n_players % 2 == 0 else Action.D
        elif round_number <= self.game_description.n_rounds // 4:
            ci = current_stock / capacity
            if ci > 0.6:
                return Action.C
            else:
                return Action.D
        else:
            if history is not None:
                opponent_actions = history.opponent_actions
                avg_cooperation_rate = np.mean(opponent_actions, axis=1).mean()
            else:
                avg_cooperation_rate = 0.5
            ci = current_stock / capacity * (1 + avg_cooperation_rate)
            if current_stock > capacity / 2 and ci > 0.6:
                return Action.C
            elif current_stock < capacity / 4:
                return Action.D
            else:
                opponent_defection_rates = np.mean(opponent_actions, axis=1)
                if np.mean(opponent_defection_rates) > 0.5:
                    return Action.C
                else:
                    return Action.D
        if round_number >= self.game_description.n_rounds - self.game_description.n_rounds // 4:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_118(BaseStrategy):
    """
    The ASG strategy aims to exploit opponents' behaviors while ensuring long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_growth_threshold = 0.25 * game_description.capacity

    def stock_growth(self, current_stock, capacity):
        return 2 * current_stock * (1 - current_stock / capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        opponent_actions = history.opponent_actions[-2:, :]
        for opponent_action in opponent_actions:
            if all(opponent_action) and history.my_payoffs.mean() > history.opponent_payoffs.mean():
                return Action.C
            elif not any(opponent_action):
                return Action.D
        if self.stock_growth(state.current_stock, self.game_description.capacity) > 0:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_119(BaseStrategy):
    """
    A strategy that balances short-term gains with long-term sustainability while trying to exploit potential weaknesses in opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number <= self.game_description.n_players // 2:
            return Action.C
        avg_opponent_consumption = np.mean(history.opponent_actions[-self.game_description.n_players:, :].sum(axis=1))
        if avg_opponent_consumption < state.current_stock / (2 * self.game_description.n_players):
            return Action.D
        else:
            return Action.C
        aggressive_opponents = np.argmax(np.mean(history.opponent_actions[-self.game_description.n_players:, :], axis=0))
        if np.mean(history.opponent_actions[:, aggressive_opponents]) > state.current_stock / self.game_description.n_players:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < self.game_description.n_players:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_120(BaseStrategy):
    """
    Exploitative strategy: "Adaptive Stock Raider".
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock > self.game_description.capacity / 2:
            self.stock_threshold = self.game_description.capacity / 4
        else:
            self.stock_threshold = state.current_stock / 2
        if history is not None:
            num_defectors_last_round = sum((1 for opp_action in history.opponent_actions[-1, :] if not opp_action))
            if num_defectors_last_round <= self.game_description.n_players // 2 and state.current_stock >= self.stock_threshold:
                action = Action.C
            else:
                action = Action.D
        else:
            action = Action.C
        if state.current_stock < 0.1 * self.game_description.capacity:
            action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return action

class Strategy_EXPLOITATIVE_122(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game.
    Adapts to changing opponent behaviors and adjusts its exploitation level accordingly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.exploitation_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 2 * self.game_description.n_players:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        total_consumption = sum((1 for action in opponent_actions if not action))
        if total_consumption > state.current_stock / 2:
            self.exploitation_threshold -= 0.1
        elif total_consumption < state.current_stock / 4:
            self.exploitation_threshold += 0.1
        if state.current_stock / self.game_description.capacity < self.exploitation_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_123(BaseStrategy):
    """
    Adaptive Stock Raider strategy to maximize payoff by exploiting the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        opponents_cooperated = sum((1 for action in history.opponent_actions[-1, :] if action))
        if current_stock >= 0.75 * self.capacity:
            return Action.D
        elif 0.25 * self.capacity <= current_stock < 0.75 * self.capacity:
            p = current_stock / (2 * self.capacity)
            return Action.C if random.random() < p else Action.D
        else:
            return Action.C
        if opponents_cooperated > self.n_players / 2:
            return Action.D
        else:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_124(BaseStrategy):
    """
    A strategy that balances short-term gains with long-term sustainability by exploiting opponents' behaviors while maintaining a robust and adaptive approach.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_types = [None] * game_description.n_players
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < 3:
            return Action.C if state.round_number == 0 else Action.D
        if state.round_number >= 3 and state.round_number % 3 == 0:
            self.assess_opponent_types(history)
        return self.adaptive_exploit(state, history)

    def assess_opponent_types(self, history: PlayerHistory):
        for opponent in range(self.game_description.n_players - 1):
            cooperations = sum((1 for action in history.opponent_actions[:3, opponent] if action))
            if cooperations >= 2:
                self.opponent_types[opponent] = 'Cooperator'
            elif sum(history.opponent_actions[:3, opponent]) == 0:
                self.opponent_types[opponent] = 'Defector'
            else:
                self.opponent_types[opponent] = 'Unpredictable'

    def adaptive_exploit(self, state: CommonPoolState, history: PlayerHistory) -> Action:
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.game_description.capacity / 4:
            return Action.C
        if state.current_stock > self.game_description.capacity * 0.9:
            return Action.D
        opponent_type = random.choice(self.opponent_types)
        if opponent_type == 'Cooperator':
            return Action.D if state.current_stock > self.game_description.capacity / 2 else Action.C
        elif opponent_type == 'Defector':
            return Action.D if state.current_stock < self.game_description.capacity / 2 else Action.C
        else:
            probability = 0.4 if state.current_stock > self.game_description.capacity / 2 else 0.6
            return Action.C if random.random() < probability else Action.D

class Strategy_EXPLOITATIVE_125(BaseStrategy):
    """
    An exploitative strategy that adapts to opponents' behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.rounds_left_for_cooperation = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        recent_rounds = min(state.round_number, 3)
        avg_opponent_consumption = np.mean(history.opponent_actions[-recent_rounds:] * (self.capacity / self.n_players), axis=0)
        if np.mean(avg_opponent_consumption) > 0.75 * self.capacity / self.n_players:
            return Action.C
        stock_level = state.current_stock / self.capacity
        remaining_rounds = self.game_description.n_rounds - state.round_number
        late_game = remaining_rounds < 0.2 * self.game_description.n_rounds
        if late_game:
            return Action.C
        if remaining_rounds == 1:
            return Action.D
        if self.rounds_left_for_cooperation > 0:
            self.rounds_left_for_cooperation -= 1
            return Action.C
        if state.current_stock == self.capacity or np.isclose(state.current_stock, self.capacity):
            return Action.C
        if stock_level > 0.75:
            return Action.D
        elif stock_level < 0.25:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_126(BaseStrategy):
    """
    An exploitative strategy that adapts to the current stock depletion rate and past payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def calculate_average_coop_payoff(self, history: PlayerHistory) -> float:
        coop_rounds = np.where(history.my_actions)[0]
        avg_coop_payoff = np.mean(history.my_payoffs[coop_rounds])
        return avg_coop_payoff if len(coop_rounds) > 0 else math.nan

    def calculate_average_defect_payoff(self, history: PlayerHistory) -> float:
        defect_rounds = np.where(~history.my_actions)[0]
        avg_defect_payoff = np.mean(history.my_payoffs[defect_rounds])
        return avg_defect_payoff if len(defect_rounds) > 0 else math.nan

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.capacity - state.current_stock <= 0 or history.my_actions.shape[0] < self.game_description.n_players - 1:
            return Action.D
        depletion_rate = (self.capacity - state.current_stock) / self.capacity
        if depletion_rate > 0.5:
            return Action.D
        avg_coop_payoff = self.calculate_average_coop_payoff(history)
        avg_defect_payoff = self.calculate_average_defect_payoff(history)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if not math.isnan(avg_coop_payoff) and (not math.isnan(avg_defect_payoff)):
            return Action.C if avg_coop_payoff > avg_defect_payoff else Action.D
        elif not math.isnan(avg_coop_payoff):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_127(BaseStrategy):
    """
    Exploitative strategy that adapts to the current stock level and opponents' cooperation rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.round_count = 0
        self.acr_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.round_count += 1
        if self.round_count == 1:
            return Action.C
        stock_level = state.current_stock / self.capacity
        last_round_opponent_actions = history.opponent_actions[-1, :] if history else None
        if self.game_description.n_players == 2 and last_round_opponent_actions is not None and all(last_round_opponent_actions):
            return Action.D
        if stock_level < 0.1:
            return Action.D
        if self.round_count == self.game_description.n_rounds:
            return Action.D
        if stock_level > 0.75:
            return Action.D
        if self.round_count < self.game_description.n_rounds // 2:
            return Action.C
        if len(self.acr_history) > 5:
            acr = np.mean(self.acr_history[-5:])
        else:
            acr = np.mean(self.acr_history)
        if last_round_opponent_actions is not None and any(last_round_opponent_actions):
            self.acr_history.append(np.mean(last_round_opponent_actions))
        if acr < 0.5:
            return Action.D
        else:
            return Action.C
        if stock_level < 0.25 and self.round_count > 3 * self.game_description.n_rounds // 4:
            return Action.D

class Strategy_EXPLOITATIVE_128(BaseStrategy):
    """
    Exploitative strategy that adapts to the game state and history while exploiting opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        prev_consumption = sum(history.opponent_actions[-1, :]) * self.capacity / self.game_description.n_players + (not history.my_actions[-1]) * self.capacity / self.game_description.n_players
        opponents_defected = not all(history.opponent_actions[-1, :])
        if current_stock > 0.75 * self.capacity:
            return Action.D if opponents_defected or prev_consumption > 0.5 * self.capacity else Action.C
        elif 0.5 * self.capacity <= current_stock < 0.75 * self.capacity:
            return Action.D if prev_consumption > 0.5 * self.capacity else Action.C
        else:
            return Action.D if any((not opponent for opponent in history.opponent_actions[-1, :])) else Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if current_stock <= 0:
            return Action.C

class Strategy_EXPLOITATIVE_129(BaseStrategy):
    """
    Adaptive Stock Raider strategy.
    
    This strategy adapts to the dynamic state of the common pool and opponent behavior,
    aiming to maximize individual payoff while being robust to a wide range of opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.opponent_payoffs = [[] for _ in range(game_description.n_players)]
        self.own_payoff = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        average_opponent_payoff = np.mean([payoff for payoff_list in self.opponent_payoffs for payoff in payoff_list])
        if history is not None:
            opponent_actions_last_round = history.opponent_actions[-1]
            own_payoff_last_round = history.my_payoffs[-1]
            self.stock_history.append(current_stock)
            opponents_defected_last_round = sum((1 for action in opponent_actions_last_round if not action))
            if opponents_defected_last_round > self.game_description.n_players / 2:
                return Action.D
            own_payoff_average_opponent_payoff_diff = average_opponent_payoff - own_payoff_last_round
        else:
            own_payoff_average_opponent_payoff_diff = 0
        if current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        if current_stock > 0.75 * self.game_description.capacity or own_payoff_average_opponent_payoff_diff > 0:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_130(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game.
    
    Cooperates initially to gather information about opponents, then adapts its strategy based on 
    the current stock level and the behavior of its opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        SLT = self.game_description.capacity / 2
        defect_counts = np.sum(history.opponent_actions, axis=0)
        cooperate_counts = history.opponent_actions.shape[0] - defect_counts
        for i in range(self.game_description.n_players):
            if i == 0:
                continue
            if defect_counts[i - 1] > cooperate_counts[i - 1]:
                return Action.D
            elif cooperate_counts[i - 1] > defect_counts[i - 1]:
                return Action.C
        if state.current_stock < SLT:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_131(BaseStrategy):
    """
    Exploitative strategy that adapts to the dynamic state of the game and opponents' behaviors.
    Balances short-term gains with long-term sustainability by cooperating when stock levels are high or opponents cooperate,
    and defecting when stock levels are low or opponents defect.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if state.current_stock < 0.75 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        avg_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
        avg_cooperative_payoff = state.current_stock / (2 * self.n_players)
        if avg_opponent_payoff >= avg_cooperative_payoff:
            return Action.D
        elif state.current_stock > 0.5 * self.game_description.capacity:
            return Action.C
        else:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        elif state.current_stock > 0.9 * self.game_description.capacity:
            return Action.C

class Strategy_EXPLOITATIVE_132(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game.
    
    This strategy initially cooperates to gather information about opponents' behavior. 
    It then exploits cooperation by defecting when the average payoff is high, while avoiding over-exploitation that might lead to stock depletion.
    The strategy also punishes opponents for over-exploitation and adapts its behavior based on the current state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.max_possible_payoff = game_description.capacity / (2 * game_description.n_players)
        self.punish_cooperate = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_payoff_prev_rounds = np.mean(history.my_payoffs)
        if avg_payoff_prev_rounds > 0.75 * self.max_possible_payoff and (not self.punish_cooperate):
            return Action.D
        elif state.current_stock < 0.25 * self.game_description.capacity:
            self.punish_cooperate = True
            return Action.C
        elif avg_payoff_prev_rounds < 0.5 * self.max_possible_payoff or self.punish_cooperate:
            self.punish_cooperate = False
            return Action.C
        elif state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_133(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game.
    
    Initially cooperates to gather information about opponents' behavior, 
    then adapts to changing game conditions by balancing cooperation and defection based on stock levels and opponent payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
        depletion_rate = (self.capacity - state.current_stock) / self.capacity
        if state.current_stock < 2 * self.n_players:
            return Action.C
        elif history and history.my_actions.size > 0 and (avg_opponent_payoff > self.capacity / self.n_players):
            return Action.D
        if depletion_rate > 0.5 and avg_opponent_payoff < self.capacity / (2 * self.n_players):
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_134(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors and maximizes payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.depletion_threshold = 0.2 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        opponent_actions = history.opponent_actions[-1]
        avg_consumption = self.calculate_avg_consumption(opponent_actions)
        if state.current_stock < self.depletion_threshold or (state.round_number == self.game_description.n_rounds - 1 and state.current_stock < 0.1 * self.game_description.capacity):
            return Action.C
        if avg_consumption < 0.5 * self.game_description.capacity / self.game_description.n_players:
            return Action.C
        else:
            return Action.D

    def calculate_avg_consumption(self, opponent_actions: NDArray[np.bool_]) -> float:
        total_consumption = np.sum(opponent_actions) * (self.game_description.capacity / (2 * self.game_description.n_players)) + np.sum(~opponent_actions) * (self.game_description.capacity / self.game_description.n_players)
        return total_consumption / self.game_description.n_players

class Strategy_EXPLOITATIVE_135(BaseStrategy):
    """
    Exploitative strategy that adapts to the dynamic state of the game and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_consistency = None
        self.consistent_cooperation_count = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        if self.opponent_consistency is None:
            n_players = self.game_description.n_players
            self.opponent_consistency = [False] * (n_players - 1)
            self.consistent_cooperation_count = [0] * (n_players - 1)
        capacity = self.game_description.capacity
        stock_fraction = state.current_stock / capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock_fraction < 0.25:
            return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        for i, action in enumerate(opponent_actions):
            if action and self.consistent_cooperation_count[i] == 2:
                self.opponent_consistency[i] = True
            elif not action and self.consistent_cooperation_count[i] == -2:
                self.opponent_consistency[i] = False
            else:
                self.consistent_cooperation_count[i] += 1 if action else -1
        for i, is_consistent in enumerate(self.opponent_consistency):
            if is_consistent and history.my_payoffs[-1] > history.opponent_payoffs[-1, i]:
                return Action.D
            elif not is_consistent and history.my_payoffs[-1] < history.opponent_payoffs[-1, i]:
                return Action.C
        if stock_fraction >= 0.75:
            return Action.C
        elif 0.5 <= stock_fraction < 0.75:
            return random.choice([Action.D] * 7 + [Action.C] * 3)
        else:
            return Action.D

class Strategy_EXPLOITATIVE_136(BaseStrategy):
    """
    Adaptive Exploiter Strategy for Common Pool Resource Game.
    
    Initially cooperates to gather information and then adapts based on 
    current stock level, exploiting opponents' behaviors while maintaining 
    long-term sustainability. Switches to aggressive defect-only strategy 
    if group's average payoff is too low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        t = state.round_number + 1
        if current_stock >= 0.75 * capacity:
            return Action.D
        elif current_stock <= 0.25 * capacity:
            return Action.C
        else:
            p = (current_stock / capacity) ** 2
            return Action.C if random.random() < p else Action.D
        if t == self.game_description.n_rounds // 2:
            avg_payoff = np.mean(history.my_payoffs)
            max_possible_payoff = capacity / (2 * self.game_description.n_players) * self.game_description.n_rounds
            if avg_payoff < 0.5 * max_possible_payoff:
                return Action.D
        elif t > self.game_description.n_rounds // 2:
            p = (current_stock / capacity) ** 2
            return Action.C if random.random() < p else Action.D
        elif t == self.game_description.n_rounds:
            return Action.D

class Strategy_EXPLOITATIVE_137(BaseStrategy):
    """
    The Adaptive Exploiter (AE) strategy for the Common Pool Resource Game.
    
    AE aims to maximize its total payoff by dynamically adjusting its cooperation level 
    based on the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.theta = 0.7 * self.capacity
        self.defect_prob = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions
        opponent_payoffs = history.opponent_payoffs
        opponents_tend_to_defect = np.mean(opponent_actions[-1, :]) < 0.5
        high_payoff_opponents = np.any(opponent_payoffs[-1, :] > state.current_stock / self.n_players)
        if opponents_tend_to_defect or high_payoff_opponents:
            self.defect_prob += 0.1
        else:
            self.defect_prob -= 0.1
        self.defect_prob = max(0, min(self.defect_prob, 1))
        rounds_remaining = self.game_description.n_rounds - state.round_number
        self.theta *= rounds_remaining / self.game_description.n_rounds
        if state.current_stock > self.theta:
            return Action.C
        elif random.random() < self.defect_prob:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_138(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behavior and game state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.avg_opponent_consumption = 0
        self.threshold = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        if state.round_number == 0:
            if state.current_stock >= capacity * 0.75:
                return Action.D
            else:
                return Action.C
        else:
            opponent_consumptions = history.opponent_payoffs[-1, :] / (state.current_stock / n_players)
            self.avg_opponent_consumption = np.mean(opponent_consumptions)
            growth_rate = 2 * state.current_stock * (1 - state.current_stock / capacity) / capacity
            self.threshold = self.avg_opponent_consumption * (1 - growth_rate)
            if self.avg_opponent_consumption >= state.current_stock / (2 * n_players):
                return Action.D
            elif state.current_stock < capacity * 0.25 or growth_rate > 0.5:
                return Action.C
            elif self.avg_opponent_consumption > self.threshold:
                return Action.D
            else:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_139(BaseStrategy):
    """
    An exploitative strategy that adapts to opponents' behaviors and stock dynamics.
    Cooperates in initial rounds, then switches based on stock level, opponent defection rate, 
    and endgame conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / 3
        self.stock_threshold_low = game_description.capacity / 6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number <= 2:
            return Action.C
        if state.current_stock == 0:
            return Action.C
        if state.current_stock > self.stock_threshold:
            return Action.C
        opponent_defections = np.sum(history.opponent_actions[-1, :])
        defection_rate = opponent_defections / self.game_description.n_players
        if defection_rate > 0.5:
            return Action.D
        if state.current_stock < self.stock_threshold_low:
            return Action.D
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_140(BaseStrategy):
    """
    An adaptive strategy that exploits opponents' cooperation while maintaining a sustainable resource level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        prev_cooperators = sum((1 for action in history.opponent_actions[-1, :] if action))
        θ = 0.5
        ε = 0.1
        if state.current_stock < 0.2 * self.capacity:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif prev_cooperators / self.n_players < θ:
            return Action.D
        elif state.current_stock > 0.8 * self.capacity and prev_cooperators / self.n_players >= θ:
            return Action.C
        elif random.random() < ε:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_141(BaseStrategy):
    """
    Exploitative strategy designed to maximize payoffs by adapting to changing game conditions and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k = 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if self.game_description.n_rounds - state.round_number <= 1:
            return Action.D
        stock = state.current_stock
        capacity = self.game_description.capacity
        if stock > 0.75 * capacity:
            return Action.D
        elif stock < 0.25 * capacity or stock < self.game_description.n_players * (stock / (2 * self.game_description.n_players)):
            return Action.C
        coop_freq = self.analyze_history(history, self.k)
        if coop_freq > 0.5:
            return Action.C
        else:
            return Action.D

    def analyze_history(self, history: PlayerHistory, k: int) -> float:
        opponent_actions = history.opponent_actions[-k:, :]
        coop_count = np.sum(opponent_actions == True)
        return coop_count / (k * self.game_description.n_players - 1)

class Strategy_EXPLOITATIVE_142(BaseStrategy):
    """
    Exploitative Strategy: "Adaptive Stock Raider"
    
    Decision Rules:
    1. Initial Round (t=1): Cooperate (C) to gather information about opponents' behaviors and avoid early stock depletion.
    2. Subsequent Rounds (t>1):
        * If the current stock level is above 75% of capacity, Defect (D) to maximize short-term gains.
        * If the current stock level is between 50% and 75% of capacity, Cooperate (C) to balance individual gain with sustainable stock management.
        * If the current stock level is below 50% of capacity, Defect (D) aggressively to capitalize on remaining resources before they dwindle.
    3. Opponent Behavior Analysis: Monitor opponents' actions in previous rounds and adjust strategy accordingly:
        + If most opponents (≥ n/2) Cooperate, Defect (D) to exploit their cooperation.
        + If most opponents (≥ n/2) Defect, Cooperate (C) to conserve resources and avoid further depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        opponent_actions = history.opponent_actions[-1, :]
        most_opponents_cooperate = np.sum(opponent_actions) >= self.game_description.n_players // 2
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock_ratio > 0.75 or (most_opponents_cooperate and stock_ratio > 0.5):
            return Action.D
        elif stock_ratio < 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_143(BaseStrategy):
    """
    The Adaptive Hawk-Dove strategy balances short-term exploitation with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_defection_rates = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if history is not None:
            if self.opponent_defection_rates is None:
                self.opponent_defection_rates = [sum(opponent_actions) / (state.round_number + 1) for opponent_actions in history.opponent_actions.T]
            else:
                self.opponent_defection_rates = [(opponent_rate * state.round_number + int(not history.opponent_actions[-1, i])) / (state.round_number + 1) for i, opponent_rate in enumerate(self.opponent_defection_rates)]
        if state.round_number == 0:
            return Action.C
        p_defect = 0.5
        if current_stock > 0.75 * capacity:
            return Action.D if random.random() < p_defect else Action.C
        avg_previous_payoff = np.mean(history.my_payoffs) if history is not None and len(history.my_payoffs) > 1 else 0
        expected_defect_payoff = current_stock / self.game_description.n_players
        if current_stock >= 0.25 * capacity and avg_previous_payoff > expected_defect_payoff:
            return Action.C
        for opponent_rate in self.opponent_defection_rates or []:
            if opponent_rate > 0.75:
                p_defect = max(p_defect, 0.7)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D if random.random() < p_defect else Action.C

class Strategy_EXPLOITATIVE_144(BaseStrategy):
    """
    Exploitative strategy designed to adapt to a wide range of opponent behaviors 
    while prioritizing self-interest in times of scarcity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        prev_stock = state.current_stock
        opponents_cooperated = sum(history.opponent_actions[-1, :])
        capacity = self.game_description.capacity
        n = self.game_description.n_players
        rounds_remaining = self.game_description.n_rounds - state.round_number
        if prev_stock > 0.75 * capacity:
            p = (prev_stock / capacity) ** 0.5
            return Action.C if random.random() < p else Action.D
        elif prev_stock < 0.25 * capacity:
            return Action.D
        else:
            p = (opponents_cooperated / n) ** 0.5
            return Action.C if random.random() < p else Action.D
        if rounds_remaining <= 5:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_145(BaseStrategy):
    """
    Exploitative strategy that adapts to the game state and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.75 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.D
        prev_opponent_actions = history.opponent_actions[-1]
        prev_payoff = history.my_payoffs[-1]
        D_prev = np.sum(prev_opponent_actions == 0)
        if state.current_stock >= self.stock_threshold:
            action = Action.C
        else:
            action = Action.D
        if D_prev >= 2:
            action = Action.D
        max_payoff = state.current_stock / self.game_description.n_players
        if prev_payoff < 0.5 * max_payoff:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_146(BaseStrategy):
    """
    An adaptive exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.opponent_actions = []
        self.exploitation_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_history.append(state.current_stock)
            return Action.C
        current_stock = state.current_stock
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        if current_stock > 0.75 * self.game_description.capacity:
            action = Action.D
        elif 0.25 * self.game_description.capacity <= current_stock <= 0.75 * self.game_description.capacity:
            if opponent_cooperators > self.exploitation_threshold * self.game_description.n_players:
                action = Action.D
            else:
                action = Action.C
        else:
            action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        self.stock_history.append(current_stock)
        self.opponent_actions.append(history.opponent_actions[-1, :])
        return action

class Strategy_EXPLOITATIVE_147(BaseStrategy):
    """
    Exploitative strategy that adapts to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = game_description.capacity / (2 * game_description.n_players)
        self.low_stock_threshold = game_description.capacity / 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        num_defectors_prev = sum((not opponent_action for opponent_action in history.opponent_actions[-1, :]))
        if state.current_stock > self.cooperation_threshold:
            action = Action.C
        else:
            action = Action.D
        if num_defectors_prev >= self.game_description.n_players / 2:
            action = Action.D
        if state.current_stock < self.low_stock_threshold:
            return Action.C
        return action

class Strategy_EXPLOITATIVE_149(BaseStrategy):
    """
    This strategy aims to maximize its payoff by adaptively exploiting the common pool resource while considering the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        if state.round_number == 0:
            if capacity > 10 * n:
                return Action.C
            else:
                return Action.D
        avg_consumption = self._calculate_average_consumption(history)
        stock_ratio = state.current_stock / capacity
        if stock_ratio > 0.75:
            return Action.C
        elif 0.25 <= stock_ratio < 0.75 and avg_consumption < capacity / (2 * n):
            return Action.D
        elif stock_ratio < 0.25:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if stock_ratio > 0.5:
                return Action.D
        return Action.C

    def _calculate_average_consumption(self, history: PlayerHistory):
        total_payoffs = np.sum(history.my_payoffs)
        avg_consumption_per_round = total_payoffs / len(history.my_payoffs)
        opponent_total_payoffs = np.sum(np.sum(history.opponent_payoffs, axis=0))
        opponent_avg_consumption_per_round = opponent_total_payoffs / (len(history.my_payoffs) * self.game_description.n_players - 1)
        return avg_consumption_per_round + opponent_avg_consumption_per_round

class Strategy_EXPLOITATIVE_150(BaseStrategy):
    """
    Exploitative strategy that adapts to changing game conditions and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.D
        if state.current_stock < 0.25 * self.capacity:
            return Action.C
        opponent_defected = np.any(~history.opponent_actions[-1, :])
        if state.current_stock > 0.75 * self.capacity and opponent_defected:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_151(BaseStrategy):
    """
    Exploitative strategy for the Common Pool Resource Game.
    
    The Adaptive Stock Hawk (ASH) combines elements of game theory and adaptive decision-making 
    to respond effectively to various opponent behaviors and maximize payoffs in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number < self.game_description.n_rounds // 2:
            if state.current_stock > 0.75 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C
        elif state.round_number >= self.game_description.n_rounds // 2 and state.round_number <= 3 * self.game_description.n_rounds // 4:
            opponents_behavior = np.sum(history.opponent_actions[-1, :])
            if opponents_behavior > self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D
        elif state.round_number > 3 * self.game_description.n_rounds // 4:
            if state.current_stock < 0.25 * self.game_description.capacity:
                return Action.C
            elif state.current_stock < 0.5 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_152(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game, 
    balancing short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_reputation = [0.5] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        previous_round_defections = sum((1 for action in previous_round_opponent_actions if not action))
        if state.current_stock > 0.5 * self.game_description.capacity:
            return Action.D if previous_round_defections > 0 else Action.C
        elif state.current_stock <= 0.5 * self.game_description.capacity and state.current_stock > 0.2 * self.game_description.capacity:
            for i, action in enumerate(previous_round_opponent_actions):
                if action:
                    self.opponent_reputation[i] += 0.1
                else:
                    self.opponent_reputation[i] -= 0.1
            previous_round_cooperations = sum((1 for opponent, action in zip(self.opponent_reputation, previous_round_opponent_actions) if action and opponent > 0.5))
            return Action.C if previous_round_cooperations >= self.game_description.n_players // 2 else Action.D
        elif state.round_number >= self.game_description.n_rounds - 2 or state.current_stock <= 0.2 * self.game_description.capacity:
            return Action.D
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D

class Strategy_EXPLOITATIVE_153(BaseStrategy):
    """
    The Adaptive Stock Raider strategy is designed to exploit a wide range of opponent behaviors while adapting to the game's dynamic state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.current_stock > 0.75 * self.game_description.capacity:
            action = Action.C
        else:
            action = Action.D
        opponent_actions = history.opponent_actions[-1, :]
        cooperate_count = np.sum(opponent_actions)
        if cooperate_count > self.game_description.n_players / 2:
            return Action.D
        num_rounds_to_consider = min(3, state.round_number + 1)
        my_payoffs = history.my_payoffs[-num_rounds_to_consider:]
        avg_opponent_payoffs = np.mean(history.opponent_payoffs[-num_rounds_to_consider:, :], axis=0)
        if np.sum(my_payoffs) < np.sum(avg_opponent_payoffs):
            return Action.D if action == Action.C else Action.C
        if state.round_number + 1 >= self.game_description.n_rounds:
            return Action.D
        return action

class Strategy_EXPLOITATIVE_154(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to the game state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.trust_metrics = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_payoffs = history.my_payoffs[-1] if history.my_payoffs.size > 1 else history.my_payoffs
        avg_prev_payoff = np.mean(prev_round_payoffs)
        theta = 0.5 * self.game_description.capacity / self.game_description.n_players
        if avg_prev_payoff > theta:
            return Action.D
        if self.trust_metrics is None:
            self.trust_metrics = np.zeros(self.game_description.n_players - 1)
        for i in range(self.game_description.n_players - 1):
            if history.opponent_actions[-1, i]:
                self.trust_metrics[i] += 0.1
            else:
                self.trust_metrics[i] -= 0.2
        T_avg = np.mean(self.trust_metrics)
        if T_avg < 0.5:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1 or self.game_description.n_players == 2:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_155(BaseStrategy):
    """
    Exploitative strategy to maximize individual payoff by adapting to game state and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.my_payoff_last_round = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        high_threshold = 0.75 * self.game_description.capacity
        low_threshold = 0.5 * self.game_description.capacity
        opponent_payoffs_last_round = history.opponent_payoffs[-1, :]
        avg_opponent_payoff = np.mean(opponent_payoffs_last_round)
        if state.current_stock > high_threshold:
            return Action.D
        elif state.current_stock >= low_threshold:
            if avg_opponent_payoff > self.my_payoff_last_round:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_156(BaseStrategy):
    """
    An exploitative strategy that adapts to the game's state and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_behavior = []
        self.average_opponent_defection = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number < self.game_description.n_rounds // 2:
            if state.current_stock > 0.75 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C
        elif state.round_number >= self.game_description.n_rounds // 2 and state.round_number < 3 * self.game_description.n_rounds // 4:
            if history is not None:
                opponent_actions = history.opponent_actions[-1, :]
                self.opponent_behavior.append(np.mean(opponent_actions))
                self.average_opponent_defection = np.mean(self.opponent_behavior)
            if self.average_opponent_defection > 0.5:
                return Action.D
            else:
                return Action.C
        elif state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_157(BaseStrategy):
    """
    The Adaptive Stock Hawk strategy balances exploitation and conservation by adapting to the current stock level, opponents' behaviors, and game progression.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if history is None:
            return Action.C
        stock_level_ratio = state.current_stock / self.game_description.capacity
        if stock_level_ratio >= 0.75:
            return Action.D
        elif stock_level_ratio >= 0.5:
            return Action.C
        else:
            return Action.D
        opponents_cooperated = sum(history.opponent_actions[-1, :])
        if opponents_cooperated >= self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock_level_ratio < 0.25:
            return Action.C

class Strategy_EXPLOITATIVE_158(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Stock Raider (ASR)
    
    This strategy balances exploration, exploitation, and adaptation to opponents' behaviors.
    It initially explores the game environment, gathers information about opponents' strategies,
    assesses the current state of the game, analyzes opponents' payoffs, and exploits potential weaknesses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.rounds_played = 0
        self.stock_level = game_description.capacity
        self.avg_payoff_D = None
        self.avg_payoff_C = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.stock_level = state.current_stock
        self.rounds_played = state.round_number
        if self.rounds_played < math.ceil(0.1 * self.game_description.n_rounds):
            return Action.D if random.random() < 0.5 else Action.C
        if self.stock_level > 0.75 * self.game_description.capacity:
            action = Action.D
        else:
            action = Action.C
        if history is not None:
            opponent_payoffs_D = np.array([payoff for payoff, action in zip(history.opponent_payoffs[-1], history.opponent_actions[-1]) if not action])
            opponent_payoffs_C = np.array([payoff for payoff, action in zip(history.opponent_payoffs[-1], history.opponent_actions[-1]) if action])
            self.avg_payoff_D = np.mean(opponent_payoffs_D) if len(opponent_payoffs_D) > 0 else None
            self.avg_payoff_C = np.mean(opponent_payoffs_C) if len(opponent_payoffs_C) > 0 else None
        if self.avg_payoff_D is not None and self.avg_payoff_C is not None:
            action = Action.D if self.avg_payoff_D > self.avg_payoff_C else Action.C
        if self.rounds_played == self.game_description.n_rounds - 1:
            return Action.D
        if self.stock_level < 0.25 * self.game_description.capacity:
            return Action.C
        return action

class Strategy_EXPLOITATIVE_159(BaseStrategy):
    """
    The Adaptive Exploiter (AE) strategy balances exploitation and sustainability in the Common Pool Resource Game.
    It maximizes individual payoffs while adapting to changing game conditions and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_thresholds = {'exploit': 0.75 * game_description.capacity, 'conserve': 0.25 * game_description.capacity}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        cooperators = sum(opponent_actions)
        defectors = len(opponent_actions) - cooperators
        if state.current_stock > self.capacity_thresholds['exploit']:
            return Action.D
        elif state.current_stock < self.capacity_thresholds['conserve']:
            return Action.C
        elif defectors > cooperators:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_160(BaseStrategy):
    """
    A hybrid exploitative strategy that balances short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_threshold = game_description.capacity / 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        previous_round_defections = sum((1 for action in history.opponent_actions[-1, :] if not action))
        if previous_round_defections > self.game_description.n_players / 2:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock <= self.capacity_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_161(BaseStrategy):
    """
    An exploitative strategy that adapts to the dynamic state of the game and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        S_prev = history.my_payoffs.shape[0] > 1 and current_stock >= history.my_payoffs[-2] * self.n_players / (2 * self.game_description.capacity)
        if history.my_actions.shape[0] == 1:
            return Action.C
        C_cnt = sum(history.opponent_actions[-1, :])
        D_cnt = self.n_players - 1 - C_cnt
        T = 0.5 * (C_cnt / self.n_players) + 0.25 * (D_cnt / self.n_players)
        if current_stock < 0.25 * self.capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if S_prev or T > 0.6:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_162(BaseStrategy):
    """
    The Adaptive Stock Raider strategy aims to maximize individual payoffs by adaptively responding 
    to the game state and history of opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_count = 0
        self.avg_coop_rate = 0.5

    def calculate_avg_coop_rate(self, history):
        if len(history.my_actions) < 3:
            return 0.5
        avg_coop_rate = np.mean(~history.opponent_actions[-3:, :])
        return avg_coop_rate

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_defections = np.sum(~history.opponent_actions[-1, :])
        self.defection_count = opponent_defections / self.game_description.n_players
        self.avg_coop_rate = self.calculate_avg_coop_rate(history)
        if state.current_stock > 0.75 * self.game_description.capacity and state.round_number < self.game_description.n_rounds // 2:
            return Action.D
        elif state.round_number >= self.game_description.n_rounds // 2:
            if self.defection_count > 0.5:
                return Action.D
            elif self.avg_coop_rate > 0.7:
                return Action.C
            else:
                return random.choice([Action.C, Action.D])
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_163(BaseStrategy):
    """
    Exploitative strategy that adapts to the average depletion rate of the common pool.
    Cooperates in initial rounds, and defects when the average depletion rate exceeds a certain threshold.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.k = 3
        self.theta = 0.4
        self.sigma = 20

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.current_stock <= self.sigma:
            return Action.C
        avg_depletion_rate = self.calculate_avg_depletion_rate(state, history)
        if avg_depletion_rate > self.theta or state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.C

    def calculate_avg_depletion_rate(self, state: CommonPoolState, history: PlayerHistory):
        total_depletion = 0
        for i in range(max(0, state.round_number - self.k), state.round_number):
            if i == 0:
                stock_before_round = self.game_description.capacity
            else:
                stock_before_round = history.my_payoffs[i - 1] * 2 * self.game_description.n_players + (self.game_description.capacity - history.my_payoffs[i - 1] * self.game_description.n_players)
            total_depletion += (stock_before_round - state.current_stock) / self.game_description.capacity
        return total_depletion / min(self.k, state.round_number)

class Strategy_EXPLOITATIVE_164(BaseStrategy):
    """
    A strategy that adapts to opponents' behavior and balances short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.T = game_description.capacity / (2 * game_description.n_players + 1)
        self.S_recovery = game_description.capacity / (2 * game_description.n_players + 2)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        num_defectors_prev = sum((not action for action in history.opponent_actions[-1, :]))
        if state.current_stock > self.T and num_defectors_prev == 0:
            return Action.C
        elif state.current_stock <= self.T and num_defectors_prev > 0:
            return Action.D
        if state.current_stock < self.S_recovery:
            return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_166(BaseStrategy):
    """
    An adaptive strategy that balances short-term gains with long-term sustainability.
    It exploits opponents' behavior while adapting to the changing state of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        num_defectors = sum((1 - action for action in history.opponent_actions[-1, :]))
        stock_ratio = state.current_stock / self.game_description.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if num_defectors == self.game_description.n_players // 2 and stock_ratio < 0.5:
            return Action.C
        if num_defectors > self.game_description.n_players / 2 and stock_ratio >= 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_167(BaseStrategy):
    """
    An exploitative strategy designed to adapt to the dynamic state of the game and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.OCR = 0

    def calculate_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        opponent_actions = history.opponent_actions[-1, :]
        return np.mean(opponent_actions)

    def adjust_decision_rule(self, stock_proportion: float, OCR: float) -> None:
        if OCR > 0.5:
            self.threshold_high = 0.67
            self.threshold_low = 0.33

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_proportion = state.current_stock / self.game_description.capacity
        if history is not None:
            self.OCR = self.calculate_opponent_cooperation_rate(history)
        threshold_high = 0.75
        threshold_low = 0.5
        self.adjust_decision_rule(stock_proportion, self.OCR)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif stock_proportion > threshold_high:
            return Action.D
        elif stock_proportion >= threshold_low and self.OCR > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_168(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behavior and the dynamic state of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        threshold_stock = capacity / 2
        if state.round_number == 0:
            return Action.D if state.current_stock >= threshold_stock else Action.C
        total_consumption_prev = sum(history.my_payoffs[-1] + history.opponent_payoffs[-1, :])
        EI = total_consumption_prev / capacity * n_players
        if EI >= 0.5 or state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock >= threshold_stock:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_169(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.75 * game_description.capacity
        self.n_consecutive_defects = 2
        self.opponent_cooperation_levels = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.opponent_cooperation_levels = history.opponent_actions.mean(axis=1)
        if state.current_stock > self.stock_threshold:
            if not (self.opponent_cooperation_levels[-1] == 0 or self.opponent_cooperation_levels[-1] == 1):
                return Action.D
        elif state.current_stock <= self.stock_threshold or self.opponent_cooperation_levels[-1] == 1:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_170(BaseStrategy):
    """
    A strategy that adaptively responds to the current state and history of the game,
    aiming to maximize payoffs while considering potential future consequences.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consume_threshold = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        stock_threshold = capacity * (1 - 1 / (2 * n_players))
        if state.round_number == 0 or history is None:
            return Action.C
        previous_consumptions = np.sum(history.opponent_actions, axis=1) + np.array(history.my_actions)
        total_previous_consumption = np.sum(previous_consumptions)
        if total_previous_consumption / (n_players * state.current_stock / n_players) > self.consume_threshold:
            return Action.D
        if state.current_stock > stock_threshold:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_171(BaseStrategy):
    """
    Adaptive Exploitation strategy combines observation, adaptation, and exploitation to maximize payoffs in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.observationPhase = True
        self.exploreExploitThreshold = 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or self.observationPhase:
            action = random.choice([Action.C, Action.D])
            if state.round_number >= self.exploreExploitThreshold - 1:
                self.observationPhase = False
        else:
            opponent_actions_last_round = history.opponent_actions[-1, :]
            majority_action = np.mean(opponent_actions_last_round) > 0.5
            if majority_action:
                action = Action.D
            elif not majority_action and np.mean(opponent_actions_last_round) < 0.5:
                action = Action.C
            else:
                action = random.choice([Action.C, Action.D])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        return action

class Strategy_EXPLOITATIVE_172(BaseStrategy):
    """
    Exploitative strategy that adapts to the game state and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.5 * game_description.capacity
        self.min_stock_level = game_description.capacity
        self.coop_rate_estimates = [0.5] * game_description.n_players
        self.previous_stocks = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        self.previous_stocks.append(state.current_stock)
        if len(self.previous_stocks) > 2 and all((self.previous_stocks[i] < self.previous_stocks[i - 1] for i in range(1, len(self.previous_stocks)))):
            self.stock_threshold *= 0.9
        if history:
            opponent_actions = history.opponent_actions[-1, :]
            self.coop_rate_estimates = [min(max(coop_rate_estimate + (action == Action.C) / state.round_number, 0), 1) for coop_rate_estimate, action in zip(self.coop_rate_estimates, opponent_actions)]
        self.min_stock_level = min(self.min_stock_level, state.current_stock)
        self.stock_threshold = max(0.5 * self.game_description.capacity, self.min_stock_level)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.2 * self.game_description.capacity:
            return Action.C
        if state.current_stock >= self.stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_173(BaseStrategy):
    """
    Adaptive Stock Exploiter strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        opponent_actions = np.array(history.opponent_actions[-1, :])
        n_cooperators = sum(opponent_actions)
        avg_consumption_rate = (self.game_description.n_players - n_cooperators) / self.game_description.n_players
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        elif state.current_stock <= 0.25 * self.game_description.capacity:
            return Action.D
        else:
            if avg_consumption_rate > 0.5:
                cooperate_prob = 0.6
            else:
                cooperate_prob = 0.4
            if random.random() < cooperate_prob:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_174(BaseStrategy):
    """
    The Adaptive Stock Raider (ASR) strategy aims to maximize its own payoff by 
    adaptively exploiting the current state of the game and the history of opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_defections = np.sum(history.opponent_actions, axis=1)
        stock_growth_rate = self.calculate_stock_growth_rate(history)
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.D
        elif 0.5 * self.game_description.capacity <= state.current_stock < 0.75 * self.game_description.capacity:
            if np.sum(opponent_defections) / self.game_description.n_players >= 0.5 and history.opponent_actions[-1].any():
                return Action.C
            else:
                return Action.D
        elif state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

    def calculate_stock_growth_rate(self, history):
        recent_rounds = min(5, len(history.my_actions))
        total_consumption = np.sum(np.where(history.opponent_actions[-recent_rounds:], 1.0 / self.game_description.n_players, 1.0 / (2 * self.game_description.n_players)), axis=0)
        stock_depletion_rate = np.mean(total_consumption)
        growth_rate = 2 * (1 - stock_depletion_rate) * (history.my_payoffs[-recent_rounds:] / self.game_description.capacity)
        return np.mean(growth_rate)

class Strategy_EXPLOITATIVE_175(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        stock_level = state.current_stock / self.game_description.capacity
        opponent_payoffs = history.opponent_payoffs[-1]
        opponent_actions = history.opponent_actions[-1]
        average_opponent_payoff = np.mean(opponent_payoffs[opponent_actions == 0])
        cooperators_payoffs = opponent_payoffs[opponent_actions == 1]
        if len(cooperators_payoffs) > 0:
            average_cooperator_payoff = np.mean(cooperators_payoffs)
        else:
            average_cooperator_payoff = 0
        if stock_level >= 0.75:
            return Action.C
        elif stock_level >= 0.5 and average_opponent_payoff > average_cooperator_payoff:
            return Action.D
        elif stock_level < 0.5:
            return Action.D
        else:
            opponent_cooperation_rates = np.mean(history.opponent_actions, axis=0)
            if (opponent_cooperation_rates == 0).any():
                return Action.D
            elif (opponent_cooperation_rates > 0.75).any():
                return random.choices([Action.C, Action.D], weights=[0.75, 0.25])[0]
            else:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_176(BaseStrategy):
    """
    An adaptive strategy that combines elements of Tit-for-Tat and a novel "Stock-based Exploitation" mechanism.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        et = self.game_description.capacity / (2 * self.game_description.n_players)
        num_cooperators = sum(history.opponent_actions[-1, :])
        if state.current_stock < self.game_description.capacity / (4 * self.game_description.n_players):
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if num_cooperators >= self.game_description.n_players // 2:
            action = Action.C
        elif state.current_stock > et:
            action = Action.D
        else:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_177(BaseStrategy):
    """
    Exploitative strategy: "Adaptive Stock Raider".
    
    Cooperates initially to gather information about opponents' behavior and stock dynamics.
    Adapts to the stock level and opponents' behavior, balancing short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_odr = None

    def analyze_opponent_behavior(self, history: PlayerHistory) -> float:
        if history is None or len(history.my_actions) < 2:
            return 0.0
        opponent_defects = sum((1 - action for action in history.opponent_actions[-1, :]))
        opponent_odr = opponent_defects / self.game_description.n_players
        return opponent_odr

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        round_number = state.round_number
        total_rounds = self.game_description.n_rounds
        if round_number <= 5:
            return Action.C
        elif current_stock > capacity / 2:
            p = min(0.5 + (round_number - 1) / total_rounds, 0.9)
            return Action.D if random.random() < p else Action.C
        elif capacity / 4 <= current_stock <= capacity / 2:
            if history is not None and sum(history.opponent_actions[-1, :]) > capacity / 2:
                return Action.C
            else:
                p = min(0.5 + (round_number - 1) / total_rounds, 0.9)
                return Action.D if random.random() < p else Action.C
        elif current_stock < capacity / 4:
            return Action.C
        self.opponent_odr = self.analyze_opponent_behavior(history)
        if self.opponent_odr > 0.7:
            return Action.D
        return Action.D if round_number == total_rounds else Action.C

class Strategy_EXPLOITATIVE_178(BaseStrategy):
    """
    A strategy that adapts to the game state and history while aiming to maximize my own payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_actions = []
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if len(self.prev_actions) < state.round_number - 1:
            self.prev_actions.append(np.any(history.opponent_actions[-2] == True))
        self.stock_history.append(state.current_stock)
        prev_defect_count = np.sum([not action for action in self.prev_actions])
        if state.current_stock < 0.75 * self.game_description.capacity:
            if prev_defect_count > self.game_description.n_players / 2:
                return Action.D
            else:
                return Action.C
        elif history.my_payoffs[-1] == np.mean(history.my_payoffs) and prev_defect_count > self.game_description.n_players / 4:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_179(BaseStrategy):
    """
    Exploit the game's dynamics and opponent behaviors while adapting to changing conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.num_defection_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if history and (not np.all(history.opponent_actions[-1, :])):
            self.num_defection_rounds += 1
        sdt = 0.25 * self.game_description.capacity
        if state.current_stock <= sdt:
            return Action.D
        cp = 1 - self.num_defection_rounds / state.round_number
        if cp < 0.5 or state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock == 0:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_180(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to opponents' behavior and stock dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_payoff_prev = np.mean(history.opponent_payoffs[-1, :])
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        elif state.current_stock <= 0.25 * self.game_description.capacity:
            return Action.D
        elif avg_payoff_prev > state.current_stock / (2 * self.game_description.n_players):
            return Action.C
        else:
            return Action.D
        if self.game_description.n_rounds == state.round_number + 1:
            return Action.D

class Strategy_EXPLOITATIVE_181(BaseStrategy):
    """
    Adaptive Stock-Based Exploitation (ASBE) strategy.
    
    This strategy aims to maximize its payoff by exploiting the game's dynamics and adapting to the opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        T = self.game_description.capacity / (self.game_description.n_players + 1)
        cooperation_condition = state.current_stock >= T
        if history is not None:
            opponent_actions_in_last_round = history.opponent_actions[-1, :]
            opponents_defected = np.sum(opponent_actions_in_last_round == 0)
            if opponents_defected > self.game_description.n_players / 2:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if cooperation_condition:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_182(BaseStrategy):
    """
    The Adaptive Stock Hawk (ASH) strategy is designed to exploit a wide range of opponent behaviors while being robust and adaptive to changing game conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_round_consumption = 0.0
        self.opponent_payoffs = [0.0] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        expected_cooperation_payoff = state.current_stock / (2 * self.game_description.n_players)
        avg_opponent_payoff = sum(self.opponent_payoffs) / len(self.opponent_payoffs)
        if history:
            for i, payoff in enumerate(history.opponent_payoffs[-1]):
                self.opponent_payoffs[i] = payoff
        opponent_defectors = [i for i, (payoff, action) in enumerate(zip(self.opponent_payoffs, history.opponent_actions[-1])) if action == Action.D and payoff > expected_cooperation_payoff]
        if state.current_stock >= 0.75 * self.game_description.capacity and avg_opponent_payoff < expected_cooperation_payoff:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity or self.previous_round_consumption > 0.5 * self.game_description.capacity:
            return Action.C
        if opponent_defectors:
            return Action.D
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_183(BaseStrategy):
    """
    Adaptive Stock-Based Defection Strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_threshold = 0.6
        self.k = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_prop = state.current_stock / self.game_description.capacity
        if history is not None:
            for opponent_idx in range(self.game_description.n_players - 1):
                avg_payoff = np.mean(history.opponent_payoffs[-self.k:, opponent_idx])
                expected_coop_payoff = state.current_stock / (2 * self.game_description.n_players)
                if avg_payoff > expected_coop_payoff:
                    self.defection_threshold -= 0.05
                elif avg_payoff < expected_coop_payoff:
                    self.defection_threshold += 0.05
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif stock_prop > self.defection_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_184(BaseStrategy):
    """
    Exploitative strategy that balances exploration, observation, and exploitation 
    to maximize payoffs in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        if state.round_number <= self.game_description.n_rounds // 2:
            if state.current_stock > self.game_description.capacity * 0.75:
                most_cooperators = sum(history.opponent_actions[-1, :]) >= (self.game_description.n_players - 1) / 2
                return Action.C if most_cooperators else Action.D
            elif state.current_stock < self.game_description.capacity * 0.25:
                return Action.D
        if state.round_number > self.game_description.n_rounds // 2 and state.round_number < self.game_description.n_rounds - 1:
            recent_opponent_actions = history.opponent_actions[-self.game_description.n_rounds // 4:]
            cooperators = np.sum(recent_opponent_actions, axis=0) >= recent_opponent_actions.shape[0] * 3 / 4
            for i in range(self.game_description.n_players - 1):
                if cooperators[i]:
                    return Action.D
                elif not cooperators[i]:
                    return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_185(BaseStrategy):
    """
    The Adaptive Exploiter (AE) strategy balances cooperation and exploitation throughout the game.
    It adapts its strategy based on the stock level and opponents' actions, exploiting situations where possible while avoiding depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        avg_payoff = np.mean(history.my_payoffs[-1] + history.opponent_payoffs[-1, :])
        if state.round_number <= 5:
            if avg_payoff > capacity / (4 * n_players):
                return Action.C
            else:
                return Action.D
        stock_level = current_stock / capacity
        if stock_level > 0.5:
            return Action.C
        elif stock_level >= 0.25 and stock_level < 0.5:
            if state.round_number % 3 == 0:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D
        if current_stock > capacity / 8:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if current_stock < capacity / 16:
            return Action.D

class Strategy_EXPLOITATIVE_186(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_defection_rate = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        opponent_actions = history.opponent_actions
        defected_opponents = sum((1 for action in opponent_actions[-1, :] if not action))
        self.opponent_defection_rate = defected_opponents / n_players
        if current_stock > capacity * 0.75 and state.round_number < self.game_description.n_rounds / 2:
            return Action.D
        average_payoff_per_player = np.mean(history.my_payoffs[-5:])
        if average_payoff_per_player < capacity / (4 * n_players):
            return Action.D
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        if current_stock < capacity / (2 * n_players):
            return Action.C
        if self.opponent_defection_rate > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_187(BaseStrategy):
    """
    An exploitative strategy that adapts to changing stock levels and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        C_count = np.sum(history.opponent_actions[:, :] == True, axis=0)
        D_count = self.game_description.n_players - C_count
        cooperation_ratio = C_count / (C_count + D_count)
        if state.current_stock < self.stock_threshold:
            return Action.D
        if np.any(cooperation_ratio > 0.5):
            return Action.D
        if state.current_stock > self.stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_188(BaseStrategy):
    """
    Robust and adaptive exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        S = state.current_stock
        capacity = self.game_description.capacity
        if t == 0:
            return Action.C
        if S > capacity / 2:
            return Action.D
        elif S < capacity / 4:
            return Action.C
        else:
            if history is not None:
                opponent_coop_rate = np.mean(history.opponent_actions[-3:, :])
                if opponent_coop_rate > 0.5:
                    return Action.D
            return Action.C
        if t == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_189(BaseStrategy):
    """
    Exploitative strategy that adapts to changing stock levels and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C if n_players <= 4 else Action.D
        opponents = [self.analyze_opponent(opponent_actions) for opponent_actions in history.opponent_actions.T]
        stock_level = state.current_stock / capacity
        if stock_level >= 0.75:
            most_cooperators = sum((1 for x in opponents if x == 'cooperator')) > n_players / 2
            return Action.C if most_cooperators else Action.D
        elif stock_level < 0.25:
            return Action.D
        else:
            p = stock_level
            return Action.C if random.random() < p else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

    def analyze_opponent(self, opponent_actions):
        cooperation_rate = sum(opponent_actions) / len(opponent_actions)
        return 'cooperator' if cooperation_rate >= 0.5 else 'defector'

class Strategy_EXPLOITATIVE_190(BaseStrategy):
    """
    An adaptive strategy that balances cooperation and exploitation in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_level = state.current_stock / self.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        cooperators = sum(history.opponent_actions[-1, :])
        cooperation_rate = cooperators / self.game_description.n_players
        if stock_level > 0.75:
            p_C = cooperation_rate + 0.1
            return Action.C if random.random() < p_C else Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_191(BaseStrategy):
    """
    The ASE strategy aims to maximize its payoff by adaptively exploiting the common pool resource,
    taking into account the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        low_stock_threshold = 0.5 * self.game_description.capacity
        high_stock_threshold = 0.8 * self.game_description.capacity
        coop_count = sum(history.opponent_actions[-1, :])
        defect_count = len(history.opponent_actions[-1, :]) - coop_count
        if state.current_stock > high_stock_threshold:
            return Action.C
        elif state.current_stock < low_stock_threshold or state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif coop_count > defect_count:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_193(BaseStrategy):
    """
    Exploitative Strategy: "Adaptive Stock Raider"

    This strategy focuses on maximizing individual payoffs by adaptively responding to the game's dynamic state and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_consumption = sum(np.mean(history.opponent_actions[:state.round_number, :], axis=0)) / self.game_description.n_players
        if state.round_number < self.game_description.n_rounds // 2:
            avg_opponent_consumption = total_consumption
            if avg_opponent_consumption < state.current_stock / (4 * self.game_description.n_players):
                return Action.C
            else:
                return Action.D
        elif state.round_number >= self.game_description.n_rounds // 2:
            if state.current_stock > self.game_description.capacity / 2:
                return Action.C
            else:
                return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock < self.game_description.capacity / 4:
                return Action.C
            else:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1 and state.current_stock > 3 / 4 * self.game_description.capacity:
            return Action.C
        opponent_actions_last_round = history.opponent_actions[state.round_number - 1, :]
        most_opponents_cooperate = np.sum(opponent_actions_last_round) >= self.game_description.n_players // 2
        if most_opponents_cooperate and state.round_number < self.game_description.n_rounds - 1:
            return Action.D in [Action.C, Action.D]

class Strategy_EXPLOITATIVE_194(BaseStrategy):
    """
    Exploitative strategy that balances cooperation and defection to maximize payoffs,
    while adapting to the dynamic state of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.rounds_to_track_opponents = 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock < 0.25 * capacity:
            return Action.D
        if current_stock > 0.75 * capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        opponent_actions = history.opponent_actions[-self.rounds_to_track_opponents:, :]
        cooperation_rates = np.mean(opponent_actions, axis=0)
        cooperators = np.sum(cooperation_rates >= 0.7)
        defectors = self.game_description.n_players - 1 - cooperators
        if cooperators >= defectors:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_196(BaseStrategy):
    """
    An adaptive exploitative strategy that maximizes payoff by responding to current stock level and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / (2 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock > self.stock_threshold:
            play_defect = True
        else:
            play_defect = False
        opponent_actions_last_round = history.opponent_actions[-1, :]
        defecting_opponents = sum((1 for action in opponent_actions_last_round if not action))
        if defecting_opponents > self.game_description.n_players // 2:
            play_defect = True
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D if play_defect else Action.C

class Strategy_EXPLOITATIVE_197(BaseStrategy):
    """
    A robust and exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.k = 5
        self.m = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock = state.current_stock
        if stock > 0.75 * self.capacity:
            action = Action.D
        elif stock < 0.25 * self.capacity:
            action = Action.C
        else:
            avg_coop_payoff, avg_defect_payoff = self.analyze_last_k_rounds(history)
            if avg_coop_payoff > avg_defect_payoff:
                action = Action.C
            else:
                action = Action.D
        opponent_actions = self.monitor_opponents(history, self.m)
        if self.most_opponents_played_C(opponent_actions):
            action = Action.D
        elif self.most_opponents_played_D(opponent_actions):
            action = Action.C
        rounds_left = self.game_description.n_rounds - state.round_number
        if rounds_left == 1:
            if stock > 0.5 * self.capacity:
                action = Action.D
            else:
                action = Action.C
        elif stock < 0.1 * self.capacity:
            action = Action.C
        return action

    def analyze_last_k_rounds(self, history: PlayerHistory) -> tuple[float, float]:
        avg_coop_payoff = np.mean(history.my_payoffs[-self.k:])
        avg_defect_payoff = np.mean(np.where(history.opponent_actions[-self.k:], history.opponent_payoffs[-self.k:], 0))
        return (avg_coop_payoff, avg_defect_payoff)

    def monitor_opponents(self, history: PlayerHistory, m: int) -> NDArray[np.bool_]:
        opponent_actions = history.opponent_actions[-m:]
        return opponent_actions

    @staticmethod
    def most_opponents_played_C(opponent_actions: NDArray[np.bool_]) -> bool:
        return np.sum(opponent_actions) > len(opponent_actions) // 2

    @staticmethod
    def most_opponents_played_D(opponent_actions: NDArray[np.bool_]) -> bool:
        return np.sum(~opponent_actions) > len(opponent_actions) // 2

class Strategy_EXPLOITATIVE_198(BaseStrategy):
    """
    A robust and adaptive strategy designed to exploit a wide range of opponent behaviors in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.defect_probability = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.D
        stock_level = state.current_stock / self.capacity
        if stock_level > 0.75:
            return Action.C
        elif stock_level < 0.25:
            return Action.C
        else:
            opponent_actions = history.opponent_actions[-1, :]
            opponent_cooperators = sum(opponent_actions)
            if opponent_cooperators > self.game_description.n_players // 2:
                return Action.D
            elif opponent_cooperators < self.game_description.n_players // 2:
                return Action.C
        my_payoffs = history.my_payoffs
        average_payoff = np.mean(my_payoffs)
        if len(history.opponent_payoffs) > 0 and len(history.opponent_payoffs[0]) > 0:
            opponent_average_payoffs = np.mean(np.mean(history.opponent_payoffs, axis=1))
            if my_payoffs[-1] < opponent_average_payoffs:
                self.defect_probability += 0.01
            else:
                self.defect_probability -= 0.01
        return Action.D if random.random() < self.defect_probability else Action.C

class Strategy_EXPLOITATIVE_199(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and defection,
    adapting to the game's state and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = np.array(history.opponent_actions)
        avg_consumption = self.calculate_avg_consumption(opponent_actions)
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        if avg_consumption > 0.5 * state.current_stock:
            return Action.D
        opponent_types = self.classify_opponents(opponent_actions)
        if all((t in [Action.C, None] for t in opponent_types)) and state.current_stock > 0.5 * self.game_description.capacity:
            return Action.C
        else:
            return Action.D

    def calculate_avg_consumption(self, opponent_actions: NDArray[np.bool_]) -> float:
        rounds = opponent_actions.shape[0]
        n_defectors = np.sum(~opponent_actions, axis=1)
        avg_stock_depletion = n_defectors / self.game_description.n_players + 0.5 * ((self.game_description.n_players - n_defectors) / self.game_description.n_players)
        return np.mean(avg_stock_depletion[-3:]) if rounds >= 3 else np.mean(avg_stock_depletion)

    def classify_opponents(self, opponent_actions: NDArray[np.bool_]) -> list[Action | None]:
        opponent_types = []
        for i in range(opponent_actions.shape[1]):
            coop_ratio = np.mean(opponent_actions[:, i])
            if coop_ratio > 0.75:
                opponent_types.append(Action.C)
            elif coop_ratio < 0.25:
                opponent_types.append(Action.D)
            else:
                opponent_types.append(None)
        return opponent_types

class Strategy_EXPLOITATIVE_200(BaseStrategy):
    """
    Exploitative strategy that focuses on maximizing individual payoffs by adaptively responding to the game state and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.player_avg_payoff_history = []
        self.opponent_avg_payoff_history = [[] for _ in range(game_description.n_players - 1)]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C if self.game_description.n_players < 5 else Action.D
        my_payoffs = np.array(history.my_payoffs)
        avg_my_payoff_recent = np.mean(my_payoffs[-min(5, len(my_payoffs)):])
        self.player_avg_payoff_history.append(avg_my_payoff_recent)
        opponent_payoffs_recent = []
        for i in range(self.game_description.n_players - 1):
            opponent_payoffs = np.array(history.opponent_payoffs[:, i])
            avg_opponent_payoff_recent = np.mean(opponent_payoffs[-min(5, len(opponent_payoffs)):])
            self.opponent_avg_payoff_history[i].append(avg_opponent_payoff_recent)
            opponent_payoffs_recent.append(avg_opponent_payoff_recent)
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        elif state.current_stock < 0.25 * self.game_description.capacity or np.sum(history.my_actions[-1] + history.opponent_actions[-1, :]) > 0.8 * self.game_description.capacity:
            return Action.D
        if any((opponent_payoff > 1.2 * avg_my_payoff_recent for opponent_payoff in opponent_payoffs_recent)):
            if len(self.player_avg_payoff_history) < state.round_number + 3:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_201(BaseStrategy):
    """
    The Adaptive Exploiter (AE) strategy for the Common Pool Resource game.
    
    This strategy aims to balance short-term gains with long-term sustainability by adapting to the game state and opponents' behavior.
    By exploiting cooperative behavior when possible, AE seeks to maximize its payoff in a wide range of scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_ratio = 0.5
        self.num_cooperators = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        current_stock = state.current_stock
        opponents_actions = history.opponent_actions[-1, :]
        self.num_cooperators = sum((1 for action in opponents_actions if action))
        num_defectors = self.game_description.n_players - self.num_cooperators
        self.cooperation_ratio = self.num_cooperators / self.game_description.n_players
        if current_stock > 0.75 * self.game_description.capacity:
            return Action.C if random.random() < self.cooperation_ratio else Action.D
        elif 0.25 * self.game_description.capacity <= current_stock <= 0.75 * self.game_description.capacity:
            return Action.D if any((not action for action in opponents_actions)) else Action.C
        else:
            return Action.D
        if self.cooperation_ratio > 0.5:
            return Action.D
        elif self.cooperation_ratio <= 0.5:
            return Action.C if random.random() < self.cooperation_ratio else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_202(BaseStrategy):
    """
    An exploitative strategy that detects and adapts to opponents' cooperation rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.exploitable_opponents = []
        self.cooperation_rates = {i: [] for i in range(game_description.n_players)}
        self.window_size = 3

    def calculate_cooperation_rate(self, opponent_id: int) -> float:
        history = self.cooperation_rates[opponent_id]
        return np.mean(history[-self.window_size:]) if len(history) >= self.window_size else np.mean(history)

    def reassess_exploitable_opponents(self):
        self.exploitable_opponents = [opponent for opponent, rates in self.cooperation_rates.items() if self.calculate_cooperation_rate(opponent) < 0.4]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        for opponent_id, action in enumerate(history.opponent_actions[-1, :]):
            self.cooperation_rates[opponent_id].append(action)
        if state.round_number % (5 + random.randint(-2, 2)) == 0:
            self.reassess_exploitable_opponents()
        current_stock = state.current_stock
        threshold = self.game_description.capacity / 2
        if any(self.exploitable_opponents):
            if current_stock > threshold:
                return Action.D
            else:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_203(BaseStrategy):
    """
    An exploitative and adaptive strategy for the Common Pool Resource Game.
    
    This strategy aims to balance exploitation for maximum gain with a cautious approach 
    to ensure long-term access to the resource, making it robust against various opponent strategies.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_depletion_rates = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.opponent_depletion_rates is None or len(history.my_actions) != len(self.opponent_depletion_rates):
            self.opponent_depletion_rates = np.zeros(self.game_description.n_players - 1)
        for i, actions in enumerate(np.transpose(history.opponent_actions)):
            consumption = (actions == Action.D).sum() * state.current_stock / self.game_description.n_players
            if len(actions) > 0:
                self.opponent_depletion_rates[i] = min(consumption / len(actions), 1.0)
        average_depletion_rate = np.mean(self.opponent_depletion_rates)
        if state.current_stock < self.game_description.capacity // 4 or average_depletion_rate > state.current_stock / (2 * self.game_description.n_players):
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif average_depletion_rate < state.current_stock / (2 * self.game_description.n_players):
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_204(BaseStrategy):
    """
    An exploitative strategy that adapts to changing game conditions and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_coop_rate_history = []
        self.previous_stock_growth = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[:-1]
        opponent_coop_rate = np.mean(opponent_actions)
        self.opponent_coop_rate_history.append(opponent_coop_rate)
        average_opponent_coop_rate = np.mean(self.opponent_coop_rate_history)
        if state.current_stock > 0.5 * self.game_description.capacity:
            if average_opponent_coop_rate > 0.4:
                return Action.D
            else:
                return Action.C
        elif state.current_stock <= 0.5 * self.game_description.capacity:
            current_stock_growth = (state.current_stock - history.my_payoffs[-1]) / history.my_payoffs[-1]
            if self.previous_stock_growth is None or current_stock_growth > self.previous_stock_growth:
                self.previous_stock_growth = current_stock_growth
                return Action.C
            else:
                return Action.D
        elif state.round_number > self.game_description.n_rounds - 3:
            return Action.D
        if all((opponent_action == False for opponent_action in history.opponent_actions[:-1].flatten())):
            return Action.D
        elif average_opponent_coop_rate == 0.5:
            if state.current_stock > 0.75 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_205(BaseStrategy):
    """
    An exploitative strategy that adapts to opponents' behavior while maintaining a robust approach.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_avg_payoffs_last_3_rounds = None

    def calculate_average_payoff(self, opponent_actions: NDArray[np.bool_], my_action: bool) -> float:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        opponent_payoffs = np.where(opponent_actions[-1, :], capacity / (2 * n_players), capacity / n_players)
        my_payoff = capacity / (2 * n_players) if my_action else capacity / n_players
        return (np.mean(opponent_payoffs), my_payoff)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = np.where(history.opponent_actions, True, False)
        my_action = history.my_actions[-1]
        avg_opponent_payoff, our_payoff = self.calculate_average_payoff(opponent_actions, my_action)
        if state.round_number < 5:
            return Action.C if state.current_stock > 0.75 * self.game_description.capacity else Action.D
        elif 5 <= state.round_number < self.game_description.n_rounds // 2:
            if avg_opponent_payoff > our_payoff:
                return Action.D
            elif our_payoff > avg_opponent_payoff and state.current_stock > 0.5 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        elif state.round_number >= self.game_description.n_rounds // 2:
            if state.current_stock < 0.25 * self.game_description.capacity:
                return Action.D
            if history.my_payoffs.shape[0] > 3:
                our_avg_payoff_last_3_rounds = np.mean(history.my_payoffs[-3:])
                opponent_avg_payoff_last_3_rounds = np.mean(avg_opponent_payoff) if self.opponent_avg_payoffs_last_3_rounds is None else self.opponent_avg_payoffs_last_3_rounds
            else:
                our_avg_payoff_last_3_rounds = np.mean(history.my_payoffs)
                opponent_avg_payoff_last_3_rounds = avg_opponent_payoff
            if self.opponent_avg_payoffs_last_3_rounds is None:
                self.opponent_avg_payoffs_last_3_rounds = opponent_avg_payoff_last_3_rounds
            if our_avg_payoff_last_3_rounds > opponent_avg_payoff_last_3_rounds:
                return Action.C
            else:
                return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_206(BaseStrategy):
    """
    An adaptive exploitative strategy that responds to opponents' behavior while maximizing payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_total_consumption = self._previous_total_consumption(history, state.current_stock)
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.D if previous_total_consumption < 0.5 * self.game_description.capacity else Action.C
        elif 0.25 * self.game_description.capacity < state.current_stock <= 0.75 * self.game_description.capacity:
            if history is None or len(history.opponent_actions) == 0:
                return Action.C
            opponent_defected = sum((not action for action in history.opponent_actions[-1, :]))
            return Action.D if opponent_defected > self.game_description.n_players // 2 else Action.C
        elif state.current_stock <= 0.25 * self.game_description.capacity:
            return Action.D
        else:
            return Action.D if state.round_number == self.game_description.n_rounds - 1 else Action.C

    def _previous_total_consumption(self, history: PlayerHistory, current_stock: float):
        if history is None or len(history.opponent_actions) == 0:
            return 0.5 * self.game_description.capacity
        opponent_defect_payoffs = sum((current_stock / self.game_description.n_players for _ in range(self.game_description.n_players - 1)))
        opponent_cooperate_payoffs = sum((current_stock / (2 * self.game_description.n_players) for _ in range(self.game_description.n_players - 1)))
        return opponent_defect_payoffs + opponent_cooperate_payoffs

class Strategy_EXPLOITATIVE_207(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game.
    
    This strategy balances short-term gains with long-term sustainability, 
    adapting to the game's dynamics and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.exploration_rounds = 3
        self.exploitation_threshold = 0.75 * game_description.capacity
        self.opponent_cooperation_rate = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number <= self.exploration_rounds:
            action = Action.C
        elif current_stock >= self.exploitation_threshold:
            action = Action.D
        else:
            action = Action.C
        if round_number == self.game_description.n_rounds:
            action = Action.D
        elif current_stock < 0.25 * self.game_description.capacity:
            action = Action.C
        opponent_actions = history.opponent_actions[-1, :]
        if self.opponent_cooperation_rate is None:
            self.opponent_cooperation_rate = np.mean(opponent_actions)
        if np.mean(opponent_actions) > self.opponent_cooperation_rate:
            self.opponent_cooperation_rate = np.mean(opponent_actions)
        else:
            self.opponent_cooperation_rate = np.mean(opponent_actions)
        recent_trend = history.my_payoffs[-min(3, len(history.my_payoffs)):]
        if np.all(np.diff(recent_trend) < 0):
            pass
        return action

class Strategy_EXPLOITATIVE_209(BaseStrategy):
    """
    An adaptive strategy that exploits opponents based on their average payoffs and the current stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / 2
        self.epsilon = 0.1

    def calculate_avg_payoff(self, payoffs: NDArray[np.float64]) -> float:
        return np.mean(payoffs)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        avg_payoff_AE = self.calculate_avg_payoff(history.my_payoffs)
        opponent_avg_payoffs = np.mean(history.opponent_payoffs, axis=0)
        if state.current_stock > self.stock_threshold:
            return Action.C
        for i, avg_payoff_i in enumerate(opponent_avg_payoffs):
            if avg_payoff_i > avg_payoff_AE + self.epsilon:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_210(BaseStrategy):
    """
    The Adaptive Exploiter strategy combines adaptive and exploitative elements.
    It maximizes payoffs while responding to various opponent behaviors in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_rate = [0] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number <= 1:
            return Action.C
        total_defections = np.sum(history.opponent_actions[:-1], axis=0)
        self.defection_rate = total_defections / (state.round_number - 1)
        cooperation_threshold = 0.75 * self.game_description.capacity * (1 - self.defection_rate.max())
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        if state.current_stock > cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_211(BaseStrategy):
    """
    An adaptive exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_rounds = 0
        self.threshold_adjusted = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_defections = np.sum(history.opponent_actions[-1, :] == False)
        if opponent_defections > 0:
            self.defection_rounds += 1
        if self.defection_rounds / state.round_number >= 0.25 and (not self.threshold_adjusted):
            self.threshold_adjusted = True
            threshold = 0.9 * self.game_description.capacity
        else:
            threshold = 0.75 * self.game_description.capacity
        if state.current_stock > threshold:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_212(BaseStrategy):
    """
    An adaptive strategy that exploits opponents' behavior in the Common Pool Resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.exploitation_threshold = 0.75 * self.capacity
        self.conservation_threshold = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        num_opponents = self.game_description.n_players - 1
        opponent_actions_last_three_rounds = history.opponent_actions[max(0, state.round_number - 3):state.round_number, :]
        if self.game_description.n_rounds % 2 != 0 and state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        stock_level = state.current_stock
        majority_cooperation = np.sum(opponent_actions_last_three_rounds) / (3 * num_opponents) > 0.5
        if stock_level > self.exploitation_threshold:
            return Action.D
        elif stock_level < self.conservation_threshold:
            return Action.C
        elif majority_cooperation:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_213(BaseStrategy):
    """
    Exploitative strategy that adapts to the dynamic state of the common pool resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.payoff_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < self.game_description.n_players:
            return Action.C
        self.stock_history.append(state.current_stock)
        if history is not None:
            self.payoff_history.append(history.my_payoffs[-1])
        avg_rounds = 3
        avg_payoff = np.mean(self.payoff_history[-avg_rounds:]) if len(self.payoff_history) >= avg_rounds else 0
        s_threshold = 0.75 * self.game_description.capacity
        l_threshold = 0.5 * self.game_description.capacity
        if state.current_stock > s_threshold:
            return Action.D
        p_coop = (state.current_stock - l_threshold) / (0.25 * self.game_description.capacity)
        coop_prob = random.random()
        if coop_prob < p_coop:
            return Action.C
        else:
            return Action.D
        if avg_payoff > state.current_stock / (2 * self.game_description.n_players):
            return Action.D
        if state.round_number >= self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_214(BaseStrategy):
    """
    An exploitative strategy that adaptively responds to the current state and history of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_trend = []
        self.opponent_payoffs = [0] * game_description.n_players
        self.opponent_actions = [[Action.C, Action.D]] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        stock_level = state.current_stock / self.game_description.capacity
        self.stock_trend.append(stock_level)
        if len(self.stock_trend) > 3 and all((t < self.stock_trend[-1] for t in self.stock_trend[-3:])):
            return Action.C
        if stock_level > 0.75:
            return Action.D
        elif 0.25 <= stock_level <= 0.75:
            avg_opponent_payoff = sum(self.opponent_payoffs) / self.game_description.n_players
            if history.my_payoffs[-1] < avg_opponent_payoff:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

    def update_opponent_payoffs(self, history: PlayerHistory):
        for i in range(self.game_description.n_players):
            self.opponent_payoffs[i] = history.opponent_payoffs[-1, i]

    def update_opponent_actions(self, history: PlayerHistory):
        for i in range(self.game_description.n_players):
            self.opponent_actions[i].append(Action.C if history.opponent_actions[-1, i] else Action.D)

class Strategy_EXPLOITATIVE_215(BaseStrategy):
    """
    The Adaptive Stock Raider (ASR) strategy aims to maximize its total payoff by adaptively responding 
    to the game's state and history, while exploiting opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        avg_opponent_consumption = self.calculate_avg_opponent_consumption(opponent_actions)
        stock_threshold = self.calculate_stock_threshold(state.current_stock)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.capacity * 0.1:
            return Action.C
        if avg_opponent_consumption > self.capacity / (2 * self.n_players) and state.current_stock > stock_threshold:
            return Action.C
        else:
            return Action.D

    def calculate_avg_opponent_consumption(self, opponent_actions):
        total_defections = sum((1 - action for action in opponent_actions))
        avg_opponent_consumption = total_defections / self.n_players * (self.capacity / self.n_players)
        return avg_opponent_consumption

    def calculate_stock_threshold(self, stock):
        if stock > self.capacity * 0.75:
            return self.capacity * 0.25
        else:
            return stock / 2

class Strategy_EXPLOITATIVE_216(BaseStrategy):
    """
    Exploitative strategy designed to adapt to a wide range of opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_behavior = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < 2:
            return Action.C
        if self.opponent_behavior is None:
            total_consumption = np.sum(history.opponent_payoffs[-2:, :]) * (self.game_description.capacity / self.game_description.n_players)
            avg_consumption_rate = total_consumption / (2 * state.current_stock)
            if avg_consumption_rate > 0.75:
                self.opponent_behavior = 'Greedy'
            elif avg_consumption_rate < 0.25:
                self.opponent_behavior = 'Cautious'
            else:
                self.opponent_behavior = 'Mixed'
        if state.current_stock < self.game_description.capacity * 0.25:
            if self.opponent_behavior == 'Greedy':
                return Action.C
            elif self.opponent_behavior in ['Cautious', 'Mixed']:
                pass
        if self.opponent_behavior == 'Greedy':
            return Action.D
        elif self.opponent_behavior == 'Cautious':
            return Action.C
        else:
            random_probability = random.random()
            if state.current_stock > self.game_description.capacity * 0.75:
                return Action.C if random_probability < 0.6 else Action.D
            elif state.current_stock < self.game_description.capacity * 0.25:
                return Action.C if random_probability < 0.4 else Action.D
            else:
                return Action.C if random_probability < 0.5 else Action.D
        if state.round_number >= self.game_description.n_rounds - 2:
            if state.current_stock > self.game_description.capacity * 0.5:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_217(BaseStrategy):
    """
    Hybrid exploitative strategy combining tit-for-tat, grim trigger and stock-based decision rules.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_opponent_action = None
        self.accumulated_depletion = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_consumption = sum(history.my_payoffs[-1] + history.opponent_payoffs[-1, :])
        self.accumulated_depletion += total_consumption
        theta = 0.5
        delta = 0.2 * self.game_description.capacity
        S_C_ratio = state.current_stock / self.game_description.capacity
        cooperate = False
        if S_C_ratio >= theta:
            cooperate = True
        if history.opponent_actions[-1, :].any():
            self.prev_opponent_action = Action.D if history.opponent_actions[-1, 0] else Action.C
            if self.prev_opponent_action == Action.D:
                cooperate = False
            elif self.prev_opponent_action == Action.C and cooperate:
                cooperate = True
        if self.accumulated_depletion > delta:
            cooperate = False
        return Action.C if cooperate else Action.D

class Strategy_EXPLOITATIVE_218(BaseStrategy):
    """
    Exploitative strategy that prioritizes short-term gains while adapting to opponents' behaviors and the dynamic state of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_thresholds = {'high': 0.75 * game_description.capacity, 'low': 0.25 * game_description.capacity}
        self.stock_level_last_round = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.stock_level_last_round is not None and state.current_stock < self.capacity_thresholds['low']:
            return Action.C
        opponent_defections = sum(1 - history.opponent_actions[-1, :])
        if opponent_defections >= self.game_description.n_players // 2:
            return Action.D
        if state.current_stock > self.capacity_thresholds['high']:
            return Action.D
        elif self.capacity_thresholds['low'] <= state.current_stock <= self.capacity_thresholds['high']:
            if opponent_defections >= (self.game_description.n_players - 1) // 2:
                return Action.C
            else:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        self.stock_level_last_round = state.current_stock
        return Action.C

class Strategy_EXPLOITATIVE_219(BaseStrategy):
    """
    Exploitative strategy designed to balance short-term gains with long-term sustainability.
    Adapts to the current stock level and opponent behavior in a common pool resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_payoffs = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if self.game_description.capacity > 2 * self.game_description.n_players else Action.D
        for opponent in range(self.game_description.n_players - 1):
            avg_payoff = np.mean(history.opponent_payoffs[:, opponent])
            if avg_payoff > state.current_stock / (2 * self.game_description.n_players):
                return Action.C if state.current_stock > 0.5 * self.game_description.capacity else Action.D
        return Action.C if state.current_stock > 0.25 * self.game_description.capacity else Action.D

class Strategy_EXPLOITATIVE_220(BaseStrategy):
    """
    A hybrid strategy combining Tit-for-Tat and Gradient Ascent to exploit opponents while adapting to changing game conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / (2 * game_description.n_players)
        self.p_c = 0.5
        self.alpha = 0.1
        self.opponent_defected_last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number + 1 == self.game_description.n_rounds:
            return Action.D
        if history.opponent_actions[-1, 0]:
            self.opponent_defected_last_round = False
        else:
            self.opponent_defected_last_round = True
        if state.current_stock >= self.stock_threshold:
            return Action.D
        elif self.opponent_defected_last_round:
            return Action.C
        else:
            if history.my_payoffs.size > 0:
                last_payoff = history.my_payoffs[-1]
                expected_payoff = (state.current_stock / self.game_description.n_players + state.current_stock / (2 * self.game_description.n_players)) / 2
                self.p_c += self.alpha * (last_payoff - expected_payoff)
                self.p_c = max(0, min(self.p_c, 1))
            if random.random() < self.p_c:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_221(BaseStrategy):
    """
    An adaptive exploitative strategy for the Common Pool Resource Game.
    This strategy balances cooperation and defection, adapting to the game's state and opponents' behaviors while prioritizing individual payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.reciprocity_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_avg_payoff = np.mean(history.my_payoffs[-1] / self.game_description.n_players)
        max_coop_payoff = state.current_stock / (2 * self.game_description.n_players)
        if prev_avg_payoff >= max_coop_payoff:
            return Action.D
        elif state.current_stock <= 2 * self.game_description.n_players:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            for opponent_payoff in history.opponent_payoffs[-1, :]:
                if opponent_payoff > 1.5 * prev_avg_payoff:
                    return Action.D
            self.reciprocity_counter += sum((history.my_actions[-1] and (not action) for action in history.opponent_actions[-1, :]))
            if self.reciprocity_counter >= 2:
                self.reciproity_counter = 0
                return Action.D
            return Action.C

class Strategy_EXPLOITATIVE_222(BaseStrategy):
    """
    An adaptive strategy that balances short-term gain with long-term sustainability by responding to the current state and history of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.num_players = game_description.n_players
        self.rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        stock_level = state.current_stock
        round_num = state.round_number
        if round_num == 0:
            return Action.C
        if stock_level >= 0.75 * self.capacity:
            return Action.D
        elif stock_level >= 0.5 * self.capacity and self.average_payoff(history) < self.median_payoff(history):
            return Action.C
        else:
            return Action.D
        if round_num == self.rounds - 1:
            return Action.D

    def average_payoff(self, history: PlayerHistory) -> float:
        if len(history.my_payoffs) == 0:
            return 0.0
        return np.mean(history.my_payoffs)

    def median_payoff(self, history: PlayerHistory) -> float:
        if len(history.my_payoffs) == 0:
            return 0.0
        return np.median(history.my_payoffs)

class Strategy_EXPLOITATIVE_223(BaseStrategy):
    """
    An exploitative strategy that adapts to opponents' behaviors in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_behavior_history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        if stock_level > 0.75:
            return Action.D
        elif stock_level >= 0.25 and stock_level <= 0.75:
            opponents_defected_last_round = np.mean(~history.opponent_actions[-1, :])
            if opponents_defected_last_round >= 0.5:
                return Action.C
            else:
                return Action.D
        elif stock_level < 0.25:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

        def opponent_heuristic(opponent_actions):
            defect_count = np.sum(~opponent_actions)
            cooperate_count = len(opponent_actions) - defect_count
            if defect_count >= 0.75 * len(opponent_actions):
                return 1.2
            elif cooperate_count >= 0.75 * len(opponent_actions):
                return 0.9
            return 1
        if self.opponent_behavior_history is None:
            self.opponent_behavior_history = np.ones(self.game_description.n_players)
        for i, opponent in enumerate(history.opponent_actions[-1, :]):
            self.opponent_behavior_history[i] *= opponent_heuristic(~opponent)
        if random.random() < np.mean(self.opponent_behavior_history):
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_224(BaseStrategy):
    """
    Balances short-term exploitation with long-term sustainability by adapting to opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_threshold_abundant = 0.75 * self.game_description.capacity
        stock_threshold_low = 0.25 * self.game_description.capacity
        stock_threshold_moderate = 0.5 * self.game_description.capacity
        if history is not None:
            opponent_cooperation_rate = np.mean(history.opponent_actions[-1, :])
        else:
            opponent_cooperation_rate = 0.5

        def mirror_opponent_behavior(opponent_history):
            return sum(opponent_history) / len(opponent_history) > 0.8
        if state.current_stock > stock_threshold_abundant:
            return Action.D
        elif opponent_cooperation_rate > 0.5 and stock_threshold_low <= state.current_stock <= stock_threshold_abundant:
            return Action.C
        elif state.current_stock < stock_threshold_low:
            return Action.C
        if history is not None and len(history.my_actions) > 1:
            for opponent in history.opponent_actions.T:
                if mirror_opponent_behavior(opponent):
                    return Action.D
        if state.round_number == self.game_description.n_rounds - 1 and state.current_stock > stock_threshold_moderate:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_225(BaseStrategy):
    """
    Adaptive Exploiter strategy designed to maximize payoffs while being robust to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock > 0.75 * self.capacity:
            return Action.C
        opponent_defections = np.sum(history.opponent_actions[:, :] == False, axis=1)
        if np.any(opponent_defections > (self.n_players - 1) / 2):
            return Action.D
        avg_c_payoff = np.mean(np.where(history.my_actions[-3:] == True, history.my_payoffs[-3:], 0))
        avg_d_payoff = np.mean(np.where(history.my_actions[-3:] == False, history.my_payoffs[-3:], 0))
        if avg_c_payoff > avg_d_payoff:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.n_rounds - 1:
            return Action.D
        if np.all(history.opponent_actions[-1, :] == False):
            return Action.D

class Strategy_EXPLOITATIVE_226(BaseStrategy):
    """
    An exploitative strategy that adapts to the current state of the game and observed behavior of opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.moving_avg_window_size = 3
        self.threshold_multiplier = 1.0
        self.previous_payoffs = []
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if self.game_description.capacity > 2 * self.game_description.n_players:
                return Action.C
            else:
                return Action.D
        app = np.mean(self.previous_payoffs)
        moving_avg_stock = np.mean(self.stock_history[-self.moving_avg_window_size:])
        if app > state.current_stock / (2 * self.game_description.n_players):
            return Action.C
        elif app < state.current_stock / self.game_description.n_players:
            return Action.D
        if moving_avg_stock < 0.8 * self.game_description.capacity:
            self.threshold_multiplier *= 1.02
        elif moving_avg_stock > 0.9 * self.game_description.capacity:
            self.threshold_multiplier /= 1.02
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock == 0:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_228(BaseStrategy):
    """
    Exploitative strategy "Adaptive Predator" that adapts to opponents' behaviors while being robust and responsive to extreme situations.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return random.choice([Action.C, Action.D])
        previous_round = history.opponent_actions[-1, :]
        cooperators = np.sum(previous_round)
        defectors = self.n_players - cooperators
        C_avg = state.current_stock / (2 * self.n_players) if cooperators > 0 else 0
        D_avg = state.current_stock / self.n_players if defectors > 0 else 0
        if C_avg > D_avg:
            p = (C_avg - D_avg) / (2 * self.capacity)
            return Action.C if random.random() < p else Action.D
        elif state.current_stock < 2 * self.n_players or state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif state.current_stock > self.capacity * 0.8:
            p = 1 - (self.capacity - state.current_stock) / self.capacity
            return Action.D if random.random() < p else Action.C
        else:
            p = 1 - (D_avg - C_avg) / (2 * self.capacity)
            return Action.D if random.random() < p else Action.C

class Strategy_EXPLOITATIVE_229(BaseStrategy):
    """
    The Adaptive Stock Hawk is a robust and adaptive strategy that exploits the dynamics of the common pool resource game.
    This strategy focuses on maximizing individual payoffs while considering the state of the stock and the history of opponent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = [game_description.capacity]
        self.opponent_cooperation_rates = [0.5] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = self.stock_history[-1]
        if state.round_number == 0:
            return Action.C
        else:
            opponent_actions = history.opponent_actions[-1]
            most_common_opponent_action = np.mean(opponent_actions)
            if current_stock > 0.75 * self.game_description.capacity:
                action = Action.D
            elif 0.25 * self.game_description.capacity <= current_stock < 0.75 * self.game_description.capacity:
                if most_common_opponent_action >= 0.5:
                    action = Action.C
                else:
                    action = Action.D
            else:
                action = Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return action

class Strategy_EXPLOITATIVE_230(BaseStrategy):
    """
    A strategy that balances exploitation and protection of the common pool resource by adapting to opponents' behaviors and prioritizing long-term payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.theta = 0.7 * self.capacity
        self.defectors = []
        self.payoff_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if len(self.payoff_history) < state.round_number:
            self.payoff_history.append(0.0)
        opponents_defected = np.sum(history.opponent_actions, axis=1) > (state.round_number - 1) / 2
        for i, opponent_defected in enumerate(opponents_defected):
            if opponent_defected and i not in self.defectors:
                self.defectors.append(i)
        if state.current_stock > self.theta and len(self.defectors) > 0:
            return Action.D
        if state.current_stock < self.theta or (len(self.payoff_history) > 1 and self.payoff_history[-2] < np.mean(history.my_payoffs)):
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.3 * self.capacity:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_231(BaseStrategy):
    """
    The Adaptive Stock Raider strategy aims to maximize individual payoff by adaptively responding to the game state and opponents' actions while minimizing cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.stock_history) == 0:
            if state.current_stock > 0.75 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        prev_consumption = self.stock_history[-2] - self.stock_history[-1]
        if prev_consumption < 0.5 * self.game_description.capacity:
            action = Action.C
        elif prev_consumption > 0.75 * self.game_description.capacity:
            action = Action.D
        else:
            p_coop = (state.current_stock / self.game_description.capacity) ** 2
            if random.random() < p_coop:
                action = Action.C
            else:
                action = Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        self.stock_history.append(state.current_stock)
        return action

class Strategy_EXPLOITATIVE_232(BaseStrategy):
    """
    A strategy that adaptively responds to the game state and history,
    aiming to maximize its own payoff by exploiting opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return random.choice([Action.C, Action.D])
        avg_payoff_prev = np.mean(history.opponent_payoffs[-1, :])
        if state.round_number == self.game_description.n_rounds:
            return Action.D
        if state.current_stock < self.game_description.capacity / self.game_description.n_players:
            defect_prob = state.current_stock / avg_payoff_prev * 2
        else:
            defect_prob = state.current_stock / (avg_payoff_prev * self.game_description.n_players)
        if avg_payoff_prev >= self.game_description.capacity / self.game_description.n_players:
            return Action.C
        return random.random() < defect_prob and Action.D or Action.C

class Strategy_EXPLOITATIVE_233(BaseStrategy):
    """
    The Adaptive Stock Raider is an exploitative strategy that combines elements of cooperation and exploitation to maximize payoffs in a dynamic, adaptive manner.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.low_threshold = 0.3 * game_description.capacity
        self.high_threshold = 0.7 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = history.opponent_actions[:-1]
        opponent_avg = np.mean(opponent_actions)
        if state.current_stock > self.high_threshold:
            return Action.D
        elif state.current_stock < self.low_threshold:
            return Action.C
        else:
            weighted_avg = np.mean(np.where(opponent_actions, 1.0, 0.5))
            if weighted_avg > 0.6:
                return Action.D
            elif weighted_avg < 0.4:
                return Action.C
            else:
                return Action.C if random.random() > 0.5 else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_234(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behaviors and the dynamic state of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.75 * game_description.capacity
        self.opponent_cooperation_threshold = 0.6
        self.recent_rounds_window = 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        recent_opponent_actions = history.opponent_actions[max(0, state.round_number - self.recent_rounds_window):state.round_number]
        opponents_cooperation_rates = np.mean(recent_opponent_actions, axis=0)
        if np.any(opponents_cooperation_rates > self.opponent_cooperation_threshold):
            return Action.C
        previous_stock_growth = state.current_stock - history.my_payoffs[state.round_number - 1] * self.game_description.n_players
        if previous_stock_growth > 0:
            return Action.C
        if state.current_stock > self.stock_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_235(BaseStrategy):
    """
    An adaptive exploitative strategy for the Common Pool Resource Game.
    
    This strategy aims to maximize payoffs by identifying opportunities to defect while maintaining the stock level.
    It uses a combination of cooperation and defection based on the current stock level, opponent behavior, and game state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.low_stock_threshold = game_description.capacity / 4
        self.high_stock_threshold = game_description.capacity * 3 / 4
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.low_stock_threshold / 10:
            return Action.C
        if state.current_stock > self.high_stock_threshold:
            action = Action.D
        elif state.current_stock < self.low_stock_threshold:
            action = Action.C
        else:
            recent_rounds = history.opponent_actions[-int(0.1 * self.game_description.n_rounds):]
            avg_defectors = np.mean(np.sum(recent_rounds == 0, axis=1))
            if avg_defectors > self.game_description.n_players / 2:
                action = Action.C
            else:
                action = Action.D
        if random.random() < 0.05:
            return Action.D if action == Action.C else Action.C
        return action

class Strategy_EXPLOITATIVE_236(BaseStrategy):
    """
    Exploitative strategy that adapts to the opponent's behavior by balancing cooperation and defection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_stock = 0.5 * game_description.capacity
        self.avg_opponent_consumption = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if state.current_stock >= self.threshold_stock:
                return Action.C
            else:
                return Action.D
        if history is not None:
            for opponent_actions in history.opponent_actions.T:
                opponent_consumption = sum(opponent_actions[:state.round_number]) / state.round_number
                self.avg_opponent_consumption += opponent_consumption
            self.avg_opponent_consumption /= self.game_description.n_players
            own_action_consumption = state.current_stock / (2 * self.game_description.n_players) if True else state.current_stock / self.game_description.n_players
            expected_stock = state.current_stock - (self.avg_opponent_consumption + own_action_consumption)
            if expected_stock >= self.threshold_stock:
                return Action.C
            else:
                return Action.D
        for opponent_actions in history.opponent_actions.T:
            opponent_defection_rate = sum((1 - action for action in opponent_actions[:state.round_number])) / state.round_number
            if opponent_defection_rate > 0.5:
                self.avg_opponent_consumption += 0.1 * state.current_stock
            elif opponent_defection_rate < 0.5:
                self.avg_opponent_consumption -= 0.1 * state.current_stock
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.2 * self.game_description.capacity:
            return Action.C

class Strategy_EXPLOITATIVE_237(BaseStrategy):
    """
    Exploitative Strategy: "Adaptive Stock Raider"

    This strategy aims to balance short-term gains with long-term sustainability.
    It adapts its behavior based on the current stock level, opponents' payoffs,
    and their actions in previous rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        opponents_payoffs = history.opponent_payoffs[-1]
        my_last_payoff = history.my_payoffs[-1]
        average_opponents_payoff = np.mean(opponents_payoffs)
        opponent_actions = history.opponent_actions[-1]
        if state.round_number < self.game_description.n_rounds // 2:
            if state.current_stock > 0.75 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C
        elif state.round_number < 3 * self.game_description.n_rounds // 4:
            if average_opponents_payoff > my_last_payoff:
                return Action.D
            else:
                return Action.C
        elif state.round_number < self.game_description.n_rounds:
            if state.current_stock < 0.25 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C
        elif state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        opponent_defectors = np.sum(opponent_actions == 0)
        if opponent_defectors >= self.game_description.n_players // 2:
            return Action.C
        else:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_238(BaseStrategy):
    """
    An exploitative strategy that balances short-term gains with long-term sustainability,
    adapts to opponents' behaviors, and exploits vulnerabilities when detected.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif 1 <= state.round_number < self.game_description.n_rounds - 1:
            stock_ratio = state.current_stock / self.game_description.capacity
            cooperate = True
            if stock_ratio > 0.75:
                cooperate = False
            elif stock_ratio >= 0.5 and stock_ratio <= 0.75:
                cooperate = True
            else:
                cooperate = False
            opponent_payoffs_avg = np.mean(history.opponent_payoffs[-3:, :], axis=0)
            average_payoff = np.mean(opponent_payoffs_avg)
            for i in range(self.game_description.n_players - 1):
                avg_payoff_i = opponent_payoffs_avg[i]
                if avg_payoff_i > (1 + 0.2) * average_payoff:
                    cooperate = False
                elif avg_payoff_i < (1 - 0.2) * average_payoff:
                    cooperate = True
            all_opponent_actions = history.opponent_actions[-3:, :]
            if np.all(all_opponent_actions == Action.D):
                stock_level_critical = state.current_stock / self.game_description.capacity < 0.25
                if stock_level_critical:
                    cooperate = True
            return Action.C if cooperate else Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_239(BaseStrategy):
    """
    Exploitative strategy that adapts to changes in the stock level and game history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_threshold = self.game_description.capacity / (self.game_description.n_players + 1)
        if history is None or len(history.opponent_actions) < 2:
            prev_total_consumption = 0.0
        else:
            my_previous_action = history.my_actions[-1]
            opponent_previous_actions = history.opponent_actions[-1, :]
            cooperators = sum(opponent_previous_actions) + int(my_previous_action)
            defectors = self.game_description.n_players - cooperators
            if state.round_number == 1:
                prev_stock = self.game_description.capacity
            else:
                prev_stock = max(0.0, history.my_payoffs[-2] * (self.game_description.n_players / cooperators) + sum([payoff for payoff in history.opponent_payoffs[-2]]))
            prev_total_consumption = 0.5 * prev_stock * cooperators / self.game_description.n_players + prev_stock * defectors / self.game_description.n_players
        if state.current_stock > stock_threshold and prev_total_consumption <= 2 * self.game_description.capacity / (self.game_description.n_players + 1):
            return Action.D
        elif prev_total_consumption > 2 * self.game_description.capacity / (self.game_description.n_players + 1):
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_240(BaseStrategy):
    """
    An exploitative strategy that adapts to opponents' behaviors while maximizing individual payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_threshold = self.game_description.capacity / (2 * self.game_description.n_players)
            return Action.C
        total_defections = sum(~history.opponent_actions[-1, :])
        if state.round_number < self.game_description.n_rounds - 1:
            new_stock_threshold = self.stock_threshold + total_defections / self.game_description.n_players * (self.game_description.capacity / (2 * self.game_description.n_players))
            self.stock_threshold = min(new_stock_threshold, self.game_description.capacity / 2)
        if state.current_stock >= self.stock_threshold or state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_241(BaseStrategy):
    """
    Exploitative strategy that adapts to the dynamic state of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_thresholds = [0.25 * game_description.capacity, 0.75 * game_description.capacity]
        self.tit_for_tat_opponents = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number < 2:
            return Action.C
        opponents_cooperated = sum((1 for opponent_action in (history.opponent_actions[-1] if history else []) if opponent_action))
        if state.current_stock >= self.stock_thresholds[1]:
            return Action.D
        elif state.current_stock < self.stock_thresholds[0]:
            return Action.C
        elif opponents_cooperated >= self.game_description.n_players / 2:
            return Action.C
        else:
            return Action.D
        if state.round_number >= self.game_description.n_rounds - 2:
            if state.current_stock >= self.stock_thresholds[1]:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_242(BaseStrategy):
    """
    Exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors and maximizes payoff over multiple rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.avg_opponent_coop_rate = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions_last_round = history.opponent_actions[-1]
        S_current = state.current_stock
        avg_opponent_coop_rate = np.mean(opponent_actions_last_round)
        if S_current < 0.2 * self.game_description.capacity:
            return Action.C
        self.avg_opponent_coop_rate = (self.avg_opponent_coop_rate * (state.round_number - 1) + avg_opponent_coop_rate) / state.round_number
        if self.avg_opponent_coop_rate > 0.7:
            return Action.D
        elif self.avg_opponent_coop_rate < 0.3:
            return Action.C
        else:
            prob_defect = 0.6
            action = Action.D if random.random() < prob_defect else Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if self.avg_opponent_coop_rate > 0.5:
                return Action.D
            else:
                return Action.C
        if S_current == 0:
            return Action.C
        return action

class Strategy_EXPLOITATIVE_243(BaseStrategy):
    """
    Exploitative strategy that adapts to the game's dynamic state and opponent behavior.
    Cooperates when the stock level is high, exploits opponents' short-term focus, 
    and adjusts cooperation threshold based on observed opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.recent_rounds = 3
        self.cooperation_threshold = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-self.recent_rounds:, :]
        if self.game_description.n_players - sum(opponent_actions[:, 0]) / len(opponent_actions) > 0.5:
            return Action.D
        if state.current_stock >= self.cooperation_threshold * self.game_description.capacity:
            return Action.C
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        opponent_behavior = np.mean(opponent_actions, axis=0)
        cooperators = sum(opponent_behavior >= 0.75)
        defectors = sum(opponent_behavior <= 0.25)
        if cooperators > self.game_description.n_players // 2:
            self.cooperation_threshold = 0.5
        elif defectors > self.game_description.n_players // 4:
            self.cooperation_threshold = 0.9
        return Action.C if state.current_stock >= self.cooperation_threshold * self.game_description.capacity else Action.D

class Strategy_EXPLOITATIVE_244(BaseStrategy):
    """
    Exploitative Strategy: "Adaptive Stock Raider"
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.my_payoff_history = []
        self.average_payoffs = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_defected = sum((1 - opp_action for opp_action in history.opponent_actions[-1, :]))
        stock_fraction = state.current_stock / self.game_description.capacity
        last_round_my_payoff = history.my_payoffs[-1]
        if len(self.average_payoffs) > 0:
            avg_payoff = np.mean(self.average_payoffs)
        else:
            avg_payoff = 0.0
        if stock_fraction > 0.7 or opponents_defected > self.game_description.n_players / 2 or last_round_my_payoff < avg_payoff:
            return Action.D
        elif state.current_stock < 0.2 * self.game_description.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

    def update_payoffs(self, payoff):
        self.my_payoff_history.append(payoff)
        opponents_avg_payoff = np.mean(history.opponent_payoffs[-1, :])
        self.average_payoffs.append(opponents_avg_payoff)

class Strategy_EXPLOITATIVE_245(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that balances short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.5 * game_description.capacity
        self.low_stock_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if self.game_description.capacity > 2 * self.game_description.n_players else Action.D
        opponent_defection_count = sum((1 - action for action in history.opponent_actions[-1, :]))
        if state.current_stock >= self.stock_threshold and opponent_defection_count > 0:
            return Action.D
        self.low_stock_count += 1 if state.current_stock < 0.25 * self.game_description.capacity else -self.low_stock_count // 4
        cooperation_flag = self.low_stock_count > self.game_description.n_rounds // 4 or (history and history.my_payoffs[-1] == 0)
        opponent_consistently_cooperates = all((action for action in history.opponent_actions[:, 0]))
        if not cooperation_flag and opponent_defection_count == 0 and opponent_consistently_cooperates:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C if cooperation_flag else Action.D

class Strategy_EXPLOITATIVE_246(BaseStrategy):
    """
    The Adaptive Stock Exploiter (ASE) strategy aims to balance personal payoff with sustainable resource management 
    while adapting to changing game conditions and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold_high = 0.75 * game_description.capacity
        self.stock_threshold_low = 0.5 * game_description.capacity
        self.opponent_cooperation_rate_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_cooperation_rate = sum(history.opponent_actions[-1, :]) / self.game_description.n_players
        self.opponent_cooperation_rate_history.append(opponent_cooperation_rate)
        avg_opponent_cooperation_rate = np.mean(self.opponent_cooperation_rate_history)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock > self.stock_threshold_high:
            if avg_opponent_cooperation_rate > 0.5:
                return Action.D
            else:
                return Action.D
        elif state.current_stock >= self.stock_threshold_low:
            return Action.C
        elif avg_opponent_cooperation_rate > 0.5:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_247(BaseStrategy):
    """
    Adaptive Stock Exploiter (ASE) strategy for Common Pool Resource Game.
    
    This strategy aims to maximize its payoff by adaptively responding to the current state and history of the game,
    while being robust to various opponent behaviors. It uses a stock-based threshold to decide whether to cooperate or defect,
    and adjusts its behavior based on the cooperation rate of opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity * (1 - 1 / game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_CRs = self.analyze_opponent_behavior(history)
        most_cooperative = sum((1 for CR in opponent_CRs.values() if CR > 0.5)) > self.game_description.n_players / 2
        if state.current_stock > self.stock_threshold:
            play_defect = True
        else:
            play_defect = False
        if most_cooperative and play_defect:
            return Action.D
        elif not most_cooperative or not play_defect:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

    def analyze_opponent_behavior(self, history: PlayerHistory):
        opponent_CRs = {}
        for opponent in range(self.game_description.n_players - 1):
            cooperate_count = sum((1 for action in history.opponent_actions[:, opponent] if not action))
            CR = cooperate_count / len(history.opponent_actions)
            opponent_CRs[opponent] = CR
        return opponent_CRs

class Strategy_EXPLOITATIVE_248(BaseStrategy):
    """
    An exploitative strategy that adapts to the current stock level and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        current_stock = state.current_stock
        coop_threshold_high = 0.75 * self.capacity
        coop_threshold_low = 0.25 * self.capacity
        opponents_cooperated = sum((1 for action in opponent_actions if action))
        opponents_defected = self.n_players - opponents_cooperated
        if opponents_cooperated > 0.5 * self.n_players:
            coop_threshold_high = 0.85 * self.capacity
        elif opponents_cooperated < 0.3 * self.n_players:
            coop_threshold_low = 0.15 * self.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if current_stock > coop_threshold_high:
            return Action.D
        elif current_stock < coop_threshold_low:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_249(BaseStrategy):
    """
    The ASP strategy aims to balance short-term gains with long-term sustainability of the common pool resource.
    It dynamically adjusts its behavior based on the game state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.r = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        T = 0.7 * self.capacity
        if state.current_stock > T:
            action = Action.D
        else:
            action = Action.C
        opponent_payoffs = history.opponent_payoffs[-1, :]
        my_payoff = history.my_payoffs[-1]
        opponent_avg_payoff = np.mean(opponent_payoffs)
        if opponent_avg_payoff > my_payoff:
            action = Action.D
        if len(history.my_actions) >= 2 and all(history.my_actions[-2:]) and (state.current_stock <= history.my_payoffs[-2]):
            action = Action.D
        if state.round_number == self.r - 1:
            return Action.D
        critical_stock = 0.2 * self.capacity
        if state.current_stock < critical_stock:
            return Action.C
        return action

class Strategy_EXPLOITATIVE_251(BaseStrategy):
    """
    Exploitative strategy that adapts to the game's state and history while exploiting potential cooperation from other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock >= self.capacity * 0.75 else Action.D
        avg_payoff_prev = np.mean(history.my_payoffs[-1] + history.opponent_payoffs[-1, :])
        cooperate = avg_payoff_prev >= state.current_stock / (2 * self.n_players)
        defect_due_to_low_stock = state.current_stock < self.capacity * 0.25
        return Action.C if cooperate and (not defect_due_to_low_stock) else Action.D

class Strategy_EXPLOITATIVE_252(BaseStrategy):
    """
    Adaptive Stock Raider strategy: 
    Cooperates initially to observe opponents' behavior and adapts its actions 
    based on the current stock level, opponents' past behavior, and remaining rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_opponent_payoffs = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if state.current_stock < 0.5 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C
        if state.round_number + 1 == self.game_description.n_rounds:
            return Action.D
        p_defect = (state.current_stock / self.game_description.capacity) ** 2
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.D if random.random() < p_defect else Action.C
        elif 0.25 * self.game_description.capacity <= state.current_stock < 0.75 * self.game_description.capacity:
            avg_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
            game_avg_payoff = self.game_description.capacity / (2 * self.game_description.n_players)
            if avg_opponent_payoff > game_avg_payoff or (self.last_opponent_payoffs is not None and all(self.last_opponent_payoffs)):
                return Action.C
            else:
                return Action.D
        else:
            return Action.C
        self.last_opponent_payoffs = history.opponent_actions[-1, :]

class Strategy_EXPLOITATIVE_253(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.opponent_probabilities = [0.5] * game_description.n_players
        self.decision_threshold = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_level = state.current_stock / self.capacity
        opponents_defected_prev_round = sum((not action for action in history.opponent_actions[-1]))
        p_defect = opponents_defected_prev_round / self.n_players
        if stock_level > self.decision_threshold:
            return Action.D if random.random() < p_defect else Action.C
        elif 0.25 <= stock_level <= self.decision_threshold:
            p_cooperate = stock_level
            return Action.C if random.random() < p_cooperate else Action.D
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        for i, action in enumerate(history.opponent_actions[-1]):
            self.opponent_probabilities[i] = (self.opponent_probabilities[i] * (state.round_number - 1) + int(not action)) / state.round_number
        if abs(state.current_stock - history.my_payoffs[-1]) < 0.05 * self.capacity:
            self.decision_threshold = max(0.25, min(self.decision_threshold + random.uniform(-0.05, 0.05), 0.75))
        if state.round_number % 5 == 0:
            for i in range(self.n_players):
                self.opponent_probabilities[i] = (self.opponent_probabilities[i] * 4 + random.random()) / 5

class Strategy_EXPLOITATIVE_254(BaseStrategy):
    """
    Adaptive Stock Hawk (ASH) Strategy: an exploitative strategy that adapts to the game's dynamics and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.my_payoffs = np.zeros(game_description.n_rounds)
        self.opponent_payoffs = np.zeros((game_description.n_rounds, game_description.n_players))

    def calculate_my_payoff(self, current_stock: float) -> float:
        return current_stock / (2 * self.game_description.n_players)

    def update_opponent_payoffs(self, opponent_actions: NDArray[np.bool_], current_stock: float):
        for i in range(self.game_description.n_players - 1):
            action = Action(opponent_actions[i])
            if action == Action.C:
                self.opponent_payoffs[-1, i] = current_stock / (2 * self.game_description.n_players)
            elif action == Action.D:
                self.opponent_payoffs[-1, i] = current_stock / self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        avg_opponent_payoff = np.mean(self.opponent_payoffs[state.round_number - 1, :])
        my_payoff = self.calculate_my_payoff(current_stock)
        stock_ratio = current_stock / capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif stock_ratio > 0.75:
            return Action.D
        elif stock_ratio >= 0.5 and avg_opponent_payoff > my_payoff:
            return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_255(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource game that monitors opponent behavior and adjusts its actions accordingly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_consumptions = []
        self.previous_stocks = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_opponent_consumption = np.mean(history.opponent_payoffs[-1, :])
        self.previous_stocks.append(state.current_stock)
        opponent_behavior = self.analyze_opponent_behavior(avg_opponent_consumption)
        if opponent_behavior == 'excessive_cooperation':
            return Action.D
        elif opponent_behavior == 'excessive_defection':
            return Action.C
        stock_trend = self.analyze_stock_trend(self.previous_stocks)
        if stock_trend == 'rapid_depletion':
            return Action.C
        elif stock_trend == 'rapid_growth':
            return Action.D
        nash_equilibrium_threshold = state.current_stock / (2 * self.game_description.n_players)
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.D
        elif avg_opponent_consumption < nash_equilibrium_threshold:
            return Action.C
        else:
            return Action.D

    def analyze_opponent_behavior(self, avg_opponent_consumption):
        if avg_opponent_consumption > 0.75 * self.game_description.capacity / self.game_description.n_players:
            return 'excessive_cooperation'
        elif avg_opponent_consumption < 0.25 * self.game_description.capacity / self.game_description.n_players:
            return 'excessive_defection'
        else:
            return None

    def analyze_stock_trend(self, previous_stocks):
        if len(previous_stocks) < 3:
            return None
        trend = np.diff(previous_stocks[-3:])
        if all((t > 0 for t in trend)):
            return 'rapid_growth'
        elif all((t < 0 for t in trend)):
            return 'rapid_depletion'
        else:
            return None

class Strategy_EXPLOITATIVE_256(BaseStrategy):
    """
    An adaptive strategy that balances short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        opponents_defected = sum(history.opponent_actions[-1, :])
        if opponents_defected > self.game_description.n_players / 2:
            return Action.D
        cooperators = sum(1 - history.opponent_actions[-1, :])
        if cooperators >= self.game_description.n_players // 2 + 1:
            return Action.C
        if history is not None and len(history.my_payoffs) > 0:
            growth_rate = (state.current_stock - history.my_payoffs[-1]) / self.game_description.capacity
            if growth_rate < 0.2:
                return Action.D
        rounds_remaining = self.game_description.n_rounds - state.round_number
        if rounds_remaining <= self.game_description.n_rounds // 4:
            if state.current_stock > 0.5 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_257(BaseStrategy):
    """
    Robust and exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        prev_stock_level = history.my_payoffs[-1] * self.game_description.n_players * 2
        num_cooperators = sum((1 for action in history.opponent_actions[-1, :] if action))
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.D if num_cooperators < self.game_description.n_players / 2 else Action.C
        elif 0.25 * self.game_description.capacity <= state.current_stock <= 0.75 * self.game_description.capacity:
            return Action.D if num_cooperators > self.game_description.n_players / 2 else Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_258(BaseStrategy):
    """
    Exploitative strategy that adapts to the game state and history.
    Balances short-term gains with long-term sustainability by adjusting cooperation levels based on the average stock level and number of players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if self.game_description.n_players <= 5 else Action.D
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.C
        if history and np.all(~history.opponent_actions[-1, :]) and (state.current_stock < 0.5 * self.game_description.capacity):
            return Action.C
        avg_stock_level = np.mean(history.my_payoffs[max(0, state.round_number - 3):])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if avg_stock_level > 0.75 * self.game_description.capacity:
            return Action.C
        else:
            p = (1 - avg_stock_level / self.game_description.capacity) ** (self.game_description.n_players / 2)
            return Action.D if random.random() < p else Action.C

class Strategy_EXPLOITATIVE_259(BaseStrategy):
    """
    This strategy balances short-term gain with long-term sustainability while adapting to opponents' behavior.
    It decides whether to cooperate or defect based on the current stock level and opponents' actions in previous rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_ratio = state.current_stock / self.capacity
        if stock_ratio > 0.8:
            return Action.D
        elif stock_ratio >= 0.5:
            return Action.C
        else:
            return Action.D
        if history is not None and len(history.opponent_actions) > 1:
            opponent_cooperation_rate = sum(history.opponent_actions[-2:-1]) / self.n_players
            if opponent_cooperation_rate >= 0.5:
                return Action.D
            else:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * self.capacity:
            return Action.D

class Strategy_EXPLOITATIVE_260(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to the game parameters, state, and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_opponent_payoff = np.mean(history.opponent_payoffs[:-1], axis=0).mean() if history else 0
        avg_my_payoff = np.mean(history.my_payoffs[:-1]) if history and len(history.my_payoffs) > 1 else 0
        num_defectors_last_round = sum((1 - opponent for opponent in history.opponent_actions[-1, :]))
        stock_level = state.current_stock / self.game_description.capacity
        if stock_level < 0.5:
            return Action.D
        elif avg_opponent_payoff > avg_my_payoff and avg_my_payoff != 0:
            return Action.D
        elif num_defectors_last_round > 0.5 * self.game_description.n_players:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_261(BaseStrategy):
    """
    A strategy that adapts to various opponent behaviors while aiming to maximize payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_behavior = [0, 0]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock_ratio = state.current_stock / self.game_description.capacity
        num_rounds = self.game_description.n_rounds
        if state.round_number < num_rounds // 2:
            if current_stock_ratio >= 0.75:
                action = Action.D
            else:
                action = Action.C
        elif state.round_number <= 3 * num_rounds // 4:
            opponent_cooperation_rate = history.opponent_actions[:-1].mean()
            if opponent_cooperation_rate > 0.5:
                action = Action.D
            else:
                action = Action.C
        elif state.round_number < num_rounds - 1:
            if current_stock_ratio < 0.25:
                action = Action.D
            else:
                action = Action.C
        else:
            action = Action.D
        self.opponent_behavior[action == Action.C] += 1
        return action

class Strategy_EXPLOITATIVE_262(BaseStrategy):
    """
    The Adaptive Stock Exploiter (ASE) strategy balances short-term payoff maximization 
    with long-term stock sustainability by adapting to the current stock level, opponents' behavior, 
    and the number of rounds remaining.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_actions_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.opponent_actions_history.append(history.opponent_actions[-1])
        opponent_CR = np.mean(self.opponent_actions_history, axis=0)
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.D
        p = (state.current_stock / self.game_description.capacity) ** 2
        for opponent_i in range(self.game_description.n_players - 1):
            if opponent_CR[opponent_i] > 0.5 and state.current_stock < 0.75 * self.game_description.capacity:
                p += (opponent_CR[opponent_i] - 0.5) / 2
        if random.random() < p:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_263(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behavior and exploits their cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number <= 2:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        C_count = sum(history.opponent_actions[-1, :])
        CR = C_count / self.game_description.n_players
        if CR >= 0.5:
            if state.current_stock >= self.game_description.capacity / 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_264(BaseStrategy):
    """
    The Adaptive Exploiter (AE) is an exploitative strategy that adapts to current stock levels and opponents' actions.
    It balances short-term gains with long-term sustainability by cooperating initially, defecting when possible,
    conserving resources when necessary, and responding to changes in the game state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if state.current_stock < 0.5 * self.capacity:
                return Action.D
            else:
                return Action.C
        if state.current_stock > 0.75 * self.capacity:
            return Action.D
        elif state.current_stock >= 0.5 * self.capacity and state.current_stock <= 0.75 * self.capacity:
            opponents_defected = sum([not opp_action for opp_action in history.opponent_actions[-1, :]])
            if opponents_defected >= len(history.opponent_actions[-1, :]) / 2:
                return Action.C
            else:
                return Action.D
        elif state.current_stock < 0.5 * self.capacity:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif len(history.my_actions) >= 2 and history.my_payoffs[-1] == history.my_payoffs[-2]:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_265(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.acl = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_cooperations = np.sum(history.opponent_actions, axis=1)
        self.acl = np.mean(opponent_cooperations / self.game_description.n_players)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if self.acl < 0.5:
            return Action.D
        if self.acl >= 0.5 and state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        if self.acl < 0.2 or state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_266(BaseStrategy):
    """
    A hybrid exploitative strategy that combines elements of Tit-for-Tat and a novel stock-based approach.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.r_max = game_description.n_rounds

    def calculate_stock_threshold(self, current_stock, capacity):
        return current_stock / capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        T = self.calculate_stock_threshold(state.current_stock, self.capacity)
        if T > 0.75:
            action = Action.C
        elif 0.5 <= T < 0.75:
            action = random.choice([Action.C, Action.D])
        else:
            action = Action.D
        for opponent_action in history.opponent_actions[-1, :]:
            if not opponent_action:
                return Action.D
            elif opponent_action and action == Action.C:
                continue
        my_payoffs = history.my_payoffs[-3:]
        avg_my_payoff = np.mean(my_payoffs) if len(my_payoffs) > 0 else 0.0
        opponent_avg_payoffs = np.mean(history.opponent_payoffs, axis=1)
        if any(opponent_avg_payoffs > 1.2 * avg_my_payoff):
            action = Action.D
        if state.round_number == self.r_max - 1 and state.current_stock < 0.25 * self.capacity:
            return Action.D
        return action

class Strategy_EXPLOITATIVE_267(BaseStrategy):
    """
    Exploitative strategy that balances short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.stock_threshold = self.game_description.capacity / (2 * self.game_description.n_players) * (1 - 1 / (self.game_description.n_rounds - state.round_number + 1)) ** 2
        if state.current_stock < self.stock_threshold:
            if history.opponent_actions.shape[0] > 1:
                opponent_defection_rates = np.mean(history.opponent_actions, axis=0)
                for i in range(self.game_description.n_players - 1):
                    if opponent_defection_rates[i] > 0.5:
                        return Action.D
            return Action.D
        elif state.current_stock <= 0.5 * self.game_description.capacity and history.my_payoffs.sum() > (self.game_description.n_rounds - state.round_number) * state.current_stock / (2 * self.game_description.n_players):
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_268(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_depletion_rates = []
        self.previous_round_payoffs = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.previous_round_payoffs.append(np.mean(history.my_payoffs))
        avg_payoff_prev = np.mean(self.previous_round_payoffs[-1])
        if state.round_number <= 5:
            if avg_payoff_prev >= self.game_description.capacity / (4 * self.game_description.n_players):
                return Action.C
            else:
                return Action.D
        stock_depletion_rate = self.calculate_stock_depletion_rate(history, self.game_description.capacity)
        if state.round_number > 5 and (stock_depletion_rate >= self.game_description.capacity / (2 * self.game_description.n_players) or (state.round_number >= self.game_description.n_rounds - 5 and state.current_stock <= self.game_description.capacity / 2)):
            return Action.D
        else:
            return Action.C
        if state.current_stock < self.game_description.capacity / 4:
            return Action.D

    def calculate_stock_depletion_rate(self, history: PlayerHistory, capacity: float) -> float:
        recent_rounds = history.my_payoffs[-3:]
        if len(recent_rounds) < 3:
            return 0.0
        total_depletion = sum(recent_rounds)
        avg_depletion_rate = total_depletion / len(recent_rounds)
        self.stock_depletion_rates.append(avg_depletion_rate)
        return min(max(0, avg_depletion_rate), capacity)

class Strategy_EXPLOITATIVE_269(BaseStrategy):
    """
    Adaptive Stock Depletion Strategy (ASD)

    This strategy aims to maximize individual payoffs by adaptively responding 
    to the game state and opponents' past actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.low_threshold = 0.3 * game_description.capacity
        self.high_threshold = 0.7 * game_description.capacity

    def calculate_avg_opponent_payoff(self, stock, n_players):
        if isinstance(stock, CommonPoolState):
            current_stock = stock.current_stock
        else:
            current_stock = stock
        return 0.5 * (current_stock / n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_opponent_payoff_prev = self.calculate_avg_opponent_payoff(state.current_stock, self.game_description.n_players)
        if state.current_stock > self.high_threshold:
            return Action.D
        elif state.current_stock < self.low_threshold:
            return Action.C
        elif avg_opponent_payoff_prev > 0.5 * (state.current_stock / self.game_description.n_players):
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_270(BaseStrategy):
    """
    Exploitative strategy that adapts to opponent behavior and stock trends.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_behavior = self.analyze_opponent_actions(history)
        stock_trend = self.analyze_stock_trend(state, history)
        cooperate = False
        defect = True
        if opponent_behavior == 'mostly_defect':
            cooperate = True
        elif opponent_behavior == 'mostly_cooperate':
            defect = True
        if stock_trend == 'rapid_depletion':
            cooperate = True
        elif stock_trend == 'stable_or_increasing':
            defect = True
        capacity = self.game_description.capacity
        stock_level = state.current_stock / capacity
        if stock_level > 0.75:
            action = Action.D
        elif stock_level >= 0.5 and stock_level <= 0.75:
            action = Action.C if cooperate else Action.D
        else:
            action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        return action

    def analyze_opponent_actions(self, history: PlayerHistory) -> str:
        last_round_opponents = history.opponent_actions[-1, :]
        cooperators = sum(last_round_opponents)
        if cooperators >= self.game_description.n_players // 2:
            return 'mostly_cooperate'
        else:
            return 'mostly_defect'

    def analyze_stock_trend(self, state: CommonPoolState, history: PlayerHistory) -> str:
        if len(history.my_payoffs) < 3:
            return 'stable_or_increasing'
        recent_stocks = [history.my_payoffs[-i] for i in range(1, min(4, len(history.my_payoffs) + 1))]
        stock_decrease = np.mean(np.diff(recent_stocks))
        if stock_decrease > 0.2 * self.game_description.capacity:
            return 'rapid_depletion'
        else:
            return 'stable_or_increasing'

class Strategy_EXPLOITATIVE_271(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def adaptive_exploiter(self, stock: float, capacity: float) -> Action:
        stock_ratio = stock / capacity
        if stock_ratio > 0.75:
            return Action.D
        elif stock_ratio <= 0.25:
            return Action.C
        else:
            p_cooperate = stock_ratio ** 2
            return Action.C if random.random() < p_cooperate else Action.D

    def opponent_based_adaptation(self, opponent_history: NDArray[np.bool_]) -> None | Action:
        defect_count = sum((1 for action in opponent_history if not action))
        cooperate_count = len(opponent_history) - defect_count
        if defect_count >= 0.5 * len(opponent_history):
            return Action.C
        elif cooperate_count >= 0.75 * len(opponent_history):
            return Action.D

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        action = self.adaptive_exploiter(state.current_stock, self.game_description.capacity)
        if history is not None and len(history.opponent_actions.shape) > 1:
            for opponent_history in history.opponent_actions.T:
                opponent_action = self.opponent_based_adaptation(opponent_history[:state.round_number])
                if opponent_action is not None:
                    action = opponent_action
                    break
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock <= 0.25 * self.game_description.capacity and state.round_number >= self.game_description.n_rounds - 3:
            return Action.C
        return action

class Strategy_EXPLOITATIVE_272(BaseStrategy):
    """
    Adaptive Stock-Dependent (ASD) strategy. Exploits opponents' behaviors while adapting to the dynamic state of the common pool resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_high = 0.75 * game_description.capacity
        self.threshold_low = 0.25 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_defect_frequently = self._opponents_defect_frequently(history)
        opponents_cooperate_frequently = self._opponents_cooperate_frequently(history)
        if opponents_defect_frequently or state.round_number + 1 == self.game_description.n_rounds:
            return Action.D
        elif state.current_stock >= self.threshold_high:
            return Action.C
        elif state.current_stock <= self.threshold_low:
            return Action.D
        else:
            if opponents_cooperate_frequently:
                return Action.D
            return Action.C

    def _opponents_defect_frequently(self, history: PlayerHistory):
        n_rounds_to_check = min(5, len(history.my_actions))
        recent_opponent_actions = history.opponent_actions[-n_rounds_to_check:, :]
        return np.any(np.mean(recent_opponent_actions == 0, axis=0) > 0.5)

    def _opponents_cooperate_frequently(self, history: PlayerHistory):
        n_rounds_to_check = min(5, len(history.my_actions))
        recent_opponent_actions = history.opponent_actions[-n_rounds_to_check:, :]
        return np.any(np.mean(recent_opponent_actions == 1, axis=0) > 0.5)

class Strategy_EXPLOITATIVE_273(BaseStrategy):
    """
    An exploitative strategy that balances short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if state.round_number == 0:
            return Action.C
        if current_stock > 0.75 * capacity:
            return Action.D
        elif 0.5 <= current_stock / capacity < 0.75:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators >= self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D
        elif current_stock / capacity < 0.5:
            return Action.C

class Strategy_EXPLOITATIVE_274(BaseStrategy):
    """
    Exploitative strategy that adapts to the current state of the game and other players' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.payoff_for_coop = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return random.choice([Action.C, Action.D])
        stock_percentage = state.current_stock / self.game_description.capacity
        avg_payoff_prev_round = np.mean(history.my_payoffs[-1] + history.opponent_payoffs[-1, :])
        if state.current_stock <= self.game_description.capacity / (2 * self.game_description.n_players):
            return Action.C
        if stock_percentage > 0.75:
            return Action.C
        elif 0.25 <= stock_percentage < 0.75:
            if avg_payoff_prev_round > self.payoff_for_coop:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_275(BaseStrategy):
    """
    An exploitative strategy that adapts to opponents' behaviors and the dynamic state of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.5

    def calculate_average_ocr(self, history: PlayerHistory) -> float:
        cooperate_count = np.sum(history.opponent_actions[:, :])
        avg_ocr = cooperate_count / (history.my_actions.size * self.game_description.n_players)
        return avg_ocr

    def adjust_threshold(self, avg_ocr: float):
        if avg_ocr >= 0.8:
            self.threshold = 0.4
        elif avg_ocr <= 0.2:
            self.threshold = 0.6

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        avg_ocr = self.calculate_average_ocr(history)
        self.adjust_threshold(avg_ocr)
        current_stock_level = state.current_stock
        if current_stock_level <= self.game_description.n_players * current_stock_level / self.game_description.n_players:
            return Action.C
        elif current_stock_level > self.game_description.capacity - self.game_description.n_players * current_stock_level / self.game_description.n_players:
            return Action.D
        if avg_ocr >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_276(BaseStrategy):
    """
    A hybrid strategy that combines elements of reactive and proactive decision-making.
    It adapts to the game's dynamics while seeking to maximize its own payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperativeness_scores = [0.5] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.opponent_cooperativeness_scores = np.mean(history.opponent_actions, axis=0)
        avg_opponent_coop_score = np.mean(self.opponent_cooperativeness_scores)
        if state.round_number <= self.game_description.n_rounds // 2:
            if state.current_stock >= 0.75 * self.game_description.capacity:
                return Action.D if random.random() < 0.7 else Action.C
            else:
                return Action.C
        elif state.round_number <= 3 * self.game_description.n_rounds // 4:
            if state.current_stock >= 0.5 * self.game_description.capacity:
                return Action.D if random.random() < 0.5 + (1 - avg_opponent_coop_score) else Action.C
            else:
                return Action.C
        elif state.round_number <= self.game_description.n_rounds:
            if state.current_stock >= 0.25 * self.game_description.capacity:
                return Action.C if random.random() < 0.5 + avg_opponent_coop_score else Action.D
            else:
                return Action.D
        if state.round_number == self.game_description.n_rounds and state.current_stock >= 0.1 * self.game_description.capacity:
            return Action.D

class Strategy_EXPLOITATIVE_277(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behaviors and the dynamic state of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.sct_history = []

    def calculate_avg_coop_rate(self, history: PlayerHistory) -> float:
        if len(history.my_actions) < 5:
            return np.mean(history.opponent_actions)
        recent_rounds = history.opponent_actions[-5:, :]
        avg_coop_rate = np.mean(recent_rounds)
        return avg_coop_rate

    def calculate_avg_stock_growth(self, state: CommonPoolState, history: PlayerHistory) -> float:
        if len(history.my_payoffs) < 5:
            return 0.0
        recent_growth = []
        for i in range(-5, -1):
            growth = max(0.0, state.current_stock - history.my_payoffs[i] * self.game_description.n_players)
            recent_growth.append(growth)
        avg_stock_growth = np.mean(recent_growth)
        return avg_stock_growth

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.sct_history.append((state.current_stock, 1.0))
            return Action.C
        sct = (self.game_description.capacity - state.current_stock) / (2 * self.game_description.n_players)
        avg_coop_rate = self.calculate_avg_coop_rate(history)
        if avg_coop_rate > 0.5:
            sct *= 1.1
        avg_stock_growth = self.calculate_avg_stock_growth(state, history)
        if avg_stock_growth > 0:
            sct *= 0.9
        cooperators = sum((1 for action in history.opponent_actions[-1, :] if action))
        if len(self.sct_history) >= 5 and self.game_description.n_rounds - state.round_number <= 1:
            scts = [x[1] for x in self.sct_history[-5:]]
            avg_sct = np.mean(scts)
            if cooperators >= avg_sct * self.game_description.n_players:
                return Action.C
        elif len(self.sct_history) < 5 or state.current_stock > sct * 2 * self.game_description.n_players:
            return Action.D
        self.sct_history.append((state.current_stock, sct))
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif cooperators >= sct * self.game_description.n_players:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_278(BaseStrategy):
    """
    Exploitative strategy adapting to opponents' behavior and game state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C if state.current_stock >= 0.75 * self.capacity else Action.D
        total_consumption_prev = np.sum(history.opponent_actions[-1, :])
        own_payoff_prev = history.my_payoffs[-1]
        avg_opponent_payoff_prev = np.mean([payoff for payoff in history.opponent_payoffs[-1] if payoff != own_payoff_prev])
        if total_consumption_prev > 0.5 * self.capacity:
            return Action.C if own_payoff_prev > avg_opponent_payoff_prev else Action.D
        elif state.current_stock >= 0.5 * self.capacity:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        action = None
        if state.current_stock < 0.25 * self.capacity and history.my_actions[-1]:
            action = Action.C
        elif state.current_stock > 0.75 * self.capacity and (not history.my_actions[-1]):
            action = Action.D
        opponent_actions = [opp_action for opp_action in history.opponent_actions[-1] if opp_action != history.my_actions[-1]]
        most_common_opponent_action = np.argmax(np.bincount(opponent_actions.astype(int)))
        if len(opponent_actions) >= self.n_players / 2:
            return Action.C if most_common_opponent_action == 0 else Action.D
        return action

class Strategy_EXPLOITATIVE_279(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.low_stock = 0.3 * game_description.capacity
        self.high_stock = 0.7 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_defected_last_two_rounds = False
        if len(history.my_actions) >= 2 and any((not action for action in history.opponent_actions[-2:, :].flatten())):
            opponent_defected_last_two_rounds = True
        total_consumption_last_round = sum((action * state.current_stock / (self.game_description.n_players * (1 + int(not action))) for action in history.opponent_actions[-1, :] + [history.my_actions[-1]]))
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif opponent_defected_last_two_rounds and state.current_stock > self.high_stock:
            return Action.C
        elif total_consumption_last_round > 0.5 * self.game_description.capacity or any((not action for action in history.opponent_actions[-1, :])) or state.current_stock < self.low_stock:
            return Action.D
        elif self.low_stock <= state.current_stock <= self.high_stock:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_280(BaseStrategy):
    """
    The Adaptive Stock Hawk strategy is designed to exploit a wide range of opponent behaviors while adapting to changing game conditions.
    This strategy prioritizes defecting (D) when possible, but cooperates (C) when necessary to maintain a healthy stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        S = state.current_stock
        TC = 0 if history is None else sum(history.opponent_actions[-1, :]) / (self.game_description.n_players - 1)
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if S >= self.capacity / 2:
            if TC > self.capacity / 4:
                return Action.C
            else:
                return Action.D
        elif S < self.capacity / 2:
            if TC <= self.capacity / 4 or (TC == self.capacity / 2 and S < self.capacity / 2):
                return Action.C
            else:
                return Action.D
        if S == 0:
            return Action.C
        if TC == self.capacity / 2 and S >= self.capacity / 2:
            return Action.D

class Strategy_EXPLOITATIVE_281(BaseStrategy):
    """
    A robust and adaptive exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.avg_opponent_consumption = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_consumption = np.sum(history.opponent_actions[-1, :] == False)
        self.avg_opponent_consumption += (prev_round_consumption - self.avg_opponent_consumption) / state.round_number
        if state.current_stock / self.game_description.capacity < 0.5 or self.avg_opponent_consumption > state.current_stock / self.game_description.n_players:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if history.opponent_actions.shape[1] == 1 and history.opponent_actions[-1, 0]:
            return Action.C

class Strategy_EXPLOITATIVE_282(BaseStrategy):
    """
    The Adaptive Stock Hawk is a dynamic, history-dependent strategy designed to exploit opponents' behaviors while adapting to changing game conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.75 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        cooperators = sum(history.opponent_actions[-2:, :].sum(axis=1) >= len(history.my_actions))
        if cooperators > 1:
            return Action.D
        self.threshold = max(0.25 * self.game_description.capacity, min(self.threshold - 0.05 * self.game_description.capacity, self.threshold + 0.1 * self.game_description.capacity))
        if state.current_stock >= self.threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_283(BaseStrategy):
    """
    A robust and adaptive exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.theta = 0.5

    def calculate_opponent_acr(self, history: PlayerHistory) -> float:
        """
        Calculate the opponent's average cooperation rate (ACR).
        
        Args:
            history: The player's history.
        
        Returns:
            The opponent's ACR.
        """
        cooperate_count = sum((1 for action in history.opponent_actions[:, 0] if action))
        return cooperate_count / len(history.opponent_actions)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_acr = self.calculate_opponent_acr(history)
        if state.current_stock > self.game_description.capacity / 2:
            self.theta -= 0.1
        elif state.current_stock < self.game_description.capacity / 4:
            self.theta += 0.1
        if opponent_acr < self.theta:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_284(BaseStrategy):
    """
    A strategy that adapts to the current stock level and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        stock_level = state.current_stock / self.capacity
        if history is None or len(history.my_actions) < 2:
            return random.choice([Action.C, Action.D])
        opponent_payoffs_last_round = history.opponent_payoffs[-1]
        avg_opponent_payoff = np.mean(opponent_payoffs_last_round)
        median_payoff = np.median(np.concatenate((opponent_payoffs_last_round, [history.my_payoffs[-1]])))
        if stock_level > 0.75:
            return Action.D
        elif 0.5 <= stock_level <= 0.75:
            if avg_opponent_payoff < median_payoff:
                return Action.C
            else:
                return Action.D
        elif state.current_stock < 0.25 * self.capacity:
            return Action.C
        else:
            opponent_actions_last_round = history.opponent_actions[-1]
            opponents_played_same_action_for_two_rounds = np.all(opponent_actions_last_round == history.opponent_actions[-2])
            if opponents_played_same_action_for_two_rounds:
                if np.all(opponent_actions_last_round):
                    return Action.D
                else:
                    return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_285(BaseStrategy):
    """
    An exploitative strategy that adapts to opponents' behavior and exploits high stock levels, 
    cooperative opponents, and favorable growth conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_stock = 0.75 * game_description.capacity
        self.threshold_growth = 0.5 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock >= self.threshold_stock:
            return Action.D
        cooperative_opponents = []
        for opponent_actions, opponent_payoffs in zip(history.opponent_actions[-1, :], history.opponent_payoffs[-1, :]):
            if not opponent_actions or opponent_payoffs > 0:
                cooperative_opponents.append(opponent_actions)
        if len(cooperative_opponents) > self.game_description.n_players / 2:
            return Action.C
        growth = 2 * state.current_stock * (1 - state.current_stock / self.game_description.capacity)
        if growth >= self.threshold_growth:
            return Action.C
        for opponent_actions, opponent_payoffs in zip(history.opponent_actions[-1, :], history.opponent_payoffs[-1, :]):
            if not opponent_actions or opponent_payoffs > 0:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_286(BaseStrategy):
    """
    Exploits cooperative opponents while maintaining a healthy stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.window_size = 3
        self.cooperation_threshold = 0.6
        self.opponent_cooperation_scores = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if self.opponent_cooperation_scores is None:
            self.opponent_cooperation_scores = [0] * (self.game_description.n_players - 1)
        opponent_actions = history.opponent_actions
        for i, actions in enumerate(opponent_actions.T):
            cooperation_score = np.mean(actions[-self.window_size:])
            self.opponent_cooperation_scores[i] = cooperation_score
        if state.current_stock < self.game_description.capacity * 0.5:
            return Action.C
        elif np.mean(self.opponent_cooperation_scores) > self.cooperation_threshold:
            return Action.D
        elif random.random() < 0.7:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_287(BaseStrategy):
    """
    The Adaptive Stock Raider strategy aims to maximize its own payoff by adaptively responding 
    to the current state of the game and the actions of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_half = game_description.capacity / 2
        self.capacity_fourth = game_description.capacity / 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        total_consumption_prev_round = sum(history.opponent_actions[-1]) * self.game_description.capacity / (2 * self.game_description.n_players)
        if 1 <= state.round_number < self.game_description.n_rounds // 3:
            if state.current_stock > self.capacity_half:
                return Action.C
            elif total_consumption_prev_round > self.capacity_fourth:
                return Action.D
            else:
                return Action.C
        elif self.game_description.n_rounds // 3 <= state.round_number < 2 * self.game_description.n_rounds // 3:
            if state.current_stock > self.capacity_half and total_consumption_prev_round < self.capacity_fourth:
                return Action.D
            else:
                return Action.C
        elif 2 * self.game_description.n_rounds // 3 <= state.round_number <= self.game_description.n_rounds:
            if state.current_stock > self.capacity_fourth and state.round_number < self.game_description.n_rounds - self.game_description.n_rounds // 6:
                return Action.D
            else:
                return Action.C
        return 'Invalid round'

class Strategy_EXPLOITATIVE_288(BaseStrategy):
    """
    Exploitative strategy that adapts to opponent behavior and game state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.P_C = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.D
        current_stock = state.current_stock
        n_cooperators = sum(history.opponent_actions[-1, :])
        C_rate = n_cooperators / self.n_players
        if C_rate > 0.5:
            self.P_C = min(1, self.P_C + 0.1)
        elif C_rate < 0.5:
            self.P_C = max(0, self.P_C - 0.1)
        if state.round_number < self.game_description.n_rounds - 1:
            if current_stock > 0.5 * self.stock_capacity:
                return Action.C if random.random() < self.P_C else Action.D
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_289(BaseStrategy):
    """
    Exploitative strategy that adaptively responds to the game state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponents_behavior = None
        self.majority_cooperated_thresholds_adjusted = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.opponents_behavior = self.monitor_opponents(history)
        if self.majority_cooperated(self.opponents_behavior):
            self.adjust_thresholds()
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.C
        if state.current_stock >= (0.9 if self.majority_cooperated_thresholds_adjusted else 0.75) * self.game_description.capacity:
            return Action.D
        elif (0.25 if self.majority_cooperated_thresholds_adjusted else 0.5) * self.game_description.capacity <= state.current_stock < (0.9 if self.majority_cooperated_thresholds_adjusted else 0.75) * self.game_description.capacity:
            return Action.C
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

    def monitor_opponents(self, history: PlayerHistory):
        opponents_cooperation_rates = np.mean(history.opponent_actions, axis=0)
        return opponents_cooperation_rates

    def majority_cooperated(self, opponents_behavior: NDArray[np.float64]):
        if np.sum(opponents_behavior > 0.5) >= self.game_description.n_players // 2:
            return True
        return False

    def adjust_thresholds(self):
        self.majority_cooperated_thresholds_adjusted = True

class Strategy_EXPLOITATIVE_290(BaseStrategy):
    """
    Exploitative strategy that adaptively depletes the stock level and responds to opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_threshold = 0.75 * self.game_description.capacity
        last_round_opponent_actions = history.opponent_actions[-1, :] if history else None
        if state.current_stock > stock_threshold:
            return Action.D
        elif state.current_stock <= stock_threshold:
            return Action.C
        if last_round_opponent_actions is not None:
            opponent_behavior = np.mean(last_round_opponent_actions)
            if opponent_behavior > 0.5:
                return Action.D
            elif opponent_behavior < 0.5:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_291(BaseStrategy):
    """
    The Adaptive Stock Hawk strategy is designed to exploit opponents' behavior while adapting to the dynamic state of the game.
    This strategy prioritizes cooperation when the stock level is high and defects when the stock level is low, with a smooth transition between these two modes.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (state.round_number == 1 and self.game_description.n_players == 2 and (self.game_description.n_rounds == 2)):
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio > 0.7:
            return Action.C
        else:
            defect_prob = max(0, min(1, (0.7 - stock_ratio) / 0.3))
            if random.random() < defect_prob:
                return Action.D
            else:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_292(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' actions and the game state while protecting the stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.7
        self.low_stock_threshold = 0.2 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        scr = state.current_stock / self.game_description.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.low_stock_threshold:
            return Action.C
        num_defectors = sum((not action for action in history.opponent_actions[-1, :]))
        if scr >= self.cooperation_threshold:
            if num_defectors > self.game_description.n_players / 2:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_293(BaseStrategy):
    """
    A robust and exploitative strategy designed for the Common Pool Resource Game.
    Adapts to various opponent behaviors by analyzing the game's history and state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.aggressive_opponents = set()

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        opponents_behavior = np.mean(history.opponent_actions[-1, :], axis=0)
        if stock_level > 0.75:
            return Action.D
        elif 0.25 <= stock_level <= 0.75:
            if np.mean(opponents_behavior) > 0.5:
                return Action.C
            else:
                return Action.D
        else:
            for opponent_idx, opponent_action in enumerate(history.opponent_actions[-1, :]):
                if not opponent_action and opponent_idx in self.aggressive_opponents:
                    return Action.D
            return Action.C
        if state.round_number == self.game_description.n_rounds - 2:
            if np.mean(opponents_behavior) > 0.5:
                return Action.D
            else:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if history.opponent_actions.shape[0] >= 2:
            for opponent_idx, opponent_actions in enumerate(history.opponent_actions[-2:, :].T):
                if not all(opponent_actions) and state.current_stock / self.game_description.capacity < 0.25:
                    self.aggressive_opponents.add(opponent_idx)

class Strategy_EXPLOITATIVE_294(BaseStrategy):
    """
    The Adaptive Stock Raider strategy aims to maximize its payoff by adaptively adjusting 
    its cooperation level based on the current stock state and the observed behavior of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperation_rate = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        stock_percentage = state.current_stock / self.game_description.capacity
        if stock_percentage > 0.75:
            return Action.D
        elif 0.25 <= stock_percentage <= 0.75:
            cooperation_probability = 0.5 * stock_percentage
            return Action.C if random.random() < cooperation_probability else Action.D
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if history is not None and len(history.my_actions) > 5:
            recent_opponent_cooperation_rate = np.mean(np.any(history.opponent_actions[-5:], axis=1))
            self.opponent_cooperation_rate -= (self.opponent_cooperation_rate - recent_opponent_cooperation_rate) / 10
        if history is not None and len(history.my_payoffs) > 5:
            recent_stock_trend = np.mean(np.diff(history.my_payoffs[-5:]))
            if recent_stock_trend < 0:
                cooperation_probability -= 0.1

class Strategy_EXPLOITATIVE_295(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Stock Raider (ASR)

    The ASR strategy aims to maximize its payoff by adaptively responding to the game state and opponent behavior.
    It balances cooperation and defection to ensure long-term stock sustainability while exploiting opponents' weaknesses.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        low_threshold = 0.5 * self.game_description.capacity
        high_threshold = 0.8 * self.game_description.capacity
        if state.current_stock < low_threshold:
            return Action.C
        elif state.current_stock > high_threshold:
            return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        num_cooperators = sum(opponent_actions)
        num_defectors = len(opponent_actions) - num_cooperators
        if num_cooperators > num_defectors:
            return Action.C
        else:
            return Action.D
        growth_rate = 2 * state.current_stock * (1 - state.current_stock / self.game_description.capacity)
        if growth_rate > 0.5 * self.game_description.capacity:
            return Action.C
        elif growth_rate < 0.2 * self.game_description.capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_296(BaseStrategy):
    """
    A hybrid strategy that balances exploitation with sustainability in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperation_rates = [0.5] * (game_description.n_players - 1)
        self.recent_opponent_actions = np.full((game_description.n_rounds, game_description.n_players - 1), True)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        for i in range(self.game_description.n_players - 1):
            self.opponent_cooperation_rates[i] = np.mean(history.opponent_actions[:, i])
            self.recent_opponent_actions[state.round_number % self.game_description.n_rounds, i] = history.opponent_actions[-1, i]
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.D
        elif 0.25 * self.game_description.capacity <= state.current_stock <= 0.75 * self.game_description.capacity:
            most_recent_opponent_behavior = np.mean(self.recent_opponent_actions[-1, :])
            if most_recent_opponent_behavior > 0.5:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C
        for opponent in range(self.game_description.n_players - 1):
            cooperation_rate = self.opponent_cooperation_rates[opponent]
            if cooperation_rate > 0.7:
                return Action.D
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_297(BaseStrategy):
    """
    An adaptive strategy that maximizes payoffs by balancing short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        average_payoff_previous_round = np.mean(history.my_payoffs[-1] + history.opponent_payoffs[-1, :])
        if self.game_description.capacity * 0.75 < state.current_stock:
            return Action.D
        elif self.game_description.capacity * 0.25 <= state.current_stock and state.current_stock <= self.game_description.capacity * 0.75:
            if average_payoff_previous_round < self.game_description.capacity / (2 * self.game_description.n_players):
                return Action.C
            else:
                return Action.D
        elif state.current_stock < self.game_description.capacity * 0.25:
            if self.previous_action == 'C':
                return Action.C
            else:
                return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < self.game_description.capacity * 0.1:
            if self.previous_action == 'C':
                return Action.C
            else:
                return Action.C
        self.previous_action = Action.C if random.random() < 0.5 else Action.D
        return self.previous_action

class Strategy_EXPLOITATIVE_298(BaseStrategy):
    """
    A hybrid strategy that balances short-term gains with long-term sustainability by dynamically adjusting its behavior based on the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == 1:
            return Action.C
        current_stock = state.current_stock
        round_number = state.round_number
        theta = 0.6 + 0.1 * (round_number / self.n_rounds)
        if history is not None:
            opponents_cooperated = sum(history.opponent_actions[-1, :])
            if opponents_cooperated > self.game_description.n_players // 2:
                theta += 0.05
            else:
                theta -= 0.05
        if current_stock >= theta * self.capacity:
            action = Action.C
        elif current_stock >= 0.8 * self.capacity and (history is not None and sum(history.opponent_actions[-1, :]) > self.game_description.n_players // 2):
            action = Action.D
        else:
            action = Action.D
        if current_stock < 0.2 * self.capacity:
            action = Action.C
        elif round_number == self.n_rounds - 1:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_299(BaseStrategy):
    """
    An exploitative strategy that adapts to opponents' behavior and the game's state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        round_number = state.round_number
        if round_number == 0:
            return random.choice([Action.C, Action.D])
        elif round_number < self.game_description.n_rounds / 2:
            if current_stock > 0.75 * self.capacity:
                return Action.C
            else:
                return Action.D
        elif self.game_description.n_rounds / 2 <= round_number < self.game_description.n_rounds * 3 / 4:
            if history is not None:
                opponent_actions = history.opponent_actions[-1, :]
                opponents_cooperated = np.sum(opponent_actions)
                if opponents_cooperated > 0.5 * self.n_players and current_stock >= 0.25 * self.capacity:
                    return Action.C
            return Action.D
        elif current_stock >= 0.5 * self.capacity:
            return Action.C
        elif current_stock < 0.1 * self.capacity:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_300(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behaviors and the game state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_classifications = [None] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_payoffs = history.my_payoffs[:state.round_number]
        opponent_actions = history.opponent_actions[:state.round_number]
        avg_coop_payoff = np.mean(my_payoffs[opponent_actions[:, 0] == True])
        avg_defect_payoff = np.mean(my_payoffs[opponent_actions[:, 0] == False])
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.D if avg_defect_payoff > avg_coop_payoff else Action.C
        elif state.round_number > self.game_description.n_rounds // 2:
            opponent_actions_last_round = opponent_actions[-1]
            cooperators_last_round = sum(opponent_actions_last_round[1:])
            if cooperators_last_round >= (self.game_description.n_players - 1) // 2:
                return Action.C
            else:
                return Action.D
        elif state.round_number > 3 * self.game_description.n_rounds // 4:
            return Action.D if state.current_stock < 0.5 * self.game_description.capacity else Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        for i, action in enumerate(opponent_actions[-1]):
            if self.opponent_classifications[i] is None:
                if all(opponent_actions[:, i] == False):
                    self.opponent_classifications[i] = 'defector'
                elif all(opponent_actions[:, i] == True):
                    self.opponent_classifications[i] = 'cooperator'
        if state.current_stock < 0.5 * self.game_description.capacity and any((classification == 'cooperator' for classification in self.opponent_classifications)):
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_301(BaseStrategy):
    """
    Exploit a wide range of opponent behaviors while adapting to the dynamic state of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_depletion_rates = []
        self.opponent_cooperation_rates = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (state.round_number == 1 and self.game_description.n_rounds == 2):
            if state.current_stock >= 0.9 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        elif 2 <= state.round_number < self.game_description.n_rounds - 1:
            current_depletion = (self.stock_depletion_rates[-1] if self.stock_depletion_rates else history.my_actions[-1]) if history is not None else 0.5
            new_depletion = max(0, min(1, state.current_stock / self.game_description.capacity - current_depletion))
            self.stock_depletion_rates.append(new_depletion)
            avg_coop_rate = np.mean(history.opponent_actions[-self.game_description.n_rounds // 2:, :]) if history else 0.5
            self.opponent_cooperation_rates.append(avg_coop_rate)
            low_stock_threshold = 0.25 * self.game_description.capacity
            high_stock_threshold = 0.75 * self.game_description.capacity
            if new_depletion > 0.5:
                return Action.C
            elif avg_coop_rate > 0.5 and state.current_stock < high_stock_threshold:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_302(BaseStrategy):
    """
    Adaptive Exploitation strategy for the Common Pool Resource Game.
    
    This strategy aims to maximize individual payoffs by adapting to the game state and history while exploiting opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_consumption = np.sum(history.opponent_actions[-1, :])
        avg_opponent_consumption = total_consumption / self.n_players * state.current_stock / self.n_players
        if avg_opponent_consumption < state.current_stock / (2 * self.n_players):
            opponent_behavior = 'cooperative'
        elif avg_opponent_consumption > state.current_stock / self.n_players:
            opponent_behavior = 'defective'
        else:
            opponent_behavior = 'mixed'
        if opponent_behavior == 'cooperative':
            action = Action.D
        elif opponent_behavior == 'defective':
            action = Action.C
        else:
            majority_action = np.mean(history.opponent_actions[-1, :]) > 0.5
            action = Action.C if majority_action else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        if state.current_stock < 0.2 * self.capacity:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_303(BaseStrategy):
    """
    A robust and adaptive exploitative strategy for the Common Pool Resource Game.
    
    This strategy aims to adaptively balance resource exploitation with conservation,
    while also exploiting opponents' cooperation rates. By monitoring stock levels 
    and opponent behavior, "Adaptive Predator" adjusts its actions to maximize payoffs
    while minimizing the risk of resource depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.opponent_profiles = {i: {'C-rate': 0.5} for i in range(game_description.n_players)}
        self.avg_depletion_rate_window_size = 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_level = state.current_stock
        self.stock_history.append(stock_level)
        opponents_coop_rate = sum((profile['C-rate'] for profile in self.opponent_profiles.values())) / len(self.opponent_profiles)
        if stock_level > self.game_description.capacity / 2 and opponents_coop_rate > self.game_description.n_players / 2:
            return Action.D if random.random() < 0.7 else Action.C
        elif stock_level < self.game_description.capacity / 4:
            return Action.C
        avg_depletion_rate = self.calculate_avg_depletion_rate(self.stock_history)
        if avg_depletion_rate > self.game_description.capacity / 10:
            self.increase_cooperation_probability()
        for i, action in enumerate(history.opponent_actions[-1, :]):
            self.update_opponent_profile(self.opponent_profiles[i], action)
        if history is not None:
            for i, opponent_action in enumerate(history.opponent_actions[-1, :]):
                if opponent_action and self.opponent_profiles[i]['C-rate'] > 0.7:
                    return Action.D if random.random() < 0.9 else Action.C
                elif not opponent_action and self.opponent_profiles[i]['C-rate'] < 0.3:
                    return Action.C if random.random() < 0.6 else Action.D
        return Action.C

    def calculate_avg_depletion_rate(self, stock_history):
        window_size = min(len(stock_history), self.avg_depletion_rate_window_size)
        avg_depletion_rate = sum([stock_history[i] - stock_history[i - 1] for i in range(1, window_size)]) / (window_size - 1) if window_size > 1 else 0
        return abs(avg_depletion_rate)

    def update_opponent_profile(self, profile: dict, action: bool):
        if action:
            profile['C-rate'] += 0.1
        else:
            profile['C-rate'] -= 0.1
        profile['C-rate'] = max(0, min(profile['C-rate'], 1))

    def increase_cooperation_probability(self):
        for profile in self.opponent_profiles.values():
            profile['C-rate'] += 0.05

class Strategy_EXPLOITATIVE_304(BaseStrategy):
    """
    Exploitative strategy that adapts to the game's state and history.
    Balances short-term gain with long-term sustainability by cooperating when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.my_payoffs = []
        self.opponent_avg_payoff = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_payoff_sum = sum(history.opponent_payoffs[-1])
        avg_opponent_payoff = opponent_payoff_sum / self.game_description.n_players
        self.my_payoffs.append(avg_opponent_payoff)
        if 1 <= state.round_number < self.game_description.n_rounds // 2:
            if state.current_stock > 0.75 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C
        elif self.game_description.n_rounds // 2 <= state.round_number < self.game_description.n_rounds - 1:
            avg_payoff = sum(self.my_payoffs[-5:]) / min(5, len(self.my_payoffs))
            if len(self.opponent_avg_payoff) > 0 and avg_payoff >= self.opponent_avg_payoff[-1]:
                return Action.D
            else:
                self.opponent_avg_payoff.append(avg_payoff)
                return Action.C
        elif state.round_number >= self.game_description.n_rounds - 2:
            if state.current_stock < 0.25 * self.game_description.capacity or state.round_number == self.game_description.n_rounds - 1:
                return Action.D
            else:
                return Action.C
        elif state.current_stock < 0.1 * self.game_description.capacity:
            return Action.C

class Strategy_EXPLOITATIVE_306(BaseStrategy):
    """
    A robust and adaptive exploitative strategy designed for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_stock = game_description.capacity
        self.opponent_actions_history = []
        self.stock_depletion_rate_history = []

    def calculate_coop_threshold(self, stock_depletion_rate, opponent_defection_rate):
        if stock_depletion_rate > 0.5:
            coop_threshold = 0.2 + (1 - opponent_defection_rate) * 0.3
        else:
            coop_threshold = 0.5 - opponent_defection_rate * 0.2
        return coop_threshold

    def calculate_stock_depletion_rate(self, initial_stock, current_stock, round_number):
        if round_number == 0:
            return 0
        depletion = (initial_stock - current_stock) / round_number
        return depletion / self.game_description.capacity

    def estimate_opponent_defection_rate(self, opponent_actions_history):
        if not opponent_actions_history:
            return 0.5
        total_actions = len(opponent_actions_history) * (self.game_description.n_players - 1)
        defections = sum((1 for actions in opponent_actions_history for action in actions if not action))
        return defections / total_actions

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.opponent_actions_history.append(history.opponent_actions[-1])
        stock_depletion_rate = self.calculate_stock_depletion_rate(self.initial_stock, state.current_stock, state.round_number)
        opponent_defection_rate = self.estimate_opponent_defection_rate(self.opponent_actions_history)
        coop_threshold = self.calculate_coop_threshold(stock_depletion_rate, opponent_defection_rate)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.initial_stock * 0.2:
            return Action.C
        if random.random() < coop_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_307(BaseStrategy):
    """
    Exploitative strategy that adapts to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = game_description.capacity / (2 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        opponent_cooperation_rate = np.mean(history.opponent_actions[-1, :])
        if state.current_stock < self.cooperation_threshold:
            return Action.C
        if opponent_cooperation_rate > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_308(BaseStrategy):
    """
    The Adaptive Stock Hawk strategy balances short-term gains with long-term sustainability by adaptively responding to the current stock level and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 1:
            return Action.D
        threshold_high = 0.75 * self.game_description.capacity
        threshold_low = 0.25 * self.game_description.capacity
        opponent_actions_prev = history.opponent_actions[-1, :]
        most_defected = np.sum(opponent_actions_prev == False) > self.game_description.n_players // 2
        if state.current_stock > threshold_high:
            return Action.D
        elif state.current_stock < threshold_low:
            return Action.C
        elif most_defected:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_309(BaseStrategy):
    """
    The Adaptive Stock Raider (ASR) strategy is designed to exploit a wide range of opponent behaviors while adapting to changing game conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_type = [None] * game_description.n_players

    def calculate_average_opponent_payoff(self, history: PlayerHistory) -> float:
        opponent_payoffs = np.mean(history.opponent_payoffs[:-1], axis=0)
        return np.mean(opponent_payoffs)

    def identify_opponents(self, opponent_type: list[None | str], history: PlayerHistory) -> list[str]:
        for i in range(len(opponent_type)):
            if opponent_type[i] is None:
                if self.calculate_average_opponent_payoff(history) < 0.5 * (self.game_description.capacity / (2 * self.game_description.n_players)):
                    opponent_type[i] = 'cooperator'
                elif self.calculate_average_opponent_payoff(history) > 0.75 * (self.game_description.capacity / (2 * self.game_description.n_players)):
                    opponent_type[i] = 'defector'
        return opponent_type

    def increasing_or_stable_trend(self, average_opponent_payoff: float, history: PlayerHistory) -> bool:
        if len(history.my_payoffs) < 3:
            return True
        payoffs_diff = np.diff(history.my_payoffs)
        trend = np.mean(payoffs_diff[-2:])
        return trend >= 0

    def early_game(self, round_number: int) -> bool:
        return 1 < round_number <= self.game_description.n_rounds // 5

    def mid_game(self, round_number: int) -> bool:
        return self.game_description.n_rounds // 5 < round_number <= self.game_description.n_rounds * 2 // 3

    def late_game(self, round_number: int) -> bool:
        return round_number > self.game_description.n_rounds * 2 // 3

    def low_stock(self, state: CommonPoolState) -> bool:
        return state.current_stock < self.game_description.capacity / 4

    def few_rounds_left(self, round_number: int) -> bool:
        return self.game_description.n_rounds - round_number <= 3

    def last_round(self, round_number: int) -> bool:
        return round_number == self.game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        average_opponent_payoff = self.calculate_average_opponent_payoff(history)
        self.opponent_type = self.identify_opponents(self.opponent_type, history)
        if self.early_game(state.round_number):
            if average_opponent_payoff > 0.75 * (self.game_description.capacity / (2 * self.game_description.n_players)):
                return Action.D
            else:
                return Action.C
        elif self.mid_game(state.round_number):
            if self.increasing_or_stable_trend(average_opponent_payoff, history):
                return Action.D
            else:
                return Action.C
        elif self.late_game(state.round_number):
            if self.low_stock(state) or self.few_rounds_left(state.round_number):
                return Action.D
            else:
                return Action.C
        elif self.last_round(state.round_number):
            if state.current_stock > self.game_description.capacity / 2:
                return Action.D
            else:
                return Action.C
        if state.current_stock < self.game_description.capacity / 10:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_311(BaseStrategy):
    """
    An adaptive exploitative strategy for the Common Pool Resource Game.
    
    Balances short-term gains with long-term sustainability by:
    - Initially cooperating to gather information and promote cooperation.
    - Exploiting opponents' willingness to cooperate when the stock level is high, while avoiding over-exploitation.
    - Conserving resources and promoting sustainability when the stock level is low or all opponents cooperate.
    - Maximizing short-term gains in the endgame.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponents_actions_last_round = history.opponent_actions[-1]
        any_opponent_defected = np.any(~opponents_actions_last_round)
        all_opponents_cooperated = np.all(opponents_actions_last_round)
        if state.current_stock > 0.75 * self.game_description.capacity and any_opponent_defected:
            return Action.D
        elif state.current_stock < 0.5 * self.game_description.capacity or all_opponents_cooperated:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_312(BaseStrategy):
    """
    The Adaptive Stock Exploiter (ASE) strategy is designed to adaptively exploit the common pool resource while being robust to a wide range of opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        if state.round_number + 1 == self.game_description.n_rounds:
            return Action.D
        if stock_ratio > 0.75:
            return Action.D
        elif 0.5 <= stock_ratio <= 0.75:
            return Action.C
        else:
            return Action.D
        if state.round_number == 1 and state.current_stock / self.game_description.capacity < 0.5:
            return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        cooperators = sum(opponent_actions)
        defectors = len(opponent_actions) - cooperators
        if cooperators > defectors:
            return Action.C
        elif defectors > cooperators:
            return Action.D

class Strategy_EXPLOITATIVE_313(BaseStrategy):
    """
    Exploitative strategy that adapts to the dynamic state of the game.
    Balances short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if self.capacity >= 2 * self.n_players else Action.D
        opponent_actions = history.opponent_actions[-1, :]
        coop_ratio = np.mean(opponent_actions)
        if state.current_stock > self.capacity / 2:
            return Action.C if coop_ratio < 0.5 else Action.D
        elif state.current_stock <= self.capacity / 2:
            return Action.C if coop_ratio >= 3 / 4 else Action.D
        if state.round_number == self.game_description.n_rounds - 1 or state.current_stock < self.capacity / 4:
            most_cooperated = np.sum(opponent_actions) > self.n_players * 0.5
            return Action.C if most_cooperated else Action.D

class Strategy_EXPLOITATIVE_314(BaseStrategy):
    """
    Exploitative strategy that balances short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.last_round_opponent_actions = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        opponent_actions = history.opponent_actions if history else self.last_round_opponent_actions
        if current_stock > 0.75 * self.capacity:
            p_defect = min(0.5, (self.n_players - 1) / self.n_players)
            return Action.D if random.random() < p_defect else Action.C
        elif 0.25 * self.capacity <= current_stock < 0.75 * self.capacity:
            p_cooperate = max(0.2, (state.round_number - 1) / (self.game_description.n_rounds - 1))
            return Action.C if random.random() < p_cooperate else Action.D
        else:
            return Action.D
        if self.last_round_opponent_actions is not None:
            opponent_consistently_cooperates = np.all(opponent_actions[-1, :] == 1)
            if opponent_consistently_cooperates:
                p_defect = max(p_defect, 0.6)
            elif not opponent_consistently_cooperates and np.any(opponent_actions[-1, :] == 0):
                p_cooperate = min(p_cooperate, 0.4)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if current_stock < 0.1 * self.capacity:
            return Action.C
        self.last_round_opponent_actions = opponent_actions

class Strategy_EXPLOITATIVE_315(BaseStrategy):
    """
    An exploitative strategy that adapts to the current stock level and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        cooperators = sum(opponent_actions)
        defectors = self.n_players - 1 - cooperators
        mixed = np.sum(np.logical_xor(history.opponent_actions[-2], opponent_actions)) if state.round_number > 1 else 0
        theta = self.capacity / (2 * self.n_players)
        if state.current_stock > theta and defectors > cooperators:
            return Action.D
        elif state.current_stock <= theta or cooperators >= defectors:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_316(BaseStrategy):
    """
    Exploitative strategy that adapts to the dynamic state and history of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def calculate_average_consumption(self, history: PlayerHistory) -> float:
        opponent_actions = history.opponent_actions[:-1] if len(history.my_actions) > 0 else np.array([])
        avg_defectors = np.mean(opponent_actions == Action.D)
        return (self.n_players - 1) * (avg_defectors + self.game_description.capacity / (2 * self.n_players))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or len(history.my_actions) == 0:
            return Action.C if state.current_stock >= self.capacity / 2 else Action.D
        avg_consumption = self.calculate_average_consumption(history)
        exploitation_threshold = state.current_stock / self.capacity * (avg_consumption / self.n_players)
        if exploitation_threshold <= 0.5 or state.current_stock < self.capacity / 4:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.D
        if state.current_stock < self.capacity / 10:
            return Action.C
        elif avg_consumption > self.n_players * (self.capacity / 2):
            return Action.D

class Strategy_EXPLOITATIVE_317(BaseStrategy):
    """
    Adaptive Exploiter strategy for the Common Pool Resource Game.
    
    This strategy starts by cooperating in the initial round, then adapts to the opponents' behavior and current stock level throughout the game.
    It uses a probabilistic approach to decide between cooperation and defection based on the number of consistent cooperators and defectors among the opponents.
    In late rounds or when the stock is low, it prioritizes short-term gains over sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.rounds_played = 0
        self.stock = game_description.capacity
        self.avg_payoff_threshold = 0.75 * (game_description.capacity / (2 * game_description.n_players))
        self.low_stock_threshold = 0.1 * game_description.capacity
        self.critical_stock_threshold = 0.25 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.rounds_played = state.round_number
        self.stock = state.current_stock
        if self.rounds_played < 5:
            avg_payoff = np.mean(history.my_payoffs[:self.rounds_played])
            return Action.C if avg_payoff > self.avg_payoff_threshold else Action.D
        opponent_actions = history.opponent_actions[:self.rounds_played, :]
        consistent_cooperators = sum(np.all(opponent_actions == True, axis=0))
        consistent_defectors = sum(np.all(opponent_actions == False, axis=0))
        if self.rounds_played <= 20:
            if consistent_cooperators > consistent_defectors + 2:
                return Action.C
            elif consistent_defectors >= consistent_cooperators - 2:
                return Action.D
            else:
                p = (consistent_cooperators + 1) / (self.game_description.n_players + 2)
                return Action.C if random.random() < p else Action.D
        if self.stock < self.critical_stock_threshold:
            return Action.D
        elif self.stock < self.low_stock_threshold:
            return Action.C
        p = (consistent_cooperators + 1) / (self.game_description.n_players + 2)
        return Action.C if random.random() < p else Action.D
        if self.rounds_played == self.game_description.n_rounds - 1:
            return Action.D
        elif np.all(opponent_actions == True, axis=0).any():
            return Action.D
        elif np.all(opponent_actions == False, axis=0).any():
            return Action.C

class Strategy_EXPLOITATIVE_318(BaseStrategy):
    """
    Exploitative Strategy: "Adaptive Stock Raider"

    This strategy aims to maximize individual payoffs by adaptively responding 
    to the current state of the common pool and the observed behavior of opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_actions = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.opponent_actions = history.opponent_actions
        avg_coop_rate = np.mean(self.opponent_actions, axis=1)
        S = state.current_stock / self.game_description.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif S > 0.7:
            return Action.D
        elif S < 0.3 or math.isclose(S, 0):
            return Action.C
        else:
            prob_coop = 1 - S if avg_coop_rate[-1] > 0.5 else S
            return Action.C if random.random() < prob_coop else Action.D

class Strategy_EXPLOITATIVE_319(BaseStrategy):
    """
    A dynamic strategy designed to maximize payoffs in the Common Pool Resource Game by adapting to changing game conditions and exploiting opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.my_history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        if self.my_history is None:
            self.my_history = {'actions': np.array([], dtype=bool), 'payoffs': np.array([], dtype=float)}
        stock_ratio = state.current_stock / self.game_description.capacity
        if state.round_number <= 3:
            return random.choice([Action.C, Action.D])
        cooperation_prob = 1 - stock_ratio ** 2 if stock_ratio > 0.5 else 1 - (self.game_description.capacity / (2 * state.current_stock)) ** 2
        opponent_actions = history.opponent_actions[-3:, :] if len(history.opponent_actions) >= 3 else history.opponent_actions
        most_cooperative_opponent = np.argmax(np.mean(opponent_actions, axis=0))
        defect_prob = 0.8 if np.mean(opponent_actions[:, most_cooperative_opponent]) > 0.5 else cooperation_prob
        action = Action.C if random.random() < cooperation_prob * (1 - defect_prob) else Action.D
        self.my_history['actions'] = np.append(self.my_history['actions'], int(action == Action.D))
        self.my_history['payoffs'] = np.append(self.my_history['payoffs'], state.current_stock / (2 * self.game_description.n_players) if action == Action.C else state.current_stock / self.game_description.n_players)
        recent_payoff_avg = np.mean(self.my_history['payoffs'][-3:])
        if recent_payoff_avg < self.game_description.capacity / (4 * self.game_description.n_players):
            cooperation_prob *= 0.9
        elif recent_payoff_avg > self.game_description.capacity / (2 * self.game_description.n_players):
            cooperation_prob *= 1.1
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return action

class Strategy_EXPLOITATIVE_320(BaseStrategy):
    """
    Exploitative strategy that adapts to various opponent behaviors in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_stock = game_description.capacity
        self.opponent_consumptions = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number < self.game_description.n_rounds // 2:
            avg_consumption = self._calculate_average_consumption(history)
            if avg_consumption > 0.75 * self.game_description.capacity / self.game_description.n_players:
                return Action.D
            else:
                return Action.C
        cooperative_players = self._identify_cooperative_players(history)
        if len(cooperative_players) >= 2:
            return Action.D
        else:
            return Action.C
        current_stock = state.current_stock
        remaining_rounds = self.game_description.n_rounds - state.round_number
        if current_stock < 0.25 * self.game_description.capacity or remaining_rounds <= 2:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if all_opponents_cooperate(history):
            return Action.C
        if current_stock <= 0:
            return Action.D

    def _calculate_average_consumption(self, history: PlayerHistory) -> float:
        opponent_actions = history.opponent_actions[-1, :]
        cooperators = sum(opponent_actions)
        total_consumption = (self.game_description.n_players - cooperators) * self.current_stock / self.game_description.n_players + cooperators * self.current_stock / (2 * self.game_description.n_players)
        avg_consumption = total_consumption / self.game_description.n_players
        return avg_consumption

    def _identify_cooperative_players(self, history: PlayerHistory) -> list:
        cooperative_players = []
        opponent_actions = history.opponent_actions[-1, :]
        for i in range(len(opponent_actions)):
            if opponent_actions[i]:
                cooperative_players.append(i)
        return cooperative_players

    def all_opponents_cooperate(self, history: PlayerHistory) -> bool:
        opponent_actions = history.opponent_actions[-1, :]
        return all(opponent_actions)

class Strategy_EXPLOITATIVE_321(BaseStrategy):
    """
    Exploitative Strategy: "Adaptive Stock Raider"

    This strategy balances short-term gains with long-term sustainability by adapting to opponents' behaviors and the current stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.opponent_actions = []
        self.my_payoffs = []
        self.cooperation_likelihood = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if 1 <= state.round_number < self.game_description.n_rounds - 1:
            current_stock = state.current_stock
            capacity = self.game_description.capacity
            if current_stock > 0.75 * capacity:
                return Action.D
            elif 0.25 * capacity <= current_stock <= 0.75 * capacity:
                average_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
                my_payoff = history.my_payoffs[-1]
                if average_opponent_payoff < my_payoff:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        self.stock_history.append(state.current_stock)
        if history is not None:
            self.opponent_actions.append(history.opponent_actions[-1, :])
            self.my_payoffs.append(history.my_payoffs[-1])
        average_stock_level = np.mean(self.stock_history[-5:]) if len(self.stock_history) >= 5 else state.current_stock
        previous_average_stock_level = np.mean(self.stock_history[-10:-5]) if len(self.stock_history) >= 10 else average_stock_level
        if average_stock_level < previous_average_stock_level:
            self.cooperation_likelihood += 0.1
        return Action.D

class Strategy_EXPLOITATIVE_322(BaseStrategy):
    """
    A dynamic approach that balances self-interest with adaptability to opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_payoffs = np.sum(history.my_payoffs)
        opponent_actions = history.opponent_actions[-1]
        opponent_defection_rate = np.mean(opponent_actions == False)
        current_stock_depletion_rate = (self.capacity - state.current_stock) / self.capacity
        if current_stock_depletion_rate >= 0.5:
            return Action.C
        opponent_payoffs = history.opponent_payoffs[-1]
        average_opponent_payoff = np.mean(opponent_payoffs)
        if total_payoffs > average_opponent_payoff:
            return Action.D
        if state.current_stock <= 2 * self.n_players:
            return Action.C
        if opponent_defection_rate >= 0.75:
            return Action.D
        cooperative_opponents = np.sum([np.mean(actions == True) > 0.75 for actions in history.opponent_actions.T])
        if cooperative_opponents > self.n_players // 2:
            return Action.C
        if state.round_number + 1 >= self.game_description.n_rounds:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_323(BaseStrategy):
    """
    A robust and exploitative strategy for the Common Pool Resource Game.
    It dynamically adjusts cooperation levels based on game state, history, and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / 2
        self.cooperate_after_opponents_coop = math.ceil(game_description.n_rounds / 5)
        self.late_game_defect_start = max(3, game_description.n_rounds - min(game_description.n_rounds // 4, 3))
        self.round_number = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.round_number = state.round_number + 1
        if state.current_stock > self.threshold:
            return Action.C
        avg_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
        if avg_opponent_payoff > history.my_payoffs[-1]:
            return Action.D
        opponent_coop_recently = np.any(np.all(history.opponent_actions[-self.cooperate_after_opponents_coop:, :], axis=0))
        if opponent_coop_recently:
            return Action.C
        if self.round_number >= self.late_game_defect_start:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_324(BaseStrategy):
    """
    An adaptive strategy that balances cooperation with exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_scores = np.zeros(game_description.n_players - 1)
        self.thresholds = {'cooperate': 0.7, 'defect': 0.4}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = np.array(history.opponent_actions[-1, :])
        self.opponent_scores[opponent_actions == 1] += 1
        self.opponent_scores[opponent_actions == 0] -= 1
        stock_fraction = state.current_stock / self.game_description.capacity
        if stock_fraction >= self.thresholds['cooperate']:
            return Action.C
        elif stock_fraction < self.thresholds['defect']:
            return Action.D
        else:
            average_opponent_score = np.mean(self.opponent_scores)
            if average_opponent_score > 0:
                return Action.C
            else:
                return Action.D
        for i in range(len(self.opponent_scores)):
            if self.opponent_scores[i] < -2 or (opponent_actions[i] == 0 and history.my_payoffs[-1, i] > 0):
                return Action.D
        cooperators = sum(opponent_actions)
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock_fraction < 0.2:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_325(BaseStrategy):
    """
    Exploitative strategy that adapts to the game state and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if state.current_stock >= self.capacity / 2:
                return Action.C
            else:
                return Action.D
        opponents_cooperated = sum(history.opponent_actions[-1, :]) / self.n_players >= 0.5
        stock_depleted = state.current_stock <= self.capacity / 4
        if state.current_stock >= self.capacity / 2 and (not stock_depleted):
            if opponents_cooperated or state.round_number < self.game_description.n_rounds - 1:
                return Action.C
            else:
                return Action.D
        elif state.current_stock >= self.capacity / 2 and stock_depleted:
            if opponents_cooperated:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_326(BaseStrategy):
    """
    The Adaptive Exploiter strategy balances cooperation and defection based on the game state,
    adapting to opponents' behavior while prioritizing individual payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperation_rate = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            prev_round_actions = history.opponent_actions[-1, :]
            coop_count = np.sum(prev_round_actions)
            self.opponent_cooperation_rate = (self.opponent_cooperation_rate * state.round_number + coop_count / self.game_description.n_players) / (state.round_number + 1)
        cooperation_probability = state.round_number / self.game_description.n_rounds * (1 + (self.opponent_cooperation_rate - 0.5) / 2)
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.D
        elif 0.5 * self.game_description.capacity <= state.current_stock <= 0.75 * self.game_description.capacity:
            return Action.C if random.random() < cooperation_probability else Action.D
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_327(BaseStrategy):
    """
    Adaptive Stock Exploiter (ASE) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round = history
        avg_payoff_C = np.mean([payoff for action, payoff in zip(prev_round.opponent_actions[-1], prev_round.opponent_payoffs[-1]) if action])
        avg_payoff_D = np.mean([payoff for action, payoff in zip(prev_round.opponent_actions[-1], prev_round.opponent_payoffs[-1]) if not action])
        if state.current_stock < 0.75 * self.game_description.capacity or avg_payoff_D > avg_payoff_C or sum((1 for action in prev_round.opponent_actions[-1] if not action)) > self.game_description.n_players / 2:
            return Action.D
        if state.current_stock > 0.25 * self.game_description.capacity and np.sum([consumption for _, consumption in zip(prev_round.opponent_actions[-1], prev_round.opponent_payoffs[-1])]) < 0.5 * self.game_description.capacity:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_328(BaseStrategy):
    """
    This strategy adapts to the current stock level and opponent behavior.
    It aims to maximize its own payoff while minimizing the risk of stock depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_action = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_percentage = state.current_stock / self.game_description.capacity
        if stock_percentage > 0.75:
            return Action.D
        elif stock_percentage < 0.25:
            return Action.C
        opponent_actions_last_round = history.opponent_actions[-1]
        C_count = sum(opponent_actions_last_round)
        D_count = self.game_description.n_players - 1 - C_count
        if C_count > D_count:
            return Action.C
        else:
            return Action.D
        if state.round_number + 1 == self.game_description.n_rounds:
            return Action.D
        self.last_action = Action.C

class Strategy_EXPLOITATIVE_329(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game.
    Dynamically adjusts its behavior based on the current stock level and opponent cooperation rate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.theta = game_description.capacity / (2 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        S_t = state.current_stock
        opponent_cooperation_rate = self.calculate_opponent_cooperation_rate(history)
        if opponent_cooperation_rate > 0.5:
            self.theta *= 1.05
        else:
            self.theta /= 1.05
        if S_t > self.theta:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif S_t < 0.1 * self.game_description.capacity:
            return Action.C
        else:
            return Action.D

    def calculate_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        cooperation_count = sum((1 for action in history.opponent_actions[-1, :] if action))
        return cooperation_count / len(history.opponent_actions[-1, :])

class Strategy_EXPLOITATIVE_330(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_defections = sum((1 - action for action in history.opponent_actions[-1, :]))
        if state.round_number == self.game_description.n_rounds:
            return Action.D
        if len(history.opponent_actions) == 1:
            return Action(opponent_defections == 0)
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.C
        if state.round_number <= 5:
            if state.current_stock > 0.75 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C
        elif state.round_number <= self.game_description.n_rounds // 2:
            if opponent_defections > self.game_description.n_players / 2:
                return Action.D
            else:
                return Action.C
        elif state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_331(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize its payoff by adaptively exploiting the current state of the game and the behavior of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def calculate_avg_opponent_consumption(self, history: PlayerHistory) -> float:
        total_consumption = sum([int(not action) * self.game_description.capacity / self.game_description.n_players + int(action) * self.game_description.capacity / (2 * self.game_description.n_players) for action in history.opponent_actions[-1]])
        return total_consumption / self.game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_opponent_consumption = self.calculate_avg_opponent_consumption(history)
        cooperative_threshold = state.current_stock / (2 * self.game_description.n_players)
        if avg_opponent_consumption > cooperative_threshold:
            return Action.D
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.D
        if state.current_stock >= 0.5 * self.game_description.capacity and avg_opponent_consumption <= cooperative_threshold:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1 or state.current_stock < 0.1 * self.game_description.capacity:
            return Action.C

class Strategy_EXPLOITATIVE_332(BaseStrategy):
    """
    Adaptive Depletion strategy.

    This strategy is adaptive and exploitative. It dynamically adjusts its cooperation level based on the current stock level, 
    opponents' past actions, and the remaining rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            safety_threshold = 0.75 * self.capacity
            if state.current_stock < safety_threshold:
                return Action.D
            else:
                return Action.C
        total_consumption = sum([self.calculate_stock_after_consumption(h) for h in history.my_payoffs])
        dr = total_consumption / len(history.my_payoffs)
        ocl = self.estimate_ocl(history.opponent_actions)
        critical_threshold = 0.25 * self.capacity
        warning_threshold = 0.5 * self.capacity
        if state.current_stock <= critical_threshold or dr > 0.75:
            return Action.D
        elif state.current_stock >= warning_threshold and ocl == Action.C:
            return Action.C
        elif history.opponent_actions[-1].sum() >= self.game_description.n_players / 2:
            return Action.C
        else:
            return Action.D

    def calculate_stock_after_consumption(self, payoff: float):
        n = self.game_description.n_players
        return payoff * n / 2 if payoff > 0 else 0

    def estimate_ocl(self, opponent_actions: NDArray[np.bool_]) -> Action:
        last_round_cooperators = opponent_actions[-1].sum()
        return Action.C if last_round_cooperators >= self.game_description.n_players / 2 else Action.D

class Strategy_EXPLOITATIVE_333(BaseStrategy):
    """
    A strategy that adapts to various opponent behaviors and maximizes its payoff in a Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio > 0.75:
            return Action.D
        elif stock_ratio >= 0.5 and stock_ratio <= 0.75:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if self.is_stock_decreasing(history):
            return Action.D
        opponent_actions = self.get_opponent_actions(history)
        if self.most_opponents_cooperate(opponent_actions):
            return Action.D
        elif self.most_opponents_defect(opponent_actions):
            return Action.C

    def is_stock_decreasing(self, history: PlayerHistory) -> bool:
        if len(history.my_payoffs) < 3:
            return False
        current_stock = self.game_description.capacity - sum(history.opponent_payoffs[-1, :]) - history.my_payoffs[-1]
        previous_stock = self.game_description.capacity - sum(history.opponent_payoffs[-2, :]) - history.my_payoffs[-2]
        if len(history.my_payoffs) > 3:
            previous_previous_stock = self.game_description.capacity - sum(history.opponent_payoffs[-3, :]) - history.my_payoffs[-3]
            return current_stock < previous_stock and previous_stock < previous_previous_stock
        return current_stock < previous_stock

    def get_opponent_actions(self, history: PlayerHistory) -> NDArray[np.bool_]:
        return np.delete(history.opponent_actions[-1], 0)

    def most_opponents_cooperate(self, opponent_actions: NDArray[np.bool_]) -> bool:
        return sum(opponent_actions) >= len(opponent_actions) / 2

    def most_opponents_defect(self, opponent_actions: NDArray[np.bool_]) -> bool:
        return sum(1 - opponent_actions) >= len(opponent_actions) / 2

class Strategy_EXPLOITATIVE_334(BaseStrategy):
    """
    Exploitative strategy that adapts to changes in the game state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        S_current = state.current_stock
        n = self.n_players
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if S_current >= 0.75 * self.capacity:
            return Action.D
        elif S_current < 0.25 * self.capacity:
            return Action.C
        else:
            previous_opponent_actions = history.opponent_actions[-1, :]
            opponent_cooperators = sum(previous_opponent_actions)
            average_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
            if average_opponent_payoff >= 0.5 * S_current / (2 * n):
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_335(BaseStrategy):
    """
    The Adaptive Stock-Based Exploiter (ASBE) strategy balances short-term exploitation with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        threshold = 0.7 * self.game_description.capacity
        if state.current_stock >= threshold:
            action = Action.D
        else:
            action = Action.C
        opponent_actions = np.sum(history.opponent_actions[-1, :])
        n_players = self.game_description.n_players
        if opponent_actions >= n_players - 1 or opponent_actions == n_players - 2:
            if state.current_stock >= threshold:
                action = Action.D
        elif opponent_actions < n_players - 2:
            action = Action.C
        if state.round_number + 1 == self.game_description.n_rounds:
            return Action.D
        if state.current_stock < 0.3 * self.game_description.capacity and state.round_number < 5:
            return Action.C
        if state.current_stock < 0.2 * self.game_description.capacity and state.round_number > 9:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_336(BaseStrategy):
    """
    An exploitative strategy that adapts to the game's state and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.round_number = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 1:
            return Action.C
        stock_fraction = state.current_stock / self.capacity
        if stock_fraction > 0.75:
            return Action.D
        elif 0.25 <= stock_fraction <= 0.75:
            p = stock_fraction ** 2
            if random.random() < p:
                return Action.C
            else:
                return Action.D
        elif state.round_number == self.game_description.n_rounds:
            return Action.D
        else:
            return Action.C
        opponent_actions = history.opponent_actions if history is not None else np.array([])
        opponent_cooperations = np.sum(opponent_actions)
        if opponent_cooperations >= self.game_description.n_players // 2:
            return Action.D
        stock_trend = state.current_stock - (history.my_payoffs[-1] if history is not None and len(history.my_payoffs) > 0 else 0)
        if stock_trend < 0:
            return Action.C

class Strategy_EXPLOITATIVE_337(BaseStrategy):
    """
    The "Adaptive Stock Raider" strategy is designed to maximize individual payoff by 
    adaptively responding to the game state and opponents' actions, while maintaining a 
    robust and exploitative mindset.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        if history is not None:
            opponent_cooperation_rate = np.mean(history.opponent_actions[-1, :])
        else:
            opponent_cooperation_rate = 0.5
        if history is not None and len(history.my_payoffs) > 1:
            avg_payoff_per_player = np.mean(history.my_payoffs[-2:])
        else:
            avg_payoff_per_player = state.current_stock / (2 * self.game_description.n_players)
        if stock_ratio > 0.75 or state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif stock_ratio >= 0.5 and avg_payoff_per_player < state.current_stock / (2 * self.game_description.n_players):
            return Action.C
        else:
            defect_probability = max(0.7, min(opponent_cooperation_rate, 0.9))
            return Action.D if random.random() < defect_probability else Action.C

class Strategy_EXPLOITATIVE_338(BaseStrategy):
    """
    The Adaptive Stock Exploiter (ASE) strategy is designed to balance cooperation and exploitation in the Common Pool Resource Game.
    By monitoring the stock level and adapting to opponents' behaviors, ASE aims to maximize individual payoffs while maintaining a stable game state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock > 0.75 * self.game_description.capacity else Action.D
        avg_prev_payoff = np.mean(history.my_payoffs)
        over_exploiter = False
        for opponent_action in history.opponent_actions[-1, :]:
            if not opponent_action and state.current_stock < 0.5 * self.game_description.capacity:
                over_exploiter = True
                break
        if over_exploiter:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1 and state.current_stock < 0.25 * self.game_description.capacity or state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        return Action.C if avg_prev_payoff > 0.5 * (self.game_description.capacity / self.game_description.n_players) else Action.D

class Strategy_EXPLOITATIVE_339(BaseStrategy):
    """
    A hybrid strategy that balances short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def get_stock_level(self, current_stock: float) -> float:
        return current_stock / self.game_description.capacity

    def get_ae_payoff(self, history: PlayerHistory) -> float:
        ae_payoffs = np.where(history.my_actions == True, self.game_description.capacity / (2 * self.game_description.n_players), self.game_description.capacity / self.game_description.n_players)
        return np.sum(ae_payoffs)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_level = self.get_stock_level(state.current_stock)
        if stock_level > 0.75:
            if np.any(history.opponent_actions[-1, :] == False):
                return Action.D
            else:
                return Action.C
        elif stock_level >= 0.25 and stock_level <= 0.75:
            coop_count = np.sum(history.opponent_actions[-1, :] == True)
            if coop_count > self.game_description.n_players / 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D
        if state.round_number >= self.game_description.n_rounds - 1:
            ae_payoff = self.get_ae_payoff(history)
            avg_opponent_payoff = np.mean(np.sum(history.opponent_payoffs, axis=0))
            if ae_payoff < avg_opponent_payoff:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_340(BaseStrategy):
    """
    Exploitative strategy that adapts to the stock's growth dynamics and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.5 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        coop_payoff = state.current_stock / (2 * self.game_description.n_players)
        defect_payoff = state.current_stock / self.game_description.n_players
        num_cooperators_prev = sum(history.opponent_actions[-1, :])
        if state.current_stock > self.stock_threshold:
            if coop_payoff > defect_payoff or num_cooperators_prev >= self.game_description.n_players / 2:
                return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

    def update_stock_threshold(self, current_stock, previous_stock):
        if current_stock > previous_stock:
            self.stock_threshold -= 0.1 * self.game_description.capacity
        elif current_stock <= previous_stock:
            self.stock_threshold += 0.1 * self.game_description.capacity

class Strategy_EXPLOITATIVE_341(BaseStrategy):
    """
    The Adaptive Stock Exploiter (ASE) strategy aims to maximize its own payoff by 
    adaptively responding to the current stock level and the actions of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.num_players = game_description.n_players
        self.opponent_strategy_changes = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        growth_rate = self.calculate_growth_rate(state.current_stock)
        if growth_rate < 0.2 * self.capacity:
            return Action.D
        self.opponent_strategy_changes = self.get_opponent_strategy_changes(history)
        for change in self.opponent_strategy_changes:
            if change == 'cooperate_to_defect':
                return Action.D
            elif change == 'defect_to_cooperate':
                return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        most_opponents_defected = np.sum(opponent_actions == False) >= self.num_players // 2
        if state.current_stock < 0.5 * self.capacity:
            return Action.D
        elif state.current_stock > 0.75 * self.capacity:
            return Action.C
        elif most_opponents_defected:
            return Action.D
        else:
            return Action.C

    def calculate_growth_rate(self, stock):
        growth = 2 * stock * (1 - stock / self.capacity)
        return growth

    def get_opponent_strategy_changes(self, history):
        changes = []
        for i in range(len(history.opponent_actions) - 1):
            previous_round_actions = history.opponent_actions[i]
            current_round_actions = history.opponent_actions[i + 1]
            for j in range(len(previous_round_actions)):
                if previous_round_actions[j] == True and current_round_actions[j] == False:
                    changes.append('cooperate_to_defect')
                elif previous_round_actions[j] == False and current_round_actions[j] == True:
                    changes.append('defect_to_cooperate')
        return changes

class Strategy_EXPLOITATIVE_342(BaseStrategy):
    """
    The Adaptive Stock Raider (ASR) strategy is designed to exploit a wide range of opponent behaviors 
    while adapting to the dynamic state and history of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def calculate_average_cooperation_rate(self, history: PlayerHistory) -> float:
        opponent_actions = history.opponent_actions[:-1, :]
        total_rounds = opponent_actions.shape[0]
        total_players = opponent_actions.shape[1]
        total_cooperations = np.sum(opponent_actions)
        return total_cooperations / (total_rounds * total_players)

    def calculate_expected_payoff(self, action: Action, stock_level: float, history: PlayerHistory) -> float:
        if action == Action.C:
            consumption = stock_level / (2 * self.game_description.n_players)
        else:
            consumption = stock_level / self.game_description.n_players
        expected_stock_after_consumption = stock_level - consumption
        growth = 2 * expected_stock_after_consumption * (1 - expected_stock_after_consumption / self.game_description.capacity)
        new_stock = min(expected_stock_after_consumption + growth, self.game_description.capacity)
        if action == Action.C:
            return new_stock / (2 * self.game_description.n_players)
        else:
            return new_stock / self.game_description.n_players

    def detect_opponent_pattern(self, history: PlayerHistory) -> bool:
        return False

    def adapt_to_pattern(self, history: PlayerHistory) -> Action:
        return Action.D

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number < 5:
            if state.current_stock >= 0.75 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        avg_cooperation_rate = self.calculate_average_cooperation_rate(history)
        if avg_cooperation_rate > 0.5:
            return Action.C
        else:
            return Action.D
        expected_payoff_C = self.calculate_expected_payoff(Action.C, state.current_stock, history)
        expected_payoff_D = self.calculate_expected_payoff(Action.D, state.current_stock, history)
        if expected_payoff_C > expected_payoff_D:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        elif self.detect_opponent_pattern(history):
            return self.adapt_to_pattern(history)

class Strategy_EXPLOITATIVE_343(BaseStrategy):
    """
    The Adaptive Stock Raider strategy aims to maximize its total payoff by adapting to the changing stock level and exploiting the opponent's behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if state.round_number == 0 or history is None:
            return Action.C if state.current_stock >= capacity / 2 else Action.D
        previous_opponent_actions = history.opponent_actions[-1, :]
        opponent_cooperated = all((action for action in previous_opponent_actions))
        previous_stock = max(state.current_stock + (state.round_number - 1) * n_players / state.round_number, 0)
        total_consumption_prev = sum((1 - action for action in history.my_actions[-1:])) * (previous_stock / n_players)
        if opponent_cooperated and state.current_stock > capacity / 2:
            return Action.C if total_consumption_prev <= 0.5 * previous_stock else Action.D
        elif not opponent_cooperated or state.current_stock < capacity / 2:
            return Action.D if total_consumption_prev > 0.5 * previous_stock else Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < capacity / 4:
            return Action.D
        elif state.current_stock > 3 / 4 * capacity:
            return Action.C

class Strategy_EXPLOITATIVE_344(BaseStrategy):
    """
    The Adaptive Exploiter strategy is designed to exploit the common pool resource game by adaptively adjusting its behavior based on the current state and history of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.75
        self.defection_probability = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        opponent_actions = history.opponent_actions[-1, :]
        opponents_defected = sum((1 for action in opponent_actions if action == False))
        opponent_cooperation_rate = (self.game_description.n_players - opponents_defected) / self.game_description.n_players
        stock_level_percentage = state.current_stock / self.game_description.capacity * 100
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif stock_level_percentage > self.cooperation_threshold * 100:
            return Action.C
        elif 50 <= stock_level_percentage < self.cooperation_threshold * 100:
            defect_probability = opponents_defected / self.game_description.n_players * 0.2 + self.defection_probability
            if random.random() < defect_probability:
                return Action.D
            else:
                return Action.C
        elif stock_level_percentage < 50:
            if opponent_cooperation_rate < 0.3:
                self.cooperation_threshold -= 0.1
            elif opponent_cooperation_rate < 0.5:
                self.defection_probability += 0.2
            if state.current_stock / self.game_description.capacity < 0.25:
                return Action.C
            else:
                return Action.D
        else:
            return random.choice([Action.C, Action.D])

class Strategy_EXPLOITATIVE_345(BaseStrategy):
    """
    Adaptive Stock Exploiter: an exploitative strategy for the Common Pool Resource game.
    
    This strategy adapts to opponents' behavior, exploits their defects when possible, 
    and adjusts its approach based on the stock dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.et = 0.5
        self.st = game_description.capacity * (1 - self.et / 2)
        self.opponent_profiles = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        for i in range(self.game_description.n_players - 1):
            opponent_profile = np.mean(1 - history.opponent_actions[:state.round_number, i])
            self.et += opponent_profile / (self.game_description.n_players - 1)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if self.et <= 0.5 or (self.et > 0.5 and state.current_stock < self.st):
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_346(BaseStrategy):
    """
    An adaptive strategy that exploits opponents' behaviors while balancing short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def calculate_average_consumption(self, history: PlayerHistory, round_number: int) -> float:
        recent_rounds = max(1, round_number // 3)
        total_consumption = sum(np.sum(history.opponent_actions[-recent_rounds:, :], axis=0))
        return total_consumption / (self.n_players * recent_rounds)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < self.capacity / 8:
            return Action.C
        if history.my_payoffs.shape[0] < self.game_description.n_rounds // 3:
            most_cooperated = sum(history.opponent_actions[-1, :]) > self.n_players / 2
            return Action.C if most_cooperated else Action.D
        avg_consumption_rate = self.calculate_average_consumption(history, state.round_number)
        if avg_consumption_rate > self.capacity / 4:
            return Action.C
        elif state.current_stock < self.capacity / 4 or state.round_number > self.game_description.n_rounds - 2:
            return Action.C
        else:
            return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        for i in range(self.n_players):
            if np.all(opponent_actions[i] == 0):
                return Action.C
            elif np.all(opponent_actions[i] == 1):
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_347(BaseStrategy):
    """
    Adaptive Exploiter strategy for the Common Pool Resource Game.
    
    This strategy aims to balance short-term gains with long-term sustainability,
    while also adapting to the behavior of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_level = state.current_stock / self.capacity
        opponent_history = history.opponent_actions[:-1] if history else []
        if stock_level >= 0.75:
            return Action.D
        elif 0.5 <= stock_level < 0.75:
            return random.choice([Action.C, Action.D])
        else:
            return Action.C
        for player in range(self.game_description.n_players):
            defect_rate = np.mean(1 - opponent_history[:, player])
            cooperate_rate = 1 - defect_rate
            if defect_rate > 0.75:
                return Action.D
            elif cooperate_rate > 0.75:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock_level < 0.1:
            return Action.C

class Strategy_EXPLOITATIVE_348(BaseStrategy):
    """
    An adaptive strategy that balances cooperation and defection in a common pool resource game.
    It takes into account the current stock level, opponent behavior, and the number of rounds remaining.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.p_c = 0.5
        self.p_d = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        for i in range(self.game_description.n_players):
            if i != self.game_description.n_players - 1:
                opponent_cooperation_rate = sum((1 for j in range(state.round_number) if history.opponent_actions[j, i])) / state.round_number
                if opponent_cooperation_rate > 0.75:
                    self.p_c += 0.1
                elif opponent_cooperation_rate < 0.25:
                    self.p_d -= 0.1
        stock_level = state.current_stock
        if stock_level > 0.5 * self.game_description.capacity:
            self.p_c = 0.5 + stock_level / self.game_description.capacity / 4
            action = Action.C if random.random() < self.p_c else Action.D
        else:
            self.p_d = 0.5 - stock_level / self.game_description.capacity / 4
            action = Action.D if random.random() < self.p_d else Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return action

class Strategy_EXPLOITATIVE_349(BaseStrategy):
    """
    Exploitative strategy that adapts to the game's state and history,
    exploiting potential cooperation from opponents while maximizing individual payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_coops = [0] * game_description.n_players
        self.opponent_defects = [0] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        for prev_round in range(state.round_number):
            for i, action in enumerate(history.opponent_actions[prev_round]):
                if action:
                    self.opponent_coops[i] += 1
                else:
                    self.opponent_defects[i] += 1
        cooperative_opponents = [i for i in range(self.game_description.n_players) if self.opponent_coops[i] / state.round_number >= 0.75]
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio > 0.75:
            if any((self.opponent_defects[opponent] > 0 for opponent in range(self.game_description.n_players))):
                return Action.D
            else:
                return Action.C
        elif 0.25 <= stock_ratio <= 0.75:
            coop_count = sum(history.opponent_actions[-1, :])
            if coop_count >= self.game_description.n_players / 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_350(BaseStrategy):
    """
    The Adaptive Stock Raider (ASR) is a dynamic, exploitative strategy designed to maximize individual payoffs 
    while adapting to various opponent behaviors and game state dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def calculate_max_payoff(self):
        return self.capacity / (2 * self.n_players)

    def avg_last_round_payoff(self, history: PlayerHistory):
        total_payoffs = np.sum(history.opponent_payoffs[-1, :]) + history.my_payoffs[-1]
        return total_payoffs / self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            max_payoff = self.calculate_max_payoff()
            threshold = 0.75 * max_payoff
            return Action.C if state.current_stock > threshold else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        avg_last_round_payoff_value = self.avg_last_round_payoff(history)
        stock_threshold = 0.5 * self.capacity
        if state.current_stock < 0.1 * self.capacity:
            return Action.D
        if state.current_stock >= stock_threshold:
            max_payoff = self.calculate_max_payoff()
            threshold = 0.5 * max_payoff
            return Action.D if avg_last_round_payoff_value < threshold else Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_351(BaseStrategy):
    """
    The Adaptive Stock Raider (ASR) is a dynamic and responsive strategy 
    designed to maximize payoffs by adapting to the game's state and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponents_defected = sum((1 for action in history.opponent_actions[-1, :] if not action))
        num_opponents = len(history.opponent_actions[-1])
        current_stock = state.current_stock
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if current_stock > 0.75 * self.capacity:
            return Action.D
        elif current_stock >= 0.5 * self.capacity and opponents_defected / num_opponents >= 0.5:
            return Action.C
        elif current_stock < 0.5 * self.capacity or current_stock < 0.25 * self.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_352(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances cooperation and defection based on observed opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.theta = 0.6
        self.phi = 0.7
        self.max_payoff = game_description.capacity / (2 * game_description.n_players)
        self.payoffs = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action(random.choice([True, False]))
        opponent_actions = np.pad(history.opponent_actions, ((1, 0), (0, 0)), mode='constant', constant_values=0)
        avg_opponent_coop = np.mean(opponent_actions[:-1], axis=(0, 1))
        if avg_opponent_coop > self.theta:
            action = Action.C
        else:
            prob_defect = np.sum(np.array(self.payoffs) < self.max_payoff) / len(self.payoffs)
            action = Action(random.random() < prob_defect)
        opponent_coop_rates = np.mean(opponent_actions[:-1], axis=0)
        if any((coop_rate > self.phi and opponent_action for coop_rate, opponent_action in zip(opponent_coop_rates, opponent_actions[-2]))):
            action = Action(False)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        self.payoffs.append(self.max_payoff)
        return action

class Strategy_EXPLOITATIVE_353(BaseStrategy):
    """
    Exploitative strategy based on adaptive stock depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.5 * game_description.capacity
        self.opponent_acrs = {}
        self.k = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        for opponent in range(self.game_description.n_players - 1):
            if opponent not in self.opponent_acrs:
                self.opponent_acrs[opponent] = []
            acr = np.mean(history.opponent_actions[-self.k:, opponent])
            self.opponent_acrs[opponent].append(acr)
        for opponent, acrs in self.opponent_acrs.items():
            avg_acr = np.mean(acrs)
            if avg_acr > 0.7:
                return Action.D
            elif avg_acr < 0.3:
                return Action.C
        if state.round_number < self.game_description.n_rounds // 2:
            self.stock_threshold *= 1.1
        else:
            self.stock_threshold *= 0.9
        return Action.D if state.current_stock < self.stock_threshold else Action.C

class Strategy_EXPLOITATIVE_354(BaseStrategy):
    """
    A strategy that adapts to the game state and opponent behaviors, 
    balancing short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (state.round_number < self.game_description.n_players // 2 and history is not None):
            return Action.C
        elif history.opponent_actions is not None:
            opponents_cooperated = np.sum(history.opponent_actions[-1, :]) / self.game_description.n_players
            if state.round_number >= self.game_description.n_players // 2 and state.round_number < 3 * self.game_description.n_players // 4:
                if opponents_cooperated > 0.5:
                    return Action.D
                else:
                    return Action.C
            elif state.current_stock / self.game_description.capacity > 0.75 or state.round_number == self.game_description.n_rounds - 1:
                return Action.D
            elif state.current_stock / self.game_description.capacity < 0.25:
                return Action.C
        if state.current_stock / self.game_description.capacity < 0.1:
            return Action.C
        elif state.current_stock / self.game_description.capacity > 0.9:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_355(BaseStrategy):
    """
    Exploitative strategy that adapts to game state and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        stock_threshold = capacity / (2 * n)
        payoff_threshold = capacity / n * 0.75
        growth_threshold = 2 * capacity / 3
        if state.current_stock < stock_threshold:
            return Action.C
        opponent_defected_last_round = history.opponent_actions[-1, :].any()
        if opponent_defected_last_round:
            return Action.D
        avg_payoff_last_round = np.mean(history.my_payoffs[-1])
        if avg_payoff_last_round > payoff_threshold:
            return Action.D
        stock_growth_last_round = history.my_payoffs[-1] * (1 - state.current_stock / capacity)
        if stock_growth_last_round < growth_threshold:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_356(BaseStrategy):
    """
    An exploitative strategy that adapts to various opponent behaviors and maximizes payoff over the course of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        opponents_defected = any((not action for action in history.opponent_actions[-1, :]))
        if state.current_stock > capacity / 2:
            return Action.D if opponents_defected else Action.C
        elif capacity / 4 < state.current_stock <= capacity / 2:
            p = (state.current_stock / capacity) ** (1 / n_players)
            return Action.C if random.random() < p else Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_357(BaseStrategy):
    """
    An exploitative strategy that adapts to the game state and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_history = [state.current_stock] if history is None else np.concatenate(([100.0], history.my_payoffs * (2 / self.game_description.n_players)))
        action_history = [Action.C] if history is None else np.where(history.opponent_actions.sum(axis=1) >= self.game_description.n_players // 2, Action.D, Action.C)
        num_cooperators = sum((action == Action.C for action in action_history[-self.game_description.n_players:]))
        total_consumption = stock_history[-1] - stock_history[-2]
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.D if num_cooperators >= self.game_description.n_players // 2 else Action.C
        elif 0.25 * self.game_description.capacity <= state.current_stock <= 0.75 * self.game_description.capacity:
            return Action.C if total_consumption > 0.5 * self.game_description.capacity else Action.D
        elif state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_358(BaseStrategy):
    """
    A robust and adaptive strategy that exploits various opponent behaviors 
    while ensuring long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.p = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_cooperations = sum(history.opponent_actions[-1, :])
        if opponent_cooperations > self.game_description.n_players // 2:
            self.p += 0.1
        elif opponent_cooperations < self.game_description.n_players // 2:
            self.p -= 0.1
        self.p = max(0, min(self.p, 1))
        stock_trend = np.diff(history.my_payoffs[-3:]).mean() if len(history.my_payoffs) >= 3 else 0
        if stock_trend > 0:
            self.p += 0.05
        elif stock_trend < 0:
            self.p -= 0.05
        self.p = max(0, min(self.p, 1))
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.D
        elif state.current_stock >= 0.25 * self.game_description.capacity and state.current_stock < 0.75 * self.game_description.capacity:
            actions = [Action.C, Action.D]
            probabilities = [self.p, 1 - self.p]
            return random.choices(actions, weights=probabilities)[0]
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_359(BaseStrategy):
    """
    An adaptive strategy that exploits various opponent behaviors in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.opponent_cooperation_rate = None
        self.low_stock_condition_met = False
        self.opponent_defection_dominance_met = False
        self.defect_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C if state.current_stock >= self.capacity / 2 else Action.D
        opponent_actions = history.opponent_actions[-1, :]
        cooperation_count = sum(opponent_actions)
        self.opponent_cooperation_rate = cooperation_count / self.n_players
        if state.current_stock <= self.capacity / 4 and (not self.low_stock_condition_met):
            self.low_stock_condition_met = True
            self.defect_counter = 2
        elif self.low_stock_condition_met and self.defect_counter > 0:
            self.defect_counter -= 1
        opponent_defection_rate = (self.n_players - cooperation_count) / self.n_players
        if opponent_defection_rate >= 0.75 and (not self.opponent_defection_dominance_met):
            self.opponent_defection_dominance_met = True
            self.defect_counter = 2
        elif self.opponent_defection_dominance_met and self.defect_counter > 0:
            self.defect_counter -= 1
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if self.low_stock_condition_met or self.opponent_defection_dominance_met:
            return Action.D
        elif self.opponent_cooperation_rate >= 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_360(BaseStrategy):
    """
    Exploitative strategy that adapts to the current stock level and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if state.current_stock > 0.9 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        cooperating_opponents = sum(history.opponent_actions[-1, :])
        if cooperating_opponents >= len(history.opponent_actions[-1, :]) / 2 and state.current_stock > 0.5 * self.game_description.capacity:
            return Action.C
        elif state.current_stock > 0.3 * self.game_description.capacity:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_361(BaseStrategy):
    """
    A strategic approach that balances exploitation with adaptability, 
    considering the dynamic state and history of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.low_stock_threshold = 0.1 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        my_payoff = history.my_payoffs[-1]
        opponent_payoffs = history.opponent_payoffs[-1, :]
        avg_opponent_payoff = np.mean(opponent_payoffs)
        exploit_threshold = state.current_stock / self.game_description.capacity * (self.game_description.n_rounds - state.round_number) / self.game_description.n_rounds
        if state.current_stock < self.low_stock_threshold:
            return Action.C
        if avg_opponent_payoff < my_payoff and exploit_threshold < 1.0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_362(BaseStrategy):
    """
    Adaptive Stockwatcher strategy description here.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_history = {}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number <= 2:
            return Action.C
        prev_consumption = np.sum(history.opponent_actions[-1, :] == False)
        T = state.current_stock / (2 * self.game_description.n_players)
        if prev_consumption <= T:
            return Action.C
        else:
            return Action.D
        for opponent, actions in self.opponent_history.items():
            if len(actions) >= 2 and all((action == False for action in actions[-2:])):
                return Action.D
        if state.current_stock <= 2 * self.game_description.n_players:
            return Action.D
        for i, action in enumerate(history.opponent_actions[-1, :]):
            if i not in self.opponent_history:
                self.opponent_history[i] = []
            self.opponent_history[i].append(action == False)
        return Action.C

class Strategy_EXPLOITATIVE_364(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors and maximizes payoffs based on game parameters, state, and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        prev_round_defectors = sum((not action for action in history.opponent_actions[-1, :]))
        if stock_level > 0.75:
            if prev_round_defectors >= self.game_description.n_players - prev_round_defectors:
                return Action.D
            else:
                return Action.C
        elif 0.25 <= stock_level <= 0.75:
            coop_payoff = sum(history.my_payoffs[-2:]) + state.current_stock / (2 * self.game_description.n_players)
            defect_payoff = history.my_payoffs[-1] + state.current_stock / self.game_description.n_players
            if coop_payoff > defect_payoff:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_365(BaseStrategy):
    """
    An exploitative strategy that adapts to the game's dynamic state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_avg_payoff = 0.0
        self.opp_coop_rate = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock >= 0.75 * self.game_description.capacity else Action.D
        self.prev_avg_payoff = np.mean(history.my_payoffs[:state.round_number])
        action = Action.C if self.prev_avg_payoff >= state.current_stock / (2 * self.game_description.n_players) else Action.D
        opponent_coop_rates = np.mean(history.opponent_actions, axis=0)
        self.opp_coop_rate = np.mean(opponent_coop_rates)
        if self.opp_coop_rate > 0.5 and state.current_stock < 0.5 * self.game_description.capacity:
            action = Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if abs(state.current_stock) < 1e-06:
            return Action.D
        return action

class Strategy_EXPLOITATIVE_366(BaseStrategy):
    """
    The Adaptive Stock-Based Exploitation (ASBE) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        threshold = 0.75 * self.game_description.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock >= threshold:
            return Action.C
        else:
            opponent_actions = history.opponent_actions[-1, :]
            p_defect = np.mean(~opponent_actions)
            p = max(0.5, p_defect)
            return Action.D if random.random() < p else Action.C

class Strategy_EXPLOITATIVE_367(BaseStrategy):
    """
    The Adaptive Predator strategy aims to maximize individual payoffs by adaptively responding 
    to the evolving game state and opponents' behaviors. This strategy prioritizes exploitation 
    over cooperation, while maintaining a level of robustness against various opponent tactics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def calculate_average_payoff(self, history: PlayerHistory) -> float:
        if len(history.my_payoffs) == 0 or sum(history.opponent_actions[-1, :]) == 0:
            return 0.0
        else:
            opponent_cooperators = sum(history.opponent_actions[-1, :])
            average_opponent_payoff = np.mean(history.opponent_payoffs[-1, history.opponent_actions[-1, :] == True])
            return (history.my_payoffs[-1] + average_opponent_payoff * opponent_cooperators) / (1 + opponent_cooperators)

    def calculate_cooperation_rate(self, history: PlayerHistory) -> float:
        if len(history.opponent_actions) == 0 or self.game_description.n_players - 1 == 0:
            return 0.5
        else:
            opponent_cooperators = sum(history.opponent_actions[-1, :])
            return opponent_cooperators / (self.game_description.n_players - 1)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        pi_avg = self.calculate_average_payoff(history)
        coop_rate = self.calculate_cooperation_rate(history)
        if state.round_number < self.game_description.n_rounds // 2:
            if pi_avg > state.current_stock / (2 * self.game_description.n_players):
                return Action.D
            else:
                return Action.C
        elif state.round_number < 3 * self.game_description.n_rounds // 4:
            if coop_rate > 0.5:
                return Action.D
            else:
                return Action.C
        elif state.round_number < self.game_description.n_rounds:
            if state.current_stock > self.game_description.capacity / 2:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_368(BaseStrategy):
    """
    Exploitative strategy for the Common Pool Resource Game.
    Adapts to opponents' behavior and stock depletion rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return random.choice([Action.C, Action.D])
        avg_depletion_rate = (state.current_stock - self.get_stock_at_round(history, state.round_number - 5)) / 4 if state.round_number >= 5 else 0
        if avg_depletion_rate > self.capacity / (2 * self.n):
            return Action.D if random.random() < 0.8 else Action.C
        elif state.round_number < self.r // 4:
            coop_prob = 0.5 * sum(history.opponent_actions[-1, :]) / self.n
            return Action.C if random.random() < coop_prob else Action.D
        if state.current_stock < self.capacity / self.n:
            return Action.D if random.random() < 0.9 else Action.C
        elif state.round_number > 3 * self.r // 4 or state.round_number == self.r - 1:
            return Action.C if random.random() < 0.6 else Action.D
        if sum(history.opponent_actions[-1, :]) / self.n > 0.75:
            return Action.C if random.random() < 0.7 else Action.D
        return Action.C if random.random() < 0.4 else Action.D

    def get_stock_at_round(self, history: PlayerHistory, round_number):
        total_consumption = sum(history.my_actions[:round_number + 1]) / self.n + np.sum(history.opponent_actions[:round_number + 1, :], axis=1) / self.n
        stock_after_consumption = self.capacity - np.cumsum(total_consumption)
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
        return min(stock_after_consumption[round_number] + growth[round_number], self.capacity)

class Strategy_EXPLOITATIVE_369(BaseStrategy):
    """
    A robust and adaptive exploitative strategy for the Common Pool Resource Game.
    Balances short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.6 * game_description.capacity
        self.opponent_defection_rates = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        opponent_actions = history.opponent_actions[-1]
        if len(self.opponent_defection_rates) < self.game_description.n_players - 1:
            self.opponent_defection_rates.append(np.mean(1 - opponent_actions))
        else:
            for i in range(len(opponent_actions)):
                self.opponent_defection_rates[i] = self.opponent_defection_rates[i] * (state.round_number - 2) + (1 - opponent_actions[i]) / (state.round_number - 1)
        if current_stock < self.stock_threshold:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif current_stock < 0.2 * self.game_description.capacity:
            return Action.C
        average_opponent_defection_rate = np.mean(self.opponent_defection_rates)
        if average_opponent_defection_rate > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_370(BaseStrategy):
    """
    Exploitative Strategy: "Adaptive Stock Raider"

    This strategy aims to maximize individual payoffs by adaptively responding to the game state and history of opponent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.max_payoff = self.capacity / (2 * self.n_players)
        self.my_actions = []
        self.opponent_majority_actions = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock > 0.75 * self.capacity else Action.D
        avg_payoff = np.mean(history.my_payoffs)
        opponent_majority_action = np.sum(history.opponent_actions[-1, :]) >= self.n_players // 2
        if state.current_stock < 0.5 * self.capacity:
            return Action.C if opponent_majority_action else Action.D
        elif avg_payoff < 0.5 * self.max_payoff:
            return Action.D
        else:
            return Action.C if opponent_majority_action else Action.D

class Strategy_EXPLOITATIVE_371(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behavior and exploits potential cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return random.choice([Action.C, Action.D])
        ocr = np.mean(history.opponent_actions[-1, :])
        critical_stock_level = self.capacity / 4
        if state.current_stock <= critical_stock_level:
            cooperate_prob = 1.0
        elif ocr >= 0.5:
            cooperate_prob = 0.7
        else:
            cooperate_prob = 0.2
        if state.round_number == self.game_description.n_rounds - 1:
            cooperate_prob = 0
        action = Action.C if random.random() < cooperate_prob else Action.D
        return action

class Strategy_EXPLOITATIVE_372(BaseStrategy):
    """
    Exploitative strategy that aims to maximize its payoff by adaptively responding to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_prev = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        coop_count_prev = np.sum(history.opponent_actions[-1])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        elif coop_count_prev >= 0.5 * (self.game_description.n_players - 1):
            return Action.C
        elif self.stock_prev is not None and state.current_stock < self.stock_prev:
            return Action.C
        else:
            return Action.D
        if history is not None:
            self.stock_prev = state.current_stock

class Strategy_EXPLOITATIVE_373(BaseStrategy):
    """
    A robust and exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.previous_actions = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.previous_actions = history.opponent_actions
        if state.round_number <= 5:
            avg_depletion_rate = np.mean(np.diff(history.my_payoffs)) / self.game_description.capacity
            if avg_depletion_rate > 0.5:
                return Action.D
        num_cooperators, num_defectors = (np.sum(self.previous_actions[-1, :] == True), np.sum(self.previous_actions[-1, :] == False))
        if num_cooperators > num_defectors:
            return Action.D
        elif num_defectors > num_cooperators:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 2:
            if state.current_stock < 0.2 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_374(BaseStrategy):
    """
    An adaptive strategy that balances exploitation with sustainability.
    It adapts to the game state and history, monitoring opponents' behaviors 
    and adjusting the probability of defection accordingly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_defection_counts = [0] * game_description.n_players
        self.stock_thresholds = {'high': game_description.capacity / 2, 'low': game_description.capacity / 4}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.opponent_actions):
            for i in range(self.game_description.n_players - 1):
                if not history.opponent_actions[-1, i]:
                    self.opponent_defection_counts[i] += 1
        p_defect = 0.7
        stock = state.current_stock
        if stock > self.stock_thresholds['high']:
            pass
        elif stock < self.stock_thresholds['low']:
            return Action.C
        else:
            previous_round_opponent_defections = ~history.opponent_actions[-1, :]
            if any(previous_round_opponent_defections):
                p_defect += 0.2
            opponent_defection_dominance_threshold = self.game_description.n_rounds * 3 / 4
            for i in range(self.game_description.n_players - 1):
                if self.opponent_defection_counts[i] > opponent_defection_dominance_threshold:
                    p_defect += 0.2
        return Action.D if random.random() < p_defect else Action.C

class Strategy_EXPLOITATIVE_375(BaseStrategy):
    """
    A dynamic and adaptive strategy for the Common Pool Resource Game,
    designed to capitalize on opportunities for short-term gains while maintaining a balance 
    that allows for potential long-term benefits.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_cooperations = np.sum(history.opponent_actions[-1, :])
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.D
        elif 0.5 <= state.current_stock / self.game_description.capacity < 0.75 and opponent_cooperations >= 1:
            return Action.C
        elif state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            opponent_defections = np.sum(history.opponent_actions[:-1, :]) / (state.round_number * self.game_description.n_players)
            if opponent_defections > 0.5:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_376(BaseStrategy):
    """
    The Adaptive Stock Harvester strategy adapts to the game state and opponents' actions 
    while aiming to maximize individual payoffs by exploiting their behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C if state.current_stock >= capacity - n_players * (state.current_stock / (2 * n_players)) else Action.D
        avg_opponent_consumption = np.mean(history.opponent_payoffs, axis=1)
        if avg_opponent_consumption[-1] <= state.current_stock / (2 * n_players):
            return Action.C if state.current_stock >= capacity - n_players * (state.current_stock / (2 * n_players)) else Action.D
        elif state.current_stock < 0.5 * capacity:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * capacity:
            return Action.D

class Strategy_EXPLOITATIVE_377(BaseStrategy):
    """
    An exploitative strategy that adapts to the game state and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_payoff_sum = 0.0
        self.opponent_payoff_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and history.opponent_payoffs.shape[1] > 1:
            self.opponent_payoff_sum = np.sum(history.opponent_payoffs[-1, :])
            self.opponent_payoff_count = history.opponent_payoffs.shape[1]
        avg_opponent_payoff = self.opponent_payoff_sum / max(self.opponent_payoff_count, 1)
        cooperative_payoff = state.current_stock / (2 * self.game_description.n_players)
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.D
        elif 0.25 * self.game_description.capacity < state.current_stock <= 0.75 * self.game_description.capacity:
            if avg_opponent_payoff >= cooperative_payoff:
                return Action.C
            else:
                return Action.D
        elif state.current_stock <= 0.25 * self.game_description.capacity:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_378(BaseStrategy):
    """
    Adaptive Stock-Based Defection strategy.
    
    Exploits opponents by adapting to the current stock level and history of play,
    balancing individual payoffs with the risk of over-harvesting the common pool.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.dt = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        if state.round_number == 0 or history is None:
            return Action.C
        S = state.current_stock
        opponent_actions = history.opponent_actions[-1, :]
        opponent_defected = any((not action for action in opponent_actions))
        if opponent_defected:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if S < 2 * n_players:
            return Action.C
        if self.dt is None:
            self.dt = capacity * (1 - 1 / (n_players + 1))
        if S < self.dt:
            return Action.D
        total_consumption = n_players / (2 * n_players) * S if all(opponent_actions) else sum((action / n_players * S for action in opponent_actions))
        new_S = max(S - total_consumption, 0)
        stock_growth = 2 * new_S * (1 - new_S / capacity)
        if new_S >= S - total_consumption + stock_growth:
            self.dt *= 0.95
        else:
            self.dt *= 1.05
        return Action.C

class Strategy_EXPLOITATIVE_379(BaseStrategy):
    """
    A dynamic strategy designed to exploit opponents' behaviors while adapting to changes in the game state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < self.n_players:
            return Action.C
        low_stock_threshold = self.capacity / 4
        high_stock_threshold = self.capacity * 3 / 4
        if state.current_stock < low_stock_threshold:
            return Action.D
        elif state.current_stock > high_stock_threshold:
            return Action.C
        if history is not None and len(history.my_actions) >= self.n_players:
            avg_consumption_i = np.mean([self.capacity / (2 * self.n_players) if action else self.capacity / self.n_players for action in history.my_actions])
            overall_avg_consumption = np.mean(np.concatenate([[self.capacity / (2 * self.n_players) if action else self.capacity / self.n_players for action in opponent_actions] for opponent_actions in history.opponent_actions]))
            if avg_consumption_i > overall_avg_consumption:
                return Action.D
            elif avg_consumption_i < overall_avg_consumption:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock <= 0:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_380(BaseStrategy):
    """
    Exploitative strategy "Adaptive Stock Raider" that balances short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        last_round_history = history.opponent_actions[-1]
        majority_defected = sum((1 for action in last_round_history if not action)) > self.n_players / 2
        if state.current_stock > 0.75 * self.capacity:
            return Action.D if majority_defected else Action.C
        elif 0.25 * self.capacity <= state.current_stock <= 0.75 * self.capacity:
            total_consumption = sum((self.get_consumption(action, state.current_stock) for action in last_round_history))
            return Action.D if total_consumption > 0.5 * self.capacity else Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock == 0:
            return Action.C

    def get_consumption(self, action: bool, current_stock: float) -> float:
        """
        Calculate consumption based on the player's action.
        :param action: The player's action (True/False for C/D)
        :param current_stock: The current stock level
        :return: Consumption value
        """
        return current_stock / self.n_players if not action else current_stock / (2 * self.n_players)

class Strategy_EXPLOITATIVE_381(BaseStrategy):
    """
    A dynamic, exploitative strategy that leverages game theory and machine learning principles 
    to maximize payoffs in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def monitor_opponents(self, history: PlayerHistory) -> NDArray[np.float64]:
        """Monitor opponents' behaviors and calculate their cooperation ratios"""
        opponent_cooperation_ratios = np.zeros(self.n_players - 1)
        for i in range(self.n_players - 1):
            opponent_actions = history.opponent_actions[:, i]
            cooperate_ratio = np.mean(opponent_actions)
            opponent_cooperation_ratios[i] = cooperate_ratio
        return opponent_cooperation_ratios

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        opponent_cooperation_ratios = self.monitor_opponents(history)
        if state.round_number < self.n_players // 2:
            return Action.C
        if current_stock > self.capacity / 2:
            return Action.D
        elif current_stock < self.capacity / 4:
            return Action.C
        else:
            cooperate_prob = 0.6
            defect_prob = 0.4
            for opponent_cooperation_ratio in opponent_cooperation_ratios:
                if opponent_cooperation_ratio > 0.7:
                    cooperate_prob += 0.1
                    defect_prob -= 0.1
                elif opponent_cooperation_ratio < 0.3:
                    cooperate_prob -= 0.1
                    defect_prob += 0.1
            if random.random() < cooperate_prob:
                return Action.C
            else:
                return Action.D
        if state.round_number >= self.game_description.n_rounds - self.n_players // 2:
            return Action.D

class Strategy_EXPLOITATIVE_382(BaseStrategy):
    """
    An exploitative strategy that adapts to the game's dynamics and its opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.stock_threshold = self.capacity / (2 * self.n_players)
        self.epsilon = self.capacity / (10 * self.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponents_cooperated = np.sum(history.opponent_actions[-1, :])
        if opponents_cooperated > self.n_players / 2:
            self.stock_threshold -= self.epsilon
        elif opponents_cooperated < self.n_players / 2:
            self.stock_threshold += self.epsilon
        if state.current_stock >= self.stock_threshold and state.round_number < self.game_description.n_rounds - 1:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_383(BaseStrategy):
    """
    Exploitative strategy that adapts to the current stock level and opponents' behaviors.
    Prioritizes individual payoff while cooperating when necessary to sustain the stock for future rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_level = game_description.capacity
        self.round_number = 0
        self.opponent_cooperates = False

    def calculate_total_consumption(self, actions: NDArray[np.bool_]) -> float:
        """Calculate total consumption based on all players' actions"""
        cooperation_consumption = (self.game_description.n_players - np.sum(actions)) * self.stock_level / (2 * self.game_description.n_players)
        defection_consumption = np.sum(actions) * self.stock_level / self.game_description.n_players
        return cooperation_consumption + defection_consumption

    def calculate_stock_growth(self, stock_level: float, capacity: int) -> float:
        """Calculate stock growth based on the remaining stock level and capacity"""
        growth_rate = 2 * stock_level * (1 - stock_level / capacity)
        return min(growth_rate, capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or self.round_number == 0:
            self.stock_level = state.current_stock
            self.round_number += 1
            return Action.C
        if history is not None and history.opponent_actions.shape[0] > 2:
            opponent_actions_last_round = history.opponent_actions[-1, :]
            self.opponent_cooperates = np.mean(opponent_actions_last_round) > 0.5
        if state.current_stock < 0.01 * self.game_description.capacity or (self.opponent_cooperates and state.round_number > 2):
            return Action.C
        if state.current_stock >= 0.75 * self.game_description.capacity:
            action = Action.D
        elif state.current_stock >= 0.5 * self.game_description.capacity:
            action = Action.C
        else:
            action = Action.D
        total_consumption = self.calculate_total_consumption(action == Action.C)
        stock_growth = self.calculate_stock_growth(state.current_stock - total_consumption, self.game_description.capacity)
        self.stock_level = min(state.current_stock - total_consumption + stock_growth, self.game_description.capacity)
        if state.round_number == self.game_description.n_rounds:
            return Action.D
        self.round_number += 1
        return action

class Strategy_EXPLOITATIVE_384(BaseStrategy):
    """
    Exploitative Strategy: "Adaptive Stock-Dependent Defection" (ASDD)
    
    This strategy balances short-term gains with long-term sustainability by adapting to various opponent behaviors.
    It considers the stock-dependent defection threshold and opponents' past actions to effectively exploit vulnerabilities
    in others' strategies while minimizing its own exposure to exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperative_targets = set()

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponents_defected_prev_round = sum((1 for action in history.opponent_actions[-1, :] if not action))
        sdt = self.game_description.capacity / (2 * self.game_description.n_players)
        if state.current_stock <= sdt:
            return Action.C
        elif state.current_stock > sdt and opponents_defected_prev_round >= 2:
            return Action.D
        avg_payoff_opponents_defected = np.mean([payoff for action, payoff in zip(history.opponent_actions[-1, :], history.opponent_payoffs[-1, :]) if not action])
        current_player_cooperate_payoff = state.current_stock / (2 * self.game_description.n_players)
        for i, opponent_action in enumerate(history.opponent_actions[-1, :]):
            if opponent_action and state.current_stock <= sdt:
                self.cooperative_targets.add(i)
        if any((opponent_defected in self.cooperative_targets for opponent_defected in [not action for action in history.opponent_actions[-1, :]])):
            return Action.D
        if current_player_cooperate_payoff >= avg_payoff_opponents_defected:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_385(BaseStrategy):
    """
    Exploitative strategy that balances short-term gains with long-term sustainability by adapting to the game's dynamic state and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        if state.round_number == 0 or history is None:
            return Action.D
        current_stock = state.current_stock
        num_cooperators = sum(history.opponent_actions[-1, :])
        if current_stock > 0.75 * capacity:
            return Action.C
        elif 0.25 * capacity <= current_stock <= 0.75 * capacity:
            p_defect = (self.game_description.n_players - num_cooperators) / self.game_description.n_players
            if random.random() < p_defect:
                return Action.D
            else:
                return Action.C
        elif current_stock < 0.25 * capacity:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_386(BaseStrategy):
    """
    A strategy to maximize individual payoffs by adaptively exploiting the stock dynamics and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if self.game_description.n_players > 10 else Action.D
        total_consumption = sum(history.opponent_actions[-1, :]) / self.game_description.n_players + history.my_actions[-1] / (2 * self.game_description.n_players)
        growth = 2 * state.current_stock * (1 - state.current_stock / self.game_description.capacity)
        if state.current_stock > 0.75 * self.game_description.capacity and growth > 0.25 * self.game_description.capacity:
            return Action.D
        elif total_consumption < 0.5 * state.current_stock:
            return Action.C
        if total_consumption > 0.75 * state.current_stock:
            self.cooperation_threshold = min(self.cooperation_threshold + 0.05, 1)
        elif growth < 0.25 * self.game_description.capacity and self.cooperation_threshold > 0:
            self.cooperation_threshold = max(self.cooperation_threshold - 0.05, 0)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        return Action.C if random.random() < self.cooperation_threshold else Action.D

class Strategy_EXPLOITATIVE_387(BaseStrategy):
    """
    An adaptive exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.cooperation_threshold = 0.75 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > 0.5 * self.capacity:
                return Action.D
            else:
                return Action.C
        recent_opponent_actions = history.opponent_actions[-3:]
        opponent_cooperation_rate = np.mean(recent_opponent_actions)
        if opponent_cooperation_rate > 0.5:
            return Action.D
        if state.current_stock < self.cooperation_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_388(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors and maximizes payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold_fraction = 0.7
        self.cooperation_rate_threshold = 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        stock_threshold = self.stock_threshold_fraction * capacity
        if state.current_stock < stock_threshold:
            return Action.D
        opponent_actions = history.opponent_actions
        for player in range(opponent_actions.shape[1]):
            cooperation_rate = np.mean(opponent_actions[:, player])
            if cooperation_rate < self.cooperation_rate_threshold:
                return Action.D
        stock_trend = np.diff(history.my_payoffs[-3:])
        if all(stock_trend <= 0):
            return Action.C
        if state.round_number > self.game_description.n_rounds - 2:
            return Action.D
        return random.choice([Action.C, Action.D])

class Strategy_EXPLOITATIVE_389(BaseStrategy):
    """
    The Adaptive Predator strategy is designed to exploit a wide range of opponent behaviors while adapting to the dynamic state of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0:
            return Action.C
        elif current_stock > 0.75 * capacity:
            return Action.D
        elif 0.25 <= current_stock / capacity <= 0.75:
            if history is not None and len(history.opponent_actions) > 0:
                opponent_cooperation_rate = np.mean(history.opponent_actions[-1, :])
                return Action.C if opponent_cooperation_rate > 0.5 else Action.D
            else:
                return Action.C
        else:
            if history is not None and len(history.opponent_actions) > 0:
                all_opponents_defected = np.all(~history.opponent_actions[-1, :])
                return Action.C
            return Action.C
        if round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_390(BaseStrategy):
    """
    An adaptive exploitative strategy for the Common Pool Resource Game.
    Initially explores the environment by randomizing actions, then adapts to the game state and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_trend = None
        self.average_payoff_last_rounds = float('inf')

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return random.choice([Action.C, Action.D])
        if self.stock_trend is None:
            self.stock_trend = 'increasing' if state.current_stock > self.game_description.capacity / 2 else 'decreasing'
        if state.current_stock >= self.game_description.capacity / 2:
            action = Action.C
        elif self.stock_trend == 'increasing':
            action = Action.C
        else:
            action = Action.D
        if history.my_payoffs.mean() < self.game_description.capacity / (2 * self.game_description.n_players):
            action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        previous_stock = history.my_payoffs.size * (self.game_description.capacity / (2 * self.game_description.n_players))
        if state.current_stock > previous_stock:
            self.stock_trend = 'increasing'
        elif state.current_stock == previous_stock:
            self.stock_trend = 'stable'
        else:
            self.stock_trend = 'decreasing'
        return action

class Strategy_EXPLOITATIVE_391(BaseStrategy):
    """
    An exploitative strategy that adapts to various opponent behaviors in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        ocr_window_size = min(5, state.round_number)
        opponent_actions = history.opponent_actions[-ocr_window_size:, :]
        ocr = np.mean(opponent_actions) / self.game_description.n_players
        if state.current_stock < 0.2 * self.game_description.capacity:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 1:
            return Action.D
        prev_opponent_actions = history.opponent_actions[-1, :]
        majority_action = np.mean(prev_opponent_actions) > 0.5
        if ocr > 0.7:
            return Action.D
        elif ocr < 0.4:
            return Action.C
        else:
            return Action.C if majority_action else Action.D

class Strategy_EXPLOITATIVE_392(BaseStrategy):
    """
    Exploitative strategy that adapts to the game state and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / (2 * game_description.n_players)
        self.selfishness_factor = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.selfishness_factor += 0.1
        if state.current_stock > self.stock_threshold:
            defectors_prev = sum((1 for action in history.opponent_actions[-1, :] if not action))
            if defectors_prev > self.game_description.n_players / 2:
                return Action.D
            if self.selfishness_factor > random.random():
                return Action.D
        avg_coop_payoff = np.mean(history.my_payoffs[history.my_actions])
        avg_defect_payoff = np.mean(history.my_payoffs[~history.my_actions])
        if avg_coop_payoff > avg_defect_payoff:
            return Action.C
        else:
            return Action.D
        if state.current_stock < self.game_description.capacity / (4 * self.game_description.n_players):
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_393(BaseStrategy):
    """
    Adaptive Exploiter strategy for the Common Pool Resource Game.
    
    This strategy combines elements of cooperation, defection, and adaptability 
    to effectively exploit various opponent behaviors in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.my_actions = None

    def calculate_acr(self, history: PlayerHistory) -> float:
        """Calculate average cooperation rate among opponents"""
        opponent_cooperations = np.sum(history.opponent_actions, axis=1)
        return np.mean(opponent_cooperations)

    def assess_stock_level(self, stock_level: float) -> bool:
        """Assess current stock level"""
        return stock_level < self.game_description.capacity / 2

    def analyze_opponent_actions(self, history: PlayerHistory) -> int:
        """Analyze opponents' actions in the most recent round"""
        opponent_defections = np.sum(~history.opponent_actions[-1, :])
        return opponent_defections

    def alternate_actions(self) -> Action:
        """Alternate between cooperating and defecting"""
        if self.my_actions is None or len(self.my_actions) == 0:
            return Action.C
        last_action = self.my_actions[-1]
        return Action.D if last_action else Action.C

    def focus_on_payoffs(self, stock_level: float) -> bool:
        """Focus on maximizing payoffs"""
        return stock_level < self.game_description.capacity / 4

    def update_stock_level(self, stock_level: float, n: int, capacity: int) -> float:
        """Update the current stock level"""
        total_consumption = np.sum(stock_level / (2 * n)) if len(self.my_actions) == 0 else np.sum(stock_level / n)
        remaining_stock = max(0.0, stock_level - total_consumption)
        growth = 2 * remaining_stock * (1 - remaining_stock / capacity)
        return min(remaining_stock + growth, capacity)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.my_actions = []
            return Action.C
        if state.round_number <= 5:
            acr = self.calculate_acr(history)
            return Action.D if acr > 0.5 else Action.C
        if state.round_number <= self.game_description.n_rounds // 2:
            low_stock = self.assess_stock_level(state.current_stock)
            if low_stock:
                return Action.D
            opponent_defections = self.analyze_opponent_actions(history)
            if opponent_defections >= self.game_description.n_players / 2:
                return Action.D
            opponent_cooperations = np.sum(~history.opponent_actions[-1, :])
            if opponent_cooperations > 0.75 * self.game_description.n_players:
                return Action.C
            return self.alternate_actions()
        low_payoff = self.focus_on_payoffs(state.current_stock)
        if low_payoff:
            return Action.C
        return Action.D
        self.my_actions.append(action)
        state.current_stock = self.update_stock_level(state.current_stock, self.game_description.n_players, self.game_description.capacity)
        return action

class Strategy_EXPLOITATIVE_394(BaseStrategy):
    """
    An adaptive and exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        opponents_defected_prev_round = sum((1 for opponent_action in history.opponent_actions[-1, :] if not opponent_action))
        if stock_level > 0.75:
            return Action.C
        elif 0.25 <= stock_level <= 0.75:
            if opponents_defected_prev_round >= self.game_description.n_players / 2:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D
        for opponent_actions in history.opponent_actions.T:
            if not opponent_actions[-1] and (not opponent_actions[-2]):
                return Action.D
            elif opponent_actions[-1] and opponent_actions[-2]:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 2:
            if stock_level > 0.5:
                return Action.C
        for opponent_actions in history.opponent_actions.T:
            if all((action is None for action in opponent_actions)):
                return Action.C

class Strategy_EXPLOITATIVE_395(BaseStrategy):
    """
    Adaptive Stock Raider exploits the common pool resource by adapting to opponents' behavior and dynamic state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.ACR_threshold = 0.5
        self.avg_payoff_diff = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock >= 0.75 * self.game_description.capacity else Action.D
        ACR_t = sum((1 for action in history.opponent_actions[-1, :] if action)) / self.game_description.n_players
        payoff_diff = (sum(history.my_payoffs[:]) - np.mean(history.opponent_payoffs[:, :], axis=0).mean()) / state.round_number
        if abs(payoff_diff) > 0.1:
            self.ACR_threshold += np.sign(-payoff_diff) * 0.1
        return Action.C if ACR_t >= self.ACR_threshold else Action.D

class Strategy_EXPLOITATIVE_396(BaseStrategy):
    """
    A strategic approach for the Common Pool Resource Game that adapts to various opponent behaviors while aiming to maximize payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_avg_payoff = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C
        avg_payoff = np.mean(history.my_payoffs[-1] + history.opponent_payoffs[-1, :]) / n_players
        coop_threshold = state.current_stock / (2 * n_players)
        if 0 < state.round_number < self.game_description.n_rounds - 1:
            if avg_payoff >= coop_threshold and state.current_stock > n_players * coop_threshold:
                return Action.C
            elif state.current_stock > n_players * coop_threshold:
                return Action.D
        else:
            return Action.D
        self.prev_avg_payoff = avg_payoff
        return Action.C

class Strategy_EXPLOITATIVE_397(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource game that exploits various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.total_consumption_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        my_previous_action = history.my_actions[-1]
        opponent_previous_actions = history.opponent_actions[-1, :]
        total_consumption = self.calculate_total_consumption(my_previous_action, opponent_previous_actions, state.current_stock)
        self.total_consumption_history.append(total_consumption)
        if state.current_stock >= 0.75 * self.capacity:
            if total_consumption < 0.5 * self.capacity:
                return Action.D
            else:
                return Action.C
        elif 0.25 * self.capacity < state.current_stock < 0.75 * self.capacity:
            p = math.pow(state.current_stock / self.capacity, 2)
            return Action.C if random.random() < p else Action.D
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

    def calculate_total_consumption(self, my_action: bool, opponent_actions: NDArray[np.bool_], current_stock: float) -> float:
        total_consumption = 0
        for action in [my_action] + opponent_actions.tolist():
            if action:
                total_consumption += current_stock / (2 * self.game_description.n_players)
            else:
                total_consumption += current_stock / self.game_description.n_players
        return total_consumption

class Strategy_EXPLOITATIVE_398(BaseStrategy):
    """
    Adaptive Stock-Based Defection (ASBD) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.initial_threshold = 0.5
        self.threshold = self.initial_threshold
        self.previous_stock = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock > self.threshold * self.game_description.capacity:
            action = Action.D
        else:
            action = Action.C
        growth_rate = (state.current_stock - self.previous_stock) / self.game_description.capacity
        if growth_rate > 0.2:
            self.threshold *= 1.1
        elif growth_rate < 0.05 and self.threshold > 0.01:
            self.threshold *= 0.95
        opponents_defected_last_round = sum((1 for opponent_action in history.opponent_actions[-1, :] if not opponent_action))
        if opponents_defected_last_round > self.game_description.n_players / 2:
            action = Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.C
        self.previous_stock = state.current_stock
        return action

class Strategy_EXPLOITATIVE_399(BaseStrategy):
    """
    An exploitative strategy that adapts to changing game conditions by 
    balancing short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_payoff_per_player = np.mean(history.my_payoffs[-1] + np.sum(history.opponent_payoffs[-1], axis=0))
        stock_level = state.current_stock / self.game_description.capacity
        C_payoff = state.current_stock / (2 * self.game_description.n_players)
        if stock_level > 0.75 and avg_payoff_per_player >= C_payoff:
            return Action.D
        elif stock_level < 0.25:
            return Action.C
        elif avg_payoff_per_player < C_payoff and any((not action for action in history.opponent_actions[-1, :])):
            return Action.D
        else:
            cooperate_prob = min(1, 0.5 + stock_level)
            if random.random() < cooperate_prob:
                return Action.C
            else:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_400(BaseStrategy):
    """
    A dynamic and exploitative strategy that leverages game parameters, state, and history to maximize payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.opponent_actions = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.stock_history.append(state.current_stock)
        if history is not None:
            self.opponent_actions.extend(history.opponent_actions)
        avg_coop_rate = self.calculate_avg_coop_rate(self.game_description.n_players, self.opponent_actions[-self.game_description.n_players:])
        theta = 0.5 - state.current_stock / self.game_description.capacity / (2 * self.game_description.n_players)
        if avg_coop_rate > theta:
            return Action.C
        else:
            return Action.D

    def calculate_avg_coop_rate(self, n: int, opponent_actions):
        coop_count = sum((1 for actions in opponent_actions for action in actions if action))
        return coop_count / (n * len(opponent_actions))

class Strategy_EXPLOITATIVE_401(BaseStrategy):
    """
    An adaptive and exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if self.game_description.n_players % 2 == 0 else Action.D
        avg_payoff_per_player = np.mean(history.opponent_payoffs[-1, :])
        stock_level = state.current_stock / self.game_description.capacity
        if avg_payoff_per_player >= 0.75 * (self.game_description.capacity / self.game_description.n_players):
            return Action.C
        elif stock_level > 0.5 and state.round_number != self.game_description.n_rounds - 1:
            return Action.D
        elif stock_level < 0.25 and np.sum(history.my_actions[-2:]) == 0:
            return Action.C
        else:
            return Action.D if state.round_number == self.game_description.n_rounds - 1 else Action.D

class Strategy_EXPLOITATIVE_402(BaseStrategy):
    """
    An exploitative strategy that adaptively responds to the current stock level, opponent behavior, and game history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        stock_level_ratio = state.current_stock / self.capacity
        if stock_level_ratio >= 0.75:
            return Action.C
        elif stock_level_ratio < 0.25:
            return Action.D
        else:
            opponent_actions = history.opponent_actions[:-1, :]
            opponent_cooperation_rate = np.mean(opponent_actions)
            if opponent_cooperation_rate > 0.5:
                return Action.C
            elif opponent_cooperation_rate < 0.5:
                return Action.D
            else:
                cooperation_probability = stock_level_ratio
                return Action.C if random.random() < cooperation_probability else Action.D
        if history.my_payoffs[-1] > 0 and state.current_stock > 0.5 * self.capacity:
            return Action.C
        elif history.my_payoffs[-1] < 0 and state.current_stock < 0.2 * self.capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_403(BaseStrategy):
    """
    The Adaptive Stock Hawk strategy is designed to exploit a wide range of opponent behaviors 
    while adapting to changes in the game state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.ocr_window_size = 3

    def calculate_average_opponent_cooperation_rate(self, history: PlayerHistory) -> float:
        last_rounds = min(history.opponent_actions.shape[0], self.ocr_window_size)
        recent_opponent_actions = history.opponent_actions[-last_rounds:, :]
        opponent_cooperations = np.sum(recent_opponent_actions == 1, axis=(0, 1))
        return opponent_cooperations / (last_rounds * self.game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        ocr = self.calculate_average_opponent_cooperation_rate(history)
        stock_level = state.current_stock / self.game_description.capacity
        if state.round_number + 1 == self.game_description.n_rounds:
            return Action.D
        if stock_level > 0.9:
            return Action.C
        if stock_level < 0.1:
            return Action.D
        if stock_level > 0.75:
            return Action.D
        elif stock_level > 0.5 and ocr > 0.6:
            return Action.C
        elif stock_level < 0.5:
            return Action.D
        elif ocr < 0.4:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_404(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Stock-Based Defection (ASBD)

    This strategy starts by cooperating in the first round, gathering information about opponents' behavior and initial stock level.
    Then it uses a stock-dependent defection threshold that is adjusted based on observed opponents' behavior and payoffs from previous rounds.
    If an opponent's payoff in the previous round is significantly higher than this player's, ASBD assumes they are exploiting this player and adjusts its strategy to defect more often.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if state.round_number == 0:
            return Action.C
        previous_round_payoffs = history.opponent_payoffs[-1]
        previous_round_actions = history.opponent_actions[-1]
        stock_threshold = capacity / (2 * n)
        adjusted_stock_threshold = stock_threshold
        if len(history.my_payoffs) > 0:
            my_previous_payoff = history.my_payoffs[-1]
            defection_rate = sum((1 for action in previous_round_actions if not action)) / n
            adjusted_stock_threshold *= 1 - defection_rate
        if current_stock > adjusted_stock_threshold:
            return Action.D
        if len(history.opponent_payoffs) > 0:
            for opponent_index, opponent_payoff in enumerate(previous_round_payoffs):
                payoff_ratio = opponent_payoff / my_previous_payoff
                if payoff_ratio > 1.2 and state.round_number < self.game_description.n_rounds - 1:
                    stock_threshold *= 1.1
        return Action.C

class Strategy_EXPLOITATIVE_405(BaseStrategy):
    """
    A strategic approach that's both adaptive and exploitative for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_level = game_description.capacity
        self.opponents_cooperating = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.stock_level = state.current_stock
        if history is not None:
            opponent_actions_last_round = history.opponent_actions[-1, :]
            estimated_defectors = sum(1 - opponent_actions_last_round)
            total_consumption = self.game_description.capacity / (2 * self.game_description.n_players) * (self.game_description.n_players - estimated_defectors) + self.stock_level / self.game_description.n_players * estimated_defectors
            if total_consumption > self.game_description.capacity / 2:
                return Action.D
            if self.stock_level < self.game_description.capacity and total_consumption <= self.game_description.capacity / 2:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_406(BaseStrategy):
    """
    Adaptive exploitative strategy for the Common Pool Resource Game.
    
    Combines elements of Tit-for-Tat with a dynamic threshold for cooperation based on 
    the current stock level and opponent's history. Includes simple exploitation detection.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.exploitation_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_level = state.current_stock
        capacity = self.game_description.capacity
        if stock_level > 0.75 * capacity:
            return Action.C
        elif stock_level < 0.25 * capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        majority_cooperated = sum(opponent_actions) > len(opponent_actions) / 2
        if majority_cooperated:
            return Action.C
        self.exploitation_count += sum((1 for i in range(len(opponent_actions)) if opponent_actions[i] == False and sum(opponent_actions) > len(opponent_actions) / 2))
        if self.exploitation_count >= 3:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_407(BaseStrategy):
    """
    Exploitative strategy for the Common Pool Resource Game.
    
    This strategy adapts to the game's state and history while attempting to exploit opponents' behaviors.
    It balances cooperation and defection to maximize payoffs by adjusting a dynamic threshold θ based on the game's progression.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.theta = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        total_consumption = sum(history.my_payoffs[-1] + history.opponent_payoffs[-1])
        current_stock = state.current_stock
        if current_stock < self.theta * self.capacity or total_consumption > self.capacity / (2 * self.n_players):
            self.theta -= 0.05
        elif current_stock >= self.theta * self.capacity and total_consumption <= self.capacity / (2 * self.n_players):
            self.theta += 0.05
        if current_stock >= self.theta * self.capacity:
            opponent_defected = any((not action for action in history.opponent_actions[-1]))
            if opponent_defected and total_consumption < self.capacity / (2 * self.n_players):
                return Action.C
        else:
            all_cooperated = all((action for action in history.opponent_actions[-1]))
            if all_cooperated or total_consumption > self.capacity / (2 * self.n_players):
                return Action.D
        return Action.D

    def handle_edge_cases(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.current_stock < 0.1 * self.capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            opponent_defected = any((not action for action in history.opponent_actions[-1]))
            total_consumption = sum(history.my_payoffs[-1] + history.opponent_payoffs[-1])
            if state.current_stock >= self.theta * self.capacity and opponent_defected and (total_consumption < self.capacity / (2 * self.n_players)):
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_408(BaseStrategy):
    """
    Dynamic and adaptive strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.avg_cooperation_rate = 0.5
        self.stock_level = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number < self.game_description.n_rounds // 2:
            opponents_actions = history.opponent_actions[-1, :]
            avg_cooperation = np.mean(opponents_actions)
            self.avg_cooperation_rate += avg_cooperation / (self.game_description.n_rounds // 2 - 1)
            if self.avg_cooperation_rate > 0.5:
                return Action.D if random.random() < 0.7 else Action.C
            return Action.C
        self.stock_level = state.current_stock
        opponents_actions = history.opponent_actions[-1, :]
        at_least_one_defected = np.any(~opponents_actions)
        all_cooperated = np.all(opponents_actions)
        if self.stock_level < self.game_description.capacity / 2:
            return Action.D if random.random() < 0.8 else Action.C
        if at_least_one_defected:
            return Action.D
        elif all_cooperated and self.avg_cooperation_rate > 0.7:
            return Action.C
        return Action.D if random.random() < 0.6 else Action.C

class Strategy_EXPLOITATIVE_409(BaseStrategy):
    """
    Exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_thresholds = {'initial': math.ceil(game_description.n_rounds / 2), 'middle': math.floor(3 * game_description.n_rounds / 4)}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock >= 0.75 * self.game_description.capacity else Action.D
        opponent_actions = history.opponent_actions[-1, :] if history is not None else []
        most_defected = sum((1 for action in opponent_actions if action == False)) > len(opponent_actions) / 2
        if state.round_number <= self.round_thresholds['initial']:
            return Action.C if state.current_stock >= 0.75 * self.game_description.capacity else Action.D
        elif state.round_number <= self.round_thresholds['middle']:
            return Action.D if most_defected else Action.C if state.current_stock >= 0.5 * self.game_description.capacity else Action.D
        else:
            return Action.C if state.current_stock < 0.25 * self.game_description.capacity else Action.D

class Strategy_EXPLOITATIVE_410(BaseStrategy):
    """
    The Adaptive Predator strategy is designed to exploit the behaviors of other players while adapting to changing game conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        avg_coop_rate = np.mean(opponent_actions)
        if state.current_stock > 0.75 * self.game_description.capacity and avg_coop_rate < 0.5:
            threshold = 0.4
        elif (state.current_stock >= 0.25 * self.game_description.capacity and state.current_stock <= 0.75 * self.game_description.capacity) and avg_coop_rate >= 0.5 and (avg_coop_rate <= 0.8):
            threshold = 0.6
        else:
            threshold = 0.8
        π_defect = state.current_stock / self.game_description.n_players
        π_coop = state.current_stock / (2 * self.game_description.n_players)
        if π_defect > π_coop and avg_coop_rate < threshold:
            return Action.D
        elif np.any(~history.opponent_actions[-1, :]) and state.current_stock > 0.1 * self.game_description.capacity:
            return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_411(BaseStrategy):
    """
    An exploitative strategy that adapts to the current state and history of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.coop_probability = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.D
        previous_round = history.opponent_actions[-1, :]
        opponents_d = sum([not action for action in previous_round])
        opponents_c = len(previous_round) - opponents_d
        if opponents_d > opponents_c:
            return Action.C
        elif opponents_c > opponents_d:
            return Action.D
        total_consumption = 0
        my_action = history.my_actions[-1]
        for i, action in enumerate(history.opponent_actions[-1, :]):
            if action and (not my_action):
                total_consumption += state.current_stock / self.game_description.n_players
            elif not action and my_action:
                total_consumption += state.current_stock / (2 * self.game_description.n_players)
            elif action and my_action:
                total_consumption += state.current_stock / (2 * self.game_description.n_players)
            elif not action and (not my_action):
                total_consumption += state.current_stock / self.game_description.n_players
        if total_consumption > 0.5 * self.game_description.capacity:
            self.coop_probability = min(1, self.coop_probability + 0.2)
        elif total_consumption < 0.3 * self.game_description.capacity:
            self.coop_probability = max(0, self.coop_probability - 0.2)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C if random.random() < self.coop_probability else Action.D

class Strategy_EXPLOITATIVE_412(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_actions_history = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.opponent_actions_history is None:
            self.opponent_actions_history = history.opponent_actions
        else:
            self.opponent_actions_history = np.concatenate((self.opponent_actions_history, [history.opponent_actions[-1]]))
        high_stock = state.current_stock > self.game_description.capacity / 2
        if high_stock and sum(self.opponent_actions_history[-1, :]) > self.game_description.n_players / 2:
            return Action.D
        elif state.current_stock <= self.game_description.capacity / 4:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if high_stock:
                return Action.D
            else:
                return Action.C
        defector_count = sum(self.opponent_actions_history[-1, :]) == 0
        majority_defected = defector_count > self.game_description.n_players / 2
        if high_stock and (not majority_defected):
            return Action.C
        elif state.current_stock <= self.game_description.capacity / 2:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_413(BaseStrategy):
    """
    An exploitative strategy that adapts to the game's state and opponents' behavior.
    Initially cooperates, then switches to defect when the stock is depleted or opponents are non-cooperative.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.theta = 0.5
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < self.game_description.n_players:
            return Action.C
        total_consumption = sum(history.my_payoffs[:state.round_number])
        self.theta = max(0.5, 1 - total_consumption / self.game_description.capacity)
        if state.round_number == self.game_description.n_rounds:
            return Action.D
        if state.current_stock < 2 * self.game_description.n_players:
            return Action.D
        if state.current_stock < self.theta * self.game_description.capacity:
            return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        cooperators = sum(opponent_actions)
        if cooperators >= self.game_description.n_players // 2:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_414(BaseStrategy):
    """
    A robust and exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio > 0.75:
            return Action.D
        elif stock_ratio < 0.25:
            return Action.C
        else:
            opponent_actions = history.opponent_actions[-1, :]
            defect_count = np.sum(~opponent_actions)
            cooperate_count = self.game_description.n_players - 1 - defect_count
            if state.round_number == self.game_description.n_rounds - 1:
                return Action.D
            elif defect_count > cooperate_count:
                return Action.C
            elif cooperate_count > defect_count:
                return Action.D
            else:
                return Action.C

class Strategy_EXPLOITATIVE_415(BaseStrategy):
    """
    The Adaptive Stock Hawk strategy balances short-term gains with long-term sustainability.
    It adapts to opponents' behavior and adjusts the Defection probability accordingly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.hawks_detected = []
        self.prob_defect = 0.4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock_percentage = state.current_stock / self.game_description.capacity
        if current_stock_percentage >= 0.75:
            return Action.D
        elif 0.5 <= current_stock_percentage < 0.75:
            prob_coop = 0.6
            if random.random() < prob_coop:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C
        for i in range(self.game_description.n_players - 1):
            opponent_defections = np.sum(history.opponent_actions[:, i])
            if opponent_defections > state.round_number / 2:
                self.hawks_detected.append(i)
        if len(self.hawks_detected) == 1:
            self.prob_defect = 0.7
        elif len(self.hawks_detected) > 1:
            self.prob_defect = 0.8
        return Action.D if random.random() < self.prob_defect else Action.C

class Strategy_EXPLOITATIVE_417(BaseStrategy):
    """
    Exploitative strategy that adapts to the dynamic state of the game and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_c_propensities = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.opponent_c_propensities is None and history is not None:
            self.opponent_c_propensities = [0.0] * (self.game_description.n_players - 1)
        for i, opponent_action in enumerate(history.opponent_actions[-1]):
            if opponent_action == Action.C:
                self.opponent_c_propensities[i] += 1
        c_threshold = 0.75 * self.game_description.capacity
        d_threshold = 0.5 * self.game_description.capacity
        for i, propensity in enumerate(self.opponent_c_propensities):
            propensity /= state.round_number
            if propensity > 0.6:
                c_threshold += 0.1 * self.game_description.capacity
            elif propensity < 0.4:
                d_threshold -= 0.1 * self.game_description.capacity
        if state.current_stock > c_threshold:
            action = Action.D
        elif state.current_stock >= d_threshold:
            action = Action.C
        else:
            action = Action.D
        if state.round_number >= self.game_description.n_rounds - 2:
            action = Action.C
        return action

class Strategy_EXPLOITATIVE_418(BaseStrategy):
    """
    Exploitative strategy that adapts to the dynamic state of the game and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defect_prob = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.current_stock > 0.7 * self.game_description.capacity:
            action = Action.C
        elif state.current_stock >= 0.3 * self.game_description.capacity:
            action = Action.D
            if history is not None:
                cooperators = sum((1 for a in history.opponent_actions[-1, :] if a))
                defectors = self.game_description.n_players - 1 - cooperators
                if cooperators > (self.game_description.n_players - 1) * 0.5:
                    self.defect_prob += 0.2
                elif defectors > (self.game_description.n_players - 1) * 0.5:
                    self.defect_prob -= 0.2
        else:
            action = Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if random.random() < self.defect_prob:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_419(BaseStrategy):
    """
    An adaptive exploitative strategy for the Common Pool Resource game.
    It balances short-term gains with long-term sustainability by adjusting its behavior based on the stock's current state and opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.7 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock = state.current_stock
        opponent_actions = history.opponent_actions[-1, :] if history else []
        action = Action.D if stock > self.stock_threshold else Action.C
        majority_defect = sum((1 - opp for opp in opponent_actions)) / len(opponent_actions) >= 0.5 if opponent_actions.size > 0 else False
        if majority_defect and action == Action.C:
            action = Action.D
        elif not majority_defect and action == Action.D:
            action = Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return action

class Strategy_EXPLOITATIVE_420(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game.
    This strategy adapts to the game's state and history, balancing cooperation and defection to maximize individual payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.opponent_actions_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock > 0.9 * self.stock_capacity else Action.D
        previous_round_opponent_actions = history.opponent_actions[-1, :]
        opponents_cooperated = sum(previous_round_opponent_actions)
        average_payoff = np.mean(history.my_payoffs)
        if state.current_stock > 0.5 * self.stock_capacity and opponents_cooperated >= self.n_players / 2:
            return Action.C
        elif history.my_payoffs[-1] < average_payoff:
            return Action.C
        return Action.D if state.round_number == self.game_description.n_rounds - 1 else Action.C

class Strategy_EXPLOITATIVE_421(BaseStrategy):
    """
    The Adaptive Stock Hawk strategy aims to maximize individual payoff by adaptively responding 
    to the current stock level and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C if state.current_stock > 0.75 * self.game_description.capacity else Action.D
        previous_total_consumption = np.sum(history.opponent_actions[-1, :]) / self.game_description.n_players + 1 / self.game_description.n_players
        previous_new_stock_level = max(0, state.current_stock - previous_total_consumption)
        EF = previous_total_consumption / self.game_description.capacity * (1 - previous_new_stock_level / self.game_description.capacity)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock > 0.5 * self.game_description.capacity and EF < 0.3:
            return Action.C
        elif state.current_stock > 0.25 * self.game_description.capacity and EF < 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_422(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behaviors and the current state of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.threshold_high = 0.5 * self.capacity
        self.threshold_low = 0.25 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        cooperators = sum(opponent_actions)
        defectors = len(opponent_actions) - cooperators
        if cooperators >= self.game_description.n_players // 2:
            self.threshold_high *= 1.5
            self.threshold_low *= 0.4
        elif defectors >= self.game_description.n_players // 2:
            self.threshold_high /= 1.5
            self.threshold_low *= 0.4
        if state.round_number < self.game_description.n_rounds - 1:
            if state.current_stock > self.threshold_high:
                return Action.D
            elif state.current_stock >= self.threshold_low and state.current_stock <= self.threshold_high:
                return Action.C
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_423(BaseStrategy):
    """
    An adaptive strategy that balances information gathering, adaptability, and exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number <= 2 or (history is not None and history.my_actions.shape[0] < 3):
            return Action.C
        prev_defectors = self.n_players - sum(history.opponent_actions[-1, :])
        threshold = state.current_stock / self.capacity * (self.n_players - 1)
        if state.round_number == self.game_description.n_rounds:
            return Action.D
        elif state.current_stock <= self.n_players:
            return Action.C
        return Action.D if prev_defectors >= threshold else Action.C

class Strategy_EXPLOITATIVE_424(BaseStrategy):
    """
    The Adaptive Exploiter strategy takes advantage of opponents who cooperate or are slow to adapt.
    It balances short-term gains with long-term sustainability and adaptability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        if state.current_stock < 0.75 * self.game_description.capacity:
            return Action.C
        opponent_defected = any((not action for action in history.opponent_actions[-1, :]))
        if opponent_defected:
            return Action.D
        growth_last_round = 2 * (state.current_stock - self.game_description.capacity) * (1 - state.current_stock / self.game_description.capacity)
        if growth_last_round > 0.2 * self.game_description.capacity:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_425(BaseStrategy):
    """
    An exploitative, adaptive strategy that balances short-term payoffs with sustainability concerns.
    
    The strategy starts by cooperating to observe opponents' initial actions and set a baseline for stock consumption.
    Then, it adapts its behavior based on the current stock level and opponents' previous actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_rate = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Determine the action for this round based on the current state and history.
        
        :param state: The current state of the game
        :param history: The history of actions and payoffs (or None if it's the first round)
        :return: The chosen action (either Action.C or Action.D)
        """
        if state.round_number == 0:
            return Action.C
        current_stock_ratio = state.current_stock / self.game_description.capacity
        if history is not None and len(history.opponent_actions) > 0:
            opponents_defected = sum(~history.opponent_actions[-1, :])
            if opponents_defected / self.game_description.n_players > 0.6:
                self.cooperation_rate += 0.1
            elif opponents_defected / self.game_description.n_players < 0.4:
                self.cooperation_rate -= 0.1
        if state.round_number == self.game_description.n_rounds - 1 or current_stock_ratio < 0.2:
            return Action.C
        if current_stock_ratio > 0.75 or random.random() > self.cooperation_rate:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_426(BaseStrategy):
    """
    Exploitative Strategy: "Adaptive Stock Raider"
    
    This strategy balances short-term gains with long-term sustainability by adapting to opponents' actions and current stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock > 0.75 * self.game_description.capacity else Action.D
        prev_opponent_coop_rate = sum(history.opponent_actions[-1, :]) / self.game_description.n_players
        if prev_opponent_coop_rate >= 0.5:
            return Action.C
        elif state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        elif sum(history.opponent_actions[-1, :]) > 0.75 * self.game_description.n_players:
            return Action.D
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_427(BaseStrategy):
    """
    A robust and exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        opponents_payoffs = np.mean(history.opponent_payoffs[-1, :])
        if not history.opponent_actions[-1, :].any():
            return Action.D
        consistent_cooperator = history.my_payoffs.shape[0] > self.game_description.n_rounds // 2 and np.mean(history.opponent_actions[:, :].any(axis=1)) >= 0.5
        if consistent_cooperator:
            return Action.C
        if current_stock > 0.75 * self.capacity:
            return Action.D
        elif 0.5 <= current_stock / self.capacity <= 0.75:
            if opponents_payoffs > history.my_payoffs[-1]:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_428(BaseStrategy):
    """
    Adaptive Stock Harvester strategy for the Common Pool Resource Game.
    This strategy aims to maximize its total payoff by adaptively responding 
    to the game state and history, while exploiting opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.D if state.current_stock >= self.game_description.capacity / 2 else Action.C
        avg_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
        if state.current_stock <= self.game_description.capacity / 4:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if avg_opponent_payoff >= state.current_stock / (2 * self.game_description.n_players):
            return Action.D
        elif state.current_stock > self.game_description.capacity / 4:
            return Action.C if avg_opponent_payoff < state.current_stock / (2 * self.game_description.n_players) else Action.D
        return Action.C

class Strategy_EXPLOITATIVE_429(BaseStrategy):
    """
    This strategy adaptively responds to the game state and history, 
    while being robust to various opponent behaviors. It aims to balance 
    short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def calculate_average_cooperation_rate(self, opponent_history: NDArray[np.bool_], num_rounds: int) -> float:
        """
        Calculate average cooperation rate over last 'num_rounds' rounds.
        
        Args:
            opponent_history (NDArray[np.bool_]): Opponent's actions history.
            num_rounds (int): Number of rounds to consider.

        Returns:
            float: Average cooperation rate.
        """
        coop_count = sum((1 for action in opponent_history[-num_rounds:] if action))
        return coop_count / num_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        stock_level = state.current_stock / self.game_description.capacity
        opponent_coop_rates = [self.calculate_average_cooperation_rate(opponent_history, min(3, state.round_number)) for opponent_history in history.opponent_actions.T]
        if stock_level > 0.75:
            return Action.D
        elif stock_level >= 0.5 and stock_level <= 0.75:
            coop_prob = 0
            for rate in opponent_coop_rates:
                if rate > 0.7:
                    coop_prob += 0.1
                elif rate < 0.3:
                    coop_prob -= 0.2
            return Action.C if random.random() < coop_prob else Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_430(BaseStrategy):
    """
    Exploitative strategy that adapts to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.75 * game_description.capacity
        self.sustainability_threshold = 0.5 * game_description.capacity
        self.previous_stock_level = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        num_cooperators = sum((1 for action in opponent_actions if action))
        if self.previous_stock_level is not None and state.current_stock - self.previous_stock_level < -0.25 * self.game_description.capacity:
            return Action.C
        if num_cooperators > self.game_description.n_players / 2:
            return Action.C
        if state.current_stock < self.sustainability_threshold:
            return Action.D
        elif state.current_stock > self.cooperation_threshold:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        self.previous_stock_level = state.current_stock

class Strategy_EXPLOITATIVE_431(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behaviors in the Common Pool Resource Game.
    Cooperates initially, then uses a mixed strategy based on opponent cooperation ratio and stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.5 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        elif state.current_stock < self.stock_threshold:
            return Action.D
        else:
            opponent_actions = history.opponent_actions[-1, :]
            cooperative_opponents = np.sum(opponent_actions)
            cr = cooperative_opponents / self.game_description.n_players
            if cr > 0.5 or state.round_number == self.game_description.n_rounds - 1:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_432(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behavior and stock dynamics.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_low_threshold = 0.3 * game_description.capacity
        self.stock_high_threshold = 0.7 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_defection_rate = self.calculate_opponent_defection_rate(history)
        if state.current_stock <= self.stock_low_threshold:
            return Action.C
        elif state.current_stock >= self.stock_high_threshold:
            return Action.D
        if opponent_defection_rate > 0.6:
            return Action.C
        else:
            return Action.D

    def calculate_opponent_defection_rate(self, history: PlayerHistory) -> float:
        defect_count = sum((1 for round_actions in history.opponent_actions if not np.all(round_actions)))
        total_rounds = len(history.my_payoffs)
        return defect_count / total_rounds

class Strategy_EXPLOITATIVE_433(BaseStrategy):
    """
    An exploitative strategy that adapts to the current stock level and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        stock_threshold = 0.75 * capacity
        mid_threshold = 0.5 * capacity
        low_threshold = 0.25 * capacity
        current_stock = state.current_stock
        if current_stock > stock_threshold:
            return Action.D
        if current_stock >= mid_threshold and current_stock <= stock_threshold:
            opponents_actions = history.opponent_actions[-1, :]
            opponents_cooperation_rate = sum(opponents_actions) / len(opponents_actions)
            if opponents_cooperation_rate > 0.6:
                return Action.C
            elif opponents_cooperation_rate < 0.4:
                return Action.D
        if current_stock < low_threshold or state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_436(BaseStrategy):
    """
    Exploitative strategy "Adaptive Stock Raider" for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n = game_description.n_players
        self.r = game_description.n_rounds
        self.capacity = game_description.capacity

    def get_consumption(self, action: bool) -> float:
        return self.capacity / (2 * self.n) if action else self.capacity / self.n

    def calculate_average_consumption(self, history: PlayerHistory) -> float:
        total_consumption = sum([self.get_consumption(action) for action in history.my_actions]) + sum([self.get_consumption(action) for actions in history.opponent_actions.T for action in actions])
        return total_consumption / ((self.n + 1) * len(history.my_actions))

    def get_current_stock_level(self, state: CommonPoolState, history: PlayerHistory) -> float:
        current_stock = self.capacity
        for i in range(len(history.my_actions)):
            consumption_my = self.get_consumption(history.my_actions[i])
            consumption_opponents = sum([self.get_consumption(action) for action in history.opponent_actions[i]])
            total_consumption = consumption_my + consumption_opponents
            remaining_stock = current_stock - total_consumption
            growth = 2 * remaining_stock * (1 - remaining_stock / self.capacity)
            current_stock = min(remaining_stock + growth, self.capacity)
        return current_stock

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_consumption = self.calculate_average_consumption(history)
        S = self.get_current_stock_level(state, history)
        if avg_consumption > 0.75 * self.capacity / self.n:
            return Action.D
        elif S < 0.5 * self.capacity:
            return Action.C
        else:
            p = S / self.capacity * (self.r - state.round_number) / self.r
            if random.random() < p:
                return Action.D
            else:
                return Action.C
        if state.round_number == self.r - 1:
            return Action.D

class Strategy_EXPLOITATIVE_437(BaseStrategy):
    """
    An adaptive exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.D
        previous_round_defectors = self.n_players - np.sum(history.opponent_actions[-1, :])
        defect_probability_reactive = previous_round_defectors / self.n_players
        action_reactive = random.random() < defect_probability_reactive
        stock_level = state.current_stock
        if stock_level <= self.capacity / 2:
            action_stock = False
        elif stock_level > self.capacity / 2:
            excess_stock = stock_level - self.capacity / 2
            defect_probability_stock = excess_stock / (self.capacity / 2)
            action_stock = random.random() < defect_probability_stock
        if previous_round_defectors == 0 or history.my_actions[-1] is True:
            action = not action_stock
        else:
            action = action_reactive or action_stock
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock_level == 0:
            return Action.C
        return Action.C if not action else Action.D

class Strategy_EXPLOITATIVE_438(BaseStrategy):
    """
    The Adaptive Stock Raider (ASR) is a dynamic strategy that balances short-term gains with long-term sustainability.
    It monitors the game's state and history to adjust its behavior, exploiting opponents' weaknesses while protecting itself from over-exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        opponent_defected = False
        for opponent_action in history.opponent_actions[-1, :]:
            if not opponent_action:
                opponent_defected = True
        avg_opponent_consumption = np.mean(history.my_payoffs[:state.round_number]) / self.game_description.capacity * self.n_players
        optimal_sustainable_consumption = self.capacity / (2 * self.n_players)
        if state.current_stock > 0.75 * self.capacity:
            return Action.C
        elif opponent_defected:
            return Action.D
        elif state.current_stock < 0.25 * self.capacity:
            return Action.C
        elif avg_opponent_consumption > 0.5 * optimal_sustainable_consumption:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_439(BaseStrategy):
    """
    A hybrid strategy that combines reactive and proactive elements to maximize payoff while ensuring sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        prev_round_outcomes = history.opponent_actions[-1, :]
        opponents_defected = np.any(prev_round_outcomes == False)
        if opponents_defected:
            return Action.D
        elif np.all(prev_round_outcomes == True):
            return Action.C
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_440(BaseStrategy):
    """
    An adaptive strategy that balances short-term gains with long-term sustainability,
    exploiting opponents' behaviors while minimizing the risk of over-consumption.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponents_defection_rate = 0.0
        self.average_opponent_payoff = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_actions = history.opponent_actions[-1, :]
        opponents_defections = sum(1 - opponents_actions)
        self.opponents_defection_rate = opponents_defections / self.game_description.n_players
        if history.my_payoffs.shape[0] > 1:
            recent_opponent_payoffs = np.mean(history.opponent_payoffs[-2:, :], axis=0)
            self.average_opponent_payoff = np.mean(recent_opponent_payoffs)
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.D
        elif self.opponents_defection_rate > 0.5:
            return Action.D
        own_payoff = history.my_payoffs[-1]
        if own_payoff < self.average_opponent_payoff and state.round_number < self.game_description.n_rounds - 1:
            if history.my_actions[-1]:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_441(BaseStrategy):
    """
    The Adaptive Stock Raider is a dynamic, self-interested strategy designed to exploit 
    a wide range of opponent behaviors while navigating the Common Pool Resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock >= self.game_description.capacity * 0.75 else Action.D
        opponent_actions = history.opponent_actions[-1, :]
        avg_coop_rate = np.mean(opponent_actions)
        total_consumption_prev = sum(self.get_consumption(opponent_actions, state.current_stock))
        if state.current_stock >= self.game_description.capacity * 0.5:
            if avg_coop_rate > 0.5 and total_consumption_prev < state.current_stock / self.game_description.n_players:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

    @staticmethod
    def get_consumption(actions: NDArray[np.bool_], current_stock: float) -> NDArray[np.float64]:
        n_players = len(actions)
        consume_rate = np.where(actions, 0.5 / n_players, 1.0 / n_players)
        return current_stock * consume_rate

class Strategy_EXPLOITATIVE_442(BaseStrategy):
    """
    This strategy adapts to various opponent behaviors and exploits their actions while being robust.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_payoffs_avg = np.mean(history.opponent_payoffs[-1])
        stock_depletion_rate = (self.game_description.capacity - state.current_stock) / self.game_description.capacity
        if opponent_payoffs_avg >= 0.5 * (self.game_description.capacity / self.game_description.n_players):
            theta = 0.7
        else:
            theta = 0.3
        if stock_depletion_rate >= theta or state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_443(BaseStrategy):
    """
    The ASR strategy aims to maximize its total payoff by adaptively exploiting the common pool resource, 
    taking into account the game parameters, state, and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.tau = 0.5
        self.prev_payoff = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock < self.game_description.n_players:
            return Action.C
        if state.current_stock >= self.game_description.capacity - self.game_description.n_players:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        opponent_cooperators = sum(history.opponent_actions[-1, :])
        if opponent_cooperators >= self.game_description.n_players // 2:
            self.tau += 0.05
        else:
            self.tau -= 0.05
        self.tau = max(0, min(self.tau, 1))
        if state.current_stock >= self.tau * self.game_description.capacity:
            my_action = Action.C
        else:
            my_action = Action.D
        if history.my_payoffs[-1] < state.current_stock / self.game_description.n_players and self.prev_payoff is not None:
            my_action = Action.D
            self.prev_payoff = history.my_payoffs[-1]
        else:
            self.prev_payoff = history.my_payoffs[-1]
        return my_action

class Strategy_EXPLOITATIVE_444(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_trend = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if self.game_description.n_players > 6:
                return Action.C
            else:
                return Action.D
        S = state.current_stock
        if S < 0.5 * self.game_description.capacity:
            return Action.C
        avg_payoff_defectors, avg_payoff_cooperators = self._calculate_avg_payoffs(history)
        if avg_payoff_defectors > avg_payoff_cooperators:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

    def _calculate_avg_payoffs(self, history: PlayerHistory) -> tuple[float, float]:
        """Calculate average payoffs of cooperators and defectors in the previous round."""
        prev_round = history.my_actions.shape[0] - 1
        my_prev_action = history.my_actions[prev_round]
        opponent_prev_actions = history.opponent_actions[prev_round, :]
        coop_opponents = opponent_prev_actions == True
        defect_opponents = ~coop_opponents
        avg_payoff_cooperators = np.mean(history.opponent_payoffs[prev_round, coop_opponents])
        avg_payoff_defectors = np.mean(history.opponent_payoffs[prev_round, defect_opponents])
        return (avg_payoff_defectors, avg_payoff_cooperators)

class Strategy_EXPLOITATIVE_445(BaseStrategy):
    """
    An exploitative strategy that balances short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        T = self.capacity * (1 - 1 / (2 * self.n_players))
        avg_payoff = np.mean(history.opponent_payoffs[-1, :])
        max_payoff = state.current_stock / self.n_players
        if avg_payoff > 0.25 * max_payoff:
            asr_action = Action.D
        elif state.current_stock < 0.2 * self.capacity:
            asr_action = Action.C
        elif state.current_stock >= T:
            asr_action = Action.D
        else:
            asr_action = Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return asr_action

class Strategy_EXPLOITATIVE_446(BaseStrategy):
    """
    Exploitative strategy that adapts to the current state and history of opponent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_rounds = self.game_description.n_rounds
        stock = state.current_stock
        opponent_actions = history.opponent_actions
        if stock < self.capacity / 2:
            return Action.D
        else:
            prev_defections = np.sum(opponent_actions[-n_rounds // 2:, :], axis=0)
            most_defective_opponent = np.max(prev_defections)
            if most_defective_opponent >= self.n_players / 2:
                return Action.C
            else:
                D_count_i = prev_defections
                max_D_count_i = np.max(D_count_i)
                if max_D_count_i > self.n_players / 2:
                    return Action.D
                elif state.round_number == n_rounds - 1:
                    return Action.D
                else:
                    return Action.D

class Strategy_EXPLOITATIVE_447(BaseStrategy):
    """
    Adaptive Exploiter strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_behavior = {Action.C: 0.5, Action.D: 0.5}
        self.average_opponent_payoff = 0
        self.cumulative_payoff = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        average_opponent_payoffs = np.mean(history.opponent_payoffs[:state.round_number, :], axis=1)
        self.average_opponent_payoff = np.mean(average_opponent_payoffs)
        opponent_actions_last_round = history.opponent_actions[state.round_number - 1]
        opponents_cooperation_rate = np.sum(opponent_actions_last_round == Action.C) / len(opponent_actions_last_round)
        if self.average_opponent_payoff >= state.current_stock / (2 * self.game_description.n_players):
            action = Action.C
        else:
            action = Action.D
        if opponents_cooperation_rate > 0.7:
            self.opponent_behavior[Action.C] += 0.1
            self.opponent_behavior[Action.D] -= 0.1
        elif opponents_cooperation_rate < 0.3:
            self.opponent_behavior[Action.C] -= 0.1
            self.opponent_behavior[Action.D] += 0.1
        if state.current_stock < self.game_description.capacity / 2:
            self.opponent_behavior[Action.C] -= 0.1
            self.opponent_behavior[Action.D] += 0.1
        elif self.cumulative_payoff > self.average_opponent_payoff * 1.1:
            self.opponent_behavior[Action.C] += 0.1
            self.opponent_behavior[Action.D] -= 0.1
        total_probability = self.opponent_behavior[Action.C] + self.opponent_behavior[Action.D]
        if total_probability > 1:
            self.opponent_behavior[Action.C] /= total_probability
            self.opponent_behavior[Action.D] /= total_probability
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        action = random.choices(list(self.opponent_behavior.keys()), weights=list(self.opponent_behavior.values()))[0]
        self.cumulative_payoff += state.current_stock / (2 * self.game_description.n_players) if action == Action.C else state.current_stock / self.game_description.n_players
        return action

class Strategy_EXPLOITATIVE_448(BaseStrategy):
    """
    Exploitative Strategy: "Adaptive Stock Raider"

    Adapts to the game's state and opponents' behavior by balancing short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif 1 < state.round_number <= self.game_description.n_rounds // 2:
            stock_ratio = state.current_stock / self.capacity
            if stock_ratio > 0.75:
                return Action.D
            elif 0.5 <= stock_ratio <= 0.75:
                return Action.C
            else:
                return Action.C
        elif self.game_description.n_rounds // 2 < state.round_number <= 3 * self.game_description.n_rounds // 4:
            opponent_cooperation_rates = np.mean(history.opponent_actions, axis=0) if history else None
            if opponent_cooperation_rates is not None and np.mean(opponent_cooperation_rates) > 0.6:
                return Action.D
            else:
                return Action.C
        elif 3 * self.game_description.n_rounds // 4 < state.round_number <= self.game_description.n_rounds:
            if state.current_stock > 0.5 * self.capacity:
                return Action.D
            else:
                return Action.C
        elif state.round_number == self.game_description.n_rounds:
            if state.current_stock >= 0.1 * self.capacity:
                return Action.D
            else:
                return Action.C
        if state.current_stock < 0.1 * self.capacity:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_449(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource game that adaptively exploits 
    the common pool resource while considering the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.actions_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.stock_history.append(state.current_stock)
        capacity_thresholds = [self.game_description.capacity * 0.75, self.game_description.capacity * 0.5]
        if state.current_stock > capacity_thresholds[0]:
            action = Action.D
        elif state.current_stock >= capacity_thresholds[1]:
            action = Action.C
        else:
            action = Action.D
        avg_depletion_rate = self.calculate_avg_depletion_rate(self.stock_history)
        if avg_depletion_rate > 0.3 * self.game_description.capacity:
            action = Action.C
        detected_defector = self.detect_consistent_defector(history.opponent_actions)
        if detected_defector:
            action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        self.actions_history.append(action)
        return action

    def calculate_avg_depletion_rate(self, stock_history):
        depletion_rates = []
        for i in range(1, len(stock_history)):
            depletion_rate = (stock_history[i - 1] - stock_history[i]) / self.game_description.capacity
            depletion_rates.append(depletion_rate)
        if len(depletion_rates) < 3:
            return sum(depletion_rates) / max(len(depletion_rates), 1)
        return sum(depletion_rates[-3:]) / min(3, len(depletion_rates))

    def detect_consistent_defector(self, opponent_actions):
        consistent_defectors = []
        for player in range(opponent_actions.shape[1]):
            consecutive_defections = 0
            for i in range(len(opponent_actions)):
                if not opponent_actions[i, player]:
                    consecutive_defections += 1
                else:
                    break
            if consecutive_defections >= min(3, len(opponent_actions)):
                consistent_defectors.append(player)
        return len(consistent_defectors) > 0

class Strategy_EXPLOITATIVE_450(BaseStrategy):
    """
    This strategy exploits the Common Pool Resource game's structure by adapting to opponents' behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock_level = state.current_stock / self.game_description.capacity
        most_recent_opponent_actions = history.opponent_actions[-1, :]
        if len(most_recent_opponent_actions) > 0 and sum((1 for action in most_recent_opponent_actions if not action)) > len(history.my_payoffs) // 2:
            return Action.C
        elif current_stock_level < 0.25 or current_stock_level > 0.75:
            return Action.D if current_stock_level > 0.5 else Action.C
        else:
            if len(history.my_payoffs) < 3:
                return Action.D
            opponent_cooperators = sum((1 for action in most_recent_opponent_actions if action))
            if opponent_cooperators > len(history.my_payoffs) // 2:
                return Action.D
            else:
                return Action.C
        if state.current_stock < 0.1 * self.game_description.capacity or state.current_stock > 0.9 * self.game_description.capacity:
            return self.update_strategy_with_thresholds(state.current_stock, current_stock_level)
        return Action.C

    def update_strategy_with_thresholds(self, stock: float, current_stock_level: float) -> Action:
        if stock < 0.1 * self.game_description.capacity:
            return Action.C
        elif stock > 0.9 * self.game_description.capacity:
            return Action.D

class Strategy_EXPLOITATIVE_451(BaseStrategy):
    """
    Exploitative strategy that adapts to the game's dynamic state and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        stock = state.current_stock
        if t == 0 or history is None:
            return Action.C
        opponents_history = history.opponent_actions
        prev_round_opponents_defected = np.any(opponents_history[-1, :] == False)
        prev_round_consumption = self.n_players / (2 * self.n_players) if np.all(opponents_history[-1, :] == True) else sum((1 / self.n_players if opponent else 1 / (2 * self.n_players) for opponent in opponents_history[-1, :]))
        if stock >= 0.75 * self.capacity:
            return Action.D if prev_round_opponents_defected else Action.C
        elif 0.25 * self.capacity <= stock < 0.75 * self.capacity:
            if prev_round_consumption > 0.5 * self.capacity:
                return Action.C
            else:
                return Action.D if prev_round_opponents_defected else Action.C
        else:
            return Action.D
        if t == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_452(BaseStrategy):
    """
    Exploitative strategy that adaptively responds to the game state and opponent behavior.
    Balances short-term gains with long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock = game_description.capacity
        self.opponent_cooperation_rates = [0.5] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_opponent_coop_rate = np.mean(history.opponent_actions[-1, :]) if history else 0.5
        self._update_opponent_cooperation_rates(avg_opponent_coop_rate)
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.D
        elif state.current_stock >= 0.5 * self.game_description.capacity and avg_opponent_coop_rate < 0.5:
            return Action.C if random.random() < 0.6 else Action.D
        else:
            return Action.C

    def _update_opponent_cooperation_rates(self, avg_opponent_coop_rate: float) -> None:
        for i in range(self.game_description.n_players):
            self.opponent_cooperation_rates[i] += (1 - self.opponent_cooperation_rates[i]) * 0.1

class Strategy_EXPLOITATIVE_453(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behavior and current stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_behavior = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        previous_stock = self.get_previous_stock_level(history)
        cooperators_last_round = self.count_cooperators(history.opponent_actions[-1])
        stock_trend = self.analyze_stock_trend(self.get_recent_stock_levels(history))
        if previous_stock > 0.75 * self.game_description.capacity:
            return Action.C if cooperators_last_round >= self.game_description.n_players / 2 else Action.D
        elif 0.25 * self.game_description.capacity <= previous_stock < 0.75 * self.game_description.capacity:
            return Action.D
        elif previous_stock < 0.25 * self.game_description.capacity:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return random.choice([Action.C, Action.D])

    def get_previous_stock_level(self, history: PlayerHistory) -> float:
        if len(history.my_payoffs) == 0:
            return self.game_description.capacity
        else:
            return max(0.0, self.game_description.capacity - sum(history.my_payoffs[-1:]))

    def count_cooperators(self, opponent_actions: NDArray[np.bool_]) -> int:
        return sum(opponent_actions)

    def analyze_stock_trend(self, recent_stocks: list[float]) -> float:
        if len(recent_stocks) < 3:
            return 0.0
        else:
            return (recent_stocks[-1] - recent_stocks[-3]) / (self.game_description.capacity * 2)

    def get_recent_stock_levels(self, history: PlayerHistory) -> list[float]:
        if len(history.my_payoffs) == 0:
            return [self.game_description.capacity]
        else:
            stocks = []
            remaining_stock = self.game_description.capacity
            for payoff in reversed(history.my_payoffs):
                remaining_stock -= payoff * (2 / self.game_description.n_players)
                stocks.append(remaining_stock)
            return list(reversed(stocks))[:5]

class Strategy_EXPLOITATIVE_454(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game.
    It adapts to opponents' behaviors and adjusts its cooperation threshold,
    aiming to maximize its payoff while minimizing the risk of over-exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.epsilon = 0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        theta = lambda S: S / (2 * self.game_description.capacity)
        prev_actions = history.opponent_actions[-1, :]
        defector_count = sum((1 for a in prev_actions if not a))
        cooperation_threshold = theta(state.current_stock) * self.game_description.n_players
        punishment_prob = 0.8 if any((not a and state.current_stock < self.epsilon * self.game_description.capacity for a in prev_actions)) else 0
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if all(prev_actions):
            return Action.C
        if state.current_stock < self.epsilon * self.game_description.capacity:
            return Action.D
        if defector_count <= cooperation_threshold:
            return Action.C
        else:
            return Action.D if random.random() < max(punishment_prob, 0.5) else Action.C

class Strategy_EXPLOITATIVE_455(BaseStrategy):
    """
    Adaptive Stock Conservation strategy for the Common Pool Resource Game.
    This strategy aims to maximize individual payoffs by exploiting opponents' behaviors while conserving the common pool stock for long-term gains.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.current_stock < 0.75 * self.game_description.capacity:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.D
        opponent_cooperation_rate = np.mean(history.opponent_actions[-1, :])
        if opponent_cooperation_rate == 1.0 and state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        if opponent_cooperation_rate == 0.0 and state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        if opponent_cooperation_rate > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_456(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game.
    
    This strategy aims to maximize individual payoffs by playing Cooperate (C) 
    initially, then adapting based on current stock levels and opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = [game_description.capacity]
        self.opponent_actions = [[] for _ in range(game_description.n_players - 1)]

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_level = self.stock_history[-1] / self.game_description.capacity
        previous_opponent_actions = [opponent_action for opponent_action in self.opponent_actions if opponent_action]
        if stock_level > 0.75:
            return Action.D
        elif 0.5 <= stock_level < 0.75:
            if any(previous_opponent_actions):
                return Action.C if previous_opponent_actions[-1] == [Action.D] else Action.D
            else:
                return Action.D
        else:
            return Action.C

    def update_stock(self, current_stock: float, actions: list[Action]) -> float:
        total_consumption = sum((action.value * current_stock / (2 * self.game_description.n_players) for action in actions))
        stock_after_consumption = current_stock - total_consumption
        growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
        new_stock = min(stock_after_consumption + growth, self.game_description.capacity)
        return new_stock

    def update_opponent_actions(self, opponent_actions: list[list[Action]], new_actions: list[Action]) -> list[list[Action]]:
        for i, action in enumerate(new_actions):
            if i < len(opponent_actions):
                opponent_actions[i].append(action)
        return opponent_actions

class Strategy_EXPLOITATIVE_457(BaseStrategy):
    """
    The Adaptive Stock Raider (ASR) strategy is designed to exploit a wide range of opponent behaviors while adapting to the game's dynamic state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_defection_rates = np.mean(history.opponent_actions, axis=0)
        if state.current_stock < 0.5 * self.capacity:
            return Action.D
        for opponent_defection_rate in opponent_defection_rates:
            if opponent_defection_rate > 0.5:
                return Action.D
            elif opponent_defection_rate < 0.25:
                return Action.C
        recent_payoff_average = np.mean(history.my_payoffs[-3:]) if len(history.my_payoffs) >= 3 else np.mean(history.my_payoffs)
        max_payoff = self.capacity / (2 * self.game_description.n_players)
        if recent_payoff_average < 0.5 * max_payoff:
            return Action.D
        if state.round_number > self.game_description.n_rounds - 2 and state.current_stock > 0.25 * self.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_458(BaseStrategy):
    """
    Exploitative strategy that adapts to changing game conditions and stock levels.
    Balances cooperation and defection based on current stock level, opponent behavior, and round number.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if self.game_description.capacity > 2 * self.game_description.n_players else Action.D
        opponents_defected = any((not action for action in history.opponent_actions[-1]))
        opponents_cooperated = any((action for action in history.opponent_actions[-1]))
        if state.current_stock >= 0.5 * self.game_description.capacity:
            cooperate_probability = min(1, (self.game_description.n_players - 1) / self.game_description.n_players) if opponents_defected else 0
            return Action.C if random.random() < cooperate_probability else Action.D
        elif state.current_stock < 0.5 * self.game_description.capacity:
            cooperate_probability = max(0, 1 - (self.game_description.n_rounds - state.round_number) / (self.game_description.n_rounds - 1)) if opponents_cooperated else 0
            return Action.C if random.random() < cooperate_probability else Action.D
        elif state.current_stock <= 0:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_459(BaseStrategy):
    """
    A robust and exploitative strategy for the Common Pool Resource Game.
    Balances cooperation and defection based on current stock level, opponent behavior, and game history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.exploitation_threshold = 0.75 * game_description.capacity
        self.conservation_threshold = 0.25 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.my_actions) == 0):
            return Action.C
        opponent_payoffs = np.mean(history.opponent_payoffs[-1])
        payoff_ratio = opponent_payoffs / (self.game_description.capacity / self.game_description.n_players)
        if state.current_stock >= self.exploitation_threshold and payoff_ratio < 0.5:
            return Action.D
        elif state.current_stock <= self.conservation_threshold or (payoff_ratio >= 0.5 and state.current_stock > self.conservation_threshold):
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 2 * self.game_description.n_players:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_460(BaseStrategy):
    """
    The Adaptive Stock Raider strategy aims to maximize its own payoff by adaptively responding 
    to the game state and history of opponent actions in a Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        opponent_history = history.opponent_actions if history else []
        n_opponents = self.game_description.n_players - 1
        avg_cooperation_rate = self.calculate_avg_cooperation_rate(opponent_history)
        growth_rate = self.calculate_growth_rate(state.current_stock, self.game_description.capacity)
        if state.round_number < 5:
            return Action.C if state.current_stock > 0.75 * self.game_description.capacity else Action.D
        elif 5 <= state.round_number <= 10:
            return Action.C if avg_cooperation_rate > 0.6 else Action.D
        elif state.current_stock < 0.5 * self.game_description.capacity or growth_rate < 20:
            return Action.C
        else:
            return Action.D
        if self.opponent_cooperated_twice(opponent_history):
            return Action.C
        elif self.opponent_defected_twice(opponent_history):
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.1 * self.game_description.capacity:
            return Action.C

    def calculate_avg_cooperation_rate(self, opponent_history):
        last_three_rounds = opponent_history[-3:, :]
        if len(last_three_rounds) == 0:
            return 0.5
        return np.mean(np.any(last_three_rounds, axis=1))

    def calculate_growth_rate(self, current_stock, capacity):
        remaining_stock = max(current_stock - self.game_description.n_players * (current_stock / (2 * self.game_description.n_players)), 0)
        growth = 2 * remaining_stock * (1 - remaining_stock / capacity)
        new_stock = min(remaining_stock + growth, capacity)
        return (new_stock - current_stock) / current_stock if current_stock != 0 else 0

    def opponent_cooperated_twice(self, opponent_history):
        last_two_rounds = opponent_history[-2:, :]
        for i in range(last_two_rounds.shape[1]):
            if np.all(last_two_rounds[:, i]):
                return True
        return False

    def opponent_defected_twice(self, opponent_history):
        last_two_rounds = opponent_history[-2:, :]
        for i in range(last_two_rounds.shape[1]):
            if not np.any(last_two_rounds[:, i]):
                return True
        return False

class Strategy_EXPLOITATIVE_461(BaseStrategy):
    """
    Adaptive Stock Depletion Exploiter (ASDE) strategy for Common Pool Resource Game.
    
    This strategy cooperates in the first round, then uses a dynamic threshold to decide 
    whether to cooperate or defect based on the current stock level. The cooperation 
    threshold is adjusted based on the average stock depletion rate over recent rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.75
        self.avg_depletion_rate_window_size = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None or len(history.my_payoffs) < self.avg_depletion_rate_window_size:
            return Action.D
        avg_depletion_rate = self.calculate_avg_depletion_rate(history)
        self.threshold = self.adjust_threshold(avg_depletion_rate)
        if state.current_stock > self.threshold * self.game_description.capacity:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.C

    def calculate_avg_depletion_rate(self, history: PlayerHistory) -> float:
        """
        Calculate average stock depletion rate over recent rounds.
        
        Args:
            history (PlayerHistory): Player's history of actions and payoffs.

        Returns:
            float: Average stock depletion rate.
        """
        depletion_rates = []
        for i in range(1, min(self.avg_depletion_rate_window_size + 1, len(history.my_payoffs))):
            depletion_rate = (history.my_payoffs[i - 1] + np.sum(history.opponent_payoffs[i - 1, :])) / self.game_description.capacity
            depletion_rates.append(depletion_rate)
        return np.mean(depletion_rates)

    def adjust_threshold(self, avg_depletion_rate: float) -> float:
        """
        Adjust cooperation threshold based on average stock depletion rate.
        
        Args:
            avg_depletion_rate (float): Average stock depletion rate.

        Returns:
            float: Adjusted cooperation threshold.
        """
        if avg_depletion_rate > 0.2 * self.game_description.capacity / self.game_description.n_players:
            return max(0, self.threshold - 0.05)
        else:
            return min(1, self.threshold + 0.05)

class Strategy_EXPLOITATIVE_462(BaseStrategy):
    """
    Exploitative strategy "Adaptive Stock Raider" that adapts to the dynamic state of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        previous_consumption = sum((self.game_description.n_players * (action / self.game_description.n_players) for action in history.my_actions[:-1] + [False]))
        if state.current_stock > 0.75 * self.game_description.capacity:
            if previous_consumption < 0.5 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C
        p = state.current_stock / self.game_description.capacity
        if random.random() < p:
            return Action.D
        else:
            return Action.C
        if state.round_number > self.game_description.n_rounds - 2 and state.current_stock <= 0.25 * self.game_description.capacity or state.current_stock == 0:
            return Action.D

class Strategy_EXPLOITATIVE_463(BaseStrategy):
    """
    Exploitative strategy designed to adapt to opponent behavior and maximize individual payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < self.n_players - 1:
            return Action.D
        if history is None:
            return Action.D
        avg_depletion_rate = np.mean(history.opponent_payoffs) / (state.round_number - 1)
        if avg_depletion_rate > 0.5:
            opponent_behavior = 'defecting'
        else:
            opponent_behavior = 'cooperating'
        if state.current_stock < 0.25 * self.capacity:
            return Action.C
        elif state.current_stock > 0.75 * self.capacity:
            return Action.D
        if opponent_behavior == 'defecting':
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_464(BaseStrategy):
    """
    Exploitative strategy that adapts to opponent behavior and game state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_consumption_ratio = self._calculate_total_consumption_ratio(history)
        opponent_cooperation_rate = self._estimate_opponent_cooperation(history)
        if state.current_stock >= self.capacity / 2 and total_consumption_ratio > 0.25:
            return Action.D
        elif state.current_stock < self.capacity / 2 and total_consumption_ratio < 0.25:
            return Action.C
        elif state.round_number >= self.game_description.n_rounds - 1:
            return Action.D
        elif opponent_cooperation_rate > 0.5:
            return Action.C
        else:
            return Action.D

    def _calculate_total_consumption_ratio(self, history: PlayerHistory) -> float:
        previous_my_action = history.my_actions[-1]
        previous_opponent_actions = history.opponent_actions[-1, :]
        consumption_per_player = self.capacity / (2 * self.game_description.n_players)
        if previous_my_action:
            my_consumption = consumption_per_player
        else:
            my_consumption = 2 * consumption_per_player
        opponent_consumptions = np.where(previous_opponent_actions, consumption_per_player, 2 * consumption_per_player)
        total_consumption = my_consumption + np.sum(opponent_consumptions)
        return total_consumption / self.capacity

    def _estimate_opponent_cooperation(self, history: PlayerHistory) -> float:
        previous_opponent_actions = history.opponent_actions[-1, :]
        cooperation_count = np.sum(previous_opponent_actions)
        return cooperation_count / (self.game_description.n_players - 1)

class Strategy_EXPLOITATIVE_465(BaseStrategy):
    """
    The Adaptive Predator strategy exploits opponents' behaviors while being robust and adaptive to various playing styles.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.previous_payoffs = []

    def calculate_average_payoff(self, payoffs: list[float]) -> float:
        if len(payoffs) == 0:
            return 0.0
        return sum(payoffs[-3:]) / min(3, len(payoffs))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        previous_payoff = history.my_payoffs[-1]
        self.previous_payoffs.append(previous_payoff)
        avg_payoff_last_3_rounds = self.calculate_average_payoff(self.previous_payoffs)
        theoretical_max_payoff = self.capacity / (2 * self.n_players)
        if current_stock > 0.75 * self.capacity:
            return Action.D
        elif 0.25 * self.capacity <= current_stock <= 0.75 * self.capacity:
            if avg_payoff_last_3_rounds > theoretical_max_payoff:
                return Action.C
            else:
                return Action.D
        elif current_stock < 0.25 * self.capacity or current_stock < 0.1 * self.capacity:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_466(BaseStrategy):
    """
    An adaptive strategy that balances short-term gain with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.D
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if current_stock > 0.75 * capacity:
            return Action.C
        elif 0.25 * capacity <= current_stock <= 0.75 * capacity:
            return Action.D
        else:
            return Action.C
        opponent_actions = history.opponent_actions
        recent_rounds_count = min(5, state.round_number + 1)
        most_recent_opponent_actions = np.sum(opponent_actions[-recent_rounds_count:], axis=0)
        cooperate_ratio = most_recent_opponent_actions / recent_rounds_count
        if np.mean(cooperate_ratio) > 0.6:
            return Action.D
        elif np.mean(cooperate_ratio) < 0.4:
            return Action.C
        recent_stock_levels = [current_stock]
        for i in range(min(5, state.round_number + 1)):
            if history.my_payoffs[i] > 0:
                previous_stock_level = capacity - history.my_payoffs[i] * self.game_description.n_players
                recent_stock_levels.append(previous_stock_level)
        stock_increasing_or_stable = all((recent_stock_levels[i] <= recent_stock_levels[i + 1] for i in range(len(recent_stock_levels) - 1)))
        if stock_increasing_or_stable:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_467(BaseStrategy):
    """
    An exploitative strategy that aims to maximize individual payoff by adaptively responding 
    to the game state and opponents' behavior while prioritizing self-interest.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def calculate_expected_growth(self, current_stock: float, history: PlayerHistory) -> float:
        """
        Calculate the expected growth for the next round based on the current stock level and 
        previous rounds' consumption.
        
        Args:
            current_stock (float): The current stock level.
            history (PlayerHistory): The player's history.
            
        Returns:
            float: The expected growth for the next round.
        """
        total_consumption = sum(history.opponent_payoffs[-1, :]) + history.my_payoffs[-1]
        remaining_stock = current_stock - total_consumption
        expected_growth = 2 * remaining_stock * (1 - remaining_stock / self.game_description.capacity)
        return expected_growth

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decide an action based on the game state and player's history.
        
        Args:
            state (CommonPoolState): The current game state.
            history (PlayerHistory): The player's history.
            
        Returns:
            Action: The chosen action.
        """
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        num_defectors = sum((not action for action in history.opponent_actions[-1, :]))
        if num_defectors >= self.game_description.n_players // 2:
            return Action.D
        expected_growth = self.calculate_expected_growth(state.current_stock, history)
        if expected_growth < 0.25 * self.game_description.capacity:
            return Action.D
        if state.round_number >= self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_468(BaseStrategy):
    """
    A dynamic, exploitative strategy that adapts to the game's state and history 
    to maximize its payoff. It balances cooperation and defection to maintain a healthy 
    stock level while taking advantage of opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.max_possible_payoff = game_description.capacity / (2 * game_description.n_players)
        self.total_cooperation_payoff = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        opponents_defected = np.any(~history.opponent_actions[-1, :])
        if opponents_defected:
            return Action.D
        growth_rate = (state.current_stock - history.my_payoffs[-1]) / state.current_stock * 100
        if state.current_stock < 0.5 * self.game_description.capacity and growth_rate > 20:
            return Action.C
        self.total_cooperation_payoff += history.my_payoffs[-1]
        if self.total_cooperation_payoff < 0.75 * (self.max_possible_payoff * state.round_number):
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_469(BaseStrategy):
    """
    Adaptive Exploiter strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.C_count = 0
        self.D_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None:
            self.C_count = sum(history.opponent_actions[-1, :])
            self.D_count = len(history.opponent_actions[-1, :]) - self.C_count
        capacity = self.game_description.capacity
        stock_ratio = state.current_stock / capacity
        if state.round_number < 5:
            if stock_ratio > 0.75:
                return Action.D
            elif 0.5 <= stock_ratio <= 0.75:
                return Action.C
            else:
                return Action.D
        elif 5 <= state.round_number < self.game_description.n_rounds // 2:
            if self.C_count > self.D_count:
                return Action.C
            else:
                return Action.D
        elif stock_ratio > 0.25:
            return Action.C
        elif stock_ratio <= 0.25 and state.round_number < self.game_description.n_rounds - 1:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.1 * capacity:
            return Action.C

class Strategy_EXPLOITATIVE_470(BaseStrategy):
    """
    A robust and exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        stock_level = state.current_stock / capacity
        if stock_level > 0.75:
            return Action.D
        elif 0.5 <= stock_level <= 0.75:
            return Action.C
        elif stock_level < 0.5:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        opponents_cooperated = sum(history.opponent_actions[-1, :])
        if opponents_cooperated > n_players / 2:
            return Action.C
        consecutive_defection = sum(~history.my_actions[-min(2, state.round_number):]) == 0
        if consecutive_defection >= 2:
            return Action.C
        if state.current_stock < 0.25 * capacity:
            return Action.D

class Strategy_EXPLOITATIVE_471(BaseStrategy):
    """
    An exploitative strategy that adaptively responds to the current state and history of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.D
        stock_threshold = self.game_description.capacity / (2 * self.game_description.n_players)
        if state.current_stock > stock_threshold:
            return Action.C
        if len(history.my_payoffs) > 0 and sum(history.opponent_actions[-1, :]) * self.game_description.capacity / (self.game_description.n_players * 2) + history.my_payoffs[-1] > self.game_description.capacity / 2:
            return Action.C
        if state.current_stock <= 0 and len(history.my_payoffs) > 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_472(BaseStrategy):
    """
    A strategic approach for the Common Pool Resource Game that adapts to various opponent behaviors while maximizing its own payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.num_defectors = 0
        self.stock_threshold = 0.75 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.num_defectors = sum((not action for action in history.opponent_actions[-1, :]))
        if state.current_stock >= self.stock_threshold:
            prob_defect = self.num_defectors / self.game_description.n_players
            return Action.D if random.random() < prob_defect else Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_473(BaseStrategy):
    """
    Exploitative strategy aiming to maximize individual payoffs by adaptively exploiting the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.25
        self.defection_threshold = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        opponent_actions = history.opponent_actions[-1, :]
        cooperation_ratio = sum(opponent_actions) / self.game_description.n_players
        if cooperation_ratio > 0.6:
            self.cooperation_threshold -= 0.05
        elif cooperation_ratio < 0.4:
            self.defection_threshold += 0.05
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio > self.defection_threshold:
            return Action.D
        elif self.cooperation_threshold <= stock_ratio <= self.defection_threshold:
            majority_cooperated = sum(opponent_actions) > len(opponent_actions) / 2
            return Action.C if majority_cooperated else Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.C

class Strategy_EXPLOITATIVE_474(BaseStrategy):
    """
    Exploitative strategy that adapts to various opponent behaviors and maximizes payoffs over multiple rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if self.game_description.n_players % 2 == 0 else Action.D
        prev_consumption = sum((history.my_payoffs[-1] for _ in range(self.game_description.n_players)))
        opponents_defected = sum((not action for action in history.opponent_actions[-1, :]))
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C if opponents_defected >= self.game_description.n_players / 2 else Action.D
        elif 0.5 * self.game_description.capacity <= state.current_stock <= 0.75 * self.game_description.capacity:
            return Action.D if prev_consumption > 0.5 * self.game_description.capacity else Action.C
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_475(BaseStrategy):
    """
    Adaptive Stock Hawk strategy that responds to current game state and observed opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperation_rates = []
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        opponent_actions = history.opponent_actions[-1, :]
        avg_opponent_cooperation_rate = np.mean(opponent_actions)
        self.opponent_cooperation_rates.append(avg_opponent_cooperation_rate)
        self.stock_history.append(current_stock)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif current_stock > 0.75 * self.game_description.capacity:
            return Action.D
        elif 0.25 * self.game_description.capacity <= current_stock <= 0.75 * self.game_description.capacity:
            if avg_opponent_cooperation_rate > 0.5 or len(self.opponent_cooperation_rates) < 3:
                return Action.C
            else:
                cooperation_rate_window = np.mean(self.opponent_cooperation_rates[-3:])
                if cooperation_rate_window > 0.5:
                    return Action.C
                else:
                    return Action.D
        elif current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_476(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to the game state and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_stock = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        remaining_capacity_for_exploitation = self.game_description.capacity - state.current_stock
        opponent_actions = history.opponent_actions[-1, :]
        cooperators = sum(opponent_actions)
        defectors = len(opponent_actions) - cooperators
        if remaining_capacity_for_exploitation > 0.5 * self.game_description.capacity:
            return Action.D
        elif cooperators > defectors and state.current_stock < 0.75 * self.game_description.capacity:
            return Action.D
        elif defectors > cooperators and remaining_capacity_for_exploitation > 0.25 * self.game_description.capacity:
            return Action.D
        elif state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if cooperators == defectors:
            return Action.C if random.random() < 0.5 else Action.D
        return Action.C

class Strategy_EXPLOITATIVE_477(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behaviors and maximizes its own payoffs while minimizing the risk of stock depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defect_probability = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        opponent_cooperation_rate = np.mean(history.opponent_actions[-1, :])
        if state.current_stock > 0.75 * self.game_description.capacity:
            self.defect_probability = 0.0
        elif state.current_stock >= 0.5 * self.game_description.capacity:
            self.defect_probability = max(0.0, min(1.0, 0.4 - (opponent_cooperation_rate - 0.6) * 0.1))
        else:
            self.defect_probability = 1.0
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if random.random() < self.defect_probability:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_480(BaseStrategy):
    """
    Exploitative strategy that adapts to changing stock levels and opponent behaviors.
    Balances short-term gains with long-term sustainability by tracking opponent cooperation rates.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperation_rate = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        stock_capacity = self.game_description.capacity
        if history is not None and state.round_number > 1:
            opponents_cooperation_rate = np.mean(history.opponent_actions[-2, :])
            self.opponent_cooperation_rate = (self.opponent_cooperation_rate * (state.round_number - 2) + opponents_cooperation_rate) / (state.round_number - 1)
        if current_stock > 0.75 * stock_capacity:
            return Action.D
        elif 0.25 * stock_capacity <= current_stock < 0.75 * stock_capacity and self.opponent_cooperation_rate > 0.5:
            return Action.C
        elif 0.25 * stock_capacity <= current_stock < 0.75 * stock_capacity and self.opponent_cooperation_rate <= 0.5:
            return Action.D
        elif current_stock < 0.25 * stock_capacity or state.round_number == self.game_description.n_rounds - 1:
            return Action.C if current_stock > 0.1 * stock_capacity else Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_481(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Stock Conservation (ASC)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        opponent_actions = history.opponent_actions[-1]
        opponent_defections = sum((not action for action in opponent_actions))
        average_payoff = np.mean(history.my_payoffs) if len(history.my_payoffs) > 0 else 0
        stock_level = state.current_stock / self.game_description.capacity
        if stock_level < 0.25:
            return Action.D
        elif opponent_defections > self.game_description.n_players / 2:
            return Action.C
        elif average_payoff > 0.75 * (state.current_stock / (2 * self.game_description.n_players)):
            return Action.D
        else:
            cooperation_probability = max(0.2, min(0.8, stock_level))
            return random.choice([Action.C, Action.D], p=[cooperation_probability, 1 - cooperation_probability])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        opponent_homogeneity = len(set(opponent_actions)) == 1
        if opponent_homogeneity:
            adaptation_factor = (state.round_number + 1) / self.game_description.n_rounds
            cooperation_probability = min(0.8, max(0.2, adaptation_factor))
            return random.choice([Action.C, Action.D], p=[cooperation_probability, 1 - cooperation_probability])

class Strategy_EXPLOITATIVE_482(BaseStrategy):
    """
    Exploitative strategy "Adaptive Stock Hawk" for the Common Pool Resource Game.
    
    This strategy adapts to the game's state and history, conserving stock when low,
    punishing defectors, maintaining cooperation with cooperators, and exploiting
    homogeneous cooperation. It also has specific logic for the initial round,
    last round, and critically low stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        stock_fraction = state.current_stock / self.game_description.capacity
        if stock_fraction < 0.5:
            return Action.C
        elif stock_fraction < 0.2:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        if np.any(opponent_actions == False):
            return Action.D
        if np.all(opponent_actions == True):
            return Action.C
        recent_rounds = history.opponent_actions[-3:, :]
        if np.all(recent_rounds == True, axis=1).sum() >= 3:
            return Action.D
        if state.round_number + 1 == self.game_description.n_rounds:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_483(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behaviors while maintaining a balance between short-term gains and long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions_last_round = history.opponent_actions[-1]
        defectors_last_round = sum((1 for action in opponent_actions_last_round if not action))
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        elif defectors_last_round >= self.game_description.n_players / 2:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_484(BaseStrategy):
    """
    Exploitative strategy designed to adapt to changing game conditions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperation_history = []
        self.stock_trend = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        self.opponent_cooperation_history.append(np.mean(history.opponent_actions[-1, :]))
        if len(self.opponent_cooperation_history) >= 3 and all((coop > 0.5 for coop in self.opponent_cooperation_history[-3:])):
            return Action.D
        self.stock_trend.append(state.current_stock)
        if len(self.stock_trend) >= 3 and np.mean(self.stock_trend[-3:]) < np.mean(self.stock_trend[:-3]):
            defect_probability = 0.6
        else:
            defect_probability = 0.4
        avg_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
        if state.current_stock > self.game_description.capacity / 2 and avg_opponent_payoff >= state.current_stock / (2 * self.game_description.n_players):
            return Action.D
        total_consumption = self.game_description.n_players * (state.current_stock / self.game_description.n_players)
        if self.game_description.capacity / 4 <= state.current_stock <= self.game_description.capacity / 2 and total_consumption >= state.current_stock / 2:
            return Action.D
        if state.current_stock < self.game_description.capacity / 4:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return random.choice([Action.C, Action.D]) if random.random() < defect_probability else Action.C

class Strategy_EXPLOITATIVE_485(BaseStrategy):
    """
    An exploitative strategy that adapts to the game's dynamic state and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_opponents = game_description.n_players - 1
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C if random.random() < 0.5 else Action.D
        cooperation_rates = []
        for i in range(self.n_opponents):
            opponent_actions = history.opponent_actions[:, i]
            cooperation_rate = np.mean(opponent_actions)
            cooperation_rates.append(cooperation_rate)
        previous_stock_level = state.current_stock if len(history.my_payoffs) == 0 else history.my_payoffs[-1] * 2 * self.game_description.n_players / (self.capacity if len(history.opponent_actions) > 1 else 1)
        if previous_stock_level > self.capacity / 2:
            return Action.C
        elif previous_stock_level <= self.capacity / 2 or previous_stock_level < state.current_stock:
            return Action.D
        for i, opponent in enumerate(history.opponent_actions):
            cr = cooperation_rates[i]
            if cr > 0.7:
                return Action.D
            elif cr < 0.3:
                return Action.C
            else:
                return Action.C if history.opponent_actions[-1, i] else Action.D
        if len(history.my_payoffs) + 1 == self.game_description.n_rounds:
            return Action.D
        if self.n_opponents == 0:
            if len(history.opponent_actions) == 0:
                return Action.C
            elif not history.opponent_actions[-1]:
                return Action.D
            else:
                return Action.C if history.opponent_actions[-1] else Action.D

class Strategy_EXPLOITATIVE_486(BaseStrategy):
    """
    Adaptive Stock Raider strategy for the Common Pool Resource game.
    
    Initially cooperates if the stock level is high, then adapts based on opponents' actions and changes in the stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.5 * game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock > 0.75 * self.game_description.capacity else Action.D
        if history is not None and len(history.my_actions) > 0:
            avg_payoff = np.mean(history.opponent_payoffs[-1, :])
            if state.current_stock < self.game_description.capacity * 0.15:
                self.threshold *= 0.9
            elif state.current_stock >= history.my_payoffs[-1] + 0.05 * self.game_description.capacity / self.game_description.n_players:
                self.threshold = min(self.threshold * 1.05, 0.5 * self.game_description.capacity / self.game_description.n_players)
            if state.current_stock < self.game_description.capacity * 0.25 or state.round_number == self.game_description.n_rounds - 1:
                return Action.D
            return Action.C if avg_payoff > self.threshold else Action.D
        return Action.D

class Strategy_EXPLOITATIVE_487(BaseStrategy):
    """
    A robust and adaptive exploitative strategy for the Common Pool Resource Game.
    Balances cooperation and defection based on current stock level, opponents' actions,
    and an adaptive threshold to maximize payoffs while minimizing risks of over-exploitation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.0
        self.cooperation_history = []
        self.defection_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        self.cooperation_history.append(np.any(opponent_actions))
        self.defection_history.append(not np.all(opponent_actions))
        if all(self.cooperation_history):
            self.stock_threshold *= 0.9
        elif any(self.defection_history):
            self.stock_threshold *= 1.2
        current_stock = state.current_stock
        n_players = self.game_description.n_players
        stock_per_player = current_stock / (2 * n_players)
        if current_stock >= self.stock_threshold and any(self.cooperation_history):
            return Action.C
        elif len([h for h in self.defection_history if h]) >= 2 or current_stock < self.stock_threshold:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if current_stock < n_players:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_489(BaseStrategy):
    """
    Exploitative strategy that adapts to the current stock level and opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.alpha = 0.6
        self.beta = 0.3
        self.gamma = 0.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if self.game_description.capacity >= 2 * self.game_description.n_players else Action.D
        if state.round_number + 1 == self.game_description.n_rounds:
            return Action.D
        if state.current_stock < self.gamma * self.game_description.capacity:
            return Action.C
        opponent_defectors = sum((not action for action in history.opponent_actions[-1, :]))
        if state.current_stock >= self.alpha * self.game_description.capacity:
            return Action.C
        elif opponent_defectors > 0 and state.current_stock < self.beta * self.game_description.capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_490(BaseStrategy):
    """
    The Adaptive Stock Raider (ASR) strategy aims to maximize its own payoff by exploiting the game's dynamics and adapting to the opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.D
        old_stock = max(1e-09, self.game_description.capacity * 2 / self.game_description.n_players)
        if state.current_stock > self.game_description.capacity / 2:
            return Action.C
        opponent_defected = any((not opponent_action for opponent_action in history.opponent_actions[-1, :]))
        if opponent_defected:
            return Action.D
        new_stock = min(state.current_stock + 2 * max(0, state.current_stock) * (1 - state.current_stock / self.game_description.capacity), self.game_description.capacity)
        if new_stock > old_stock and state.current_stock / (2 * self.game_description.n_players) < 0.75 * state.current_stock / self.game_description.n_players:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.game_description.capacity / 4:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1 and state.current_stock < self.game_description.capacity / 10:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_491(BaseStrategy):
    """
    Exploitative Strategy: "Adaptive Stock Exploiter" (ASE)
    
    This strategy aims to maximize its payoff by adaptively exploiting 
    the common pool resource, while considering the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_defection_rate = np.mean(history.opponent_actions)
        total_stock_depletion = self.game_description.capacity - state.current_stock
        stock_depletion_rate = total_stock_depletion / state.round_number
        if avg_defection_rate < 0.5 and stock_depletion_rate < self.game_description.capacity / (2 * self.game_description.n_rounds):
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_492(BaseStrategy):
    """
    Adaptive Exploiter strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = game_description.capacity / (2 * game_description.n_players)
        self.opponent_cooperation_rate = 0.0
        self.k = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions
        current_round_opponents = opponent_actions[-1, :]
        recent_cooperators = np.sum(opponent_actions[max(0, -self.k + 1):, :], axis=0)
        self.opponent_cooperation_rate = np.mean(recent_cooperators / (self.k * np.ones_like(current_round_opponents)))
        adjusted_cooperation_threshold = self.cooperation_threshold + (self.opponent_cooperation_rate - 0.5) * self.game_description.capacity / (2 * self.game_description.n_players)
        if state.current_stock > adjusted_cooperation_threshold:
            action = Action.C
        else:
            action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_493(BaseStrategy):
    """
    Exploitative strategy that adapts to the current stock level and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        capacity = self.game_description.capacity
        stock = state.current_stock
        if stock >= capacity / 2:
            return Action.D
        elif stock < capacity / 2 and stock > capacity / 4:
            return Action.C
        else:
            return Action.D
        prev_coop_count = sum((1 for opp in history.opponent_actions[-1, :] if opp))
        n_players = self.game_description.n_players
        if prev_coop_count > n_players / 2:
            return Action.C
        elif prev_coop_count < n_players / 2:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_494(BaseStrategy):
    """
    The Adaptive Stock Hawk is a dynamic, history-dependent strategy designed to exploit opponents' behaviors while ensuring robustness against various opponent types.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C if state.current_stock > 0.8 * self.game_description.capacity else Action.D
        num_cooperators = sum(history.opponent_actions[-1, :])
        if state.current_stock > 0.7 * self.game_description.capacity:
            return Action.C if num_cooperators >= self.game_description.n_players / 2 else Action.D
        if 0.4 * self.game_description.capacity <= state.current_stock <= 0.7 * self.game_description.capacity:
            previous_cooperators = sum(history.opponent_actions[-2, :]) if state.round_number > 1 else 0
            return Action.C if num_cooperators >= previous_cooperators else Action.D
        return Action.D

class Strategy_EXPLOITATIVE_496(BaseStrategy):
    """
    Exploitative strategy that adaptively responds to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        if state.current_stock > 0.75 * capacity:
            return Action.D
        p = (state.current_stock / capacity) ** (1 / n)
        if history is not None and len(history.opponent_actions) > 0:
            recent_opponent_actions = history.opponent_actions[-1, :]
            opponents_cooperate_rate = np.mean(recent_opponent_actions)
            if opponents_cooperate_rate > 0.5:
                p *= 1.2
            elif opponents_cooperate_rate < 0.5:
                p *= 0.8
        if random.random() < p:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_497(BaseStrategy):
    """
    The Adaptive Stock Raider (ASR) strategy is designed to maximize payoffs by adapting to the game's dynamic state and opponents' behaviors while maintaining a robust exploitative approach.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_actions = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if history is not None and len(self.opponent_actions) < state.round_number:
            self.opponent_actions.append(history.opponent_actions[-1, :])
        ocr = self.calculate_opponent_cooperation_rate()
        if state.current_stock < self.game_description.capacity / 2 or ocr > 0.5:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

    def calculate_opponent_cooperation_rate(self):
        total_actions = sum((len(round) for round in self.opponent_actions))
        cooperations = sum((sum((1 for action in round if action)) for round in self.opponent_actions))
        if total_actions == 0:
            return 0.5
        return cooperations / total_actions

class Strategy_EXPLOITATIVE_498(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        round_number = state.round_number
        current_stock = state.current_stock
        prev_round_opponents = history.opponent_actions[-1, :]
        num_cooperators = sum(prev_round_opponents)
        if round_number < self.game_description.n_rounds // 2:
            if current_stock > 0.75 * capacity and num_cooperators > n_players / 2:
                return Action.C
            else:
                return Action.D
        elif round_number < self.game_description.n_rounds - 2:
            if current_stock < 0.25 * capacity or num_cooperators <= n_players / 2:
                return Action.D
            else:
                our_payoff = history.my_payoffs[-1]
                average_payoff = np.mean(history.opponent_payoffs[-1, :])
                if our_payoff > average_payoff:
                    return Action.C
                else:
                    return Action.D
        else:
            return Action.D
        if current_stock <= 0:
            return Action.C
        if all((not opponent_action for opponent_action in prev_round_opponents)):
            return Action.C

class Strategy_EXPLOITATIVE_499(BaseStrategy):
    """
    Exploitative strategy that adapts to changes in the game state and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defector_count = 0
        self.consistent_defection_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        if stock_level > 0.75:
            return Action.D
        elif stock_level >= 0.5 and history.opponent_actions[-1, :].sum() > 0:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C

class Strategy_EXPLOITATIVE_500(BaseStrategy):
    """
    A hybrid strategy that combines elements of Tit-for-Tat and a stock-dependent defection rule.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defect_counters = [0] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_consumption = sum((stock / self.game_description.n_players if action else stock / (2 * self.game_description.n_players) for action, stock in zip(history.opponent_actions[-1, :], [state.current_stock] * self.game_description.n_players)))
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        for player_id, action in enumerate(history.opponent_actions[-1, :]):
            if not action:
                self.defect_counters[player_id] += 1
        if all((counter < 2 for counter in self.defect_counters)):
            return Action.C
        else:
            return Action.D
        if total_consumption <= 0.5 * self.game_description.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_501(BaseStrategy):
    """
    Adaptive Stock-Based Exploitation strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold_fraction = 0.7
        self.cooperation_rate_threshold = 0.4
        self.min_payoff_fraction = 0.6
        self.k = 5
        self.m = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_threshold = self.stock_threshold_fraction * self.game_description.capacity
        if state.current_stock > stock_threshold:
            return Action.D
        opponent_cooperation_rates = np.mean(history.opponent_actions[-self.k:, :], axis=0)
        for i, rate in enumerate(opponent_cooperation_rates):
            if rate < self.cooperation_rate_threshold:
                return Action.D
        recent_payoffs = history.my_payoffs[-self.m:]
        average_recent_payoff = np.mean(recent_payoffs)
        max_possible_payoff = state.current_stock / (2 * self.game_description.n_players)
        if average_recent_payoff < self.min_payoff_fraction * max_possible_payoff:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_502(BaseStrategy):
    """
    Exploitative strategy that adaptively responds to the game's state and history 
    while exploiting opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_payoffs_history = []
        self.stock_trend = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        opponent_payoffs_avg = np.mean(history.opponent_payoffs[-1, :])
        theoretical_max_coop_payoff = self.game_description.capacity / (2 * self.game_description.n_players)
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.D
        elif 0.25 * self.game_description.capacity <= state.current_stock <= 0.75 * self.game_description.capacity:
            if opponent_payoffs_avg > theoretical_max_coop_payoff:
                return Action.C
            else:
                return Action.D
        elif state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        self.opponent_payoffs_history.append(opponent_payoffs_avg)
        self.stock_trend.append(state.current_stock)

class Strategy_EXPLOITATIVE_503(BaseStrategy):
    """
    An exploitative strategy that balances short-term gains with long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        rounds_remaining = self.game_description.n_rounds - state.round_number
        if state.round_number < 3:
            return Action.C
        stock_level = state.current_stock
        defect_threshold = capacity / (n_players * (1 + rounds_remaining))
        opponents_defecting = np.sum(1 - history.opponent_actions[-1, :])
        if opponents_defecting > n_players / 2:
            defect_threshold *= 0.8
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock_level < defect_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_504(BaseStrategy):
    """
    Adaptive Stock Raider: Exploitative strategy aiming to maximize individual payoff by adaptively responding to the current state and history of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        avg_coop_rate = np.mean(history.opponent_actions)
        if state.current_stock < 0.75 * self.game_description.capacity:
            return Action.D
        elif avg_coop_rate > 0.5 and state.current_stock > 0.5 * self.game_description.capacity:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if not np.any(history.opponent_actions[-1, :]):
            return Action.C
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D

class Strategy_EXPLOITATIVE_505(BaseStrategy):
    """
    Adaptive Exploitation strategy for Common Pool Resource Game.

    This strategy balances short-term gains with long-term sustainability by adapting to opponents' behavior and adjusting its decision-making thresholds accordingly.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.threshold = self.capacity / 2
        self.D_count = None
        self.C_count = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_defected_last_round = np.sum(~history.opponent_actions[-1, :])
        opponents_cooperated_last_round = self.n_players - 1 - opponents_defected_last_round
        self.D_count = opponents_defected_last_round
        self.C_count = opponents_cooperated_last_round
        if state.current_stock >= self.threshold:
            return Action.C
        if opponents_defected_last_round > 0 and opponents_cooperated_last_round == 0:
            return Action.D
        if self.D_count > self.C_count:
            self.threshold *= 3 / 4
        elif self.C_count > self.D_count:
            self.threshold /= 2
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_506(BaseStrategy):
    """
    Robust and exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_threshold = self.capacity / (2 * self.n_players + 1)
        current_stock = state.current_stock
        if current_stock >= stock_threshold:
            cooperate = True
        else:
            cooperate = False
        opponent_actions_last_round = history.opponent_actions[-1, :]
        opponents_defected = sum((1 for action in opponent_actions_last_round if not action))
        p_coop = 0.7 * (self.n_players - opponents_defected) / self.n_players
        p_defect = 0.9
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if self.n_players == 2 and history.opponent_actions[-1, 0]:
            cooperate = False
        elif self.n_players == 2:
            cooperate = True
        random_number = random.random()
        if random_number < p_coop:
            return Action.C
        elif random_number < p_coop + p_defect:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_507(BaseStrategy):
    """
    An exploitative strategy that adapts to the game's state and opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock_ratio = state.current_stock / self.capacity
        defect_ratio = sum(history.opponent_actions[-1, :]) / self.n_players
        if 2 <= state.round_number < self.game_description.n_rounds - 2:
            if current_stock_ratio > 0.75:
                return Action.D
            elif 0.5 <= current_stock_ratio <= 0.75:
                if defect_ratio > 0.5:
                    return random.choice([Action.C, Action.D])
                else:
                    return Action.C
            else:
                return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            if current_stock_ratio > 0.25:
                return Action.D
            else:
                return Action.C
        elif state.round_number == self.game_description.n_rounds:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_508(BaseStrategy):
    """
    The Adaptive Raider strategy balances exploitation with adaptability.
    It monitors opponents' actions and adjusts its strategy accordingly,
    making it robust against various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.acr = [0.5, 0.5, 0.5]
        self.previous_acr = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < 3:
            if state.round_number == 0 or state.round_number == 1:
                return Action.C
            else:
                return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        new_acr = np.mean(opponent_actions)
        self.acr.append(new_acr)
        self.acr.pop(0)
        if self.previous_acr is not None and abs(self.acr[-1] - self.previous_acr) > 0.1:
            pass
        self.previous_acr = self.acr[-1]
        if np.mean(self.acr) >= 0.5:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.2 * self.game_description.capacity:
            return Action.C

class Strategy_EXPLOITATIVE_509(BaseStrategy):
    """
    Adaptive Exploiter strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if self.game_description.n_players > 4 else Action.D
        avg_payoff = np.mean(history.my_payoffs)
        if state.round_number < 5:
            return Action.C if random.random() < 0.5 else Action.D
        if avg_payoff > self.threshold:
            action = Action.D
        elif state.current_stock < 0.5 * self.game_description.capacity and np.sum(history.my_payoffs) < np.mean(history.opponent_payoffs):
            action = Action.D
        elif state.round_number >= self.game_description.n_rounds / 2 and state.current_stock < 0.25 * self.game_description.capacity:
            action = Action.D
        else:
            action = Action.C
        if np.all(history.opponent_actions[-1, :]):
            action = Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_510(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors and game states.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions
        recent_opponent_cooperation_rate = np.mean(opponent_actions[-3:, :])
        if self.rounds // 2 > state.round_number >= 5:
            stock_trend = 'increasing' if state.current_stock > self.capacity / 2 else 'decreasing'
            if stock_trend == 'increasing' and recent_opponent_cooperation_rate > 0.5:
                return Action.C
            elif stock_trend == 'decreasing':
                return Action.D
        elif state.round_number >= self.rounds // 2:
            if state.current_stock > self.capacity / 4:
                return Action.D
            else:
                return Action.C
        else:
            opponent_cooperation_rate = np.mean(opponent_actions)
            if opponent_cooperation_rate > 0.5:
                return Action.C
            else:
                return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_511(BaseStrategy):
    """
    This strategy adapts to the game state and opponent behavior while maintaining a robust exploitative mindset.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_trend_window_size = 5

    def analyze_stock_trend(self, stock_history):
        if len(stock_history) > self.stock_trend_window_size:
            recent_stocks = stock_history[-self.stock_trend_window_size:]
            avg_change = np.mean(np.diff(recent_stocks))
            return avg_change < 0
        return False

    def analyze_opponent_behavior(self, last_round_actions):
        if last_round_actions is None or len(last_round_actions) == 0:
            return None
        opponent_cooperations = sum((not action for action in last_round_actions))
        return opponent_cooperations >= self.game_description.n_players // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        last_round_actions = history.opponent_actions[-1, :] if history else []
        current_stock = state.current_stock
        stock_trend_down = self.analyze_stock_trend([state.current_stock] + ([0.0] if history is None else list(history.my_payoffs.cumsum())))
        opponents_cooperating = self.analyze_opponent_behavior(last_round_actions)
        if current_stock > 0.75 * self.game_description.capacity:
            return Action.D
        elif 0.25 * self.game_description.capacity <= current_stock <= 0.75 * self.game_description.capacity:
            if opponents_cooperating:
                return Action.C
            else:
                return Action.D
        elif stock_trend_down or state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        else:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_512(BaseStrategy):
    """
    The Adaptive Stock Raider strategy is designed to exploit a wide range of opponent behaviors 
    while adapting to the dynamic state of the common pool resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        average_consumption_per_player = capacity / (2 * n_players)
        if history is None or len(history.opponent_actions) == 0:
            return Action.C
        opponent_consumptions_last_round = np.where(~history.opponent_actions[-1, :], capacity / n_players, capacity / (2 * n_players))
        average_opponent_consumption = np.mean(opponent_consumptions_last_round)
        cooperation_threshold = capacity / (2 * n_players)
        if state.current_stock > cooperation_threshold:
            return Action.C
        elif average_opponent_consumption > 0.7 * average_consumption_per_player:
            if state.round_number == self.game_description.n_rounds - 1:
                return Action.D
            if state.current_stock < cooperation_threshold:
                if len(history.opponent_actions) > 1:
                    last_opponent_consumptions = np.where(~history.opponent_actions[-2:, :], capacity / n_players, capacity / (2 * n_players))
                    average_last_two_rounds = np.mean(last_opponent_consumptions)
                    if average_opponent_consumption < average_last_two_rounds:
                        return Action.C
        elif state.current_stock < 2 * n_players:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_34(BaseStrategy):
    """
    Adaptive Stock Conservation Strategy.
    
    This strategy adapts to the game state and history, balancing cooperation and defection 
    based on the stock level and opponents' actions. It prioritizes collective conservation 
    when resources are abundant and adapts to potential over-exploitation when they become scarce.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        current_stock = state.current_stock
        previous_actions = history.opponent_actions[-1]
        previous_cooperators = sum(previous_actions)
        if current_stock > capacity / 2:
            cooperation_prob = previous_cooperators / n_players * 0.7
            return Action.C if random.random() < cooperation_prob else Action.D
        elif current_stock < capacity / 4:
            return Action.D if random.random() < 0.8 else Action.C
        else:
            ci = previous_cooperators / n_players * (current_stock / capacity)
            if current_stock < capacity / 10:
                return Action.D
            elif history.my_actions[-1] == False and all(previous_actions):
                ci *= 0.9
            return Action.C if ci > 0.5 else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_65(BaseStrategy):
    """
    Adaptive Cooperation with Stock Awareness strategy.
    
    This strategy balances individual payoffs with collective sustainability, 
    adapting to changing game conditions and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_probability = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio > 0.75:
            return Action.C
        elif stock_ratio >= 0.25 and stock_ratio <= 0.75:
            p = stock_ratio ** 2
            return Action.C if random.random() < p else Action.D
        else:
            return Action.D
        if history is not None:
            opponent_coop_rate = np.mean(history.opponent_actions)
            if opponent_coop_rate > 0.5:
                self.cooperation_probability += 0.1
            elif opponent_coop_rate < 0.5:
                self.cooperation_probability -= 0.1
        if history is not None and state.round_number > 1:
            previous_round_stock = history.my_payoffs[state.round_number - 2] * (self.game_description.n_players / 2)
            stock_increased = state.current_stock >= previous_round_stock
            all_cooperated = np.all(history.opponent_actions[-1, :])
            if all_cooperated and stock_increased:
                self.cooperation_probability += 0.05
            elif not all_cooperated or state.current_stock < previous_round_stock * 0.75:
                self.cooperation_probability -= 0.05
        self.cooperation_probability = max(0, min(self.cooperation_probability, 1))
        return Action.C if random.random() < self.cooperation_probability else Action.D

class Strategy_COLLECTIVE_85(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Dependent Threshold (ACSDT) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.growth_rounds = 0
        self.total_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        T = state.current_stock / self.game_description.capacity * (self.game_description.n_players - 1)
        self.total_rounds += 1
        if state.current_stock > self.game_description.capacity / 4:
            self.growth_rounds += 1
        if self.growth_rounds / self.total_rounds > 0.5 or state.current_stock < self.game_description.capacity / 4:
            return Action.C
        elif history.opponent_actions.shape[0] == 0:
            return Action.C
        num_cooperators = sum(history.opponent_actions[-1, :])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif num_cooperators > T:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_90(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource game, balancing individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponents_defected_rates = np.mean(history.opponent_actions[:-1], axis=0)
        stock_level = state.current_stock / self.game_description.capacity
        if stock_level > 0.75:
            action = Action.C
        elif stock_level < 0.25:
            action = Action.C
        else:
            defect_prob = np.sum(opponents_defected_rates) / self.game_description.n_players
            action = Action.D if random.random() < defect_prob else Action.C
        return action

class Strategy_COLLECTIVE_153(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that adapts to opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_rates = []
        self.punishment_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or len(self.cooperation_rates) < 5:
            return Action.C
        recent_cooperations = sum(history.opponent_actions[-1, :])
        self.cooperation_rates.append(recent_cooperations)
        cooperation_rate = np.mean(self.cooperation_rates)
        if state.current_stock < 0.25 * self.game_description.capacity and history is not None:
            opponents_defected_recently = sum(history.opponent_actions[-1, :] == Action.D)
            if opponents_defected_recently > 0:
                self.punishment_rounds += 2
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        elif state.current_stock >= 0.5 * self.game_description.capacity and state.current_stock < 0.75 * self.game_description.capacity:
            p = (state.current_stock / self.game_description.capacity) ** 2
            if random.random() < p:
                return Action.C
            else:
                return Action.D
        elif self.punishment_rounds > 0:
            self.punishment_rounds -= 1
            return Action.D
        elif cooperation_rate < 0.5 and random.random() < 0.2:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C

class Strategy_COLLECTIVE_311(BaseStrategy):
    """
    The Adaptive Common Pool Conservation (ACPC) strategy aims to balance individual payoffs with collective sustainability by adaptively adjusting cooperation levels based on game parameters, state, and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.growth_rate_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock > 0.8 * self.game_description.capacity else Action.D
        self.stock_history.append(state.current_stock)
        if len(self.stock_history) > 1:
            growth_rate = (self.stock_history[-1] - self.stock_history[1]) / (state.round_number - 1)
            self.growth_rate_history.append(growth_rate)
        prev_coops = sum(history.opponent_actions[-1, :])
        if state.round_number < self.game_description.n_rounds - 1:
            growth_rate = self.growth_rate_history[-1] if self.growth_rate_history else 0
            if growth_rate > 0 and state.current_stock > 0.5 * self.game_description.capacity:
                return Action.C if prev_coops >= self.game_description.n_players // 2 else Action.D
            elif growth_rate < 0 or state.current_stock < 0.5 * self.game_description.capacity:
                return Action.D if sum(history.opponent_actions[-1, :]) > self.game_description.n_players // 2 else Action.C
        return Action.C if state.current_stock > 0.8 * self.game_description.capacity else Action.D

class Strategy_COLLECTIVE_363(BaseStrategy):
    """
    An adaptive strategy that balances individual payoff with collective sustainability by adapting to changes in the stock level and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.low_threshold = 0.25 * game_description.capacity
        self.high_threshold = 0.75 * game_description.capacity
        self.p_defect = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_stock = history.my_payoffs[-1] * self.game_description.n_players * 2 if len(history.my_payoffs) > 1 else self.game_description.capacity
        opponent_actions = history.opponent_actions[-1, :]
        if state.current_stock < self.low_threshold:
            return Action.D
        elif state.current_stock > self.high_threshold:
            return Action.C
        elif previous_stock > state.current_stock:
            self.p_defect = 0.5 * (previous_stock - state.current_stock) / self.game_description.capacity
        for opponent in opponent_actions:
            if not opponent and state.current_stock < self.low_threshold:
                self.p_defect += 0.1
            elif opponent and state.current_stock > self.high_threshold:
                self.p_defect -= 0.1
                self.p_defect = max(0, self.p_defect)
        return Action.C if random.random() >= self.p_defect else Action.D

class Strategy_EXPLOITATIVE_35(BaseStrategy):
    """
    Exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperation_rates = [0.5] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < 3 or (history is not None and len(history.my_actions) < 3):
            return random.choice([Action.C, Action.D])
        for i in range(self.game_description.n_players - 1):
            if history is not None and len(history.opponent_actions) > 0:
                self.opponent_cooperation_rates[i] = (self.opponent_cooperation_rates[i] * (len(history.my_actions) - 1) + int(history.opponent_actions[-1, i])) / len(history.my_actions)
        if state.current_stock > self.game_description.capacity / 2:
            return Action.D if random.random() < 1 - state.current_stock / self.game_description.capacity else Action.C
        else:
            return Action.C if random.random() < state.current_stock / self.game_description.capacity else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock <= self.game_description.capacity / 4:
            return Action.C

class Strategy_EXPLOITATIVE_82(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.P_defect = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number <= 2 or history is None:
            return Action.C
        prev_stock = history.my_payoffs[-1]
        opponents_defected = sum((1 for opponent in history.opponent_actions[-1, :] if not opponent))
        if prev_stock < 0.5 * self.game_description.capacity:
            self.P_defect += 0.1
        elif prev_stock < 0.25 * self.game_description.capacity:
            return Action.D
        for _ in range(opponents_defected):
            self.P_defect += 0.1
        if state.round_number == self.game_description.n_rounds - 1 or random.random() < self.P_defect:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_109(BaseStrategy):
    """
    An exploitative strategy that adapts to the game's dynamic state and opponents' behavior.
    It balances short-term gains with long-term sustainability in a repeated game setting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.tit_for_tat_component = 0.1
        self.stock_growth_monitoring = 0.2
        self.opponent_classification = {}
        for i in range(1, game_description.n_players):
            self.opponent_classification[i] = 'cooperative'

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        previous_stock = self.get_previous_stock(state.current_stock, history)
        opponents_defected = self.count_defectors(history.opponent_actions[-1])
        if state.current_stock > 0.75 * self.capacity:
            if opponents_defected >= 1:
                return Action.D
            else:
                return Action.C
        elif state.current_stock >= 0.5 * self.capacity:
            if self.most_opponents_cooperated(history.opponent_actions[-1]):
                return Action.C
            else:
                return Action.D
        else:
            return Action.D
        self.adjust_strategy(history, state.current_stock)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

    def get_previous_stock(self, current_stock: float, history: PlayerHistory) -> float | None:
        if len(history.my_payoffs) > 0:
            previous_round = len(history.my_payoffs) - 2
            total_consumption = sum([self.get_consumption(action) for action in history.opponent_actions[previous_round]])
            stock_after_consumption = self.capacity - total_consumption
            growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.capacity)
            return min(stock_after_consumption + growth, self.capacity)
        else:
            return None

    def count_defectors(self, opponent_actions: NDArray[np.bool_]) -> int:
        return sum([int(not action) for action in opponent_actions])

    def most_opponents_cooperated(self, opponent_actions: NDArray[np.bool_]) -> bool:
        return sum(opponent_actions) >= len(opponent_actions) // 2

    def adjust_strategy(self, history: PlayerHistory, current_stock: float):
        if self.tit_for_tat_component > 0 and (not history.my_actions[-1]) and any((not action for action in history.opponent_actions[-1])):
            self.tit_for_tat_component -= 0.01
        if self.stock_growth_monitoring < 1:
            previous_stock = self.get_previous_stock(current_stock, history)
            if previous_stock is not None and current_stock - previous_stock > 20 * previous_stock / 100:
                self.stock_growth_monitoring += 0.01

    def get_consumption(self, action: bool) -> float:
        return self.capacity / (2 * self.n_players) if action else self.capacity / self.n_players

class Strategy_EXPLOITATIVE_121(BaseStrategy):
    """
    Adaptive Stock-Based Exploitation strategy.
    
    This strategy balances short-term gains with long-term sustainability by adapting to the current stock level and opponents' past behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = None
        self.opponent_cooperation_rates = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.stock_threshold is None or self.opponent_cooperation_rates is None:
            self.stock_threshold = self.game_description.capacity / (2 * self.game_description.n_players)
            self.opponent_cooperation_rates = np.zeros(self.game_description.n_players - 1)
        self.calculate_stock_threshold(state.current_stock)
        if history is not None:
            self.adjust_stock_threshold(history.opponent_actions[-1, :])
        return Action.D if state.current_stock < self.stock_threshold else Action.C

    def calculate_stock_threshold(self, stock: float) -> None:
        """
        Calculate stock threshold as a function of the current stock level.

        The threshold is calculated using the formula: `T = capacity / (2 * n) + (S - capacity / (2 * n)) / 4`
        where `S` is the current stock level, `capacity` is the maximum sustainable stock level and `n` is the number of players.
        """
        self.stock_threshold = self.game_description.capacity / (2 * self.game_description.n_players) + (stock - self.game_description.capacity / (2 * self.game_description.n_players)) / 4

    def adjust_stock_threshold(self, opponent_actions: NDArray[np.bool_]) -> None:
        """
        Adjust stock threshold based on opponents' past behavior.

        If most opponents cooperated in previous rounds, decrease the threshold by a small margin (e.g., 5%).
        Conversely, if most opponents defected, increase the threshold by a small margin to avoid over-exploitation.
        """
        average_cooperation_rate = np.mean(opponent_actions)
        if average_cooperation_rate > 0.5:
            self.stock_threshold *= 0.95
        else:
            self.stock_threshold *= 1.05

    def finalize(self, state: CommonPoolState, history: PlayerHistory) -> None:
        """
        Finalize the strategy for the last round.

        In this case, always defect in the final round to maximize payoff extraction.
        """
        return Action.D

class Strategy_EXPLOITATIVE_227(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_probabilities = [0.5] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        C_cnt = sum((1 for action in history.opponent_actions[-1, :] if not action))
        P_C = C_cnt / self.game_description.n_players
        stock_level_proportion = state.current_stock / self.game_description.capacity
        if stock_level_proportion > 0.75:
            return Action.D
        elif 0.25 <= stock_level_proportion <= 0.75:
            for i, action in enumerate(history.opponent_actions[-1, :]):
                if not action:
                    self.opponent_probabilities[i] *= 0.9
                else:
                    self.opponent_probabilities[i] = min(self.opponent_probabilities[i] * 1.2, 1)
            return random.choices([Action.C, Action.D], weights=[P_C, 1 - P_C])[0]
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_250(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game.
    
    The Adaptive Stock Raider (ASR) is a robust and adaptive exploitative strategy designed 
    to maximize its payoff by dynamically adjusting its behavior based on the game's state, 
    parameters, and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / (2 * game_description.n_players + 1)
        self.opponent_behavior = [0.0] * game_description.n_players
        self.defector_threshold = 0.3 * game_description.n_players
        self.increased_defection_probability = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock >= self.stock_threshold:
            action = Action.C
        else:
            num_defectors = sum((1 for i, rate in enumerate(self.opponent_behavior) if rate < 0.5 and history is not None))
            if num_defectors > self.defector_threshold and history is not None:
                action = Action.D if random.random() < self.increased_defection_probability else Action.C
            else:
                action = Action.C
        if history is not None:
            for i, opponent_action in enumerate(history.opponent_actions[-1, :]):
                self.opponent_behavior[i] += 1.0 / (state.round_number + 1) * (opponent_action - self.opponent_behavior[i])
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return action

class Strategy_EXPLOITATIVE_305(BaseStrategy):
    """
    An exploitative strategy that adapts to opponent behaviors and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_rates = None
        self.cooperation_counter = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_actions = history.opponent_actions
        my_history = history.my_actions
        if self.defection_rates is None:
            self.defection_rates = {opponent: 0 for opponent in range(self.game_description.n_players)}
        if len(my_history) < 3:
            most_opponents_defected = sum((1 for action in opponents_actions[-1, :] if not action)) > self.game_description.n_players / 2
            return Action.D if most_opponents_defected else Action.C
        for opponent, actions in enumerate(opponents_actions.T):
            defection_rate = sum((1 for action in actions if not action)) / len(actions)
            self.defection_rates[opponent] = defection_rate
        previous_action = opponents_actions[-1]
        max_defection_rate_opponent = max(self.defection_rates, key=self.defection_rates.get)
        if not previous_action[max_defection_rate_opponent] or self.defection_rates[max_defection_rate_opponent] > 0.5:
            return Action.D
        else:
            return Action.C
        if state.current_stock < self.game_description.capacity / 2 and self.cooperation_counter == 0:
            self.cooperation_counter = 1
            return Action.C
        elif self.cooperation_counter > 0:
            self.cooperation_counter += 1
            if self.cooperation_counter <= 3:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            max_defection_rate_opponent = max(self.defection_rates, key=self.defection_rates.get)
            return Action.D if self.defection_rates[max_defection_rate_opponent] > 0.7 else Action.C

class Strategy_EXPLOITATIVE_310(BaseStrategy):
    """
    Adaptive Stock Exploiter strategy, balancing short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_defect_rate = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.opponent_defect_rate is None:
            self.opponent_defect_rate = [0] * (self.game_description.n_players - 1)
        for i in range(self.game_description.n_players - 1):
            if history.opponent_actions[-1, i]:
                self.opponent_defect_rate[i] = (self.opponent_defect_rate[i] + 1) / 2
            else:
                self.opponent_defect_rate[i] /= 2
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.D
        elif 0.5 <= state.current_stock / self.game_description.capacity < 0.75:
            opponent_defected_last_round = any(self.opponent_defect_rate)
            if opponent_defected_last_round and sum(self.opponent_defect_rate) / (self.game_description.n_players - 1) >= 0.5:
                return Action.C
            else:
                return Action.D
        elif state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_363(BaseStrategy):
    """
    Adaptive Stock-Dependent Exploitation (ASDE) strategy.
    
    ASDE balances short-term gains with long-term sustainability by adapting 
    to the current stock level and opponent behavior. It exploits opponents who 
    tend to Defect while avoiding mutual over-exploitation when possible.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity_threshold = game_description.capacity / 2
        self.critical_stock_level = game_description.capacity / 4

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_defectors = sum(1 - history.opponent_actions[-1, :])
        if state.current_stock > self.capacity_threshold and opponent_defectors >= self.game_description.n_players / 2:
            return Action.D
        elif state.current_stock < self.critical_stock_level:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1 and state.current_stock > self.capacity_threshold:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_434(BaseStrategy):
    """
    The Adaptive Stock Raider is a dynamic and adaptive strategy designed to exploit opponents' behaviors 
    while ensuring robustness against various playing styles.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.theta = 0.2
        self.opponent_CRs = [0] * game_description.n_players
        self.window_size = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        self.update_opponent_CRs(history)
        avg_CR = sum(self.opponent_CRs) / self.game_description.n_players
        theta = self.update_theta(avg_CR)
        stock_level = state.current_stock
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock_level < self.game_description.capacity / 4:
            return Action.C
        if stock_level > self.game_description.capacity / 2 and any((cr < theta for cr in self.opponent_CRs)):
            return Action.D
        else:
            return Action.C

    def update_theta(self, avg_CR: float) -> float:
        """
        Update the adaptive threshold based on average opponent cooperation rate.
        """
        if avg_CR > 0.5:
            theta = avg_CR - 0.1
        else:
            theta = 0.2
        return theta

    def update_opponent_CRs(self, history: PlayerHistory):
        """
        Update opponent cooperation rates (CRs) using a moving average window.
        """
        recent_rounds = min(history.opponent_actions.shape[0], self.window_size)
        cr_sum = np.sum(history.opponent_actions[-recent_rounds:, :], axis=0)
        self.opponent_CRs = cr_sum / recent_rounds

class Strategy_EXPLOITATIVE_479(BaseStrategy):
    """
    The Adaptive Exploiter strategy is designed to maximize payoffs by exploiting opponents' behaviors while adapting to changes in the game state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.75 * game_description.capacity
        self.defection_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_defections = sum((1 - action for action in history.opponent_actions[-1, :]))
        if opponent_defections / self.game_description.n_players >= self.defection_threshold:
            return Action.D
        if state.current_stock > self.stock_threshold and state.round_number < self.game_description.n_rounds - 1:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_495(BaseStrategy):
    """
    An exploitative strategy that adapts to various opponent behaviors while maximizing its own payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.threshold = self.n_players // 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        prev_stock = history.my_payoffs[state.round_number - 1]
        prev_actions = history.opponent_actions[state.round_number - 1, :]
        if state.current_stock > self.capacity / 2:
            if any((action == False for action in prev_actions)):
                return Action.D
            else:
                return Action.C
        elif self.capacity / 4 <= state.current_stock <= self.capacity / 2:
            cooperating_opponents = sum((1 for action, _ in zip(prev_actions, history.opponent_payoffs[state.round_number - 1, :]) if action))
            if cooperating_opponents >= self.threshold:
                return Action.C
            else:
                return Action.D
        elif state.current_stock < self.capacity / 4 or state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if len(history.my_payoffs) > 3:
            prev_actions = history.opponent_actions[state.round_number - 1, :]
            for i in range(self.n_players):
                opponent_actions = [action for action, _ in zip(prev_actions, history.opponent_payoffs[state.round_number - 1, :])]
                if all((action == True for action in opponent_actions[-4:])):
                    self.threshold += 1
                elif all((action == False for action in opponent_actions[-4:])):
                    self.threshold -= 1
        return Action.C

class Strategy_COLLECTIVE_513(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Conservation (ASC)

    The ASC strategy balances individual payoffs with collective stock conservation, 
    adapting to opponent behaviors and game state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def calculate_average_stock(self, history: PlayerHistory, k: int) -> float:
        if len(history.my_payoffs) < k:
            return 0.0
        total_stock = sum(history.my_payoffs[-k:])
        return total_stock / k

    def count_defectors(self, round_history: NDArray[np.bool_]) -> int:
        return np.count_nonzero(round_history == False)

    def has_opponent_outperformed_me(self, history: PlayerHistory, threshold: float) -> bool:
        if len(history.opponent_payoffs) < 2 or len(history.my_payoffs) < 2:
            return False
        opponent_payoff = np.max(history.opponent_payoffs[-1])
        my_payoff = history.my_payoffs[-1]
        if opponent_payoff / my_payoff - 1 > threshold and history.opponent_payoffs[-2, np.argmax(history.opponent_payoffs[-1])] / history.my_payoffs[-2] - 1 > threshold:
            return True
        return False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_stock = self.calculate_average_stock(history, k=3)
        if avg_stock < 0.75 * self.game_description.capacity:
            return Action.C
        defector_count = self.count_defectors(history.opponent_actions[-1])
        if defector_count > self.game_description.n_players / 2:
            return Action.D
        if self.has_opponent_outperformed_me(history, threshold=0.2):
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_516(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Dependent Tit-for-Tat (ACSdT) strategy.
    
    This strategy prioritizes cooperation when the stock level is healthy, 
    but adapts to more self-interested behavior when the stock is depleted. 
    By playing tit-for-tat in intermediate stock levels, ACSdT encourages 
    reciprocity and cooperation while protecting against exploitation by defectors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_fraction = state.current_stock / self.game_description.capacity
        if stock_fraction < 0.25:
            return Action.D
        elif stock_fraction > 0.75:
            return Action.C
        else:
            if history is None or len(history.opponent_actions) == 1:
                most_players_cooperated = True
            else:
                most_players_cooperated = sum(history.opponent_actions[-2, :]) > self.game_description.n_players / 2
            if len(history.my_actions) >= 2 and (not history.my_actions[-1]) and (not history.my_actions[-2]):
                return Action.C
            if most_players_cooperated:
                return Action.C
            else:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_517(BaseStrategy):
    """
    A collective strategy that prioritizes long-term sustainability and adaptability 
    over short-term gains by cooperating initially and responding to changes in the stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        if state.round_number == 0:
            return Action.C
        prev_stock = state.current_stock - state.current_stock / self.game_description.n_players * 2
        stock_diff = state.current_stock - prev_stock
        if stock_diff >= 0 or (stock_diff > -10 and state.current_stock > 0.9 * capacity):
            return Action.C
        elif state.current_stock < 0.5 * capacity:
            return Action.D
        else:
            p_defect = (capacity - state.current_stock) / capacity
            if random.random() < p_defect:
                return Action.D
            else:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.2 * capacity:
            return Action.D
        if state.current_stock > 0.95 * capacity:
            return Action.C

class Strategy_COLLECTIVE_518(BaseStrategy):
    """
    Adaptive Tit-for-Tat with Stock Threshold strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        theta = 0.5 * self.capacity
        p = sum(history.my_actions[-1:]) / (state.round_number + 1)
        if p > 0.5:
            theta *= (1 + p) / 2
        elif p <= 0.5:
            theta *= (1 - p) / 2
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * self.capacity:
            return Action.C
        opponent_defected = np.any(~history.opponent_actions[-1, :])
        if opponent_defected and state.current_stock >= theta:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_519(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy for the Common Pool Resource Game.
    
    This strategy aims to balance individual payoffs with collective conservation of the common pool resource.
    It adapts to opponent behavior and switches between cooperation and defection based on the stock level and average cooperation rate.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / 2
        self.avg_coop_rate = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.my_actions) > 0:
            opponent_coop_rate = np.mean(np.any(history.opponent_actions, axis=1))
            self.avg_coop_rate = (self.avg_coop_rate * state.round_number + opponent_coop_rate) / (state.round_number + 1)
        if state.round_number == self.game_description.n_rounds - 1 and state.current_stock < self.stock_threshold:
            return Action.D
        if state.current_stock < self.stock_threshold or self.avg_coop_rate <= 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_520(BaseStrategy):
    """
    Adaptive Common Pool Resource Management (ACPRM) Strategy.
    
    This strategy prioritizes cooperation when the stock level is stable or increasing,
    but adapts to exploitative behavior by defecting when necessary to protect individual payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_stock = self.capacity if state.round_number == 1 else history.my_payoffs[state.round_number - 2] * 2 * self.n_players
        stock_change = state.current_stock - previous_stock
        most_players_cooperated = np.sum(history.opponent_actions[-1, :]) > self.n_players / 2
        if all((not opponent_action for opponent_action in history.opponent_actions[-1, :])) and state.current_stock < 0.1 * self.capacity:
            return Action.C
        elif np.mean(~history.opponent_actions[:, 0]) > 0.9:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if 0.25 * self.capacity <= state.current_stock < 0.75 * self.capacity:
            if most_players_cooperated:
                return Action.C
            else:
                return Action.D
        if state.current_stock >= 0.75 * self.capacity or stock_change >= 0:
            return Action.C
        elif state.current_stock < 0.25 * self.capacity:
            return Action.D

class Strategy_COLLECTIVE_521(BaseStrategy):
    """
    Adaptive Cooperative Threshold Strategy for Common Pool Resource Game.

    This strategy aims to balance individual payoffs with collective sustainability by adapting cooperation based on the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            initial_cooperation_threshold = 0.75 * self.game_description.capacity
            return Action.C if state.current_stock > initial_cooperation_threshold else Action.D
        stock_ratio = state.current_stock / self.game_description.capacity
        previous_round_opponent_actions = history.opponent_actions[-1, :] if history else []
        all_player_cooperated = all((action for action in previous_round_opponent_actions)) if previous_round_opponent_actions.size > 0 else False
        any_player_defected = not all_player_cooperated
        new_stock = state.current_stock + 2 * (state.current_stock - self.game_description.capacity) * (1 - state.current_stock / self.game_description.capacity)
        if all_player_cooperated and new_stock > 0.9 * self.game_description.capacity:
            self.cooperation_threshold += 0.05
        elif any_player_defected or new_stock < 0.5 * self.game_description.capacity:
            self.cooperation_threshold -= 0.1
        action = Action.C if stock_ratio > self.cooperation_threshold else Action.D
        consecutive_defections = history.my_actions[-2] == False and history.my_actions[-1] == False if len(history.my_actions) >= 2 else False
        all_players_cooperated_consecutively = all((all((action for action in round_history)) for round_history in history.opponent_actions[-3:, :])) if len(history.opponent_actions) >= 3 else False
        if consecutive_defections:
            action = Action.C if stock_ratio > 0.6 else Action.D
        elif all_players_cooperated_consecutively:
            action = Action.D if stock_ratio < 0.8 else Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C if state.current_stock > 0.5 * self.game_description.capacity else Action.D
        elif state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        return action

class Strategy_COLLECTIVE_522(BaseStrategy):
    """
    Collective strategy that balances individual payoffs with long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock_ratio > 0.75:
            return Action.C
        elif stock_ratio < 0.5:
            return Action.D
        elif random.random() < 0.7:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_523(BaseStrategy):
    """
    The Adaptive Stock Conservation strategy aims to balance individual payoff maximization 
    with collective stock conservation, adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.T = 0.5 * game_description.capacity
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_stock = history.my_payoffs[-1] * self.game_description.n_players * 2
        opponent_actions = np.array(history.opponent_actions)
        opponent_defections_last_round = sum((1 - action for action in opponent_actions[-1, :]))
        if state.current_stock > self.T:
            action = Action.C
        else:
            action = Action.D
        if opponent_defections_last_round > 0:
            action = Action.D
        elif all(opponent_actions[-1, :]):
            action = Action.C
        if state.round_number > 3:
            growth_rate = (state.current_stock - history.my_payoffs[-4] * self.game_description.n_players * 2) / (history.my_payoffs[-4] * self.game_description.n_players * 2)
            if growth_rate < -0.5:
                action = Action.C
        if state.round_number == self.game_description.n_rounds:
            return Action.D
        return action

class Strategy_COLLECTIVE_524(BaseStrategy):
    """
    Adaptive Collective Harvesting Strategy.

    This strategy promotes collective sustainability by adapting to changing conditions.
    It prioritizes cooperation when possible and balances individual interests with the need for collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        S = state.current_stock
        r = state.round_number
        if r < 2:
            return Action.C
        theta = S / (2 * n) * (1 - S / capacity)
        if history is not None:
            previous_coops = sum(history.opponent_actions[-1, :]) + int(bool(history.my_actions[-1]))
            if previous_coops >= n / 2:
                return Action.C
            elif random.random() < 0.5 and previous_coops == n // 2:
                return Action.C
            elif S > theta:
                return Action.C
        if r == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_525(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy.
    
    This strategy aims to balance individual self-interest with collective well-being by 
    cooperating when the stock is healthy, punishing recent defections, and conserving the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 1:
            return Action.D
        prev_round_actions = history.opponent_actions[-1, :]
        prev_round_payoffs = history.my_payoffs[-1] + np.sum(history.opponent_payoffs[-1, :])
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        recent_defections = sum((1 for action in prev_round_actions if not action))
        if recent_defections >= self.game_description.n_players / 2:
            return Action.D
        elif recent_defections == self.game_description.n_players // 2:
            return Action.C
        if prev_round_payoffs > 0.5 * self.game_description.capacity:
            return Action.C
        avg_payoff_last_3 = np.mean(history.my_payoffs[-3:])
        median_payoff_all = np.median(np.concatenate((history.my_payoffs, history.opponent_payoffs.flatten())))
        if avg_payoff_last_3 > median_payoff_all or math.isclose(avg_payoff_last_3, median_payoff_all):
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_526(BaseStrategy):
    """
    Adaptive Cooperation with Stock Conservation (ACSC) strategy.

    This strategy balances individual payoffs with collective well-being by adapting to the game's state and opponent behaviors.
    It promotes cooperation when beneficial for the group and adjusts to counter selfish behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_actions = [[] for _ in range(game_description.n_players)]
        self.selfish_opponents = set()

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (history is not None and len(history.my_payoffs) == 0):
            return Action.C
        prev_stock = self.game_description.capacity * (1 - state.current_stock / self.game_description.capacity) ** 2
        prev_cooperators = sum((1 for actions in self.opponent_actions if len(actions) > state.round_number and actions[-1]))
        for i, action in enumerate(history.opponent_actions[state.round_number - 1]):
            self.opponent_actions[i].append(action)
            if not action and prev_stock > 0.75 * self.game_description.capacity:
                self.selfish_opponents.add(i)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if prev_stock > 0.75 * self.game_description.capacity and prev_cooperators > self.game_description.n_players / 2:
            return Action.C
        elif (prev_stock >= 0.25 * self.game_description.capacity and prev_stock <= 0.75 * self.game_description.capacity) and prev_cooperators >= self.game_description.n_players / 2:
            return Action.C
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_527(BaseStrategy):
    """
    A strategy that balances individual self-interest with long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = np.sum(history.opponent_actions[:, :], axis=1)
        avg_consumption_rate = np.mean(opponent_actions / self.game_description.n_players)
        if avg_consumption_rate < 0.5:
            return Action.C
        elif 0.5 <= avg_consumption_rate <= 1.0:
            return random.choice([Action.D, Action.C])
        else:
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_528(BaseStrategy):
    """
    A collective strategy that adapts to various opponent behaviors while prioritizing sustainability and fairness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.acr = 0.0
        self.ct = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and state.round_number < 6:
            self.acr = np.mean(history.opponent_actions[-1, :])
            stock_proportion = state.current_stock / self.game_description.capacity
            if stock_proportion >= 0.5:
                self.ct = max(0.5, self.acr)
            else:
                self.ct = min(1, self.acr + 0.25)
        if history is not None and state.round_number >= 6:
            if state.current_stock > self.ct * self.game_description.capacity or (state.round_number == self.game_description.n_rounds - 1 and state.current_stock < self.game_description.capacity / 4):
                return Action.C
            elif state.round_number == self.game_description.n_rounds - 1:
                return Action.D
        return Action.D

class Strategy_COLLECTIVE_529(BaseStrategy):
    """
    The Adaptive Cooperation strategy aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_defection_rates = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock >= 0.75 * capacity:
            return Action.C
        elif 0.5 * capacity <= current_stock < 0.75 * capacity:
            if history is not None:
                opponent_defections_last_round = sum((1 - opponent_action for opponent_action in history.opponent_actions[-1, :]))
                defect_prob = opponent_defections_last_round / self.game_description.n_players * 0.2
                if random.random() < defect_prob:
                    return Action.D
            return Action.C
        elif current_stock < 0.5 * capacity:
            return Action.C
        elif state.round_number >= self.game_description.n_rounds - 2:
            return Action.C
        if history is not None and history.my_actions.size > 1:
            opponent_defections_last_two_rounds = sum((1 - opponent_action for opponent_action in history.opponent_actions[-2:, :].flatten()))
            self.opponent_defection_rates = opponent_defections_last_two_rounds / (self.game_description.n_players * 2)
        if history is not None and history.my_actions.size > 3:
            stock_trend = np.mean(history.my_payoffs[-3:]) - np.mean(history.my_payoffs[-6:-3])
            if stock_trend < 0:
                return Action.C
        return Action.C

class Strategy_COLLECTIVE_530(BaseStrategy):
    """
    Collective Strategy: "Sustainable Cooperation"
    
    This strategy balances individual payoffs with collective sustainability.
    It adapts to the current stock level and opponents' behaviors, 
    aiming to maintain a stable and sustainable common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_probability = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio > 0.75:
            action = Action.C
        elif 0.5 <= stock_ratio < 0.75:
            p = stock_ratio ** 2
            action = Action.C if random.random() < p else Action.D
        else:
            action = Action.D
        if history is not None and state.round_number > 1:
            avg_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
            player_payoff = history.my_payoffs[-1]
            if avg_opponent_payoff > player_payoff:
                self.cooperation_probability *= 0.9
            elif avg_opponent_payoff < player_payoff:
                self.cooperation_probability *= 1.1
            self.cooperation_probability = max(0, min(self.cooperation_probability, 1))
        return action

class Strategy_COLLECTIVE_531(BaseStrategy):
    """
    A collective strategy that balances individual interests with collective sustainability by adapting to changing game conditions and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if self.game_description.n_players <= 3 else Action.D
        previous_stock = state.current_stock
        current_stock = state.current_stock
        if history is not None and len(history.my_actions) > 0:
            previous_stock = self.game_description.capacity - np.sum(np.where(history.opponent_actions[0, :], self.game_description.capacity / (2 * self.game_description.n_players), self.game_description.capacity / self.game_description.n_players))
            for i in range(1, state.round_number):
                total_consumption = np.sum(np.where(history.opponent_actions[i, :], self.game_description.capacity / (2 * self.game_description.n_players), self.game_description.capacity / self.game_description.n_players)) + (self.game_description.capacity / (2 * self.game_description.n_players) if history.my_actions[i - 1] else self.game_description.capacity / self.game_description.n_players)
                stock_after_consumption = previous_stock - total_consumption
                growth = 2 * stock_after_consumption * (1 - stock_after_consumption / self.game_description.capacity)
                new_stock = min(stock_after_consumption + growth, self.game_description.capacity)
                previous_stock = new_stock
        significant_decrease = current_stock < 0.8 * previous_stock if history is not None else False
        opponents_defected = any(np.logical_not(history.opponent_actions[-1, :])) if history is not None and len(history.my_actions) > 0 else True
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.C if current_stock < 0.2 * self.game_description.capacity else Action.D
        if significant_decrease or opponents_defected:
            return Action.D
        elif current_stock > 0.5 * self.game_description.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_532(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Threshold (ACST) strategy.
    
    This strategy aims to balance individual payoff maximization with collective sustainability 
    by adaptively cooperating based on the current stock level and history of opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        capacity = self.game_description.capacity
        stock = state.current_stock
        if stock < 0.01 * capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        p = (stock / capacity) ** 2
        opponent_actions = history.opponent_actions[-1, :]
        majority_defected = sum((1 for action in opponent_actions if not action)) > len(opponent_actions) // 2
        majority_cooperated = sum((1 for action in opponent_actions if action)) > len(opponent_actions) // 2
        if majority_defected:
            p -= 0.1
        elif majority_cooperated:
            p += 0.1
        p = max(0, min(p, 1))
        if stock >= 0.75 * capacity:
            return Action.C
        elif stock < 0.25 * capacity:
            return Action.D
        else:
            return Action.C if random.random() < p else Action.D

class Strategy_COLLECTIVE_533(BaseStrategy):
    """
    Adaptive Stock Preservation (ASP) strategy aims to balance individual payoffs with long-term sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number > 0 and history.opponent_actions.shape[0] > 0:
            opponent_cooperations = sum(history.opponent_actions[-1, :])
            cooperation_quotient = opponent_cooperations / self.game_description.n_players
            if state.current_stock <= self.game_description.capacity / 2 or state.round_number == self.game_description.n_rounds - 1:
                return Action.C
            elif cooperation_quotient >= 0.5:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_534(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Dependent Threshold Strategy.
    
    This strategy balances individual payoffs with collective sustainability by adapting cooperation levels based on the current stock level and game history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        prev_round_consumption = sum(np.where(history.opponent_actions[-1, :], self.capacity / self.game_description.n_players, self.capacity / (2 * self.game_description.n_players)))
        threshold = self.capacity * (1 - prev_round_consumption / self.capacity)
        if state.current_stock < 0.25 * self.capacity:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_535(BaseStrategy):
    """
    Adaptive Stock Conservation Strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_ratio_thresholds = [0.5, 0.75]
        self.probability_cooperate = 0.7
        self.opponent_defect_rate_influence = -0.2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        if history is not None:
            recent_stock_levels = [history.my_payoffs[-i - 1] * 2 * self.game_description.n_players for i in range(min(3, len(history.my_payoffs)))]
            stock_trend_stable_or_increasing = all((recent_stock_levels[i + 1] >= recent_stock_levels[i] for i in range(len(recent_stock_levels) - 1)))
            if stock_trend_stable_or_increasing:
                self.probability_cooperate += 0.1
                self.probability_cooperate = min(self.probability_cooperate, 1)
        if history is not None:
            opponent_defect_rate = np.mean(1 - history.opponent_actions[:, 0])
            if opponent_defect_rate > 0.6:
                self.probability_cooperate += self.opponent_defect_rate_influence * opponent_defect_rate
        if stock_ratio > self.stock_ratio_thresholds[1]:
            return Action.C
        elif self.stock_ratio_thresholds[0] <= stock_ratio <= self.stock_ratio_thresholds[1]:
            return Action.C if random.random() < self.probability_cooperate else Action.D
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_536(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy for Common Pool Resource Game.
    
    Balances individual payoffs with collective sustainability by adaptively responding to game state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defect_probability = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        prev_round_actions = history.opponent_actions[-1, :]
        num_opponents_defected = sum((1 for a in prev_round_actions if not a))
        if num_opponents_defected > self.game_description.n_players // 2:
            self.defect_probability += 0.2
        elif num_opponents_defected < self.game_description.n_players // 2:
            self.defect_probability -= 0.1
        self.defect_probability = max(0.0, min(self.defect_probability, 1.0))
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        elif state.current_stock >= 0.5 * self.game_description.capacity:
            return Action.D if random.random() < self.defect_probability else Action.C
        else:
            return Action.C

class Strategy_COLLECTIVE_537(BaseStrategy):
    """
    A strategy that balances individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        if state.round_number == 0 or history is None:
            return Action.C
        conservation_threshold = 0.75 * capacity
        alarm_threshold = 0.25 * capacity
        avg_payoff_recent = np.mean(history.my_payoffs[-3:])
        max_payoff_per_round = capacity / (2 * n_players)
        if state.current_stock > conservation_threshold:
            return Action.C
        elif state.current_stock < alarm_threshold:
            return Action.D
        if avg_payoff_recent > 0.8 * max_payoff_per_round:
            return Action.C
        else:
            total_consumption = np.sum(history.my_actions[-3:] == Action.D) + np.sum(np.any(history.opponent_actions[-3:], axis=1))
            stock_depletion_rate = total_consumption / 3 * capacity / n_players
            avg_stock_depletion_recent = state.current_stock - (capacity - stock_depletion_rate)
            if avg_stock_depletion_recent < capacity * 0.8:
                return Action.D
            coop_count_prev = np.sum(history.opponent_actions[-1, :] == Action.C)
            if coop_count_prev > n_players // 2:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_538(BaseStrategy):
    """
    This strategy adapts to various opponent behaviors and aligns with the collective mindset.
    It initially cooperates, then adapts based on stock level and opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        opponents_cooperated = sum(history.opponent_actions[-1, :])
        if history.my_payoffs.size > 0:
            if history.my_payoffs[-1] == self.game_description.capacity / (2 * self.game_description.n_players) and history.opponent_actions[-1].any() == False:
                return Action.D
        elif opponents_cooperated > 0 and stock_level < 0.75:
            return Action.C
        if stock_level > 0.75:
            if opponents_cooperated > self.game_description.n_players / 2:
                return Action.C
            else:
                return Action.D
        elif 0.5 <= stock_level <= 0.75:
            if opponents_cooperated >= 1:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_539(BaseStrategy):
    """
    A collective strategy that prioritizes cooperation when the stock level is high,
    and adapts by introducing a probabilistic defect mechanism as the stock level decreases.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        elif stock_ratio < 0.25:
            return Action.D
        if stock_ratio > 0.75:
            return Action.C
        elif stock_ratio >= 0.5 and stock_ratio <= 0.75:
            num_defectors_prev_round = sum((not action for action in history.opponent_actions[-1, :]))
            defect_prob = num_defectors_prev_round / self.game_description.n_players
            return Action.D if random.random() < defect_prob else Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_540(BaseStrategy):
    """
    A collective strategy to balance individual payoffs with collective sustainability 
    in a common pool resource game by adapting Tit-for-Tat to consider stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        prev_round_actions = history.opponent_actions[-1, :]
        num_cooperators = sum(prev_round_actions)
        if num_cooperators > self.n_players / 2:
            action = Action.C
        else:
            action = Action.D
        if state.current_stock < self.capacity * 0.5:
            action = Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > self.capacity * 0.5:
                action = Action.C
            else:
                action = Action.D
        return action

class Strategy_COLLECTIVE_541(BaseStrategy):
    """
    A strategy that adapts to the game's progress and stock levels, 
    balancing individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock >= self.game_description.capacity / 2 else Action.D
        prev_total_consumption = sum(self.get_consumptions(history, state.round_number - 1))
        if prev_total_consumption <= self.game_description.capacity / 2:
            avg_payoff = np.mean([payoff for payoff in history.my_payoffs] + [payoff for payoffs in history.opponent_payoffs for payoff in payoffs])
            return Action.C if history.my_payoffs[-1] >= avg_payoff else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < self.game_description.capacity / 4:
            if state.round_number == 0 and state.current_stock == self.game_description.capacity / 2:
                return Action.C
            return Action.D
        return Action.C if state.current_stock >= self.game_description.capacity / 4 else Action.D

    def get_consumptions(self, history: PlayerHistory, round_number: int):
        cooperators = sum((1 for action in history.opponent_actions[round_number] + [history.my_actions[round_number]] if action))
        return [self.game_description.capacity / (2 * self.game_description.n_players) if action else self.game_description.capacity / self.game_description.n_players for action in history.opponent_actions[round_number] + [history.my_actions[round_number]]]

class Strategy_COLLECTIVE_542(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Awareness (ACSA) strategy.

    This strategy aims to balance individual self-interest with collective sustainability.
    It adapts cooperation based on current stock levels, past payoffs, and opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_defected_last_round = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_payoff_coop = self.game_description.capacity / (2 * self.game_description.n_players)
        low_stock_level = state.current_stock < 0.1 * self.game_description.capacity
        opponent_defections_last_round = sum(history.opponent_actions[-1, :]) > self.game_description.n_players / 2
        avg_previous_payoff = np.mean(history.my_payoffs)
        stock_threshold = 0.5 * self.game_description.capacity
        if state.current_stock >= stock_threshold and avg_previous_payoff >= avg_payoff_coop:
            return Action.C
        elif low_stock_level or opponent_defections_last_round or (self.opponent_defected_last_round and state.round_number < self.game_description.n_rounds - 1):
            self.opponent_defected_last_round = True
            return Action.D
        elif history is not None and sum(history.opponent_actions[-1, :]) > 0:
            self.opponent_defected_last_round = True
            return Action.D
        else:
            self.opponent_defected_last_round = False
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_543(BaseStrategy):
    """
    Adaptive Cooperation with Stock-based Trigger (ACST) strategy.
    
    This strategy aims to balance individual payoffs with collective sustainability 
    by adapting cooperation based on the current stock level and the history of opponent actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.low_stock_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        num_defectors_prev = self.game_description.n_players - sum(history.opponent_actions[-1, :])
        if state.current_stock < 0.5 * self.game_description.capacity:
            self.low_stock_rounds += 1
        else:
            self.low_stock_rounds = 0
        p_defect = 0.0
        if num_defectors_prev > self.game_description.n_players / 2:
            p_defect += 0.2
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        elif state.current_stock >= 0.25 * self.game_description.capacity and state.current_stock < 0.75 * self.game_description.capacity:
            p_cooperate = (state.current_stock / self.game_description.capacity) ** 2
            return Action.C if random.random() < p_cooperate else Action.D
        elif self.low_stock_rounds >= 3:
            return Action.D
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_544(BaseStrategy):
    """
    Adaptive Cooperation strategy that balances individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.sdr_threshold = 0.2
        self.payoff_differential_threshold = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        sdr = self.calculate_stock_depletion_rate(state, history)
        if sdr < self.sdr_threshold:
            return Action.C
        d_prev = sum((1 for action in history.opponent_actions[-1, :] if not action))
        if d_prev > self.game_description.n_players / 2:
            return Action.D
        pd = self.calculate_payoff_differential(state, history)
        if pd > self.payoff_differential_threshold:
            self.sdr_threshold += 0.05
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.2 * self.game_description.capacity:
            return Action.C
        return Action.D

    def calculate_stock_depletion_rate(self, state: CommonPoolState, history: PlayerHistory):
        stock_decreases = []
        for i in range(max(0, state.round_number - 3), state.round_number):
            total_consumption = self.calculate_total_consumption(state.current_stock if i == state.round_number else history.my_payoffs[i], history.opponent_actions[i])
            stock_decrease = total_consumption / self.game_description.capacity
            stock_decreases.append(stock_decrease)
        return np.mean(stock_decreases)

    def calculate_total_consumption(self, current_stock: float, opponent_actions):
        total_consumption = 0
        for action in opponent_actions:
            if not action:
                total_consumption += current_stock / self.game_description.n_players
            else:
                total_consumption += current_stock / (2 * self.game_description.n_players)
        return total_consumption

    def calculate_payoff_differential(self, state: CommonPoolState, history: PlayerHistory):
        payoff_c = history.my_payoffs[-1]
        payoff_d = 0
        for i in range(max(0, state.round_number - 3), state.round_number):
            if not history.opponent_actions[i, :].all():
                payoff_d += history.my_payoffs[i] * (self.game_description.n_players / (2 * self.game_description.n_players - 1))
        return payoff_c - payoff_d

class Strategy_COLLECTIVE_545(BaseStrategy):
    """
    Adaptive Cooperation with Stock Threshold strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.7 * game_description.capacity
        self.defectors_prev = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        if current_stock > self.stock_threshold:
            action = Action.C
        else:
            opponent_defections = sum((1 for opponent_action in history.opponent_actions[-1, :] if not opponent_action))
            self.defectors_prev = opponent_defections
            if opponent_defections > self.game_description.n_players / 2:
                action = Action.D
            elif current_stock < 0.2 * self.game_description.capacity:
                action = Action.C
            else:
                action = Action.C
        if history is not None and history.my_actions.size > 1:
            opponent_defected_twice = sum((1 for i in range(-2, 0) if not history.opponent_actions[i, 0]))
            if opponent_defected_twice == 2:
                action = Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        return action

class Strategy_COLLECTIVE_546(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and prioritizes sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.r = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock >= 0.75 * self.capacity else Action.D
        stock_level = state.current_stock
        avg_consumption_rate = self._calculate_average_consumption(history)
        if state.round_number <= self.r // 4:
            return Action.C if stock_level >= 0.75 * self.capacity else Action.D
        elif self.r // 4 < state.round_number < 3 * self.r // 4:
            if avg_consumption_rate < 0.5 * self.capacity:
                return Action.C
            else:
                defect_probability = (stock_level / self.capacity) ** 2
                return random.choice([Action.D, Action.C], p=[defect_probability, 1 - defect_probability])
        elif stock_level < 0.25 * self.capacity:
            return Action.C
        else:
            return Action.C if avg_consumption_rate < 0.5 * self.capacity else random.choice([Action.D, Action.C], p=[(stock_level / self.capacity) ** 2, 1 - (stock_level / self.capacity) ** 2])
        if state.round_number == self.r:
            return Action.D

    def _calculate_average_consumption(self, history: PlayerHistory):
        last_round_opponent_actions = history.opponent_actions[-1, :]
        opponents_defecting_last_round = sum((1 - action for action in last_round_opponent_actions))
        avg_consumption_rate = (opponents_defecting_last_round * self.capacity / self.game_description.n_players + sum((action for action in last_round_opponent_actions)) * 0.5 * self.capacity / self.game_description.n_players) / self.capacity
        return avg_consumption_rate

class Strategy_COLLECTIVE_547(BaseStrategy):
    """
    This strategy balances short-term gains with long-term sustainability, 
    adapting to the evolving game state and history while maintaining a collective mindset.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if self.game_description.capacity > 150 * self.game_description.n_players:
                return Action.C
            else:
                return Action.D
        safety_threshold = 0.75 * self.game_description.capacity
        if history is not None:
            opponent_actions_prev_round = history.opponent_actions[-1, :]
            cooperators_prev_round = sum(opponent_actions_prev_round) + (history.my_actions[-1] == True)
            if state.current_stock > safety_threshold and cooperators_prev_round >= self.game_description.n_players / 2:
                return Action.C
            else:
                return Action.D
        fair_share_threshold = 0.5 * self.game_description.capacity
        total_payoff = sum(history.my_payoffs)
        if state.round_number > self.game_description.n_rounds // 2:
            if total_payoff > fair_share_threshold and state.current_stock >= state.current_stock / (2 * self.game_description.n_players):
                return Action.C
            else:
                return Action.D
        if history is not None:
            opponent_payoffs_prev_round = history.opponent_payoffs[-1, :]
            my_payoff_prev_round = history.my_payoffs[-1]
            if np.any(np.isclose(opponent_payoffs_prev_round, my_payoff_prev_round)) or state.current_stock < 0.25 * self.game_description.capacity:
                return Action.D
        return Action.C

class Strategy_COLLECTIVE_548(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.payoff_threshold_percentage = 0.8
        self.delta_T = 0.01 * self.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round_payoffs = history.my_payoffs[-1] if len(history.my_payoffs) > 0 else 0
        total_consumption = sum((self.get_consumption(state.current_stock, action) for action in self.get_opponent_actions(history)))
        stock_dependent_cooperation_threshold = self.capacity * (1 - total_consumption / self.capacity)
        if state.current_stock > stock_dependent_cooperation_threshold and previous_round_payoffs >= self.get_min_payoff():
            return Action.C
        elif any((self.is_defection(action) for action in self.get_opponent_actions(history))) or state.current_stock <= stock_dependent_cooperation_threshold:
            return Action.D
        return Action.C

    def get_consumption(self, current_stock: float, action: bool) -> float:
        if action:
            return current_stock / (2 * self.n_players)
        else:
            return current_stock / self.n_players

    def get_opponent_actions(self, history: PlayerHistory) -> list[bool]:
        if len(history.opponent_actions) == 0:
            return [False] * self.n_players
        else:
            return history.opponent_actions[-1]

    def is_defection(self, action: bool) -> bool:
        return not action

    def get_min_payoff(self) -> float:
        return self.payoff_threshold_percentage * (self.capacity / (2 * self.n_players))

class Strategy_COLLECTIVE_549(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Trigger (ACS-T) strategy.
    
    This strategy adapts to changes in the environment by adjusting a threshold based on the stock level,
    and defects only when necessary to avoid losses or catastrophic depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        """
        Initialize the ACS-T strategy.

        Args:
            game_description (CommonPoolDescription): Description of the common pool resource game.
        """
        self.game_description = game_description
        self.stock_threshold = 0.8 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        """
        Decide the action based on the current state and history.

        Args:
            state (CommonPoolState): The current state of the game.
            history (None | PlayerHistory): The history of the game.

        Returns:
            Action: The chosen action, either COOPERATE or DEFECT.
        """
        if state.round_number == 0:
            return Action.C
        recent_rounds = min(len(history.my_actions), 5)
        self.stock_threshold = (self.stock_threshold + sum([history.opponent_payoffs[-i, -1] for i in range(1, recent_rounds)])) / (recent_rounds + 1)
        previous_round_defections = sum(~history.opponent_actions[-1, :])
        if previous_round_defections > self.game_description.n_players // 2 or state.current_stock < 0.2 * self.game_description.capacity:
            return Action.D
        if state.current_stock > self.stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_550(BaseStrategy):
    """
    A collective strategy that balances individual payoff with collective sustainability by adapting to the current state of the stock and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defect_probability = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choices([Action.C, Action.D], weights=[0.5, 0.5])[0]
        stock_ratio = state.current_stock / self.game_description.capacity
        opponent_defection_rate = sum(history.opponent_actions[-1, :]) / self.game_description.n_players
        if stock_ratio > 0.75:
            action = random.choices([Action.C, Action.D], weights=[0.7, 0.3])[0]
        elif 0.5 <= stock_ratio <= 0.75:
            action = random.choices([Action.C, Action.D], weights=[0.5, 0.5])[0]
        else:
            action = random.choices([Action.C, Action.D], weights=[0.3, 0.7])[0]
        if opponent_defection_rate > 0.5:
            action = random.choices([Action.C, Action.D], weights=[0.2, 0.8])[0]
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.round_number < 5:
            return random.choices([Action.C, Action.D], weights=[0.6, 0.4])[0]
        elif state.round_number > self.game_description.n_rounds / 2:
            self.defect_probability = min(0.8, self.defect_probability + 0.1)
            action = random.choices([Action.C, Action.D], weights=[1 - self.defect_probability, self.defect_probability])[0]
        return action

class Strategy_COLLECTIVE_551(BaseStrategy):
    """
    A dynamic strategy that adapts to the game state and history, balancing individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n = self.game_description.n_players
        r = self.game_description.n_rounds
        capacity = self.game_description.capacity
        SBT = capacity / (2 * n * (r - state.round_number + 1))
        if state.round_number == r - 1:
            return Action.D
        low_stock_threshold = 0.2 * capacity
        if state.current_stock < low_stock_threshold:
            return Action.D
        opponent_cooperation_rate = np.mean(history.opponent_actions[-1, :])
        if opponent_cooperation_rate > 0.7:
            SBT *= 0.9
        elif opponent_cooperation_rate < 0.3:
            SBT *= 1.1
        if state.current_stock >= SBT:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_552(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource game that balances individual payoffs with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.tau = 0.5 * game_description.n_players / game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number >= self.game_description.n_rounds - 1:
            return Action.C
        opponent_defection_rates = np.mean(history.opponent_actions[-(self.game_description.n_rounds // 2):, :], axis=0)
        for i, delta in enumerate(opponent_defection_rates):
            if delta > 0.5:
                return Action.D
        my_payoffs = history.my_payoffs
        opponent_payoffs = history.opponent_payoffs
        avg_my_payoff = np.mean(my_payoffs[-(self.game_description.n_rounds // 4):])
        group_avg_payoff = np.mean(opponent_payoffs[-(self.game_description.n_rounds // 4):, :])
        if avg_my_payoff < group_avg_payoff * 0.9:
            return Action.D
        return Action.C if state.current_stock >= self.tau * self.game_description.capacity else Action.D

class Strategy_COLLECTIVE_553(BaseStrategy):
    """
    A strategy that aims to balance individual payoffs with collective sustainability 
    by adapting cooperation levels based on the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        n_C = sum(history.opponent_actions[-1, :]) + (history.my_actions[-1] == True)
        theta = self.game_description.capacity / (2 * self.game_description.n_players) * (1 + n_C / self.game_description.n_players)
        phi = 0.1 * self.game_description.capacity
        if state.current_stock > theta and state.current_stock > phi:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_554(BaseStrategy):
    """
    Adaptive Sustainability strategy for Common Pool Resource Game.
    
    Balances individual payoff maximization with sustainable stock management 
    by adapting cooperation levels based on current stock levels and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_probability = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.my_actions) > 0:
            avg_opponent_action = np.mean(history.opponent_actions[-1, :])
            self.cooperation_probability = max(0, min(self.cooperation_probability + (avg_opponent_action - 0.5) * 0.2, 1))
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio > 0.75:
            return Action.C
        elif 0.5 <= stock_ratio < 0.75:
            return Action.C if random.random() < stock_ratio ** 2 else Action.D
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C

class Strategy_COLLECTIVE_555(BaseStrategy):
    """
    Adaptive Collective Harvesting strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        round_number = state.round_number
        if round_number == 0:
            return Action.C
        current_stock = state.current_stock
        last_round_payoffs = history.my_payoffs[-1]
        average_last_round_payoff = np.mean(last_round_payoffs)
        max_payoff = capacity / (2 * n_players)
        threshold_payoff = 0.5 * max_payoff
        if current_stock > 0.75 * capacity:
            return Action.C
        elif 0.25 * capacity <= current_stock <= 0.75 * capacity:
            if average_last_round_payoff < threshold_payoff:
                return Action.D
            else:
                return Action.C
        elif current_stock < 0.25 * capacity:
            return Action.D
        elif round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_556(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Threshold (ACS-T)
    
    This strategy balances individual and collective interests by adapting cooperation based on stock levels and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.min_stock = game_description.capacity / (4 * game_description.n_players)
        self.coop_count = 0
        self.avg_payoff_prev_round = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < 2 or history is None:
            return Action.C
        avg_payoff_curr_round = np.mean(history.my_payoffs[-1] + history.opponent_payoffs[-1, :])
        T = (state.current_stock + avg_payoff_curr_round * self.game_description.capacity / (2 * self.game_description.n_players)) / 2
        if state.round_number > 0:
            opponent_coops = np.sum(history.opponent_actions[-1, :] == True)
            self.coop_count += opponent_coops
        if state.current_stock < self.min_stock or state.round_number >= self.game_description.n_rounds - 1:
            return Action.D
        coop_prob = min(1, self.coop_count / self.game_description.n_players)
        action = random.choices([Action.C, Action.D], weights=[coop_prob, 1 - coop_prob])[0]
        return action if state.current_stock > T else Action.D

class Strategy_COLLECTIVE_557(BaseStrategy):
    """
    Adaptive Stock Conservation Strategy.
    
    This strategy prioritizes cooperation when the common pool is relatively healthy 
    and adapts to potential exploitation by others. By introducing randomness in response 
    to single defections, it creates an element of unpredictability while maintaining a 
    collective focus on stock conservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_defection_threshold_reached = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number + 1 == self.game_description.n_rounds:
            return Action.D
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.D
        defectors = sum(1 - history.opponent_actions[-1, :])
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        elif defectors >= 2 or state.current_stock < 0.25 * self.game_description.capacity:
            self.last_round_defection_threshold_reached = True
            return Action.D
        elif defectors == 1 and (not self.last_round_defection_threshold_reached):
            if random.random() < 0.5:
                return Action.C
            else:
                return Action.D
        elif all(history.my_actions[-3:] == True):
            return Action.C
        self.last_round_defection_threshold_reached = False
        return Action.D

class Strategy_COLLECTIVE_558(BaseStrategy):
    """
    A strategy that balances individual payoffs with collective sustainability by adapting to changing stock levels and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        opponent_defections = sum((not action for action in history.opponent_actions[-1, :]))
        if opponent_defections > self.game_description.n_players / 2:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_559(BaseStrategy):
    """
    Collective Strategy: Adaptive Tit-for-Two-Tats (ATFT).
    
    This strategy balances short-term gains with long-term sustainability of the common pool resource.
    It prioritizes collective well-being over individual short-term gains by cooperating when the stock level is high or medium,
    and encouraging opponents to cooperate when the stock level is low.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        opponent_actions_history = [actions for actions in history.opponent_actions]
        if state.current_stock >= 0.75 * self.capacity:
            return Action.C
        elif 0.5 * self.capacity <= state.current_stock < 0.75 * self.capacity:
            most_recent_round_opponents = opponent_actions_history[-1]
            most_opponents_cooperated = sum(most_recent_round_opponents) / len(most_recent_round_opponents) > 0.5
            return Action.C if most_opponents_cooperated else Action.D
        else:
            last_two_rounds_opponents = opponent_actions_history[-2:]
            at_least_two_cooperated = sum((sum(round) for round in last_two_rounds_opponents)) / (2 * len(last_two_rounds_opponents[0])) >= 0.5
            return Action.C if at_least_two_cooperated else Action.D

class Strategy_COLLECTIVE_560(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Sensitive Tit-for-Tat (ACST) strategy.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        elif state.current_stock / self.game_description.capacity > 0.75:
            return Action.C
        elif state.current_stock / self.game_description.capacity >= 0.5:
            opponent_defected = np.any(~history.opponent_actions[-1, :])
            if opponent_defected:
                return Action.D
            else:
                return Action.C
        else:
            all_cooperated = np.all(history.opponent_actions[-1, :])
            if all_cooperated and history.my_actions[-1]:
                return Action.C
            elif state.round_number == self.game_description.n_rounds - 1:
                return Action.D
            else:
                return Action.D

class Strategy_COLLECTIVE_561(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Aware Tit-for-Tat (ACSTAT) strategy.
    
    This strategy adapts to the stock levels and opponents' actions, balancing individual interests with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        prev_total_consumption = sum(history.my_payoffs[-1] + history.opponent_payoffs[-1, :])
        stock_level = state.current_stock
        if stock_level < 0.25 * self.game_description.capacity:
            return Action.D
        elif stock_level > 0.75 * self.game_description.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if prev_total_consumption < 0.5 * self.game_description.capacity:
            return Action.C
        elif prev_total_consumption > 0.75 * self.game_description.capacity:
            return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        most_common_opponent_action = np.bincount(opponent_actions.astype(int)).argmax()
        if most_common_opponent_action == 0:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_562(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperate-Defect (ACD)
    
    ACD balances individual payoff maximization with collective sustainability, 
    adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        capacity = self.game_description.capacity
        stock_level = state.current_stock / capacity
        prev_coop = np.sum(history.opponent_actions[-1, :]) / (self.game_description.n_players - 1)
        if stock_level >= 0.75:
            return Action.C
        elif 0.25 <= stock_level < 0.75:
            if prev_coop >= 0.5:
                return Action.C
            else:
                return Action.D
        elif stock_level < 0.25:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if stock_level >= 0.5:
                return Action.C
            else:
                return Action.D
        all_defected = np.all(history.opponent_actions[-1, :] == False)
        low_stock_critical = state.current_stock < 0.1 * capacity
        if all_defected and low_stock_critical:
            return Action.C
        cooperation_payoff = self.calculate_cooperation_payoff(stock_level)
        average_payoff = self.calculate_average_payoff(history.my_payoffs, history.opponent_payoffs)
        if cooperation_payoff < 0.1 * average_payoff:
            return Action.D

    def calculate_cooperation_payoff(self, stock_level: float) -> float:
        """
        Calculate the payoff for cooperating in a given round.
        
        Payoff = S / (2n)
        """
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        return stock_level * capacity / (2 * n_players)

    def calculate_average_payoff(self, my_payoffs: NDArray[np.float64], opponent_payoffs: NDArray[np.float64]) -> float:
        """
        Calculate the average payoff over all players and rounds.
        
        Average Payoff = Σ(my_payoffs + opponent_payoffs) / (n_players * n_rounds)
        """
        total_payoffs = np.sum(my_payoffs) + np.sum(opponent_payoffs)
        n_players = self.game_description.n_players
        return total_payoffs / (n_players * len(my_payoffs))

class Strategy_COLLECTIVE_563(BaseStrategy):
    """
    Collective strategy that prioritizes collective well-being by conserving stock when necessary,
    adapting to opponents' behaviors, promoting cooperation when beneficial, and avoiding over-depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_rounds = game_description.n_rounds

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C if random.random() < 0.5 else Action.D
        avg_cooperator_payoff = np.mean([payoff for payoff, action in zip(history.opponent_payoffs[-1], history.opponent_actions[-1]) if action])
        avg_defector_payoff = np.mean([payoff for payoff, action in zip(history.opponent_payoffs[-1], history.opponent_actions[-1]) if not action])
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        elif avg_cooperator_payoff > avg_defector_payoff:
            return Action.C
        else:
            defect_prob = 0.5 + (avg_defector_payoff - avg_cooperator_payoff) / (2 * self.game_description.capacity)
            return Action.D if random.random() < defect_prob else Action.C
        if state.round_number == self.total_rounds:
            return Action.C
        if state.current_stock == 0:
            return Action.D
        return Action.C

class Strategy_COLLECTIVE_564(BaseStrategy):
    """
    A collective strategy that balances individual short-term gains with long-term sustainability of the common pool resource.
    It adapts to the game state and history, cooperating when possible and defecting when necessary to maintain a stable stock level.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.action_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if len(self.stock_history) < state.round_number + 1:
            self.stock_history.append(state.current_stock)
        if state.round_number == 0:
            return Action.C
        if state.current_stock > 0.75 * self.game_description.capacity:
            return Action.C
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        recent_cooperation_rate = sum((1 for action in self.action_history[-3:] if action == Action.C)) / 3
        if recent_cooperation_rate > 0.6:
            return Action.C
        else:
            return Action.D
        cooperation_probability = 0.5
        if len(self.stock_history) >= 2 and self.stock_history[-1] > self.stock_history[-2]:
            cooperation_probability += 0.1
        elif len(self.stock_history) >= 2 and self.stock_history[-1] < self.stock_history[-2]:
            cooperation_probability -= 0.1
        if random.random() < cooperation_probability:
            self.action_history.append(Action.C)
            return Action.C
        else:
            self.action_history.append(Action.D)
            return Action.D

class Strategy_COLLECTIVE_565(BaseStrategy):
    """
    Collective Strategy: Adaptive Tit-for-Tat with Stock-Based Threshold (ATTS)
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity * (1 - 1 / game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock >= self.stock_threshold and state.round_number != self.game_description.n_rounds - 1:
            opponent_defectors = sum((1 for action in history.opponent_actions[-1, :] if not action))
            if opponent_defectors > 0:
                return Action.D
            else:
                return Action.C
        elif state.current_stock < self.stock_threshold or state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_566(BaseStrategy):
    """
    The Adaptive Stock Guardian strategy aims to balance individual payoffs with collective sustainability 
    by adaptively responding to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock <= 0:
            return Action.C
        capacity = self.game_description.capacity
        current_stock_percentage = state.current_stock / capacity
        if current_stock_percentage >= 0.75:
            return Action.C
        elif 0.5 <= current_stock_percentage < 0.75:
            p = current_stock_percentage ** 2
            return Action.C if random.random() < p else Action.D
        else:
            return Action.D

class Strategy_COLLECTIVE_567(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Awareness (ACSA) strategy.
    
    This collective strategy balances individual interests with collective well-being by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        theta = 0.5 + 1 / self.game_description.n_players * (self.game_description.n_rounds / 2)
        stock_fraction = state.current_stock / self.game_description.capacity
        if stock_fraction > theta and (any((not opponent for opponent in history.opponent_actions[-1, :])) or state.current_stock >= 2 * self.game_description.n_players * (state.current_stock / (2 * self.game_description.n_players))):
            return Action.C
        elif sum((1 for opponent in history.opponent_actions[-1, :] if not opponent)) > 1 and state.current_stock < self.game_description.n_players * (state.current_stock / self.game_description.n_players):
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_568(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Threshold (ACST) Strategy.

    This strategy encourages cooperation when the stock level is sustainably managed,
    adjusts to opponents' behavior through the selfishness factor, and maintains a positive reputation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        total_consumption_prev_round = self.calculate_total_consumption(history, state)
        stock_threshold = 0.75 * state.current_stock
        if history:
            number_of_defectors_prev_round = sum((not action for action in history.opponent_actions[-1, :]))
            selfishness_factor = number_of_defectors_prev_round / self.game_description.n_players
            stock_threshold_adjusted = stock_threshold * (1 - selfishness_factor)
        if total_consumption_prev_round < stock_threshold_adjusted:
            return Action.C
        else:
            return Action.D

    def calculate_total_consumption(self, history: None | PlayerHistory, state: CommonPoolState) -> float:
        """
        Calculate total consumption in the previous round based on player actions and current stock level.

        :param history: The game history.
        :param state: The current game state.
        :return: Total consumption in the previous round.
        """
        if not history:
            return 0.0
        cooperators = sum((action for action in [Action.C] + list(history.opponent_actions[-1, :])))
        defectors = self.game_description.n_players - cooperators
        if state.current_stock == 0:
            return 0.0
        else:
            return state.current_stock / (2 * self.game_description.n_players) * cooperators + state.current_stock / self.game_description.n_players * defectors

    @staticmethod
    def handle_edge_cases(state: CommonPoolState, history: None | PlayerHistory, action: Action) -> Action:
        """
        Handle edge cases such as critically low stock levels or tie situations.

        :param state: The current game state.
        :param history: The game history.
        :param action: The proposed action.
        :return: Adjusted action based on edge case logic.
        """
        if state.current_stock < 2 * self.game_description.n_players:
            return Action.D
        if history and sum(history.opponent_actions[-1, :]) == self.game_description.n_players // 2:
            return Action.C
        return action

class Strategy_COLLECTIVE_569(BaseStrategy):
    """
    An adaptive and robust collective strategy for the Common Pool Resource Game.
    
    This strategy balances individual self-interest with collective well-being by adapting to changing circumstances and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock < 0.25 * capacity:
            return Action.D
        opponent_coop_ratio = np.mean(history.opponent_actions[-1, :])
        if opponent_coop_ratio > 0.5:
            action = Action.C
        else:
            action = Action.D
        rounds_considered = min(3, state.round_number)
        avg_stock_change = np.mean(np.diff(history.my_payoffs[-rounds_considered:]))
        if avg_stock_change >= 0:
            action = Action.C
        else:
            action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return action

class Strategy_COLLECTIVE_570(BaseStrategy):
    """
    A strategy that balances individual self-interest with collective sustainability by adapting cooperation levels based on the current stock level and historical observations.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        T = self.game_description.capacity / (2 * self.game_description.n_players) * (1 - state.current_stock / self.game_description.capacity)
        prev_consumption = sum((state.current_stock - history.my_payoffs[-1] for _ in range(self.game_description.n_players)))
        opponent_actions = history.opponent_actions[-1, :]
        if prev_consumption < T:
            return Action.C
        if any((not a for a in opponent_actions[-2:])):
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock < self.game_description.capacity * 0.5:
                return Action.D
            else:
                return Action.C
        return Action.D

class Strategy_COLLECTIVE_571(BaseStrategy):
    """
    Adaptive Stock Conservation strategy balances individual payoffs with long-term sustainability.
    It adapts to the current stock level, opponents' behaviors, and remaining rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity * (1 - (game_description.n_players - 1) / game_description.n_players)
        self.cr_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.current_stock < self.stock_threshold:
            return Action.D
        opponent_cr = np.mean(history.opponent_actions, axis=0)
        cr_avg = np.mean(opponent_cr)
        cooperation_probability = state.current_stock / self.game_description.capacity * (1 - (self.game_description.n_players - 1) / self.game_description.n_players) * (cr_avg + 0.5)
        if random.random() < cooperation_probability:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_COLLECTIVE_572(BaseStrategy):
    """
    The ASC strategy balances individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.avg_payoff = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and len(history.my_payoffs) > 1:
            self.avg_payoff = np.mean(history.my_payoffs[-2:])
        if state.round_number < 5:
            return Action.C if state.current_stock > 0.75 * self.game_description.capacity else Action.D
        elif self.avg_payoff < 0.5 * self.game_description.capacity:
            return Action.D
        else:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.C if state.current_stock > 0.25 * self.game_description.capacity else Action.D
        if state.current_stock == 0:
            return Action.D
        elif state.current_stock > 0.9 * self.game_description.capacity:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_574(BaseStrategy):
    """
    Adaptive Cooperation with Dynamic Threshold (ACDT) strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_adjustment_factor = 0.1
        self.avg_growth_window_size = 5
        self.coop_rate_threshold = 0.7

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        T = self.game_description.capacity * (1 - 1 / (2 * self.game_description.n_players))
        if state.current_stock > T:
            action_prob_C = 0.9
        else:
            action_prob_C = 0.1
        avg_growth_window_size = min(self.avg_growth_window_size, state.round_number)
        if history is not None and len(history.my_payoffs) >= self.avg_growth_window_size:
            avg_growth = np.mean(np.diff(history.my_payoffs[-self.avg_growth_window_size:]))
            if avg_growth > 0:
                T *= 1 - self.threshold_adjustment_factor
            else:
                T *= 1 + self.threshold_adjustment_factor
        coop_rate = np.mean(history.opponent_actions[-self.avg_growth_window_size:, :])
        if coop_rate > self.coop_rate_threshold:
            action_prob_C += 0.1
        else:
            action_prob_C -= 0.1
        if state.current_stock == self.game_description.capacity:
            return Action.C
        elif state.current_stock == 0:
            return Action.D
        if state.round_number >= self.game_description.n_rounds - 1:
            return Action.D
        random_value = random.random()
        if random_value < action_prob_C:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_575(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Conservation (ASC)
    
    Balances individual payoffs with collective sustainability, adapting to the game's dynamic state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock = state.current_stock
        opponents_defected = any((not action for action in history.opponent_actions[-1, :]))
        if stock >= 0.75 * self.capacity:
            return Action.C
        if opponents_defected or stock < 0.25 * self.capacity:
            return Action.D
        my_payoff = history.my_payoffs[-1]
        avg_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
        if my_payoff < avg_opponent_payoff:
            return Action.D
        return Action.C

    def last_round(self):
        return Action.D

    def stock_depleted(self, stock):
        return Action.C

class Strategy_COLLECTIVE_576(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with the preservation of the common pool stock.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.window_size = 3
        self.threshold = self.capacity / (4 * self.n_players)
        self.my_actions = []
        self.stock_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_payoff = self.calculate_avg_payoff(history)
        stock = state.current_stock
        remaining_rounds = self.game_description.n_rounds - state.round_number
        if avg_payoff < self.threshold or (remaining_rounds == 1 and len(self.my_actions) > 0):
            return Action.D
        elif stock < 2 * self.n_players:
            return Action.D
        elif stock > self.capacity - 2 * self.n_players:
            return Action.C
        return Action.C

    def calculate_avg_payoff(self, history: PlayerHistory):
        window_size = min(len(history.my_payoffs), self.window_size)
        avg_payoff = sum(history.my_payoffs[-window_size:]) / window_size
        return avg_payoff

class Strategy_COLLECTIVE_577(BaseStrategy):
    """
    Adaptive Stock Sensitive Tit-for-Tat strategy.

    This strategy balances individual payoffs with the long-term sustainability of the common pool resource.
    It prioritizes cooperation when the stock level is above a certain threshold and adapts to opponents' actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / (2 * game_description.n_players)
        self.low_stock_threshold = game_description.capacity / (4 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_round_actions = history.opponent_actions[-1, :] if history else []
        num_defectors = sum((not action for action in previous_round_actions))
        stock_level = state.current_stock
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock_level < self.low_stock_threshold:
            return Action.C
        if num_defectors >= self.game_description.n_players / 2:
            return Action.D
        if stock_level > self.stock_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_578(BaseStrategy):
    """
    A strategy that balances individual self-interest with cooperation, adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio < 0.25:
            return Action.C
        if stock_ratio >= 0.75:
            action = Action.C
        elif stock_ratio >= 0.5:
            p = stock_ratio - 0.5
            action = Action.C if random.random() < p else Action.D
        else:
            action = Action.D
        return action

class Strategy_COLLECTIVE_579(BaseStrategy):
    """
    An adaptive strategy for the Common Pool Resource Game that balances individual self-interest with collective well-being.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_defect_prob = 0.3
        self.threshold = 0.75 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if random.random() < 0.5 else Action.D
        if state.current_stock >= self.threshold:
            return Action.C
        elif state.current_stock <= 0.25 * self.game_description.capacity:
            return Action.C
        d_prev = sum((1 for action in history.opponent_actions[-1, :] if not action))
        defect_prob = min(1, d_prev / self.game_description.n_players * self.n_defect_prob)
        if all(history.opponent_actions[-1, :]):
            self.n_defect_prob *= 0.9
        elif sum((1 for action in history.opponent_actions[-1, :] if not action)) >= self.game_description.n_players // 2:
            self.n_defect_prob *= 1.1
        return Action.D if random.random() < defect_prob else Action.C

class Strategy_COLLECTIVE_580(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Conservation (ASC)
    
    ASC aims to balance individual payoffs with collective sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        capacity = self.game_description.capacity
        stock_high = 0.75 * capacity
        stock_low = 0.25 * capacity
        if state.current_stock > stock_high:
            return Action.C
        elif state.current_stock < stock_low:
            return Action.D
        prev_round_actions = history.opponent_actions[-1, :]
        most_players_defected = np.mean(prev_round_actions) < 0.5
        if not most_players_defected:
            return Action.D
        else:
            return Action.C
        low_stock_count = sum((1 for round in history.my_payoffs if round < stock_low))
        high_stock_count = sum((1 for round in history.my_payoffs if round > stock_high))
        if low_stock_count > 2:
            return Action.D
        elif high_stock_count > 2:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_581(BaseStrategy):
    """
    Balances individual self-interest with collective sustainability by adapting its cooperation threshold based on the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_consumption = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        critical_threshold = self.game_description.capacity / (2 * self.game_description.n_players)
        if state.current_stock < critical_threshold:
            return Action.C
        n = self.game_description.n_players
        capacity = self.game_description.capacity
        total_consumption = sum(history.my_payoffs) + np.sum(np.sum(history.opponent_payoffs, axis=1))
        threshold = capacity * (1 - total_consumption / (n * capacity)) ** 2
        if state.current_stock > threshold:
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_582(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Conservation (ASC)

    This strategy aims to balance individual payoffs with collective sustainability by adaptively responding to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock >= self.game_description.capacity / 2 else Action.D
        avg_payoff = np.mean(history.my_payoffs[:-1]) if len(history.my_payoffs) > 1 else 0
        last_round_avg_payoff = history.my_payoffs[-1]
        total_consumption = sum([history.my_payoffs[i] for i in range(len(history.my_payoffs))])
        if last_round_avg_payoff >= avg_payoff and state.current_stock >= self.game_description.capacity / 2:
            return Action.C
        elif total_consumption > self.game_description.capacity / 2:
            return Action.D
        else:
            trend = state.current_stock - history.my_payoffs[-1]
            if trend > 0:
                return Action.C
            elif trend < 0:
                return Action.D
            else:
                return Action.C if history.my_actions[-1] else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_COLLECTIVE_583(BaseStrategy):
    """
    Adaptive Common Pool Resource Management Strategy.

    This strategy aims to balance individual self-interest with collective sustainability.
    It adapts to changing conditions, cooperating when possible and defecting when necessary.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.rounds_in_observation_phase = 5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number < self.rounds_in_observation_phase:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators >= len(history.opponent_actions[-1, :]) / 2:
                return Action.C
            else:
                return Action.D
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio > 0.75:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators >= len(history.opponent_actions[-1, :]) / 2:
                return Action.C
            else:
                return Action.D
        elif 0.5 <= stock_ratio < 0.75:
            cooperators = sum(history.opponent_actions[-1, :])
            if cooperators >= len(history.opponent_actions[-1, :]) / 3:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D
        if state.round_number >= self.game_description.n_rounds - 2:
            stock_ratio = state.current_stock / self.game_description.capacity
            if stock_ratio > 0.25:
                cooperators = sum(history.opponent_actions[-1, :])
                if cooperators >= len(history.opponent_actions[-1, :]) / 2:
                    return Action.C
                else:
                    return Action.D
            else:
                return Action.D
        return Action.D

class Strategy_COLLECTIVE_584(BaseStrategy):
    """
    A strategy that balances individual payoff maximization with collective sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.recent_payoffs = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        more_than_half_defected = sum((not action for action in opponent_actions)) > self.game_description.n_players // 2
        recent_payoff_average = np.mean(self.recent_payoffs) if self.recent_payoffs else math.inf
        expected_cooperative_payoff = self.game_description.capacity / (2 * self.game_description.n_players)
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.C
        elif more_than_half_defected:
            return Action.D
        elif recent_payoff_average < expected_cooperative_payoff and len(self.recent_payoffs) > 2:
            return Action.D
        else:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 1:
            return Action.C
        my_payoff = state.current_stock / (2 * self.game_description.n_players) if history.my_actions[-1] else 0
        self.recent_payoffs.append(my_payoff)
        self.recent_payoffs = self.recent_payoffs[-3:]

class Strategy_COLLECTIVE_585(BaseStrategy):
    """
    Adaptive Stock Preservation strategy for the Common Pool Resource Game.
    Balances short-term gains with long-term sustainability by adapting to the game's dynamics and player behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        previous_round_actions = history.opponent_actions[-1, :]
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        majority_cooperated = np.sum(previous_round_actions) > (self.game_description.n_players - 1) / 2
        if majority_cooperated:
            return Action.C
        recent_defection = np.any(history.opponent_actions[-2:, :])
        if recent_defection:
            return Action.D
        stock_recovery = state.current_stock >= 0.75 * self.game_description.capacity
        if stock_recovery:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_586(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Thresholds.
    
    This collective strategy aims to balance individual payoffs with the long-term sustainability of the common pool resource.
    It adapts cooperation level based on the current stock state and the history of play.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_fraction = state.current_stock / self.capacity
        num_defectors_prev_round = sum(~history.opponent_actions[-1, :])
        if stock_fraction >= 0.75 or stock_fraction < 0.5:
            return Action.C
        defect_prob = (num_defectors_prev_round / self.game_description.n_players) ** 2
        if random.random() < defect_prob:
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_587(BaseStrategy):
    """
    Collective Strategy: Adaptive Cooperation with Stock Conservation (ACSC)
    
    Aims to balance individual payoffs with collective sustainability by adapting 
    to the game's state and history. Prioritizes cooperation while conserving the 
    stock level, ensuring a stable and resilient common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_conservation_threshold = 0.7
        self.consecutive_cooperation_rounds = 2
        self.consecutive_defection_rounds = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is None or len(history.my_actions) < self.consecutive_cooperation_rounds + 1:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if current_stock < self.stock_conservation_threshold * capacity:
            return Action.D
        if self.is_stock_growing(history, self.consecutive_cooperation_rounds):
            return Action.C
        if self.is_stock_declining(history, self.consecutive_defection_rounds):
            return Action.D
        opponent_actions = history.opponent_actions
        most_recent_opponent_actions = opponent_actions[-1, :]
        cooperators = sum(most_recent_opponent_actions)
        if self.most_cooperate(cooperators, len(most_recent_opponent_actions)):
            return Action.C
        return Action.D

    def is_stock_growing(self, history: PlayerHistory, k: int) -> bool:
        my_payoffs = history.my_payoffs
        stock_growth = np.diff(my_payoffs)
        if len(stock_growth) < k:
            return False
        recent_growth = stock_growth[-k:]
        return all((growth >= 0 for growth in recent_growth))

    def is_stock_declining(self, history: PlayerHistory, m: int) -> bool:
        my_payoffs = history.my_payoffs
        stock_growth = np.diff(my_payoffs)
        if len(stock_growth) < m:
            return False
        recent_growth = stock_growth[-m:]
        return all((growth <= 0 for growth in recent_growth))

    def most_cooperate(self, cooperators: int, total_opponents: int) -> bool:
        return cooperators >= total_opponents // 2

class Strategy_COLLECTIVE_588(BaseStrategy):
    """
    Adaptive Stock Preservation strategy for Common Pool Resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.sdr_threshold = 0.2
        self.di_threshold = 0.1
        self.retaliation_rounds = 3
        self.stock_level = None
        self.prev_stock_level = None
        self.recovery_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or self.stock_level is None:
            self.stock_level = self.capacity
            return Action.C
        self.prev_stock_level = self.stock_level
        self.stock_level = state.current_stock
        sdr = (self.prev_stock_level - self.stock_level) / self.game_description.n_players
        if history is None:
            return Action.C
        opponent_actions = np.any(history.opponent_actions, axis=0)
        defector_detected = not all(opponent_actions)
        if defector_detected:
            di = self.calculate_defection_impact(history)
            if di > self.di_threshold:
                return Action.D
        if self.stock_level < self.capacity / 2:
            self.recovery_rounds += 1
            if self.recovery_rounds >= self.retaliation_rounds:
                self.recovery_rounds = 0
            return Action.C
        if sdr < self.sdr_threshold:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return Action.D

    def calculate_defection_impact(self, history: PlayerHistory):
        my_payoffs = history.my_payoffs[-1]
        expected_coop_payoff = self.stock_level / (2 * self.game_description.n_players)
        di = abs(my_payoffs - expected_coop_payoff) / expected_coop_payoff
        return di

class Strategy_COLLECTIVE_589(BaseStrategy):
    """
    Collective Strategy: Adaptive Stock Conservation (ASC)
    Balances individual payoff maximization with collective stock conservation,
    ensuring a sustainable resource for all players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_threshold = self.game_description.capacity / 2
        if state.current_stock < stock_threshold:
            return Action.D
        opponent_actions = history.opponent_actions[:-1] if len(history.opponent_actions) > 1 else history.opponent_actions
        n_opponents = opponent_actions.shape[1]
        defected_more_than_half = np.sum(opponent_actions, axis=0) / (state.round_number - 1) > 0.5
        cooperated_more_than_half = np.sum(1 - opponent_actions, axis=0) / (state.round_number - 1) > 0.5
        if any(defected_more_than_half):
            return Action.D
        elif any(cooperated_more_than_half):
            return Action.C
        p = 1 - (state.round_number / (2 * self.game_description.n_players)) ** 0.5
        random_value = np.random.rand() < p
        emergency_defection = False
        if state.round_number > 1:
            previous_round_total_consumption = sum(np.sum(opponent_actions[-1, :]) + 1) / (self.game_description.n_players - 1)
            emergency_defection = previous_round_total_consumption > 0.75 * self.game_description.capacity
        if random_value and state.current_stock > stock_threshold and (not emergency_defection):
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_590(BaseStrategy):
    """
    A collective strategy that balances individual payoffs with the long-term sustainability of the common pool resource.
    
    It employs a dynamic approach that adjusts cooperation levels based on the current stock level and observed opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        capacity = self.game_description.capacity
        stock_threshold_high = 0.75 * capacity
        stock_threshold_low = 0.25 * capacity
        if state.current_stock >= stock_threshold_high:
            return Action.C
        elif state.current_stock <= stock_threshold_low:
            return Action.D
        previous_cooperations = sum(history.opponent_actions[-1, :])
        opponents_cooperated = previous_cooperations / self.game_description.n_players
        if opponents_cooperated > 0.5:
            return Action.C
        else:
            if state.round_number == self.game_description.n_rounds - 1:
                return Action.D
            return Action.D

class Strategy_COLLECTIVE_591(BaseStrategy):
    """
    Adaptive Collective Conservation strategy for the Common Pool Resource Game.
    This strategy prioritizes cooperation when the stock level is high and defecting when it's low,
    with a probabilistic element based on historical defection rates to adapt to other players' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_rate = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 1:
            return Action.C
        stock_percentage = state.current_stock / self.game_description.capacity * 100
        if history is not None:
            for round_actions in history.opponent_actions[1:]:
                if any((not action for action in round_actions)):
                    self.defection_rate += 1 / state.round_number
            self.defection_rate = min(self.defection_rate, 1)
        if stock_percentage >= 75:
            return Action.C
        elif stock_percentage < 25:
            return Action.D
        else:
            p_defect = (1 - state.current_stock / self.game_description.capacity) * (self.defection_rate + 0.1)
            return Action.D if random.random() < p_defect else Action.C
        if state.round_number == self.game_description.n_rounds:
            return Action.C

class Strategy_COLLECTIVE_592(BaseStrategy):
    """
    Adaptive Collective Harvesting (ACH) strategy for the Common Pool Resource Game.
    
    ACH is a hybrid approach combining elements of cooperation, self-interest, and adaptability.
    It prioritizes cooperation when beneficial for the collective while adapting to individual self-interest and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_cooperations = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        CT = self.get_cooperation_threshold(state.current_stock, self.game_description.n_players, self.game_description.n_rounds)
        if self.consecutive_cooperations >= 3:
            return Action.C
        SI_ratio = state.current_stock / (2 * self.game_description.n_players * self.game_description.n_rounds)
        if state.current_stock > self.game_description.capacity / 2 and history.opponent_actions[-1, :].sum() >= self.game_description.n_players / 2:
            return Action.C
        elif self.game_description.capacity / 4 <= state.current_stock <= self.game_description.capacity / 2 and history.opponent_actions[-1, :].sum() >= self.game_description.n_players / 3:
            self.consecutive_cooperations += 1
            return Action.C
        elif state.current_stock < self.game_description.capacity / 4:
            return Action.D
        elif SI_ratio > 1:
            return Action.C
        else:
            self.consecutive_cooperations = 0
            return Action.D

    def get_cooperation_threshold(self, S: float, n: int, r: int) -> bool:
        if S > self.game_description.capacity / 2:
            return True
        elif self.game_description.capacity / 4 <= S <= self.game_description.capacity / 2:
            return False
        else:
            return False

    def increase_cooperation_rate(self, percentage: int) -> None:
        pass

class Strategy_COLLECTIVE_593(BaseStrategy):
    """
    Adaptive and robust strategy for the Common Pool Resource Game.
    Balances individual payoff maximization with collective sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = 0.75 * game_description.capacity
        self.payoff_threshold = 0.5 * (game_description.capacity / (2 * game_description.n_players))
        self.avg_payoff_window = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.current_stock >= self.stock_threshold:
            return Action.C
        total_consumption_prev_round = sum((self.game_description.n_players / (2 * self.game_description.n_players) if action else self.game_description.capacity / self.game_description.n_players for action in history.opponent_actions[-1, :]))
        if total_consumption_prev_round > 0.5 * self.game_description.capacity:
            return Action.D
        opponent_payoffs = np.mean(history.opponent_payoffs[-3:, :], axis=0)
        avg_payoff_window = np.mean(opponent_payoffs)
        if len(self.avg_payoff_window) >= 3 and avg_payoff_window < self.payoff_threshold:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.C
        return Action.D

class Strategy_COLLECTIVE_594(BaseStrategy):
    """
    Adaptive Stock Conservation (ASC) strategy aims to balance individual payoff maximization with collective stock conservation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        current_stock = state.current_stock
        if state.round_number == 0:
            return Action.C
        previous_round_opponent_actions = history.opponent_actions[-1]
        num_defectors = sum((1 for action in previous_round_opponent_actions if not action))
        total_consumption_prev = self.get_total_consumption(history, state.round_number - 1)
        S_remaining = current_stock - total_consumption_prev
        if S_remaining >= 0.75 * self.capacity:
            return Action.C
        elif S_remaining >= 0.5 * self.capacity:
            defect_prob = total_consumption_prev / (self.n_players * current_stock / self.n_players)
            if random.random() < defect_prob:
                return Action.D
            else:
                return Action.C
        else:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 2:
            return Action.C

    def get_total_consumption(self, history: PlayerHistory, round_number: int) -> float:
        """
        Calculate total consumption for the specified round.
        
        Parameters:
        history (PlayerHistory): The game's history
        round_number (int): The round number to calculate consumption for
        
        Returns:
        float: Total consumption in the specified round
        """
        actions = np.concatenate(([history.my_actions[round_number]], history.opponent_actions[round_number, :]))
        consumption = sum((self.get_consumption(action) for action in actions))
        return consumption

    def get_consumption(self, action: bool) -> float:
        """
        Calculate the consumption based on the specified action.
        
        Parameters:
        action (bool): The player's action
        
        Returns:
        float: Consumption value
        """
        if action:
            return self.capacity / (2 * self.n_players)
        else:
            return self.capacity / self.n_players

class Strategy_COLLECTIVE_595(BaseStrategy):
    """
    A collective strategy that balances individual self-interest with collective sustainability,
    adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions_last_round = history.opponent_actions[-1]
        all_defected_last_round = np.all(opponent_actions_last_round == False)
        stock_level = state.current_stock / self.game_description.capacity
        if stock_level >= 0.75:
            return Action.C
        elif stock_level >= 0.25 and stock_level < 0.75:
            opponent_cooperated_last_round = np.any(opponent_actions_last_round)
            if opponent_cooperated_last_round:
                return Action.C
            else:
                return Action.D
        elif stock_level < 0.25 and all_defected_last_round and (state.current_stock < self.game_description.capacity * 0.1):
            return Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_596(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that balances individual payoffs with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.high_stock_threshold = 0.75 * game_description.capacity
        self.low_stock_threshold = 0.5 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock <= 0:
            return Action.D
        if state.current_stock >= self.high_stock_threshold:
            return Action.C
        elif state.current_stock >= self.low_stock_threshold:
            p = (state.current_stock / self.game_description.capacity) ** 0.5
            return Action.D if random.random() < p else Action.C
        else:
            return Action.D

class Strategy_COLLECTIVE_597(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors 
    while prioritizing sustainability and fairness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.avg_payoff_threshold = game_description.capacity / (4 * game_description.n_players)
        self.sustainability_threshold = game_description.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if random.random() < 0.3 else Action.D
        avg_payoff = np.mean(history.my_payoffs[-1]) if history.my_payoffs.size > 0 else 0
        opponent_defection_rates = np.mean(~history.opponent_actions, axis=0) if history.opponent_actions.size > 0 else 0
        action = Action.C if avg_payoff > self.avg_payoff_threshold else Action.D
        if state.current_stock < self.sustainability_threshold:
            action = Action.C
        for opponent_defection_rate in opponent_defection_rates:
            if opponent_defection_rate > 0.5:
                action = Action.D
                break
        return action

class Strategy_COLLECTIVE_598(BaseStrategy):
    """
    A collective strategy that balances individual payoff maximization with collective sustainability.
    It uses a combination of tit-for-tat and stock sensitivity to encourage cooperation and reciprocity.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        previous_stock_level = history.my_payoffs[-1] * self.game_description.n_players * 2
        opponent_actions_last_round = history.opponent_actions[-1, :]
        if previous_stock_level < 0.75 * self.game_description.capacity:
            return Action.D
        for action in opponent_actions_last_round:
            if not action:
                return Action.D
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return Action.C

class Strategy_COLLECTIVE_599(BaseStrategy):
    """
    Adaptive Cooperation with Stock-Based Trigger (ACS-T) strategy.

    This strategy prioritizes collective sustainability by maintaining a balance between individual gains and stock preservation.
    It cooperates when the stock is above a threshold, defects for one round to signal dissatisfaction if the stock level drops too low or opponents exploit cooperation,
    and reverts to cooperation once the stock has recovered or opponents adjust their behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / (2 * game_description.n_players)
        self.avg_opponent_consumption = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        if state.current_stock <= 0:
            return Action.C
        opponent_consumptions = np.where(history.opponent_actions[-1, :], state.current_stock / self.game_description.n_players, state.current_stock / (2 * self.game_description.n_players))
        self.avg_opponent_consumption = np.mean(opponent_consumptions)
        if state.current_stock > self.stock_threshold and self.avg_opponent_consumption <= state.current_stock / (2 * self.game_description.n_players):
            return Action.C
        elif state.current_stock < self.stock_threshold or self.avg_opponent_consumption > state.current_stock / (2 * self.game_description.n_players):
            return Action.D
        else:
            return Action.C

class Strategy_COLLECTIVE_600(BaseStrategy):
    """
    A collective strategy for the Common Pool Resource Game that adapts to various opponent behaviors and game states.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if state.current_stock >= 0.75 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        prev_payoffs = history.my_payoffs[-1] if len(history.my_payoffs) > 0 else []
        prev_opponent_actions = history.opponent_actions[-1, :] if len(history.opponent_actions) > 0 else []
        avg_prev_payoff = np.mean(prev_payoffs)
        max_possible_payoff = state.current_stock / (2 * self.game_description.n_players)
        opponent_defected = np.any(prev_opponent_actions == Action.D.value)
        if avg_prev_payoff < 0.5 * max_possible_payoff:
            return Action.D
        if state.current_stock >= 0.75 * self.game_description.capacity and opponent_defected:
            return Action.C if random.random() < 0.5 else Action.D
        if state.current_stock <= 0.25 * self.game_description.capacity:
            return Action.D
        if state.current_stock >= 0.9 * self.game_description.capacity and opponent_defected:
            return Action.C if random.random() < 0.75 else Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_513(BaseStrategy):
    """
    Exploitative strategy "Adaptive Stock Hawk" for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.alpha_threshold = 0.5
        self.gamma = 0.05
        self.min_stock_threshold = game_description.capacity / (2 * game_description.n_players)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.round_number == self.game_description.n_rounds - 1:
            return Action.C if state.round_number == 0 else Action.D
        opponent_actions = history.opponent_actions
        alpha = np.mean(opponent_actions, axis=1)
        average_cooperation_rate = np.mean(alpha)
        S = state.current_stock
        n = self.game_description.n_players
        T = self.game_description.capacity / (2 * n) + (S - self.game_description.capacity / (2 * n)) / 2
        if average_cooperation_rate < self.alpha_threshold or S <= self.min_stock_threshold:
            return Action.D
        dynamic_T = T * (1 - self.gamma * (state.round_number / self.game_description.n_rounds))
        return Action.C if S >= dynamic_T else Action.D

class Strategy_EXPLOITATIVE_514(BaseStrategy):
    """
    Exploitative strategy that balances short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.stock_history = []
        self.payoff_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.stock_history.append(state.current_stock)
        if history is not None:
            avg_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
            self.payoff_history.append(avg_opponent_payoff)
        current_stock = self.stock_history[-1]
        avg_opponent_payoff = sum(self.payoff_history) / len(self.payoff_history) if self.payoff_history else 0
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if current_stock > 0.75 * self.capacity:
            return Action.D
        elif 0.25 * self.capacity <= current_stock < 0.75 * self.capacity:
            if avg_opponent_payoff > current_stock / (2 * self.n_players):
                return Action.C
            else:
                return Action.D
        elif current_stock < 0.25 * self.capacity or current_stock == 0:
            return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_515(BaseStrategy):
    """
    A strategy that balances short-term gains with long-term sustainability by adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        low_stock = 0.25 * self.game_description.capacity
        high_stock = 0.75 * self.game_description.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        avg_payoff_3r = np.mean(history.my_payoffs[max(0, state.round_number - 2):])
        coop_avg_payoff = state.current_stock / (2 * self.game_description.n_players)
        if state.current_stock >= high_stock:
            return Action.D
        elif state.current_stock <= low_stock:
            return Action.C
        elif avg_payoff_3r > coop_avg_payoff:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_516(BaseStrategy):
    """
    An exploitative strategy that adapts to the behavior of other players and the state of the resource.
    Cooperates initially, then defects when the stock level is high or when opponents have defected in previous rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponents_defected = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if history is not None and state.round_number > 1:
            self.opponents_defected = sum((1 - action for action in history.opponent_actions[-2, :]))
        if self.opponents_defected > self.game_description.n_players / 2:
            threshold = self.game_description.capacity * 0.75
        else:
            threshold = self.game_description.capacity / 2
        if state.current_stock > threshold:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_517(BaseStrategy):
    """
    The Adaptive Depletion strategy aims to exploit the game's dynamics by balancing short-term gains with long-term sustainability.
    
    It adapts to the current state and history of the game, without relying on coordination or cooperation from other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.total_consumption = 0.0
        self.total_payoff = 0.0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 1:
            return Action.C if state.current_stock >= self.capacity * 0.75 else Action.D
        avg_consumption_prev = self.total_consumption / self.n_players
        if state.current_stock >= avg_consumption_prev * self.n_players:
            return Action.C
        elif state.current_stock < self.capacity / 2 or self.total_payoff / state.round_number <= state.current_stock / (2 * self.n_players):
            return Action.D
        if state.round_number == self.game_description.n_rounds:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_518(BaseStrategy):
    """
    Exploitative strategy that adaptively responds to the game's state and history 
    while exploiting potential cooperative behavior from opponents.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_rate_history = []
        self.threshold_stock_level = None

    def calculate_threshold_stock_level(self) -> float:
        """
        Calculate the threshold stock level based on the current game state.
        
        Returns:
            float: The calculated threshold stock level.
        """
        return self.game_description.capacity * (1 - 1 / (2 * self.game_description.n_players))

    def update_cooperation_rate_history(self, opponent_actions: NDArray[np.bool_]) -> None:
        """
        Update the cooperation rate history based on the opponent actions in the current round.
        
        Args:
            opponent_actions (NDArray[np.bool_]): The actions of opponents in the current round.
        """
        cooperators = sum(opponent_actions)
        self.cooperation_rate_history.append(cooperators / self.game_description.n_players)

    def adapt_threshold_stock_level(self) -> None:
        """
        Adapt the threshold stock level based on the cooperation rate history.
        
        If most opponents have cooperated in previous rounds, increase the TSL by 10%.
        """
        if len(self.cooperation_rate_history) > 1 and sum(self.cooperation_rate_history[-2:]) / 2 > 0.5:
            self.threshold_stock_level *= 1.1

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.D
        if self.threshold_stock_level is None:
            self.threshold_stock_level = self.calculate_threshold_stock_level()
        opponent_actions_in_last_round = history.opponent_actions[-1, :]
        self.update_cooperation_rate_history(opponent_actions_in_last_round)
        self.adapt_threshold_stock_level()
        if state.current_stock > self.threshold_stock_level:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < self.game_description.capacity / (2 * self.game_description.n_players):
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_519(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behavior and the game's state.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.recent_defection_window_size = 3

    def calculate_avg_payoff(self, history: PlayerHistory) -> float:
        total_payoff = sum(history.opponent_payoffs[-1, :])
        return total_payoff / self.game_description.n_players

    def recent_defection_detection(self, history: PlayerHistory) -> bool:
        defector_count = sum((1 for action in history.opponent_actions[-self.recent_defection_window_size:, 0] if not action))
        return defector_count > self.recent_defection_window_size / 2

    def stock_rebound(self, growth: float, capacity: int) -> bool:
        return growth > 0.5 * capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        avg_payoff_prev = self.calculate_avg_payoff(history)
        stock_threshold = 0.5 * self.game_description.capacity
        if state.current_stock < stock_threshold:
            return Action.D
        if avg_payoff_prev >= state.current_stock / (2 * self.game_description.n_players):
            if history is not None and self.stock_rebound(state.current_stock - history.my_payoffs[-1], self.game_description.capacity):
                return Action.C if random.random() < 0.7 else Action.D
            return Action.C
        else:
            if history is not None and self.recent_defection_detection(history):
                return Action.D if random.random() < 0.8 else Action.C
            return Action.D

class Strategy_EXPLOITATIVE_521(BaseStrategy):
    """
    The Adaptive Exploiter strategy balances cooperation and defection based on the current stock level and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defection_threshold = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        cooperators = sum(history.opponent_actions[-1, :])
        if cooperators > self.game_description.n_players // 2:
            self.defection_threshold += 0.1
        elif cooperators < self.game_description.n_players // 2:
            self.defection_threshold -= 0.1
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if stock_ratio >= self.defection_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_522(BaseStrategy):
    """
    The Adaptive Stock Exploiter strategy balances short-term gains with long-term sustainability while adapting to opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_75 = 0.75
        self.threshold_50 = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        C_count = sum(history.opponent_actions[-1, :] == True)
        D_count = self.game_description.n_players - 1 - C_count
        if C_count > D_count:
            self.threshold_75 -= 0.1
            self.threshold_50 -= 0.1
        elif D_count > C_count:
            self.threshold_75 += 0.1
            self.threshold_50 += 0.1
        if history and history.opponent_actions[-1, :].any() == False and (stock_level < 0.25):
            return Action.D
        if stock_level > self.threshold_75:
            return Action.D
        elif stock_level >= self.threshold_50:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_523(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behaviors and the dynamic state of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        if current_stock > 0.75 * capacity:
            return Action.C
        elif 0.25 * capacity <= current_stock <= 0.75 * capacity:
            defectors = sum(1 - history.opponent_actions[-1, :])
            p = defectors / n_players
            if random.random() < p:
                return Action.D
            else:
                return Action.C
        elif current_stock < 0.25 * capacity:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_524(BaseStrategy):
    """
    Exploitative strategy that adapts to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.last_round_avg_payoff = None
        self.last_round_total_consumption = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            avg_coop_consumption = self.game_description.capacity / (2 * self.game_description.n_players)
            return Action.C if avg_coop_consumption >= 0.25 * self.game_description.capacity else Action.D
        round_avg_payoff, total_consumption = self.calculate_round_payoffs_and_total_consumption(history)
        if state.current_stock >= history.my_actions[-1] * (self.game_description.capacity / (2 * self.game_description.n_players)) + (not history.my_actions[-1]) * (self.game_description.capacity / self.game_description.n_players):
            return Action.C
        elif round_avg_payoff >= 0.5 * self.game_description.capacity and total_consumption <= 0.75 * self.game_description.capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D if state.current_stock >= 0.25 * self.game_description.capacity else Action.C
        return Action.C

    def calculate_round_payoffs_and_total_consumption(self, history: PlayerHistory) -> tuple[float, float]:
        avg_payoff = np.mean(history.my_payoffs[-1] if len(history.my_payoffs.shape) == 2 else [history.my_payoffs[-1]])
        total_consumption = sum(((not action) * (self.game_description.capacity / self.game_description.n_players) + action * (self.game_description.capacity / (2 * self.game_description.n_players)) for action in history.opponent_actions[-1, :]))
        self.last_round_avg_payoff = avg_payoff
        self.last_round_total_consumption = total_consumption
        return (avg_payoff, total_consumption)

class Strategy_EXPLOITATIVE_525(BaseStrategy):
    """
    Exploitative strategy that adapts to the current state and history of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        opponent_actions = history.opponent_actions
        last_round_opponents_cooperate = sum(opponent_actions[-1, :]) >= self.game_description.n_players // 2
        low_stock_threshold = 0.5 * capacity
        high_stock_threshold = 0.8 * capacity
        if current_stock <= low_stock_threshold:
            return Action.D
        elif low_stock_threshold < current_stock < high_stock_threshold:
            if last_round_opponents_cooperate:
                return Action.C
            else:
                return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_526(BaseStrategy):
    """
    An exploitative strategy that adapts to opponents' behaviors by adjusting cooperation probability based on past outcomes.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / 2
        self.p_coop = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or (state.round_number > 0 and history is None):
            return Action.C if random.random() < 0.5 else Action.D
        previous_round_cooperators = sum(history.opponent_actions[-1, :])
        avg_payoff_coop = np.mean([payoff for payoff, action in zip(history.opponent_payoffs[-1, :], history.opponent_actions[-1, :]) if action])
        avg_payoff_defect = np.mean([payoff for payoff, action in zip(history.opponent_payoffs[-1, :], history.opponent_actions[-1, :]) if not action])
        if avg_payoff_coop > avg_payoff_defect:
            self.p_coop = min(1, self.p_coop + 0.1)
        else:
            self.p_coop = max(0, self.p_coop - 0.1)
        if state.current_stock > self.stock_threshold or (state.round_number == self.game_description.n_rounds - 1 and state.current_stock < self.stock_threshold):
            return Action.D
        elif state.current_stock <= 0:
            return Action.C
        else:
            return Action.C if random.random() < self.p_coop else Action.D

class Strategy_EXPLOITATIVE_527(BaseStrategy):
    """
    The Adaptive Stock Hawk strategy is designed to exploit opponents' behaviors while adapting to the dynamic state of the game.
    It balances short-term gains with long-term sustainability, ensuring a robust performance across various opponent strategies.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_payoff_prev = np.mean(history.my_payoffs[-1] + history.opponent_payoffs[-1, :]) if len(history.my_payoffs) > 0 else 0.0
        stock_threshold = 0.75 * self.game_description.capacity
        low_stock_threshold = 0.25 * self.game_description.capacity
        if state.current_stock > stock_threshold:
            return Action.D
        elif avg_payoff_prev > self.game_description.capacity / (2 * self.game_description.n_players):
            return Action.C
        else:
            return Action.D
        if state.current_stock < low_stock_threshold:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_528(BaseStrategy):
    """
    Exploitative strategy that adapts to the game state and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_history = []
        self.opponent_actions = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.stock_history.append(state.current_stock)
        if history is not None:
            self.opponent_actions.append(history.opponent_actions[-1, :])
        if state.round_number < self.game_description.n_rounds // 2:
            if state.current_stock > 0.75 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C
        elif state.round_number >= self.game_description.n_rounds // 2:
            avg_opponent_behavior = np.mean(self.opponent_actions[-1])
            if avg_opponent_behavior > 0.5:
                return Action.D
            else:
                return Action.C
        elif state.round_number > self.game_description.n_rounds * 3 // 4:
            if state.current_stock < 0.25 * self.game_description.capacity:
                return Action.D
            else:
                return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_529(BaseStrategy):
    """
    Adaptive Stock Exploiter (ASE) strategy for the Common Pool Resource Game.
    This strategy adapts to the dynamic game state and opponent behavior, 
    balancing short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_defection_threshold = 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        T = state.current_stock / (self.game_description.n_players * 2)
        D_count, C_count = self.analyze_opponent_behavior(history)
        consecutive_defections = self.track_consecutive_defections(history.opponent_actions)
        if state.current_stock < T or D_count > C_count or any((defections >= self.consecutive_defection_threshold for defections in consecutive_defections.values())):
            return Action.D
        stock_growth_rate = self.monitor_stock_growth_rate(history.my_payoffs)
        if stock_growth_rate is not None and stock_growth_rate < 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

    def analyze_opponent_behavior(self, history: PlayerHistory):
        D_count = sum((1 for opponent_action in history.opponent_actions[-1] if not opponent_action))
        C_count = self.game_description.n_players - 1 - D_count
        return (D_count, C_count)

    def track_consecutive_defections(self, opponent_actions: NDArray[np.bool_]):
        consecutive_defections = {}
        for i in range(opponent_actions.shape[1]):
            opponent_id = i + 1
            if not opponent_actions[-1, i]:
                consecutive_defections[opponent_id] = consecutive_defections.get(opponent_id, 0) + 1
        return consecutive_defections

    def monitor_stock_growth_rate(self, my_payoffs: NDArray[np.float64]):
        if len(my_payoffs) < 2:
            return None
        growth_rates = []
        for i in range(1, len(my_payoffs)):
            growth_rate = (my_payoffs[i] - my_payoffs[i - 1]) / self.game_description.capacity
            growth_rates.append(growth_rate)
        return sum(growth_rates) / len(growth_rates)

class Strategy_EXPLOITATIVE_530(BaseStrategy):
    """
    Exploitative strategy that adapts to the game state and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < 2:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.25 * self.capacity:
            return Action.C
        if state.current_stock > 0.75 * self.capacity:
            return Action.D
        if history is not None:
            opponent_actions = history.opponent_actions[-1, :]
            cooperators = sum(opponent_actions)
            defectors = len(opponent_actions) - cooperators
            if cooperators > self.n_players // 2:
                return Action.D
            elif defectors > self.n_players // 2:
                return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_531(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold_stock = 0.5 * game_description.capacity / game_description.n_players
        self.defector_count = 0
        self.growth_window = 3

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        self.defector_count = np.sum(~opponent_actions)
        if state.current_stock < self.threshold_stock:
            return Action.D
        elif self.defector_count <= self.game_description.n_players / 2:
            return Action.C
        for opponent in history.opponent_actions[-self.growth_window:]:
            if np.sum(~opponent) > np.sum(opponent):
                avg_growth = (state.current_stock - history.my_payoffs[-1]) / self.growth_window
                if avg_growth > 0:
                    self.threshold_stock *= 0.95
                elif avg_growth <= 0:
                    self.threshold_stock *= 1.1
        return Action.D

class Strategy_EXPLOITATIVE_532(BaseStrategy):
    """
    A robust and exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.alpha = 0.5 * game_description.capacity / game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number <= 1:
            return Action.C
        p = np.mean(history.opponent_actions[-1, :])
        if state.current_stock > self.alpha:
            return Action.C if random.random() < p else Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_533(BaseStrategy):
    """
    Exploit the common pool resource by adapting to the game's state and history while minimizing cooperation.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        stock_threshold = self.game_description.capacity / 4
        num_defectors_prev_round = sum((1 for action in history.opponent_actions[-1, :] if not action))
        if state.current_stock > stock_threshold:
            return Action.C
        if num_defectors_prev_round >= self.game_description.n_players / 2:
            return Action.D
        avg_payoff_prev_round = np.mean(history.my_payoffs[-1:])
        payoff_threshold = self.game_description.capacity / 8
        if avg_payoff_prev_round > payoff_threshold:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_534(BaseStrategy):
    """
    The Adaptive Exploiter balances short-term gains with long-term sustainability by 
    adjusting its behavior based on the current stock level and opponents' historical actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponents_defection_rates = None

    def update_opponent_defection_rates(self, opponent_actions: NDArray[np.bool_]):
        if self.opponents_defection_rates is None:
            self.opponents_defection_rates = np.zeros((self.game_description.n_players - 1,), dtype=np.float64)
        opponents_defect_count = np.sum(opponent_actions[-1, :] == False)
        for opponent in range(self.game_description.n_players - 1):
            self.opponents_defection_rates[opponent] = (self.opponents_defection_rates[opponent] * len(opponent_actions) + (opponent_actions[-1, opponent] == False)) / (len(opponent_actions) + 1)

    def count_defectors(self, opponent_actions: NDArray[np.bool_]):
        return np.sum(opponent_actions == False)

    def any_opponent_defected(self, opponent_actions: NDArray[np.bool_]):
        return np.any(opponent_actions == False)

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.opponents_defection_rates = None
            return Action.C
        if history is not None:
            self.update_opponent_defection_rates(history.opponent_actions)
        current_stock = state.current_stock / self.game_description.capacity
        if current_stock >= 0.75:
            if history is not None and self.any_opponent_defected(history.opponent_actions[-1, :]):
                return Action.D
            else:
                return Action.C
        elif 0.5 <= current_stock < 0.75:
            return Action.C
        elif current_stock < 0.5:
            if history is not None and self.count_defectors(history.opponent_actions[-1, :]) >= 2:
                return Action.D
            else:
                return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_536(BaseStrategy):
    """
    The ASE strategy aims to maximize individual payoffs by adaptively exploiting 
    the common pool resource while minimizing the risk of depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        num_defectors = sum((1 - action for action in history.opponent_actions[-1, :]))
        ei = state.current_stock / self.game_description.capacity * (num_defectors / self.game_description.n_players)
        if state.current_stock < 0.1 * self.game_description.capacity:
            return Action.C
        if num_defectors == 0:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if ei > 0.5:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_537(BaseStrategy):
    """
    Exploitative strategy adapting to the game's state and history while exploiting opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return random.choice([Action.C, Action.D])
        opponent_consumptions = np.where(history.opponent_actions[:, :], self.capacity / self.n_players, self.capacity / (2 * self.n_players))
        current_stock = state.current_stock
        if state.round_number < 3:
            return random.choice([Action.C, Action.D])
        elif state.round_number >= self.game_description.n_rounds - 2:
            if history.my_payoffs.size < 1:
                sdr = 0.0
            else:
                sdr = (current_stock - history.my_payoffs[-1]) / self.capacity
            if sdr > 0.5 or state.round_number == self.game_description.n_rounds - 1:
                return Action.D
            else:
                return Action.C
        else:
            ocr = np.mean(np.sum(opponent_consumptions[-2:, :], axis=0)) if history.my_payoffs.size > 1 else 0.0
            if ocr > current_stock / (4 * self.n_players):
                return Action.D
            elif current_stock < self.capacity / 4:
                return Action.C
            else:
                return Action.C

class Strategy_EXPLOITATIVE_538(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behavior and exploits their cooperativeness.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        opponent_cooperation_rate = sum(history.opponent_actions[-1, :]) / self.n_players
        stock_depletion_rate = (self.capacity - state.current_stock) / state.round_number if state.round_number > 0 else 0
        if state.current_stock < self.capacity / 4:
            return Action.C
        if opponent_cooperation_rate > 0.5 and stock_depletion_rate < self.capacity / (2 * self.n_players):
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_539(BaseStrategy):
    """
    Exploitative strategy that adapts to dynamic state and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_threshold = 0.5 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        pi_C = state.current_stock / (2 * self.game_description.n_players)
        pi_D = state.current_stock / self.game_description.n_players
        if state.current_stock < self.cooperation_threshold:
            return Action.C
        avg_pi_prev = np.mean(history.opponent_payoffs[-1, :])
        pi_prev = history.my_payoffs[-1] if len(history.my_payoffs) > 0 else 0
        if avg_pi_prev > pi_prev:
            return Action.D
        elif state.current_stock <= self.game_description.capacity * 0.5 or (history is not None and history.my_payoffs[-1] >= avg_pi_prev):
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_540(BaseStrategy):
    """
    An exploitative strategy that adapts to various opponent behaviors and maintains a robust approach throughout the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.punishment_rounds = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock >= 0.75 * self.capacity else Action.D
        if self.punishment_rounds > 0:
            self.punishment_rounds -= 1
            return Action.D
        opponent_consumption = np.sum(history.opponent_actions[-1, :] == False) / (self.n_players - 1)
        avg_opponent_consumption = np.mean(opponent_consumption)
        if state.round_number < self.game_description.n_rounds - 1:
            if state.current_stock >= 0.5 * self.capacity and avg_opponent_consumption <= state.current_stock / (2 * self.n_players):
                if state.current_stock < 0.25 * self.capacity:
                    return Action.C
                else:
                    return Action.C
            elif opponent_consumption > 2 * state.current_stock / self.n_players:
                self.punishment_rounds = 2
                return Action.D
            else:
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_541(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to the game state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.D
        rounds_remaining = self.game_description.n_rounds - state.round_number
        greed_threshold = state.current_stock / self.capacity * (self.n_players / (2 * rounds_remaining))
        if state.current_stock < 0.1 * self.capacity:
            return Action.C
        elif rounds_remaining == 1:
            return Action.D
        elif state.current_stock / (2 * self.n_players) >= greed_threshold:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_542(BaseStrategy):
    """
    Exploitative strategy that balances short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        current_stock = state.current_stock
        opponent_payoffs = np.mean(history.opponent_payoffs[-1, :], axis=0)
        if current_stock >= 0.75 * self.game_description.capacity:
            return Action.D
        elif 0.5 <= current_stock / self.game_description.capacity < 0.75:
            own_payoff = np.mean(history.my_payoffs)
            if np.mean(opponent_payoffs) > own_payoff:
                return Action.C
            else:
                return Action.D
        elif current_stock < 0.5 * self.game_description.capacity:
            rounds_remaining = self.game_description.n_rounds - state.round_number
            if rounds_remaining >= 2:
                return Action.D
            else:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_543(BaseStrategy):
    """
    An adaptive strategy that balances short-term gains with long-term sustainability by adapting to opponents' behaviors and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_defections = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_ratio = state.current_stock / self.game_description.capacity
        opponents_defected = np.sum(history.opponent_actions[-1] == True)
        if self.opponent_defections is None:
            self.opponent_defections = [opponents_defected]
        else:
            self.opponent_defections.append(opponents_defected)
        if stock_ratio >= 0.75 or (state.round_number == self.game_description.n_rounds - 1 and history.my_payoffs[-1] > state.current_stock / (2 * self.game_description.n_players)):
            return Action.C
        elif 0.5 <= stock_ratio < 0.75:
            defect_prob = min(1, opponents_defected / self.game_description.n_players)
            return Action.D if random.random() < defect_prob else Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_544(BaseStrategy):
    """
    Adaptive Stock Exploiter (ASE) strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperation_rates = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if self.opponent_cooperation_rates is None:
            self.opponent_cooperation_rates = [self.opponent_cooperation_rate(opponent_actions) for opponent_actions in history.opponent_actions.T]
        stock_level = state.current_stock / self.game_description.capacity
        if stock_level > 0.75:
            return Action.D
        elif 0.25 <= stock_level <= 0.75:
            majority_cooperated = sum((1 for rate in self.opponent_cooperation_rates if rate > 0.5)) >= self.game_description.n_players / 2
            if majority_cooperated:
                return Action.C
            else:
                return Action.D
        else:
            multiple_defectors = sum((1 for rate in self.opponent_cooperation_rates if rate < 0.3)) > 1
            if multiple_defectors:
                return Action.C
            return Action.C

    def opponent_cooperation_rate(self, opponent_actions):
        cooperation_count = sum(opponent_actions)
        return cooperation_count / len(opponent_actions)

class Strategy_EXPLOITATIVE_545(BaseStrategy):
    """
    An adaptive strategy that balances short-term gains with long-term sustainability by exploiting cooperative behavior and adapting to the game's state and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.thresholds = {'high': 0.75 * self.capacity, 'medium': 0.5 * self.capacity, 'low': 0.25 * self.capacity}
        self.opponent_behavior = {}

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_change = state.current_stock - self.capacity if history is None else state.current_stock - history.my_payoffs[-1]
        if abs(stock_change) < 0.2 * self.capacity or stock_change >= 0:
            return Action.D
        if state.current_stock > self.thresholds['high']:
            return Action.D
        elif state.current_stock >= self.thresholds['medium']:
            return Action.C
        else:
            return Action.D
        for opponent in range(self.game_description.n_players):
            if history.opponent_actions[-1, opponent]:
                self.opponent_behavior[opponent] = 'cooperative'
            else:
                self.opponent_behavior[opponent] = 'defective'
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        for behavior in self.opponent_behavior.values():
            if behavior == 'cooperative':
                return Action.C
            elif behavior == 'defective':
                return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_546(BaseStrategy):
    """
    An exploitative, adaptive strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number <= self.game_description.n_players // 2 or (history is None and state.round_number == 0):
            return Action.C
        avg_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
        if self.game_description.n_players // 2 < state.round_number <= self.game_description.n_rounds - self.game_description.n_players // 2:
            max_possible_payoff = state.current_stock / (self.game_description.n_players * 2)
            if avg_opponent_payoff < 0.75 * max_possible_payoff or state.current_stock <= self.game_description.n_players:
                return Action.D
            else:
                return Action.C
        elif state.round_number > self.game_description.n_rounds - self.game_description.n_players // 2:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_547(BaseStrategy):
    """
    The Adaptive Stock Raider (ASR) strategy is designed to exploit a wide range of opponent behaviors 
    while adapting to changing game conditions. ASR balances short-term gains with long-term sustainability, 
    aiming to maximize total payoff over the entire game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_models = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock / self.game_description.capacity
        if state.round_number + 1 == self.game_description.n_rounds:
            return Action.D
        opponent_actions_last_round = history.opponent_actions[-1, :]
        if self.opponent_models is None:
            self.opponent_models = np.zeros(self.game_description.n_players - 1)
        self.opponent_models[opponent_actions_last_round == 0] += 1
        if current_stock > 0.75:
            defect_prob = current_stock ** 2
            return Action.D if random.random() < defect_prob else Action.C
        elif 0.25 <= current_stock <= 0.75:
            if np.any(opponent_actions_last_round == 0):
                return Action.C
            else:
                return Action.D
        else:
            cooperate_prob = current_stock ** 2
            return Action.C if random.random() < cooperate_prob else Action.D

class Strategy_EXPLOITATIVE_548(BaseStrategy):
    """
    Exploitative strategy that adapts to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_number = 0
        self.recent_payoffs = []
        self.all_payoffs = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.round_number += 1
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        S_threshold = capacity * 0.7
        if history:
            num_defectors_prev = sum((not opponent_action for opponent_action in history.opponent_actions[-1, :]))
        else:
            num_defectors_prev = 0
        if current_stock > S_threshold:
            action = Action.C
        elif num_defectors_prev >= n_players / 2:
            action = Action.D
        elif history and len(self.recent_payoffs) > 0:
            recent_avg_payoff = np.mean(np.array(self.recent_payoffs))
            long_term_avg_payoff = np.mean(np.array(self.all_payoffs))
            if recent_avg_payoff < long_term_avg_payoff * 0.8:
                stock_consumption_is_high = current_stock / capacity < 0.5
                if stock_consumption_is_high:
                    action = Action.C
                else:
                    action = Action.D
            else:
                action = Action.C
        else:
            action = Action.C
        if self.round_number == self.game_description.n_rounds:
            return Action.D
        elif current_stock < capacity * 0.3:
            return Action.C
        if history:
            payoff = current_stock / (2 * n_players) if action is Action.C else current_stock / n_players
            self.recent_payoffs.append(payoff)
            self.all_payoffs.append(payoff)
        return action

class Strategy_EXPLOITATIVE_549(BaseStrategy):
    """
    The Adaptive Stock Raider (ASR) strategy maximizes payoffs by exploiting 
    the dynamic state of the common pool resource game while adapting to various 
    opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.cooperation_rate_history = []
        self.defect_probability = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        previous_stock = state.current_stock
        if previous_stock > self.capacity / 2:
            action = Action.C
        else:
            action = Action.D
        if previous_stock < self.capacity / 4:
            action = Action.D
        elif previous_stock > 3 * self.capacity / 4:
            action = random.choices([Action.C, Action.D], weights=[0.7, 0.3])[0]
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        if history is not None and len(history.opponent_actions) >= 3:
            opponent_cooperations = np.sum(history.opponent_actions[-3:, :], axis=0)
            cooperation_rate = np.mean(opponent_cooperations / self.n_players, axis=None)
            self.cooperation_rate_history.append(cooperation_rate)
            if cooperation_rate > 0.5 and self.defect_probability < 1:
                self.defect_probability += 0.1
            elif cooperation_rate < 0.3 and self.defect_probability > 0:
                self.defect_probability -= 0.1
        return action

class Strategy_EXPLOITATIVE_550(BaseStrategy):
    """
    An exploitative strategy designed to adapt to the dynamic state of the game and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.k = 3
        self.past_cooperators = set()

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        S_th = self.capacity / (2 * self.n_players)
        opponent_actions = history.opponent_actions
        last_round_opponent_actions = opponent_actions[-1, :]
        for i in range(self.n_players - 1):
            if last_round_opponent_actions[i] and i not in self.past_cooperators:
                self.past_cooperators.add(i)
        if current_stock >= S_th:
            return Action.C
        p_defect = max(0, 1 - current_stock / self.capacity)
        if random.random() < p_defect and len(self.past_cooperators) > 0:
            return Action.D
        stock_growth = min(current_stock * (2 - current_stock / self.capacity), self.capacity)
        if stock_growth > 2 * self.capacity / self.n_players:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.D

class Strategy_EXPLOITATIVE_551(BaseStrategy):
    """
    An adaptive strategy that balances short-term gain with long-term sustainability,
    exploiting potential cooperation from other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperation_likelihood = 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_cooperation_rate = np.mean(history.opponent_actions[-1, :])
        if opponent_cooperation_rate > 0.5:
            self.cooperation_likelihood += 0.05
        elif opponent_cooperation_rate < 0.5:
            self.cooperation_likelihood -= 0.05
        self.cooperation_likelihood = max(0, min(self.cooperation_likelihood, 1))
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock > 0.75 * self.game_description.capacity:
            return Action.D
        elif 0.5 * self.game_description.capacity <= state.current_stock <= 0.75 * self.game_description.capacity:
            if random.random() < self.cooperation_likelihood:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_552(BaseStrategy):
    """
    An exploitative strategy that adapts to the game state and opponent behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.theta = 0.6 * game_description.capacity / game_description.n_players
        self.low_stock_threshold = 0.2 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        opponent_actions_last_round = history.opponent_actions[-1]
        total_consumption = (opponent_actions_last_round.sum() + 1) * state.current_stock / (2 * self.game_description.n_players)
        stock_level_dropped_significantly = total_consumption > 0.2 * state.current_stock
        if stock_level_dropped_significantly:
            self.theta *= 0.9
        cooperators_last_round = opponent_actions_last_round.sum()
        if cooperators_last_round >= self.game_description.n_players / 2:
            self.theta *= 1.05
        elif cooperators_last_round < self.game_description.n_players / 2:
            self.theta *= 0.95
        if state.current_stock > self.theta and state.round_number != self.game_description.n_rounds - 1:
            return Action.C
        elif state.current_stock < self.low_stock_threshold:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_553(BaseStrategy):
    """
    Exploitative strategy "Adaptive Stock Raider" (ASR) for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = np.logical_not(history.opponent_actions)
        greedy_opponents = np.sum(opponent_actions, axis=1) > self.game_description.n_rounds / 2
        stock_trend = np.diff(history.my_payoffs)
        rapidly_depleting_stock = np.any(stock_trend < -0.5 * self.game_description.capacity / self.game_description.n_players ** 2)
        if state.current_stock >= 0.75 * self.game_description.capacity:
            return Action.D
        elif 0.5 * self.game_description.capacity <= state.current_stock < 0.75 * self.game_description.capacity:
            if np.any(greedy_opponents) or rapidly_depleting_stock:
                return Action.D
            else:
                return Action.C
        elif state.current_stock < 0.5 * self.game_description.capacity:
            if state.round_number == self.game_description.n_rounds - 1:
                return Action.D
            else:
                return Action.C
        elif state.current_stock < self.game_description.capacity / (2 * self.game_description.n_players):
            if np.any(greedy_opponents):
                return Action.D
            else:
                return Action.C
        if self.game_description.capacity < 50 * self.game_description.n_players:
            threshold = self.game_description.capacity / (2 * self.game_description.n_players)
            if state.current_stock >= threshold:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_554(BaseStrategy):
    """
    Exploitative Strategy: Adaptive Stock Raider.
    
    This strategy aims to maximize payoff by taking advantage of various opponent behaviors.
    It monitors the stock level and opponents' actions to adjust its decision-making.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if self.n_players % 2 == 0:
                return Action.C
            else:
                return Action.D
        avg_payoff = np.mean(history.opponent_payoffs[-1, :])
        if avg_payoff > 0.75 * state.current_stock / (2 * self.n_players):
            if history.my_payoffs[-1] < avg_payoff:
                return Action.D
            else:
                return Action.C
        if state.current_stock < 0.25 * self.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            if state.current_stock > 0.5 * self.capacity:
                return Action.D
            else:
                return Action.C
        return Action.C

class Strategy_EXPLOITATIVE_555(BaseStrategy):
    """
    The Adaptive Exploiter (AE) strategy balances short-term gains with long-term sustainability,
    adapting to various opponent behaviors and game states.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_round = 0
        self.stock_level = game_description.capacity
        self.opponent_actions = []
        self.my_payoffs = []

    def classify_opponents(self, opponent_actions):
        """Classify opponents based on their past actions."""
        return np.array([action[-1] for action in opponent_actions])

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        self.current_round = state.round_number
        self.stock_level = state.current_stock
        if self.current_round == 0:
            return Action.C
        elif self.current_round <= 5:
            if self.stock_level > 0.75 * self.game_description.capacity:
                return Action.D
            elif 0.5 * self.game_description.capacity <= self.stock_level <= 0.75 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D
        elif self.current_round <= 15:
            if history:
                opponent_actions = [history.my_actions] + list(history.opponent_actions.T)
                classifications = self.classify_opponents(opponent_actions)
                for i, classification in enumerate(classifications):
                    if classification:
                        return Action.D
                    else:
                        return Action.C
        elif self.stock_level > 0.25 * self.game_description.capacity:
            return Action.D
        else:
            return Action.C

class Strategy_EXPLOITATIVE_556(BaseStrategy):
    """
    Adaptive Exploiter (AE) strategy.
    
    This strategy focuses on exploiting opponents with low cooperation ratios 
    while conserving stock for future rounds. By adapting to changing circumstances 
    and opponent behaviors, AE aims to maximize its payoffs in the tournament 
    against various independent strategies.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_CRs = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_CRs = np.mean(history.opponent_actions, axis=0)
        self.opponent_CRs = opponent_CRs if self.opponent_CRs is None else (self.opponent_CRs * (state.round_number - 1) + opponent_CRs) / state.round_number
        if state.current_stock > 0.75 * self.game_description.capacity and np.any(self.opponent_CRs < 0.5):
            return Action.D
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.round_number == self.game_description.n_rounds - 2:
            if np.mean(self.opponent_CRs > 0.5) > 0.5:
                return Action.C
            else:
                return Action.D
        if np.any(self.opponent_CRs < 0.2):
            opponent_defector = np.where(self.opponent_CRs < 0.2)[0][0]
            return Action.D if history.opponent_actions[-1, opponent_defector] else Action.C
        return Action.C

class Strategy_EXPLOITATIVE_557(BaseStrategy):
    """
    Robust and adaptive exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_defection_rates = []
        self.stock_trend = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        opponents_defected = sum((1 for action in history.opponent_actions[-1, :] if not action))
        self.opponent_defection_rates.append(opponents_defected >= self.game_description.n_players / 2)
        if len(self.stock_trend) > 0:
            trend = state.current_stock - self.stock_trend[-1]
            self.stock_trend.append(state.current_stock)
        else:
            self.stock_trend.append(state.current_stock)
        if stock_level > 0.5:
            return Action.D
        elif 0.25 <= stock_level <= 0.5:
            if opponents_defected >= self.game_description.n_players / 2:
                return Action.C
            else:
                return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_558(BaseStrategy):
    """
    Exploitative Strategy: "Adaptive Stock Guardian"
    
    This strategy balances short-term gains with long-term sustainability of the common pool resource, 
    while adapting to opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        n_rounds = self.game_description.n_rounds
        if state.round_number == 0 or history is None:
            return Action.C if state.current_stock < 0.75 * capacity else Action.D
        avg_consumption_prev = np.mean(state.current_stock - history.my_payoffs[-1])
        if state.round_number > 0 and state.round_number < n_rounds - 1:
            opponent_coop_rate = np.mean(history.opponent_actions[-3:, :]) if state.round_number >= 3 else np.mean(history.opponent_actions[:, :])
            threshold = 0.6
            if state.current_stock < 0.5 * capacity:
                threshold = 0.4
            elif state.current_stock > 0.75 * capacity:
                threshold = 0.8
            return Action.C if avg_consumption_prev > 0.5 * state.current_stock or opponent_coop_rate > threshold else Action.D
        return Action.D

class Strategy_EXPLOITATIVE_559(BaseStrategy):
    """
    An exploitative strategy that balances short-term gains with long-term sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.theta = 0.5 * self.capacity / self.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        S = state.current_stock
        r = self.game_description.n_rounds
        t = state.round_number
        if S < self.theta or r - t + 1 <= 2:
            return Action.D
        elif history and self.opponents_have_consistently_cooperated(history):
            return Action.D
        return Action.C

    def opponents_have_consistently_cooperated(self, history: PlayerHistory) -> bool:
        opponent_actions = history.opponent_actions[:, :]
        recent_rounds = opponent_actions[-3:, :]
        cooperators = np.sum(recent_rounds)
        return cooperators >= (self.n_players - 1) * 2

    def stock_depletion(self, state: CommonPoolState) -> bool:
        S = state.current_stock
        return S < 0.2 * self.capacity

class Strategy_EXPLOITATIVE_560(BaseStrategy):
    """
    The Adaptive Stock Hawk strategy is designed to exploit a wide range of opponent behaviors 
    while adapting to the dynamic state of the common pool resource game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / 4

    def calculate_previous_round_growth(self, current_stock, previous_stock):
        remaining_stock = previous_stock - previous_stock / (2 * self.game_description.n_players) * sum([1 if action else 0 for action in [Action.C] + list((Action.D for _ in range(self.game_description.n_players - 1)))])
        growth = 2 * remaining_stock * (1 - remaining_stock / self.game_description.capacity)
        return growth

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or state.current_stock == 0:
            return Action.C
        elif state.round_number + 1 == self.game_description.n_rounds:
            return Action.D
        else:
            previous_round_actions = history.opponent_actions[-1, :]
            opponents_cooperated = sum([action for action in previous_round_actions])
            previous_stock = state.current_stock + state.current_stock / (2 * self.game_description.n_players) * (1 if Action.C else 0)
            prev_growth = self.calculate_previous_round_growth(state.current_stock, previous_stock)
            if state.current_stock < self.stock_threshold:
                return Action.C
            elif prev_growth < self.game_description.capacity / 10:
                return Action.D
            elif opponents_cooperated >= self.game_description.n_players // 2:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_561(BaseStrategy):
    """
    An exploitative strategy that adapts to the game's state and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.num_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = history.opponent_actions[-1]
        my_previous_action = bool(history.my_actions[-1])
        total_consumption = sum(opponent_actions) * self.capacity / self.num_players + self.capacity / (2 * self.num_players) if my_previous_action else self.capacity / self.num_players
        if state.current_stock < 0.1 * self.capacity:
            return Action.C
        elif state.current_stock > 0.75 * self.capacity:
            return Action.D
        elif total_consumption <= self.capacity / 2:
            return Action.D
        else:
            if my_previous_action and opponent_actions.sum() >= self.num_players // 2:
                return Action.C
            return Action.D

class Strategy_EXPLOITATIVE_562(BaseStrategy):
    """
    Exploitative strategy adapting to opponents' behaviors and maximizing individual payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_status_history = []
        self.opponent_cooperation_rates = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_coop_rate = np.mean(history.opponent_actions[-1, :])
        self.stock_status_history.append(state.current_stock)
        self.opponent_cooperation_rates.append(avg_coop_rate)
        stock_status = 'high' if state.current_stock > 0.75 * self.game_description.capacity else 'low'
        if stock_status == 'high' and avg_coop_rate > 0.5:
            return Action.C
        elif stock_status == 'low' or avg_coop_rate < 0.5:
            return Action.D
        for opponent_actions in history.opponent_actions.T:
            if all(opponent_actions[-2:]) and state.current_stock > 0.75 * self.game_description.capacity:
                return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if avg_coop_rate == 0.5 or (len(self.opponent_cooperation_rates) > 2 and all((coop_rate == self.opponent_cooperation_rates[-1] for coop_rate in self.opponent_cooperation_rates[-3:]))):
            return random.choice([Action.C, Action.D])
        return Action.D

class Strategy_EXPLOITATIVE_563(BaseStrategy):
    """
    Exploitative strategy that adapts to the game state and opponents' behavior.
    Cooperates in the initial round, exploits high stock levels, uses mixed strategies 
    in moderate situations, conserves resources when the stock is low, and maximizes 
    final-round payoffs by defecting.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        elif state.current_stock > 0.75 * self.game_description.capacity:
            return Action.D
        elif 0.25 * self.game_description.capacity <= state.current_stock <= 0.75 * self.game_description.capacity:
            p = (state.current_stock / self.game_description.capacity) ** 2
            if random.random() < p:
                return Action.C
            else:
                return Action.D
        elif state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_564(BaseStrategy):
    """
    Adaptive Stock Defender (ASD) strategy.

    ASD aims to balance short-term gains with long-term sustainability by adapting to the game's state and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        opponent_behaviors = np.sum(history.opponent_actions, axis=1)
        if history.my_actions.size < 5:
            return Action.C
        elif 0.25 <= stock_level < 0.75:
            recent_opponent_behaviors = history.opponent_actions[-1]
            defectors = np.sum(recent_opponent_behaviors == False)
            if defectors >= self.game_description.n_players // 2:
                return Action.D
            else:
                return Action.C
        elif stock_level < 0.25 or state.round_number > self.game_description.n_rounds - 5:
            recent_opponent_behaviors = history.opponent_actions[-1]
            defectors = np.sum(recent_opponent_behaviors == False)
            if defectors >= self.game_description.n_players // 2:
                return Action.D
            else:
                return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_565(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that balances individual gain with sustainability concerns while adapting to opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.consecutive_d_count = 0
        self.consecutive_c_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.25 * self.game_description.capacity:
            return Action.D
        opponent_behaviors = history.opponent_actions[-1, :]
        majority_behavior = np.mean(opponent_behaviors)
        if majority_behavior > 0.5:
            self.consecutive_c_count += 1
            self.consecutive_d_count = 0
            if stock_level < 0.75:
                return Action.C
        else:
            self.consecutive_d_count += 1
            self.consecutive_c_count = 0
            if self.consecutive_d_count > 1 and state.current_stock < 0.5 * self.game_description.capacity:
                return Action.D
        if stock_level > 0.75:
            return Action.D
        elif stock_level >= 0.5:
            return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_566(BaseStrategy):
    """
    A dynamic and responsive strategy designed to exploit various opponent behaviors while maximizing its own payoffs.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_profiles = [0] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if state.current_stock >= self.game_description.capacity * 0.75 else Action.D
        cooperate = False
        if state.current_stock < self.game_description.capacity * 0.25:
            cooperate = True
        elif state.current_stock >= self.game_description.capacity * 0.75:
            cooperate = True
        if state.round_number <= 5:
            for opponent, action in enumerate(history.opponent_actions[-1, :]):
                if action:
                    self.opponent_profiles[opponent] += 1
        if sum(self.opponent_profiles) > len(self.opponent_profiles) // 2:
            cooperate = True
        if state.round_number >= self.game_description.n_rounds // 2:
            cooperate = False
        if state.round_number == self.game_description.n_rounds - 1:
            cooperate = False
        return Action.C if cooperate else Action.D

class Strategy_EXPLOITATIVE_567(BaseStrategy):
    """
    A strategy that balances short-term gains with long-term sustainability by adapting to opponent behavior and stock levels.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_cooperation_rates = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        cooperation_rate = np.mean(opponent_actions)
        self.opponent_cooperation_rates.append(cooperation_rate)
        avg_opponent_cr = np.mean(self.opponent_cooperation_rates)
        if avg_opponent_cr > 0.5:
            threshold_high = 0.8 * self.game_description.capacity
            threshold_low = 0.6 * self.game_description.capacity
        else:
            threshold_high = 0.75 * self.game_description.capacity
            threshold_low = 0.5 * self.game_description.capacity
        if state.current_stock > threshold_high:
            return Action.D
        elif threshold_low <= state.current_stock / self.game_description.capacity < threshold_high:
            return Action.C
        elif state.current_stock / self.game_description.capacity < threshold_low:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_568(BaseStrategy):
    """
    The Adaptive Stock Exploiter (ASE) strategy, which combines elements of adaptive play,
    exploitative behavior, and edge-case handling to maximize payoffs in a wide range of scenarios.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_consistent_cooperators = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        capacity = self.game_description.capacity
        S = state.current_stock
        if history is not None and history.opponent_actions.shape[0] > 1:
            recent_opponent_actions = history.opponent_actions[-2:, :]
            consistent_cooperators = np.all(recent_opponent_actions == True, axis=0)
            self.opponent_consistent_cooperators = np.any(consistent_cooperators)
        if S > 0.75 * capacity:
            return Action.D
        elif 0.25 * capacity <= S <= 0.75 * capacity:
            if self.opponent_consistent_cooperators:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_569(BaseStrategy):
    """
    Exploitative strategy that adapts to the dynamic state of the common pool resource game.
    Balances short-term gains with long-term sustainability to maximize total payoff over multiple rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_threshold = game_description.capacity / (2 * game_description.n_players)
        self.consumption_threshold = 0.7 * game_description.capacity

    def calculate_opponent_cooperation_rates(self, history: PlayerHistory) -> NDArray[np.float64]:
        opponent_cooperation_rates = np.zeros(self.game_description.n_players - 1, dtype=np.float64)
        for i, opponent_actions in enumerate(history.opponent_actions.T):
            cooperation_count = np.sum(opponent_actions)
            total_rounds = len(opponent_actions)
            opponent_cooperation_rates[i] = cooperation_count / total_rounds
        return opponent_cooperation_rates

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D
        if state.current_stock > self.stock_threshold:
            return Action.C
        opponent_cooperation_rates = self.calculate_opponent_cooperation_rates(history)
        for opponent in range(self.game_description.n_players - 1):
            if opponent_cooperation_rates[opponent] < 0.5:
                return Action.D
        previous_total_consumption = np.sum(np.where(history.my_actions[-1], state.current_stock / (2 * self.game_description.n_players), state.current_stock / self.game_description.n_players) + np.where(history.opponent_actions[-1, :], state.current_stock / (2 * self.game_description.n_players), state.current_stock / self.game_description.n_players))
        if previous_total_consumption > self.consumption_threshold:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_570(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game.
    Adapts to the game's state and history, balancing individual gain with sustainability.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.total_consumption = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        ei = self.total_consumption / self.game_description.capacity / (self.game_description.n_players * (state.round_number + 1))
        my_previous_action = history.my_actions[-1]
        opponent_actions = history.opponent_actions[-1, :]
        self.total_consumption += state.current_stock / self.game_description.n_players * (my_previous_action or np.any(opponent_actions))
        if ei >= 0.7:
            return Action.D
        elif 0.4 <= ei < 0.7:
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_571(BaseStrategy):
    """
    Adaptive Exploiter strategy for the Common Pool Resource Game.
    
    This strategy initially cooperates to gather information about opponents' behavior, 
    then adapts by exploiting cooperative opponents and punishing defectors. It also 
    adjusts its strategy based on the current stock level to avoid depletion.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.current_strategy = Action.C
        self.opponent_behavior = []
        self.stock_threshold = game_description.capacity * 0.5

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_payoffs = np.mean(history.opponent_payoffs[-1, :], axis=0)
        avg_opponent_payoff = np.mean(opponent_payoffs)
        max_possible_payoff = state.current_stock / (2 * self.game_description.n_players)
        threshold = 0.75 * max_possible_payoff
        is_cooperating = avg_opponent_payoff > threshold
        self.opponent_behavior.append(is_cooperating)
        if sum(self.opponent_behavior) >= len(self.opponent_behavior) / 2:
            self.current_strategy = Action.D
        elif np.any(history.opponent_actions[-1, :] == False):
            self.current_strategy = Action.C
        elif state.current_stock < self.stock_threshold:
            if state.current_stock < 0.25 * self.game_description.capacity:
                self.current_strategy = Action.D
            else:
                self.current_strategy = Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            self.current_strategy = Action.D
        return self.current_strategy

class Strategy_EXPLOITATIVE_572(BaseStrategy):
    """
    Exploitative strategy that aims to maximize individual payoffs by adaptively responding 
    to the current stock level, opponent actions, and game history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.D if state.current_stock >= 0.75 * self.game_description.capacity else Action.C
        prev_round_opponent_actions = history.opponent_actions[-1]
        avg_opponent_consumption = np.mean(prev_round_opponent_actions) * state.current_stock / self.game_description.n_players
        cooperative_threshold = state.current_stock / (2 * self.game_description.n_players)
        if state.current_stock < 0.25 * self.game_description.capacity:
            return Action.C
        if state.current_stock >= 0.5 * self.game_description.capacity and avg_opponent_consumption < cooperative_threshold:
            return Action.C
        elif state.current_stock >= 0.25 * self.game_description.capacity:
            return Action.D
        if state.round_number == self.game_description.n_rounds and state.current_stock >= 0.5 * self.game_description.capacity:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_573(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors and maximizes payoff.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.prev_payoff = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        avg_payoff = np.mean(history.my_payoffs)
        if self.prev_payoff is None:
            self.prev_payoff = history.my_payoffs[0]
        mid_game_adjustment_round = math.ceil(self.game_description.n_rounds / 2)
        if state.round_number < mid_game_adjustment_round:
            if self.prev_payoff >= avg_payoff:
                return Action.C
            else:
                return Action.D
        stock_ratio = state.current_stock / self.game_description.capacity
        if stock_ratio > 0.75:
            if self.prev_payoff >= avg_payoff:
                return Action.C
            else:
                return Action.D
        elif stock_ratio >= 0.5:
            prev_action = history.my_actions[-1]
            if self.prev_payoff < avg_payoff or prev_action == False:
                return Action.D
            else:
                return Action.C
        else:
            return Action.D
        end_game_rounds = self.game_description.n_rounds - 2
        if state.round_number >= end_game_rounds:
            return Action.D
        self.prev_payoff = history.my_payoffs[-1]

class Strategy_EXPLOITATIVE_574(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.C_count = 0
        self.D_count = 0
        self.C_avg_payoff = 0
        self.D_avg_payoff = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number < 2:
            return Action.C
        if state.current_stock >= 0.75 * self.game_description.capacity:
            action = Action.C
        else:
            action = Action.D
        if history is not None:
            opponent_actions = history.opponent_actions[-1, :]
            self.C_count = np.sum(opponent_actions)
            self.D_count = self.game_description.n_players - 1 - self.C_count
            C_payoffs = history.opponent_payoffs[-1, opponent_actions]
            D_payoffs = history.opponent_payoffs[-1, ~opponent_actions]
            if len(C_payoffs) > 0:
                self.C_avg_payoff = np.mean(C_payoffs)
            else:
                self.C_avg_payoff = 0
            if len(D_payoffs) > 0:
                self.D_avg_payoff = np.mean(D_payoffs)
            else:
                self.D_avg_payoff = 0
        if self.C_count > self.D_count and self.C_avg_payoff > self.D_avg_payoff:
            action = Action.C
        elif self.C_count < self.D_count or self.C_avg_payoff < self.D_avg_payoff:
            action = Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return action

class Strategy_EXPLOITATIVE_575(BaseStrategy):
    """
    The Adaptive Stock Raider (ASR) strategy is designed to exploit a wide range of opponent behaviors 
    while adapting to changing game conditions. ASR balances short-term gains with long-term sustainability, 
    aiming to maximize total payoff over the game's multiple rounds.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if state.current_stock > 0.8 * self.game_description.capacity:
                return Action.C
            else:
                return Action.D

        def calculate_total_consumption(previous_round: PlayerHistory):
            total_payoff = np.sum(previous_round.opponent_payoffs[-1, :] + previous_round.my_payoffs[-1])
            total_consumption = total_payoff * self.game_description.n_players / self.game_description.capacity
            return total_consumption

        def estimate_defectors(previous_round: PlayerHistory):
            opponent_actions = np.logical_not(previous_round.opponent_actions[-1, :])
            defectors = np.sum(opponent_actions)
            return defectors
        stock_depletion = calculate_total_consumption(history)
        opponent_behavior = estimate_defectors(history)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.2 * self.game_description.capacity:
            return Action.C
        elif opponent_behavior > 0.7 * self.game_description.n_players:
            return Action.D
        elif stock_depletion > 0.5 * self.game_description.capacity and opponent_behavior < 0.3 * self.game_description.n_players:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_576(BaseStrategy):
    """
    The Adaptive Exploiter strategy aims to maximize its total payoff by adaptively responding 
    to the game state and history of opponent actions. It balances cooperation and defection to 
    exploit opponents' tendencies while avoiding over-exploitation, which could lead to mutual destruction.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_history = history.opponent_actions
        current_stock = state.current_stock
        threshold = 0.5 if current_stock > 0.75 * self.capacity else 0.25
        opponent_cr = []
        for player in range(self.n_players - 1):
            cr = np.mean(opponent_history[:, player])
            opponent_cr.append(cr)
        actions = []
        for i, cr in enumerate(opponent_cr):
            if cr < threshold:
                actions.append(Action.D)
            else:
                actions.append(Action.C)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif current_stock <= 0.25 * self.capacity:
            return Action.C
        elif all(opponent_history[-1, :]):
            return Action.C
        if actions:
            return actions[0]
        return Action.D

class Strategy_EXPLOITATIVE_577(BaseStrategy):
    """
    An exploitative strategy that adapts to the current state and history of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.recently_switched_to_C = False

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        if state.round_number <= 5:
            _ = self._calculate_opponents_ACR(history)
            return Action.C
        stock_threshold = 0.75 * self.game_description.capacity
        if state.current_stock >= stock_threshold and self._most_opponents_ACR_below_threshold(history, threshold=0.4):
            self.recently_switched_to_C = False
            return Action.D
        if not self.recently_switched_to_C or state.round_number > 0.8 * self.game_description.n_rounds:
            self.recently_switched_to_C = False
            return Action.D
        self.recently_switched_to_C = True
        return Action.C

    def _calculate_opponents_ACR(self, history: PlayerHistory) -> float:
        opponent_actions = history.opponent_actions[:, :]
        opponents_ACR = np.mean(opponent_actions, axis=0)
        return opponents_ACR

    def _most_opponents_ACR_below_threshold(self, history: PlayerHistory, threshold: float) -> bool:
        opponents_ACR = self._calculate_opponents_ACR(history)
        below_threshold_count = np.sum(opponents_ACR < threshold)
        most_opponents_below_threshold = below_threshold_count >= (self.game_description.n_players - 1) // 2
        return most_opponents_below_threshold

class Strategy_EXPLOITATIVE_578(BaseStrategy):
    """
    Exploitative strategy that adapts to the dynamic state of the game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_defected = np.sum(history.opponent_actions[-1, :]) < self.n_players
        stock_ratio = state.current_stock / self.capacity
        if stock_ratio > 0.75:
            if opponents_defected:
                return Action.D
            else:
                return Action.C
        elif 0.25 <= stock_ratio <= 0.75:
            p = (1 - stock_ratio) * (np.sum(history.opponent_actions[-1, :]) / self.n_players)
            return Action.D if random.random() < p else Action.C
        elif state.round_number > 0.75 * self.game_description.n_rounds and stock_ratio <= 0.25:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.C if np.all(history.opponent_actions[-1, :] == True) else Action.D

class Strategy_EXPLOITATIVE_579(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behavior in a Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        round_number = state.round_number
        current_stock = state.current_stock
        if round_number == 0 or history is None:
            return Action.C
        opponent_payoffs = history.opponent_payoffs[-1, :]
        avg_opponent_payoff = np.mean(opponent_payoffs)
        adaptive_threshold = capacity / (2 * n_players) * (1 - (round_number + 1 - 1) / round_number)
        if current_stock > adaptive_threshold and avg_opponent_payoff < current_stock / (2 * n_players):
            return Action.C
        elif round_number == self.game_description.n_rounds - 1:
            return Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_580(BaseStrategy):
    """
    Exploitative strategy that adapts to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.coop_threshold = 0.75

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C if state.current_stock >= self.game_description.capacity * self.coop_threshold else Action.D
        avg_coop_rate = sum((1 for actions in history.opponent_actions[:state.round_number] for action in actions if action)) / (self.game_description.n_players - 1)
        if state.current_stock < self.game_description.capacity * 0.2:
            self.coop_threshold = 0
        elif history.my_payoffs[state.round_number - 1] > 0 and state.current_stock / self.game_description.capacity - history.my_payoffs[state.round_number - 1] / self.game_description.n_players < -0.2:
            self.coop_threshold -= 0.1
        else:
            self.coop_threshold += 0.05
            self.coop_threshold = min(self.coop_threshold, 0.75)
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C if avg_coop_rate >= self.coop_threshold else Action.D

class Strategy_EXPLOITATIVE_581(BaseStrategy):
    """
    An exploitative strategy that adapts to changing game conditions and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        if state.round_number >= self.game_description.n_rounds - 1:
            return Action.D
        current_stock = state.current_stock
        if current_stock < 0.1 * self.capacity:
            return Action.C
        elif current_stock > 0.75 * self.capacity:
            return Action.D
        opponent_cooperation_rates = np.mean(history.opponent_actions, axis=0)
        acr = np.mean(opponent_cooperation_rates)
        if acr > 0.5:
            return Action.C if random.random() < 0.7 else Action.D
        else:
            return Action.D if random.random() < 0.7 else Action.C

class Strategy_EXPLOITATIVE_582(BaseStrategy):
    """
    Adaptive Exploitation with Stock-Based Threshold (AEST) strategy.
    Cooperates initially to gather information, then uses a stock-based threshold and opponent behavior analysis to decide actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.opponent_CRs = [0] * game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number <= 3:
            return Action.C
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        T = capacity * (1 - (n_players - 1) / n_players)
        if state.current_stock > T:
            return Action.C
        if history is not None:
            for i, actions in enumerate(history.opponent_actions.T):
                self.opponent_CRs[i] = actions.sum() / len(actions)
            COP_count = sum((1 for CR in self.opponent_CRs[1:] if CR >= 0.5))
            DEF_count = n_players - 1 - COP_count
            if COP_count >= DEF_count:
                return Action.C
            else:
                return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.2 * capacity:
            return Action.D
        if n_players == 1:
            if self.opponent_CRs[0] >= 0.5:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_583(BaseStrategy):
    """
    The Adaptive Stockpiler strategy maximizes its own payoff by adaptively responding to 
    the current state of the game and the actions of other players.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.round_consumption_history = []
        self.stock_growth_history = []

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            if state.current_stock >= self.game_description.capacity * 0.9:
                return Action.C
            else:
                return Action.D
        avg_consumption = np.mean(self.round_consumption_history)
        avg_stock_growth = np.mean(self.stock_growth_history)
        total_consumption = sum((1 if action else self.game_description.capacity / self.game_description.n_players for action in history.opponent_actions[-1, :]))
        total_consumption += 1 if history.my_actions[-1] else self.game_description.capacity / self.game_description.n_players
        self.round_consumption_history.append(total_consumption)
        stock_growth = min(self.game_description.capacity, state.current_stock + 2 * (state.current_stock - total_consumption) * (1 - (state.current_stock - total_consumption) / self.game_description.capacity))
        self.stock_growth_history.append(stock_growth)
        if state.current_stock > self.game_description.capacity / 2 and avg_consumption is not None and (avg_consumption > self.game_description.capacity / self.game_description.n_players):
            return Action.C
        elif state.current_stock < self.game_description.capacity / 4 or (avg_stock_growth is not None and avg_stock_growth < 0):
            return Action.D
        opponents_actions = history.opponent_actions[-1, :]
        majority_played_C = sum((1 for action in opponents_actions if action)) >= self.game_description.n_players // 2
        if majority_played_C:
            return Action.D
        elif not majority_played_C and state.current_stock > self.game_description.capacity / 2:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        opponent_actions_counts = np.sum(history.opponent_actions, axis=0)
        for i, count in enumerate(opponent_actions_counts):
            if count >= len(self.stock_growth_history) // 2:
                return Action.D
            elif count < len(self.stock_growth_history) // 4:
                if state.current_stock > self.game_description.capacity / 2:
                    return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_584(BaseStrategy):
    """
    An exploitative strategy designed to maximize payoffs by adapting to changing game conditions and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C if self.game_description.n_players % 2 == 0 else Action.D
        stock_fraction = state.current_stock / self.game_description.capacity
        if state.round_number < self.game_description.n_rounds - 1:
            if stock_fraction > 0.75:
                return Action.D
            elif 0.25 <= stock_fraction <= 0.75:
                cooperation_probability = stock_fraction ** (1 / self.game_description.n_players)
                return Action.C if random.random() < cooperation_probability else Action.D
            else:
                return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_585(BaseStrategy):
    """
    Exploitative strategy that adapts to opponents' behavior and stock levels.
    Cooperates initially, defects when stock is high, cooperates if majority of opponents defected previously,
    and defects in the last round.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        previous_opponent_actions = history.opponent_actions[-1, :]
        majority_defectors = sum(previous_opponent_actions) >= len(previous_opponent_actions) / 2
        if state.current_stock >= 0.75 * self.capacity:
            return Action.D
        elif state.current_stock >= 0.25 * self.capacity and (not majority_defectors):
            return Action.C
        else:
            return Action.D
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_586(BaseStrategy):
    """
    An adaptive exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players
        self.threshold_75 = 0.75 * self.capacity
        self.threshold_50 = 0.5 * self.capacity
        self.stock_depletion_rate = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        total_depletion = self.capacity - state.current_stock
        rounds_played = state.round_number + 1
        self.stock_depletion_rate = total_depletion / rounds_played
        adjusted_threshold_75 = max(self.threshold_75 * (1 - self.stock_depletion_rate), 0)
        adjusted_threshold_50 = max(self.threshold_50 * (1 - self.stock_depletion_rate), 0)
        opponents_defected = sum([not opp_action for opp_action in history.opponent_actions[-1, :]])
        most_cooperated = sum(history.opponent_actions[-1, :]) > self.n_players / 2
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock >= adjusted_threshold_75:
            return Action.D if opponents_defected else Action.C
        elif adjusted_threshold_50 <= state.current_stock < adjusted_threshold_75:
            return Action.C if most_cooperated else Action.D
        else:
            return Action.D

class Strategy_EXPLOITATIVE_587(BaseStrategy):
    """
    Exploitative strategy that adapts to the current stock level, opponent behavior, and round number.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        depletion_rate = state.current_stock / self.game_description.capacity
        if history:
            opponent_defection_rate = np.mean(1 - history.opponent_actions[-1, :])
            if opponent_defection_rate > 0.5:
                return Action.C
        if state.round_number > 0.7 * self.game_description.n_rounds:
            return Action.C
        if depletion_rate >= 0.5 and depletion_rate < 0.8:
            return Action.C
        return Action.D

class Strategy_EXPLOITATIVE_588(BaseStrategy):
    """
    Adaptive Exploiter strategy for the Common Pool Resource Game.
    Balances cooperation and defection based on game state and history,
    aiming to maximize payoffs while adapting to changing opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        t = state.round_number
        S = state.current_stock
        if t == 0:
            return Action.C
        elif t < self.game_description.n_rounds / 2:
            if S > 0.75 * self.capacity:
                return Action.D
            else:
                return Action.C
        elif t >= self.game_description.n_rounds / 2:
            avg_payoff = np.mean(history.my_payoffs) if history is not None else 0
            max_payoff = S / (2 * self.n_players)
            if avg_payoff > 0.5 * max_payoff:
                return Action.C if history.my_actions[-1] else Action.D
            else:
                return Action.D if history.my_actions[-1] else Action.C
        elif t > 3 * self.game_description.n_rounds / 4:
            if S < 0.25 * self.capacity:
                return Action.C
            else:
                return Action.D
        elif S < 0.1 * self.capacity:
            return Action.C
        else:
            return Action.C

class Strategy_EXPLOITATIVE_589(BaseStrategy):
    """
    Adaptive Exploiter strategy for the Common Pool Resource Game.
    This strategy balances short-term gains with long-term sustainability,
    adapting to the game's state and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        current_stock = state.current_stock
        capacity = self.game_description.capacity
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if current_stock > 0.8 * capacity:
            return Action.D
        elif current_stock < 0.4 * capacity:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        RC_D = np.mean(opponent_actions)
        if RC_D > 0.5:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_590(BaseStrategy):
    """
    Exploitative strategy that aims to maximize its own payoff by adaptively responding 
    to the game state and opponent behavior, balancing short-term gains with long-term 
    sustainability of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.defect_threshold = 0.75 * game_description.capacity

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponents_defected = sum((1 for action in history.opponent_actions[-1, :] if not action))
        if opponents_defected > self.game_description.n_players / 2:
            self.defect_threshold = 0.9 * self.game_description.capacity
        elif opponents_defected < self.game_description.n_players / 2:
            self.defect_threshold = 0.6 * self.game_description.capacity
        current_stock = state.current_stock
        if current_stock > self.defect_threshold:
            return Action.D
        elif current_stock >= 0.5 * self.game_description.capacity:
            return Action.C
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if current_stock < 0.25 * self.game_description.capacity:
            return Action.C

class Strategy_EXPLOITATIVE_591(BaseStrategy):
    """
    The Adaptive Stock Raider (ASR) strategy is designed to maximize payoffs by adaptively exploiting the common pool resource game's dynamics and opponent behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        n_players = self.game_description.n_players
        capacity = self.game_description.capacity
        current_stock = state.current_stock
        if state.round_number <= 2:
            return Action.C
        elif 2 < state.round_number < self.game_description.n_rounds - 2:
            if current_stock > 0.75 * capacity:
                return Action.D
            elif current_stock < 0.25 * capacity:
                return Action.C
            else:
                p_C = (current_stock / capacity) ** 2
                return Action.C if random.random() < p_C else Action.D
        else:
            return Action.D

    def analyze_opponent_actions(self, opponent_actions):
        cooperation_rate = np.mean(opponent_actions == True)
        return cooperation_rate

    def assess_stock_growth(self, current_stock, capacity):
        growth_rate = 2 * current_stock * (1 - current_stock / capacity)
        return growth_rate

class Strategy_EXPLOITATIVE_592(BaseStrategy):
    """
    Adaptive Exploiter strategy for Common Pool Resource Game.
    
    This strategy balances short-term payoff maximization with long-term sustainability by adapting to opponents' behavior and the current state of the common pool resource.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.avg_coop_rate = 0.5

    def update_stock(self, stock, n, capacity, action):
        consumption_per_player = stock / (2 * n) if action == Action.C else stock / n
        total_consumption = consumption_per_player
        remaining_stock = stock - total_consumption
        growth = 2 * remaining_stock * (1 - remaining_stock / capacity)
        new_stock = min(remaining_stock + growth, capacity)
        return new_stock

    def estimate_opponent_cooperation(self, n, capacity, stock):
        if self.avg_coop_rate > 0.7:
            return 0.8
        elif self.avg_coop_rate < 0.3:
            return 0.2
        else:
            return self.avg_coop_rate

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.avg_coop_rate = 0.5
            return Action.C
        action = None
        if state.round_number < self.game_description.n_rounds // 2:
            opponent_actions = history.opponent_actions[-1, :]
            avg_coop_rate = np.mean(opponent_actions)
            self.avg_coop_rate = (self.avg_coop_rate + avg_coop_rate) / 2
            action = Action.D if self.avg_coop_rate > 0.5 else Action.C
        elif state.current_stock < 0.5 * self.game_description.capacity:
            action = Action.D
        elif history.opponent_actions[-1, :].mean() > 0.7:
            action = Action.D
        elif state.current_stock < 0.25 * self.game_description.capacity:
            opponent_coop_rate = history.opponent_actions[-1, :].mean()
            action = Action.C if opponent_coop_rate > 0.7 else Action.D
        else:
            action = Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            action = Action.D
        return action

class Strategy_EXPLOITATIVE_593(BaseStrategy):
    """
    Adaptive Stock Raider Strategy.
    
    This strategy adapts to the dynamic state of the game and exploits opponents' behavior by switching between Cooperate and Defect modes based on stock levels, opponent cooperation rates, and previous actions.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.C
        opponent_actions = history.opponent_actions[:-1]
        opponent_cooperations = np.sum(opponent_actions, axis=1)
        avg_cooperation_rate = np.mean(opponent_cooperations / self.game_description.n_players)
        if state.current_stock <= self.game_description.capacity / 2:
            return Action.D
        if avg_cooperation_rate >= 0.5:
            return Action.D
        else:
            return Action.C
        prev_stock = history.my_payoffs[-1] * 2 * self.game_description.n_players
        if state.current_stock > prev_stock or state.current_stock == prev_stock:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_594(BaseStrategy):
    """
    An exploitative strategy that adapts to the game's dynamic state and opponents' behaviors.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.cooperate_threshold = 0.75
        self.opponent_behavior = None

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0 or history is None:
            return Action.D
        opponent_actions = history.opponent_actions[-1, :]
        opponent_cooperation_rate = sum(opponent_actions) / self.game_description.n_players
        if opponent_cooperation_rate > 0.5:
            self.opponent_behavior = 'cooperative'
        elif opponent_cooperation_rate < 0.5:
            self.opponent_behavior = 'defective'
        if state.current_stock >= self.game_description.capacity * self.cooperate_threshold:
            return Action.C
        if self.opponent_behavior == 'cooperative':
            return Action.D
        elif self.opponent_behavior == 'defective':
            return Action.C
        else:
            return Action.D if state.current_stock < self.game_description.capacity * self.cooperate_threshold else Action.C

class Strategy_EXPLOITATIVE_595(BaseStrategy):
    """
    An exploitative strategy that adapts to the current stock level and opponents' behavior.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.capacity = game_description.capacity
        self.n_players = game_description.n_players

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choices([Action.C, Action.D], weights=[0.8, 0.2])[0]
        stock_level = state.current_stock / self.capacity
        if stock_level > 0.75:
            return random.choices([Action.D, Action.C], weights=[0.9, 0.1])[0]
        elif 0.5 <= stock_level < 0.75:
            return random.choices([Action.C, Action.D], weights=[0.5, 0.5])[0]
        else:
            return random.choices([Action.C, Action.D], weights=[0.9, 0.1])[0]
        if history is not None:
            for opponent_actions in history.opponent_actions.T:
                if sum(opponent_actions) > 2 / 3 * state.round_number:
                    return random.choices([Action.D, Action.C], weights=[0.9, 0.1])[0]
                elif sum(1 - opponent_actions) > 2 / 3 * state.round_number:
                    return random.choices([Action.C, Action.D], weights=[0.5, 0.5])[0]
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C

class Strategy_EXPLOITATIVE_596(BaseStrategy):
    """
    An exploitative strategy that adapts to changing conditions in the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.history = None

    def calculate_avg_defection_rate(self) -> float:
        if not self.history or len(self.history.my_actions) == 0:
            return 0.5
        defections = sum((1 for action in self.history.opponent_actions[:, 0] if action == False))
        total_actions = len(self.history.my_actions)
        return defections / (total_actions * self.game_description.n_players - 1)

    def update_history(self, action: bool, opponent_actions: NDArray[np.bool_], history: PlayerHistory):
        if not self.history:
            self.history = history
        else:
            self.history.my_actions = np.append(self.history.my_actions, action)
            self.history.opponent_actions = np.vstack((self.history.opponent_actions, opponent_actions))

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        self.update_history(False, history.opponent_actions[-1, :], history)
        avg_defection_rate = self.calculate_avg_defection_rate()
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        if state.current_stock < 0.5 * self.game_description.capacity:
            return Action.D
        elif avg_defection_rate > 0.5:
            return Action.D
        elif avg_defection_rate < 0.3:
            return Action.C
        else:
            prob_coop = 1 - avg_defection_rate
            if random.random() < prob_coop:
                return Action.C
            else:
                return Action.D

class Strategy_EXPLOITATIVE_597(BaseStrategy):
    """
    Adaptive Exploitation strategy for Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.n_players = game_description.n_players
        self.capacity = game_description.capacity
        self.coop_count = 0
        self.defect_count = 0

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return random.choice([Action.C, Action.D])
        avg_opponent_payoff = np.mean(history.opponent_payoffs[-1, :])
        S_prev = history.my_payoffs.size * self.capacity / (2 * self.n_players)
        total_consumption_prev = np.sum(history.opponent_payoffs[-1, :] + history.my_payoffs[-1])
        if avg_opponent_payoff > S_prev / (self.game_description.n_players // 2):
            cooperate_prob = 0.7
            defect_prob = 0.3
        else:
            cooperate_prob = 0.4
            defect_prob = 0.6
        self.coop_count += np.sum(history.opponent_actions[-1, :] == True)
        self.defect_count += np.sum(history.opponent_actions[-1, :] == False)
        if state.round_number >= 5:
            opponent_cooperation_ratio = self.coop_count / (self.coop_count + self.defect_count)
            if opponent_cooperation_ratio > 0.6:
                cooperate_prob += 0.1
                defect_prob -= 0.1
            elif opponent_cooperation_ratio <= 0.4:
                cooperate_prob -= 0.15
                defect_prob += 0.15
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < self.capacity / 4:
            cooperate_prob = 0.8
        if random.random() < cooperate_prob:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_598(BaseStrategy):
    """
    An exploitative strategy for the Common Pool Resource Game that adapts to various opponent behaviors and maximizes payoffs based on game parameters, state, and history.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.threshold = game_description.capacity / 2

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        opponent_actions = history.opponent_actions[-1, :]
        cooperators = sum(opponent_actions)
        defectors = len(opponent_actions) - cooperators
        if cooperators > self.game_description.n_players / 2:
            self.threshold *= 0.9
        elif defectors > self.game_description.n_players / 2:
            self.threshold *= 1.1
        if state.current_stock > self.threshold:
            return Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D

class Strategy_EXPLOITATIVE_599(BaseStrategy):
    """
    A robust and exploitative strategy for the Common Pool Resource Game.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description
        self.stock_depletion_history = []
        self.average_opponent_consumption = 0

    def calculate_average_opponent_consumption(self, history: PlayerHistory) -> float:
        total_stock_depletion = sum(self.stock_depletion_history)
        average_opponent_consumption = total_stock_depletion / (self.game_description.n_players - 1)
        return average_opponent_consumption

    def cooperation_threshold(self, current_stock_level: float, average_opponent_consumption: float) -> float:
        capacity = self.game_description.capacity
        n_players = self.game_description.n_players
        ct = current_stock_level / capacity * (1 - average_opponent_consumption / (capacity / n_players))
        return ct

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            self.stock_depletion_history.append(0)
            return Action.C
        last_round_stock = self.game_description.capacity if state.round_number == 1 else history.my_payoffs[-2] * self.game_description.n_players + self.stock_depletion_history[-1]
        current_stock_depletion = last_round_stock - state.current_stock
        self.stock_depletion_history.append(current_stock_depletion)
        average_opponent_consumption = self.calculate_average_opponent_consumption(history)
        cooperation_threshold = self.cooperation_threshold(state.current_stock, average_opponent_consumption)
        if cooperation_threshold > 0.5:
            return Action.C
        elif state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        elif state.current_stock < 0.2 * self.game_description.capacity:
            return Action.C
        else:
            return Action.D

class Strategy_EXPLOITATIVE_600(BaseStrategy):
    """
    Exploitative strategy designed to maximize individual payoffs in the Common Pool Resource Game.
    Adapts to the game's state, history, and opponent behaviors while maintaining a robust and responsive decision-making process.
    """

    def __init__(self, game_description: CommonPoolDescription):
        self.game_description = game_description

    def __call__(self, state: CommonPoolState, history: None | PlayerHistory) -> Action:
        if state.round_number == 0:
            return Action.C
        stock_level = state.current_stock / self.game_description.capacity
        if stock_level > 0.75:
            return Action.D
        elif 0.5 <= stock_level <= 0.75:
            return Action.C if random.random() < 0.5 else Action.D
        else:
            return Action.C
        if state.round_number == self.game_description.n_rounds - 1:
            return Action.D
        return Action.C
